"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // node_modules/@iden3/js-iden3-core/dist/browser/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Blockchain: () => o,
    BytesHelper: () => R2,
    ChainIds: () => l2,
    Claim: () => P2,
    ClaimOptions: () => C,
    Constants: () => s,
    DID: () => Q2,
    DIDNetworkFlag: () => F,
    DidMethod: () => h3,
    DidMethodByte: () => u,
    DidMethodNetwork: () => d2,
    ElemBytes: () => B2,
    ErrSlotOverflow: () => M2,
    Flags: () => L2,
    Id: () => $2,
    IdPosition: () => U3,
    MerklizedFlag: () => v2,
    MerklizedRootPosition: () => V2,
    NetworkId: () => a2,
    Param: () => K,
    Parser: () => W2,
    SchemaHash: () => k2,
    SlotName: () => H,
    StringUtils: () => O,
    SubjectFlag: () => A,
    buildDIDType: () => G4,
    chainIDfromDID: () => rt,
    checkBigIntArrayInField: () => N2,
    checkBigIntInField: () => x2,
    encoder: () => I,
    findBlockchainForDIDMethodByValue: () => Y2,
    findDIDMethodByValue: () => j2,
    findNetworkIDForDIDMethodByValue: () => z2,
    fromBigEndian: () => E,
    fromLittleEndian: () => g,
    genesisFromEthAddress: () => T2,
    getChainId: () => et,
    getDateFromUnixTimestamp: () => p2,
    getUint32: () => m2,
    getUint64: () => S2,
    getUnixTimestamp: () => b2,
    idenState: () => D,
    initDIDParams: () => J,
    putUint32: () => w2,
    putUint64: () => _2,
    registerBlockchain: () => Z2,
    registerChainId: () => tt,
    registerDidMethod: () => X2,
    registerDidMethodNetwork: () => nt,
    registerNetwork: () => q2,
    toBigEndian: () => y2,
    toLittleEndian: () => f2
  });

  // node_modules/@iden3/js-crypto/dist/browser/esm/index.js
  var cI = Object.defineProperty;
  var DI = (G7, I5) => {
    for (var E4 in I5)
      cI(G7, E4, { get: I5[E4], enumerable: true });
  };
  var M = {};
  DI(M, { beBuff2int: () => ZI, beInt2Buff: () => WI, leBuff2int: () => pI, leInt2Buff: () => lI, unstringifyBigInts: () => d });
  var B = {};
  DI(B, { abs: () => fI, add: () => iI, band: () => KI, bitLength: () => f, bits: () => l, bor: () => TI, bxor: () => PI, div: () => P, e: () => nI, eq: () => aI, exp: () => bI, fromArray: () => wI, fromRprBE: () => z, fromRprLE: () => m, fromString: () => R, geq: () => RI, gt: () => xI, isNegative: () => MI, isOdd: () => p, isZero: () => Z, land: () => qI, leq: () => OI, lor: () => VI, lt: () => yI, mod: () => hI, mul: () => QI, naf: () => tI, neg: () => kI, neq: () => uI, one: () => w, pow: () => N, shiftLeft: () => sI, shiftRight: () => W, shl: () => UI, shr: () => eI, square: () => YI, sub: () => T, toArray: () => rI, toLEBuff: () => vI, toNumber: () => JI, toRprBE: () => X, toRprLE: () => q, toString: () => SI, zero: () => y });
  var BI = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
  var R = (G7, I5) => {
    if (!I5 || I5 === 10)
      return BigInt(G7);
    if (I5 === 16)
      return G7.slice(0, 2) == "0x" ? BigInt(G7) : BigInt("0x" + G7);
    throw new Error("Unsupported radix");
  };
  var nI = R;
  var wI = (G7, I5) => {
    let E4 = BigInt(0), A5 = BigInt(I5);
    for (let o4 = 0; o4 < G7.length; o4++)
      E4 = E4 * A5 + BigInt(G7[o4]);
    return E4;
  };
  var f = (G7) => {
    let I5 = G7.toString(16);
    return (I5.length - 1) * 4 + BI[parseInt(I5[0], 16)];
  };
  var MI = (G7) => BigInt(G7) < BigInt(0);
  var Z = (G7) => G7 === y;
  var sI = (G7, I5) => G7 << I5;
  var W = (G7, I5) => G7 >> I5;
  var UI = sI;
  var eI = W;
  var p = (G7) => (G7 & w) == w;
  var tI = (G7) => {
    let I5 = G7, E4 = [];
    for (; I5; ) {
      if (I5 & w) {
        let A5 = 2 - Number(I5 % BigInt(4));
        E4.push(A5), I5 = I5 - BigInt(A5);
      } else
        E4.push(0);
      I5 = I5 >> w;
    }
    return E4;
  };
  var l = (G7) => {
    let I5 = G7, E4 = [];
    for (; I5; )
      I5 & w ? E4.push(1) : E4.push(0), I5 = I5 >> w;
    return E4;
  };
  var JI = (G7) => {
    if (G7 > BigInt(Number.MAX_SAFE_INTEGER))
      throw new Error("Number too big");
    return Number(G7);
  };
  var rI = (G7, I5) => {
    let E4 = [], A5 = G7, o4 = I5;
    for (; A5; )
      E4.unshift(Number(A5 % o4)), A5 = A5 / o4;
    return E4;
  };
  var iI = (G7, I5) => G7 + I5;
  var T = (G7, I5) => G7 - I5;
  var kI = (G7) => -G7;
  var QI = (G7, I5) => G7 * I5;
  var YI = (G7) => G7 * G7;
  var N = (G7, I5) => G7 ** I5;
  var bI = (G7, I5) => G7 ** I5;
  var fI = (G7) => G7 >= 0 ? G7 : -G7;
  var P = (G7, I5) => G7 / I5;
  var hI = (G7, I5) => G7 % I5;
  var aI = (G7, I5) => G7 === I5;
  var uI = (G7, I5) => G7 !== I5;
  var yI = (G7, I5) => G7 < I5;
  var xI = (G7, I5) => G7 > I5;
  var OI = (G7, I5) => G7 <= I5;
  var RI = (G7, I5) => G7 >= I5;
  var KI = (G7, I5) => G7 & I5;
  var TI = (G7, I5) => G7 | I5;
  var PI = (G7, I5) => G7 ^ I5;
  var qI = (G7, I5) => G7 && I5;
  var VI = (G7, I5) => G7 || I5;
  var q = (G7, I5, E4, A5) => {
    let o4 = "0000000" + E4.toString(16), D4 = new Uint32Array(G7.buffer, G7.byteOffset + I5, A5 / 4), s3 = ((o4.length - 7) * 4 - 1 >> 5) + 1;
    for (let t = 0; t < s3; t++)
      D4[t] = parseInt(o4.substring(o4.length - 8 * t - 8, o4.length - 8 * t), 16);
    for (let t = s3; t < D4.length; t++)
      D4[t] = 0;
    for (let t = D4.length * 4; t < A5; t++)
      G7[t] = JI(KI(W(E4, BigInt(t * 8)), BigInt(255)));
  };
  var X = (G7, I5, E4, A5) => {
    let o4 = "0000000" + E4.toString(16), D4 = new DataView(G7.buffer, G7.byteOffset + I5, A5), s3 = ((o4.length - 7) * 4 - 1 >> 5) + 1;
    for (let t = 0; t < s3; t++)
      D4.setUint32(A5 - t * 4 - 4, parseInt(o4.substring(o4.length - 8 * t - 8, o4.length - 8 * t), 16), false);
    for (let t = 0; t < A5 / 4 - s3; t++)
      D4.setInt32(0, 0, false);
  };
  var m = (G7, I5, E4) => {
    E4 = E4 || G7.byteLength, I5 = I5 || 0;
    let A5 = new Uint32Array(G7.buffer, G7.byteOffset + I5, E4 / 4), o4 = new Array(E4 / 4);
    return A5.forEach((D4, s3) => o4[o4.length - s3 - 1] = D4.toString(16).padStart(8, "0")), R(o4.join(""), 16);
  };
  var z = (G7, I5, E4) => {
    E4 = E4 || G7.byteLength, I5 = I5 || 0;
    let A5 = new DataView(G7.buffer, G7.byteOffset + I5, E4), o4 = new Array(E4 / 4);
    for (let D4 = 0; D4 < E4 / 4; D4++)
      o4[D4] = A5.getUint32(D4 * 4, false).toString(16).padStart(8, "0");
    return R(o4.join(""), 16);
  };
  var SI = (G7, I5 = 10) => G7.toString(I5);
  var vI = (G7) => {
    let I5 = new Uint8Array(Math.floor((f(G7) - 1) / 8) + 1);
    return q(I5, 0, G7, I5.byteLength), I5;
  };
  var y = BigInt(0);
  var w = BigInt(1);
  function d(G7) {
    if (Array.isArray(G7))
      return G7.map(d);
    if (typeof G7 == "object") {
      let A5 = {};
      for (let [o4, D4] of Object.entries(G7))
        A5[o4] = d(D4);
      return A5;
    }
    let E4 = [...Uint8Array.from(atob(G7), (A5) => A5.charCodeAt(0))].map((A5) => A5.toString(16).padStart(2, "0")).join("");
    return BigInt(`0x${E4}`);
  }
  function ZI(G7) {
    let I5 = BigInt(0), E4 = G7.length, A5 = 0, o4 = new DataView(G7.buffer, G7.byteOffset, G7.byteLength);
    for (; E4 > 0; )
      E4 >= 4 ? (E4 -= 4, I5 += BigInt(o4.getUint32(E4)) << BigInt(A5 * 8), A5 += 4) : E4 >= 2 ? (E4 -= 2, I5 += BigInt(o4.getUint16(E4)) << BigInt(A5 * 8), A5 += 2) : (E4 -= 1, I5 += BigInt(o4.getUint8(E4)) << BigInt(A5 * 8), A5 += 1);
    return I5;
  }
  function WI(G7, I5) {
    let E4 = G7, A5 = new Uint8Array(I5), o4 = new DataView(A5.buffer), D4 = I5;
    for (; D4 > 0; )
      D4 - 4 >= 0 ? (D4 -= 4, o4.setUint32(D4, Number(E4 & BigInt(4294967295))), E4 = E4 >> BigInt(32)) : D4 - 2 >= 0 ? (D4 -= 2, o4.setUint16(D4, Number(E4 & BigInt(65535))), E4 = E4 >> BigInt(16)) : (D4 -= 1, o4.setUint8(D4, Number(E4 & BigInt(255))), E4 = E4 >> BigInt(8));
    if (E4)
      throw new Error("Number does not fit in this length");
    return A5;
  }
  function pI(G7) {
    let I5 = BigInt(0), E4 = 0, A5 = new DataView(G7.buffer, G7.byteOffset, G7.byteLength);
    for (; E4 < G7.length; )
      E4 + 4 <= G7.length ? (I5 += BigInt(A5.getUint32(E4, true)) << BigInt(E4 * 8), E4 += 4) : E4 + 2 <= G7.length ? (I5 += BigInt(A5.getUint16(E4, true)) << BigInt(E4 * 8), E4 += 2) : (I5 += BigInt(A5.getUint8(E4)) << BigInt(E4 * 8), E4 += 1);
    return I5;
  }
  function lI(G7, I5) {
    let E4 = G7;
    typeof I5 > "u" && (I5 = Math.floor((f(G7) - 1) / 8) + 1, I5 == 0 && (I5 = 1));
    let A5 = new Uint8Array(I5), o4 = new DataView(A5.buffer), D4 = 0;
    for (; D4 < I5; )
      D4 + 4 <= I5 ? (o4.setUint32(D4, Number(E4 & BigInt(4294967295)), true), D4 += 4, E4 = E4 >> BigInt(32)) : D4 + 2 <= I5 ? (o4.setUint16(D4, Number(E4 & BigInt(65535)), true), D4 += 2, E4 = E4 >> BigInt(16)) : (o4.setUint8(D4, Number(E4 & BigInt(255))), D4 += 1, E4 = E4 >> BigInt(8));
    if (E4)
      throw new Error("Number does not fit in this length");
    return A5;
  }
  function V(G7) {
    if (G7 <= 0)
      throw new Error("Length must be greater than 0");
    let I5 = globalThis;
    if (I5.crypto?.getRandomValues) {
      let E4 = new Uint8Array(G7);
      return I5.crypto.getRandomValues(E4), E4;
    }
    throw new Error("Random byte generation is not supported in this environment");
  }
  var i = class {
    constructor(I5) {
      this.type = "F1", this.one = BigInt(1), this.zero = BigInt(0), this.p = BigInt(I5), this.m = w, this.negone = this.p - this.one, this.two = BigInt(2), this.half = this.p >> this.one, this.bitLength = f(this.p), this.mask = (this.one << BigInt(this.bitLength)) - this.one, this.n64 = Math.floor((this.bitLength - 1) / 64) + 1, this.n32 = this.n64 * 2, this.n8 = this.n64 * 8, this.R = this.e(this.one << BigInt(this.n64 * 64)), this.Ri = this.inv(this.R);
      let E4 = this.negone >> this.one;
      this.nqr = this.two;
      let A5 = this.pow(this.nqr, E4);
      for (; !this.eq(A5, this.negone); )
        this.nqr = this.nqr + this.one, A5 = this.pow(this.nqr, E4);
      for (this.s = 0, this.t = this.negone; (this.t & this.one) == this.zero; )
        this.s = this.s + 1, this.t = this.t >> this.one;
      this.nqr_to_t = this.pow(this.nqr, this.t), NI(this), this.shift = this.square(this.nqr), this.k = this.exp(this.nqr, BigInt(2 ** this.s));
    }
    e(I5, E4 = void 0) {
      let A5;
      if (E4 ? E4 == BigInt(16) && (A5 = BigInt("0x" + I5)) : A5 = BigInt(I5), A5 < 0) {
        let o4 = -A5;
        return o4 >= this.p && (o4 = o4 % this.p), this.p - o4;
      } else
        return A5 >= this.p ? A5 % this.p : A5;
    }
    add(I5, E4) {
      let A5 = I5 + E4;
      return A5 >= this.p ? A5 - this.p : A5;
    }
    sub(I5, E4) {
      return I5 >= E4 ? I5 - E4 : this.p - E4 + I5;
    }
    neg(I5) {
      return I5 && this.p - I5;
    }
    double(I5) {
      return this.add(I5, I5);
    }
    mul(I5, E4) {
      return I5 * E4 % this.p;
    }
    mulScalar(I5, E4) {
      return I5 * this.e(E4) % this.p;
    }
    square(I5) {
      return I5 * I5 % this.p;
    }
    eq(I5, E4) {
      return I5 == E4;
    }
    neq(I5, E4) {
      return I5 != E4;
    }
    lt(I5, E4) {
      let A5 = I5 > this.half ? I5 - this.p : I5, o4 = E4 > this.half ? E4 - this.p : E4;
      return A5 < o4;
    }
    gt(I5, E4) {
      let A5 = I5 > this.half ? I5 - this.p : I5, o4 = E4 > this.half ? E4 - this.p : E4;
      return A5 > o4;
    }
    leq(I5, E4) {
      let A5 = I5 > this.half ? I5 - this.p : I5, o4 = E4 > this.half ? E4 - this.p : E4;
      return A5 <= o4;
    }
    geq(I5, E4) {
      let A5 = I5 > this.half ? I5 - this.p : I5, o4 = E4 > this.half ? E4 - this.p : E4;
      return A5 >= o4;
    }
    div(I5, E4) {
      return this.mul(I5, this.inv(E4));
    }
    idiv(I5, E4) {
      if (!E4)
        throw new Error("Division by zero");
      return I5 / E4;
    }
    inv(I5) {
      if (!I5)
        throw new Error("Division by zero");
      let E4 = this.zero, A5 = this.p, o4 = this.one, D4 = I5 % this.p;
      for (; D4; ) {
        let s3 = A5 / D4;
        [E4, o4] = [o4, E4 - s3 * o4], [A5, D4] = [D4, A5 - s3 * D4];
      }
      return E4 < this.zero && (E4 += this.p), E4;
    }
    mod(I5, E4) {
      return I5 % E4;
    }
    pow(I5, E4) {
      return HI(this, I5, E4);
    }
    exp(I5, E4) {
      return HI(this, I5, BigInt(E4));
    }
    band(I5, E4) {
      let A5 = I5 & E4 & this.mask;
      return A5 >= this.p ? A5 - this.p : A5;
    }
    bor(I5, E4) {
      let A5 = (I5 | E4) & this.mask;
      return A5 >= this.p ? A5 - this.p : A5;
    }
    bxor(I5, E4) {
      let A5 = (I5 ^ E4) & this.mask;
      return A5 >= this.p ? A5 - this.p : A5;
    }
    bnot(I5) {
      let E4 = I5 ^ this.mask;
      return E4 >= this.p ? E4 - this.p : E4;
    }
    shl(I5, E4) {
      if (Number(E4) < this.bitLength) {
        let A5 = I5 << E4 & this.mask;
        return A5 >= this.p ? A5 - this.p : A5;
      } else {
        let A5 = this.p - E4;
        return Number(A5) < this.bitLength ? I5 >> A5 : this.zero;
      }
    }
    shr(I5, E4) {
      if (Number(E4) < this.bitLength)
        return I5 >> E4;
      {
        let A5 = this.p - E4;
        if (Number(A5) < this.bitLength) {
          let o4 = I5 << A5 & this.mask;
          return o4 >= this.p ? o4 - this.p : o4;
        } else
          return y;
      }
    }
    land(I5, E4) {
      return I5 && E4 ? this.one : this.zero;
    }
    lor(I5, E4) {
      return I5 || E4 ? this.one : this.zero;
    }
    sqrt_old(I5) {
      if (I5 == this.zero)
        return this.zero;
      if (this.pow(I5, this.negone >> this.one) != this.one)
        return null;
      let A5 = this.s, o4 = this.nqr_to_t, D4 = this.pow(I5, this.t), s3 = this.pow(I5, this.add(this.t, this.one) >> this.one);
      for (; D4 != this.one; ) {
        let t = this.square(D4), H4 = 1;
        for (; t != this.one; )
          H4++, t = this.square(t);
        let J4 = o4;
        for (let K4 = 0; K4 < A5 - H4 - 1; K4++)
          J4 = this.square(J4);
        A5 = H4, o4 = this.square(J4), D4 = this.mul(D4, o4), s3 = this.mul(s3, J4);
      }
      return s3 > this.p >> this.one && (s3 = this.neg(s3)), s3;
    }
    normalize(I5) {
      if (I5 < 0) {
        let E4 = -I5;
        return E4 >= this.p && (E4 = E4 % this.p), this.p - E4;
      } else
        return I5 >= this.p ? I5 % this.p : I5;
    }
    random() {
      let I5 = this.bitLength * 2 / 8, E4 = this.zero;
      for (let A5 = 0; A5 < I5; A5++)
        E4 = (E4 << BigInt(8)) + BigInt(V(1)[0]);
      return E4 % this.p;
    }
    toString(I5, E4 = 10) {
      E4 = E4 || 10;
      let A5;
      return I5 > this.half && E4 == 10 ? A5 = "-" + (this.p - I5).toString(E4) : A5 = I5.toString(E4), A5;
    }
    isZero(I5) {
      return I5 == this.zero;
    }
    toRprLE(I5, E4, A5) {
      q(I5, E4, A5, this.n64 * 8);
    }
    toRprBE(I5, E4, A5) {
      X(I5, E4, A5, this.n64 * 8);
    }
    toRprBEM(I5, E4, A5) {
      return this.toRprBE(I5, E4, this.mul(this.R, A5));
    }
    toRprLEM(I5, E4, A5) {
      return this.toRprLE(I5, E4, this.mul(this.R, A5));
    }
    fromRprLE(I5, E4) {
      return m(I5, E4, this.n8);
    }
    fromRprBE(I5, E4) {
      return z(I5, E4, this.n8);
    }
    fromRprLEM(I5, E4) {
      return this.mul(this.fromRprLE(I5, E4), this.Ri);
    }
    fromRprBEM(I5, E4) {
      return this.mul(this.fromRprBE(I5, E4), this.Ri);
    }
    toObject(I5) {
      return I5;
    }
    sqrt(I5) {
      throw new Error("Not implemented sqrt for F1" + I5);
    }
  };
  function NI(G7) {
    for (G7.sqrt_q = N(G7.p, G7.m), G7.sqrt_s = y, G7.sqrt_t = T(G7.sqrt_q, w); !p(G7.sqrt_t); )
      G7.sqrt_s = G7.sqrt_s + w, G7.sqrt_t = P(G7.sqrt_t, 2n);
    let I5 = G7.one;
    for (; G7.eq(I5, G7.one); ) {
      let E4 = G7.random();
      G7.sqrt_z = G7.pow(E4, G7.sqrt_t), I5 = G7.pow(G7.sqrt_z, 2n ** (G7.sqrt_s - w));
    }
    G7.sqrt_tm1d2 = P(T(G7.sqrt_t, w), 2n), G7.sqrt = (E4) => {
      if (G7.isZero(E4))
        return G7.zero;
      let A5 = G7.pow(E4, G7.sqrt_tm1d2), o4 = G7.pow(G7.mul(G7.square(A5), E4), 2n ** (G7.sqrt_s - w));
      if (G7.eq(o4, G7.negone))
        return null;
      let D4 = G7.sqrt_s, s3 = G7.mul(E4, A5), t = G7.mul(s3, A5), H4 = G7.sqrt_z;
      for (; !G7.eq(t, G7.one); ) {
        let J4 = G7.square(t), K4 = w;
        for (; !G7.eq(J4, G7.one); )
          J4 = G7.square(J4), K4++;
        A5 = H4;
        for (let C5 = 0; C5 < D4 - K4 - w; C5++)
          A5 = G7.square(A5);
        H4 = G7.square(A5), t = G7.mul(t, H4), s3 = G7.mul(s3, A5), D4 = K4;
      }
      return G7.geq(s3, G7.zero) ? s3 : G7.neg(s3);
    };
  }
  function HI(G7, I5, E4) {
    if (Z(E4))
      return G7.one;
    let A5 = l(E4);
    if (A5.length == 0)
      return G7.one;
    let o4 = I5;
    for (let D4 = A5.length - 2; D4 >= 0; D4--)
      o4 = G7.square(o4), A5[D4] && (o4 = G7.mul(o4, I5));
    return o4;
  }
  var j = class {
    constructor(I5) {
      this.F = I5, this.p = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"), this.pm1d2 = B.div(B.sub(this.p, B.one), 2n), this.Generator = [I5.e("995203441582195749578291179787384436505546430278305826713579947235728471134"), I5.e("5472060717959818805561601436314318772137091100104008585924551046643952123905")], this.Base8 = [I5.e("5299619240641551281634865583518297030282874472190772894086521144482721001553"), I5.e("16950150798460657717958625567821834550301663161624707787222815936182638968203")], this.order = BigInt("21888242871839275222246405745257275088614511777268538073601725287587578984328"), this.subOrder = B.shiftRight(this.order, 3n), this.A = I5.e("168700"), this.D = I5.e("168696");
    }
    addPoint(I5, E4) {
      let A5 = this.F, o4 = new Array(2), D4 = A5.mul(I5[0], E4[1]), s3 = A5.mul(I5[1], E4[0]), t = A5.mul(A5.sub(I5[1], A5.mul(this.A, I5[0])), A5.add(E4[0], E4[1])), H4 = A5.mul(D4, s3), J4 = A5.mul(this.D, H4);
      return o4[0] = A5.div(A5.add(D4, s3), A5.add(A5.one, J4)), o4[1] = A5.div(A5.add(t, A5.sub(A5.mul(this.A, D4), s3)), A5.sub(A5.one, J4)), o4;
    }
    mulPointEscalar(I5, E4) {
      let A5 = this.F, o4 = [A5.e("0"), A5.e("1")], D4 = E4, s3 = I5;
      for (; !B.isZero(D4); )
        B.isOdd(D4) && (o4 = this.addPoint(o4, s3)), s3 = this.addPoint(s3, s3), D4 = B.shiftRight(D4, B.one);
      return o4;
    }
    inSubgroup(I5) {
      let E4 = this.F;
      if (!this.inCurve(I5))
        return false;
      let A5 = this.mulPointEscalar(I5, this.subOrder);
      return E4.isZero(A5[0]) && E4.eq(A5[1], E4.one);
    }
    inCurve(I5) {
      let E4 = this.F, A5 = E4.square(I5[0]), o4 = E4.square(I5[1]);
      return !!E4.eq(E4.add(E4.mul(this.A, A5), o4), E4.add(E4.one, E4.mul(E4.mul(A5, o4), this.D)));
    }
    packPoint(I5) {
      let E4 = this.F, A5 = new Uint8Array(32);
      E4.toRprLE(A5, 0, I5[1]);
      let o4 = E4.toObject(I5[0]);
      return B.gt(o4, this.pm1d2) && (A5[31] = A5[31] | 128), A5;
    }
    unpackPoint(I5) {
      let E4 = this.F, A5 = false, o4 = [BigInt(0), BigInt(0)];
      if (I5[31] & 128 && (A5 = true, I5[31] = I5[31] & 127), o4[1] = E4.fromRprLE(I5, 0), B.gt(E4.toObject(o4[1]), this.p))
        return null;
      let D4 = E4.square(o4[1]), s3 = E4.div(E4.sub(E4.one, D4), E4.sub(this.A, E4.mul(this.D, D4))), t = E4.exp(s3, BigInt(E4.half));
      if (!E4.eq(E4.one, t))
        return null;
      let H4 = E4.sqrt(s3);
      return H4 == null ? null : (A5 && (H4 = E4.neg(H4)), o4[0] = BigInt(H4), o4);
    }
  };
  var XI = new i(BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
  var n = new j(XI);
  var CI = { C: [["CcRunsaOm9T+H6q6KUy6OKcaoXdTTN0bbH3A29Cr16c=", "DANWUwiW7sQql+2TfzE1z8UUKzrkBbg0PB2D/6YEy4E=", "JQ9RFqQX12qqQilS/MWzMyn3cU/CbVbAQyUH/HQKh8Q=", "JkBlrYdXLgFmWWJsM8ghP3o3O5uCJaOE9FjYULtKlJ8=", "K7jpStjYrcps6Qn/lLh1BymylORAA3baOeM/2iS9Qq8=", "GQUQZdBdhh7IE8FSkdRqMo9iAbIa1dI51Phfuwml264=", "JFvQYXqkSWGPW9RVCqx7jgjU0cAXFllDzfR3bN/zQ0o=", "CfsaERgHT/edisv1sCEx4EihVwFV4PKxw2rQkdSRqI8=", "I0q1BLuugZiXJ0GVL3i36wGOoZLwXlTBSEq4lz/2bYg=", "AfZuUJuEw1WuPUw1E6KC/Uj5yMZDn0Kng1+8/g8qMkw=", "GyL11p1yXmACzwDdnuYtGlrw79xJEPVBJ6kgzMQ/kfo=", "AlK1Xt6tE1+FKWi38cT0kPplns1bR6eKfbkfZabfwj8=", "F3OuLhY3ySrQZ3wqBH/qjspLUzA/IYcfaJKiwEh9f/E=", "LVewKQbNCrgqeedvru9vh2ZurAk893FWRdXsn3rHMvU=", "ChbzpigksoHost24/DkaSY+wYTF/r/oDaW+DRZYxPZM=", "Fmb1Jff0tpiNKjeDSrdH6uBYd1e3iOt/HiawjjaghZE=", "BdpE+OCjuLsTIx8MoltQtX9cghKOHf7D5UHZEuvhe3Y=", "CaObqZkzA7oZG6yL2z4BRNv7XzliTN2VJNx4YWM7yVo=", "BsD7gkoZIC0w7mtBjAAp4QDoWm0Vj58qgo39LtCSCmg=", "A4fY4FaysXapd2tEkss7QYrcZgYn5SuzMkKDv5UiOV0=", "FHoa+CA271sop6N76kDWrDATzxtiNYOWv3FW9cLcloQ=", "MDjZIGDa6q8b0Egr0/BhPYjo3/kKegUl+SJ+TLfG+Bs=", "BylAqh1Tilo5oyP55dZWFs9sIjM5AG+XialyRVMpCPU=", "LT1gSUn04UxwuKh5rt7Emzo2e6IWrwSPRk7W8V4rkCM=", "IlueTzXHVJ+Ad0wrTRgwmy3PfHKHuYLkl0ahdmQec8U=", "HqeBKI/fE7IZAJWiNEgo433+gcdaCXCfDRObu/bHBBQ=", "COlsPn6N5EMrICQFRYRouQ3GiQ1M7hKLNQLltstK7us=", "BbQ9p8iqKa9tyq5X0HC0nSnOiJpkpKwYPoXVWzZsgF8=", "vsmKA047ive6SGHxrVpI3O98mW56UcfN3nJNj2EOUg==", "LrZ8z6KeK0Irn4Sl0FdfxDWzD8rjAwOUgL44TuTr5yo=", "ECu9who/FHvwTu3uXXC9CEpxBcYxyG7NLE6HSaE5Fco=", "J0vBbIhyG6v9W76NhWLBvxJ644kVKA+7jjEVytNYL3k=", "GFzs5BdUmyUoPeBFEfdpEByIULQJ1JKKuDFhE1G9mTg=", "E8c/sEP36Xi8nPtVx/qstPTII2dKvhdzcFmsCjLDYAc=", "JLOh2DMIdCs2DJxgWVZz4gHN1M71pBRckzxOWWlIHXA=", "GLWulN+eyXqqKo8PQkJbzM3IJmoHD4Zu8PSNejdEOYs=", "IOs5jLlYzCzMfLH6w4UBq744FpsthSLZ5fCZ8tWQXLQ=", "HliN0+yLDSUsLHwMeKArIru60fTcqi54qLju8vTik0Q=", "D4vzvWwiujsb86suP7QIGM1CF/+68pTKQjMdTjBDoKY=", "A4jJ/PMPwoQdZI9GutAd0QvuncGE0l6ryfYXAhEJzsM=", "K7fzl8WUGsZ776iyMvFciFPawmPaeTVVRBqQzsg7ZFQ=", "F/OJtS+ep6mIdKSjHvanvrQ/sX2w5JklC7PwGBxZ+yE=", "A6IJDqy4l6MfsQVh1WCpruwkt60U0XsUXyDIdaCyjHw=", "DDmFNPDrWA8f5L9kVTOJ5nzKRxQ5lDDglhncvuF7oJk=", "Bwlayf2kavp/GBJZ42Nf7/p/Ee5j8+53elzr9IIjKMQ=", "IEb3zxyPE+8racvIvA1dgJ+CVoq+KzPRzQYJWLHO1oM=", "LCdBNqXeKEnebn+S+QlyllAay2jVYTj7y2YMTLD2kQc=", "HE1ReKy1xrbs7vI6/G8W7HsDgwlMtkZ+jQ9FB7PPdMM=", "BlsUR9DWTOztEWeFuSxjpqfdlwFQfcvouQkyXij3uNM=", "ImXX4kSIEiDIGhk9l5MwQJyb+jM0OJUTQOAj57cqGWE=", "FbErNVr34FY3ocduZ/nOxvyopkSbN2afaFBQIlazCro=", "GhUi/sxq4Cjk0+MClJe4jzXCtIxoevFo7CWC2QdbQ4c=", "IvVueegbdJbkcqZBoFPEFLzFOwqTUOJYkkCAMHb1jyY=", "IC3bZtCYiZTnqrrWks6sTiMkZyoXq4QX0e4niv0X/Qw=", "ErBwHogTxbIajjAgj48RWLls1Ciud73qcvhFEPc+384=", "HmP9IOcG4UB8iDjOsmuEyf5pP93g6x4anffoTlPu7n4=", "IKFsWoYlbe/9Fa8XTDn52aoRUAZ2rH5XAIgoDdGJYlk=", "HI+L+OFT2lWtWsouqu442lY+BDXA8vN8J1WPubrgo+s=", "DXcyaHu3v186q8/cxPu2fhWcGYMhPkFsOIAST93xh8k=", "DN0ER1qGmZou3Lu/gmSxleEIs7YLZHXYNfbM754vaGU=", "L+ZVhs1OdUtMY6iMLtP5ug47+kP1R7QRU1YMIU/jy80=", "BQPPljyCc2BOZZEo7CkmH2I5mBXZjFbb9PKDfHJ61Nk=", "HuSOong5Bht4N5k29tl8qUALOT71/fOO8Udch0LLM0w=", "GkI/jY/IkrItfNW/AZfFdcV56DVj0EhZ1zssHFwEE/k=", "BpoNpQEz6ZUvAOYXeJcqe+Do2Kt2yVYWrkZWNqu5fsc=", "G/eHndQvLLuRxloJdjVvZ5ZML5Tfvw5EzyuZCRZdhhQ=", "GyPcz0hYIgZcj8Cv5hC+cWTiUFYmf2xKgF//1FR6C5g=", "Lr6Q1vb9ykIODC4ATOXFpECeVkycTzZx4wEfYnvsfC4=", "FnzWkwU1qBbf6+gdIMN253aHdg86L6DaKQsvTWxoY/c=", "CIZcEPSmM8VMzItot53yhfGfEhA3TMZOPIqWbU+QJks=", "HekC+8C/AZUcolq7OdeIlHIbN+BxhRsDpyzGuDO3iTs=", "Dj7KAHaZ3Q+FLrItpkLklfZ8mI3VvwE3Z2sWox6rRmc="], ["DumlkrqalRjQWYbWVvQMIRTEmTwRuymTjSHUcwTNjm4=", "8URSNfIUjFmGWHFp/BvNiHsI1NAIaN9Wlv/0CVboZA==", "CN/zSH6KyZ4fKaBY0PqAuTDHKHMLerNs6HnziQ7Pc/U=", "CE1SDk5btGnh+Qdct8SQ76WVZe7a4tAMqO+IzuorAZc=", "LRXZgtmVd/oz2lZyJBb9c0s+ZnovnxXY6z52euD9gR4=", "DtJTiESroWHPFXikPPA2TpFgH2U2pZltDvvmVjLEG20=", "JgDCfYefvKGG5znmNjxxz4BMh32Cm3NdzD468ClV5go=", "KPi9RKWDy6pHW9FTlkMOfMuZpVF0QN/ZcAWFWCgr8sU=", "Cc19TDgNxUiHgarQEufq7x7TFNf2l6VXLQMMVd8VMiE=", "Ebtu4Skaq7IGEg7KrORg0ktnE/6+giNJUeK+59D4VfU=", "LXTo+gY32YUzEPPA4/rh0G8XFYD1uP0FNJyt7s/OsjA=", "JzXk7J05vf+sm+8xusujOLGglVmlEaGL5LTTFu2IkDM=", "DwPB6eCJXbGl2mMS+qeOlxEGwz+Cbgjc9hfiQhMTLf0=", "FwlM0pe/gnyvkpICBbcZwYdBCQuPd3gRhIp+nq1neMQ=", "Dbj0GcIfkkYfwrMhlGV5g0jfkNQXgELIG6fUtNVZ4rg=", "JDRDYT9k/6QXQn7Vkz/PvGaAnbYLnKFySiJwnOzu7OI=", "Iq9J+/1dfp/NJWwlwH092Oy7rm3uzQOqBLsZH62nVBE=", "FPvTf6itbk4MeKINk8cjDEZ395e0MnMj9/fAl8GUIOA=", "Fakpi7uIJTTUssn7xuTvQYlCDE6z8+HqIvqn4Yta5iU=", "L33nXyPdqqUiEyPrzrLyrIPu+S6FTnVDTC8dkFYiMrw=", "A2pEMqhoKDt4oxXoTErlrsohby/56bLmI1hPdHnNXCc=", "IYDXeGqM+BDidyGKsUoR5eOfPJYvEehgrhxWgseX3lw=", "CiaO+HBzbuvQy1W+ZA1z7jd4mQSEzAPOU1cjd+7/+OQ=", "Hu/v4RwL5GZPKZkDHxWZSCnpgujJDgkGnfm64WgJpbI=", "J+h/AzvR4KicpZboy3f+OkuPuT2aESmUZXGjw88kTFI=", "AUmKPmWZ/iQzIfV9bFQ1iJl5xPnSo+GE0hRRgJF47jk=", "J8CkH0y5/mfp3U184zcH901da8wjW+8Qjeobvr3lB6o=", "H3UjCQixQbRmNyOLEg/HcPT0roJdUATBanyR/h2uKA8=", "JfmakZjpIxZ7uoMbFf/9LXuXs6CJgI1OsfCghb7iFlY=", "EBvDGOnqWSDQ9qzcK7UmWT09VuyO0UxnYil0IoupAMY=", "GhdWBwZ9UXOXwTNOywGXVOvAyFKjzwkewczEMgeoPHY=", "DwLw5tJfnqPeskXz6MOB7msus4C6SvXBxNiXcBVd83s=", "FR11esyCN68I2KZncgPslpJWXeRWrnif81izFjs5O8k=", "JWzZV3zqFDBJ4KH+AGjdIAhJgO5bdXiQp50To6Yk+tQ=", "BROrr/YZXqSIM7E9pQ4IhEdmgsP73RlUl7iuhuGTfGE=", "HZVw3HCiBfNvYQJR7m4ugDkkboTkrESDhtGdusTkplU=", "GPGlGUdVuMXV1/G/iqpvVu/7AS3XhM9eBE7sULKfydQ=", "JmtTthXvc6yGZRLAkeSk8vpLsK+WbvQg2IFjI47rvKg=", "LWMjTJIHQ4qkK43idkTAImgwTf64yJoaP0/W6DRK4Pc=", "KrMPvlHuSbx7Ot3iGabwtfu5diBe+N9+ACHa7m9VxpM=", "Gu5tSz6+k2bcuczkiWnU3x3EKrzVKLJwBo2SB/pqRck=", "GJGuq3HjS4laeUUuWGSuHRH1dkbGC7NKohHRI/YJUhk=", "JEkrX5XAsIdkN+lLQQHGkRjhayZXdxvTp8qrAcgYqks=", "AXUhYbM1D34bOyyGY6DWQpZGKCE9ZsEKsv3fcbz95o8=", "CrZ2k1ci4vZ8+4STjmFMbC9EW40UjeVDaM+4+QoA86c=", "Cw9yRyuaL19FvHMBF+2a5Wg/wubiJ+PU/g2h96o0gYk=", "FqpvknOs1WMcIB0aUvxPisryshUsOubfE6eKUT7c02k=", "L2C5h+Y2FOsTwyTB2HFusL9i2bFV0jKBpFwI1SQ1zWA=", "GNJK4B3ekv12Brt4hFVOnfHLibBC9Qj9nbdrfMGyEhI=", "BPw792/jHi+Nd2NzEw33nRjDGF/fFZOWBxXUckz/pYY=", "DRj2tT/GlUbP3WcLQXMr323ungayEmDGtdJicEaNv4I=", "ukIxqRjxOs7BH7r6F8UiPx9wtM2wRQNvpdcEW9EOJA==", "B7RYsuAM18YQCYUwFmPn7DPIJtoGNf8evt0N2GEgtMg=", "HDXC2W25D09gWOdvFaDIKGu6JOLtQLFs7Dnp/XuqV5k=", "HRK+o9jDKl12ZWjwPdHs2wpPWJq775aUXg3eaI4pIFA=", "DZU+IAIgAycFJfmnNSbpiJyZW7Yv3qlDE9tAWmEwAoY=", "KfBT7DiHldeGpAvsTIdQR/Bv8LYQtAQKdg4zUG0mceE=", "BBiOM3NfRrFKSVKphGO8EuJk1fRG4MP2S5Z5yqrkT8I=", "FJ7CiEbU9DioTx0FKUMbuemWpAi36X6zvxc1zb6W9o8=", "DeIPrgr1GIvKJLX2NjC61Hrq/ZjmUZItFIzOHF/d3ug=", "EtZQ6PeQsSU+qUNQ5yKtL32DbCNLhmDt9En7pphMZwk=", "IqtTqjnzStMOqWcXunRGqv2tvBqKvijXg0DfxLq7j2w=", "JlA+jUhJvfVFDavqeQe8PeDeEJhx3XdpBKEp25FJFmw=", "HV56Dill3/oA9UVPUAPFyOw0sj2Jfn/EyAZANbDTOFA=", "DuPY2qCYvuAS2Wt+xIRIxryaau+lRGFbnLPHu9BxBMs=", "G/KCCCoEl5lV0wdUzU2QVvqe96cXVwPZHcIytfmOrQA=", "B64TRKv8bCzj6VG8MWvuSZcWRfFraTczoCchc+6a1GE=", "IX46JHgnw3bsIbEx1RHX29yYo2t6R9l6XI6Jdi7oBIg=", "IV/+WEsOsGegA9Q44vvii6vh5Q78KJQRdQm2Fq3cMO4=", "HncPyOy/3IaS3O3Fl8TKD77Bm4TjPaV0EqktHTzj7CA=", "L2JDzakZv0yfHjqKbWagV0KRT8GTOLPA5Q6Cj2n/bR8=", "JG793DEX7NOVldAEb0SrMDoZXQ6cyJNF08A/+HoRtpM=", "U+jZs+pbjtT+AG8TnLxOAWixyJqRjfvmArxizsat8Q==", "G4lKL0XLlmR9kQ9qcQ04t+tPJhvu//E1rsBMGr5ZQns=", "CusVVOJmaT2CEmUkeRB9X9wHer+IZR9aQlU9VOwkLMA=", "Fqc19vcgnSTmiIaA0XgcfwS6fXG9S30OEfr52o2coo4=", "BIe4t/q1/I/XwTtN8FQ80mDkvLthWxk3T/VJ3PBz1Bs=", "HnW50sIAYwcSS+omsHckk8+11RIGjDrWd/31HJI4h5M=", "BRIOPQ4oADwlO0bV/3fScq5G+h4jnRxslh3LAto7OI8=", "DaX+tTRXZJK4Iuh2MkARmsCQCgU7Fxgj+JD1/VXXg3I=", "LiEbOaAjAxoirMGh9fO7bYwmZqY3nZ0sQMyPeLe9mr4="], ["GbhJ9pRQsGhI2h05vV5KQwK7hnRO3CYjiwh44mntI+U=", "Jl3f4SfdUb1yOTR7dY8KEyDrLMdFCswdrUf4DI3PNNY=", "GZdQ7EcvGAng9mpUXh5RYkEIrIRQFcKqPfw2urSX2Ko=", "FX/z/mWscggRDwal90MCsU10PqJQZ/D/0DL3h8fxzfg=", "Gw9o8HJqBRSk0Fs3e1iqvEWUWELnAYN4Skq1oyM3uPg=", "EijSVleHFAQwVp1pNC03TYVQnepCRdtHn97xpCXidSY=", "F6h4Ts3N1uVQh1w2qJYQ97jB0kXVL1P/lu65EoNYXgs=", "CYcKi0UHIqKy1e566GWq8KoArc/DFSCjLgzqolCq668=", "Hh1qqpAldOPkBVxrbwOkmyu9t4R/lA68eMCm0/k3KmQ=", "KBbE+msIVIfh7sHu/ZLun+9A8wGQrGEAkQPQMmZVDbI=", "FzWf2Ivja6hnAA6D92/7RmYGNO+60V3PTU1QLUJ/9Rw=", "DjAEy0S6RVo/Fv770MAmQEy6wgPA8ja6rYeWELhmECI=", "ClXydq8c6268bGgg8zSybxHKSvmMgzvBtJYZPWsEp8o=", "Ae5LBFitzUxIYaJ63BQEpZgdMgtrjiDlHTG5uHfoNG0=", "FDFeJ1Pn+5T3AZn4ZF14+HwZSkBU5phys4QdobT0gvE=", "K3tj7P/VXZXGYPQ1rZ4uJfJmy1fhfr0baw116IpqVtY=", "u1b6Pp/UirRtTnKVu+EgS2UuvpWCIYYPVuONuA2DwA==", "BQZTv13Vnt1tFfpgcfUAUFchizOo+SpYucJlYIEkn4I=", "LFdUI+JLUiZVxal2xl0GkoeQDI1YJVFAmMWxPIbx/Nw=", "L/OizN7pHgmjL3QjK3BM3Zn3LB94VXos5WiwfiGAcdc=", "EURzSQGoHBVDuLxvydNl9QRp64mUlJHTaT2+nGI42Qw=", "Hv+alU4kvNSvILardNieHNOLxpSp516m2iF6mNuAzSI=", "FHB950lsVjj5f+m9fUhcIOrWv9v8BZl5Hkn60DAc1t8=", "E9DeNBuoGfkP4+8ffOClTYU4rN2bPvhAqR1I7lNgQrg=", "JlIKsdIAVdre1xLVmwcIhFjBivvQ2liu6fFRqQM3K6E=", "Boy0gnrEhfxudTejwKBtCKTCeQ9cZdmGbXUpaZn3SV8=", "B9a6qi5YfCGwPfoOtxE24pgss4m0OMi8KCdI0OZ06J4=", "FbktNtsCyxa4Me6rLm7XXRJv+8J0zDNiNwhRUm3hPSc=", "J3uc6JEz3nt5GK1fz6tzI+9bnBkWtYjNfloNgUy8M5U=", "KuhHtms8XXO3C3MwQKqGxR9zcJLWXDSS1SkAD6GAKyQ=", "L6Porh/vl0ze1qum3CXPVn4W4K8p5nVwZkPyG/jv1lE=", "Cx1LlQjOxNGapT9O/kbFeVLb02j8vNRUqLEIe8GKIIg=", "AtOBAU0BV4uIizJzJwur3Dk6w5LnlYvgR4lH+vpWm7A=", "LnmoJ8hUBiQlI6lEMQBwIbyGWkXKvLpDaMQdRIb+/sg=", "AgfJm31ZSlxh1+YMwjZcTAyATNQ0CYr2JE8KAMJZs0c=", "EZwSQIbqWOu4PxTyYsaTQkNg6X5vtCroWWutvp7bLco=", "EE/zjMoPABc8zQtovdugn8VD8HT3U72OQT+DNPiHolE=", "L1tTd70Vb4mEWBHrJiQ2Y43AOLjLEOFHqH30wOI4QlM=", "D3Do4C0dI5aJMKjg22mxwgIE8+O0zs0QH4FHbQteqZY=", "GsRlOlEHGuci+QoD8AbYV1gU23grfxn2B9rk1WrVhrM=", "ErEmAOO/2Oe9+uXvnE84BfpB50rKv33oF4IwF6iyPbk=", "EbnRmQiRnay34PjQuncobUF1KaGKHYnEBe0cMCif3Sg=", "LDUNJF9PdYZHRPiNv/j+M1sA9PtoiJXBNjp0hKzoINM=", "Fqf3b9KyFH2275TCLHi/94LeF+9z5S2n34JgP0IrRh8=", "HRjYAkvh6W7CViavBqE59gk1RapQQDPax+KF0cw9s94=", "DIyrGtWZgHKUW5uIIo9TwpVGaBn7lNj2qe1Em+j3wYw=", "GmjRM9cDzUBsowBBkTzjQjxzsTOEGHqxUwEJt1atT3o=", "JKWLnobOgj/0xFNClBQX/yPQPID83vlJjKDYYIVeAak=", "DmMVyT+7idOAIRSLbDUyD7eTxBxqQ4bWrtas/i+VLFc=", "LDgG2ZppzmMpnodvXyGMcpXYciR5XXVo1VhpbjTGkvg=", "BZyJOncelHdNSaNWSUVo3TdoVquJcF3/JduCc4YPoE4=", "EWbZgZxPquiYIkPQ3rH4l3An1cxWv1LOJgvsXifosPU=", "EoBvqz/LCfwreUBsPCA8SWX8clkRKvIQQxLhU3Mn4KM=", "FyAV4OM3NgWPYKoz6C091z3D6tifmN7Q26NdzB2L2iw=", "B3uhiADYUtCjT3CujP1ooIApa/nUehtA3n5v1jkqDTA=", "IJTs12i/qPDfDXjQ2Ubhr/Si044CnkFHnW48D+efqLk=", "DM69MCr+hMIP93TTwfZQynzQvKCLqh4mHanHRBqCP4k=", "W5MDBTu0DHNnH11VtAUuDVVJhx8bUoPwFIWmtWjNBQ==", "JScokISrSSJ1tM1n04MRorgW6qaO5r2yOJ7u/WukxyE=", "IiL5c4KQ2NXyo+rNrZXxLNTnQX7SZhsBL2RIx1A4d/I=", "ImyCCPJtaea34C/iZVfmvRYPy+J+50H9HlgRYcF4k1Q=", "IWsgjAJh88kfr2CeFfep1IU+QNkgRJayRBEV1zwpQcU=", "Dg1mDgRqJZ87rWgpcptq4xUfvNdd4zsSL+E0yj1aTdY=", "JA8DnSAmsyZvObpcTsSKxqzoiq2u+ZFJjNUtqqD/u6g=", "KMjMz3tAosPP0u7g7E0WCodqTf60CP/jM+kvpeHuTXk=", "DX+BtLRtTyR8QkPwRahSzJV9Kykj0o6y+ne1qYRO/Wk=", "K+Qy+HssUJSoLHiEV2Ud2M2wIArDtChgy/VEdZlrdy8=", "E+o58tY9mtrhh68U3Qe1M9RaY0NeDqTl5VXTXnDUAWs=", "KeOxr+GXO+nNHPSwRzJav6plzyuY/zrtR4cEYZd+ySE=", "CNt9aE5rhBtelpJJj5Wh+VChzx62OLtOSPO8GjxXEZc=", "D08QQal2qgUZbaHAQhJOMnfqGij7bu6rS+wSQ70xYYs=", "BanQUm1vGMhrJV8A6G7DTn+KJsJRtRwh/kwSvcTA/x0=", "KEsDBN1s5mm89lDFq4XInUQQ1HKqbrAN8bjRflLy8/8=", "I2PpsBoBY1mJYv+GkHAC+VkC5yUEkpTKerEMx6o/Bro=", "AsLbEmR8TARh3TKQp1xfL9jX8RWz4EDLBd1+OtJg2EI=", "LjxC9nFDH5Vg89CGOsRFBSQi1bmT6f2muBSGsU/+OnQ=", "HThEHyKMDOIv8oglYPXX7jtMDKoQE3HLd4L/2Xr1//E=", "JoFBsOScWeqx1XPq1OLh83k2TdEz8s7FdMJa3ix5Qoc=", "IgnLLhh98VIoENPyiGjabPUq+aZdvXuAYEn0ctlmN0o=", "Cl6yUQ5vgE0YMNeXSsFnfQggNOU4i/rukaMZ7KfB/6s=", "HLKGTDiABzb4862YZp0616nV7lITjpa4pwFeEInjauA=", "KvjtBb/I+K2lR+6bxsfGxejBXGwNOAo/mqJ3JzMhtU4=", "D4XRWTs1vgP3myIohVVaJSvx8KORHXhBMsSbGpasDzw=", "KQlRkuxT4LhZ66RWKV2VvEVn01Gm2tORuLiXB4VQCMU=", "GpLv3h9fpWrrArTEuPUayAgx+JjHhDQHET+7YBEXeFQ=", "KgXo3u6hXkN3wICqcP1qhtxz8/36a1X1YQYUwYSwsC4=", "EhGfOwGcw/xG7MgIk+hvUQsd1AMLLOKMna3NHnGtSJE=", "BCtv/mh7wjor9rczFyhqVDxg7RIvwiWq50LDocLdOh0="], ["DrVE/uKBXdp/U+KcysmO19iJu069R8OGTzwr2BptqJE=", "BVTXNjFbhmLwL9un3XN/vKGXrrEupkcTunM/KEdRKMs=", "L4O53yWbK2i810gFYwfDd1SQffDA+wA19Qh8WNXowtQ=", "LKcOLo1/OaEkR6yDBSRRtGHxX4tBp17zGRUgj1q6loM=", "HLX5MZvmpF6RsE1yIicclJlBlvEu0ixdTscZy4Ps/qk=", "CpwLGRao5B02DQLm4uXRuYw0387HaUKchRhn5G4Sb6M=", "Hda6NzHknSHo026dTR7a0kXr+b3Z67YKJS5IBKY5D2o=", "JK4qZ8PVIcEaEbcRKrve4wZHEHuAiGapgIN9DX2k4+A=", "DSDJMQtcFNnvEoZq9aRerjypvhbSAElwZsiy7pZ4HXA=", "DgR8mCH+lNVdQA12OmbExhaZk6vtVDxyhLSjVDABlEU=", "KUdKt5mx4TlI7/QdLOeb+tM10JEQFXB2mIrCB+EMgd0=", "A4mfE50NxLKBvjt0q0xweJt/QeespH6iciog15r7ypM=", "GGZiT3YauN16kcXzevXkdjmVHVrLaxu/O5bKJz9xAp0=", "E8EZ82cY99XwmthUEyWhOs9rNNttnuKvfqBgYSQPMAk=", "DkoQCBWAd0ArEfE8CIkLc5ZDzI6T+kRIe1oVdd2Gf9c=", "DvUF/USsEKJRtnDa/hTKvZranjACIQrJw4dvN95Oetg=", "HTHk4qWXi3SRxD02dHClpdFEW2uBKaW5pv0jhAVyDeU=", "Cpea1UKNSBy2JNnVBFJKlpTKXLRCG10dxq8sAw++rDk=", "D3/M0uyLxu2c42gvOKopHe6pNz9JlXeL92Kt421qsqA=", "JpG5JN+hIwBffAeNm/hwbe/pnCupm9buU7FT6f7Hu4A=", "Agd99lELSGDla5E77zqA28RksORnit1g3qepUXRjIgs=", "Ke4J2K+dJMpJNQzi4KpH0Ao9whuvv6wcm6YcWOKZPow=", "CLKSxmHUJ1BrmgGRZiTzzeMyqs7Z8aSUpzPOpvJb+q0=", "JYNpnOU2p1eyLkcT7fuwUAkshKvHLJCthzk6Hamkz5A=", "Hj8bZgIj1lrYiZlHU3T24l/UFI64EQoLEs/6GWV7C2Y=", "IPPsuzfDSux5ExRVRhJZ5ZsiLw7o4C8xlM9iqa1MNEg=", "DfT1CI5ERPv4fVU7pi29qVaW2LnPYhCxyFUTsXdvvGQ=", "ArNI7/1MnO8Aoc9N1n3WZLL/42GoB8WJolLGO8v8aDM=", "G6HlIvyxU2ds2PIOgiVvAyfAAPqWsbRi/IS1VvJqhsc=", "ApTETfjmjJYUTpZMN7vFdmdk7TVQr/gNvp0/p0QZ/lA=", "AxNxbuxtzYpgLKBAcASY3ATHff4hlHU8WbyBjB0mNqE=", "KH3sdGltZj4jWfaCJd6VU4TZYLuvuQlnQppELhnj7GE=", "JeQvcsa+CUIxG6CXzzZWg9tJYsggT+ySE/D49ywZRr4=", "EraIG5ZlT+F2jCQqzVOZsIY58IGpSJb16m2nC2tHXJE=", "DfwrVFRv0yZ9e+VccWyyQ+8YEY7ZSYyCcESb2UGK/bU=", "J91V/g1cD/Vq1IkPoCnCfF820Ezcc4mauZsocrKO7fA=", "DGCWJxGu8W56LOWfWHRD7ItB743PzLOBiK3L3dMvFz8=", "LtwJ/rJnxrWG5i//4yv18WwotYWYa4ERZoS36LQNQtI=", "Cvg4aFnbJS/ylaGUZtjRAGIskFAhN6oc1MS8yWVtEeI=", "Eh8hg5L3PUwWq+OCECpFnmwICzyk7aUaI+ZRoTpoBVA=", "HqOCc/XVnmUGH4x3XFcf/HXvZ9KUBbXgKRPLMBnVb44=", "Cb0jSQBWmbzArDW2J+L48Iv8OwvzCxRvN3QqwVVhh/4=", "CRxQWx6SRIwRrqIqqsTUT2p/ITL4npG39V+UBGlsFDM=", "CzFvHClonU9JD3/N1eny0lbUQ7oUzaS7eZsFc6kxqZ8=", "IEklGRmo8/Q5gYi4H5nS4tDj9TWc+lW986p1/a3zZ+c=", "H+f562eIEBkIgUFo4+TPeomaEFv55YSvAGQYikqsVb0=", "FY5lebA4gVOwrNYw6pTej22WbVKcLQG56bHGfB7B1XA=", "GZT4LycVOvud4qo/S+BcSyxIfjk9ztyiVmqmt/vDaWs=", "G2JQVT6GKaWopAtWhDLOfb2DyHYD7szI2tVyzOvvbh0=", "AgKWlAp9Ht7Srnn9ePoqwRq7IhC/JFQv6r7nHw0NfJ4=", "JVOUP54P/OnCl80xwp8fpfAYg8yeUE/e16kFAywXDIk=", "HFbrNiiWwvAK0Y+urwTVd/X+tNtOB3llw48ur1974Iw=", "DtiFcgXgaABV3n6CK299YqwPdf72faH/e3c1IIiFz5A=", "ARj5EYWgk1X52MP1VjZ6K+vnnn2VKKjXKlkmgWcarHU=", "KnHmpnq9slp4AQ/m/gog0dhOIcunWtVZN9wYNME68MU=", "AjJ9vAWZfOhXVoDkuJKdTp7SX7kgQnfWAwYZhtvuV+A=", "DgUjXgHyHMPylxw4LRjBTkF4Wl7I1EfNk9EygXkubW4=", "CYr6Lqf/Blsq38SrAPOwRJbB5JDqsmTSNwsQflpJIE4=", "J73be/BuqmNBmtrkQgndJaTjXty4Y7AJvTTMxJBdIEs=", "JwRAa8gG9MyxkIXLnTdxsSq1znqr8GAengaivJiDet4=", "IcdcVGZLn+yGdWqpAnJhl1JE9Cz5HJzAszwqYrdWo+8=", "K+hMHYTBYDjqX5MykGmdqqqBZMXqOaAry93GbPaf6Ow=", "LJcOQdSGSc8BPGdsjGiKwWVWNyDR1fMmKKxbI5SIqW4=", "DhrSZgoulY2qHyZUs6N/7mBUbKAycVBzMHB0LtyAZDU=", "IGDuf993X8fjiaVTdjdMnjXVyHY9WX9CYwTiNvV3uCk=", "HgEWgYyEPthvCdruClga8Q1S3ura13ZW5zbqwI5vDxc=", "ConBSY7yWjg9iGu1hCTmlArDmePlV+nelRppfFSnV2w=", "AwN0PW822SXhCXSDNQ9b0sspfU7JI5IJ9jxRa4SaZ+Y=", "CM9ERG2WhDAjLfF11GK5ybDi4sN+hAZ2TLlsfDRGAY0=", "JBmBHLrrP1UbCpIy7uXVPjdp+89SOVMwdDdfGwB3fxY=", "QjfGImJts3a3dISdu+h2gJCC8bE/WCT0xYNp8n/ntg==", "HltJDHLutgfhFKXLh6hJSxeJN83uNLno6Uc0LBRFRVg=", "BCZTM+WeGl/3SSA8tKXRQVpyhixhOAscJC0PMsoVuXo=", "GJ3q90JYRRrE2mglMr5D0kpcaDKTwf90ht4m012YLoY=", "BOxRaw/UL6U6NJBc/e2q0CGzY5nQPYJjrgjEavPsp28=", "LOHIoAhFqCs6obZkL8mIV4V2zvhhllJebVlcdwGtcA0=", "JHgW/Q00+dOzlpF0eGBclKHAUqbtZjvcNE567paGtrQ=", "xnbb5sSU1WCcRE3mIrz2DPVVCRpQf86GR3AZ2uqYfQ==", "HLOVreUw/CQHqnshSNLfruMPTd8lj8FJzOPFzegKhdU=", "GQ4UlOPP2to7nmXY/jwex2lUDaAj+ewuViWfalaJCw4=", "GPKUGyM1E4M2w1GnkjQyIqhF7goupaO5FgwdbZsin+I=", "FOojzosjEuB99X4K7OHaXSwOAfdX5qXIarXkA2iFRNw=", "KBitEAX077XVVDYaKfheoQlA1ucfOOg2m+/zVjpmC74=", "I846mlIpFaKBeTl3tJBUw31l+QuEHgypCBe6tJ1520o=", "BsLtK+h2MJqbO0Ts43scQjgpJ90EJJZYo9QePzjV4CI=", "GLZ0D3LXfrz2QrlFyi7WyKmFOjdJ1/q2BR5Mo29E/EI=", "H+rLnrKmh4BhN00Gmp2uMoNp7mPnWhuZzbBqSLDZl2o=", "GkTuRWWpZ2RzAMde0rJUPY1F1Ud/1gajVtEHO9E4MdI=", "BB87O1sQUMFr89Yth9XSc7Bn2khGeRAyMe1loY2p/kg=", "H9lYzE/gopC9D7+4uKUTrLWJjWO8DX5YW30IHEnrVlk=", "F12roHxe2/hPCch6jDTdczJZQ6SPwSy4OdykdRJWHS4=", "Cc8KTm4x3CTf1aWieneDPkd9Wy2Sz/X8XMrZUoxDung=", "EtSUZb1BIMv3jlo0FNRMZTC8ljvXAcVNTGQYps6+gLE=", "EBsvK2dYBNOyayvR4HxzZa8L/C7fAQkW7vs54oIV1Eo=", "EU/GX6ugmll0ngtfERkweDUpoGOEViFiMst+WjOXNqo=", "Hf+ZtSeZr8gCwrv5tn3QRNPLUQF9xPiDWN3Wc2bTqfU=", "KQ9ElqUt1N2lntzNcyUDi73AVUrTqaC+eTHJEGKmcCc=", "CR6HBGY8UWw7lnIdIDPZhQifuZLcpIyN3Ll9fRXH4Yg=", "Lc4iWZ3gQZagFp/CEdD5yGkmQ6oJco6t9tULtTTA4yM=", "Kaf/ByDhcMDmfv3nJ5Uyj+zvZtqtpfDiyoWKjGE1/Ug="], ["FEhhRZjgD5jnrn3qRfvYO9loZT74OQzeLoa3Bq1AxlE=", "CreykTiOXJ5DwNwfWR+4Ps22UCLhtwr0O4p7QMHf98M=", "K3y7IXiW9SyajAiOZUryHoTN51SjzvWxXE1UZmEtat8=", "K8aw3b4dcBtlcEKL3Byhvw2ln/O7u5X8K8ccDG5nplw=", "EjpVoxmAOE89ILLOy8RO1gw4wR99IOknHvq5qQXu/Tw=", "A3UBzIydyBkwmnafTfCY5YiwGFi8jrfieeKIO+n7jFM=", "Fd4jFjeo6jRzwkmeG+4yDBfGoKT0ipsorRRE1TUd2zY=", "HJsdo2mJIG3pFzsN37U5vfB/id8FXvwcxIkALaP0tTQ=", "Hyjsn9yzhUyzJ+Pi/jlYVQw3/ReRmKQc8goaTIEGVMs=", "KgQY4S3SbnlsCRvB+x5Q+CkCY7PID2gDbmWTwtsvg8Y=", "Dfa8mQ3WiPq8H4pfj6Aqaob3o6nuRS9WhNEj6sFQeJA=", "JM2ZqzAe504jguI4vplB2YdvMg6ZQEgWR/y/vKfraow=", "EDbuxrOrZZpQwirjs1clLmRkHOCC5cCEv2Gk5hGYrIU=", "IezhAwv1rVdZ81upavk22Cpkq+T5uy9QwopIggkoYRg=", "Ll2QWeYjA9jRf7UJpgr9xNjuHZE3+P/w0MbpE1qvZss=", "JZHYjBFYC3XE7fRNumujHGlvZ4niLT+mO7ruccaYaFc=", "HmRzRcEIAFp+L4cPARQiI7siq0SgPHGYhSqvbXZcO90=", "EH4nnXEOZTWO9E+WbllNK6BOPhXjfKWqURetxxtEHwk=", "Fzspgpit9lmz9pWgL1Fhfsyn4iH2eDdUBfIEBeN3pEw=", "EiigzRBZRocKzHWGlp5+Oz6NT19G1FCxRpggKtueoc4=", "B3jLRdmMDsaISb8gPcexUYQJKMydf0BnC/fUizxmHWg=", "Byp/8ScG+js0ADCP6zPvPd6uuaVni9Shff8Jb6menmQ=", "KwmXsBFlwodFA9wS/nfWq1ikTFg7k5w10IBbtVXNCfM=", "CAgFEpJZr1Di5fLY773jWBMtocGfy32vSJhUkcnSh7U=", "FD5OHyr03vGxkDig1qyWBuM/QHBHmfCJC0q6Cy1suSM=", "HBa0R98KMCbVuRI6uvAtaQdsWRUwUmYN8je1IhSF2j0=", "IhJ2NWShfFuBZwPl5Sp9sMW/tmj+LkJMslE2FCaDC5I=", "AW3TCkjZb3bpN49lvDQXgel8+5SvWlcJG/NBNCwNem4=", "DvrkpWlRRlf2fhnKEcAeJCbvD6or7Ujv4HEdM46juGs=", "KB3NUy3EUL5VlTbiUuAVnuIdW5H7+XJfSlfdhw2A53k=", "D+TRGos/JNxVm0o3EY8Vq4Pa1adN+u1BY36ZSoEzP5U=", "GFeTjgJ5CBkygnipEyIjRGQPIAxRQQRWCJdov86lYaU=", "IAfQQ938VP2Zn29LY9TKZsXxJpUTiM3bHc3jKUQVVnU=", "I95muSfVdnksaaLG598g0/x0VhT1ICeAvCtML7J+njk=", "K9/L7+NT+i/+edLv1aUcmBNFot5A71x2S/kNqG/tz+M=", "Js/8DlmEkzMT5PBt6tB5Q4gNpmkp063td+D6f5lCRP4=", "IcUyrQ1QZ0vjlH/y1Ot0Tq26ooEvwPwlpBy4TA/T77g=", "JG7PLuRTGGLMWi14Qv48eAuGjvRF9wyaHiv/RhScxG0=", "A5ezmAo876D9xzOcT5UAs2Q8VKPuejlgAwR0Gi53LpA=", "FESQlXZ3Y2qae/ErGsma+VXqcJmbL5ciEVUqx1Ysau8=", "SpZml3eTjNlkP/JX1fVsX08eta3qSaZ4zsPqFwZ/HQ==", "JCOlCHFCmoxIuhPk35OOYoDXFbOa9DRJ/wYDDjRuPis=", "HKUGQOj0LAPCiAFOjvErgBTDxApi/FhW7ptjMUbsYCo=", "CoM1wvp2LQm9oet+IrEcwRffeIwNAj1tiUdydoGnqes=", "HFevemeW7Te9lkwzzRvJyJdHuiHfYQAgn8Pfn3B/HNo=", "CPCtWmwB8L3n0ajn0mhIF59e4x1tWbuOLHAeN6TPuyI=", "BQx4IcblProYWmJ4/gSlwfLyhkG9yEPJ+rKsiX6KJGY=", "C8XURcXfUvubS51pVLx1dj1TsMIImDLr3KlgVnn2jQ4=", "EKayoHxHLCoy6dwfBQH72lyfBbhh0ceKXP81lBl7c9Y=", "GiREizRCR5x6yBkb+vxn2cdeQCALMY98ctDC2Qiz3bM=", "BeIwx7kdwGeALGyf6tUIl8AzeTieKn3vNw70wo5Wcb4=", "HurWhdnzV39+Nk2kf3TY7iz2zuMWYAVWFdjylKMClKw=", "BKIuqhB5G1mxvYrZYm33QnVTXr6jAfj5EsUh7ynFBLE=", "Bjd7YGFbe5qfDrInZ4bQKMyoL7zn2xzCf1C4SGyIBto=", "x2SV2keLvf1iP8rC87CNZBxMZUc4+tZ7npDqBxVxTw==", "JQrWuU4b0GgXz9JCFCOpXhi6hysnbBmeFqj8ZQxanWE=", "Gy4OZhRvtbEiHIeChqCYPpA+apU5D1fSmKUNzm9Sq0c=", "GMqJCq6u+Xx8F8qyw1GPzPEYC4+9E0+8vOOPeG8sDgM=", "G1w9uU2eDNRVccG4gIQYbrWJMLzs6yyPd1sS83lhvqA=", "BilMcmhqabYGk0mnOoFULLFqatcTN7fH/1pd/gaiYK4=", "LBiiWowsrhebGmQ+ERWej1ydpEiq7jpE3ki+Psp7slM=", "D8RaK5vW9BkBuqevrUDMKNRHnDBNEBBnw1Z/5EkzLrA=", "A3i8O1oyz1ygiCJ8W28KVm4LdXM8cEgEYZ5ql5vB028=", "AlU3U0a+q9CSv7/XJ4tDe908GL2VHX9CIM3FATYR/Z8=", "BSSFOiqXF69kUA/sg2wTgH5ZeL4yiGBHvTaDpaZbaFk=", "GzmYVTFU/CbOiPBIgWDCROHexki5MMEy0HfLk5l69eo=", "EgdLTYPpL44KuSQprrUnAUAzipfujlx08rWZ2Vd/Jf8=", "GkCx4BoJbqfrznTAJ1NrxYd4tF3O+3zAViVt0HMmpmI=", "D1IovAlLnuwZZ9d4orfWtN5Y7ejg+XQWXTerbyM2vuQ=", "JzFLlh0vlpcJd6M/L6xoI8BDIH5LakigVTfqeNd5wW8=", "Knj1vfmK+h2m3UWrNguHdwPh+fDnl/7MpFMn7kq0ZZU=", "LP3lnKLwGif85VTCZbwj/aMt3Z3/PdCi8d/d0HZMILQ=", "AZJafRys7lYAEPhD71/J57ApRmfYcdSeNSOoj+CvVqo=", "GZ/0u6+U7jh1YPu+w5XbGvnu2fUN1g3Dyiy5LpJFImM=", "Jvf5HZWc2ukZB7KPsvFJ28J18T1Vd22lGoggD458rwk=", "JM3dZBt8o7xsTSV4MqWuXpISbDvS6fBeAScxEU1i0MI=", "GFR+31C9d7JlPCpTKEyZnc5dxp3WE4BNEKDulrylVzg=", "KycXjspLeYunKy5rVmvf7MsqHmDYUE5MjskZLyuuuw==", "MCDriK56z9Y0Jwnz075FzywUa83JBu5XlSc65LbnAEo=", "VLgabTsfACIwxM1iP3ew+27so6/vr+aUVE7u7BoXDw==", "BNHgPJNRC6b7Sb2atRBj07FeSOLtRJvaJ2XQMGX2z/w=", "LKaijmuYuMgiCrwJGi+v6G8nHu8dk4ZLeyu1oWDdjZk=", "KlhmAGeGUfFEvx5U3j1vj9UZ2q9KStmh8yIz6J+dZzM=", "CpSp+4VKPFNBHXNs5Y3IIZayzRMUSiQKb+FzUIoiHZE=", "LTNsZHy7VHjjpy8g9B0TXTX5b73ZsrKITmsj7CAeR/0=", "A9vj+JlI+fRxXEkaSD379vb53PtYU8XTztcH8AUKIYo=", "IkZuwVM4EUw7MWstmGyMDT0UgA2CJ1pC9Haw/9+UNbQ=", "HC1sWxgvOU6NNpmekanu532nH1SQlh+3g6T45vhC5oc=", "BPxWUVz4MkfjcOSICdO9JFq7UmONhrSKHLdDFn2yKU0=", "Gq68kGF+WqS0+QNvzFCS2n7c6cEQ4+rwDX/Tmxeq7Sc=", "AV99rZKMs05oWKLesvnZLEUqU1oJbF1xP3MZwMV35BM=", "BgAoMHIhMj9G61Z3PFMg/aotcSOHW0IBduNLPuB56XI=", "FXsojOybU1bmA3O/pD5nUR4qfmJJNlDI842Bn8NOWdA=", "CI2+iPP+j9y+vDTOPwDwf9pBHXgOz/HaV2YK6/0S6/w=", "CfE8iSE8gtW/04+Pi8/kb99APSjm00nsAXbjffnJEv4=", "Bb/61TcirGxCI2EkwyAGaav/ptySP75RQcjkFXzTF6M=", "KQp4KaTO8uJdL28oQhRjNEv95SID1MynNlc1N68zQh4=", "CecgnaxxUWl74X0+OsUrDuZGeSm4eNgUrkzCc0s5NI8=", "B2KfW3zT3VNt9qhmoHH7XfVjUvr9Dwl3Ec0WZ+o0QDk=", "EWQd4K9dAztELc4fgzTq/UlZ8SIwTqbCF3w3fVXq4EU=", "ECHoBtg95Mvss8FlDHYXdOg8rk7Luw3xMxAVDLraiPQ=", "BK434ednbh089kKF9wQTXIzWQPcMiVve3VHe0mD7tp8=", "KkkdKLMg/3e/ciG1n8wlNcfPycDxGl/cXknIN6cfAjk=", "K6fCaVgRjwt1FETo6jUk1F/M79h0RhjmblVnnkK+KcY=", "DGUW9Musi48pvpQGxsMJ3zTi2n2TETPko08p7GKD6bM=", "KZGsx9tesxWfh2bEnWkgeQJbSApwZWQ17nDFaH2q6ww=", "KddgW0E83dGSd5tzJeGvuOUu0+l+kq33AcenDBGMZI0=", "JQe9N4j1fO/udU0/9akpgNzwYq5KP62T7ABZ6y/lRew="], ["IZdwP860y/B8bb9GxK2T59FOVU22bQkQL/hIJHQ/5Oc=", "EyLw//x+SFS9i1/CPnEGtR9ZvVBh2LVlrKL9Pv5RL3k=", "GeQU+AOAqi0iITMRjDN9gqjFiUwviIYe5G9Ej6nWE1k=", "IiQRmaTfnLfWUknZViytbGXxZGDnmnk5y/3W17kgnZo=", "AwEGFzU4Tfzs+aMRwireMntRx4shFhX0HHf22F6KQbY=", "Ip4dhsHygQ9KJjO3tLW7YbfcXRmslf2NN5VI/ytoUO4=", "DjHc+cUyCagX7rKS6YlyfD9Wv/ZYg6/l/cKKw9++pnU=", "Bo+Re7GwgF5bWIi2qXgkOVuu0ZW12gtxxCq9CRwu9Us=", "HQv7i7kKwjQALYN3FWEyl4AqW7y2mqLajPq9gy9S17I=", "DWfBgvv0HBjVr8tIviAjdBPwKmTb8J6vcfI6FPueIQM=", "MFiQnLEDVXcGMEubtk2UrqTlBNj9qLgjE5lveWKISIY=", "BNBqgBluEOZkrf79B10MygSWHuion0/W1gHuubYMjbs=", "CrBi+NS17Q7CG9tC6z/LCoj6E6/K5FI9I4ZFUihAe1Y=", "FzgHVHkq1fgZXjJ6WmPNdXDNGZS9ahMOAcH6Ghc9RjA=", "LU83gO70/5mskW9LEt1XVhPLliG8X6CYDtmk7Iqt5Ww=", "KrvvSBs2jKlx502uBGkUOfhFwQ0dV4lCabJ1wZaq+e4=", "DyQyT4LWgjHdndb4wF9S2OrLmuAcyx87MCKCIjd9DlM=", "JnYXMX9RRmVCle9gK5ElDbAQtF9HJM5+xUiEspxARZc=", "AVf54vc3SYghuwGrEAHXFessM229/Lhnvs8KK7ZJDAY=", "Dae+wMuY0zelLN8NZuipfyQilnE0aEilUurBTIowxwI=", "FfyCDvUzAtynCfPuSAuhNxyRreefn1h/x4eNcxwFltE=", "CEVxWt/KNcPoBXwPzUzmphKNDoEX2I9VHT7GWH0PQpY=", "BCL3ROK3NglryHdaOQaJOmTNqHSqRFfStEKpp3GVbQ8=", "FfQhVQv2Y51Gq1d5/Sax4RYY4El+BcyFxgiwD68zgqE=", "BPF8rSug72+GAuk/W5iNXzV+Ya5fPsNQZvy00ae3IMg=", "FzLvVmDYSuUMoJwCHrDXfx+yoAzHkFskeViMScSIZz8=", "KbElAfp54IvCUlmYX3MM3OniQ0GS7IJuD0udVovTUbI=", "IHyABqp4/ECoTbQK2CFC0PYbKN7fEOIgHYFc9PYnRZA=", "CiVwTOTLdKlNe9y9tfomir1YnYj+RbLyyC+QMmzQSag=", "ESEfOnGvMKABAcQj6kCpWFqe7HVodyXX7iifQo9A77I=", "DgHou/XuYRRxOAzou4w0uTKsdulvqry3rSC+lhh8L6c=", "HIlKFDBRPfNVI+IuT+n0EKQ96R2sc64zjHcv7x+3Q2M=", "K+40k5LfoLW0oI7ljvVPAC4GqyaDT5SEPUj/DO1SbVw=", "hKYMHXCIfZ8tI6jHcTMygp60HPMYEUn7Ijt6v/TX8A==", "I6RQbJDAfzrhdqDiv2f1f4jUWJjJe83ryKgmOrYCx8U=", "GrZolqHflcAgi5kOLGNHBzlKERDLMUu4LgouK0lYruc=", "LGuEKqvrhO3knlWdjuplgpP/S7qTJbWh1MtknTF/RhY=", "FjIa9jhxMowriPRt9DK+mqFLAIuT+FzZcd2YbcFtLjU=", "E9ZHII09vMnfENHuNbWY5sjthWCPgbppUwiOe8bbc+w=", "Acau2p4Ppp9RQ+byLnR7fnTmkrklTVXGG4kEcMvX8Gs=", "KH10pfoDpO1lvUp8ba8DNBj0dMfdm5V78rF5ZcrAJLE=", "J6Qye+sLPgzCGYBbPwXoVL7c2ht8k/EWkf/Wu3al0Ok=", "JxoDoAC/QS5/z+iRi6ponGaCQXgD9bMC8a4waVyOZ3A=", "GkQ2IA5NC+ZdLw9AABV8lX/uUV5ZHItUvNRsAtWZI18=", "G86TlKXa0KTO41uOmbSzwM7gWLiuT94wHDFFpaepTHY=", "KxtP8rwYa33anD4F3Uky845qfASwrwg5RBpZchJdyQI=", "E8h9Dkv6STzCoZexydtJQml5rf7kcUBI2GXU9ulfaZs=", "DoYUltG1TjUwqg3GTGaD7A0BpOPRxp1Q9NZyC5gczWI=", "DbY71G4GvK/7ywPl3T+qiPJqCqpygZjF0JpIP8QZcQA=", "L4/KOkS/nqmUUuGgVYhq98lYULcWIirYnwIZBU1F24c=", "Bbe7PlpOKUY5XR1t3VQb2cFmz6GVbRYXE+fjUPWUfXM=", "IOTmxHpovjF1/PWno/i/ezshmCA7RVLtYguVk7ZuVIM=", "FUoqAjecdpW6R4PhXRChR1YO4rTQOgSguQHa3nLfSGI=", "FW8CyrX7Dn5voMdDv9ZHFuFeXlDhJ3SAWxx03qicU0U=", "HSWCGFVtAVLwo74EKxvRRndKYW/8fnMT6VGbUEExiRI=", "Fgpdo1XUaUEuVTWAT5nfuPqDnXziy3r6UMH9A2IZ9Og=", "FpPAyWuV9wN/r2oYKJgUxoI3hw7clKcsiD6yx1HV7EM=", "Kw3w9GP2nKIGrVxKEV0aaoPV4Kwyi9Ro81gmqWjVcIs=", "GcrSPBSpvtDhWfJQvshlXAcUm7oEFh/gAvdpVMoZK2A=", "JYV+rmvjB7ZTw2pAkKOWPWCEJBDgTFci3+3ij6ZF9U4=", "KayXFJVbepyU55We++uhfASDmte7q9xkO5hArkMVX3I=", "LmN9uth23VKnKE2yZlk6qFsgIL80CAJiXnT0Wizfli0=", "BGjYl3n63tvbTwCThYETxQYDIaqvCCpT1E/HTGXn7oQ=", "CRTO/VGigi78+GKdV+tbbscZWpAId2LsiBTxS95kdSI=", "EgqdPLyli5F/TmERfH/iGQum0jjON0lJd4xAptF2cH0=", "HPHHWhssoJrGVSFcswizns75bXRuy8NLN1g72OBIDV4=", "BRHK3C1DF2mpU9DSNVzdPYwT3KemxbGQBby/PFvPd3A=", "HiqsBj9DA+JKKkSxvtVoikMnk1bceKdy5Nz60FYuXdE=", "Fyo5bUHPsrEkHglqpB86R4gwPYgk1UloceA8uVkPibo=", "C94GgjfMQarbescY1Ma5Fst/Nfs5nrslFTB+YASWni4=", "FSLR+PDLkhSz9mAtn4Z70q4HqPp3rvvDFTr001DZM+4=", "FX1WBTrKLEzTD3ujTl1BuKY2lh73jB3qF1nc6szR7Wk=", "EK/4wPovJfWKKZ4ixzLxuQFhb25LxvY695u5PUX8GI4=", "CpVX03+7Nc4Eby3z2L2c/M7fhe7yVJhD2n8sLjbSveQ=", "B1Ap2DUaSUkXATbeZsF5qNbua1a4lZivGZUo146NLFk=", "KqdnyRE5hpayMC/hWtM+81xsl2GOZy+DeqT9QpMDVc8=", "AU2Zx0F6Mp/2LTKChCHhuKAx0wJCsoXIak9jeV43ZiM=", "GG4beAiUZ0eDEMNeyp0gWMCou44upcMk8TFOR4oSiU4=", "LKkwbvYt+xrVgkSsW9cLC8hPhjaPbJvU4V3a7UMumDg=", "F2MNYwdihYVmHqrulDjGcWD36vbQPTymNk1K3aSb3yc=", "IRh8Hf+udDQKSIzfCM4yIiZUSBZ4CvAWCY2MOcfnLjE=", "AdshC5PDIKGLqxdpruYydr2ZrIkDWw2jJ80Gy3CFSso=", "GLtviYBcG9WdjXrRCdXya00YgT9xzzqrom7olnCUBOE=", "CcCmwtecwGAj8/Qxlsm4pgpVcW0sfKCV2Eml1n/2/pg=", "C+a31s/tlSj00a4wbzE4MG6nyBy/kD6biE6rUITcTBY=", "Fvx8gIVSsTYtinOb/fbG2+cLAGEXgPtIGNQk1eAX7Vw=", "DzGpHm23XfkEvmuxT+cnFCnleH+akY0csSitdqyUiDY=", "IwpmziT+3dRfz8tcp+TvsSRhp8CgtnOnOyUpJdMQ1Ig=", "Be03B+etNHiuUIEmy6J0dDz+hoW0YVP22joLS4PqktA=", "BGXDcNtAuPFLT275E1UMEbyyg5rHB+L+mpwxtDz42Tg=", "hfQriUhzp0UaYP7AU5+f+LLgpJXkPbe5XDp1xXwg7Q==", "Los66TaMnB8VQq5zTNmVhp+BqsZJAvsdNZcCLaCPmTg=", "FhSF1PqGIOb9CbCIFZxOIjFVAZv+nq4o+YcP8ZzP8xQ=", "C25AAznl52wdIA/SeIRZnUc92Y+t6eZIlAgz6jK3VBY=", "Jh7jH61HwNt7wEb3GEN+5Rj+c+ySweIDFV2PKE1EsxA=", "BOEGCJt3bQGihLhK3N26S/DuVsLIWsWEtNk49FAjJS4=", "BLFOifQih97jYUKhdxj3YVeJyfliO1NK/v/PnH4mRJ8=", "HVWRWyC2BTTx2J8vjElWgSP8tMbZGXNz5UZi59nrg7A=", "vwT1t9F4p37jL+VDvkaOHImqRXovTWaZrqdD+ASUuA==", "G7HzHoh2R8tFuLxb4YXiBukazPhuXOW8GzmvEvhX6j4=", "JvC0IUIS6oAwq6dbLraZ6ErfJLxLhWo1IrgsHtyofp0=", "Gtfhxv6t4mnAdrZyObMW58/BlLA2taU/kgf0V1mcX8o=", "EZR87a2FnwL/tLmegQhRL6MlIkrX4bz4KyjGGomEADU=", "HvTwMw1hRCKO9sw27aDReThMTcGFjJXeEtBw0RxDNIw=", "EDGr67Aha+UGwEplFNRx8YsNwbWpthbIekZbaJzRM20=", "I/l+toD1oTs+jarlcqvirA3ZLqq0cwAvBwjmtghLLfg=", "KJsrouPI9mW5Sk1ztb331mh0aKqoTvf24E/hI2WeQbI=", "DUD3E7MbLQQdPgHiUErxACC/xFvVu95PSxM/Y1NgkLU=", "KSBNc86Es/u+BHx0mX7nmfkpI80W7OHrYnXItxZZ8Uk=", "I80UtQ9BKfpWJj/vvnR15RyF9nzfOKmudjetBK1kTGo=", "FgOIe8fmlWrk/1ufRCOyKTq1K2my7AIay5C7bajcOIM=", "ITfZnCQUXlLq0BKbsiBpDF/49tv/dVyEZwVLZFx0sPk=", "Hz1tE0kJao4FlEQ6SHOG+fUbL8Nm6RCplS1PCz2+xBQ=", "IUjhqrPpyCopfQSvgZHisFzscbDNa4tOB5Bh3QDwGgA=", "F/sHIbM3VAYCirbwSIKiAuaAHLu7ULrcvV12DVnmDFQ=", "BE+K3jNFVM1hB0OquroRluABBudUz/iwiKxponPtB00=", "LhDnTTBnlmH8Oslgt8lny8UAKdLqRjq471VjPMVAUkM=", "HkQDCDJSbOMtVAxc3S3vf5AFCbyAGf7F44hIs1dtuo4=", "LBe9evRj1S0/1+hyPREHg2lWHKPE7OSPEpitq+fIIuA="], ["EjmS3zudqmUTnsE/u1L300jhNDM2hMFZb+sOjYw61ZY=", "L6RvXbqZCc6ZhKAeKvMLVQ3+yXi+krSRGaOVnH9iNwM=", "Idj5TTvZjwtjp6rLF1ssyhOy3YqM9o/DbZSuKUAbLSw=", "GowGxhBG4Pjcajm8V66g0H/X2zTmj3NXnaieEWr4frg=", "KYzXBG9YwMq3dSOlim/f0UAbieeuXu9JlEQtFn960dM=", "DqxzeWZxXfSiCzGraT7ahqB/PoMPykdaZXTWf8Xxn2M=", "Brm3GLs7bUXgy+bV2aLwlqd76wVoIXUNByJirypwoz4=", "C8za1uix/fuoRqlVP8eQWz+W5DXWU+7DlyVl4fu8MCo=", "IcLf4g3FpyFnu6vdlaGMFH+Eg8t8Di5oSh7kAS9L2S4=", "JK1rJ1Wmpu5R2S+jDfJIkyDlCoznEyUEzsow6UgAebA=", "BnpG/ExSxuoQLNN7RHj9vbXnSYd+xDe8t6y/tk5h7Mo=", "GiYjl1ZS1Hb0ucrcS4UhkmiRDHw7LQrhL9R+sWIlfzU=", "Al+M4wRBzobmsh1SyodGPOwpmj71QyINcrwkkf3ATEs=", "Gs3wtI2KR4mps6xf+JYrFumlbIgOIjZoolAYZXg0ql0=", "FNP6fuHNK4vi9C629LlbuLHRVtd/FD+uPoK7jFYQ6nc=", "A6Ik9kcKZPKU+k3WdSTeWLGPcIEuCTwOHAazHXWKET8=", "LIIq6nFAKAfsIdsRoIlmj84ubC0jF03j62lISlMUhSc=", "EwW2bokOl+EdUncaYFCQJrrt0OC9XnlxNCWcdIoomZU=", "Kx6AvF4/VG9LETmed6B4TrfEOcVG6fuibrbHfYnBRRc=", "FWIyaosNVDa9e9Fz0/nmnDvnTceScLT7HoU51YTqwdE=", "CMmsqJtEfnRovx6m2wgDRramgn7/H7gTks3n9hMJELQ=", "E44ALowMWXVQtyrL/JxQlSF1uoXAYbfpc9h9l5R2tUs=", "AxfuQ+b044eWghrS1VhE0BK/xcK5kPpItJHvfGNyvcM=", "G2CDH8EVIdEi2c3G/0XHAF5qFmcX56oWhcsobJ7MmSs=", "LnPTXrqbQ6UQDeF7ulxZ2HH/oqm1IrBkXig6iSWdRG8=", "IqTTy3dQ5fTS8DgSlFePaYvn1ngxFZV5P/bx7j7/LfQ=", "JHG3qWmvKVudQHY0pIahyCzCc1BtianNXIClO0Dhk18=", "AZe3Ph15KhBkUqw9Mf0CteFhf1RC/ia+9f/9t+FJd1Q=", "Cy33M7NUHHiDYqXev4GKCHvZyanTnB/PJWStOYC66Pg=", "HMZuooWzwJy0ZTKDucbuZrfno8riDNUDFdr+OpIROiw=", "AlthUrqevoNsL1Z50PiRswuWrj4GphMtovb20hL8S1I=", "GoiaoWRhNwpOdepr9/+UBcKWVilZlrC1iEIWMR7P16I=", "H2+vQc9wjYMHRCpRlMHTjcPoM8zE7N/biqRMXp/OVm4=", "FwIh41/gTaIwPeoUERP3cRxlHcpXvrf6NiTSiBCF19M=", "H0/SVDQPlQn8HOByv3lcmrz+3V+ArY6+onJr5HQZexs=", "K7T6ac1jHVtBiDe5FV2wLVSJ5/65Ky61oXvugDEFh4A=", "L8c3pMEHPAGEMs0PnovFt1wZ+U9VQxQlHVEPx4i3nV8=", "KZ040WgDYWqQZdGCDiuGCCgOgVf36e9blU6z0r6yZG4=", "Buj6ZPb54qZmUODwArKvp+DCya5BcHLGi48fMbIXvWc=", "FR4u/6Du964olFBgF59Kr9o6UGNb47PP1CUrXsnClEk=", "E/Il/yIHic89lUfxX/X2vWsFdXBjbiXL/657cH1rOms=", "B18NWy867x5yy+DQtAZQXsmgwrYfN6wPrIK0TZ/dX3k=", "Am9JG2XvGP/SOCxE7VBqUGo3WpBJ4vb6OSqDfzAExQ0=", "AmkWxGCw4tVpeRTRZS+8PaJRebAQoRWOVG3oUCB0KuI=", "F44nCww1xa3jRX+lmFwSlfZNRYoqJf6EnH61tL/IE0g=", "ErX7fhiU2Eb/OZmz+RBTKanMRZ1bYF7QDzM9p7ITCQU=", "E49C9PAfSwWc1svWr6Gq1EPymJPiQxPS/TsOYaN4z6I=", "CvaKK7X5tvtJI1a/aoD0BzAFa/HYVCRhSulwPr0groc=", "BxGh+Ejvt9ICBo0VrRglcgwrgrshFLyIQEO8ONcn9rM=", "D3J1s6/hWP3lg2elA2/Sbq24zRxkavtN6mT78dgOH1A=", "BFWsuix3vjpRj8ZPeXfuPGRrMLU0KUcm7IlpdtahZSk=", "C9Jh0dRsmf67LLG9cKyPvgEpUovgWfznXNujKPc9c0g=", "LlrusE37v1/DXds3ElSb6OZD6hQp+gAIcq8u1QAVJxk=", "HIauZMRopFLowcLVIIum4XN4zDI3OApIJ5iJvOqszL0=", "KsydFWYwJ/xbT6Rn5ww7R28qB6bqWFyvcoeSEQBWekA=", "Iw0Dvob+kRQUUxJgV3Pcr99xuX2OLPnp7yRhBrX7FFk=", "KrYKQVTiJhxuToKyC+Pgj3YTzTNNuuKVhuSMHfSa1ZI=", "IyiqY2nwr3Nqus4/eIXX3FZsOe+DFQgXjm1ivUOAz8E=", "EWS43OfkF57A4pTaVuWrQ94sIKddV7jlg//qI0nmJTk=", "JJHNbyNBYGPncXEJXA2yFySKLACtw+FGujLZrCuUF0I=", "HNyEjTU/x3LeFR+GVqfi4kt/2jhVaNZZb+gaMD6iCPQ=", "AqOY647E072ZvcNSDbc0GUbU7tOhb2+u3xZ5BeZVKIQ=", "Cwf3PMhDLh+eQJXjkjWf1GRn+b/z4kr1vEy+mxe0PmI=", "BOlkrV3tJ0lA/meOT3IHnrsJ8om4OBv6cdfI7wYFlUs=", "DbKjqrMmwTRHcfTF+HKgUEZfh0aconcE/ZPvP+WlodY=", "J7BE/v2S2olypgsCl/m5PykXhqdJ/vHin4zPa/3nJWQ=", "DGwL9ezgu5vgc34MlPmxBZRInuXABnblHzF4EVXuhyk=", "CjbIr5MXgayxHMaSLwv24ozgGhoY7pkNo0IaCprqAUc=", "JV92IE5hN6wSrldv3Em6oFS6GCZ411oKPOvQHQzWwoY=", "CqMaaBF/Ih++G2Cdjiaem6HprCKOLgpRKrnHdKOmP3k=", "FBUTEOZWZEyGpc2nYgxkQK0rsJaIxwUwweusYNltVrU=", "J7lTsd4OMKGkI0BbdJ2DAoW/6ilM+h0+EbTMWAGqpkA=", "MEdrdg8LRatOW3vr7yzOr7KwbztBk/uZOMlGxjEVsAg=", "C3D/oA+Xo3eZBUTZUBYCN275pJarjfxEhWMGvyihuSA=", "KGGtuQZ/RG20Wza/k6tjRfU+B3RsBjVG32kWBOwCZSk=", "Az6bQnTDV6jG3WGj4wI2c1taI/OWrLUtktZoWl8D72c=", "KLTlBdUwnimm2o+U/ewDmsRLQxELwPi83kK9gz37DTE=", "D2+uESKyGe4LFnXui7XHxIdElU49ri+dXR6nHA7bCpw=", "ArQXO71ULxuJ/o00eKBQ6B1C+klenJavJjquo8SY6Rc=", "CNcvXwFqspORNE8guCFFDakS/wFuTaZ0/5fF2SvToaE=", "HZ44eZg3fZ5oCwtV6DCfuKKXGVUd54PBz4F8/5rWqQs=", "FCTirPXbDZGVbhXVtdxBMq1sT7hjycjlcrtJ/u6/fiI=", "Cz2zTkJTVYd5ZpuEnvL6tV/8ZU1Pn3cPdMvEW6EX9IM=", "EmmGHEnX83E2c/b+xLV0NskFmqELVB1krr28EeZRP2o=", "JVe3oxhoFmSsJ8SDSbG19EiS5a0CyLgUk0GL3GZRc0I=", "BlDc1NNhCx13bWcwJOZ5tsdrXN4LmFCRugDhz06yYGI=", "6udzEqc9w+yyQxQ7pk98/clGXPAPsIcpWChkMP1Bqg==", "D0PZnxC7fI2FE4T1IVvNvJBIm9Y8m0+j7Ei/GFEBLZM=", "LZW9BB0bVSL+2COl2dYH16/UVUYfM7yMFATvNIIhq7g=", "L9g/UZWXt+gHq4D9hwHco/QIWVe48pVfXfecJPAKH1M=", "JcDJq9V2yAPkIu7Nd6PKT2OjK5+Q9TZu03ZY7qhvJx0=", "AxUJvemnKG7tFeojU3rHLfzDWp9MjNySuvOd18ykk5s=", "L2aS6fv6CtZLP3SEJc5Dw8acteTBOg/wbBTyu3UUGvA=", "GqN1yHmWbL2H1M5wieNUeGxvKljia5fHYN+vty35xes=", "LxS68XkjZaR2xMGTk5JEpqTt819BYWu220sr9RFkKiM=", "DBVSURoxhdlzDZrTqGxtzmKfWHHX6co4OZdYtYeDDs4=", "CkmRY7iEtnQCBY4TkQ0ciYc8lS6hp9Gj7v6qItKjfX8=", "LP2txGNNyHXkwr4PV5doyFsy5aGbrztdU2o9EKMZm/4=", "K6mBizXbGMt2MRZGh8WTybray1O/cgYHtGISMwvkIMo=", "DjewrnMGDcK19nHifhSnzb9vN7egPmllS+51qfvVLGo=", "/c4vw6daOB9t2EtMpfl1Ol8Pi+v1y25gbFlxeqe4FA==", "D7Wi3cAwQd/7gIoQh31DfCdkJAlkwu39vlRYVKrigq8=", "HqQDCQC590wzpTqVDSH0BziBP2nouvRERNbwoTaMbYU=", "KyauUrv31Bpm2YTuN6QMlRKcSUnMdO3kD9ffPzv8dxQ=", "FgYuqPnD0byazs4+OvrZYer3ZQaXc+Z5JA3XI91FMPo=", "B4gwVz+rNqR3e02CwESmDQb8KryqwYJv/9LOBjDQDrA=", "AvF/2+7arlTRQJxc7io/Pe0AX7b4TbjrYAERZ55HG+g=", "GgGwxbIJr5DjV5nPYwRBsP44OUMAodva336AIwQlzgM=", "D6IKJqaVDQMeIMn+GfExfA5pTrQ5eiX9+XlGv9ZuUZg=", "G2OGnidJJuoukcD6CRtwdNX8/ZmH6IdhTahu69a0LB0=", "BygEMyhVcDjnNw3ZhKgiBQGZGTp9qcCmcK96+QlDgtA=", "CVcKf3oGECtVvPzf9kxCzyrplKICVAVKvs9mCTGLNwc=", "AcL/I/1tAJAWHbVKmYEPdux2fi226DCvyaq96WFIKeY=", "B/r32AdS9QHPDszGvaAc00k3YzDfeZyoQu1PRSUX9v0=", "KiXckNReNrk2fSB+Rb441EkDQjHtfGQi0nlbrtngjT8=", "BdbQjkDSdBvDGM/dlh5ivVsUORRSBvSa6w6LtookSFE=", "Cdez+KRvAws7Cye9x32ZDMZC5PPdZnsIXvEU0Iu9qfA=", "LReWDs0GcGw33c2tXkcH3cA4XYg/CP58izZlnZTvhbE=", "FfJHFWSEihYyBLB0wdukxRix6aQFKjp+XZwqDnfo6pk=", "C8KdZEQF0M8+8YsxFHS49tDlu5hWBZ6muQjY6ru+Sj8=", "HzzCuaZmyl2ri8F0NnYt7ODqbvO+zzkhSZJifUlZXuI=", "DFx+wLcseUf34RKRkaEepcLSGkMVYbPuFRPQ/ge2tdE=", "GwKwL4VHv2LAJQYi/b9sCUkJ/CUVHDlBtcjC4G1nW+I=", "DTITtzIQm+6vECs1nbIk2GAx6iu+FAb3C2VOupgKuEw=", "FYSOzyHmDD7B70WZh3cgK3CEJqcrA/jcTlaW3HTu/Iw=", "FNv276fK7Sz57GmNuX51UsYrOGo0g6w5Aovp+11uOww=", "JhYSa3RsPYpNzcvubUu4xat6OsjFxbkaZUdHEZvHCuQ=", "GR/hI5bvwj74hl4ykI12wJqw/lKkZlVUAgt7plk4Ypc="], ["IIjOlTRXe/OL57xFfydW1VjWbgwHucwAGlgL1CzaDnc=", "G4bmOQjEsSr0POxoEDVslNIcnjfXPf/5dCpY4Ow1a+E=", "CcoCK6EULRcPdVIS4u3J0KSs4z4Wgl9UDV1Q1aAhoWk=", "J35p1HoTOAQkH2rr6USb5uIshJxtitjJOOr2E7wa7NQ=", "F7V+oDdU4krg70Jaoq2TGqybpUV6GM7FlFRaI122smk=", "EcdAmDOV4PSgJuLHyTkjY3XJB3dV6xo3p31aH9dKusY=", "HNhVKQEN1+L7fqQDUVurVydVakecWbgi78WoHrN7xb0=", "LLk1QALOxLy/qYXeNPQ9cCztg9GXqjdLWh+W+HsS8pI=", "H3r5jgj2h3kj8no9rUDFJaxS9W+72HhQZUT5rNYaoy0=", "GguAfeVe8SY8t01z8ci/NAO7Px4DzFAqniuNQjaI7Bg=", "H9WaSTrwH1OOrumxy8ss0beZ1gk/AVkQc0QEfCFY2Q0=", "HT+kwE1U5SY+dDovoBA3AJh3OFN3e3PHySr2TuoHlhI=", "HciSqNAG6bmdWX9EnQVT67UbJZMZq52LLQLtnGWCwjI=", "KgU3N53Kt22TCNJpng6QAQkxinQMdbjuG6cRIO2/4HE=", "FJ0syJLny8H0ECSTu5a0o2ko3PYvfbptng1Eb1/9T6E=", "Hknydxt1EK6nfuAA51esEFaZxiozpBjr2lcpaQN7W8g=", "BWSf+/SKFdOThctikSvwSelwYVX/PdQ/fODkyzXIbD0=", "JpizWbuzaGtiaDHVlvxbUDn0r1FrxoOiiYdice1iiXs=", "zYwI78XSvGJ+5yfawyWvmbT3KscPYciQsFk+sDyM0g==", "A2qamtMnqnAjLP5seIhOwjrqcDgUxwGhhieJNntFs/U=", "K1iZ0DiiNIJHRtaX04/0I0Wfe9QBV4L1KKNwWm8v658=", "JSS9ehlpdEFo8RqgP6gtoDTtzRwxFBQgsjCTRNJ0Gu8=", "CJGJVwWTZ52jW2aL1bNUJIm6sQIt15DKapnAntCnmso=", "BmCJcKScDqZfIaVEwhXr2JtAI8OH6DOex8nLgLa4euQ=", "KDpjNtgeAujc+9S+Z/zX+Lc8/0zj+KfzRRsm6BZ5MJ0=", "FFNuob1Dr015JwVOzcliVj9vOW43LzXK4OUhjWK/9FQ=", "MDauP0zvikoKMk9AnykMFy5ewjo0911XIzoEoFVkjgA=", "IiYtmhywtZQbPxk8OBQDQluD5v2eG02TAYMUjkFNuZ0=", "FVXkcmz1140Rtm9JaXJOZL6NwwR9CVOqhL5CxKOrQJg=", "Kj6eUqwfpJFeJiQGwnzs8ksEEfpnTqUEasRIl2KehUQ=", "FNiryXAGJL/FSTn/ZPdeCtGHZi3dAhXjz/9Wo1A3EjE=", "Hg62hbVhvcxst5NQSkwbUFavM9329ek8cjlvblPuqqU=", "Ln4UbZERwR2TSOwiMCcL8hG0Mlwuh40J+u3vmLzRDb0=", "GMA2755XM2l1WvMxQruFZDf2SY+xFiuPivRSPDkLCbI=", "GVzjg89bTmWs2zANbjWTIOprrI+ogUVsclJrRRPuHXE=", "DBKGCyktIuVSDUFkJ+H/gO7u7kd5mzIuBYDC1F1g5qw=", "L/c7hZ9oybjqqUB4VF9U3R6d/XT912LdZfUirxnsP/4=", "EgXcRhVdnMIqieg4/xpGJzjT7xlyoBhkxyrw80LlJP8=", "D+y2gP8ZsSTOdFtvcPuhuRcW4S9mT+k1Ytk3AK3wvEU=", "I0ORt4b5SY2yaAxueqv0sKzg8DaOIe/5RSjQURKMvGo=", "KTfa2J4r8S+VzOcNvjukwu4BhCJjh0Ib0YA4iUzq7ck=", "IsermpEsKqkuKv1HSecJaDIvfldQzmxpfcs0RGECuFo=", "G92CQcyRzwkXgDKOpqDKba6MEMUHlgBtRiRVuQ5/YA4=", "BJ4+tNO9uOo/tuw9wGVVbqzhinGYZBhLNtqDW/Po3hE=", "IKhhHuOpGhUT4RrpYuyCiEuiTzIXGTmJKjTsbUYiqIs=", "J9KB9IIVS1wAHKODoQh7sUgXgvK7RX+zJQX/YzFew3Y=", "BTDF7kW2sWq8gwbrvxAqHAd0+GGGmSeNXTqZ9CSVo/A=", "JW9ALsFzIoiirif1ai/uIZm95nyikXmE4qbH85UqjjI=", "DtVEvTAdM9S57zWd478B5hOX8vKZEZRMXQkd28UY4UY=", "E3D/uwI9Zu5i7DiV9h3nMhIgergxlL9ssdSdN73U800=", "KkbVU4pam9r0fkRZTzCSES51XN3hpsEoVomUoEDpoE4=", "HzOW19sxwZERBpE17y0JXBqvvix218w4eUSy8TftumQ=", "Il8yA/7Za4RnJMFGs9OzUdZhXuXLHfg5CgKnFe4gbxg=", "tAXaNRDnq+dZKYE31IU/ZR41t2YAKNnOaA7ynbTCKw==", "Fi352c+HSoljDZBhYKvRFLCSdMAQY2xEDDdztfASN0w=", "JjSdB9v+hi9HOT01RJHf/Y7Va8wUJNRdwykmab6M4NM=", "GnWg69Ar1gv4UeDMVkoHylFF1Oy5cGJazH8iVIDimQM=", "Itw1MW00Mk3E/EgSskRoozuUvRGH/eQJJnDXifg3K6A=", "HyYMIGjd00S/j9DZha2ZngoqCzRbXU4VZHxgoAGd3rk=", "BDCYkG9guouWTD0zhUvqO/xyjr03S4cetxbhvuj2+oE=", "F/wGAl99ATKRL2zRibdYReio6+Jko1YWEOwttMsi+AA=", "GFNQG2oiI3z3kPZNWS5Gt2vXjXpuEahqXpZL/fmLNfg=", "E/hahgwyjX/paXD7sT2sGSMwZ7GG3cqB97gF3H6NTeA=", "JVOFii397iVW0kkjxgnrO9kuWPHKscQGMXAZ3wvd+8c=", "AY25XfHvXKwfTV4h3YHk59T7+Y3u8ym6w+R0Sy9yzC0=", "IYz6QAoAPaaf85b5ovsoLVRKQ2l7aPxrrMzNnPmTOTk=", "FbGSr9r3zMRhIJEnuVZHzWYcNwRGQvAgfMnMaZ7oo/o=", "D6Khk8yK3a33dm1xLHrxAHS8gUlGDuNbXHjRXPUnA04=", "BvPdQd1KlGWGKPp8/BfrAkpZzqzZ7w/AYX8nXNncD8U=", "B6nL9GYROHztGxjE83HVgs17BaUMr34jCjtfyeAouuI=", "E1+YhxV3xeY45WMlN3ch+8vVkNhek+0xD8HAyALdBqA=", "6PitpP/+Cmufr/F/apJvKP/DjZWN3yWd30CQCDvWbg==", "Il32qpvEnpsvXI3IHhXJHsEGTbIBvmM/Hl/Oa8W5tqA=", "Fxw79/RbpXGTCZHmPcj02CPqHYhTV6N/eCUnTpueDUA=", "FxIHdh9NccXV+mI1KzBtqQLwJZ9MBHC8gkCRRP65rPM=", "JqiAWQCmCH9NkWxfi3UqsyEQI9cwocX3RdkSL9nBmXM=", "EpQz1qtaj1RDSJw1e2m8DCfKxq48JJl+Vyj/x2Q51bk=", "HAwCvZpPejb8Ktk4+adCwK9dd0Xx8KxbZkqj5AV6bxg=", "Fl/3MJwZrfzI7m3fdS+U+lwkvQ4+vbrHLB+wau9W37A=", "JrOH0tzaWs/kiHLxyQdwgwQ5gaTSLsNhgwSJzLSdOEw=", "E29zsgBmv5u2KeFNyFJOYCbBWQWf2/URYAZu98QWvkw=", "KrS4bnzeOYLS6II1wxLRQT2F5p0/XVG/+X+FIb18NbA=", "Fas7983YlEUB1Pbh+/m8xlDFt6loYPdc4I9SmaVg48o=", "BjdXse4BGQsYqqkHjObFm0/5eaQ4l/esQfZnrBMAxSI=", "ByNdXIlzJ7my3qQ6nJJNY63wliyAJOlIazHH99yT+T0=", "DHk+CV8k+XMAKUuQ+cc0JBUJrjGsDhP58d9G4P5Tf4w=", "FsRhE14UPG+wjZwz/jhbDHoBK8II+mZx5GGVNLPnMTk=", "A2laP8tvN3jdSITa1i5OhsdQ4o0U+zHNWVZ+Ou/Q+3E=", "F1AfAS9UxPGWqjHL2RuxJsJU9VPlXUq4RPTUxonRofs=", "IP+MJwFyPr4RTZMtSF+0r5r2QeUsqw1TkNtNxiQpXNg=", "BgXUgkPiHP7x7ZEw9YRKDBTHkGJLk+yYkw0lDBtBC78=", "D/oDKrm2M9NJCbt0ikmNHXb4IFeXPsyun8+sRfUOpuY=", "IC2W8W9idhKfg1/MyD9S5MwafV8qwyrkNj6UIfZwS+s=", "CX4/1NNb0TlM1ILC/kvDwCiB5FKtv1iFiiQQahy/CtY=", "J3woR66MpkRGydBOK+RbeGpP/cfdHSfWvJeNuFrIWsg=", "A0EKp6IDjXXTMIKl/WvXfQGFeK1/up93EuT0Hn05fm8=", "D/AvHXnUEMgo3UTGM4wxBIzteciq28Ra/kVZ2r7AKYE=", "BJ54H0ZuJWG5LUWkD7dgJa+xcys5pI264cVUInKx4SY=", "CojEmlhZFKGtmYBdqd7IUP/7K72mT3tQlRamcTuIQoY=", "BF57xL7scQey7fJkn5goY8bhBliViBiesMneSw4DkBc=", "CCiuomO59dsjn5xJ42oujNyONI9YkEE44InPy4Rwrls=", "JTlV8QWKM4e0CYHN+zO3RiOBejiUtRCH0/mks51xahA=", "F3xpvD33pGPE0msGVWJGHvHK/5yS07sUPOKym+E7IzY=", "FNYGjDm5e5oQPLDUDpqL8+96bHvR1iLX2le3oiyx36s=", "Jd0rV7R5n2EQNm4LrqZlqkIyUBlYG4kB/K94hktR8Qc=", "MF7HWPpuu+XOULsvFuwA0EMBM6Df1M15wS1p+MwOjsM=", "EawKgAnOJ9PiGD4x3QF1+BKEs3yfbnFOgt50aWnJiGU=", "HRCbi2j0QqCaBixaZjoJNalqkSGVh+/PPpXwqik1eOU=", "DHsKEE5APa3IDu9V1o/VbVau/8QL7a1PRLLr54DQiuE=", "GAdlSEH/ty57BGlCwAgNl/QxkcbS54tw5p/4ZwFc+ng=", "G2PaGpntkPQLApIYDbp4tuCUVLdb3mSsnlzK8rK2QEM=", "1+XE0yG8bRgBBOahNEULimIDTpjXLJMYxhF2RTyW1A==", "LiUqOXvfG1NUcjnjxum7UmDBkFkwZE4imF9B62oib00=", "C+Ppsair24iTda5gguFON73SG44qZ16lZibp9LnVfIE=", "FhtSkEqZjwPqYq5ntWHx10gEzhVPkoweCGcx1o77UhM=", "CFL1ZnL8BsvnJgNmF+/SELgCXIW5Z2bpWSXhfwhWSv8=", "IcToc9jQOvmJ8i2+T6CmryqHGdKJcHrlBrOVGDSbbL8=", "GsQaRDFO4YufnU/cpYKgUsm2nAkwmuRHQEs7pYEEWB4=", "DuMzupNEQuSYzt5mCaGCj/zpTPB/p7FMHJkYia0USNk=", "KZbGjQB+qNFsAU/bMxkPpY7l3nk/B/5EE+46T8pDRm8=", "I/Z4si/sJbo1fMBo6yWfEUdUplR3Aiq+JM0HUHgl/Bc=", "H2yCcUKIVJ2kZGU0VHGJNJ7JCKovoCcp6XnfaliChVs=", "H4GOdLnDpJC2EpJr/onnlHFo00PHgISjvt93EhYBQ1Q=", "IGgzQ17EmIdy7h8Ou5MTMZyyQ3BcExPeYD/fYaMj7wQ=", "FxeFsDEE3xWmMqr03Hy3rPR5NMcsljEPE0JQCAUSDRE=", "ILc2OJHNNYnv6Dq7kdny5sWbV1uNOtpsbMhPrwZ2PbA=", "AtYGCbxoXQklzexveNcx3woEBjinVNpVW4v+JlNqMl0=", "GpGXmrOtNAGHLSELO0E0fUQxLl1Y3wwSF4gdVEujAas=", "FmVG02TkIFDyw50ZbdQYmugkpXDTnAKuaoXYKwBBm/w=", "GsIIn3SqfWG3xExX67tnUb5MiiKy+C8TtROVm8LyAMk=", "CQjKhkoEvPZ326PNJyxqF3DnqcY4Hu2/nwSRsCgA/w4=", "JLyKhm2be+2SQu1qSCJS23fp2DrOYGKTGTmUqqEm5y8=", "F6M7TUoIIRdsQGtHnjjagNJlIv7Akx8hjI5U4mmw/6w=", "EtbRefGL9sbBNmECbA/c/uWWrwglRfMpngWop4v/Lig=", "Fcf7n8+PGpLPDGd/5Yt5BlpaUC13isaWfAIvbzETJAU="], ["DhliwjL9Cmu1StiWKoK5g4z+8Z0pClX8SdbevQYc0vY=", "AeH0XP8+dBaKzNCpRTb8pjFxKJU+tH2NLXm4R7NVz1E=", "E2fuw7IMt0lTYY/ZJhBHdV73+Krl/+lvyPfZoC43vRo=", "L/atQFM6+irLeMm5FlDXzL0nSwn3jBAEefOk1ylW1wY=", "FSyMPZ5D2QrYCUgxp0r4FR/c2gsY172DdP/aaNGl/HE=", "JBcH2yb5bfUCNk0mcSx/Rl0KxVl6MJVZsHVAY1GiCXc=", "FaTkcooZfa5jA9DN0rbR5BFKn604pTC8pv0Gyh/8H1Y=", "DL/WPzY5eMOH1lbpPxHjNph6aHSMj1TzhYh+ZLEHVZg=", "H7WUR0uDNPmupv5eMj+w4Kwn0olZIaxk6T5STk/9JcQ=", "BaxVNh2pMcG0xWCqjbq8hiS6IlhxvOIkrdta+QFnaus=", "DnJm+Qk5W11C7CmK0+tz9sERSfSRFk+ZfqdrZCgrmvU=", "HZKM6RbsAXiiwNiokK+QRoyK9oxMEoxo8ELK1RxteJU=", "EVIeN48imEQmNBD+RGKPyp/60X6umWXe6QDvFKTS1tI=", "I/PqO1WtNxCgBS16S5yaZUVu9xvE6xbB6QgDSzzTstA=", "DU+XLnlbvKhiO7CFA3ZKkOQ4S+ZE9XtKVvHn4VSJIr8=", "KlPmDsucAN2ZaS1X16VNiTk0RoIDmVJn6DlUhZ0htZU=", "GFg7sKg60ucQNpR1vVSuHYIddanh6HDfEcFU9BvhpjI=", "DUVojcmG945xxGO3btLAVogcdtxVLM+NOh15XXaC77I=", "FEglaDCredJhjG68WvViT9Bk4qFhlOWgw1x2/LCU03E=", "DAx5Er9nwnO6riZcaPN4o/wG7td3i6atMYFCi9VaFIo=", "CQDPxxXtsQnT5sAreleDJvV+/rPab1jmR5Lco0UqVfk=", "C4S4UdnQ1iHrKHL9dbhIrWqQWRGpiLRqPQ1w0mTIeQo=", "BpuBBbxgvuEwl8D7FNBaG5MtN9twP2/1V2db+72opbA=", "CgrQgqYiaEAzRSQCLh08cWhCNEnfnC/8tEzZ1NIwIyU=", "GMNQUAp7uf7MBLKG7g6+ds9xKBtEY9u8+OJmIhgX0yw=", "LaMXxFnAsNlz4EvMqcEScmx2GM6XYMIijDCLdDPZB6A=", "IyoH0a73nBET4//nCUrDec1nxBmBudvTDcaR7d7dvG8=", "BvjruMsEbAqn6nlXRM77yCflcn3RbQ8nZ12Z+JZEkso=", "ENt4g30GUlhq+gZmtyHhyUGAFzGDMAmSxGAsjBxBVHg=", "EvX7d3j7K44bXsMG09jypJfuTpqlvxkkppTQTK3VxSY=", "9qlL9mEh1Zk5MpiGNtCqJHngKZr/LOpbfvwxGhUAfQ==", "GLgYocJQ1vi3eHDB71lCJQIUZVRg5LWqCcgGZIkEFzI=", "DSUYX9tKPGXgWWO4AxBYTypgacLAsHqytt8tBL6g9So=", "BjZm9xnJ2s0/85WZkmgCvZ4HxhBQsQ7nmt8NoExZ6OI=", "Jfni5HZs9Le/kaY/fb6VSy/6TO5yaZMxNLUwnq+dcC4=", "Ejeiv+fvyFP8TpxPuE2OfFaxJShti8gaVDTG2HNyBtM=", "AUmxeSGmDwJVGgPr3Qo6cfcEjQ+fR4kwdcYlNBrgYVk=", "IeEp7gUtpFfpTL3BrFc4qzAKq7dqPMPCNjfLYiGHRjA=", "D/vM+BjMz0e+3fhVi4JCyQ5B+2A/E3sC8HdCKNaXjZQ=", "EwGMZAcr2gNs5lMQUB71eBbTl6nrpW+HtWAkusXr6eY=", "GwCfLoq8A/SY/bhIV8IJG7sAlXePmQ/nmdDyyX4sJnA=", "EBVG/bcfMpkcEYDMB+rs9HkgzQcEaR5VWzvETeXFKJ8=", "HR9mouwGIfIpw/jMexU2g9mT4iDsWh8B1CoU20anhcc=", "DA0NjHn3b2LrjqeFhT7mrqrFklYXKhRHnTQQHcjmOtA=", "Cj8Dil83Bzwep6Tt/B3LYIWcEhjh+2EbpZ3SRTmclXI=", "C36Jq69pev6iq3k/fLw+gH26RSMdT75rZXqV8D8bFwU=", "CRxHoiv76MwGf3ABnqGi6qmzgf35D/qJcbJHgSuXf2w=", "I1AmGeNHVTtbvYhroOuvS2PAfCidoHsMdyj71gkiQdE=", "L11SgXSb6QEZNU51HqEm5XjMxDpMNy1nrmbYfAwBM2s=", "HOaFW124DEKXHMUsnDUnXov8dwVoSjkbzkFRrZ/Nm+c=", "BPA/I1BdbhF2A1EO8lv0beRLlVBgEbVkKxILdsSnonc=", "AvDzam7Nj1OvlbS5UUmXrgogjYnpdL0zWd2Y/i4rPUE=", "HPPE/5q1idClZguGtf34847Dyl6SxEW9TPvmxw3mSSk=", "DZB+FFEGEfwUYS5AZhbPzAs7ElgnjYAqWj1914UoTmM=", "AUhXX9mEz4TQ89u0lWSzl8F6yBfm/+NIiBMhznbjXEQ=", "E8MsJoicu/qvTR8l5kvLcg4cykUxL5D73qhDXZ5nKa8=", "Lyj3AtaEGYEU5yHvr7aSLDpC3Qj7sf1oMZAt9LVaapY=", "Bf2R7AVIAPYe4Si7y+My7ExOslvFd4HENskx1aRLY2c=", "KgcTfgIR1ABX051wexd8tXbzOZspuacBnD38fXoi0nw=", "G5WSwaCFJHDl+gRdMnJffOF5glBaozF6fapssx4+NZw=", "DP0wU4fNpCofWo4AoO9ShuBQRzgHPcyHE6Q8JDnBcME=", "LhDGKxtVZrUEfxgnn0aABzSUKQWExpcIVTx3KbagTak=", "K7FlOlYiHGJjsMYquKCnc9IltBSphJlLbT1a/QiS5n0=", "DycKuJvSIN32Lxj9+NJ49ng3nnthYAaovq2frJ9HPHA=", "ChMB4sGJIIUTZzuI1rMjh1lIj3m5mnndEdC9HJc7laY=", "JMsC/DSoznXuz1NBhNc3O34ckPtffiT76OyOoe9U45M=", "FgMWVTf9ouQxt10D3wHe57Of2FGkciQ9zrwsltDe/1Q=", "KHFm2HeQ9c9UDs/7G/Zaza8YzEak8RZLW8B3gCLhGhg=", "AqgcmYuvhHu7Ife3FB7+hPesVqg0x5Z+pvRUKfovsaU=", "IMlcR8LOF2pQD8GOW3mOv0306r66HWlf4hfgA6wvDhA=", "BUz+I5tG1JuvRWgIinKyv+0Hc74n9ufposArux/6UVs=", "CHdFZDkvupoCib0gErUJvMexJtnvM3jaB2nYrzfLRMc=", "JKfyFpg3MsEa0wFTgYQQDiywkHQt2BwJeDkYQE8cdTg=", "D6+lI8qd63WMxcD1TkhZGaOxxsqrbzIqNrAUghx0ZFw=", "DIsR8zGhfYOEixDvtvhxa6qS5knZ7hyVhLM00DeLUxg=", "Av6LilI6CMLl6nYAt4dvpLdZOP1WwDx07itgudHoKZo=", "HQOa2KzGyVFcS0p48bioV4TCh9X6DszvQ5AUNcHEGUI=", "G4khfFEEN0wLdKOj7glxylg/WdCYDDdWbvjvNjsaQXo=", "IotNBlvYTWEE44KMrtBv6aoR192OqQ7+/ChIkzBnSy0=", "HVf2TKb7Jdmktlc2aD3G+PkLTVWU/P/WA0RD6Yczr3I=", "Eezlu7u2EZaK1ktS2J165dHuvEFpIX4HuZ39/qD7adg=", "Icovt7GGl0tLtn+V+UOget9mLrAsc5LZ9edSZ2TnuYY=", "H0cTjYM7DIz2KU73fQ6+3pTqV6KKwKPmS8td+RMg8Qo=", "C5W+XK0xsGypfKdCidiXcqqw6AB9BVgijYjxE2ShSWw=", "B5SkjW0CAdSzr4bA/NVHk5H5j3ViMQXz4mbd4hXXYVc=", "JFWgPoM7Ha+hfymnH9dvlNjF0J+h+xZlNz1Qmojzdj4=", "B5nqk9eBw13qS0h/mEn/GADxtjzJeELi/eafVHu3Z2M=", "KP0HDjSdUGlCzCF6UAZM+y4+u9PN4WwJ/Wi35OqxuCI=", "HPUAHJz87oUvy5+NieGeM226lb7FRUEPRDW1sB9LgNM=", "CO38TkmsQEhhB040I3obEk5Njl1szeKdHunAQ3VsRPQ=", "LuW2UkKJzdN85MzI3RnpTNLucv8mS0aARL2oInsRDfw=", "J3WpPis+743Av5vTIuXxQoHrW7v/mM962T019MQ5JiQ=", "BMVk7nShGZRE09xCYekLGIbXYKf6aOuu61teNTaE4ks=", "Jf/nsg6u6PaU+oEDlEC1xj7KHKxxL147Ia8bmnvhF60=", "FKEDU2gJMGmypDNwJ/ppXphbblbKgY/5RHgMFneoNqo=", "D9U6sfxt75dlHS1m0PWJdrOdB9uMTJrBldsNq3MGAnQ=", "Fkdrw7w2QZORIFG2TJOcAAHpWVPHb3p0iVfXjMyIEEA=", "DFpSM5/YSx7KxKFjs21BlBoVb1OyVZBhYC5k0t0DEDk=", "IbY8MNwLrytx7oa31ckdocF83OvloKDl8shEZYTgXCA=", "G8zKIgmG2Pw9IjkacL+6V1pHtPgyMGUuF3Li3NGgbtY=", "FiqWltbfKhMDjgvG2i9SI5lRogS9BanioJBmz2sTpr8=", "HWYa9L5ZvVPakqzfVzan3OUNp5bDk7TkMAHSf4jVjW8=", "AftD/v9IsKTlrJsXpsk+JB8Xtd/HZSO2XcNmvATJ8Gs=", "HnCvXSif6i7yYUEkbpY1/QB748PXVavzu82pxOSmALE=", "FIkoQz/APTqHi0IO/IlU8E/dSVi8giphI98dTRXQLfo=", "BhswRT2O2utaDno6n5UachGlD8NgkDxLJaUeTjbcQ0o=", "CsrUvyLhS/MVN/OShtJftJP+Z/Fjvd68PpTekRqVVvE=", "BaTcYC9z4TmEF33ApvLXryaZiPhyuBfIN8hVnHmwOBk=", "HR+BPcodj1TXNEHIFMyw6Evq6O9EY+/7YS62rRMc8F8=", "DoLDV0th1MI5owJNaCK/oYbVmJuhrgWXCSVg6GlK2as=", "F+qe+e99qAbJkpFrJAmid//wnTYznL/fRodgZ5P97p0=", "GUVOXH/6lxa9HbXXB9TSS5CfTHGBN+u3OpZh70GnzkQ=", "Cvjcz77eogZFhncaI6x3bbmsTfN4f9+FfbSiGT6TSjs=", "J0iHKmrToHswFhrjdEDV3aJ5oSzC/+FHR7+QgucmMOI=", "GlKaOfZRnc3+OOMRx7D2YVUOOIhwdyZQ4c4CE1va6YQ=", "CKV6/+E1E7O7GWgDgaF/ghAb6fWse+DPnH5h9xDmOJI=", "IA0TsBcMEkolAm94AnPE9Vej6Vy9aGhOTk317ABhD2A=", "FMeaNX9TRp+R0B9EMrcoVR24Y6sjJSXC2Vz2FvegmNg=", "DFE/1Dr0PsbJBQksbV1Qqsgz8US5Yw6ZSDqDw0AvSDI=", "CrgCF3s5X2tq09x9GZX2Dt22Ppw3inUkeggALSmGSC8=", "WJ0ijzFtp0+9jwgGukX8wfMdxFLjdDAFC9nLjz4KzA==", "G0bfb4iJ/QdbWF1hkl/h8I0VkAB0vOcG6l+yEdzGPUM=", "HSuTgTKs9w8SK2SuFy7BqCLsveWhiLR454nFw+kc76E=", "IwjCA1RNFi1UpLh9khAu+Fy78atMPALWZCrwOHMDM9o=", "Lrc3m9aZltgTE2yZwuZvRcpGe8364DoxXP456pnu2jo=", "DLz4vgnneptwBPqknFYOhAdwODJjmBlsBPlI0JrFc4g=", "By7WlzJC8Rfl/Bw0TZvDjV+z6UvMAvSIQ6BX4ZusyRc=", "BmcMOlaNfvt/EOrr1yfnpCSl4rQNcgH7ZtC3RyMIHuQ=", "HiEFzTVuvqqhIjMjOioi4FJMgiuE+7NotAnUSBku+dc=", "EPMJLLEm2RPoKeseCc74UIEmWEheWsBsFAvRtUn1OQc=", "K88bmRfLc9GFauXa00n/CGYOgApbaalZrdGa9lWIhMQ=", "e/zZiP7qvi++A65xQIwaOU2vKUPI0y5B9rcvJJO/rg==", "Kpd91XNakRAXjiuwmJxxKbqyxvknb/GpxLOGehFbgV0=", "Ip8B5lP3soAVPeH41OnqoOGOgcPd/pzw9RhbY9z4864=", "Jy6+8QYWq5x5407/ALD66nUh/OpV31Jr3J40JZLalGk=", "AsilCFFw3I5ib9n18RhvmXY5dupqwIwlPQJftG4VJsc=", "K3e3x/e4Yra9RbiUrxzRzKRE9CbWNXH/5tV+YI8SRBw=", "FRggljnlE9ViMYSHHMwaAuglNraNSDlXdJMNvU8TDd0=", "JBckT8mazOjR2maF334zh2vaPdYyzWhCQqYNVFVbDvQ=", "EtvVYW6Tr/8FbnQCr7Nh9XU+1mjW3tCMyL4/6+WK49E="], ["B1KvPG/cyvOGgnZoXwppuXSeFwaoKRe2TsLvhH+ARVk=", "BpUD1BfiX0Vox4WLqDNDAcD6GcGzSLx+GKTBrOHRVBg=", "JcGxIfM/TPezCOxGMPJ7YD0iqoHKNZXoAcX6fZdwoJY=", "I9a1UUW9sygnwUVq9Ne+TC0hPoJcHS8Mn/mbInN1H24=", "GzV7zj7z8rdq/CtYBIBa2xTPa/N/4jV8eap9azKsrso=", "KOxawIgcHmQmukmUCYlKbzwnb+Vonyw1yQJ+gJRId9k=", "LJhiUkrIoHtH0hHJxQTIsL05jQKKz2kOS47UAF3Qbu0=", "H25vCsSut6UjQ/MEGAeLQGRM1D4pDaC67pKJHEwGWsg=", "A9s1F+Iz+KdtIbL7I8hfp8rMV3dp7eoJquOUB7mvL90=", "D8Mz3KQYPatHnFli6wXuS3morG4Mzp6bCiFCJHv9CHc=", "Hu0oGXioOVwEKJuGGXZzsPK2XhoTUmRSfiUKXN+ZrKQ=", "LjcNsjhX3jaJ/JuQi/Ra2PQtqQD9tMyUp6QWKGVVp/U=", "EJu25eBMDrUpcTDGUkCXRw8zdcEvyQktIe0zQAYXoKU=", "Bz9KF9Rc5MtvTbh9bz9fTxZQxhjkA+GHPqO4xNwYfPs=", "GjvNRaKx37jnVobTZRys4T4aIvXYOMtKYbF0F2Ze7PA=", "JyFHUaqG/SZU6gX9JhHw2QcodDOHWosMPrSyLSTXOrc=", "HFRj1ARgQV3GhO8kFbpmYosXq1+fvJWXumW3SJLTRAE=", "D5NOwezXrXTeWQgXNHZYoip4NJa6uZQ8oaPGBNTLdF4=", "DsKtHsoLJgxMZXPy87UG6UbSqCql+eZcL8S/ZdMQsdE=", "EEA8b5MFGa8xd6gvK+FTLldYEnyp/ITJPGUieWGKyrY=", "EsuDGWg5cXQPqBZggxq229PZPHvNRBqRKBDZY1gr80Y=", "LHy6sztilPKS7g6zHVPa8uuElNlqgcD9vWL/xoHnEwI=", "GeFsG5Eju7+PreA7SjbF34WA+N4BY2ebGBXckOxYG/I=", "AtJzT9rqbaVwMT30pTPABJ5EtytkkGrpzcs8hnCGN6Q=", "D+185dUMotM9Gt+pkBYfx4DNwwxb8tWIGEoZD2hlZ8Y=", "JTO4s98h/OhUSm4S/Uw8H6CdPh8UbM+rUq8epNbqNhw=", "JUqbDaF/HRNJXfr2jN6Y4iT4BpegwxuJrwl/PLJw8nc=", "BSoZZ4nn48agIKDS+CwkapA61/jOPO3oFT23KsQc5WY=", "Id+diZmB4QBUGq+ih1PnY6TFoq+YRbDpt8TtHnvu4sU=", "EOklTZXAS/SYj23lH7AZyKfFogFotqWUeTVeiAAoyHM=", "GHLUBK+4QklSlY8p0Htg2fho1fJqTSYPhDNztwbD6FA=", "L3+7syr2fYhzcgECK1am30fUdtr6e4h4Sqmrc8V6b54=", "J7WtOD/AhdLCY56AYp1whuQDCujgjrtAOGC06ytKxIc=", "IKBLpzl16hr4bqQY5bn/9CS5OjgH7MOuzOx33pwdWx8=", "BNJzXbQYlo6AR2b1efKkq/ed7rZiQPspkHsDTbk0cuY=", "IQuhHzUmEBAZuYqvlJLARJHu2nAeusjGbEU1AxdvwNU=", "BZjHVBPz+EM4xN3xduhW9s7XPMrI1byPxvEtXzBuyOw=", "Dxotn6hAfjEMWK9Ae/cwvs2RkgcNeqQhU3nR79nm0ro=", "C69XesJiHKvc9//tQHPifR9xH561qXOcEr1t8Ho88lc=", "AjujBX5dnxQp7HhIuJOrO0AWG9vGOHyVjFhytEkbNmo=", "G2AQ/WmQ0+SSj9/3NvqFe9UX41k15UodbK3ZQerbhAg=", "KUP9rblmB1MM2fEADbUNovxcsDCwOYXR08tT3NaTeuk=", "CTdbmP3XN/J3ouwmpW03Rlj0SMaQ/I43bg8QEuTaQPs=", "HBJPnzomcjYbGfq68PLhFYsxP6I3S3LDcLRmK/luiiY=", "EOKCuTeSwqiTxUKURGpjuzals1ZarXUESZ/CLrzFiDY=", "BL+M1nMZn0Hfa2e3bcRs77QJcfD91eH6Fe4ZIatdhgM=", "FBDL3CYZZKKtUA47bq6qUOqLEZ6hFmb2VY+bPVhVrPc=", "KxeDO2yZ2NRMaPGmYqR0k9q6WCvFScPNjOR9Vy/8kTc=", "GsVaD52dSYMpLrMEJ/HKAbhh8XgJ8v2U09ibL3JifsA=", "Cl78Qd52yRRBDpFH5eZ/icd5KyAoXNDRWhwYkekawpM=", "E0S221Q5xGoi0UT01YQ+KcdQsaz3sHJxBr/blMwCPPM=", "GgQYOehEzaoPfCphypJZ6GBZklhJX7ANanW1xQPnGXc=", "JVXFKdNm49lYmdnErUwtSrKE3kpF1gYK2RuKi8X8JN8=", "E3iU0sf/BrFB5gHJqV9WZBGcoytV3F4WZ7piUklUpyQ=", "Hy7Rsmz6OJGUR3kl9N07zveeiYKcjJZFZ4NDoTqy9jc=", "IHKwxK9G/V0gASK+XFAR8b/y1Eq11ECtlG20uhG1I1A=", "DKs6jnfEOJbvxKtbsS4/1tI0oNyyNsfJNcV6ADOFEe4=", "BADoZ++zqIhxJvlsqIQ1jpafFLqBvk33ZoZS4VpYHLc=", "BZTxSvcCclCRGksFR49lm6sYGrQmYx+kw2nDYf7w4J0=", "FxNFCUre3IfzhA940/PtZ87ztqaiablxmOASq/DrtyI=", "H9vuT4WACvz/oQ12wlwBhntHLUjaEpbsqrR4GQ+B4kI=", "GjfIsBD+Wn8pn89Bc4xQ9akEyrWC5BGsFIKODBi6h1M=", "BZy+kY1Mxdzy06MbOvLCzBB7bPsDsb6ak5p/c8UHW44=", "LwBU1xnn8NOZHlIXigINO3ggp/KgdWld8gGl4pKDGzM=", "DTNTrXObrM9cqaVoQNmXdrWn+2D5F53BWVDAY50Y+4M=", "BQeow9P185ZeLp/mL+noJGkctTr9dDC2JRU2Ydo+lN8=", "HqsdK0T3n1DiupF6lrIZNOvUPvUMqlsh3vXv2MONkXQ=", "D/+Xq8WmMYsDtG6kNhyNKf2KWk2tUShol+d8KrqfJe0=", "IokHwUa076Vq9bjy5ZvqoBdBqxDzKHNp78144bFt7Qc=", "GDognRSvShqdsMZHrYJvt1qmdQbQOlDm6TfjpNzC0M4=", "FwUrQIYOz9S65oSuEicek6MuG3A8MSfV0jVYvXVJbSw=", "A6YYELYOAZ46X7U/sFX4FgDI8mmzyX/CKLNzvGpeVk0=", "KW0ENNl3oQWwf46NU3qDgeiF3P5ILDq3c88cObO948k=", "C/rHO45/mIK/aRJWhK4gxxhIgtN2POh5EdvD6uz+hsQ=", "E5AOITxIze/j5wkBEarxwIc+IboPCxJNqh6QiWd+qTc=", "GfVyXYWb2ZRpNp2KWwKUAdkKTHzzcme0cA3c7jH3i+8=", "EPjCCzBiK7dp2QL+wGTYf+hwBJfeTDoyZzQUYD80HyI=", "Gl1EqdbrFmcn87rR5Mnk8g3Z5cCbj/FoWBPoSHX3wmc=", "KFgS0ffpxWUupUnv3jQmAZQFuwgECLAfUf8Er1yk97k=", "F7XWV8pSTE/ctkIbvxXc6q7IkeenMBd4ZVQqPsZ2RLQ=", "FRISDlTe9hGfxzGoDr+LmqRJpealZU3LFu6HgbVcQO8=", "DOb9n/Mm2ZGBftZvD+2TKY3IEWwF8J4hRIMMB6+iVwA=", "FMnlRP/obzEMAnUircpuZn2/E4pYbm+kJb8fKyEUv4A=", "Louo5X/hxOoGqUHN0iQsQU/Mmh5kW34TfOYfxEVt+iU=", "Gh+y5p6/Q9y4rHzw5oVhcL6MYsodsPdxINNqren66Qg=", "BZnhDdxxbXAdWFfiPewRMLVQnDkT//xyfOIHeDoqzKA=", "KQis5Vb/HzaPhD4IQszQ36pCo0+vZ+C3jebEfeK2oDY=", "HoDTgc/hhLLxH+ONZEVKYpLv8j9STW+vrjTOFQ0bhAU=", "Ayw7Kohyw5+z7cku+V52/bY4H4Kfv83e8mAE2ltdcg4=", "DwWDBuTzl7ewKljdrofVFl8hu2EJvmTNMXUJf2PQ1AI=", "KpeCQsVR+oYm0N717llnWZjdj/kO6vp9k1tYuKLQ0fw=", "LGRs+NntFHRviipDjN/Ia3D6HDEDPUr9hpSnNj0coLE=", "HMfVnHVqjpMHH5Xx64pcvCruo2ZxVDKHO+j5Tj+chzM=", "DQnQ5rZHV739cSjQQcQwsNIagKN5LQZ08AKIcsFP2Os=", "DCjTnRRcuLav4YV2QDCA7RlFFHO1eJSaSRoJW2oZ0II=", "IqKoXxMpFaoJiYB3vL125XLkNA2AhXCO76q+zDfOyh0=", "GtaMThSKbGGX/dn6LEX4xvMRHdrFLbCL0q53hg4gOm0=", "GbWaTrI5iJbieg5nBSn79LcsOVOoLCu6lUGlIYbPdHc=", "Hjru1h46e8bb92dPgAKlnuKNPV1Rq7612FDbs69QVZ0=", "I30U/hDMENQc97lUXF2s0kUgdyUifuXVV4o80WPEwWE=", "B6VhsDwDqFb117FeiVRIQBqKTd8d4xG1FmNkDIHPRMA=", "IOPBICH1P8IGiTmFZHo93WT7FmAlekudfTP7qL5ymho=", "Ec/dU4b53fNunhonHAqFZeA6p+QnxiTFBQ2+q0CxC2U=", "CXuQ9wFmaMVThaDxAbaZ0Mkk0VVpGOtYydmhbHgVs8w=", "I91PggXpy54SPifoD0a46/tFVN9BUorNvKFBZq9wqLE=", "IATPSDktHTSSBp0LIMXqY2x95HBGaLrgQA8y0GeLX5A=", "EO+6frsiDemvSvWz0s9OOkY9b2GzpRsZCzkol5IrFa4=", "JsqPoyhgRw6bqV8rMo9FttOuqMZpT1L3srYTmzHw5lk=", "Lnpgloiekyw7vcEjSwQpRsqNvDvZ1CiU4ier6ZSzlUw=", "KypbIiAAx0hXF+UTTTHZZtAQlNIBQs4L4O1bzSOPpPw=", "BdJSVm2yQ8Js7tlXGf9Oay25JqgqkK9mw5E0V3JNaIs=", "MBbXo0LMrv/4M4NPjIXkzd5QL0z9Ll5npDTO6o5+hzQ=", "IuSldCcgzFRfWoteyB/HbIVmdMKVbHTpPQnaFbnqhdo=", "FYwDlYPZFHFlG0JbZ6nEKHRrfS/00/nHgFzQlyUogrA=", "LiuRk67nVzuhgQXTbVRSY28KSiP2u4CN17g1GzEEKIw=", "FSiO7sB3l3hju+zCevDohlNDT521AEG8ZMrjpKsCZ9Y=", "KUrD0j+tw5/95PxRwjH8sekEPSBzhKUSgexpk4Bvy8M=", "yZTwFUpgQt8DDPy4d16puvh5DRAfsAT3khve/uTd", "I74ZfIPfM0w4GKTrVPN1X7pa1hxspAjW/K7nU6LkSeI=", "Cr5PYPVxAGLfeDiiXmE+7Fx8UAKSz83YjEsQT5Lmbc8=", "Itnuos6YG+aNA6Ynoaw4rhc5O0L9WJ6Ekt+GvQP2m6U=", "F/1/TmdfRW53kCvWjaQ9egzIunUHW97HOAC2cPrvLIE=", "A8vxORfY9pYrhb2bG0deCDqaZQMpAmTXMrxwRetMDno=", "E+OELni2vjQUwpvVUoWTZzvPegccnlR9SmqOjB8p9Dw=", "AmOLzDTn7Jd+YgWjVtgHPtrrN9bQyy7hXMxlfgCIT3E=", "GCSjb5szzYiynZ1WeUwC8EmMjDUgz+uNfSPfAd0RvLg=", "L2TT6elmDv10eiihgXGXcMuJrMho8dsLQqDUFCTVuXw=", "J+l2uVwdsKQxzGPSvLd7dCDqtyQMqvvU9u2Ut3HX7iA=", "BxAXzwWQOKbxrZIjyEPm9od3Sntnftt9fdbU2Krd/w==", "Jj4etpt7LIfz2fTUkhADZwQaAMwgCRQC1r9JXXTe66U=", "Hb2PenkO5PthI9gWLoebbTNOE3wiTadbr5sA29WxSic=", "HfD0RACM3+9DSE3AT1/dFpTWyQ6PLjWhhQgxh52deis=", "KsKQSUYrp3BAiRQDbw/ESfSsFcSlwWdo6V4khsYtqLk=", "Cv7kIWzeRBq0fbkP/a2xKwiXisb2I/Os3k1PnYx386g=", "H1314dM3LcvIPXByv78rqJFAJOM5jrvDRhQD05oemJU=", "ARwJ9L5EM1RLtgTbZipyK7FoJP2FxITEW/Jd+l6pcy4=", "ER6l/rdW6wf5QrX7I4Sdsk0QZbJ4tGQ9VTEcBnLP+UI=", "CrfBlHY1h/HcMODtU6627rYDas1wK77JUJ1kmoH5QL8=", "KCxZUfmIGRYD+d0HdZpPZT8Zl2lD0g4w1MD4+roNqgU=", "I7gnIafNqsKjn3tL0QF25QmD8yz9qLq4jqdG69TSXuU=", "C6/CLDHnNYcN+tkaVqRuu60psp5TFknIW/ecjckceSo=", "JHEOnNn29C9xzIgVk0zofKDWd/rPHz2JqavC2omPloc=", "JHXMq1DiwT+113KgdXHg5r5VGlXiUORPIq3xx6TX7eg=", "FzJv3mjhk+SjF4LyrOzXpGhJOqlNY4M1da5RhOm6JEE=", "HQRL4CXHn2ENQAnuCj87UNxVbnhXGNGW5nxg/NpJhFk=", "C8OFF7C+22agROOLHBmdEQ+jat+hJR1G5jXyLOj7O2E=", "Ahin7XtbTjnSHL1OzfDU8xMIzCBVg6nvbZHtaWm0XCc=", "BwmJwj7+HA1gifm/mHvoaFS0v1qoizfdo7T73dsGjzY=", "EfCh8tWJRjBwECc0YWOkxpdAI9MheA6RyN9ekeqTDHs=", "CQcCAr0UTEWrcExy3MQKVWbL/Vgm969HRrRHKx5ow5A=", "JDOS/kzWymtnR1lsOHRQzmoa57CpDroiLDRw2KgBOPc=", "GpQmUJOrRAYuXQ5n359LcC343o363KxstCKWgRF6Xak=", "GrMc5J439pC6+ex7FEM1fNJNe60WqebpXkO2Vk2Yexw=", "IXnO7w/u47CwPJZY6XtjQvJbII1+2OUmFQ/DtVkSjF8="], ["FRLfATW2aSWJ8HEUCmB0nPd1xkKzANovtK1cbiOtTl8=", "KxCa4DftMDYc9lRLL0zljzVliYltaohJSC7T+bZuEZg=", "Alhb7OBu/1U9SFR4oZ6xSeIRGuTh7LHWH8EM/hwHfzQ=", "Af+Jb0wGYvSyrZJnQbSB0DuBOozDQ7nC0rxIGccLLzw=", "GwyvAvQ0+j1M1PuxPTEWrItzhqWv1sZwduy8NwSqRdw=", "D8t8nxPIVRengFiUrIK1fAby8VOm9R9g+OUIaE3+W80=", "LcK99/Q4EuOc7yEOQukrSWiti/VUVBGCNUUE0yy/mVQ=", "Ba3Z3yDBiY2ka790WUQ4vrB8mmVjXJD0XAoI/rrRNmQ=", "IcraZkFmTaqZf9VazouIGRzcQZT727bKWJVEfIpYhZ8=", "GWI1BFiaYPBYsESJsVMyTRbtZmZ6BN9XKxA1kLhIvwQ=", "F3ZELYUKQ2oAXgLGR1ty/S1fhEUokMREFihI7h1X3sI=", "BsFpH9bS7pg5ZhDzyGjXCHTyTv+FOTjYf6zokjSgmpg=", "F/DVzzYMNUpX5/uYba2zquuglJIOdyzdmrx1hQQAr/I=", "MGLA25ySXEjML4C2mNlgJkKoTPow4b02QI4s+C7zNYo=", "I57H5LRyPI7TW5h9sD1iwqB8RHvdbvGDsGR4IfaHTC8=", "K9Oe1/T2py0CaT6Wd0C1+gMU2aH42fiRHCja0/Ff+m0=", "IDUOdbvVYuM5Jpz3/SIft8btLKz8yQNlaLtLpcsXvcA=", "Dpe7nZeEkg+zmr81pDNDftb7YxUlKF3DwSbiTvVOS48=", "CxLMyHHTJy6AohZGFANVkEjkpbOvRF7uvYIkp+2saF0=", "Hfo7BcICzZguPXPLgXCdXUizzBBfp47I8PIWQ2gmvi8=", "CNn7sHFcm/Ex1t5wsojZSvwC1GlgRZ/qMOBzPtO+aw==", "KSt1FCSPGuZi5UN3Bc5JFT5b4nwhLoYQffFyX/RlMy4=", "HViwaE9k22Ias60NyYJj/XKF1rzYbgehRb3GqnXJAe8=", "BOe71o6ZiakRkAgvCymwsK3CvignYcRNG6aHdXUUrMQ=", "DZOlN0Z3x1vcG0BxsZSOU6G2cwjnDq0XhyWwj9ntjSI=", "EeyhiInp9Jsfl9WZjSNfl8Fj0XBrTT1MOA2a4fPnmig=", "JmuSTmeoaKWFs5jC4/KOMhh4MjeGK6s+kl5uep1lmmA=", "DS4mrVjqzqO2oUwceAPKynqzxYgbxrWydFMcLUYYZ/w=", "C8y6RTK37qbD5AE1ZVFx+9knE+9ughgWlZHlATqEvd8=", "F6EuqXUEBbPVkDCvA1wY5PNi4YPaa4TphYCPMgIR0GE=", "B2UQu56xkHDco4ih06la7MXeSixpwxgWZfmCtg4Bg8I=", "G3A0s76waAuFi8jxlSjowSLW9oBZsVxwWZkQyZO2vAA=", "Dqz3rJhi/4VlhSFRcTh5XaWfQnPx2Wn4FbqrI4Kyi9k=", "E0QEO+7xr8Fl0JTIxdpD55O7qYtXnyQXoZ+/5Tjiy4A=", "BWbcoQoLks4Xe29ygkk+azE5Hm7dP/RWMnflBMRBsfo=", "DJxrXEa5h3wu6s0DPxhP70l9LtGh7ydrpFSNBfPHg4c=", "Gl+Skh1PNKdEX+8GGPGxoh1ocUuAtoUN+5yDT5iKlso=", "FNFOYhy+YnAigJ8H7geMsrP+T6AkcV4/cZKlEPHY4QY=", "G29nyi/wei3lj3oKyGB8kv6MQTM1WTjMmBLDKxK4/HU=", "BMO7f1VaGodH7d5f0z/uw6tS9T275u8j98JuYt4m+hI=", "GsoDo9h8kOej/7uCMxSb6wtoCUktM84+UHlRqjimYzE=", "IpSrLxQ+SaI9J5xv6RTWfuh4s9xU+df/EHu+eKwv+vE=", "L7QwOMC0QzrAyYCfTn1+aI9cHTwI9mrGQ5f66UHmqkM=", "J0R5hnphbGAuh8dSH/+6qF++szASijvIyLg2D7WjKWs=", "GKNBDQY7TnIBZQAijYiJ3GIyAbTAVdq2YLZTR/tO+CA=", "LW/o09aUul2tuQT9aQSiUaotNR88wRxtGqlP/u5FJhk=", "HsUYJRjW00kKsLP/iZ74m2ERl0MYjt3+uyVNzSp4fiA=", "JjoGHz7JIovfk+uT8mlf6mKZJdbc6C8Y5tunmzvp7Qo=", "L+AwCoGWuaRusffVKbTUwJ28WHZaQqnzth73wQe80iY=", "CGL0SG3AM1DqY4Q9udoJpaPDASwIVKest17hg2PcBBQ=", "CezQHX3RUxby099yqecxJ02uEWWSra6Kge7OUaRFM1M=", "D8Enzu43f+3A0tppYXc5/nkLrgKIWNvl24qT4yVOuPg=", "FdIkFgJl345eTBth5/lWCz38V2SfMDj0QLZOkovTKXA=", "EQ94X30EFRo3tEk1obv0eCr8cq0o4ELEL+Y+YwJVD1A=", "F//+4TcDm0KUPm+NBErofOBtX7HD4uUeMAmkX6GHP3A=", "CssYiJUAZ++pesrZKR9jwFJFzeEW1+C+36HdkNrBhaE=", "IqSrqlgTdUUvw7UxvU7VT++bv+4BbmZeQkk/CcOT/tE=", "Ja3s1jaA0j+HvmIm7AWivKhSSWPd/6+GM3nUyB/Hk8Q=", "IgzpDtZEL0Weyh/h8gJ+Y3fnGJ4PbvQ+HNNk6coc654=", "I3LU5ACf7V72WjZB2zyNbsszBA/CWYkDk5RIGpS5cZU=", "EZJrCs2USv4gMM8OiZTZDapTX0ZZZ7ZKsLbPaeMWpR8=", "Eik1l1P7Sg3HQdqEvJdYqgp2YrMUox/gA0dPqtGOOAA=", "Kzpm0WbFGmK/avLlSJfFHkX9CL2nTVhXrf6P4+S8OXc=", "Hn9Po2K9htaSd4GvKkysRqd6GbKMTuVbK6CIHS97ji0=", "CR99ZvyOoufqlewYdqk9M2iPn51H08iwffktFVTjjLo=", "LBeufZr4AL05O1+g+LFik9r0nlr8raUIR3lbh+Era74=", "Jm52iRsCcbytFkS4Uu+N6dPD56U+IvbPCW70T7Nbu8c=", "Ak2jDDTkm0F+bOaW/vfrlOZ7TXTbbS1c2qR3fCYCFmw=", "BMPTFwP/7qIu+FCe3UaFhrrWabdMJfya2kmhhZN8LJQ=", "ImUxTGbhgv7KdV+aDPfFx/fba1AeAQwoMVn1/MW97TM=", "GqF2ZkPrMPljKfo+zLZ5ZNUQBU25WZ9fJTbXw39cEUk=", "EH6NpoiWpNOrQO7fL6deAl94fdknmTVyGOgj+r68iUc=", "GRr/RLe/mQJ7sdaVTKCQHJUPe6jx4VSUdfDyisbnLWA=", "LWoA7VuKsAVaQneznReJGHROxbTlo5IgXdTq6bTx9Qc=", "CL3dE84+bQrdK6vF8No+2cJOEKr7KJ0D6WgWPET05mk=", "LwV1z5t96ttjQyD5DYRnjXcYM/msnRtnwxiXP8qxjxM=", "E2agXTBH1bNFL8xiQXNDJF6nJ3lfsNBe+4CnXh5NfLA=", "I02twpVXnGKxCA/WTzQFlOryWLlCJfzWvrEOXvtNb+M=", "H3ixwVKkACeix7CsGb/27eMgLqG5Xl0K9DElozzqeCE=", "FTLo21/QpsLHhaC8oRF0GQP9CJ2bc3Fb8N1wwuFN+bI=", "kBJ0f//gXotEgvJ401ooxvWObVAtaaXzUSJSJaoCeQ==", "EFsZL3eMQjVPKpedkbAv0zxSxZ1UKhKPwI5dEclvvWU=", "JLy9ikkvVC0ub67mxQPJxvemfPx9jnVnWeC65nmSC4E=", "E+VZEylfJml+qM4ar/sHNz374kuPQeeJ4F2LlsLcnis=", "CsUk8pCNjhKSoY7m1e1YPClibuvQOlk9sBphWZwoYTk=", "DcQCx66+PwI8pLdd1faaz4r2YH7a0UvYBhgQd+QRaKg=", "BtaHtw8gCATLOzlUZgnBrCMJxLWfyWx2c+vfLJANlAA=", "HgwmYs2qkTNuEMfrPG6rEjMKmdqKCV6Sj3OotFrMyLM=", "FL4MvbJaX4TTa0Ffcf+Af534nb5qmFAhOiiKvebbYmQ=", "L8jIk44lVNnQLhNesNK9JROQkC6C1uy0rDe4q20SIzs=", "IFnzrR1P+ieH/gV3378ScBaJuzNZZHIZ2EoADpXGLJU=", "AekO0JYAsa1+X5J7peQNb7h7tTfGldWrb+8WbaGP5/Q=", "Bk+1l+O7Cj/bjtJe76lD9sohFQtOApg2/THWPLgSI84=", "BxBkQxT/fWCR6rdzJ0Ibixj71kq29nVrYbqW15hU1vI=", "F0kbYi4vR8rweiq/C2I4lulzZH0CvgEfCZuEr0Xf0d0=", "LHqkOCwcwYl5iN1RJD+s27fTfoyrLieibdf7B5XXdxI=", "FGldKMf6EupgROiYptimWSpfERopNiSkXcJJRPd7txE=", "FgLnfW7jpGtgrKa6ZcgUV8TTbI7hSzVZlmy+oK4yzvk=", "GrAuW/r51M6sdfU5g7rplNEtDESigNfi3zKD7h9CmtU=", "DSs6FIsT2KVB48uC1iTLMCCbT1j+9RIbt06O7Kyr2Tk=", "Lmgu2PA8XpXYQAfompIEPJaBEc/+nRhmUljfDTpqm44=", "FCimucjMzFl6nq2jnDz/8BVP2fXOSHjZljuJx6h4zvU=", "El2uQHW9b4MxT/cXLHDxkhc6LU6vCdiHuULUW3z3raU=", "Jzqv6mLvatGFu/vlSnU+WfY5qy3/hbH0wKKOITbUvsY=", "F5MUcF304LUw8dN/nQLDqItm4icu3KFhNlYVmZsc9AQ=", "DcBaqGF9V/2+MNdtdAet1qLpX7c+n5QuTCQuLtEBYxg=", "GEafNaGtVrJYseYCQ8li7m3Jn68nTwL+tCqKURgmUsE=", "L3m3lmMYJzmi/gxgcHcWPffA6RkxQyNDN7kAfPRy/3o=", "G7TUrpRtXsfPsizqgo0mO35XTqd3qokcsLoHy0EsJBM=", "JycLJ9yPuc6xxapaSfl6eVwdxlL5AS6iEQrGh332wgw=", "FNo1Roc53D/wEQyR71QL6QTHPl1x5bC17aXsbcsvbq8=", "LpDZ7j58IWSFG2SvvN4AS2wLgq58zfb3iEn7mBo1ou4=", "KxVhLrlCR0ab2Uda5L3peAURysq9VmwedLoXYdYLYVg=", "EhxSFXa6SuSgXtJWVlGyiT1fcE5cbwpkLGDlDfIsjvk=", "I4Y/0IAVgu6bmkyD87bq74PFkGjAsdS56T7F7BoMKTg=", "E6WXoZMH6Q+wR3j4Ly5ngKnixOA8sFFeLLlgxRg4aT0=", "D+TxEED37IA7qGzG3Ma6AO11aaAMtKr1aF0BS+7KNag=", "DDDt2sAz4/ETiUMn25djqv10ezLRNEtl/3EIF3El3i8=", "FkSeu3FzfGUTMmtGNpFP3J94ZMfxACWglzSIDUI80cI=", "Jn8aoRYrcoTOyN+DQDJBiEv0opVH4tDEcParwZ+8TnU=", "D/plwSsg9awFqwNaO5zwmDvLTNAHXZqeW+d/+bTxe/w=", "D+VQ2eTj6txoiDqXe2hppYh9sVP2vbpJIz9gvvd79Eo=", "JVAC8UxFrs+MvczCXCXPFsnHccZT3SE6LOIuGQ198RE=", "FgxlAFQPibFF3lqp/pRGBOqs/L8cF1UOyR2mB4CCzho=", "E4P683uGbZl2n8MraORadT+APqNuNRvsNCInKTVsY5M=", "JAsa9wr2SNpK5ohtytXGc+Wzauz7fy5YvRJWTFp3aXw=", "DfnxBYfpn8YoC2qE8Ksdy06q3IlYUY6iu9XmSMyknho=", "JuQmHyPwhWrvQpowe6/fG1czXXoPOKuZKnelzKm1CtA=", "FFuEgsFZhvvBpAhdqyOb8tW1JGMrrtOSc1USc84XZaU=", "JRAapHFaur1Gf5F2fQzQ6AN3QYgzgeOSyFIbCMbPYt0=", "KJYljx0T+LVWuS0LX+BoT2eoZlvZd0frA2Ttm0HLK50=", "C/wlr2DjdfGn4J7FwEEe4UtSNG7emDffVwNCAYn9h38=", "KaBCvSXW86pd+ZYZp5TeF0MvvRx1+jOhAQwa8wy82Cg=", "HNDecrZYz6iXXc6XfMxrbNBuT49J5iDnLX6oT/I3PAE=", "IZfERp7syni9Rim11TveKajTIiu//8WUgFLgOfGONGE=", "BZxvQLKxu4Jzk1bCTnjuuQDR0QV/qdSCiRV69gPQXdA=", "GM4we4njcAhwxwpulGDxrtUWn3KdLnX35sfm0CmPwzQ=", "J8cKt9V+zwuDSN+JxC44F0ULPwGFGWc/n1COXh3crok=", "Gq1aq/N1Hn1BO4E4wnaQNehZEic5XQ0c4p0cWztCpU8=", "FlY0tUdwVCpJ/2hOyjBMmdnQYxVBIlK7gqLOXv4k/ek=", "C+eCbyZ+d6znSk6w4Q5SaPB/Us78HXt056W4KgjIUmY=", "Jj/b6qKEDAXeUt0Q+0KBc2GhidKr1UzhRf7BjLEbftQ=", "LB3dLolsnatVM9hADfF+s1OgGRublygt8Yd0ETZXtHM=", "CJS5DBiwXX6jR7jb4Ucf4AILnQsetFoHsPcNSzvZAig=", "MFa4CFbJ5sotkqW7O6RsA94ieF1YVlq6UI0tiYBo10E=", "GzOVkBsASRcuwJoxTkpBg1Y3J9Mqh3Z6CU1wU1M2vpM=", "FD5loqh5t6NWYNpP4hQb4zwXrg5vEyT7PNmh0GGhV1c=", "Lz86UMgjcsrGgVMiaY8JgmIQpXGpzWTGjf7EcRpf5gs=", "C8wzjVqa0VUZqgDon+UswkSRQW4atpY1pn0yRuWLEqw=", "KkYvqcSmguEYzO1lpK7JISSW3ftd50NynLKB7Dp2qPw=", "BzkUSc5+/jFfgW8MHDrTO1IABxBu+NEcKiRj3icKsoI=", "CMwrwIB1PHcwxX8XnjjL+VuV2x/cq/rgqNI5NC/GjIs=", "HOFgUDN5oAfjirPM5h1voNeP9rGVJuFUYCPLbd41UaU=", "L+X1PmoW10MOyadl1kC9XeZYdQm+i9dzvnEHPk5lKXU=", "K51jWePeeyUVm40v1CyWJErZK8tU8mrYpqELJxPeTXM=", "L3MKD78kgQ1JBlUhKWgJtQxelqa9xOP+RNnUUXollyg="], ["E3PHcc3xUSGiJPMw2EtmiO+f4AOKO8JqKOMZZXigAA0=", "Kfn72jyZmDYBf3bhIa86ylzni7SPqGemqV5bnbOHUzo=", "HH61EWogB1wWm3htnchqJO56JSW1ZbvCYiCajNpJBSg=", "IaVJ61VPD4WfYdaPG2u+mqNEmmI4VGu98qHDCMnMUuY=", "C1P/9wE0fRud+YtGF1gA4NMlCsbUoa+nGjSe0ZWHNQg=", "AhKaxHQkFcAg2yRzmZs039urujytRxNxj5XmNG4Vg7c=", "AdKPMF6LDsiNo3yCUbDI0jC2i+qUAaFfUSTWTFRUvCk=", "HtMB4C4/yTCZn85tN0TCNZZwDANyBwWTnWHO5FH6/5M=", "LtsYMpZuNOru4JA4WK/tsT27qffIAsg+5ihTDQ4mrhs=", "Ej2q3ckwxl/Ge8d8qL9BI/6B+9BQHo+JrDGmmHVth9k=", "K8w2NiyQIQrPZ9X+IdUxBOnVR40FcUHTsXJZ/tjkqPw=", "H6koyrWTggfomOYdmcfWFiaRRPeQCBWxcJX3/3bjydU=", "KcLxz6cqD7j1OmMehM/fXMGPtCbCVPWpBf0+gx/HyDc=", "AtpYYJ94sprmiJ+V6i6O8BpqbCgU7QIxeunnFCop0wE=", "K+8fRe+64aT3dyFjHfT2mCVV0FrF9e0hXdJZOa9cGwY=", "BpJmu4mBPnewDjR0Ou4Caoc7fjH8b2TtV9oYnEYBQvc=", "K3GYsEP/MdkV3rnV/dAzjlvYAomSzcAz7vuc6/ksn1U=", "IP9ss46NlQGt2T0WhOVCDRu6YDlOfAJ4eo3rlXOHgAA=", "Fq/U8Z0xLMSyVo3ahdid18g0sFtNj/q/RBDxXCK3fLw=", "K8lsS9nrjwnBdIOqV8XAXwAsaiGuriIB6IIzW+308fo=", "GCehG2WEFLmLj3bdEL1eD+yWVowv4Fn3GZnsr7qwoAo=", "IC0b7OU3WDY0tuHnBlmhvPGv4cd3XEeMAGSLQ3V42ak=", "IYtbWLMzPnNc58iKbi8XnpBzIhUKeDP7hBMlveg4RQ==", "EXJn8FKzkxnEzjS8ilQ7E+gHhGYsIIzjeK1hGP2wrOU=", "KXm8STrh6z4N90MWzxL9723RZ0F0oArp75CLOi35irU=", "GSUxMkN5X5BlHESMgUsT8vqYjPyIlcmiv6hVEWRGGkc=", "MJuLw7CrB1JaZDEFrO3QrmZOUzMviaGF7T1/HagCAw==", "LFFNGAO0E0X5bK3PmD3O9VUbfr6P948j7N4j69WjaDE=", "I9Vv/W04ybqQlzD75kQ8tbTPmpcC792YaWZSw/LRd10=", "HreuL5327TN2DlGjUc+qP0quunyFS4W8bitjzD8qPcY=", "Czpjc2mD82WIC+365vuP5e6g8y4LOY4W1hDWKoJAeVc=", "JJ9RHzHE3et02RnNqRM/28HPLZtmKIya0T4CxxnDlhI=", "Eh07duZb1mX19dKQhDXCVxRBVGqVBDcKDwwz3m/X5zg=", "Hh/VfnnPBCsbO4g9T0Jl8V8Ig5qLXD8YAqt7YtVesjg=", "Fv772gWA5Sjb8mSOyC1qzBFMPBtyDVavAcVC7W1layI=", "CDqLj0hU1ZnuI3++oyOfkJDgbCI7d9Ew9ZEDa+ggnb8=", "KlITI9/n5+LNYiZ09GzF1kEjET40I0BpZu0G8ufTeTU=", "EPrQKKVDuURe5oQaRENBITF7mhY+Qjp71sCFLsUh6WU=", "J0vdBJpztmd+D/PmSo1200AJ5Gd2CBmpsBialP8U95o=", "Jmnim4vUaKo5kWOZR9/nb8FmER1v8bJBOdL//x4SWe4=", "EvWUlLVpWs12Ej/sAB3Xd+QCeLc0KzSGPmHauUd5gx8=", "DkWsHzU/Rf84RljzS61Hs7A9qTeEt3C2B9Iu4DbI/2I=", "Jw1af8WvnU/7xu3FfJFZQ0jGDzyop5TRQfV8eup7DiA=", "HFfIR/23Cb/Th3YWSvmq5xdQBYYfbM5o5xedyOuNWdo=", "CXvUx0ye+GF/Nk6H2QouT0YcV/LntC3EiyRZc6JfgZg=", "CTmdz1/avmr+bAKj+oMb8KT5LM5GZU1660qrgAZ4Y+Y=", "oR2qZyTs8vddjjaNMe1Dff8bugrNMroSKI1EKKtm2Q==", "CVylsAOGtnVzjuOYJ/muWkPOCc0renCMUmydR49lCQY=", "EWHrLZbY9eGZoB+xcSxfSynryX1d6Y5kRHSqo0OR918=", "J8oJvMYUdSkFNZ3EiYKbnKB1Xei578HMxtg0d9sb1go=", "Ly3dEBAFsNdtR/RECy3o2YL/yyZBa9es1bEhgycJeWg=", "Imuw0xqOlh/3kl3g4H0zrmPD6Ab/GfN16OlrFQrC65w=", "HlD4zl6OSKR2kzUbxMlf/8J051qtL+fm1gfYBh4I2hc=", "F+mL3BAGLcqzPhlFkxhv0p8GpaPNlaa/Nz4xQEfqddo=", "B+bTiyjbDVh7E6x8pAVv4nzG5RRnJTueG5MYsYH2Gtk=", "B6Bt1iMHUOP1m1ft9rP91xpKFIXiuXZbyFQC3mxTnhU=", "IkvL+eetnrY72qjmecC6Z8WU5Mi+vS4G8dc2xPpbnBk=", "FOQ7EEhP0zHvAnqU3pU90TPBToI2VuKj91gDdtkLd4o=", "IcLGnjBUb1M2PiTmAyICYnIo8tMsYZJP9PZLez6TqMg=", "A/43eW3t/BP6AWDS2jmYiQo/IOjDUixPpxfhB5b0BxU=", "K9Wy4RzaSFvvU7tMLGVMOb67WBSwYTSQKFi6HHn+CIM=", "HbbQbTDWLAj/wcIknTKXc0wI3BQemtmrzCUb9GBbO2M=", "A1DVF1gk0Repegx1j/rQ09I99QDwl6JfjgYded1Cru0=", "D0bRRerOax3Bu38hhDGumvDJJ4rCkSyhAmJ6ZWvi+tM=", "D70pU6HNtAzoTKWJ9xGoquXnXHRcXKSCb2XdK7UIE9I=", "Lm/ub/UbKr9m2zzpwjJxujXK7U5ok3YhYb9yg+DCeYI=", "60whIUwM5DQBDx/kczoyeCDhr+U7pyMzEt9RYV1Ylw==", "FJoB42RKmupHXXfnKKLpgm9rk1zLXenwYMCgXYkEpHA=", "MFGry9Qi2yObBO1L6s07Tbi9BFuNSrNqhyRU42L4KyI=", "E4oBGYFu5KyAFbrf5au3EUgg8WE3W2B0IFr1SIfniOc=", "FsjhRklw4NdsHjxAc+Y/suUUslhYv0at71mxdRSA9FI=", "F5rlmeAJo/ECe1WbB5YTB+9UZz1S6L+MT4esX5mamsI=", "E7NRjLSohGhr5e+AL+PJoHYZUPLl9mpGnfR8SYD7284=", "BSo1Tm+KjEgrnKj6UeRzJ2O9ohSmX+V1/xLJVKQz4ns=", "MDSBVLFAf5uzs9j+jezEHHcMzhiNZLp7AhhRWzYi/n4=", "Ikk/vdBtwqzOxBXemKnUEeOTOT5kjN+GrT77YDc9pNw=", "K9M8ONZ9qeKP8itK47bg6mjGyLJ11kQIzXwLx/PCB0Y=", "GMo1gCcw69WqvyX8fNNSKDRCu/pukl5m6DRDRZMuw6A=", "EjoVsx22RIBzbucgYxqwCIokFn0UYL5N1CD3zUCs8uU=", "G6MftJ2/4IPR9CEONEWWqcYeb0vMv+3diPO+sWiSGwc=", "EMcxZ6l9kUEJdnLISM8+6BFtOA5vEwF3hTOTOgePKic=", "ErLwljtnfWiQD74lAL39S1MgheXK/p25wuY2qKsMmMw=", "H+7pqMgYJUvsQ8C/6k4Bzip+b6qaTdASCHcKbwu+fDU=", "I4jGpH7HO5wZi/CtPVki41mEV8vKgtCx0s28rPVq420=", "G9m3a2emcuyYLNuutV4UYopNsHkrwPUkUcR1yrDs890=", "Cy7mTd7NPyaswcbETvFkO4625YnQME/qO3t+HpHC9TQ=", "EH+A2IP9dhMiRnVlqZ3IeG5prBl/vtt2NkMuxc/LJng=", "GfCoMeFkdyNo1TZaAQfQriZLqXvVFgvuBp8eK0Wbq8Q=", "CZq4fnuFJCl4K8r/WL0ZZJ6iayTkk7JDxx1BG0jjY3U=", "GNtC+MtCGAQiWH5oFzokzQ3WL2sXAJiXVB8WJjpAV0Y=", "KiITJFPbLWjTiLcAVFzehj1lK9vF9zPGkqGGN1T8cpQ=", "Lj+B6Um74aLooGtw4h1DOhA2qmhL85t+kzg5lzhn6jw=", "LCH4VRjMkywjKq+8oeTsyvbXN1qAsVQoKOGv962NhEI=", "IcAjkSf+iylloyzH7o0GPreS/0aHA8VM3eEAkvqdki0=", "IBxrW3kdQrhQAKEBGsUrJbrVMJ709ILiYRAxAAG8y04=", "LbHSNM11XqlZn+VgAYZrtLcR7QSSJ9Z92zXAO9uMbfM=", "GEmLa06+o51CnCXlqrG1/JfsiA5zYzGBSjzfeZv+pxg=", "Hl0S/MDGgIJOCTSmQVOh3t1JHsKe/7Yp41pF2IkCg0M=", "HdxLnTFZNUpFlEuWO1QIHTWERIGSZZYl0/BvqYGB9Do=", "Efxy5JlOay6Z+LWHc6XrirKC3QbvBgcFE3G62nuAxAo=", "Ibx0YeUWDy3IbScPvCyPkWBaSeXHWsV8euNIG/H0u08=", "LRZRCiIJWu6V2sczWJWnDg7FapqbMyAdlLX3y2/GJrc=", "L9+xE0ofVK192QS+OZHghuG44MTVwOuAQg2lwP5LCUQ=", "KGRtTgBhNV1c2TbAj36EGXAdlZSCmQpG1MvhZLra+yY=", "AduxtHbA/dUHZkocA2JAOMLPIjLIe+qecR/TLckVBiI=", "CB29T9yHedqUcvx8PcizVBjD9nBkO07I6HjCVvbMIqQ=", "CIbNqgtDHJfYRjQZrFZR/0V6fBVnP7iJFulPpV9YTTE=", "KDgzFofgMum6P/9kksHFR/aF69dglTZ3DAnb1+w80t4=", "JiG8YWluyZzyL2RQGxMWVfSYyV/tcZ7cNGkeGBVDVOU=", "JUnUVdrqoBt7Ungkk/4bC3wU37dwh8kVG0yjbxUwask=", "CkwjbrU4Rv80iKW89Z/iIlL3iiDpU1FvIsiLTAbn9Kc=", "EMB36U8NOFKz48KxTuy6GMJ7Us79b7Gh/2om75XkGBU=", "LrGHyOi11p3kSXGks3CukX7N0ChrdVYMHTA27MVLGWs=", "Czlb0gmhUIP7OlgKuqN2ofo5fFT5HPigwUHse018Hpc=", "Khqk4k2DXYo/nq14gao5H6kwdS+MnBpEjVMwf/kw2Lw=", "GjlZv6puXsn6RamTm0dnbtdztUXTcuX4QDzgAFKGBa0=", "Ax7qW3c6nhiqaimGP/bFETD052l0BxIHu8p/I45JEOk=", "EJqKhneNgM/fhrTWu7HlfiGKuP2ElfH+BRtXb/LnfJg=", "A2HTNL8ukHlIwFtiUr/3kDr93HOPKVKg3Ik7CfsDTs8=", "EfY2t9fuGWA71+2pDmaLfssjmXUNAC2c0peDZLYy6gs=", "I68vHWp9vnNNYAY3f+BqICpUgs33zzJL/yw+70F+jZ4=", "IAV+CIfQiYVs1bzeu551sSR0rdWOV+OneibLbMNrthw=", "Jlc3Hb2yYojkoxl1QQ3VdyAD4iVaFeVBnxHpfaAKpeI=", "FJaB4+dnHs5zgcaYH8+0bskyZMwkL5phQLM0SqZBdY0=", "BEg0gqUCVF/OSQ1zZ0vswp3skds6ZyGGmpKFYlL16+M=", "GvseJH9XlRBSlvjwdevIMe3otRKON4v8N0ND7m+TGX4=", "IxQL5U+X9tHMW6AIR4SOT8lzZWuqVqs+G3VMwSopa74=", "Cub/zkbmwLwM5jQfnTCMeSQ28KBxQpiKk32z/YozNTk=", "EpIxwN+tmG+cDC+YaLAMIrMU4isktVpDh3CzIO8ZPqc=", "HWK1ZhipZ8fRKORaKAYv5/C85txVCDtYN0q2gG4BVzo=", "F+N5QFLUjEqpNsXhif3gG4u0YH/UeLZ/27ytPoqpFms=", "JK9PQ6kcXFHGsvP0TspZvceayGsGygks/5/H2cRpH7M=", "IVB1zkG9aFvjyX0rwovsF0QhOYAkqLvk2RIgCObgJ8E=", "EP8p/j52HZ94UY62CyodrrOUdTSHSQyfXvk33zuHaZs=", "Fg/55Dp2S6IoDV/2danbBJop55JPW6JFg7HW2QyqAyQ=", "CtMBFXwooSAHFWduWrWyRp+jlVnBqEf3eHq/SH2CgFU=", "A0CeOoO79S0W/vEPu+67tAuime93DjZAZRpIYC8T0Qg=", "CxIyNk2HzbxwlEKQmBHQoCQdDYt5M7WUcXmdazCljaQ=", "GV3Mct2fJinbha8+DJo/9S/thoA4yycQPZ8wyMcOH7w=", "GS0tnjH7ZbQJqyc+fisFDBv/WWrlbKRof/joa6i8J68=", "Ktnu22fovxgruWcEW5Bq/Ohm4AJYoyA4CnCbgYUhvzs=", "Ld/pKVbfLnUXFe3oBXPPpTCLRr5f0Pd974pRnxE6QQc=", "HvDaxgINezdubw+oIYeCCgpNi+eo7/2jQvf4gGVl8qg=", "Dk1u/iPBSW2Cdfik3VNr+YiiyLotK+ujKPKGBqTKD5E=", "GFsw7i06Fm8vWaA8funyBkEfdPd3hzuSBFtsEo/4QgI=", "Gep9YnWm3RZ3V5QncNrChhBX4WqYjS6T5PYYSdhCeqQ=", "I8O09eSeFq5p5jm5VtSK1rppbyQ6ZpqrE6ssKFXhGH8=", "KQN9ZLVJ0cnsRSTrvtuAacsjIYvvPNqBETSzbTVR3cc=", "Lqhje4m3mKL3MdmPKria6YFPGN6qfv/MljP+gpqdEJs=", "K7S/NrFb53tzdKAmNSZEuOcLGslRbrh+unZy7NA/EgI=", "EAbwdTO25fM9YTuJuFi7ZhbBj4R48iWvL049cmeAzqg=", "F0n0Ft97T0MlfZuFVeVAuwrQ18irCkrhKWAh2g2Q7Fk=", "JshrWEN7BFV6lsx0tRHb2gDpxMV7uGwV1JvOMY2otZI=", "JnncXlauH2pU04KHx+1gbQ2VBaXK1aBpmwkEFXHEVgo=", "Ez6rLXpxjz90HrEOlzvF4poCHoP2RCQYqDKwkbwtYTY=", "FoSktxzXLsPL7mcVHGONVYjjcFggxGjCicUuc9aaj6A=", "F8uTa8qXo39jcywB5sQPaAc2DNtz9i15LrkQ4DS0BB8=", "G/S0c/DHeqWslKRpciFrM52ZyTOo9QNARLS1Na3DiKc=", "LGt2pCov2fyBBTeN5RdtYML4Epzcyon6CwDz7cZOB5s=", "KJPQy0Jile3Om1UGtWorhn6vSLCMUkKIjveXZvjZrtI=", "GS10v1jz362QFhKYPGvMdTkC4iQaNx+YgONRFQ5oKSs=", "G/abtm23Pvag4EaJ6WmIluvthNl5ZoOBE/XfX1cQc20=", "H4IBqAILop6FIaGgzTv/UGA9qvrwhPA3Py7baP7nMI0=", "L8UdevpUi0SfQO58SDhmVdsCH5404UPFGxOCOZu/bkw=", "H06QkRTGXWLhoeRm1JaLqfb6YSV41HTiXMHqE4iPNg8=", "KVf4qlHRJrmWGVD9cuHHIkZoo1naTlwL92HUmRPRR+w=", "GoD5V3yDhK64iJtjNhB4KE71UsYtLMCIBmfoXwHQMz4=", "HeQW4IrThtZUs3/Sth6ttbVV4P7Bt7CdhDW+6X5XsOE=", "G6LOPW41LQZDstPFx8AjttF3fyRieM/m4WVOnlQTtTU="], ["MEwprrbxhzhHh5V20w8fboo85BCCwVx2Mt+SDW21Fk0=", "K3OA2LJbymSbP4u9CoauQXEJBpvicGb0b90cfIfUxAw=", "BMdyAOVJSxy4o9M09prluvp+h3W6GSTlY+/lke/zAvc=", "BsC4lm35MIDDrBV2SG5hqw0CdjeqxBuzXkgr+hDjT8U=", "JMc/QlkDkE9A2/9ZAiXyUc4ZgKWlzi0HrkNuHQkHeNc=", "I99vb0RIJzx0XOU9XXq7XSbEZySljWiETTw+5F6bkks=", "HcGxrDiSgBiOk3VmBxuEv4GJuVXQV5tt5eqKUTa8Luk=", "J/ccXKd0ziACi4FA8URHIEORfNSRnP9k2EinRb1WkYA=", "IrLuU7MCui6Da5h4PhXrbenRWnLMfKo3TmG1HdDS4sc=", "JU2FBl+HJx6G17QR1qzCgPntJXwJjJ/bBKLKTffH12Y=", "KGIHk/N4v+iB4Ji9LsYr60aJnzelSr0FPPsLO7jV51Q=", "LBnybQg2Y1sE84+jDuXGSPoOobIC6whGghrNPGmc8GE=", "D57Yfpobp+58KL/XrDj/O6EISfsE0zIomLqf4BBPtEU=", "DR3v9CJjt8rooSOhZBtyWAFUdhYauIHh3CDhZbPwRXk=", "Aa2IKyKLXyK59qAuELoJBJySgbMq1xgYUCtmrHfuOsY=", "GCK6jFWODmvQ79GrS0USmHnkO3pqzwdXmx5jQ8Uxokg=", "GSwAXXRsDQRfVTDxDziim1DLbIYDlBDmNNJagJID9JI=", "Lp5t5OdFGT0uuLibW1c+3fimUGdGr7mKLbhYE0rNgI0=", "ATNzoGLHHQdU7osYct0oYb1MJUXoB93cZU1or0Ouh/A=", "EwyU85qaB9cdrH32H7VsuXXJCSrCq3OxE7NB6BmOqwg=", "GTTutyEId8PC4H2azntyq01lm7FDH46K55oaXo2v9e4=", "IlRzZbkGn0Ga6Lk3CBbwMKOHzwzmuI/cVPzpHEhdzfE=", "EIsgmbcmTuxQ66tczTVYo1njT8oc+2nfTj+Mnan6qnM=", "IrlG8Yhs7gf7Abf447xYXqj5p/zbKq7F+qh483jrIA4=", "AikzeysxbCeQl2RNj6hh5eXAc3fL47oWi1VhNUKHRoE=", "DpKDy4X6gAEgNEyrmn95LpdfXCXWT1y2pSG2JmWvdFE=", "ESlWv5x2PsEBr5ozUVnfB9GwvZC8hL4pGv+ahfMPUWM=", "JvJ99P2vM/PRLVlIaQZTrR7mJcsArvkrc1J9NzZcRyY=", "LtTEtz4lR2Irt4QDzZg8bx0zslU0En6Yp0col6hOSzo=", "CfAQjq190xUE3iuEYHaoAZgnCGoMTdZXDBt0I8oFsM0=", "EXLG7BbMUC+8Yz+KTDCLFFUdLEgitZGBeZRuZUXp3l8=", "JkiO5fDU+LV2bFuMv0FJcLdQ50iKoxaXbf9aty80nxo=", "A5KuzQDaOL9OOfsZjvlucLuHdLgVKXDdLhYptR/xCuU=", "L22XHNX5kxFErNm56Yutbh541gy9lm+xjm9jCnbfprY=", "BaeV0SMNPHgblxdzW/RUZPNsQd8HN2NkmG0P0SyDF8w=", "HiOKNi/+Vgsx47BQU55sj+DaIh+6GLEq1mGUXiLl9bk=", "A1++Pg2dknbJkKOxcZ4nVQVFoHf2IV6sskea8bNoY2Q=", "B+0UEQ6avrNSDhRoLvrXka1cL+tR1VjtATZ1KJsca9w=", "EdrYImcXJO5qeG4hDpU24K2geW1KoPztacHUEeEeDAY=", "EQsykHqshpAFRDrWajPOKFCMkl9QXkSjS1P3CjqkU4U=", "BVqPS+Ss0m42Kk263znBmLQ+oCXsQp32sgERd92ObPo=", "G86ZzNDzdHi+PsxbZ+x8CoSwP3IxYw3/peFs5vkNa64=", "HWFZWnFKXxsypSVd1VItYzoOv3/fgqnPsiJxzJYsgB8=", "DeT7qO8QdoMkqh6R5gbyo8Pz9qKdyNMb96Zw0xaVvwI=", "DurxF0DycGVCOXecuDoFGC0MmPPUu4p6EYzkwN5Hfj0=", "JcOXSJ5lggqVXWKEwAJCeheEIz+qcInGZ38QPS+v23w=", "6zoWA1bIkpSVvZ9Y06hlf2nz7sqxUXEj5ySpRtxQxA==", "GRIv/ZtkMKb2yBysC/yLSI4aKHWOlAf97493qh/kwO4=", "B3DKTGeqQKFlk2UJfdtw7u1tYjBzkmX3Z4bL6giZ6CM=", "IM8999u/R7siDMrw7Njz1U4FdWKKcpGnLPjbXkLhSYs=", "If4snJYl1mqTH6kxv3++psKAj/19B/073hV3WVfGJ2g=", "KtFYu2df8UsdzdyZPZ1gpbTp82SK+9tb67LNmpjMuIE=", "D4nHw0SZ2YHGzDdsb76vyIt934dRXf7GXam7zc1o6u8=", "DW8zrGUONdPWQqo/01kS/f5QFLhs0R6KgyF5S5qcKZI=", "Cc3NeFjyc2NvwDPHeOX1iLn+YxVHYlTxeqYCwgBlyqw=", "K8aOAp2AA1UwBkijb9iiQVd1Cg1vsvIwOQZFHzs9mCA=", "Fj+KJCeAXQJiDFS8HTIYbuPQfaxB2SiemqPdLK0zdgE=", "K3LLBC4Hne6NVrF2LQBSeQEFOV+gKZ55zHL0wnv6IPQ=", "GqV4pe4sZquCmf6ZEzCJ6QZ2xKLm1Wy52gZ5//bL3P0=", "Ji0VKasef1iSUDDmyvDnmhTENuWSbjPNedMhOIuWbfo=", "Gqa3HBe+M2sbHPI4TW0+4Kfs4a0gA8pyf2Nr1LcGF6U=", "KGqKLHH1OZRSShietb9B7tV5BNkfRO7kCXZ3g2JUevM=", "A3reUu0pYNgLwtkrgVpTFYg81C0mcJrmSoIv+S/zc+Q=", "DWQfCXq2JgstwkCoW3eZVB9uc6OiVknOmLS2SmxJnc0=", "EXZRDMZ0sPDKqwD06b4fjG77rHtzFf9tQWkYS47wCbs=", "KbZ4ORjzeoAV0SKrOXE4SMqEAIq6pxaIKwSSxszRVkI=", "KKi+WPEQ3YwrkEKPtP61m2fv+BXpKPt9dXR9NcvEDr0=", "GD8mMuPKbsI3foNYwyBdI/khG3WfYvyrxfsjFNByipo=", "Bq654QC0fqzC2s3souqZD3Bmp54sfIPySQvas+tDYgo=", "ISlJRnzdgH6PNXbUA/7wnpu2PKN1SJdUHGzXfeTO7a4=", "GFj3R73fWU1mPKSf0qq5NAL/nRhssjCgJdU7jUxibnA=", "GaKTresJSFzMA4ALghcHBg3CfoZj41XpCONo4ui8AVA=", "HUJB7QOCeSY6GE6zqrfy4UMmt/rwQKSGKM6KOMewq/g=", "FpKDgYgHH3P/gnNCI+WZnHJrBV3Rm7WmjlE9VwVdi78=", "CB2BndpXJl6I+56190VK59zeOaFLAPRc2xlAbovyTvs=", "H6etWivHmd+jipxYGw0XmQ0fU6FF4m57EKCQGp376Ko=", "FAEH2XVUtV7ChQEapT83JonhbWir12PN/6v4cYvMd9c=", "GqblLAWqfUDc5hvDiwOKabs2SQ0gFNrPT6Rucb4BKtY=", "Izx7px+eDKCewgJ3/gmpY5mhR05NylFY6XU2iS3nK1Y=", "IjcJ3riCcHbynCB3jSSiAG+rWQCSx7s08hLDMbSxuTI=", "FBh8TpTQWbZWVZHhbf4s6kBzHVgsFIfj774c8wWptFk=", "EtV/nDd1sFCfXJXxzC4X8SZKUSGvpjVWEd4qce4j2AM=", "I7oGuoMFgj5eYsrB7SWIi2I08TKUyT4dNtXy9zyLYT4=", "CQGDIrjydGI6TvBWIiOhZsD8pZfUUnro+83yl8j20cc=", "AajQ/FYW7cAjjlKH2ftoaUaKg6wWhFLFzz+aQGNFLyI=", "KxqNuao7BgvkKJALNSgIoYIenJ80+MjnWxct738LPQc=", "FOeMtlJKcSXXcY1J3XZSX1jPJzmrnLsNQI3PLhL2BNA=", "ASCLc0+Xi9rkVxS/t20/qDxVjQl26cmh+pOh+mn3vq0=", "JstrfB1l+eW1I1w/MfnX/x2BfktblF+slKmbPP+sPVo=", "ETRGVkMaDYfeluaAb8CrueFRTN8XXWF7cACLHN+n+xc=", "KBgHeOlNkA3yMap+VR9tcgfzNE9bQWTRmtRiflOq3iU=", "FJfMBYeqmmYssum7Kua/PnWgcW2zf/By1sXM5v+mUnc=", "EVW4ifF5jBtZfN9OqYt6IuIpGqL0nUYoF5EVrRmBeh8=", "E2vPxJ707PnGE7/vrOEpZEoAooPI6VZ8CwFJ7X1+Amg=", "LJTqMY324xMdhaRoFoJVHOZS2y92/2cCEsU3WZTS2ps=", "EaAIV37bh+UoUVnhZV1wtfatSrvz+PGdZu4acXJiPM4=", "FCYrh59YtVMSbMF1dDsJtd6s9a7Sl/4+QSRBftIBapk=", "AzjYa46E/ovWE9V6OnE6welx1SpYbpQQa0nX05DJJlg=", "GtFph1EB4WLEnsJ+wyvjeuPTefNHkw+7ZW1xi4fBTDY=", "HjNlSCTJFeFvrUoWbuIW0bOjZCjZBEPckTH4GN+FD24=", "I9FXAdj12gU4ZqB/R4jElHbFUYyKgSKV3uOqEHTbbZ0=", "LS+6Ny3nBaoAXCHbTXG7oSydR90BYbzUVAnIg0I5SOw=", "AWg3HfuYs4D6LSYwxhL4YTBC5t+QZYwjULJw7s6Q1n0=", "BBIRLs0MrGHERc5GqFGLVuDyuvg5SIWR6tSqzthfoB8=", "I60O2x9P6XTu9UP8F/zX3BoPBeLOWsGON0yHvAn3XHg=", "Dta+PusLkUfXxQmp2rS6LVfHudSyeA+wUVUl/qQnjrg=", "BpDQgZiCPBD1Gn6jy0c6bZjtDP9qFwabUJcaaFZ6exE=", "C/XK7kiM7oh/Z9syBs1dok7NG6prrbRLx2F1fiE3zjo=", "A9wxkGgpVUTdMyIZRLnihfchn4XohVl1xI9p937fChc=", "FkwPn9NY4qAR5VkxtR5WVDUrtv3Gyy36TYp1ci8mIcw=", "B+iXjoixwHiek5fgnJ6xDjaPzockypSPbyrJLPIw5uo=", "AixUYlCMSAhns82W4Y3DxC/9kOFYbKQfpnFYg4zfFZM=", "kiuXqS1qEfsYF40F8FQ0W0PbT1xrkcc+KPbOOiLexQ==", "F2JjA9G9qOR91tDaNC5DJ+rmxCAFJSF6IPYibLVL1E4=", "Fu0tcCxvhIA5sx/4f7Har4iyP2sArNf2QJp83vg7WuM=", "HZVSpC3vF1C1XSftsJziZAn4+JBQ+3TMUwcveI/spsk=", "CT8urGwIsKQ9TfN8GyDRllx3ED3i5t2Ihi93syKjLdM=", "BjZIJZq/G5/rjAsD2zH1WeR/DhHeKzcbKZBDkU0OvaA=", "Co24rnVwgYvZznwC3OiXEs/AT4ANVfFWLrHtJ9qd6u8=", "Kt3Yp/qUoBHhKRCpiyuK5Th3ASQu4igd8TL56d0/x8Y=", "CCUyy8mnLgVmaJRvqwjqxIF1R88m7z648Vnnb5Aj3qc=", "Kry6Cq7BQdd0LA8HhdqicmIAtq5p1GToSa/XBGXJtVc=", "ETrALVl3islpAuP90FYsUEtBjPio40nafWFFCi/G1oU=", "GTp/Y51M5NYtx1Z+5xiFP1xShLoJ3kKP3wKEbuIjMao=", "B21JtcDceN2cjnzMm1o132nc6GgFqkf+P4zwYuR+lc8=", "IwUfrqN6rI4SrpS4egJBF0exTec3UaoaP2oH/umGleQ=", "LDqEhZxGvtwkEgRBu237ETwJ3IBwsuDNE57UnJZHtzc=", "AWXfRehGDLe0I6lGjSk1wUyTwzxwDGVOMsLmdD3lnes=", "JDwdzy6AHfG1Orcq0x/CTMyweyUYWUxOXzAk2mcSFFQ=", "LU8HdIhRhpvFgSErQxwgyz4mjLf2rvJy3q72bpKb2Fk=", "FEXdkkjov6TmaY5/UVU+8aFS032IlJ4VucUMPoB0rKc=", "PzEo9fzuoiNDLTHOri+LEbOKFcqcP84hy4dW6OCWQg==", "DldLYgHpJ+XzaalmFR3fxcBvrWbmTV4JcC7xcrWt5Gc=", "B4S1GnrhB2wXN+ri/Ew728IYeyj3FOVs3eDNMiKSqkw=", "KJAS09H7NBnj+oEpTzpkwVaF/6pliSfAnBgzzlnOX/c=", "K88+NauJGeBdVRZpCL7KI6cRxxIoTEVpXGVY4OPaIvM=", "A99c3BD+r9Nh2XgzDLlVFbwuWH59u4naTsrFdGG3W20=", "GdxltK+6qBJwFbP2jTW1V8j6yZON7pWuNeoS2mG33NA=", "H6J51Tn8m/ck2i52Irwyb5U10ArcWWkWeR130DvwFsg=", "I33ZbOA0aYWMq/8YlE8FUhlx0a03PtbgQZh3VNv87Bc=", "AxJhY4zDdi6wJacWrTvPHWRHoIDzzMYPgRcxUlT1aNQ=", "Ak+0AwJuEBYGB68uCiFKpyVjfxmvftRBMKlAA2W/Yac=", "Cnc/m77Gw1tdepUAVHd5Y2bE82ymNOlLKDIzr/9XUho=", "L/KbfdBHUPkmuID1Ssw58ugohS9AaYr6wmYbMFMnhYA=", "FVWoILQGmJPmYl0RMEnEa8W0OU1ifCZorczTrAxkkug=", "Kl0lz3HIHlsSnn03peJyja1dmdMQnSOhjEYntK/Pj9A=", "DXScXe3O+xkQ7JRQqziNp66yWtx4zQKadbzsKVWejVE=", "ITSXmlXa1kXvg4MiBY57yO3jCWlIH/K75JbYzNaqjKU=", "Gl0o8ex5qKcNjPt4PP9MK5bkzlvrl2ZaD2pS5zpwu2s=", "Ikj+8cyXexi/UFGlcTdMNsrQszi64he82c/wOPzXvFc=", "GjEFwyNNSvvBEtep840iIGwKHncRLWrCbG1qpj71AIg=", "Bv9F5s8mS9y56LO08TpE0cGXrXfuU9Avq9DAp43fauQ=", "B+o0yvf5yXNPSJlT1CjK2Vv5jNMtXBjltR4B0URLj5E=", "C7m9TqVi+oh9Tmcjp5jnZBoI27Qs1yhSuAAqhsV/H5I=", "C+Hij9iI5C+tN+cur4hPbGxdA3r8CVe8nrtIk+TKEh0=", "HeiVW191Linn59ktY0XaEbzzKTeowqvJPEl9Gv+u0FU=", "FA+u0DLlGQD+ID2NMvph2YQta3KDhkzrmk0YV9apy14=", "BlOkWs50V7Ry6tGzQ4ZoxX02+vWeKhkTR1Y1bOXL4TE=", "BtIzaeAk38MaHjbNkRT7eJIxbcV9pmE+zEHKCEmhp+U=", "EGojT35MXQl88A8lZgmwKd6YPQQESmYCPUd4l7ka2xk=", "DVkHw1O2dFQMINuHLNbg3ovWb5s9aROWqgZni1qbi9Q=", "HIzEhYzc1fNq6867nPGF/rqAmpIwj/X2O2bCsfUt0U4=", "GHCaXtVe5PhhT/BOUDhyAh6I+D1IjYoFZ1l7YOjNs/c=", "IFc+t6Qm05/c1fRvoZlz5r5TEWDnWulAG5nd1+KsJcU=", "G2ixzrv1m5biOuwR8HV2m1SsHn3kT/E3CPq1qb/hdxk=", "HnRij9KAtFHq4NAK3ZZflb8Z+6Q0JcPAWJIHeC9wK30=", "Gt9mcrutqfg0lMorq5fy6Q9jBSX5xoM4uks0zMSEtHg=", "Bro9rd9o0oOoX2WgrBWRNGGnrAmjIOOU0JqlrpelDbQ=", "I2E0g+gRysryeCDQqcpVKtIqsp1PHVefEL/r058U7mY=", "BboTcCg7oxnPF/YxqSkfzl4OaC7B0BvW3yhDUo42Pbc=", "EwocGoPpGiHLN24N+BsZbYwinsYN+FowvOTKj0ZvxYk=", "KtdFFY4L1a7RcITV/hLWcbCCmoM5Lm3QqQocApLsoA==", "GkcD7Kj+yEzYI01fxGdzd2Hm0ta7bVAqQOJflAROCu8=", "F+7aU2CLS+fSybZmTdj8ZyvUhkHin2QCv1VEPGZ7q0o=", "GvnniGCQ/LvnPZtwtynun4o4TEhiYm6mhWc7SDeuJic=", "LDANBEEveeFcld/USInvSn34KMazJ3bbN5fGdPzLX9o=", "D2F8FcQcQko5qooWAcXKRCB7PG5EsAO8Exefp6+4Iyo=", "KA5nIeIzqR9/JgBPdTqCqjQD+9n/QgQRwFjvJ1+1QpU=", "A5HDtMaq0yA+8+nX0hfUt3/x/djGOp/svl5wLVHFPyM=", "ID+cFK7dYxnT7ITtdRfV/EcDqghfRfWQ6GUEITsX+2s=", "EIQr1XxHDnGLdVU93xgni2BZStO9f+EgvEbLD7RQ1CQ=", "MCUMd6ZAMPMi4Pzkbrl4NlWpNkV4S1IZwJ6wzPP+iKg="], ["FI2eRUIGaxJdptaf8/tnbr0n5qOKH/QoG9Y5yXr2/9U=", "C2CiiAUyQpX8r1G7iNlpI3LL9O7xy6i4XLwFk0ZpGog=", "LTj4Eq0desecMv3VelbtuGGIXyD6S8bQ2ULC9B6OSn0=", "JXOKzRFjWAAzNn/Y8e4ZnX6zw3iR4GvCDmtHagNXWIs=", "JH9pZ/ykJomujiC1p6GY1jCGVJt4wWIKUfXTaCTM9D0=", "LiKBMHemaLK3Ukm41RWj3Nk1AgBmlCRbsIf/BzJwi5M=", "FSPqib5hvkfhw2sOAkBowoxI2nS/cGmrLXc4nIPUdPQ=", "FGaVzhOCMOCHtT7xv4FgHyWR3TRKfLUJ8TiTk2ng0cM=", "EtBdlXH6S0FxiG2cLNRMfX/FpBJRlefSjDxHy1y1t8U=", "JCchFHCE1GE1Q3iJdxEfP95siTJqVW41vM0qLnPKxos=", "D9khuoOVpd3oM+bbpBczhQB7ONGvXjhBo0XJpIDJ0pI=", "Dwu9x6OeUUaSny4cqftKY1UM6o8SEJwdguYBl11YH10=", "DWUAhYiy7hpN7gMTttQ5aVLZAThfLhr+agoN73Zdwg==", "CupWe+MeHELOM/WJ2QM2OkgvIcHD2P5Q+m3wGKLcfCU=", "AvozR1ewPexr4d91jr4DUzF7NTFuz8cpNNBp8YI0a70=", "IYDdn5crHrXogZqEPST2UOglfnqMz27vP6PXRLFvBzo=", "F4ej/WbLSTKBANNXTXBwGZpruIuE326bRK/Ol5gjPE8=", "+/UGtnFNZNyGI/wM9Cb5GAU66B5YR9M2euffAik9qA==", "FPV72z3cdbZesHIOJ9qglBKzDs97EV6BYrnlX69J9b0=", "DasL740tGtyA3MpYHhiR7YALv0FT7tFc5x7l4LC/lAo=", "Jfa+OpxfKm/zIIeyyqAbOht5CYEfAlGW8VYxkjnTWaw=", "JbVBuWkjsXVQ4TekpbwNVE0Axdp3FcbwC9/7m8VtDcc=", "K0rQhg+MPEMvKgN7Di99p6Sls2AQRLokpWtbmj29pA4=", "B9WBe9Ej+QpKPC13Uo/ZNmMh2NxpmIRYzEJVgclkOvM=", "E/2jsdAqU7EGxLpGUs2Q9Ga5es/RNsmoQx8dzlMapEM=", "JFD9axoXvh7EY4eGvT/KTMpM2HEmjrB7HlrureNvy0Q=", "HAdT6/Y3lKKd/YPrDQ529tHq1YP3L2TAvjmu+eV3oKE=", "DxENwAetgQwPrlCImb7SCqXMjcPYMk8Pe7w5lRGdr4w=", "MGI8LySnxqswfw6ISIoAmSL8K4I1/HQVJqTT5qWSKK8=", "HYlYF+ePLx8Y5TEwpu2L1uHRiVQzgPaRqWlIPwrjFIw=", "A6vxdNIHUQJ5f2FmAQXPQY3tH6syS6410TaxegJUwB0=", "I3R4Fy8HPRXbqdEsrmQz7nFSGsKUtU146s59yUGy+C4=", "GA+CCnQI3uc6cqwC99zHX5miufdamquCN303Pt3KcS0=", "Kl67p0Tqem6CEPSD8La2HB/uyqhnyMEa6gSIuCJ3JhQ=", "IoLYMmw8EuD3V14azEvZQYk3MuHn08C83dNeNm7dX34=", "DrZ9jmh8ssugFVLs/U/X/8PVeIy0eqOIeh8uw77rCPM=", "F29AbMBLvMS7uCxW5OwgvO6liPG++P11fh5Y1HVFt38=", "HE0M7GyLIr4PGj6eMnBaiiIdiH6gvuG+oagiZgiQVlg=", "HjXex59aV5pC+CxFsaGRFHvMTj/QL0WvQS7drgjbStk=", "B1xKM7Eon3kjq7RtemhO7acSAE+XTvVxX04rUEOX6b8=", "L0FsFfkBgYFSkRCJziqWAY55qPt/MRxMak2e6ffYqD4=", "B6kjZ9IQKSZYRJ7z1G7Ja5gsNEgFO//I0nsXpkP0OXk=", "FoeZ5R7y58e0NaIgBS4GKV9sCLHmsLUSKrox4tlT5E8=", "LEIstAQM4iOunCHdczGJa2hwTCao9N3Id70GWedcjEg=", "KZZv7ULAmzVZHttMrAV0RB38/U9SvwzDGy5iS36sKAo=", "Jt3BRalEV+rwKDh21Op9a/ELeCe/OmhK+xD6wdFyiU4=", "E6ijBZCixdR29g2enqekwXg6X+oHevAymbjDiWQb9MI=", "IdEucSLENyUWVnYIgu748xaMI3ZG86WKUcJl2LRRhPY=", "JxpiVzBrQzfM7qVwOdQE4ZlgWMaOcdY84TKYEK8tpO4=", "GYBHhgfmireWGGDjjceNoh8uRT+JrN+C6mKtkpXY9iU=", "JgZTz+DrwFYrVLlZm6AGado0OjyzoUxk+GFJ2FEN+Ko=", "LE/XvidR+LYSnZlzUQiAgeYFhf8BJJhCS1Jkg/g3L5g=", "BkDJ229Fhpff4XYQsGkpCMx/csHAv1z/MxaMSGfCKg4=", "CSXmK3dyFkBVAI+HZbgn8lGwBvLdI3BTXfGhbocrkjw=", "CvTYzXTq6796Kbzu3R3PCrDQD43mRCu4Ym5/BLBD9A4=", "DPajTizTdtawANiwpe0ATnz8rYmH82UAlfTZdAr9ozU=", "HnXcabe5T5Fbklp3MoC5s6I0GrkGnrh8iDrIfaEC2ec=", "Jr1YJZwn+s/KY+JIq2oTDqmJO1OSjz03OgoZfFwnN+Y=", "FRG2wZrvCPbnnLxygs9LXT6weq0QufXWXgBeVDPbETA=", "JtgW+DeGFeoxsIZzuu9nPFFRwDalo0/xHMDOr/5K2YI=", "HDjWCBfDpkahXYLt5TqO+CH/vrKxbI/qvW+n7QLmXCo=", "KrGSNXkj0RmBQ0FNRIZIuh9gqRf0gGu8KkrTsmF+y8c=", "KSCpAqwsEVI8lCXqL8+c9DC24nwK6fWH3Ju765ZTY1I=", "DU6b/cb43Bpu5auo5fn2fvO4OlJgEpU6mcg+2wrhmUs=", "KVv2du+V7zCcHT+N7e9XWC7DF4B6cuwQZ0rc0beaFxc=", "IyGA6FT+3hozWdyPGl4Uw657UYb7saP2pv2fUlI1GBI=", "JAWkPzXSR/+3XedYa6Iof5sFe7MhvZzpvtjImAfWeXk=", "GJMbJ/86npKQNxey7trg398z6ctfD7EKNb+o87rbzcI=", "H9bhCvGzGJ1CVIx8y5N0nEFGrfOZe403fAlURdkK8JI=", "DEdy/5q+/HmPVTVUzDkihLKorEsENwjBg/GL321pvkE=", "In/Uc050cWQarPZkgl07Fe4Q0Cg8LcNTZMmxZ8zsqtc=", "Ey+uqiULYO9X9+CuF/F5n8lTC6Xm8rqtrwGwiVld+d8=", "H+JK+atiRuDIUQTMMbpZF1xgsVVkdiP4k3GGCO+iBH4=", "LzdrGCFSkPJcP7mHzIlWmj8YrEQ//xaYlnjiBYcb7LI=", "Ly/A7pEqoCh1sJbkgzZBHu7Kbz3oUVL1EDjKKRvAyxg=", "LK04Ek2IJBDDhrTrFEX/4cc/e3iaJzqc0ma8Iy5MaLA=", "BSAC3pwEVT30cWxGqAEC7UU76NW/2bLw7HwdMAKn57I=", "MC1oCtNETgJrBs1uS/Ys998jT/nlpGxIwXwpN1B8/Ms=", "KzqdzNOHaBl6vDtMtkCrPAEgb0mt0U0dcFw3HH9wWv4=", "CWpuR9Q0Vwe1wl6GyKaQJo9egx5t9Nhk4fP6kPLYU3w=", "LisAWgpU0P76zcjBU+hPXLtQ68oQX6DwJCND/EiTeDw=", "EcisKn95bHhS4j52zbV2zfNb2rppGPkMv+eqImVVSpU=", "LC5mRRqtuDDxyR2FVPLjnk7hmxVwkFKFH0gWKbvxK5E=", "DbB4yeL2jrfY+GlVTaQ0uVdvGG3ZQ7H1hrm+YaFy+WA=", "B5Mo+H9zGYQw4X3NdhO/ZRr9yGtRQpX3wjjS8mdhir0=", "BXkk6PPnmARNZZGveWt0zpa/62dt4zE+tQ4IEBNriwk=", "FzC4u53QPYMmmBIl6OUfuSN+TAP73eXw7hIAQzm2uaU=", "DRIbVN7yERLZGlvJ/tUkn1373nxjvyqmPRTLWbDczvs=", "E5JMG1u+bVwBlE1oI3DBPP39kPF7VfB7BYYHE7qUV78=", "HPr3rgiWjHYnkANZjrH362t2yj77qoc/IePg66pjfOI=", "IJCNB8h+ZcjGauKdLvIPi4BJ4wSoGOdpo8PGPuTu4NI=", "DSJfQIlZ2RdoIB/cA1daaOeoVZOYUsAs9k4zSPs4PUI=", "ESeF1ysJt0mgMSCz7Xz3k6mc5XEK/S8H0e6zmXTwM0A=", "LcAf10X47EPWGls1W0WXUAEOx+a0oTrNzKYn1/b2ur8=", "FvNa1NyAdfbBc7lYi+M4Oa1n+liDeDsK5vBgHecmr6Q=", "G7wUPmyT5nQdrjcDcoX6Qu+Nrg1v43KLnpLnnqVmsnc=", "DffhfaWXo3iE7ANCm0l2TZ6M2kb9ZWoSL4xh2RI9Sro=", "DXOwwKdF3Um83dYy1OQfV7OcKNtyJSDCTLPZztDYqzM=", "Jj+VDJUUGiiHP07MDRjIK4n2DnBCyz6fEoz8XwPjhYA=", "GV4ZcVFg2ZbOdGT5XbGb7CxxwC+roPLGxc4K10j9PTw=", "HO5yBBUbakerjO/+okTRkoYh/iZhtcCV0cwkwaZXlpM=", "KddpbOW7ZvK+ptVczsTb1GQpjYAYE19zTRFUMMyCxC0=", "JsR8GLccjoHdAlNp4S4kzN/Oxsq5dMD4bamN7t6s7ck=", "D6yWMXYMC38IJL+BSSeX24yz9eSRgEDErxekwEKxFuA=", "B+fqeJqy8xGE9ak4ILCKT2vd8C/oP3xCpq9ppjKN6GM=", "IOs3/GXvz42HqybHy9JM4rWX59mnP7byuds+B3VTS8A=", "IPQCi2O9/rpOLa1h9CMtKlhFYK63G9wvbDkpp2ANZKo=", "Bg4gS3wI8XhLNmo3qG0NjZDDhpic0Wf8+ryMJ0Gu+c0=", "QIyt0rDI/DnMvoNm4W7e4W72/LALyguENoHtVqZ4Tw==", "FyKuoycD9QbyTFVR47WR3ST8SrnRiMFJ/Rt157kN01M=", "KwVuoxaBGSjZhOJ5bVaELkRFAduqjNy1Rq9d42Nk9OM=", "J28SoCqkgTPmYPbpPO7PpgpSnbtESkVTgkuYHjOW0Wk=", "EZnIlBxfj47Qy2fALF4BQ2Stf3CCIu8X6CN45MFVqMs=", "KKPSpUeWe72HfrsY7SOOkXBrJZoXI8HjRd5bVFuKlD8=", "JE3eUOxl4OZsw7wmnKloniWonFJppLf9UTfpq2t7G+M=", "GN0nGlT25aw6oCAlRwtGEskES+AMUbgONHk4pSj6nXA=", "IY5CRiLX1B8zYs90MQbokNjSEIaV4l0nmi6Ivro9uKI=", "HwXF9QQbF4pUFDoC6IUKnpRiWVWvBH2eZY583lgPzUw=", "GR2oxjV5MHFrwPxhS4C3HqayVA0UvL/PJRCGdk8/bn8=", "DVS/u/ioz3yZsKqOamiLlk5Q5o8t6M4mA44VWsBjL9w=", "IuHouy19EhapgU/1RU8GTWepxW5L6/dwDPobZR3s+O8=", "Hw+njcfiMA+jar0qQMhY/BCuFFW8Q2ldEhwYeibf58M=", "FRyN5cTWtBJUEwxpd/eQ8Ttz9v54b0fTLWoOCY3IyhA=", "GRRR5VAkC58PFaXw67s2Dqm5jGcw4Ql/32t7gCgmZDM=", "CIxYohxKwF8Rad5nXCxUPN0ivB3QbEL8xOuJC/DlGMY=", "HkMaAaNM9yJHgXs8VoTwQoeMbY9n6+3dBHdzdEvM3PM=", "CKatCjYKDyVY94q7JopMfc4ZzOz5iaNK0qu86k9QmG4=", "L6fTpRTYebk7kwSf4nbmBxbFR9TykBJsFei2ZiJKz6M=", "LzUtlnXajXyBSU4BUTOluLTGICCJi+RGjeL9gaTCzvg=", "D26+A4jUJNoMeawyn0tXHMP9jVuuVNWW5jgtp2nE+ms=", "H+TLW7cKnaJOD1mDluQ0vrpe0umtU5lR3JOjjDf+P7Y=", "KfMW2MfzyOeSnTCEm6me32bmGi1BTmlgCB0BFPRcB78=", "BP6++q4+ILU1ghPu8G1Sx7eBek5b2NtJAtL/3ohoVk4=", "BNa4ZM0TCu86Bmus4nGQIEeqBWTrBXAe+vVdHyGO7LI=", "FZdH/9AZw4nlSstoB0gC7fMzMmYtXbu6m2ejwh2+1Gw=", "IRa/v1BncWr8unQZsHszFfDunI3bA0pua1/S54eT7zs=", "K6dsx6Ja8VaV+tuP19Q22RY16z8lGytG3DF8j1BgxMQ=", "AjhGX9Jz5TjZOBOSEFIKB/LOO99Q44GVlIbb/U3Qs1w=", "BcNApTKO1Q0rENJK8R52PM+dMJBuW/3CoPI/qPI+3s8=", "J5q2HP5PJUhc6kuzSRWY2BbVc045G9Gj7cu/7g2hxro=", "B24vvTnU+rKtbejVPnAZR3FSj0ykAY/FbGi4XwQVaNM=", "B1z4QEQooaOPBKzPUfXqan99fPZu5BIUnCO/TE5h+tI=", "G0W6/1OX/qV1eQCySZwKpmRH5eY3IlNFe50kct/IYis=", "Gjn77/QLc7v/9yMsJtkttK/jKGz/hA0ZO0JWpmQysJw=", "Gk1ODmivqpnAiQwyLVjkbr/fwkgIaItk/SPd705wx/A=", "JNYZ2hTlUFoEZuvSSnZvKvH8xv4txLtYRA9hjYxXp6s=", "J0RC3QLLTUlLs4wopC/AJJSrPq5W4RXLPGWuSqcocWs=", "JqnyRpSBpZT5tUZVPBLfZsD91LRjc3DL5pXKs3T18RU=", "GbbbCHscwcS3ZecCdCNtmB1bAips8NOqvUeO2i+JWJQ=", "IxuUteH47aNAXBqaBQJPu3n4cihHyMTbpq8zsLXo0HI=", "J2pXG4ss9jeuSHNMAcMKkYkHKcsTeGLQmw3uLyVcVoE=", "Bj0Nwc6FxVQzp4C8asn6i/RRHObDehIbZxLNiQV4d1E=", "G1dmSZu75EEOmQoHil7o1q1cS6nQRooFbBDg30869jw=", "EhtlCXg3p1DSTp3KLKYbjvgOHvR4w9Txy/9k1CVtoRA=", "FVvdGA4URnIzIDEev2zhZoFYkh3sDF2UloiO7yj6g5Y=", "LIVB1JRaZhDBZLSkVGsvO5u/bckxa1ZYkntjXYurhYk=", "A0oI0xtS2pAhWuAIdDB9Qh6iDHhmBa5/yH0L4XK4w8Q=", "ElUv5xJO5tIIhqcmjXOpSFDwamAESGQd9VsI55Mwd8c=", "LRnJ1GlNWUxTgnAgcOcFep8Mf3uyq4P/aEgQ3g4hBs0=", "IKfXeUvb6Tm6Fm00roQ+HYTrRjISK3/KJvTjQbDiiyk=", "IlwhPAo8mt3zLwxb2zP9aVdpETXYR1e0xE7rpZRp5WE=", "LrVCpcd/NMZ0wd8HfolAj1SB9BM+O6YqS0Sc9k+bJTc=", "MDoAOvnB5U2dMYmSA5bQx1LJr/4cF+P9uvZ7OBH+x+w=", "LEKifpTLYv+2wWmXnQnzk4ep6fm26d9xyf9BZajtVnM=", "Cua6XvLn3WTj8kryAnGSfpWFmCfpqdMqokfecMWvmDU=", "BMWNRNKxRFUnPdoMknOURu1ZWZzuGlBdDLNjERiEVBA=", "KlxJMd6fVT/k4CB1XYtcEMEuvCNN3VAdb0WxsgWDc/A=", "L9lOuJIVK1rDtz5gYfOk+VIZjzwzDhUNT0TJM+bI+zg=", "G1OVwoHhvVdjIBzRxyo7Xbcamf/Pz323k3BMC7TVPJQ=", "JtGLn/zzmuYvAxd/Rjnzf1abgFAOC7RVNGbWe0Y0K4I=", "LE63aKbbLbKV0hW6D4Hc3Nd+DjS8EjeRwD7n05GBKzg=", "DC4/Zdtz9AWOx8bMPD7lxJVQ3BBsNZKfC9LQRZAwkxM=", "KPFaTf4cdK4SirJ8oyCN/9kxPU6Hp1kTbu4+GUzJJd4=", "EezD6Nkpxb6Er5dMzkSqgLx0oW8T6blif3BeOSn9IRk=", "I51FHqPjlRc1EBlnTLwqhManrdj6YIA3F2iFnpqJ8nU=", "KiqTE3ILStuOT1eVwyJAU7Mb8tYBbZCW5Wy4fwH4ESQ=", "DACJrUnjZEdFoONZYxKzS6bA+q8Z42K8tW9KeXTG23Q=", "LugsMalG9dcb4DuaBBWWr+YkycamxJB6i+XdJ0w9FSQ=", "GuDp05xhAKje0+fsw0mIt1xTONyTbJHG8dlcQFwHu74=", "HxH3XH0KyEEAGzEjwEVSbpjCA9GmyqGNY18vK/pzVzg="], ["EeJ9p7fvlklIozKXTQfM7qd4vDOu280J3iIvoirQsQE=", "H2A4G4O0So/mWg9BQvqq/F+/VfeRM8V0DFPwNqMGW2U=", "D8HhrIrTUk69v6RdzFFXZUgjTQKSrf4c1wpwahttrdg=", "CkB5jq06EreLzY8QuxXLDEJrvSKCqB3NwHAITOeLjXY=", "LcCdM1cFEVWYfqlVlENrbL85OwE19R4vZ16l9GL0qcU=", "EEuSQdU0JkUy7aGB3hoVTdF17hUPNJAz5G3cVBgdoIg=", "EnpiCNmPbNOHuAL6RMqyA3s7kfBiLxcITxuNisnRJpg=", "LQdc7rq1Q0HcAvsfUNk4zh39zeZZlVqTDsGPhiX4bU0=", "BE/VwhAaIL4q2SO+vhWkd/QMYDmj3Q10Q/5ydYBCAQw=", "KzAshRH703ArgVVkxTmay4qPKo63f5bH8ISWKOCfm8g=", "B8vjOduQWZRV0e3tHoqHC9MCySp5sdD07ociLM6Z4is=", "EyZ0kxLG6L1O8kyXyAn3iuVIOUyUw98vKP+oEF3r4hE=", "BUAhQGuNH4xwgOfCRTBOS3p5fNI22tktkpsiPyaXgOA=", "BcDgM7WJ+N2yOp1Vnq7s+YaRqNAY8Seb9AbQjyeHzEI=", "JQiozdRQ+Wm2HHSdVmyUWaFurUMw411UFbEuyjhYS7E=", "Jk3MwC5XTKfnNtolByvY++mQliH9T0Fpsrro02j/EtI=", "E3GZ95bTENf+Itg2Y8jmB9NCQH3CjBDSeu3EpFyP9w0=", "L2h3wagYzx8Ic0PcON0SCDNXS5aRVA0DEootBRwb4kA=", "D0GOE6kOQpW9OExNR2Q5jh5EhlBY5thfEDlqfLBxZJQ=", "Gmhk3nynBzD4ZXvtQXxCiqXd2v7ibueLlCyGvmGpYsc=", "D4vi4lPLovEo5zZdixrZX4mGlozGAiREXyvXF8JgiNk=", "FqjZ8mWmb2n61te3RM8JDkkFUsbUrHf4nwnQrnAJWls=", "JfGlHqf4iEfNGcnfqchYesek9LihC/kA0gJwOYuWE+U=", "KNSm7r85KpN4t62aq4hiJFJ5qfLAsWeMttMUHrsUZE4=", "CtdTfZ1bt+NJNurfZv6STYDIk3Rf3OvV6gi3n5E3rtU=", "Bq6eGzou24abXG8jH+3ljcff5CvzgCOUzl1iw6ZVZ/c=", "H11CUHcesTDARsjfHnf3932iBwk0ajNNvSLHIZEEXLE=", "FL1qG1Z4zaTqOhbDtau/OO4dgiGYScw3+8vZNOfeEWI=", "IpBRVra7NX4nJ73LjzmmagmCgwcEYpbG1TIqvbky0L8=", "ICP8uH+J5v5M78PTFSSe2BM4NLVq6rb+B7f8JGsJbA==", "Du944jrQBkj822XrJGxze3tAYLN7a4ReuRQQjxMWZG8=", "HzAwvl2k4WwEaNYxB0pl9UV0Yv1r5ts2w6UiRTFk5I4=", "ENwgC4wbVl1MLojVvButEsSQog0F3MTPVelkTzU0RVw=", "EanPC46X6ibtDUmr86CSM3AzM3iaOQ1y22YfpwscwsY=", "AVuXhg0ag1pwb1Spf/BKFcad076w+GtRyDgD1JDCzy8=", "EiW/0NcBs0khSHOrA3FjGdnJbjzY2WICixfbhD5Kfxk=", "D0667iq8vEnUCKpSxg3MCTyw2ohMSpLQ8oDXsQBgBWA=", "Ct7up1lEzV01BF7Iy2pXSHKHqS0fcM0LI4mk8Sh5KsY=", "GHSHDHKjLw04UpSnPQ/2fXI0r44OxXxjtPd+chMFkfw=", "DNAR7lIXBoLTd3ugCF7BYg4ZsUhdmJiADdKx109hNXY=", "LnK5EHzB4am+8WuyGjCMn+P8kiHlX11MvUPujeKX4Cs=", "B62NjoY4aHRdLAxuHQjdNXgD9GU+ogRXku21YzmffYQ=", "Jz0ymOWyIoTdZrsPXpY/Cmr2jBQBjHKPxCzIKsw4TbM=", "ERuDKRhUba5aGnHTErQSRiudK76Ge+T98InrFYIL/hM=", "DE3sIyiqvuwivvBAxWWxIndTwdvNnkcPkGpPy1zb5+4=", "DSHyvwqy90pes4q/eHEh8BXYisIt4UkMVI0GBrjm17Q=", "HgiDdRLzz+Exm4+Lq/Sec4q9FZ4yIidAG3pUQZePd9M=", "IR6szDfOo0hcuDAJlFOMFTsdxbjWPJa0N7kUNGQqEbQ=", "Ej4EWFH4ZJ5jMuPiCLnU2zkJnwd6EQRVW8OPaMYt7ug=", "CLZq5go14ZKWOvnKPoaBAS1SiKWrxnBlulK7FR1AQuE=", "AukYjI4CoItxn3z4rzB96CfUJKFm5vnrsXK6QYVaQFw=", "BSRYuUFXsOXQtc75/+jgFOr9fPwbQ2EfrzHC2NWbTqw=", "JLsCZsIKBAEK3dUUv3bj2hJ20TzFj6+JZo4ji57S7W8=", "DNmmGdwGIaX0zbqDA7X2naYga/KKBLltT9/TohTj5U4=", "EZlJuRRFylX6bqjaLBHZOJLltM80hVmfQRBu7xSe6po=", "AmXsN7VFzV3BKifBEowxShPoyyIrXSXDuQYZNOk8uXs=", "BqqE58JGzXI8ePo5Sn3tGVluB0//SsIAFxofTHW9eSQ=", "G05sI3UnVlBoqmUmnNc7XEZ1sRSPwx+6vNyqNB9jIF8=", "K8fZewmRE8WrZyVP+spJMEG8Q+jTRL6YFS6YpPt4baE=", "Ho/UFFxM2gPhfrYsD52MyX9bE7g7qEALV6PYAAnADus=", "DeRYrEospl4lxsAosj5z/K0b2z4/G2pzDrR+BN+mUxg=", "AtG6K/3bWHha4UDCORl3KfDGDvYR87N31Krjxt1ES1s=", "KdlLBojjI2sgln7HR7kug3/Lw5b9bDSLHgx0im7gIfE=", "LsbFUAvHmYx7gh0gnGCKYwGVtzTAKlrrFbHHVbeFfV8=", "DRhclwuNA/qwywWGBdLAhxx2ryBH78rKDhvjk6SBfvI=", "MAxYoLPFmJOlrPp6Ctwd4p36Pxa0aJrwU1zCUT1gkgw=", "AjYK6/7ognpLkDcBOm3sivjzgwjRGbMWffGePs7WLvY=", "BDuhOaqs1aHBNJEEI16YVe6IAsrlowqF7a2FOwkrUYE=", "GwWXsAI8yQKXuKTplmdtZSdrGkxkCdfDwmAI5Wz+b2M=", "6xhXaSyuYVBG0P69ku2+2WQXwHuEG0YveLkJYHce0A==", "BjmbWHNQaFVoTQJ8dg+luJchrDAECWEU7isMXqcn6qA=", "kmNuyjGs6tGi5jEx4lostMteXbdmYVhh9PywbkMh6w==", "Lh2UDxXGofSaKPZsDVOfXsRDHrxTPd/vis8PVGO30P0=", "CUZBITe9AsiJvD9mAGNTmOXCk0elgJlDOORKb6QbQLk=", "GOwsWUhVfIaZ5eQlrkK19R24+urbYrq4CNFmIlPmHK4=", "CsFmZ56yhk12dKib2gFsI1c2eDggWRy5UEuJC5EX/ks=", "BNuX4c/58vti4WB3IhwgMGwy9Xm+QNeDjm7BUyDDhEM=", "DE1UCrF9O6Ayj5U2nob7Bz82YIlthaZ5/5xsmSaLt/w=", "LmtL5e74mN179ms3VK0b26sBOrDtmcFjKkicdph/LvI=", "FfIHL/0tbKo9bKE/dwOkfAu6lCsNm6CxQQR6KXrhmJk=", "HvgVXlwz+IVb/cwkrIlduTVVnV28RCUU1CcuCyJwYE0=", "GU9ONFg15RZWRnfRr1GT5n8mVzr+HRL9d2cxJuS2weA=", "Kj/VikBDarz0/316WCxbq1Xt8hUKeG7VHFbG/ytmjJg=", "EXKcG/Cg+RrDTkRW057m0t0cBkNowvCot29VWALZrw0=", "LhP3zh837l8oObrNlP6xBjlg7mQ48Q4BAAdpvChW51U=", "DhRC9fD6hzf1DYk1/fwgTPB+b7Os18fLx4/Sjc543uo=", "GqxW3H/20K2yy3sBxn9IfjyBI1BFCZO8yxhrL7oHeVc=", "DbZKNaNaj9a0hs8A9TJIh/hMICQGN7Bx1GKoiWrxETQ=", "LPax63J2ErRnbmXXUKLLFcgvE7yFjgv2wc+HuW+HlvI=", "B2HR/zqQ+g7OUYcF8vgAVbdmf/ZnBj+1vaqVDvyAUZk=", "CSqERW6KsaJu0J9MnHjfvtv0kEk3u7qq6aI9xoD7AcA=", "DPnLGgqeF6nWv0spbuBTDBuIFBvOaTV/lk+8InlkZc4=", "H9OzSnw6ROGPqOrbiW5aF+1Dm+2O/XIyRqAJRGu5Xw0=", "BLWtGCtLpAraX2nkNnQEF8G8kBtYUV+WnP8vveUweHo=", "F67UPwKJVHWrlCf4TFe5ZWg9RKySVU0UDr0ENP79aUQ=", "MCdyhIvKzviY1Z4UnvhOSCLtqmCR4jaqQb1oOsvUOn8=", "FLZsSw9e42yflGRKQRDNCYJcyMhfbLMoOR6D/Mhscek=", "GNbQC9e4Vhndi5eRWLqqh+X9l6DG1TbCEaPsZjRY+ys=", "DAlMKa13AY1NoBrF0Gu681MzC6/FWpQvuqMLSHbhEkA=", "AfbEvZZyo0DBFGI8g/8lDI5BDwo6EbT+dpCZ+L4jDk0=", "J52XUe5znpdKtleSvrknZ3NTfiCV2+gLryNq2vLZ3j8=", "JWCZm/i5uheASxMGfdSwsAIiGdy+Fn2rX5MAtoI22io=", "AhHYBQoMwI1DPUhzgd/uduOcivxGKS8zZWUSH930+LQ=", "JtxvSE0URcX1wgj/Gkh+Ny8fh4LewKXaA6hfcG70jow=", "DRHqtWfEY/1nlsO7cRRnpqePfYR94gHrcX26UWgI0jc=", "I5swqGbjd4SRuEKowt+a4UpjFZgcI5TCbZnOl8Tn/OA=", "LjXNv3lTNHHkhJqXRn600bIcatjvNGkeCLdO8Zwnc1o=", "Ijdynq1Sc+jWrNQKY+sIgToik+Id/1TqAmGca9uxjHc=", "KQyHI5NvNrkaofxCdoAH6pBJUuwOQUgNB0uW1BcD1kg=", "HCefHVCGDs6BSMwbWfXBSoUK8vOn4q+4/d9ylk/fnFM=", "GTjkIUYF+OL6Wef5DrEOug6YTCSl9cG3GfQUISKZIuI=", "G0WuNqMsaJFQSJBW6hYc847RUG8zpxHWtHFlcnfXcO4=", "LwrIt740nTjwrn99zXzIbrOqBscIs/r/kPaySotpFDE=", "HEAjjebGHcj9tadWEb4NS/f1xOs5/pwGXCaulw4rHwY=", "G0uqcek9EwGK5Ou3kLwYjEtGyJLGeConEVvKxNFl89w=", "FF0P0Vlg3+WXGH3N0pJ8UXC4U5KO4IaGVVylpXq0sdM=", "CDeRpCOsQFBOfJkISYBZmjNZymk8aqzEexkqMl1t9iY=", "KZmIXJR8ndAGFrv8CIgZ/+TA0vkDOwT0CKz88deWUaM=", "CNCmKj7gW8NiQa9e6gti39TyjDH753+6rjkvp7Ba9PI=", "GOk5cKioBwoYNRFMQxbn/8JC6xKAMayghtPOLNNVjjM=", "EmWQ8nO6zdwo/IfBALW8z5XupcFgfbvL8FttspkswS4=", "IaeyoYq6m4FAbP58ZMGwtAN8JB51ZbUnYNdOdyDpIRc=", "BJhd/yQ8u9jqwWt7bwNgMRgpOWbeCVsuBXBDiRv1F00=", "GK1VhEaxyTQuOEbDmNBXJ+vCLUqMA95jgMvlWqtyQbs=", "GwVdkI2o5mLuSwXDxmiGo1vO+2eUbPprru3djLBvtl8=", "GhAmP7Y71PI/26y6b7Pw10mf6i4eFUezaxfE+nncDro=", "EUssP3cwrgihoxu9wnyhs/2mPV2OtVvaxleLJ2Mzlcw=", "Gj8n4g3zxARfOmcGXthpN34MY6mjZ/CfejvGPUAGuuM=", "Huu0jmVIhen9xgs61nuYhTCSP2X6dpg4UbEJJkC+vvc=", "KrOwW5zFiDjuhT+dSkgXx7ux76ne7bhNUskK2dgMKx4=", "C+jVEMPw2O3VcWlx8kUrMQauD0kz2JRAS8C17uzr41Y=", "MAIl55K+X2ea0tT4s9BwSVvN+HblBSPNh3tPzpvTBUM=", "LfSzY4jRHCyl2VwkyT6K0Qunt0c1dTzQx6pIBfrb8Pc=", "DvberFrjIcBUY5RE1PADFmMZWZe0z94WPHXpiesGKbY=", "D+BBdTgxqmprwOoIoVO9WkCd4U7PY2s2glOQdDVuWFI=", "EHEF0So5TbyzGDK1cIGu23PgqhesfC+u4YcNLawUf4k=", "HCYYVi8EFmvPqTuAxTfqizWqB9juM3A/2nYHn3t48c4=", "J/f02RufRSIReZQ4pjjwyA49tY7LjRlOl+IR4VjfRvs=", "KpmC8xyfYotDZS3CAhfZqRvfqUvRJeHgMuT2Ym6zuwI=", "JnbBRRAR2rWJHuj3FUCUEjlpYISWE9EzNK8DYXa380M=", "AnyV31bbqydmAmJxdVble209ZoaaD4NL/9zfWMgN6TI=", "BQJVyOdapOKUuSFzOAPanWuanu7ihga72mQ6kSL8drc=", "AmoNu6ESjB7tZ0vyHnp9IxY9SGNJZ9Da9+RnUBdo0jc=", "FugMhIg7M3DnXxqyZrRvC4OazKs3JieOwgaZi2Lnid8=", "l4Kx+1rDnjEkxehXJTM3pFA5UKbdFR8AWWPJIlStfQ==", "Cml19F0/e7GMfbCihs/fvg11t5x05nrSJlzRaMFnDB8=", "CbLWtN99cHMq017u0bRo79kyp4Dp50y4LD3BxHtMhEA=", "CWGV43UiwWP1/WbxPKyL7nKuS0RSJOvYU0Cmm1oyJzk=", "JtAV1wkxBC7Oi9FdtrCLwUlrdQG68Mi/SlU0/WBCKUE=", "A59dO/Wc6xKFQHmiZ17OznuMxdmrnD15rcHRgcphmKk=", "E1KzDsYdkt2C4jYNOBN9L7AsHnjW+ZzEN+hkC+zFYSI=", "C9jp+wOwNwnAvmUQsjP8/7wfn2P01gGbEQ93QX/jgbE=", "FNN7eSD6/5/xCsNWgSL+OCIax4Pmdb1fbmlJR1WFNyM=", "IgjFdtQ5psnAw4DnBj//dqHyaFu+1v177SPHMvNFUBo=", "CPT6cbfDxxxmwAdaW3oMticcb3Vol503QuKEfNZQqlU=", "MFU+R9QoRPTcl9O5be57bEg9KGgSXrfeUIFk3iRmt04=", "DhDCy5AU8RDLVNJ64BMJiLDDKlX40RHyv3l9xbLDmoY=", "KAGGjAhhvMlTQF5JZN/UR6iIjYg5qn5BTeF2x8Bh4jg=", "I+p9r7/nvx2Pi07IOqHwzjH9/JrF0sygLxTtG4fK9Zk=", "Iv8BLtyrZrdBbcpjKlnKum1kHgL2/kfnUQzpRZZvNyE=", "At/YAHb/uuzZcxGlwLIxRAAAWh8HtsIdkiKFg8pbWks=", "AjxFph9PLIs+Bmom4jLibbk6qiTi9l0mYBqy16G5VgY=", "IHKQf5hMo1vOmtPoLYww+azAzpjRReT+J35ihIlZTi4=", "iWTknemp/uHKdi/78H+MSoEivE6Q57Vn/P8Aim5F5g==", "LcUDJnsUl6ghRTpzAw8qNSMhO/DbnVsGE0LNhZoc2Qc=", "Bf1Cle4OdtxWr0EZ5zdqWT5LsYWvYK3d8jK5Hmf7Ku4=", "IJL/62t3YIcN+vRxgj7XWR/PbmvVsbz0N3XTwHtGJwY=", "C/Gkn5uaw00w5GO6eX4+CN+0JHkephKygJMuwgjH+AA=", "JyqIpT4mP/Cla/9MxkX8wmnTrVpj+WJf/p6sk6Nrd9Q=", "J7tAIrH2iRhLENbymCQxHMxeLvFKORSuqPBsy38qqM4=", "F48O50yDTA0i9668UXH5YLIFRt2ctTs97XijUatBzhA=", "C/bfJ2s/KK/VIGqGRt1vTAlf2YhxpQYFAvOmREvjIbU=", "IZ1OeQkt8TsyI/k10qCiVzwffVCakd1/xVM9TDxdCY8=", "IPVwK3SfVt+BBBGtmVDKn4fx4Pl7gWMoCzst8Ftnm00=", "EXKE8DiHK85ox5GtGCRu2EuttpLjOPcWeT9aa/IWOG4=", "LC28ZaJrMT+EVn7XHUCEcJPQjOjCuKNDxit/V+9j2Wg=", "F0M3PjhYzcBYIEnvfgKE0zQDzIv1aZfFCKELX7AIrnc=", "C6KPKZ0cox21o7wOggLpzo/oX4DE8D+eri2rXeBRplk=", "DkaDHcMvc8EIYFX66t8EfTQIwswNwuclyHjcnOaPF+s=", "HYY1zeLsZKpQ2Nl54p7xH6AGC/huoAdiJQ4xTiiB9wo=", "DrbYb34RsePcIYglEeA7eqZAY2iPxS9lXxLjSjQ9vLk=", "Aguy0bDK7RFLBvymSLBwOnNG9rJpDyIPgudxC1hraoE=", "HE21rIHg5HgYv8CPfsLWa/FdqquO52Zyj1iFOetgB14=", "Fuul9d1GQV9Vq7gZmwBprTq3p46O7fr8roRXYKSx5SU=", "BGcYxJz81nz8J9qvC8ANsBZaizS9GAERC4XD+JB3nwI=", "EOzPO0zxZ814+e7qzEYu7XHrkqLjG9wfxLFsCxn+tE8=", "FuGywN2IUnd08YvFP0J0/RWlr882VvFJunvw1nBQ890=", "HRO9OW2lpo57gB/wssbCcl+WG/Yz0N+vGksskElprlM=", "ICNRgQSGixuX2aUXDXozIwv/BhjfSjGzgfvpoOoyJPQ=", "CExPkFASAjnYbLDYRTXMuUgh8KHe8ESV/+tVnxU93CY=", "H/b0I9lGZ+8teWYGAOBcVw9013rgcTnSAZBp/5bINWY=", "B7Vxmh4JuWpc4sEwudPsdgAtgb1qi0atJydANrs2O7o="], ["L7WDdis3WSxsWpXrHQZpS2xvncTxrUhi3Y9eZ8t6P1w=", "Eun0bNgjG7A9QCi/ehHXwOMx3AXAiObcPR0AHaWLhaU=", "EnXNcDJvUvgWp8U/5i4yPv5hpbjTdH9t7Fg3qCWHOvw=", "BufRZbV7ApnSPnUKdeouEsnHoWlUxApNEJBKYeh3NUE=", "L2fyOpPvHiFaSt0uy0G+9LnYXvkTUGXZkoAONPqYEIs=", "Fp65lS4qhiPvON5X4V4kLfOIAZSJ4Bt8hPqDnYZNzRo=", "D0zUBLQCTKE6UTujFW1N6cs6okDGg7Pg63JTvJjItfY=", "HEhr+uOrAy/1GejcptxB6gYLDvkIMSe9fCxOCJ/UWso=", "EC50WGQlHOlAxnseL0vE0n/ThRVxzmgTuqxmXozAx50=", "HmptYgQz0iKTBE/+NqXypynBKczj7rC9r9zQ1SvDurU=", "CPOr+XrY0Bz9hlH/LVduPWjsxHqtgrQYjZITi65gO20=", "KD2j8c+Ed9mCHuYDeLHDnHJChRGhudZoPAMCk4wkjOY=", "LZnNjYjknguryEy9WK28FDp1omuhb5ZGai5BYpc0Q30=", "Fx7danRWpMJf74qm2LdI6thpNp9ypOUChh/QN92o93k=", "L6tkaUNp46K9VzwMw4NpXAKjgeeFeSo/q9bhyo3y06E=", "DGFVlE9k92lPyOzSormiNwVow8iY25Ux3BjHJHT5r+c=", "HuDlz64DBiIkkhDNzacUN/KPCxcwZTwJFe+/wIYHw8c=", "HBUVSJXr/LreEvDgLwz2X4c1GxlyNYvrDq5raXbK2rw=", "BGf+3Rb56Hswaa5pfRhcnIhO1dnmS7gUvRH3GIV1QIM=", "K1VlhS9llpuwh/y1Fia0dUtpE22SVG//RLcEiy+e+KI=", "IlCswn1e+ND0ro7ed1EKf/uJfUXZyT+y7OT+TJpSD5c=", "LAq+Jv+L1HXvcngVurioHRVNLB427s0HV0IieCsCqMA=", "GbC9ngxfofVohb4A/pfNTOjhB+laEIOLcN/zQFEYimk=", "I0L6gF7rKyN2M5Qq74C6/Trzh+yNRy9dEuj5g00y6qo=", "DtV2Y6KmTHOyhwrwBlzrjN6jl1mczZgjdH+ITNzY+vk=", "LI2oJHGfhrvj5gGxnT7iqft2bnU3qsLqn0TOSJbmS/w=", "JC+6h2sWNh4RxnfWLGqsc5MGg8DEC8EZOCR9LCRKRHQ=", "AYDP0LHNOvfVkD4eY4vdxnEYdv/21bEmBykN69XkCbM=", "/ozhsmXWV+eQu4LmiBstp3RxO3JLmojsNjc/pm+RWw==", "6HAcsPAx0Dpdgfz5SSMN043sEiGO2TfLMdWMxGQICQ==", "B+1XX5FUsSsPvBK/9DUMak04hZ0Q9VfTjFE7N0afR74=", "Iun0bhfdpAZqSvgaS+GclN5LEuCSH4GQMPg1Kq0FC5E=", "KyEEn3uObnZ9Yz3L8qyyZNrceoWjm5N0WME09lKm6l0=", "IWxaW/9EWsOj2h7rcGiYQ3hAkFuf8n2vvzjvpHC9C9M=", "LhS9TwFGL/0Mg5KaqXcGrHcvZqOgoDJsAOrBH51aSFs=", "DyjlHi93cjkgXxPqIejzMXKuU4sh+2m8/NgqxRUA7q4=", "LCKV7LrZzxs/anc8aXFOtGY6AYJwRBaefx7dWDgQbuo=", "Aa/nsdisQ4c51IjvAD+cPGeef+LwkYu8+TrR8SfyKB4=", "Lggz2v6HJ5aFzVtaAQX4uYd0swg4M770Ngi8qEUbIQ0=", "C79CZvyghhNBxxlvwVWS+iLc5hQZNeAfxgd8d0y7lnw=", "BTDGawfS243uNqsA+RxaoKJrSNiUDwtyc1plSB5eeB4=", "Lsq+7DGHemgFiiL3c+ktSDhnwB330FDD+pU8zOkKy1E=", "HjecDS+dC2WbxzK1donkjAJiqXY3mVnhK5XLXUWCDyg=", "J3Z3VmBr9ye45TYQAsYT1sOiDfnBeIycEi06dzams0A=", "G+PYMt4hlkQwYsO0IyGuBXeTaP9G62j+V9g12NZWriU=", "DpuDlwCxjvPropfLaK2ZKzvs4M1b7GXm5AcSQlRH3Fk=", "AnYJAJcKNNIFGuWH7Bj1AtJGBw1wwsPX/t7rUb3LeF0=", "A3DsP3Aob0lmks1fUPawbiHFzYn6KPnItx1CtLoneQY=", "C6j4Y2Lh8wG67rsjM4k/f7ouoILXWWmpfuMJW6q7EKg=", "LWg8PNe09US75Ka6qar3hhRDSlkVKZ/7N/kqvLSk3Wo=", "JVRMz2ANhgS/PhGu677Te3fPsbIvOxEKkwyR6eeVH4I=", "HFg2deQj+Uc0QygxUoCWaDPwX5Giokruwatu03N2+Vk=", "DLdS79B8hADVCgbz4bq6PLNbC6KLJi+FJvXrCrW8edg=", "FM9EK28iyj9MFpdOLrVsoITQXrk64QSSdbi8vk3COPA=", "GvG5Nb21YHiX9P8HRasIFA1ugIeGUoVbGUdXb8/uT6c=", "JJmtS3llIw1N1dHEHgBpnEBDPiLCdFgH7/OVoT5vHw4=", "K1guoWaQKBluYuYicaNvUysUwKgQnTTOU9+bdbgdY6o=", "HDNaNHq9oEfEta2T27LpQS1SYEn+H6vhtf7iXumeC+8=", "HjRRxJXGDc1ENzBAHvMp1wVx42RN17VmTOom2vinCqQ=", "LZYobm2erdY+OTM18SF3EHRsy5KINOcxBYI6y9LaAFw=", "DBAz3iGJHszpvQr+MTM09+ZZd5lOVFIE1hauDsTBvYo=", "Dw9Rz223PpcKa478iCO8gsrIQD7DacAqFK/+X7QO7jY=", "CO0tzsAWuO7cBnptp7ViSEwBAjTYSCF4BmKs+dKBs0g=", "GaXsO3iC7JEL91kOl3S2P/N5CZlabWlWEdVTLWuBpQ==", "I/7sXWI1pAXw1T/BbJVfoCFMu1T+lzlIod05JjYHwz0=", "CFQ43ULB10+wQH5IqxtE4OQqo/VLjX1PbvuHECxqAOk=", "GRbx1iGqr0+Qcr/E5BtLeOgrWV11ENUHWRQUwAX9Ayc=", "D8JDUVbU7nbpqFrGrsL7tQsLd3lcNwwhg/ypvLvQdpM=", "Js9NEhmQA/aXj4B2F4TeCRnToUiHpX1KKLT/OtOb2Wk=", "LEgDddjb1KxPA59FL+Gp8HTIEdSNwrIU0/XegnoaICU=", "IZtfgSZ4Q0DyeLd7dl3ExpeTez2BuiaR+JeYOfAswOs=", "FK3C8nM/VdSftijDukERDhaUYhSZbR+TJiuTR8/mmiE=", "Iwpf42bgqk364dw14CBpWXgaZPItXGhOU/+qZhSx3zE=", "Enn40uLUOp6zt+QUnRZFG3jGURi1qA+GZ49e5v3Ky94=", "K+TLQUSqS45wXDfaQriBnwFl7zR2+8Mno6PesKDo11E=", "KDsY96FJzy8sjMRGUTtaA6BgIs2FnxbaEUnn3HxgpFo=", "LVuviIh66+ItXZCW3WxF6UH2pnNprwHHVHnnB4AzeKw=", "HNmm/90Nr3ypiQho2as5jgVGM1vyliOt7Xbk96+lrVU=", "FgdnwctFfeKstAB4HYzdJbmfda8wHnScxGBJyNtVY/c=", "G7uxm/OE+YEqpjaFcp4N/gbzRUwSE5RUcHwXicOfym8=", "CtO+t1yRzrCyu4q6KhxzyV595XuNWnmE6fTQEPFaF1U=", "GEHrbMNaHdZP66HYrWz+zWUGPh5sLK1P1b/xtGFOCwY=", "I1bu3sSILZAyzoIdYRuYd5vTROKr4KV95N4GtyvmtEc=", "EP7eYkWpx4s5HmnbkRCDBr7hMPrymEMtYKSUTubtZHk=", "K08oFhx6hDaSsHQQIj2LXbdi/xasDN7UFsNZTealNEM=", "HwhGsbJqo9sUrA1plyyRGAURg+0dFjOHa0TJLwIuARs=", "KP96d1LlFzTh9WjGqj3eMAnCLtIQUD1dzX3CX39nZ9o=", "GjrL3XOXlNJSFQOZxqiz0RTZfWQ9TOg/6PZPQdjDTpM=", "KQukazgXmkR8yB0AMdGOm6o02ppgun3zyyx2VL7z9BI=", "C5h2WJY37jYow6CFANZzY6GgHaehrIH1KMRQ6bBQxuo=", "A1t7M6HhfG0WdMwikGjgPT0XZ7yVDWii43bwx5Oolt8=", "B+azCg08JSa+ZZIOa4c95y2x12H3k1IC/OCIU4dBs0c=", "Dl7Yc5NJXCp/O4d1eMa8CWU3VReRWTUdjmdHCr6cxpA=", "AoJIc6t1JhFZV3NqXNrlg7/O4QudQY744XeV3jOG8h8=", "HbSf9H6mroDCZlT/VxTmnPOh/3sxsfp6O55kYYMF1YI=", "G+QhgJ+AsRpiag7rkno5wkE+cgXSXIkna/VjNWUDiUE=", "A7fHYptTXfW0hyEfTnibmih6vnxFNjLvfUJiPC0sN34=", "Eqn39uDGWs34yf01T37ITW5BY4Rl40fzBjrcBOAOgJ4=", "HfWQXjh/jsgRKMIP/ZlfrVQCCW48xtLiKaI3CbaFmsY=", "LTnait5hVjYHDmc0/YSDaNWEKKo7Ku14TYQp8gddEi8=", "AyfB0fDdNbCN+EDbJXliMkPBPZwHO51wmEvPyXyb638=", "GKEPPkUqCAdq62uCUAQyKkim+w9RlW9QJQpBpJRUtsE=", "HpTfoLIfez5gR9WZs61JGmk/5Fit0qVsXtFhVfrFnqY=", "D+IBaUFGG+sPC+0lvzHoyaNvIf1hz3AJXS2iu5O/Oy8=", "DOuCk3yEkj12v4VaG75BLdPjXQN4AHQER3iD2IW0JbQ=", "FphbLuZLQr+boGc76w5HWAdjxSf0eS/plMI+MEZiGpo=", "EOb/lsXa2KNNevLjxqsuHrbvV4SSM9KUX8CqvUBOW20=", "GS/bxTs4K0WqMCDSFmXd1la8HMMyWBzHHsl8OtcdxUI=", "DYQxwU8f9GQPv2mQUG2TCEO83rTe7vM4C1zyFho70DA=", "BgRjK3DRwNvHTtKdadEdN7kGaYgsLj1nhLR6Wq0DSV8=", "DyVTx/pb65zy9pV7Af97t9PtYfnC5vqKUyZHBPmGwZM=", "H9wrtBrAQY2DUUFNw2CrLdMk0WIoB89Z21ymqsrl1Y4=", "GMQqFX85v8raV+CFx80zeByvx7M9ZQXdqCiXKWapwqw=", "JkV0jRsTyCW7RXqndhuc5UJcVhN+ITyGNMh6spVDuh0=", "J4ivcs21lKwI9BJpSX4a4Y1EIy7Q+AoGvZ5y/SFuOXI=", "Ia4inqZSnE+d6Je7hJq2uxW7ku5B9z00jBC6jWSsvP8=", "Grz9+ZB4Rwb1R5JmBmitEG0aaTYkV4XD/QI6U0TMJeo=", "Kczx2TTypkdZXRvgkAACubejQ8Pn06uaw9KrjeAav4w=", "A5wv/aBPuFD15w2Xyi2T/eBbZRsxCx0n3CmLn8iI2cA=", "HyulO/HJlmX9b06GKsCImaQdqTgZgVPkxji63hRxmhY=", "JFG45CMs6cgJ5Dm261/Su62PUem/BCmjO7DulbeJBxk=", "FxpinSxANkMnZm4MBc4wl7K+BepcdRI/p4hRuheJgOA=", "CMmzTfMRoYdkBE4klhqV0bLcrDxt+bvgSAZZYR248Tc=", "CyKj4yGjijgBQECR0rFg/BM1MOi3pS0kIsnxqLJSvCA=", "B5fENevlyEWnQ/h6fw0mfzO/uvyfFonCeWs5J3Ln0wE=", "HnMGsxoTf837OJ+sZLXx3cYUe9HMfzDxHWeHBFQWXe4=", "ARLwHFqotq6S4sjKdmf10hoLHkqM4AoszM3EWa3psBk=", "IZ3mtC3zBpnGaSHBHombiI6e0xe1hqvtNvt2krEhaxs=", "CGoii6VwR9xbu7BL7e8Nh8GnjOzmqvm2mBF7KScF3gQ=", "FOmEMjV+/UzDI9oqNEFC508qoRfMGqS1Wa2D5UHr6kk=", "HmuJWFhpTuyteLi4jVQhfIedi4atkoGQeJoJFHFo/JY=", "FeN/rx0IST3ytkNXbhd8n8cE/s8WS3MnSB0yMT1V0WE=", "CF0PVn3azT+OXgDEIJzZspZpPboR0Ah5YptSInDnmO0=", "EGffgh9hb8ljUQTVshUPgx/wSh8rE5nbSWc+gMXIbbE=", "CQMyFgQn3j6wVfm4dI9+K4jBH0FVducuTgh0FlRFV7o=", "LclHSTiOvYduDUS6AQX42jb84NRYMeQlUJLVx/i4QiU=", "EYyFfynlolPVC00k0tDCm4LGisTsMeiLxDx0qUh+eV0=", "CvZ/DQei/kHHKkV8kulUWKd9ua0KKHaLYrZoGt6xFXk=", "MBBCBK0PrjZvEWILLxLua7fBQeL+x+Kdlj5vyU+Mgos=", "GXasirh09JzNYyNfTYHPADLOZtU7DZqRDaO40FJKWmA=", "LDFt4xZ+3rchqxJwoHSO5/d+16inxydVlDb2+5MTv6M=", "CdIBHIOkyRH0U150H3lDK18qW45TVh0XlJbdtjy3WfA=", "E1u4d3PMohkctdIu1I5jPXEUkRm97mVpYjr4g+1zQpQ=", "LUfOZVKWdTmZ0NjKvPBW8AR+qhZvX4vDzF62Ae0sVgA=", "ErOuL402M3AmdKTqLpirW7GG2lXLf1utA4vgikb4+Ps=", "GUFnPHm+g5JKQ7AVnl8JGcO0vTNN9WfiOhCdWtcJOpY=", "C1JMG/PDkihdSaQti9q0ykVFFHkuKrtbtPYskCybkZA=", "FRXtdyJqMxHq3z/I8DXAFv03BaCLip38IXX9e/WOuNo=", "BkhilzvQt7dfe0YkqE1oD6t9qbZ0GqXW7bdqnQxAy68=", "AaIzYf7fxeSUsLLU7rgMk/iDWnMQC6y5ib5SJvzw31U=", "AUdSOB37lmWUchzZSGdQpPH44zewaBCTgxdWM4bU5UQ=", "BKCQNOD2niZYHOZuCX+bW+AI0Ivmh7gSJUDy4yYpFKw=", "ELt2Spa/QCpTeFzy60r3sF4g2JrQZYre0SwbWBURU48=", "AUmc/QNriuNyRYVhwZpZqmNQVGkoGPmzI0cHFoKY+hQ=", "Cos7SOxovC+p40UhCZaE5yJYJkt3luqpvCEwyl+WL80=", "GkblnGwhydVLmyMfwUAzedAeFmgL/pYi3MAVVb6HSH4=", "CVaaOP+2wz2OvK3GApo7qOqMit4aeHTD8BdRbDWMxpg=", "FqnCAdV0AE0CdttC5+8xWSzUmla5t2jKc8fG0d3Woso=", "GcBflmDyy2sRMXnjJlb+KznJMHwNHps+aAmD4nvJQcc=", "KfS4Ed3cZyXuWfpaKK9UXLIfFct/pvmIXLfWpAWgY6k=", "H5knH/6Ssn/fVhVy5fYJL8Bvt/qpy7LgdggGfN1SmxA=", "C5/c/cffuHJJV/ADJ93ZNy+Pzq271BWDtmcmslK2wIk=", "GTb1pBznE1yQJwR+wddZv9kcpwpiMkQA8Vox3r8Xm6A=", "Dl6vpgM0181xJRZj9bkd/hDsUDobL+WziGrZsQZiq7A=", "GAZdBlwwT3lTIxJA9USsUdiX9Yd3xpu50fikhqEMF3o=", "Jnh2a+nSxSUUeZmXYOqNb+ShUlCV4xL648y69onn6Ak=", "I3UPd685iKBgD/hothueXj0A3g+HWWEtSvJgz0sRPOI=", "BzGLEp5HidIb7HkgujVBk/3W/GKO7BUTY4UoQxJykls=", "KnutHrLmQYqVSGlROnpTHFjwmFxkqgfbJvj3lJ+whh0=", "G6uJx6648PHFW/Guv/2TelIM9jMK3ZPMM4Rgd8g6mHo=", "FVLVmFhk7yhErj0gpAo2ik4DKkyknY/2VGxFDLHgeac=", "BLkRUbOzXxH1mWNl3kPUP+VHbluvpvcR3DD6ziYj0yA=", "B1aDNMegWVtawhBbK19zil3wkxq6hXa5cHItTkXJEtw=", "CxYuRYru5S6kmtWc17X9Lf2iT72d6M+hzfBgFunRccA=", "LO8ySOtNrlV5PhvPpVPJMV9reMNWJRUI55r3z9itldM=", "FeckWtl4VzpeK5ElJ955ZM1K3QX6w2VIR8wLbt7Pua8=", "J8Rx2vBZja+A0C4GyBcflN1LaJqgvuamjleziN3FIVU=", "E8/d6TLC2PlL3OrnrXoLpdVF8qwgoE9+k5fWe5QrCaA=", "GfmmT7nRCZNuhA0cvhCMnDbrRtI3zchGLqgmf67n6Lc=", "FBaczfCHJYJjMrvVItcu+UtdyW0HoYNZsM93AzEiTWc=", "LodEF3zShJt3BAQhkH/EqcNWxM0CzPMt2PBThv8xIuI=", "FQfV3rm/a/oQ4rQytW2qxMpi0wL9jjegIezxEetCAYo=", "JtcJezJpxdYYqVuvubEoqHLFyF13BRWygVtYHpTIuf4=", "HHqydfHCIbwkjYSY27BcR/Qbl/vbY3v+FVzx51hJ1HY=", "Amcwd0BcyLweDYiSDq4aeX16QPmZk4W+Dad2wDJrkgY=", "I/6BvpuSGb4OYxLykCLH0M7JjaPFHJWYUtlR1vHLY4s=", "ELo8GD+ziQw2D6VidgrbRWsBlJ73FR7Yq4ED8xx4kKI=", "LVJZ2qwjHODnSHLEBl4U24syZ5knhycBuuJD9oQsNA==", "GmN8Jwaplv9XwDf09e43UB+z595NBnxMD1zPMPnYKgU=", "LmBnxVjZaDGt1tzj92aFRvls2ExOIny85wCWRDHs76A=", "GgxdNfxzKFGRfOO9E6fyj3WJhTf2/47vGh/0G0t66TU=", "LtyGcJXPlByx/3iHkmpMjETOsZJxcuObNi0vdGG7G4Q=", "LyBiplw/5zHirqAkGY5BdifzjWzZHgpIdKhWEiqdlls=", "JhqZZb5p3j/9dCNcOiOePjdM/hIJD2kp58REK/uLYaA=", "DlGn8hCd8lb/gU/DEKOwjv1bwWBpivmuIZwmYD6EtYY=", "IBU3SFyBi+orG8Y1A1x/kqxL6TsacyolnlCBxrEIIv8=", "Cx3GbDZN9spD6WzpFgEs/EkRWmY16KdqE8VvlmmR704=", "G3DwcJDdscSAwQVX0vgYwjVaDQES8ESPRXGW2w71heQ=", "AZQWlEOKE52N3hCGWHZAMgf2V6KIMRfNOozC58XSTzI=", "DPAxcBg4xM6qSQzTbnENNhnOVASOqCbPI6LEVvJF5v8=", "Ey1/rHNTWyx5XdqqOmkoFwToUJfXisbosenop3IYY/c=", "BK7/yg+ZIv0Debaaf7cQtJ3NBQJqPyV2pIpuBPkbYw8=", "JfW1AB+HvyWBk48+3gwqejUUHHq8Plu3u4YBoio89Dw=", "DnEZJ1olsrikpqylNGUOhOxytJCkE4TUSXXtjICiooo="]], M: [[["Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "DMV827CFB9Yr9npEk8wmL7bAnVVwE//x9XP0MSIfj/k="], ["K51LQRDJrpl3guFQmx0P2yCnwCu9i+pzBUYrn4Elseg=", "EnTmSaMu01WjGm7WlyThra3oV+hutcOhIbzRR5QyA8g="]], [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac="], ["Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "LiQZ+ewC7DlMmHHIMpY9wbiddDyMe5ZAKbIxFoex/iM=", "F2zAKWla0CWCpw7/CKb9mdBX4S5Y59e2sWzfq8juKRE="], ["K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20=", "EBBx8AMjebaXMVh2aQ8FPRSNThCfX7BlyKrMVaD4m/o=", "GaP8ClZwK/QXun/uOAJZP6ZERwMHBD93cyec1x0l1eA="]], [["I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KnWhcVY7gH21Jb4llpmrKP6bx/sfcJQ/8Em8lw6EGgw=", "IHBnnnmHgu9ZKlLKnO+CDUl60u7Lqn5C82az5SHE7UI=", "L1ReV4ICyXMkiFQOQfeDto/wYT/Xk3X4uos9MJWOdnc="], ["J3aGSU92RLvEqbGU4Qck65Z/HcWHGOWePO3IIbKnrhk=", "CDq/9eEAUfB44oJ9CS4a6Ai03T4VzMNwbzjOQVe2dw4=", "LhjIVw0gv134AHOaU9p12Qbs4xjNIkq2s6K+l54tfqs=", "I4EL+Ch3/Bm/9+7+rj+vS7gQTDK6TNcBWWoVYj0BR24="], ["Aj22h4Tj8MwLhWGIJqmzUFEpwWR5lzsKhKRSnmawnGI=", "GlrXG7vs2Kl9xJz9uuMDrSTVxHQeq4t1aKn/glOh628=", "D6hvDyfk091/M2fOhvaE8fLkOG0+W584+ig8aqcjtgg=", "AU/NXrC+bVvur8SUQDTPMhwGjvkw8QviIH7VjSo0zdY="], ["HTWdJF8obBLVDWY7rnM/l4rwjNvWMBfFezp1ZG/zgsE=", "DXRf0A3RZ/uGdyEzZA8CzpRQBKe8LFnoeQ9yXF2E8K8=", "A/Pm+reR8WYoFo5LFNuutlcDXuPaayyoPwwkkeC0A+s=", "wV/DodVzPdg16uCCPjd/i6SotidifMK7Zhwl0g+1Kg=="]], [["JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KnC58dS7zNvAPhfB0dzbAgUpA9xmCeppafZhsut0yDk=", "L2mnGY4fvMfepDJlMGo37VW5G/9lKtaapPqEeJcNQB0=", "DD8FCmv1rxUZgeVePhopoTw/+kVQvSUU8a/Wxfch+DA=", "KiDjpKDlfZL5fJ1hhsbD6nxeVcIBRiWb4veMLMwuNZU="], ["JftQtlrPT7BHy9OxwX2Xx/4m6pyiONbjSFUEhukcd2U=", "KBFUZRySHnRjFamTTxuKG7qfkq2O9Ll5EVuOLpkczXo=", "HB7dYmRbc62TGrgON7uyZ7oxKzQUDnFtajdHWU0wUg==", "DexU5tv3UgX6dbp5kr008Isu/i7NQkpz7ad4QyCho24=", "EEn4IQVmtR+q+x6aXWPA7nAWc67YINnEQDsB/rcnpUk="], ["KT1hfX2nIQI1Xznr9i+RsG3rUyXzZ6RVbqHjHtV2eDM=", "KMK+L4Jk+V8LU8cyE076M4zNj9ue4rRfuGqJT32zbDc=", "FbmM6T5HvGTOLyyWxpZjxDnEDGAwSUZvp/mksii/wys=", "HEgqJacp9d8gIlgVA0sZYJg2ShH02Yj7fMdc8y2BNvo=", "AuysaH71tLVoACvZ0blrS+81emnj6GtVYbkpm4LWnI4="], ["EE0ClasAyF6WARGsJdpHQ2ZZnldam37fYUXxS6bTwcQ=", "IYiAQeb+vVRtQnyJCxiDu5tibYy03BjcxOyPp15TChM=", "EsfirfpSTllY9lvi+6yAn8uoRYso5E2SZQUd4zFjz5w=", "JiXOSKezmkJScyYk5KuUNggSrC/JoUpfuLYHrp/YUUo=", "LToa6i5tREZoCPiMm6kD073La1i6QEQe1OvPEbvh43s="], ["Cqo14shLrxF96j4zbNlqOXkrOBOVT+m/PtW5Dy9pyXc=", "FN21+toBcduAGVuVktjPK+gQkw4+pFdKNQ1l4sv/SUE=", "LvwrkNaIE0hJAYIi57iSLq9nznmBbvRoUx7C3lO70Wc=", "B/AXp+vVbdCG981P1xDFCe1++OMAuai7n7nyivcQJR8=", "FAdLsUyYLIHJrRceTzX+SbOcSnpy27bZyY2AO/7WXmQ="]], [["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "ClFKXCJ/TOyV36Ap6N0STDSJWqRrsnwJEfN4DVAVVAo=", "J4u0mntORK6kbrD4gstpKAGm5g/dW1wjxjzWXMzk/go=", "DDmen2eqQHB6ID/u+wuVi72tzsXKNJAdJT0CaiQZ9qI=", "HWs9X26jacJvgl0jYpM+qjHqNewKd8H72eAcoVI+RDI=", "JL5RAJVDYgbdCr0LDLuVyIOrMEqlJZixppMG7JgaaI0="], ["EZJPAv0ZsJJVqqHPRuoFGOPXv+70dCFglJEBHbC9CwI=", "GS4W0X2VayV7haZS7v3y7glYnqxb6AkVd1cj0ssdoG0=", "Bj7ewb7YMfUGr422SNb96hRTRYh+i9z/EJA1odm2dNc=", "CD8N8/GgNR0DMOw/9gLKjMNTt/bnYscQcYTNe0I0SfY=", "EZ7xiLs90NMjBpdsGZQehmS+aH56aWkton2iFabwbUA=", "IRYQ4q1KN3Qm+t9waLDBpsKZoWTBwaYD6u2USHDQubk="], ["JH+n8CIwShmU/1BUVsIgHvm3FzaUmNP/zkRmAe2d+EU=", "KYzgweMRO7k1xwWOd3K1M7GqnbDAkmvciRflYFyjrBA=", "G67xy1UJtSakIGH7U2V/mbMjJQDoVRksvoyUDgaMR18=", "Gmdk1ZQ/xKcgtMChn9uMcRmEMHKHpYubX59dWCEssmM=", "LZ4KtcBok9/f0DSBOBuoa25ikt9WCdcfLGSy2aefgJ4=", "FaZ9mBBBsfbwnz+evv2GTnedOvCBV3hqwHdQXlDsefw="], ["A/17Ge8shh8i93/4EPVOJ3vJTrdsAtedmGvj3N8FHD8=", "CUy06DYhr9Jx5BvHFyfwFY69YSI5rJ1pixf+S+Bbf8g=", "EyRWSse9+eIhZOmFjX+o42ixZerqPa9Otn7lnA3y5dQ=", "ARpjom/qv4f6Zr3mbMJakiyWOC12xqf/SPFTe+rtaDo=", "JfFmMb93Bg9+o0CHwCW/E1eEMZ7wjNouMUGe4KUp5lg=", "BJMn+nnSjBKiyCQGlH938Gd1sCh0aLMTaHdwHb58lZg="], ["GL1BI5w+cVeaZ3RD7P+9VVqB7u6mk1Kmi2fIVjwMKgY=", "A9iAOVvpPCfWSa9f0ULnazORjLiEHVooFzvVz30yh5E=", "V2G4xq7LGoyk6k38LIN2BkpKgATO7aIQpVJAVi3cEw==", "CMp7ZGV8NUjzK+9bY60kKIpBwLJRCZrSf5Q0MH4+ZNQ=", "FEx6EdpafF2rrj8z+9A8rYbRi8WUx5pJfsuYlO21VPE=", "IwlA3MUjJlj/nClpej/UFtFw6MmY8aqF3qDELXn5Uao="], ["LXjDpdKN6f81vwoldjUZblcwyn9ASTJ3B4zXXai069w=", "KO6ua1hmrWjkQ7uvkWgNt9fiswN+OP72G0LLzP/OyoE=", "EMnigxWdWMtMsuNf3oOjuh/cKAAu2ZY9KpnxhheKFI0=", "AZmCcEcek2GVVEawzbi+qRXsBnXxzWSN3LBDA1B6RIk=", "D5cRYmJ3I/P+rayyiwwQTLj3TeUIdS+o18DbKvE96O4=", "GxIcBJzRFZ4okAfgydqZlcxLq0wm+4iOw5cqii5laWQ="]], [["Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "H+n+tcf3x6Qmv/AyzWoxWCeLbGssxXqHEhP8r9ZCeYk=", "zbLbnk+dcy0hfF4xFIIRZdSeWi1BVWvNU9DE1DMiTA==", "CWZCFspWXBpE/CuYNH6os2kEs4d/IVncyZmJWt601ws=", "FGP1HUpMseuhbbwRVWaqSP53tDwkTJmIo8ZY0vVkk9Y=", "IU5BeIvSuZA0fH8qj0dhLU386xoebaOBZYc99mzlH1k=", "BUhUFyT2TiASgmCJmr6PvN/xhKGVepOF+3FZI78Px50="], ["G0vFiF0c/I62kYdTANtaDHNirjgYmKyvi2PK0E7LNsY=", "DMfquxVKp5VerEehn2Q3orjewP6eVoYVD/boixp7S8Q=", "AS87spyXJ5MYISP1xJMG4Wo6eHxLzZx5ihMbcIVtHL4=", "ER/Y384r07e6DPqT4g+2hav3bXcwWFe43zCRTkhJ7O8=", "Fq/Y9MOQOLgAalnSkq6oRzHA+DgyphuCJQ7ZARjo/sI=", "A/uoLT94NiCHPalOn06EyLUp129U5LXX1IBScq+bl3U=", "IcXiWmmRNk5ZogXlsByBHe6wlWgKcpKDac/S3nGxT5g="], ["CKcvu1Xd4+k8WBhXGkJKVJU2lQKe7bz5Hq6wEnUcf4M=", "A5Pv2WOZqgcm75r3m+i2xxXkKZBsoNFQdrWpkP6nWs4=", "C7qQBkBMXt6CtSdnfa9ETtQ/0eDb3FUo3SzR8XrXNIE=", "GfU8ClkrPqk0l6UR5W9mdTWYJlsatndNpI7sBOTZNCY=", "IpY2HzvxVO+6uZaSGTbpsd/4NScR+VhjgXIFUzPgdXk=", "BmeC/j6GneLOvX679g+0NXhTKd+xKtm9G05G7TYolRE=", "EcXMU/YzjIJYF6/3eSou+86P/xcTANQUVaLtrDdmPQI="], ["D5U1mh9oRdSSGJL4PlALuxs9N2PY/HYkAK8Dmwq7g/U=", "CHEjODW3UuoDDPik9DdxKW7rM/aX0bCCXbR9OayeWVU=", "F+TnO/cB+I0hms8cpjkMweF8n4SxcTggg3ygcL6Eotw=", "GbaDw507AC/DUjt77lpgFIsdvfGN0cMY5qVB6M9moXQ=", "HDFg666xD4CfaYQ8+NW7rKGY0fjjQ5vim+uS2QnsiRw=", "HFzWsj7zNr4B76N6J+a3quXRZD/O6yEs3/UViINftTc=", "J6CUn9yfEElcTuchSqDt0q2O72j1d9qLlvnYejlQS/k="], ["FvAXUc6YUyiv3jTYFhne+0Pmx7Xa31LQ+CRy+853cNk=", "GgJ5jwR6Ubquo0/Psmymr+lqX60dLbQnBJe25lBIkcs=", "I0uKB371K1OjQ7jaWyDMNYrWB2DdYCdtSFAV9z1T0gc=", "JUcROoGHefE+NEhxnH7xALgDa7Pogt1eZFbDUxHBvVs=", "CUxmvc/1Q4LNkhOr5DMS7bW01BTG4JrMokkSp2NUBMY=", "LztL8PEF+I4nJIrwlOKf7tn/P62aeU4VgwvSsxFTlFM=", "HH/Gjz+95KI8RV7w0NvODOVWoBlObVUsBFXLtbDCMOI="], ["HDkWJjKEV/yvpinz5tM+JVXo2IXjwHzsyK8fTVZZZBc=", "BVZl123zzQ/LcTwjTqedBqMdbj5MO8xlfbpMZk1aDaA=", "LcP9dzlLe1rBy9G0bm3tW4NdchekxQpIeumjWn/UXZ0=", "zxSPgEXNvnuxAT9y69QSaj41y6mpcEQbqNW8dpQ7Cw==", "Log71AjEyCbQBP93fXwJOENKtbuE80IOXZS4U7F0b4k=", "L0CF6qn4Cmm3Ofwj8v5AV/ZHKbMReD/PqzoKNvwf9DI=", "EdD1b8AOfYWzopOf0zmR3Iq8HO0MPzxTDL+0UA1j3pw="], ["lw9nG5ujXj48ZC0eC4AyAj7VuskcLBBW8DllpCxSlw==", "Ju6WkaY47cfJGIfjAvxV6Od1goakSEWtiP1947sQUsE=", "FmhHdkD6sUxyscFv8BkuSM+ILxIna9Evl/gsbuLmHkg=", "MAhCHu12egkzIqCcNzOXOgOBaMsozS4fcJB2wAuGlZk=", "Ior21CXpGng90Y/Ymms4vaBT8vI8CUuHXyfLOruiAws=", "I2NgM0npT1IPofmP4lB/aq42GTQHiqWaFiFMCIGFY4s=", "AbLp0g2bVd6wSMq+Fjbw6WNjvsiGZ5y9kfMy+yut5E8="]], [["GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "JUuBJvRSQ/FN2CEd9B/lUWs1lS1WxiZ4wUjnPNutNxg=", "JwcS8YsVGPr+CTZg9JLNvC+3D/qzHYpNihk0vmh5I2k=", "K/w5gaJJrqrsSrkAFyfTLU5v51WY7pZPyFzzDVDfWEs=", "FgYKF+GxH4Uc6rIEZFcrPXjVguoFABSEMQFIX2Wrcj0=", "5zIXoQbEAuTGwWbNnvH9KgsWrBy0Nka8HHJvgxd3cA==", "BLlZygfnGCygjyNRoDVFvXq2dvdAsCMxY36hQ0yFRew=", "D8nMlSIvknFc90dgECJeFMw48xQHHlDg87yexnSoqsw="], ["Dh9OTSbp2l+O496vSLSTYQvmHX09sdl1T+yjCHmtxkQ=", "IInFl/6qTKmiAu37yCN2MQDilMnjMADlE7KiFkkdR0o=", "EHz++h6GQEWmaDllJu2fZ1srvycspjXY0+iAEJm7l9A=", "AhYw7D8jbtIZ9zzGF7n4smfb7pmmPFKFROoxsnzeSfs=", "J0EgPWbFI8djnqcTsgNGEZyWHMHpZZpFivdMvuFtcb8=", "F7IJKw9jRXa2VMbeIaGo2BK9TAFVn/+DIXEpCC4rKyA=", "Bo6OY0Ed8rOp18Vn9mQZpYDTuhW7/dEibv+j/WvUezw=", "L1oqDNDLJIlslIeKgQbVfoLGjc8eIJFnpFrpz4Vw/tI="], ["DCmMFDVqWn8ibFpUnlkYSQA4Wq/Y6kHZdGcplk73XzQ=", "Dd6qkGy2Xz6cm+pjRN2o25DCU8D3+Z7O+IeG/v4OXMM=", "BLlqKWo1rPQVkpuHhLa7pkpjDSnf8otij8mO9wgjC1c=", "KIkKAxmbcn/t5e0AkO1pSUwFPJeTD7tsUjWLDX0QTBY=", "IgjFAEgGx6r1gxRZC8vqFhaP5i7ASXr8a90pOMEtmiM=", "LyTWCcsjcg7aVfrinsbxmQLELYv5BPtlYgJzbZey62k=", "A0TQx3LC8FNmSnuSZrGdSK5dKrPRwaGBUHVKtLg2r9M=", "LNGbXFW6sYCeUsyfwaA4wIk12hnPxWPnBI1r0ZcKDI4="], ["GeBwmC0+5nXhYiyiDROyN15Si2dnBoguuPGv4cUEXqE=", "ERTJEgRCdQST2ZnU3UXb1PO3WrGDIJI1OWzoPY7pkW8=", "HwRlqcEzocaAXXBb5rPqmRKi0GLDTb75LeRpVbg+e9k=", "G4Dz9Dk5bC9Ga46bJXZaAUlwRVob6u16b6MI2sdftYI=", "HAH220NdxIhe75zf7RkyULnT60zuNmZ0sHvdGU/zSf0=", "LfGD/ivJuLdXc/qWHI1BF+WCqAtlavXFh2PnAk6kGJw=", "B+DMoaNe0V+9thm/rsx6mo9MUSk5J1YqzqjquBfGuEs=", "JP8phngf5ArmHo9coO8XxaXqe928En1DFUfB9qj1zt0="], ["AzPikjmS6J3uVwplASXtp1ogpy5p4QhjoZ0Xt77qkpU=", "Los1qMKeY53ejf1JtLNH8A7kZ4Y/bvyzVfoVNO9weD8=", "J6K39VSeXu25AQXA+OIPBXGrevCAHxvdI+qtkfIimhM=", "Kku60kWjPl2XAVN/dRQQ5P8pe48dHZCY/pxRjCYaGwo=", "Hw42ws+awsQ4jnSWbZ7n0aCzGGkWoIz6MG9rs20h5Ug=", "Ff6WP1vQ2Sh4wQqJThGAGNuC5jUor6TUcD6Yge2hGNE=", "Ii7fPia/dLL1A5gxiSAdTujm1vrTQdf/UHSN1zl0nfY=", "Eqh9DFQZ9EhBmEDl5aktJ2rOAJY9mH8qEAiRPZiicRQ="], ["GUSqxyv2+83sBDYSOMPE2VENXwdDmhtv9B9lKZC+ATk=", "IObMYTrmywpRhCX1PbEpin+IWe4gqtCDINCk+bv+hRI=", "AxsK+3qy8dJB+IIXj33NrUhZHMZ5BdZR28r86UsU0HM=", "HkMfKxt+2uT4y7XTB79RMcNSwqIVqHDXOWF/SwF8bRY=", "GZ/CvmDknmeewu3mzzNF3LO5GOWz4Hws2BQTM5NOF48=", "CvWU3EAw6FCXAfvT2JlfcxJq1yp68P/zRO7oKjHOd/8=", "LUMItII7Rl22U9NoGBgSCdI80S+ET3L3VI1J5VBVpgE=", "CvPO/yyGWpAblAbV2bL8WIM9ZC9Gxkk8oDDvWVBh7Gw="], ["J9gCrQGaQv0EiSrRZ9noNZanMGBYkEATGWYWdXNjWfM=", "JCDdEoH8DfrBdqdS0VkGtV8Te5zDINXV2qnfPz1D0+Y=", "IuAyO7vazl+8dKCz3t6m4eO/EOhN/HH+OVCJrBl690Q=", "JVY5iJolnr5Z90qP3y785/3h46Zms12ObsYB1NCyJok=", "CjjRY7ii+jCSmZwXl7GvkJvZcaJaZWuu+9vfo2KOZ48=", "C46FfZ+x1VTzpOwwetkH3npDZDhgOvGyjU5O43mWDOc=", "Lo5n/IX5tNAOnhGXs1vt9Vr9cwCkw3CYfIPBXPc8rjw=", "J/QthoQvTYqMOv8vR//B4Xnwl6rszlW7oLD9/VsZCqc="], ["K9BaBAoJh6xrwB9nJC1Ut6LFJ6lwrSgVsnNHHrliPnM=", "F71PJyZ0jZmSWvmi8pKeIxwYaUKME7Hjl7sAmRkXI6M=", "Hu821i8/hk6uZ8YzJOR6Y0TjOi1b+4LwW++ZAMVOdFo=", "LQ2KgUz6FsIyPxdL4ty+DClYKfxZvyqJ8TtOrQ6wVqg=", "GYlJ7vKyfCucPWmeP+V9o9W1CcK2cK/OQAq6Gqqe1R8=", "B+vNJaEOVmk6KBVfza97NRnZ4OCCQeIXiWlst27gYpc=", "IvG8TsE4tZYSjOXuW4GElkzCYjGOF60h1FxVJHf1PmE=", "K2s7w0DUEZ5Xgx5KIYcBPxIWqztjmUXdkqmElDJB8dA="]], [["AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "BgfNj/m4iXc8nraLikNmRp1HDNfGAEEGyq6VwQxCRBk=", "HaUkz/YLZIVtwfXd4P9i2nsYLaJpCPa6blkK3r+RtAw=", "IvM+ruPEgeZYAbdhpygykI8Gb+Idq1+l7B1Mbpndbfw=", "B1+E6ccZu43o5hCDKQ2v8ZqqQzdFTluoBCV3h0cPL1Q=", "IIS+mlfprbgDA6jcr/1Lt3rbaBUWizah02OzhCVDcTU=", "CzA0SfG/S5LSy8Jqs0tCFbbdevAQdHpwWypuM5iIKSI=", "DAmbxoJDU3ID+XJU8I37fvwJ3o+W1y87Pgqt7UXhi0o=", "HF/ZBg1ODZmSZEKaUATBZVcL0WdbCfl3cIscpI5hY4g="], ["H406nS0xqzLZvbY3UXDbuon2+PdNFuT9AvNnXV/iuq0=", "JZFYC3PntdXzTZ/cDPf+Pef2oYolXkN2/ePrMd+lHXk=", "K7RWWJO2/8V5kTnNwVEVh0nCxl20hnKrryTFs4E8Dis=", "HFznd3aJPUgUdES59tZqTaKclXB96DJ1bHOeq46HZY8=", "F1UFORxhm3VTD6g+UTGEOB5gPYRJ0eBwAX7o7ApNJfk=", "Bu0dFN7fdjowZfJ+ekbX+/INK06GoNuGaSoml2fVd+M=", "FAzdozu3p5srqoUd9a1Fnn31abnyw9pULTuNW3azVs4=", "A16ezEZMtDHMksM1boqYVH6EPtEyTB6XEXn9Gtn9UaA=", "Ep8GyTDt02/C+3BEpjMnUaLjvNvnVtiDcWzq1rxwY8s="], ["IwxpQTlBb0BCLXE+E8BWxFw8Yxs0aFRSOXDq6lijffQ=", "CTz/EhUK7LNGXEyZ8ES+hdzB66IdQpEywiYN09EupEE=", "JQgaAPwgrjZrH+fqawnmKlH2/Td/YINowSuk47+Jk18=", "Krjt0i++KhzTzppCEtDvsoLMrCivTYdvyUYgMHDJIL0=", "KcXOl3EMFXigmQ2GLPiBut8Q5Pa95ikZnoA80cQmvk4=", "EyRUSlQXTPezzY/8S4YyDyMZ2biMF3m4mxkWAY8/ubc=", "HRiyWqyYsoLhC1o6dM5cqhaaXDC65Su6KA7VF/P4L+8=", "AvNekh2uh/EoTAyK5zfb3Ek2y7sDoDpZGFUv5WUnCo0=", "FKXOFgMijW5vreV8HaU2ZZukbRslVm8Swo3ry+3FtPQ="], ["IGOkYa0GMVrlmSpToUu1mDZ2JK/CgzzLuDr5LKD2ozQ=", "BZEW2oiggSZ92IggT8b7eQRsMpfMtl+eD+DVC020TsY=", "G0NxnNELYMVkfAl9H6hLjzwSycR1reE7OIx+xHJAvhE=", "JuSRVKzKJEJNX40p9lD5gk3oLreIcynLyDpWrgHe5KI=", "LK+Gz/YFIczF7G4uLIO0cHu5D5SGRL+qj4Cwr81M3hA=", "LpI+pG1JIkfhLgp9zPZiD17qZim3Uys68kaAk5iFljM=", "HsbDL1E7jzDHqrQufZGuy+VK6xiKhPjKRr1+l0G5o4k=", "I6csJ/T15upTJdWzaPmLQGk7LbHoyj0JZzl1PcVngwM=", "FDYX7827wNJ6CR8oA566irs5OS4qRihQsfnNhTL1B18="], ["DFdOYo+EtrqdF7nSv9R0fgbdaM2iOD1kzjZZJwmMBG8=", "LJSElzc1FOfZhG3qnd9XVTN922YQQ9bGKM7Lj1UXO9g=", "It0gHsurlKLuOTeW/vzKY6pU2aGaucfyCgvtz7nRkfI=", "C63Xf1FtT6Mh0QmbweUZCQAVka2ZGfCM6XGK7rK8pNY=", "JPknk9Z2OLSr/fSM47YqtdDhslDcJ010by99BUQYW2I=", "C7u7h+zMkdX7B7bFUIjKUU1o3dk88xyO0tLMfyOyKw==", "CJvushw0bLm8GCqitw+FPxoiWNVok85alI2cZF7Lybs=", "Dgex0i7tVP35Zv/fvOu2U7Xaw7KpH1AnKHbvsXFYviw=", "KIXy1Evg7P9X2SpDhO21vr+1hbsj6uKi6lCAa6uLe9c="], ["J2Qo2IBAo+D0QkJNL/y40Zvs8/tsoCwbXGG13cU865A=", "LCcpgSvp7UMudXCRMxGcsKFOG26jHBJ5t8Pkld6vEI4=", "C455g4zTBweZnGIWIed+acD0M9VDt5xmjPN5tmI7rIQ=", "I2ccXR+1VgY6ZLX2ZDQJNtxf/t1L26ouliBXBNpYZPU=", "AoCd/iTH/XzUm5eycVD004o0C2Dwcz/UUwzUJptIEeQ=", "JgEKP1KVu0SBMQy8pThKR68PmQXkx2v1S4cO8P/vocg=", "J5BkOmYDjM5KZIiEfY0tou6oSWH4E0sb42lH+ANSfmc=", "BfpW1DHUvQliWobTYjRk3JC9VB6kF0jyAm9lAl6p0vI=", "BHFdtthrUT0AJYnx+VIvfeOxqL1wLBZ1We3pfaLAB20="], ["JL32EBsvIjF06GnWrsvo6lsEoUw4/fFJQ5PMb9s+QqU=", "IoDW1HGPnwa1UamIQI8FFQcORV7WM3fpEL4If7eb0ZE=", "AggtVkdljq5kiTbO++360s0FOFcqphIspozM7Wj0MvQ=", "Ag1yAszeJJAdbOLRB+eeH9eNbJOYunpJlvEWre8U3vM=", "JnCWiBUO0DX5WWh+33dH7o7pRrdwFz2+UDkKuMCMX5w=", "B1GkpK8kYlXOQSxLtH+jSlG4Yo882QIHd3XI+kiOdRk=", "FZ4l4AMmp28lwRQ6W+b1P6UczzaNmXTMbZPM6OuB03w=", "LW8+DphBPV1qEQGyRcnnEbsulW4npYcHhP1UA7OYZ8w=", "CIiHlmwHnS5omo1te9kT6S0yaVm62lm5mmU/6q32xGc="], ["GA/KGEFQwONUtLOkoHWCTUto6CdJQ/Tdiwxk7KJdxo4=", "Gxu6ElUFrpZ1vOx8mvV5xcyDUzydVVvjmK+gnL+V1qc=", "J3uuL8WXpTatvpwkvI7oFzHt21dMalFCwcWkjFH4LoE=", "HYZJaZXxQmTnoFTMgiSQA2h3XD5axrX1QoX0pzwhca4=", "HlrkwpWtWhfgD5c/E28SMKb7hWN2MbMG03BfgO/6wko=", "KNI1FhnMxvsxrUIG4sBkv02bIpKyhGPlPkdx8QZw3b8=", "JIa4hDcNSaAD/QQegA8KiYq2G16UeZdGHuMoQkHzuqo=", "ITF2vBoEk5/n1rwwaRqr1hUu0k8wm/85OaDZHVTGemY=", "Et7UH4BH2j5sIr/tPsW7UtAn5WAEjbTA+Wyp+oXhe8M="], ["EHJtz/hymchTIVmXZgdjPxvCrSRFPBurJrcmuC11brs=", "FwEyV3FtPLrijhwnLLaqooRBNgSf+8oFyiAVIwMsZNQ=", "MDVMnynJIMBemdfMdHUQ529/pppxWUopDq5yk8WkhEE=", "E2lhdG00/RlgJRc8TXm/iz0dBSkcWEko2XJY/V+0+04=", "IxDiM35NU8FjXaGKJyIXjVWvWDWRvMMX66hC3yR96qk=", "GBXk97QKcCeHhkCmzcSyhUMAz2/UlTwqwsd2Je9ErgQ=", "ER78E2qd/g68/66JQ+Z5zA+/Yv0M4DtAn+zZMqgoGxA=", "CloRSNrUVi6rGBYrORS2TVdT6WF6UVTpP35D5oYGh+o=", "H0fGekMlZy8XuL0d29gOTp5sYkGanCBMx+iCGJJDGq4="]], [["Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GruVtuMyQ6BQ5WO1xP0FneVRPsKJlKb2DlfJjTvI9YY=", "EQ0hOoNkeKowG8H9Tt04hQfYd0Wzq/ulvygq/SH3JCo=", "GO2y0QW7U7dorgE3hQ3C0r9tEwOh+O5Krfdtj4GZBYg=", "HlPpLfbFPs7EwN5bB9xMmgxVRfKrzB+r9My4SgpuLCc=", "EPy4F+EPafcHTmTDk7gHzd3zPISotc/jP0S3P+GMDjY=", "Kx2MEfxlLFk1Q7b5gAu30Mk3He25bwi7vM/9xsxE25g=", "GfRz5AwFZ21fjVHhEzbpxlyzKCjDl8yBJfHcZntsrfc=", "D886TZxsM5LeG9/iXPuGgX7LgMUb4X1H95dQIB8fzQE=", "I7AtAP4mNIiWc6fQRzb+Fbn2JlKxwGJqGa+NYIXXCCI="], ["L+Qp24Bo5huCYk8ldmJzzZ/mNo/wl+q5eqoJvkxjDic=", "CltgTJWLyQBxrRBhixdyWZ4Mjd37ZBEx/vOdqlijmSM=", "LN7gxjWk/NlUnw+RtPSptiiqcxni6qCUppOzi1z5okI=", "LJYtfVSpjDqCpjjYyCRQgT9CBxoXxsBfRwtElY9X7xU=", "K8dhGF9Z77e2e88dPlTaANrqBn/knj8dkzTlRwQ4tFQ=", "LkUNH+d3PJiJoL5V5ERTvMhEyUtW/Au4BuuZgqxVNCg=", "JcD4fJRvN140H3L2qN1jqU6G9K0YJxW8/L8rKN9rSg0=", "C/5vwI4qLhuJEa4GW5hTiPzRBaSQpKuUOyVVjPPQVLY=", "DBguQ4JXxK1+e3nDto1gmE5QesWXy0fcMdkTp6VA/Zo=", "L/TQuHmKgmZ3k1M3MAg8JSI9WJzdB5Ni8ejC4B1UR2o="], ["LnUIZ5QkOQgzZdIf52DH3+yeNZPGfeEqQlXGsBZItpA=", "JOgt9Yc5U3krrKNFt8GfYQOa3rEZBZK8oYz0+QfBpv4=", "1g8FhXVdSFd7RldG3o4obkmSUVDxeE8p+2uW29jw7A==", "H0lekwFDFJiNrOXk6Gf1EJ4J+gD86Hkp0eDs6VpEk0U=", "EkMx4Oyx2YCKHZHvqpiVCr6TDEb+5aMNWtB5dqW8AmM=", "L0Ifz1TXfdOJMM1pB2+bqt09PxlHNxIVpmyJTWN+ibk=", "BUOyvGbzstk9TBiCA53bN8cMC0N6wjrFu5ho5t8kSF4=", "ID2e5kYqWGkU/n2/wb+il3O3+bPWOupBIMYBEpwWZg8=", "Aloey9fniT9kbzXT4H7pl8lDVHN4hP5sJq6BVXYNuKo=", "HYl/YOh/zlzu2Np/L0pj/e5/+dzxecCOBenlzdgjisc="], ["IyN5halrF3/3wBSGqw1gPSmZG4Mkq9awfbuW9cIboX8=", "EOM0nu/ToRJBfhEP2egyB45UtfRTfNAYruPfu5BUFYE=", "IWjc8hbYNppibMxhRTI2o4nQJRnzBS6H7/nMuKopnEY=", "JikD82rPDcBV9hA5ffB5T7wwkn7xhcY1a8M+XDH6758=", "Roh3JPKTIYlcLvi8DPVF33c8BLqgl8NSpBZTlcynhg==", "EydggdsBLR1PS33S2KL4pRgNLswzhUzdNfnOsHv0DVM=", "LdEXIYU46KywMB60Ct+iQ19b/6gCj/Uvlqmdd/6ScGY=", "G5Eqvy4WSa1INMpbKjgxzJwgfU0I5L8nSnncqA5S/iQ=", "IBNf8mOGf3CO4CdRcMyXiGicCIspM6Nhx3XPQwdI7x8=", "C6bUzu4hgtPyqy5KOtCPwx9/TMD+yRrVPpK/ito+J48="], ["FczshXslk0/9Qpr5LJENsx0A3Bw/uDdFox2BMepbqoU=", "FlrevgDHugGUmQGMlvXFhw7KVnnJDIQ9lScYSlJfzKA=", "A1MN2WLvI9wW95sowfwd2v6UWL4VF0y7vzqAbeX2PO8=", "G36SKz3VA+ZEGtqWbIs7p7kIyyuYtfvh5ML7mCRVuqI=", "JHRgrUWAoYY56tppuQTJGxn31Dh0NXB2lsQLrDv73TM=", "FE1b441Exb+PPFc1M0+xoHwTcC2Grzm6C0Ig7Jp1aKI=", "JpsGsx6J/xMtrrwgDv3IqwaBNvzmXy/FWh3Lk5t/xvU=", "BiyqPJ/Tm2mGT69wHcikWIVxyzG/1cnDxZ39l+mfcBo=", "IOFg93KZii99AGTH76FYhOvG2LcYIc1TNuLfFDQcle4=", "Bc6UuOmmCyiUdxBGHYfHdXJGJmro+l068+qBd2tbjAc="], ["FxAq0tmAQ+VQnnbDMeayLV+2LQdHYIBqpnV2RmDrVtI=", "AfuBIY/u7fTn4OM92Oy+YtZca31CM/MuBzVx/4YticM=", "HO3G1OFHZ0HBCZVX5Y5kLEKJKqNuLQp5P2cHgaIbDb0=", "GoiuL94SujLl9OzKzxHCW8Fjve2qqIJEdMrlhp5ewg8=", "JlQSpOO1Vgq6UC0g7YM97/cHt9QlujwJ87Y5K28fQzk=", "EmkbWZ0y7cSK6Zx6c6vVnlsY9L93P6EFHKvSxJqqv2s=", "INRAHLv5KHfs9hbX0oVRywrsVS+ulRjc+SGMOMGgvJA=", "E4wDouzqGDy48mXuzX6TJ1sLuYKXwVRachl9xt3ZM18=", "FQ3xEpG2gOO6kloEccf7sw5wSrS1VOpdjAe3CyuWICo=", "DDRrBGrwPLkEjCk1PhEH1rdeWQuy1CLqg8CaXaG6DGU="], ["Ck7Kq96dHqEcgdr6jV1Iab7nrQv063g5e3G4+YnPmBI=", "G+KAL76lEAOq+ugv9EmdEVg3exCPiwIMgrhGCo1gOvo=", "JpyME5pPYeFr+q6ei7scaYCMkHEIOwoznf+eSQS0Q9Y=", "I0B3KCaccP5xKwIZFQWdyNwhJK5kjiy1Sfx2NivCuX0=", "Aq0G/J+BaEVC4EWKrhnAp8GL6U8d4/zmo+XSM1oB6Q4=", "BXilXw/aKZCbn4UMPXS+ZmjkRErGkXZPFkSmJkmCGOQ=", "LuLaJLf45wNftzsIw0FIM/+jjhSx+qwZioYKV2fS/u0=", "EViZWfwkkykvtsUHMOdJlK181tNTPDsApX2ugzzHAeU=", "F1cgKejolyAtDmXCFyxXHUuRyoVuetPxGK2SISe4cFQ=", "L7+Mxux++zAQZCPy5nsKqUAzYOVuiLbFy67DSoC9x/Q="], ["DsGCFkj93ESKFRKuzIrDdxSSOYGUD1VCc3pGjU2IfI8=", "BBgIHejClYNVoeReKO5RuixmytBINfT72B5pbeY5h2k=", "Dqe8UlA+IDnSd5EuAi/W0N7VvGh8b/lxlJdvOii9MMY=", "EqsxhibVEcI9KLqp+1tYAuCrlePLF67bqiX00ITP2lc=", "DR40GSND1m/BtlkctqOwYCsINaQDxyJ9vL1y/YAAxvI=", "EuOwSSSyz25Ae9JrPNR7ymHW/89++hrqHC4NikneZL4=", "Bt2J+r+SVGhHucE7Oja7x+Z5xbsN14VAPz/0m75hyOc=", "F7n6zb50fXxRY8oA47C4JdAS7UNXYE5xhXUNZ3xrNX8=", "Cv8VZQuAW/9vizUV1eKc+RS3NJr4kk55YAn4pPG3Jkw=", "DQZOckSe/BHR6QuXdJ3jkJSQuRK7H3L1QvQdYqsthHo="], ["JVpJOqS+zZ0TfrdpQcQSB4TBIz9sX99dZcCDKvVD5BU=", "Hz6TerKfOojG/kOGmKcZilIJqmrJ8UExnzuyAef9ZxY=", "IYC56xVuszytGqdQ6g+j3b+kEnKW5Jf4bmRB4FKiO0U=", "HMadjzTuh3g4lQ4gqdTEvT6ayvPWk6pkyuBPqiJaLh4=", "C1ZReYh+4w44FjHY5d01fHDuLrtBBhfSMh9thTf5iXA=", "EWKlbtO7u0tnYKFqMAunICEwCG2k1ViKcJJkI/+MJC8=", "E2D3GQNFcrWUEMUptipiqpRWVlRZfkJ3nzNADx0X1lI=", "DGA9A/koYNqKaMbcsZJNGkUJmupQ8aNi7bLyp93+kP8=", "GpGPwRfZpkReNj7lgz3AFBEDS5U4TZju5HrolvkqfWc=", "AqiODDVhdmXzzC/HfZCvx6jRABxx3rzyczygxxoZ4eo="], ["Eg9EZwMBsUNSSSlNmDPVngFoKvTIZYcZcnZ4/Zq37y4=", "ARPpaHabDqMst7X/cEhKrMlvE9woJ6jl5hFpXgeX/Dw=", "GM0UcUMK2tMeRbUpSU/Ip+MZvS/AYZyZIH36zbZXu/c=", "I9D6ll6SDfxTC1JnCx4y4tX8KCH8kYwIRKADtxQYJa0=", "LqazKvN812XXKN3vowkYkCoh4ZspFACFT1Y5PFbWlGA=", "AzQMrLBNWoVhTqzEvjNSk4uqP8cUwldaqdhfc5ETxQs=", "Ff+CfgNMAqkHZ/AVKEDn/G25g+SW6gUZwP9B3qgYBig=", "BdVvDIRNFpJIUDE15N65/9YynVTPzu1LlH14pWhoEUc=", "LlYYQR7+owzH3jENSHJZfQh8HhIuAuuxF9sMLf8E/Aw=", "Fe6z4FQbzwENoMR62xL231QLl01DnJPhnqTQL5l11EY="]], [["Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "mBPIA/+Eo2lO7a9LHCFyYVJ13BjKZUx5mnBECUbM8A==", "IClz9/ulvSHtWL/nFW17KQENQQkPY/G7KQwdXaGtYA==", "EjBerfZNrCSnkTpi2Vrv1F9INVV2xnHlb96cx8g0T/0=", "JceDrWbWofxshHcL1jf2IHCX3/sDeNfgOV+MC4a1Bfk=", "Ii3rYG8TzyjHOmchbYixb1lY1dKSuhDvO8LBD1oLYT8=", "FhTQJUcncf2HCp6dQis1ccVJTn1nmCTY/hISF31fouw=", "ATWL3Wt6UbH1tdCU29juCGzNz7nCf6rQgG6O9xjQ4rE=", "HCAH66TRYphGu2lASsyEVl3l0kYg91z82fEf7us/N0g=", "IvSdckQHfkH0CcCzU6/RaW46oV/9tKC9uIP/56Gochc=", "GVFSOkJwxUQD3+Mhj9PUzO+kMRTxsZ+ywoIaQ3Rxi50="], ["ARoTGjd4w3dCM7xUCWQZ1GPTq7rhgyKn53pRGIFmX5M=", "FJWvA9yRgMiG8OG9r50Y4y5rDRuANw58vldF2vxDNSM=", "EZNExTcH8AJDmDxtAk/Umg+K+A5YcZM+WP+Hw6H0i5M=", "qSvWqRnRYFYVeG8u/oB0PKV8EOyAz7kmcitb7UCLeQ==", "HH06ksqkNc3ZdFILtvtsrIFjTMm/TlNN93c24G12jDw=", "EvuIoPb3SdaNqSUNWt7PCIRCgnJI1n+Yn9FLXJzU1Mc=", "L2xOCXu1hRvhK74scSwvqQbzELeASNaVtKrTAf/A0mg=", "HAbHgvvAmAueSTsppeSgSu/GaM1CVdbP4gjp58i5ocQ=", "IRhlt/nBx5GjPXA60ygPaXVjJDSa/IkSoZuD3izQagw=", "JVQuB8HBOXm7FPjU7pPat6PcdQgGzzfywC/1O0u55m0=", "ErWgnh6V4NAfvNI0+tRz2O4rqXb6IoJ/+m3QPIslpk8="], ["KhirTcR3fhPLg1jBxCMVNXDRy5CVRCQ6vazUVHyOw6o=", "DZXoz4pmtWwy59EeAQfkHhKXEi0azEEzLxtJiVo8l/w=", "B8IvlvL1VlPQTtxjFQVnp6BGCbC3nuz6yxSF3Ot7yHM=", "D3FsVN5BkgxAGmLfj5GG4ZuVI+mGN6WxE9YczDC6AhM=", "LNaPwxtn3EX7axb0K164nboq5+mqUMXxkVJ1qBiHGQo=", "ZikuZOaixkZzrtNly1D3vU4dO1Jw9rLpmCWQw/hADg==", "CKHvZfUhKOs7It8rasowUJsK+K8veIju52bAwkhxGIs=", "JFKWOOvN8m3ogWKH/sY3BhThEuEMA5GQwQOnXO0RtCY=", "EuS1QI9IZBlRc56iflIQZyQLgqpRpC3i1NwegiWQgYc=", "hLiLHORZi3Ac+WozeaAqMVfUGTyKjxFXRZ9qNOwy+w==", "LBhOkE17/TaNRJW54wJ/mva5MTyPGT+SmsniTRDXo28="], ["FuvXgsvPbWPDi4eyfbKkpa9YR6mmCInEz2qjGNaGax4=", "CwXxYQjEYWqXOwHYLlDU/J3NzOZ9LSH4UoFr0jTphys=", "LzlM/T5EJQPDoiUSqkt2uVt0PHB2ykEVqfu7fGsH7l0=", "ChV+JE+TkSXVf5yOZvfYjsD7PAW5D1JrrAhxvKhGd/U=", "HUVnwS22SNSpxBMkwDKTJbdqB3MPrXLvnkkKdIZ0mFw=", "CpSi18QJPGOII7CVcz83F21+dHuiRkW1FawqJB/92oE=", "L28UUC8g2Vip/yO2lsrDriSWdReuiy6Vktr0UYQLuY4=", "EmQcw89Qyme8k7yMGe2J1GE+nigaUc3zE8vIERkiJCw=", "AhhcekrYyyHxkAk5bxNKLD/WFNMF5HXd0Z8m9tSz+c4=", "L22jhUUJEc0nLhNgHnzmbCuR2AkwdJL37leK401vX7Q=", "FvxI5V1k2DAQrVczd+okIjl/w6fmyIr4CKVm3gIj8MA="], ["ArftR/rCddNPhC8JsB75QhAU3gQMJqWRWVsie6e8b7I=", "IwtiMVswvEnXPf+KneecYg4Dx0exTEMvFwcV5YjWBao=", "IGNRdQA3vckNTz55GGGfxpDCtYV/i/vYbXwAHkzyyhg=", "Ihi+hh1STq8DuUILE2jpxap87+5y0ObvgHMu6dfm4sA=", "Bp7k6yC0hg1K+Rr+F4Ezj1OqNUVi7Nhz4OYlr3B0byY=", "CiJhKNodm9WzKfVfUsdWgt7zNpqxM1nct9IS7vyoYik=", "F860KhnebdMuOzjMKZDmQnO1KlYYJj7r+knYRRjqO+8=", "KQEt7/sRLrFANBWcWRYvhm1KGAO00ZKkMpNZ8PkDJm8=", "CcSy9hrfJFJmFozJGOlvf438Nb0997I/xkHvAbzHHM4=", "GAK5flS/Ool4Yyy+EOQpcFsDaAMl0m6hkMDx68c2LqM=", "LbGsTCscI6AAJ/3PD2Y6+JbYdBW7A1sUnSitPamMb8w="], ["DF5J4xn7lTUHPwf54FWsyvPj8ko13LRsq2ffxkjvrzA=", "FdIXoxeEdBBI8ybhVa+W6QtarnNPBneeaYhkA5yS4SM=", "GszqCcK/0X9AYXJccS/Rl2oH53PlTZBtoWYhUgGlgTY=", "L5vRnQyMOIen/AFz+GPwdeZrGDrYnxNwSTBBbh1ct+w=", "BsrQwr1DjE26LtZLv3UGbnMUhMNtH2c4tumGAen7SY0=", "G12oOWY2FYbogQ/tAyQ1yqgKm0dtshKQR07Rl3/O8i8=", "KtveXHtz6afiK5E/meQNleaJxlxCjCOXzSc5I89o3b0=", "GouK0ey2y4iCc6kL74saLPwD3UTgsosY4QdOQEqeD0w=", "KB7KFLvDkgkZ4AEVBFHD5E/xjh3RFxQS/15mPXSgc8E=", "VMyBx9HVlYHrzSaxbMvcvxlo13+HoggdEwVPURGPfA==", "FwwFpfilXVyf3F6COLNnvjWJF6GaKLTEfkbz5z1CoIU="], ["AWHkrlstJM1ji6XDK8Ixe/kNQE434APxBV2aluQG0w0=", "CvmvvsrhdhzBfUS1HKZtHb3q80HoXxCClY+cty97VdQ=", "BeUsD/jASo5ePH6vodCQL+Y+NYmJNLAPQzOzj+YU+RM=", "FOtAHBCEqd3NXQCS5dGimaoPVcNRVFx4FwPAHOh9ayk=", "Hg4WbXNKphTGtT209pEXmEGjP4EFQwo+5wq8qDum7G4=", "L6dd7tKB23NPq6W3Dq9Xli+T4u6h09zuNMgasen8wO4=", "FL/jMRXfKTZwOT4dyNpNaUesxLYCSeWxyMrjdmZc1YA=", "F+oZjzqyYdoAAVLyaw6w6+CIpwnosGoYo9whCMIJaGQ=", "BTPopFS4zW341I+psKnLKVKTPhprHUI8vFTQUzpyWZs=", "GWgbQkLRHiiqclMM8zp9FXGfGoiP/2JeBGUsd+4rLeM=", "Hrf25VICFcFeJ0NVsZu/cau/BKpCbNB9pTbLP5Cfblc="], ["Ijx/xtJPxT0bQo7bjxxS0gzuxZIYfSx6awsUe2KSuB4=", "HaT048Z5CuG4nEEYhh2MoqUMyCpOfx7TxbqMuUS6Rok=", "LnCLqviUvFg15f6oEif6jPrvmQhtErCjp/P4W7ymHSg=", "E/4jviQmG6W5LTY5ifWOF/zu1KhY0cYfws8rcdvbaTY=", "HIeclCjhlgfWR/XvFBXnb3xZ/QHlKvuASGCBhR+aUoQ=", "EoyzFQsVy8T6qxS/fWdu82grUsq/yNNBnf2YEJ0Z7MA=", "K/UjzYqjviDOfYkfhyensktypNSDhITehCrMeC/YvTI=", "BFqqmc4eBqPAIVCASpEIf1ekO3l5d3PoMhbKlp6HM4A=", "KEzPcIWVR/y5w8e2TPCtYuUXJuyBtY6wHBofjsep63A=", "Gr/ksc9dsp1AeOUom7FDSYq7vcmvVnIEcKJqPforqFU=", "FBEadL0kcwyDNpnrQbOPHU7Rb88P7MFlW3byQ31KDJo="], ["GuBg45szjQmEXi6evrcL+3TNSvkmIX9XMr4rbLf+cqY=", "KGCqUtwvlnwMGguUKsgeAhidAxQwwRqRmlqolbz7YVE=", "CsI/AP8BW6qxyL6akJQ8PHLReBi+etQnxF6z/xgocn0=", "Ay+i8WZiLwV/YalAXJJWIjyrK6gslJVgeSF1WrAY9pA=", "IVwM1OPxvbSCuT5XGHnXkxvpACPXoiDo+TshyK3UH/o=", "BScAsZ721C6jkuBEoJTL/DCO6h9y8qNCix5yG/wyxq0=", "AzuTpc8V/7r6JybyUngkoRr45C4B06fuFZsnPKCmUgw=", "JU46zbx1rFkmebAytlqckdLgkqteVxlVG12mNbE+lHE=", "BPpWIKLAV9xVKln97+UKkBBoGQ/cPfh2GZHKtQoBpEk=", "HSJ5Zz9sq/ChxLjuv46ceDYWgLLlnX7Bk0iBn1s9WhQ=", "LUa0jlCQwMVqOQ3jc/TJogCNsxH+MQY89P7VRikRNYU="], ["BGGRq0HpOSnqUfGQ/U53OsjVCDMo1LLwSCjco+aQmMM=", "Fv8z1nyFEhvO59gc/xYYkn8ckrTR0hwqB7auGLK3ubc=", "AhNHmPTKf7mSgBLJN/N96HQyuGZa7t83Pn/6b+DBPQA=", "Ku3b+iRXVq0eFlhin3R7jadZOxlcyVAyT5Xtye2kKq8=", "H0H8Z8oTIrN7eqAbYx/RkQUoH2xqTTf79o/BtfYoAsY=", "ItHmTU7hXmDEWdhR7580lek39akJkDgsl4Z8RbeUAHE=", "JJ9Bb65atSpDXWUgEAbdiujVQmbk1WQzB1UZAkI/fMY=", "EqmWq8hXcCGseIDBbwWNngbpURGH8Krf9rtkDkMW0mw=", "LSZAp07emvbJiI5faKhPrJKxMzfa2PxhUvqzS1VBmQg=", "DyRtL7tOEhfwljH7yHcIJ8NnUeatjW+xaBDjOVFDrYA=", "FfMOvfuLjuZEJBA5omtAjceo3nfyzG/tdUtwPqkt3lM="], ["FLobU4Pjczxj0Awywrv/2OVFB+0zv3VEyGOIGR7KPkA=", "G6DoNfR2JrDYJCaQDEkXCovinDnZAzeqX8EHZOIyGhs=", "Ahn14opfpSaJ0re+QyYkKAyUDJv5iDwfsP6Sn3iHPBs=", "EjpgVWgQI7FlcMcPzfOujjh6lzaQueZ2G+IvmUHX73Y=", "Hc42Bir35LAJj1WQYiztevnyjojUds3hOR6zBAjV0mY=", "JS50dGZ3/XWEzrD4qmk2vQT5Uo72AHN+mRP+S1aY6yg=", "GakHmpiXojcHQlJ2eRK+17djWujKDt4t06QqdcHGuBo=", "B3ft702RUg/NSQoi3Faal+VAoP21J7Sxo6hU/jRrjn8=", "Eho3ZCaf01zfHmIcPcYxj0e4YjgLoANXhJ2IQAWUY+4=", "L4DKFRsHe1B2coHqXUwfdFf42kRN2hbYFJu2wQYe0Ko=", "HulQxFoML0pLZGiKeTXtK2PU/ltBSvoFwaKEZ0QJ8WU="]], [["LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "H5MFV6KEmYIl9fTk37z1rCEfGxLZGwVi7T1jKF16cUo=", "AY6CIvaQfaV0Xuuc1KnmLyi4txCqhf5yn56nOj7wCZ0=", "GA6STXV9C+QGb+sUbtViEuOKz530lXQyZT83D5Bbiwc=", "L30HFdE5EZDnsUoSQrZ5nqwxQuIfCMoCwhdV6ud6Vbw=", "Aig+2NXm+UcLP09Jp3EGHkpPx9rGg978wDSKiGLGznE=", "IfYO+xMrYpCZkLn5lPOBqcAqvDzLVMXI6MnFZkxpE9Y=", "HN6CrO5guEQk6bzuSaVGTuBdHPC3BGkgimdWNaxxVJU=", "EYokUQohU/gY8KmWyH3pE1h4BfFs2xk52UBpQflY6OE=", "FkVnsN4Wt6VVD8oim6x8sHeVJDJeTKXnioYHiIFmAmQ=", "GI/zAxlBEqcDRSfMndC03rCWDJwQbOEVF43XCH5OjAI=", "CD2DKt+btKJfaGq+2p8W6/UyY9z570MReB0Jkg0JTq0="], ["D9VHhA86MKUzqZTR/bP2CuUHP0SE80vpUe4Wonb965o=", "BMQGGCDNqb9HLfP2TWr6AE8ehiPQpPYULMofGaTCdfs=", "EHdX6wwHmfeBMI2D0uBX74EG9rZWtF52NhgeETos3zI=", "Ks0544kqxCntgShj76Be2nRrVbuXRpSk53uaGau1UAE=", "KXiLts2Ufqnvru/Q7rf9Vj/MLkC9Yj6iskQrVdmNxaY=", "BquGcsk2BwoQdXrbRQMaXiki8PuLX6s6T144cvtYLtM=", "HbmKVi/NGl5EluYSZKrV6jtFX0bqvYlXumcenDHlCSs=", "HE3eB9D5TRqqgyrC9XEtQ4tOGAS1IJzlWULXr7JMZAE=", "LPyCcS7Z1x/0/fY+5K0Rb6wZV5T42RAobBUu/Z+Vm+4=", "GLSbdz9XmYiOmr4/aIPXBjMzg1ts3TM1gLK0v0jzsn4=", "CzAN5bmcJ9MyCR+PsNl88EqGpR1NIDd4jg1POOj06rI=", "BUGva5ZSRmIITRII1xtrKo1m2RF5dFshNnnCorvJSWg="], ["BQGWcb2gJmcMf/qQgXlRBZY/Vs4yf894RR+6K9s6wcY=", "Dbwiw+VMkkqILCIACVEjnMJjdV38s4sn70+IDiAstfo=", "CWaiG5YVryt1Y9/kG4ufwGA5US3JyOEZaJHrd/hWtgg=", "F7GGIdvWHfCF2kz4oDOV43ACacffTZjOSFH5Cry7NjE=", "EswnRkf8Vyu3kDW/wzMqTlZqKAEfad0IdPAcVrxEw+I=", "LH1Ti55tKy4G5y+KqrJtvd6tH+9qdAoR6ZU/jo6e4Fc=", "LzCADA7kYQEFadNrYGhaOLApEqAgvEcIWYhU9lgi8Vw=", "EWxF5NiM6uRWXA6U2oROryd11fW0NdlNLT04tYP6eEE=", "L/zLxAAx66/s/DqXKEvQ9txNRezri4mY8aZnvuNp7WI=", "IAdCSxKa3iGUxz5uLJ15Ng0TYMT7uMXzEzD5OFWLOs4=", "LFPWZ21NTIfZ6vXU2gjR6Y0QOjOI1Zp8DD3lHiYjqjo=", "LPLJksAqNjNP9dyFFkbufaBLROtUTuPA+tuNxe7ypYU="], ["KVLBjBVVjymyrnf8OeUaOV8XOpCX20BNt2WrApBrJ9w=", "L7scWenomZ2RxA9NRCMxIqs1/8l17ftDxT7Qfb8NnHY=", "CCBGCBSY7uY8KHxvo+/N7+uhtScqd7upz921avpTyC0=", "AqQpwtBtzzTTRzDDr4vBmwSr1lJGjeWoW11cv9nCPm4=", "LvWEw6ru274rSxA6YelO1AqXKUFWrX3fDeQ7hFJJ9TQ=", "KORiDSEFNryqQu5Gsc3LIb8hWTO65O7GOe+9UfS7ZVc=", "HjKx4ua1knOhE9YJZjr2swyVs2iE/l+vNx3j1WQhPDs=", "GIIDZIBNIhGTR7coE1tAmVb3kz3voQWdY0uXfZ06vN4=", "CbbACjffJ3DOwPG/Yqaqw704DGzp9PluDwh5I3/6UQs=", "BEXibib5FwfaLfXBiLr4DqL0jHA2FJgPp5iXHNjsYPU=", "GfUQFxUWKXZ2bitXpYZ0vFjhuivhilmwegfkqT4DgHU=", "BsXfj9Yeyi+0kj8KRt1OQWo6O0jBDe0TEz/+q2/RU+M="], ["I1OmCva9YeXqwsmkJj1FH60HOAZU1HkjeNr3UuXMM/o=", "C49A0sTSjEcghSA6DkYK9zu+zsOys6Y/JwKPLKinElE=", "LH7L8UstYEmmQ50PKfEOJuyXWsw+Pt23fIMaUJr1kZY=", "GX37ZBicCarvlKH1QtjDSuon//unBCAtUobWK9Du03I=", "BfmmqNZMyhJyXdFREPdK7Pmd0w5Xp9mYKc2HV7dbdy8=", "/g3vcL+6QGea741aI5s6G1pS/o/X7bdUruKxgtZLZg==", "GxUjRjpFopgoiQSGgaQiwC6jc/i4wb8Wx0o3XVBgxmI=", "DISdB7HZ5uy6xRf8GSN/9zQkoGePlGmbI/dpUq+kUUw=", "LEA2YWwVYAYzd3HB41X8Dy8jjmTL1p0Giqu0tYEWiG8=", "F2gE7Bz4XTUpg1EkXTIjZUaDjZuYz0JC1gHH6OUBtJs=", "L1hVqHajf3u71hBKzPyuUH6d3NKnIZtIenaxfFJbUMo=", "GiM8fOv7DG63Lf0HqitTfM8pHoQJOq42zGgAL/uDY5s="], ["DtajvUgXTjcLTyZLN0iLA6Xj9MD2HPMtMVetPjuG9r0=", "AowBqfAWAbtGQX7UZr5gCFlQUveC5GhX2BIp5k5r2gI=", "FEAi5+B3/yKizj3+mSMQfVrvBG0KHyy182GRqwTq5O0=", "D9O9t5ytkTQyt9OCjgctrcJs9JA9VriXYgByOEbGV34=", "KXnRrq/fl5iFYNTrus+m4rfz0CaUaru51Tl2ReboGCU=", "Iq4CNSCXl0HlxY+wT9JdEtyPX8tq0VIjpdp+D5HHtPU=", "BSRu54VLLiDoYS2gIbMHmOXw0Cpb/V550/msbHn6YJs=", "K2Ck1D0SzzEHbgaQ6TFxbEeobncow0stPLDLz5W7t08=", "BBuQmmWNE2mTs/UJqenVATi6ykj2tmOZrFxknmjdOqQ=", "JbbmXpD/v5ENGf464j0Df49k2p/j30g/xPSXfKNqexw=", "LA3kSKiN/qrMm88oULb/T3AeGlONaQmLyUCHzDWTCWY=", "BfbWL1RRjwOeeapya/FaWYNYPspAYkBUAKzKWMqdIjU="], ["IRA6eqIMjRVQG+jCNQTGqRLGEAxdiAhcwuQqUjAvRIM=", "I86OQCk5zM82F2pb2DGDoNVKJO5sq+T8f4FN+/Jvheo=", "FwQD1BQUj0aBuCE1UJUeI47cAJ9GsAaTzj2cWAD63Qo=", "Kbn/4F2yxS3dG/DlxTLu/nBJfH30uX2y8GJINldqayk=", "FTiRBS/KEpD7+DJA0zT9TOBd54rfqiyWhkiODEfOH8A=", "EFwLJGZgxL2Kbxs2/Dz/hqLEMsDckyHLUKu5ihDNG64=", "Bs34BVQ5rIQkxDXn6b6j8K6T6rFxrDg+0s7bRg/LBMQ=", "AxYde5ThsEEfwB3PvXSKbfMVb/BFNrPdMQH3suvDgRs=", "JcB1tB6i2CeklVtkadudQXYPr4hfLG6cCUB+uxxNwnQ=", "L6KveXDhMffv46fHiIkKuGD3Z1HlW0/2NN1GzE3mYNg=", "DOWHBm6uDDRcM2jFPf8hcM2wgb7lKyQ6Hm3m1PgkUdc=", "Kwnek8bjFIz3/1cxyOFE3rtmyoluy+QInS0iy9sJd34="], ["L7IyVz6F1oxTbRAMOm6pFyiERR5new0c0PtNxMJ1Nrc=", "Dbgqu806G1b3/I0RbLVMVP4mJDcCvT1X5x984NRwpA8=", "KZfZKl6bxmyE9jXoy/CA63IOzUyj5Cw6uNCIYRiAhho=", "CioAbjsIa/UCxbFUDqrsFLnBW/iEccttR5+0Vj8BZJc=", "G4x+sE01Gv9Odq9/n6ERT+Rartr960LBwjUDsSJjnHs=", "Klq6O0XnnrJgaypbR+uQdYSuz7/AtM1QzaHOSFQzhZc=", "L5pc23lkXjRUxhfXendP6vJO9gNFTAIHb8TJ11SMxFU=", "BkOOiwIgRkA5p7gCLwa+ruUCxd4mnbgvkdiP4bcoNPo=", "EVqRhnIzzHXRyQakKTDpPLnBavztOQzBRDXlz++06W4=", "DI/U7OXCBRkM9shC0Wg0RAeb9Jg11ci437sRr5VsyvM=", "LOqYzGSr2Sbflj2lfy70xDQUHLU6xjEbJWbtuVeYJxM=", "Ajns2SUXglF095Y0XbKWViIjdg+xuBwJG3SmpKgpaKQ="], ["MCoIW+BA/5pwmtDHMjiw0eEeHRdAmrqjT8Rd4ptUFTU=", "LnA+qa+ZFhrPmUnaevsY1GLYW2cWVtYcLN7jpyOQIT8=", "IUJ7Opos3x4ubGKJBrIeJCcdcsGLAmG+aMykSGXezhE=", "I3qeAgkIzQ7b2erodyNQ4Ocx4yKLiS/F9k/fqbnapnA=", "LYEl2+9gK9lw0R+tfP4Gw8ZPVoewm5YKuSsU9p776lc=", "I6OyPV7fXLZhYP0lI7OjgxQikcDg7mZmgulGsdV5N9Y=", "AbFiXXV3hqGak7N6338iyopQKqRGLKePfaLXwis31/k=", "FImLq8iBDLxiZohTFRGoRz7YmiJWnUe6WGwoTkW9CuA=", "L4+zcXi1JXWL9qpSfyV3Ph68+OFCU3lQDIJFx0G6P8Q=", "DpkvREY+Lf0mfmpKHDMD6noRhiUu/Wyfrp5fDB9tgmY=", "LHrkddkMR19zwNKb6IidDEuFNv7mwDiZhL+eTbsarm0=", "KUXLheNFMuOiL8V2cDeXiTzikNAVZDCo3OYcnfiai9U="], ["BoPmQOYVTvc8PNax0PD9huv34pLmP6hM8KiDwvH6qLo=", "FlEsFQwdL7cjXv0tTw+tX914+NDN5TpmvJAgbILEtZc=", "JLulgIanhUGo6/1TXBB8NpRteLpssm0ifmFRMfcdM30=", "bTSdYYLsMNaMm+AQWHxwf34eF1wNMk5q3e1jN6csKw==", "EJJIB/b9xOnlhnkuOs4wAfFrwC6EraXfUde9NyQ+4e4=", "JmNfTfcXIQfa1rfDBo0tQ4v79IZHEDn55lqchGKiycI=", "KL9UiKUl9VFEANznIkMCh/6OTIEBVAVusPTW/mEJHPU=", "kN/MAyelQWcs/CbH4TcFg8X5IUF3CTAQ/T+/J5qv1A==", "KaFNxLrApMUr8wqva5uOBUU9DXlyRrZHMtUPF2p8olc=", "AmCf+X71dP1o0Wo94IcsO1mluSgljdFGmCahkdy/W9A=", "IyOP2hQXMC3QPOVGB3SWECkpRb3b1YckFxT9OWSvXxA=", "075qWxK88bxwXCDDDzILiIHGwuwA6FdoXAWZJio88A=="], ["Hwnz+wf39kdvrJiUa3N1CV4BSyjyOgesn8cHcUSsOXk=", "ApiqXVpEVlt172jfkC15HQHZinXoIu9VOxdhxY1v3zI=", "Af1abrpS6eods4mh/I3T0Cg9c3wY6wbgkLb9LciOChQ=", "Cqu6OdIg8wYE0MRN1Hw8cN47efW6pwo6egygKuGwgMU=", "IwkYkZtoJvqnEkxb0V0QwDbVZeEAtpajvnr67bKrums=", "K7KO9C9fratqb/1WVbNlgN6wY64wgdWHuxWYh4WQ8cw=", "IYkb7jH7e9ifDkQis8j1s5MpmvDZgl25vnPnsgCXkjw=", "A44MLinHnM9GteobxYknauyVt06LuC5DhcBYVjfIhfg=", "LIncdWK5HY8vfaogm3VgUgtrxi7GMdtBzF7awfsUK+Q=", "FdxXh5y0HWAV2piB+Ui0DSDw4D+th3RthXWvAJyWAz0=", "HGdP8urSfOAC9L78etXw9RI+WXk8D+IQdegZzlbOHoM=", "Eee8SjnScwGWtsM0+ZdQ3lu15PvKXWoZ63/hSr6EXb0="], ["BZjDjS4seN/kkHx06CMlyxkdUmCJVbWD5YJuvr0YV7U=", "ID/SB4qyqPiLdgZUMUXuNNrqsq78oxvASkdgZWl8q/g=", "EnZELZODxS1Q/Jtaw0RCpOyOnNeu5tbOrMGm9SGq5KQ=", "Fu6YCixn3iT6GjQILxHHG3xFlmpui8aqGh28fvapurI=", "HbkiuMJJ/3v5YSHq6dlVXvd3Dz3XsFYZGumrOKXM9u0=", "CW3UOoMqto415XyY17AfKi5ZNoB3BFk6xyx0ABOD9+I=", "IoLoat6FhV1OoGV8St0gYlxtqpC8k5Q7Waktu3e2NoE=", "KDMdDTHKhnWtR2fEkCYbv+W4SttMosVZmofzMZCBMPQ=", "FJcr/IXeA3sH5VMy5rxbTwjzntTripch3/xKWG3Zod8=", "BtA5tk6C15dd0ho3te55MI8g6C4jSJOC7C0XYZBYeJY=", "Jie+aNnNDM2jgo1RYhukCfms8J8anMUDop7DBvhgauc=", "DHyduVKGX7lHD4qhQCU2yzuCJ22eKICCrH+DsQvLbRc="]], [["DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LYxwA1cxrZ77qSghqIEZ9rgYOjYr5kFympPWoyfAOAk=", "B7YgyKeOCeSc5UeqeDqnjz5FlMSas91vYCvGwDUdgj8=", "IxmWtZJShXVWfTnQBkWoOxOSkJO7+gDWpmHkppA1HQ8=", "BOR6cuSbnFqj9p9q8i+gq2QMk/xSTdPFCEhtZvB5hSo=", "Coy0sr8/DF2mceSPg+XBswGPDTEgCm8Z/VGV2yLu9/Q=", "GLuwArRvLl/sKxIPr4eCLKjnes6U4DqrXBbEuTFzncg=", "Ar+uGwVO8ukk11qKASg9opEDxXutEp7IOWzidLpFJN8=", "BtEBsZR30WJ7lUJYG/DN+rOLBc3v3LgZZcW+ANeA8ZI=", "GK9h9hhP+F8QTCvvF5s+xaXSQt++vo4nopGPYg6KW+g=", "EeOnwtX3Q3G+sYjG49ehSzMSivjuModUbRLXd3zvcMs=", "LeXWp6JzQ90EIqxxuNQJtDzLC2cul4+P39IU9NeGZAQ=", "Iny0O5gYkk8qJYiWSgrX3fo99iKEtLOxAZmlAe2XBiI="], ["Ky/18nUxtvPWqF114+CPOi8NrDaApsJtVey/gDyoBWk=", "Ce80kq0Z3R0L++sZEzCogO55M8nTs2u1+gIoO65dYF4=", "J9a9GHA9fKkqokB20xh7bAAo0LYhPZ5dLGYRUjehkFE=", "GT8yo/g592BJycvyQUWQaYohGOg2WDJ8QziqNkjY99c=", "I10OcaNQ8fI9m7UYKsROyeRhXneAHlqtyrgzaq2xcSw=", "HfXJ72lK/mG8JTrpCKj2rwoIzbnnip8yLCI4gyLxbCo=", "HbICHso6NiSn1FuxbPSkTir0+uDcKAAw5+vlU5T2nYw=", "GkaiZpGEHCYQmjKuB+tYSmuK9lcnPNxNihEt6gvMhc8=", "DK6AzAWu22bW5kmwV9vFrpdZ2l17Q9XiWkAOH5Lp0ao=", "GVBXrxMZ4k3xuQXG4uspVwA8/DSwAcDlS53PLqXfa+k=", "LU01rNnyij5r/WAUcpSCk8Hk8ITHFN2xoHXy6unOIbM=", "Al6y7YTFIKuhZOM/A1O1ExiGwPvRjlVpVUFRLexWOgw=", "FsfFxhYe2jLGW7NHZVrKqAvMmL/AI/SrEvWyqJnzfj0="], ["C2WISc5iC77v8jO30SJYAV6p+HpTkPVhSYHrbky0pfo=", "FFjeUWpTQZDFVQxqG+069TXDiyQuuSkTcwluxg45wfE=", "KWnrUBbySzGszxc8ogRmjcIimEW/ZEbOoAfBEzSb1Nc=", "Cl2mWbb8saQnPht+O1RNLL02LKxJev0AS46pIP2wS/8=", "Ehl0DEJHQ9u/iWmW8O56QHa6lgpX6Ndnm4KEeSGFcNE=", "E0QxEo5f/Aq2ATbF2FGhHc3WPNzxetZP13UXcB3mdfg=", "CXxhM66o/kjzpfxBa99eRtBd4HI7xJ5Tufteg9NQwpU=", "EH2geE37MU2ChZvkTTe00rY0XBdLkWUcZcmESWgqUgQ=", "EiVrO5nTHYo3KYb5XWbME53SPpNUh9oms+JJ6ny/ka4=", "HZUuv/y+3SYDbFSh6KKCj+MgrfB6KG5/LCEbR/bD7oY=", "JjCbUstV9upakDCwE3j2XS5repYZkm2bGx4hy6Afp+E=", "ChJSXweBMiNx/XCwkozObi6qpnuJcNzfMZ3yXoAZpt4=", "J+N8aKAVMPCSzTfEom3s4nN4aNwsNRlDXh8suI8Htiw="], ["EYEy+8HNg/lRZ8tEc9VMa9LEF+J4Ll7+oW5y1HtItw8=", "E27yUVlV/2YZSY+sWUJIFhifiWrA7Wm1mFTRBd9HxLQ=", "KcZ7zgS/0CD0/36sq2y94DSyL7hjNGdaNh8FnlA5UxE=", "Aqgyzu04N+dCGW4JSR/iPj9uURJuq5rOyW5xlTEC7yQ=", "K1AfEAPieqgJ3J5c2El2o7jBacHpxjl314I/gNP4I74=", "A+pOK//gLaWXfO0fGm6FLpIavi4BXzWzbOS9AkbCzYk=", "FQ756TKnS43r9nAIBkEzmxJoT/WjA7L7fB2NVvVqth8=", "K0WzviZ0/YIFFqzWzGGDxPrg9+36mvzQLf7szQK/7UY=", "I4ll1liWevorzlD/GMu+U1MnxlsLduUNowc53tJetJI=", "A3C3V6xs3UZhDuwMItQ6VD1eBIJXe73BTnEJAwe19po=", "KqhMHvnoSKZPdIuA4nndz/hx6cTD4vr6r3kVmwtOQBg=", "G79D3bWgsNKEWSOxzhKCkjWcuzE8WHb7tS9eax/LcDE=", "Gd0cbUUpgkitSZUx8zzgAlBUWNdheOyiYpjjmmL7lQE="], ["C1lEdo1hwbNWKldJ9PBsTdCFu1Yrg41+LvFKIf31JMA=", "GMv94M0hwYN5ei8IlZSoHNgo87B0I3HtAuuD+wBk3UM=", "EkR0sIgp2bcXxQiEvIlc0/gdUZhZ0hI116dEUNCpQns=", "CYuyxMYzTf6kdNBMsul2GGH2sYqAWKUrYZ1iJ6JiKKg=", "DzTbk+qNKtfR7/httYIMx62ke9zYyC0Bgh9cIaPqIyU=", "BuA8oRRnBVIrtencc1YO7ua5tL9R1I+VP70fAG11inU=", "Ejf0TwNrLaAGepSUczTjr6KsTPEAmJZ2b1sZHN4oSXI=", "IILpEDzEUkWSQokRFScxKGD25+6UV48BGPSpIND41SU=", "I6bhQyhOjyOMS2Mq14rOWw3NlKiXywXR4pe0iA50M7I=", "IuB2o6puv+mWugaL9b/7F/pyQzjNZ/Z+olMwGVxigXI=", "L+MbDfBPJ2pSW2GazEpbo+tY2MMhxiOQ/rqwXs28eY0=", "I+jDYGrugY0q+oxEZdXsucRb3njdgZwPNaYgWTwfQuY=", "IV9VY0ZOLfao2qjDRHakZeTun6CtAfxDmbZJsuB9Fnk="], ["KwTW/7r3FEAS2SxcYhKAPAtbzA17GVC4idH6bz5WRFo=", "InV9qegiNFKXvQYKP3G7HnDOl3BJw5MjUDVnfoQ1cxQ=", "LH4o9Z/oqKO7L6KyseEUzig/4iqXij359ioXHLHWXk4=", "EBdJ+d0mBRkcGWPyVpSuJn9rRL/i0a80/vy2XpWHhLA=", "BNAqsFgm+lC8xfmvnjlkd+aFQtB2toPuYbhYadRTWJM=", "AUxJnuUZJbIx2hfue1WnX5b0YuQxZ17jbHvk6bBp4mA=", "LZ6pnS0jcygmbVndfgGLvWvMeUHZ/18HoXuvAJn2FNI=", "MDqeIoVdldB+gXLzoFNtS5UUL5YrAGqKsJ57tjNehIc=", "JOE6OPBNXg/Atrbg94KmpSOos7ASciS44jdRucufiWA=", "EmhR8+rcAYMoinUBU5EKQeB0s1RPBhClEnOtNpi+DLk=", "J8G0Br0Z7RPVM1ULi2IRhrH9R/Zx5mBGgDF+ZjiwkeE=", "FYiA9a25bdE5gSi5/zOfPYJ9pkY4kcyhKcASwGsWsyE=", "820WbpkTm5v8GsMnCj2YxK+oG/l0NgdvVzg9pQQ2pQ=="], ["Kb4qQoNK4y3jMg+w7ka0wQKj0a5ExdzhUv3qtUUMnEQ=", "FiKAUSXd80TBjjUdEegikWGLl1girQyQPvvq2lpR1E8=", "FlwLl4tLtkap/yJaxJAFISkr5UyHmILT8R6qMQM0FIc=", "DHteCTQ9tcY8EQ0xddAbtJgpDZcbHm3A6aDp5xWDVrE=", "K8yC51ORvk6pzQ+KUF+eT2hHePx6mxvOt4aLspnNIHI=", "BhHs0fN5oAYrBcSu2xALwBUkTGqI8WMaRWzCrMqJMMw=", "BHf5UeGfUxuENK11W2eD1htnnvu4f9lW45TbnENOI1I=", "KWNRQxPwRvhE+VD/6oD15bQktwfxZZlmLlouNmjL5fs=", "CQENc2d2IKrhsPqAI/8cgSMTrpw79DBm6mC8GrR3p/g=", "A2H0CCt1puvSP5pucwnYxOdSAVnaI0Qe3WMaasFMIM0=", "DOvPMJdbNyZ67fUh7ivHU8NCTcS27fOYT7Aq4erUTa8=", "I6GsBzUZRql0yIQekgkqT/xq78f6mI48H358h+FRKpA=", "Ht18ferySeD9P1doqpLp2tZBGLSRvM4SNAxG8hCwfO0="], ["GUb+neCpQ9WnFurAhWHNkfkDH+yC2pq3KIPHshixHrc=", "KXZdjPd2GaWAZY0Sf7b6pE1scKD01l26qWB1S0GV2f4=", "AgZhNLspnZ41nLgqg4D+tjtg5LmFnZuYcu2vkVL5LU8=", "EWoxPQDPmdwY4h+TpbsZgBi76kt83O0+TSEJcd0KaBs=", "D+KbW+rVTFu/QmuxKESikgiErER5BhAc6piImGoDCxE=", "Iq83wOSojerp9/rYOBmRBzXLS0kxHgquEct1NNC87m4=", "HYuLp3LEzacujvmxnEJNVdVyUbJHxjK+olUnGvz8cLY=", "BLf40dXsi/aJrfEtZWuU4VsLIpwWOMnEdX+vDRj6ZDM=", "CkHlpEId79Xtes/UhAE5WkCaZ8Pt9MFozjNo7ZRCEtc=", "Gr6LrbLRI1O5u5gVIIapQht87hd2FzDiWsKE1rHtezc=", "KRwNpzHAFsDWxMdThwMKliv3ous14VqsAvrfUwJ4o9E=", "A0xGD/8ohi73pQmhdQom7R5ZYPy1jE9Ix9Jnx35Y3WY=", "COF0Gpf2NI7W1o9Le8bsiy2/A/QmdpzHec7uS6G+sD8="], ["GvPKYkClWrpV345Jg1uS+hfjmtVwHvcPgUQQn4lL8dA=", "K7C2sI/BvREHDtxC8j6Ae4LouI73A1Xfx04Jan/zgcs=", "CTcu0Yuhp3Tq/hv/be7EvAgUsImcYZb6Faes0V7MXKI=", "BATA+hvR9+BZBUy7h/a1xp0RRX5Z+QQZzkvRC7ioA98=", "G7IJGHCk+sA2gv5bHi61axStbkj0Z2/kFFS/7rD/1Nk=", "KZ75Wu2MdUlNuC6GefvG1aPS4prs3PaXmpsnKmB91d8=", "IGqi824ysrBta+SK1JPTVMp0aHU/Um5r2CVJ/DbNQQk=", "JZVHFotksqIolBpULzlKJpnAgcFJRj3Cw9If2LLk8xw=", "L8fRfzqa/B3iia0PlBJq7sg0SYEgYpzIfEWGxid4AHU=", "FafmSlpG9Zc+ToKiY++QXtZPGCsgQbqgChNZ5+nF7ac=", "EhbwVgfgMuSQOKwUWBAOiayFGaWjzuRUWwiFDYvxYOA=", "Ij2xjzHIXpjh3XtyRd3doP+OMZvX0aZ/28fu9W1meBg=", "L0qoZB6kE1Ax9Nl6ei9nmoy8pWK6aqVOrn0y/30E29I="], ["CB9YqRpODRAOA2n92BoZADU0L9BnfuG/UhXkf45YwsM=", "BJUedHt65rmdklAQjF0rcBgak/8dS/cjeB4bk4Apgnw=", "HjoTDoyv+bXlY+iq+EsvxzZo41HP0oz2b1AS3mE0W1g=", "DBwhavMwVMSX7wQ4H1hYIpi1QzX2Mr1irdKeCAZ6Wdk=", "D1TJxSKlx04NTgxjYRp1AmV1dbepY8DnhtKnYcToRbs=", "EDzIOEvhvhCHubtHwOtgSfheBBP3tAjx3C+h5vxK+Rs=", "KNqTCazKED7PGd9ypyITTVMLrmxmDbPDZNDrsgDCrqo=", "J5Gd0vnT3J/L2hojuVzyPjYw5v1SEPrKas9GKbiOX/E=", "H4bj6dFH7WBMceH7bvhFnPxAABu0/FzMJmFmmxVavro=", "DhVOvVDbPChk2+HtcrCBYhCFG4bDU2ktF0TLM3K/py0=", "Ga5llFodvtOWXy3jo5/y1Uqx3uDzM7iPtJ7bP8mseJk=", "mbl8h4zjXJV9AbQ9qwf4AD4sN5tBymGm5WqSBPsWvA==", "IaCkPIjOJu/7+LmtZoBWtbA2LlAJ89gAM9tHMij7f8g="], ["IqhSr5BoCoypaItx7SfBV9ArQGvWx/2BIdfHeTrSMF0=", "F3gLlGnoHKcMfLtDR+f7QMY+9o893lHQTLR7O4P8KZ4=", "JVVDoxSvxaKZFBMijHXq45i5BXayO2zYYShmXMO9lHg=", "EcsgVE9DQ3poin3LVzp9pPjHtENzSe7fP85DKm88FlM=", "Fg9awLJIH4AZ6V4LJkRbpk3AOkvooVRhSWJH5qwpACo=", "IGz0KQrJhENPp3S7D4kBojOQVjK3k8gLHVmWbpanODI=", "AblDWFXWzEM5JA6fo4GcL/QgmA1s8Ucht15Msf5X4Rg=", "K5I35ZQeFlfvpQe4ksO43Vf8jVKHbstZndXhBStrHy8=", "GC2Pke4qmiYhWzXzwO7PjsXMNgEkz2uQPnDKgxJpddw=", "JVKNXTHb13z6bnsYR/joTIHB7VuuKlHJ5APMdUxUu1U=", "L5lq5iDQCj1OVe96bOC2gTiPG3/zh1tyWupuuQOdiyU=", "LCsefHD+wvWMoBvvWsN8u5RxrnkUvwjffkfdjjvDzpM=", "Axs2nQEfIZ5Kj7Id+TUoeNk/+ANbzag0w9zEHDwt+F0="], ["Cye6gqD/uYNomBc2rpJ6IngomFwAw+XfjBJ2sQAQiaE=", "GRPVHZxx0EK/v2Sdnm5upf3YK0/TFz/y/gK4VYJSiRI=", "B2VHRJ+gOEXxheYVeKWo8mg6GXM/wExzrGoLib67hFM=", "GG8WCuhm4QxL4Op9IEzWTlczfGDECzTDo3HXU/L/ABo=", "Lz1rjiNhFmCJUBuRR+hKtrCXkqwXpfCA11s+Mgr/yGw=", "Ddhdzwj9ONIvMW2R2BLLKohDCHda+p9mfGyoCVQ5fIY=", "I4gy5kMVjpZom1gDsLd2AbWb37SSYROjRV8f9N9uK0Y=", "IC445mmINhnsvGpqRTaLm5o+mrZ+/vUPiW3+SLeNPaw=", "Bn0rYS119Pl0MS0Erg/vQ6NbYO8FTA9HUwLFX8EL2rA=", "IfDGuJb7FCINgRRBYpx4+Ojid0YCYiDjMczriaDuiaM=", "LIJe5WHEq2oiMxF3mZyJgG+8NFGDh+gHwgw1lzm6nrY=", "BGJfIljt8CYroGR8rkJqSG/IAdwLWdIOwPTQr4y9I84=", "AgpyCDV5BZy2WZUtPyoB7ZDSEAInW16hHyCcdjuqhFc="], ["BLRlJiB+3HCg0jyEOLxJo2VjVVLe4kBmGize75ZvIPY=", "Kp40KlbItkZtP+UzuJ8atEG2Lf8xU9OuZQDCw75jZeg=", "L5i/CB4Ot4+AJcA+6cGZ8ug4xR5aCu/TM+n3z7OPU0s=", "Hh1ZIO3P6day0N2y9vdBr7BlkDQPwHsYLqfD672TOTE=", "G1m7YOmGGUmH/OoHBJi8x8k91WHOivX63nVM6sB7FwU=", "JM4Ky1ItpSfT6rcoZc8HPZVLq77TzRcGqmnXZ+mv580=", "C0O4+sxDz8BntVE6vM6EZQS5OVzcFN+WhhpSilKuLsU=", "JidY+z4HaTaZX/MUDvfRsKHg/kJApQdH4sPBINl386w=", "Dqs/JkF+a1PFMgct6S1Kp4zN8dqRZgpGGrsPn9e9zX8=", "IK3esq/SDnUqOdLyHr3cJ3J3OwYpItyN07oGiDbbpGQ=", "B1SUdDbDze0ppgyeiYI3whg6Sdt+cOfrc677S1xpMkY=", "I5ymGm735QGBCqiatJltvqj71H/S96LJaoGOk6PDjIk=", "GfEXcQSbW+gbQ8qB42EfQQikudwwzRIkQfdDGcOtzek="]], [["DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EoJuW5vhybhffJiqypziiocGh9NijWDe8KswcrV7Cbg=", "Iv6hKXpKXwiQTVVcLhXQFhAqTtKcMrS7EICe8Ur0LHc=", "JMxnUYlAh7gxWYtbx/nbPLtIzilNkgjhqkNstfougOE=", "LMPQUDoOHalSsIG6XcWxF+ZGvtVypkUmbG7DzgoUdLk=", "Ee7b5aWWnzNEZQNJS0aaK4P4jTqkd+XW15Y6gzOmExU=", "GJrp6bFiqxoZ1ZnO3O9Ci9EyXHh0CqrWcVtxC/rEweY=", "Gq0RRJ1uLG4a3PnokRTDNsAUVSjzVqwEn1L9jLCENwo=", "DX4eriz+xAZALTTCWeWWb24usmHU8I4pCIMlprtmmmM=", "B5aiOtbtKsmVEEoNPmx16XfOKauh0l5iqaiiA2TqG+A=", "KZuOhiHX2MjT1ihssSazTuU7LcmjaXuDgMbkf1cRNFw=", "IPEe6B0qyantHKxh2c/fEL8bSc37ttIyhyod8UJ8GDk=", "CkA+l5lDuNL5R/btptQRcIgTQbteT7uztP4919zN13c=", "BGRiUzgPS/ZClyroGXd3lFSqCDP9o2sYIsucCXGePdE="], ["EhhrsiAArYS2vykXmt4tTn6U/wflFifglYBXEGH6jOg=", "I345mA+QB7v4aZ2+zgVP6h8ZdmvmEBiF1CH6PqRrU0g=", "GAjL593yo2hNihZP4tFQ32Igb2vjPVd9xXmPGTru16E=", "AzzM7wWwvPe3eqVWCg+UnJC+XMLFcSL5iF0koRfGP5g=", "KFTIK0tfXfbdOHLj83E3LeDRLhbpEIdmkgtUWBBedr0=", "m2PHXfyrVy0oCwV/vDZA013V8WJEhjq4ox4JVtqIAg==", "KP028cdh6nvOKebwAGf6QLMuazGPUGtslLuEe/crW1I=", "K1bC5E9wOjsUPaA8JXSTZ/dSsWgXJX5tEjsQvIVUNDI=", "GE5YJGieT4FDhWffQ1854dNagZBB1+rzr5CEKb6yvC8=", "EATF7Lq2t9Eva7TK6rM91Wwfgp7ij0fCn7+7FH6IRlQ=", "Cpc6ZlaT7QlDTtsssKlxrSd6grM4V4hVI0muCei9DIU=", "ElR4yJc7w5W2SMgiCR+N9GlQSnHKT98dq1mnCND+Rxk=", "KwaW1FmAAgoqQhBzRA46T9Oe3FKI5pAKWVjgzYHg7uY=", "AmRiXHTyo7u9wZSBt4ZnV+Y5wSS061YNpTH875l3OQM="], ["I5n6pkiu35Akxqw86v6iSCFuJKnlbK9azSnOJUap9rI=", "BUD1SSSXWV4TCA8C9rHmU+LlGJUWD/1coU0mrtk7hnI=", "HBzLRP+KttqFTpJx9L7ybSrCbNdEHxtp0W7uDXp7SBs=", "Do78hc/r3ilc5YneYK7A20PIH0vn2kTrJvpLcffLfuk=", "Cx2BD8xyFVHipZbpAJNn/GqSSFerKbcDIHsIyV7NAB0=", "Cfysw5mAZRJN4Bv3wMi6JqxCQfH33soe7+XvPVAV460=", "BdLwo8IjEirAEhQlAyC1L/Wj0kIRjhl3iyyM0al2xhE=", "DHUT92K2QCKhUdYjAgmd/9UXkdmv09z5bL/PYDWiwnw=", "GP3mRRBiAW7eqjLkCo/DB1HhfpusGS+MqJHBHznr/4E=", "B3VZRzc3VJ37IBbfpyVYuywcgW1zGHY6Xk/VFrBJFOg=", "LenuZSnlq8eu6Tt5TE7v3VF8T+EvpWvOBqNwjYYza74=", "ErWRt681/9mXs6YTaH5EkiViXdXRAc7y1vKvAtnb1tc=", "L5+I/pvjZFfopUZFWqAKD1EAp/MlgLePJqd70LdhIYE=", "CXFOcX2qPOs+l5TSSrzRcoMcuhgGbEwEiwmV6ebfHew="], ["A63Sn+OY7S1E8jMSXs0VCePO3nfmvgi5SvT+yH6z5I4=", "Erv7sRDsKXEAfdrF+ONvZVRl0F8kYplrIRTvrKxwr7U=", "G40gnWayway6ukNeMEriBmLTNtEDML6zNVz4AfGUcz8=", "Cp1+5+6RZ3r/08pPxnRiW+iX33n4LsQ46A8eAAyLH3A=", "C26yJU7frh11A8NRjmTPGfNEPWzQO3HPvxvlk22k4EY=", "AamrP8IFmwz/fjzEMffbRfWdj39yTNEKA/MaNmOPi1I=", "Aj+6I6tLwk1IgLpab/1utQUN+40PVkdtOjApDto3KsQ=", "CyZwD9TpUMJa14/ttj/LDZunPsq4WMBxZkhmqQlvFNU=", "BKVyuGEF26UlPX7R5201oSbmcYVRuXayCPWT8IFY3qk=", "G8vmftX7dSKt6v0dmhUPjVetohjbNGkVyG5sAMAOOLg=", "Lqa3pyZcUD/LKEwrsZUS2uce81cSXDrHVca8bMN722Y=", "MFRO2pwyLGyHJnHWZ/xfzwnPuNNOjlgStuc456tA2O8=", "IGcz4yemS3jTxItvdYDQiHwXeDQ7Z3aIWeJTLX0cRqc=", "FNrJBZyeeNlsfvgHujQrlGhwZ5eCIx0q8Pbkq3bL0QE="], ["Ehr2H03FuySJCr65JR5c6pR3CrBi3Awou4mV3Y8YNjU=", "Ly7FHEj4tzxRsmSnDSugtGvbQ/kz3g+uqKfaKpfLQfM=", "EXOM7TkzxLJ94TkR23HM1Yt7MTRO2RU9vd3bkfvbzqs=", "CRdbH6+s3A5itflebKZ8P/yWom43z8c0eVuS8eRhJNQ=", "IQpKgObqp5n3zgV1K72k1P8FIHQslD4e/usSqRIppa8=", "Gbr9DXlCuDnzatPXDZyHtVZ0ub3uAqfcMOT5nrzB2U8=", "JrjqsN0NlbeoQ54P99NDinOie1mT2B/OznKagko1IbE=", "FzmF/hfzsPuF3mEEwCtGw9ee7p3Ci1Z/AqsaHA3exXY=", "HZSOh3SxgPpeGjkyQ53+jF8ypDdlfSEnfkJhS0yaPcM=", "G2GgPiGDYiBP0gtnU25ebKe5bbtT1T7RYCMCmIYUh28=", "E4C+rHsGLGuJkUqXao0LnTJ2oTyCwj+iH0+kQD4yZ80=", "IRDBBe+0gbZ5zrLxEtbqcERCdjrirGXt+PFc/RacVg0=", "wnLRCvLveKmN/3SGxJ11Be3YjJIuVnKjq7FcxJ9BNA==", "Ep3Wd8H4qi020qfVNAZF36w0pkrkVvkbl96fjpExNhU="], ["LKj/7i1Y8pRSl7AM0LUR2hZwgNU5SbPx/OrKlha2FD0=", "JuNlRNC1lS3eQAfRGBhGW96RxNzmWrwBXnVWuli5X/o=", "HpfOATr6punJk+nP3JquyRsGeHgZgwmFpy6ffG5Rarc=", "MBawdMgUIl4tXBCRqDA+7kvkdrFFitVMFrThaR9rRyQ=", "HBss8R8NOjoSG+fQ3fsk3HH1S5vvlDruMpY5ZpIqg5k=", "xHSCSv0qiAxqhae3paQ0rEIsemOq+N3HxNkyXt70Dg==", "GXdex4H9QImFn2t/EnyR64Put+yereFGd7CmsQuebiQ=", "IKmmKEz8Q4F5XjsGg36VloFf1bbxYr3gL5fbaHyEef0=", "IEQapfTVY45k162ZgrG/z94Vj2o81q9ilB4FzI5TMVE=", "LT0mnuMk58Q8EaqEzRW61lRE74Np3xV0moprLIEh4rk=", "GlcY9Kkt2NF5uTKwgg9lx7uT6rzjmPmXMk+YrHYyO5I=", "CP1Dl6qLOoTdG6Ti0Ot8bRxe2h92SBS1/+IEyOxzVgY=", "GjJ/8sRvWWn8rLRjUG4QLWglAjgfw/mZuf+9RSC6RpU=", "EIec6rw60EXXb2zVsmtW3Ee1EtZQlFj5/96Np55mSc0="], ["LJnvXgZBR9qXgrkUopS2wU0h6n7sH3LodhZxBp2CoTQ=", "Imv5S4axd8/n8DED1Z4/nOI5OCGVRwjnxyP4EEpoxmQ=", "Bmq4vq2ue+vSajOtvWuzktaCXaN6Z56K+a6LxIE8MWg=", "DAmYYVReATpofN1Jo6KWqNLC6ZaRwlNdpxLTUdXmPBA=", "FXTJ5cqqimp/tIlNLEXRkB0cQrMhT+mnL9PMZo45n3Y=", "A6ZakdNbbod5CNXEGeeFD2RfYrHJE3ZaIUuw96KRW0k=", "DAc+rdtdP3nlv4O6wA83cAvWRQLYv31aCZ+z7/fTsD8=", "IXqkALK2Jbw2QypUXlMxJPmcHLmOuF33RzGehdUwRwo=", "F4pY/xItFozU/xGkcoCkuOXNsxNBG29umpR8f7V3pR8=", "DqRdIkee9Xc+WLD+dAho/B6LUL/3YEnVtu1ecjcRhns=", "HHy/JEjecRTu1wGwQYCQNOB7lGoDQLd3JoUp1YLCJao=", "JIffnV4Ga3b/yy8MoZCr9fweWHLEtqNqRocOkVkgEBA=", "LAy75GQikXFSyhkGRivLWhPvU2MiqHFSN9oJuMWUysU=", "D3w/PMls7aA55DyGwbaAx31vSfUOlN4j5NtC+OnK99M="], ["DX0HzTeY9E2DKmVxwhcGdYaT5ek2hM4tGl6KU+DMZwk=", "JeMRs3zuaTVF4sLvwgQ7wHNVIRWzoGXO8T02VHtrncU=", "IbN75SGDXDK2c6Mdca7RvH8+qW/h1MI/FGI6CoUaPNg=", "C3Gga7dbChC/0oo3iL9UqKFEsyh9+cWRomQ8QQD+OI8=", "Ju1f/wbvnhlCvT0NO6aEjkfsBFzSb5MEnYDL+mvMc7A=", "E3kIuqwuNeE/hoNKv+mNG1S3wl1shfxsBex83tkXVRc=", "FDmR6DhtYjNMoNh4MqCEW0hBbvUVjBjnuduM1q7iI6o=", "FI3JM19iH/+cjS+nKpz1tv66vh9c53aJwaKeOTGF+6M=", "JW4UU3jSYE24xQndpFUkUrbEqJH6xdoZnHVgdo2UiDY=", "IoAlDiEr4qSNKTeWqIrGKwVBEBL0amb4egIgo9/z950=", "CcieBsrVQwFT3VLMZq5PUhv0FF3wSGgb6y4Go4UFARc=", "Cq1owg+t4ePiv3D870tVC6ANY5niDYNAL+CbUt3N9Sc=", "JfQQNSHjbVXkGBYu+Ov+xtRWlVIO9HuFSLo4tSon+/U=", "EL14JPwbiDs9oActLGGUxKHllXFWWU6Qitv25rGRK5s="], ["KRlRFxBmI///sK9SXIOGhtDZcln8c6UZRgmse3sXExM=", "DyM24O7kaFdByiOCjDTCTwc0kfDnLBOWEFJKVvcapAU=", "HobsCGgFvHcSt1EN72USSbodSRB2JB2Z0AxpKIDzmnU=", "FJN4ecTHEnZEx2W2Ni+LmM/TL4Vy16rZzDKb7VtQemk=", "BZ3oc8WYBvVRFLw/gwn5tkz8unQ0quIgRH6g6cSmbaI=", "FmLybPBPW5ac3WuT6JDvK1sRJPUYIoiNwhZ7vs98Mec=", "BfuJfXHt2NjrHztcgjpYgqBtlkBWr9Uy5siIk6JfJhU=", "Ds+sqtDBR+Czx+BJdx5tQHKwLuTRccDlMiQhTRet41E=", "JfZNQqdQlxr8uAIwcPbsl7sjYrGWparir2pw8uezV68=", "IL5wP4bXwLna2Y/4u5/JL+isCoTGiXp12FEUb3SEC3E=", "KW86nBBCImkqRK0k8Pb9gZACfgdVVn6acAnsce9EDqA=", "BjAWebbNsXqmwhLONC7PaBq3zZa/C/uTNQNoAE2Xw1M=", "eUDrBLYexTQcFwLwOZP67RZ9tvos6pIpDNghsV/kwg==", "CQ2hLhWVVR0lAPkDELdwHfl2dkBBE8M+R1sud0mtthM="], ["AbYtSxfeZzdbWPJIqI2/cHzJ0UkbzgCVZEygIZoB5Ao=", "DZu32rShiaO2mQpVJsgrCuULp91Vj5Ubuf00PLtLDhk=", "B10aps0rjRgcng9CJ1yYhK5voJGG/iJ+XEZz5W46zSg=", "KPngBY688VkbwAfLAqw6zeCFFCfbIMc1jb75+pxXwro=", "AX45zLo0MqE1wAddcgxklWLuTTG22i6ckL1yoDl2XnM=", "DNCkwn3hGutkYOMvoryyicuDMhcjFVMEkp6wyk7qA8k=", "J0WgWdCWLxvw3eHhuX4Lv0xBQ9EP0/3rjSspXuTXqd0=", "E2WpBMf2chAC284XB3qJqSu4A4vSevUzM/RHxM8DWoA=", "AvgSEh4urMx9Ub8mY5jVuo9gGiqm0zXrafeGRkIXdmc=", "IfjYVAkd22AdqxsB+zDD1Pd8wxZ/ozMsOzI3egfmqsg=", "AYOTUF6mIwZpqAMPbnYTChTBBwqQG6W2QLiK6A19MLU=", "HhUf7f6hFlnBiaMbon8sz2lWCEGI6yxMmbgn9kXx22E=", "KuHsnglXfILJe0sJFCrOUaqtHffcNSzU5YE9jO6cmNs=", "JM6wdm3iX8IniShqCSh750AxDEF0cyC98utclW4EA1Y="], ["LhaBvHwi0kxDP4HdOjJv0CQr/H4r3rYwfk0qyjKt2h0=", "KkpsyITP0Ir0sNvom22ODlgRMget7Yy6stB1BT7+mYw=", "FCqDIGdHIA/bAnc+dm9QTGWvgrIAwOf9lC+SviPVhr4=", "DfZTUk//kt3o7ByaUcG+wwvzak8B6bO2LrE/j/33uL8=", "KufxQU8UQ3NTGBY+G/seG89cJx839qvxqoZ2ay5Z4Ek=", "IDC3vCpwkF0DFnTvtCAzb6uwdprAElw13+L/NywapOs=", "EqcQ3m0X+Rr4kBAiJoU7tkIJ8bQTMaHRcwW/W3tSFy0=", "H7pxO5h0IxHfs/o1b/g+7yNM6L8rDUpS3nr00lGfLxI=", "yPhyKJKi8GxatFTkB71Vfpwup374B+4OPYnGeFsNMw==", "Db0JPcFuc4Mr3mLQXLsG+CcfpHIpRwRi2MGM+KEk+es=", "HcowYKa7xMMk9++6IidP2NHyVgpO66jIsNOJl+DZxGs=", "KRvZQB3iCRa5ACoAZhFLO/rk08gwirpK/czfCuwS1mo=", "HJf8d1+WL+Bae2Y0a5PDJgyPapCn9cYyI6M4bhmFLq0=", "HH3OzqWeb3vrbXAuL+dFiEFdMOXcCZcLstVqzI4IMo8="], ["ZYUNEdDsqHw2l7b15X94yoaVK60ckEfb0utr6enbMA==", "Hrl4GbNTHrtkDta0ITQzVBkQHR22DdGpJO+WZfepGvU=", "DuRoPI2lNra1B3Okabu94uQXoc+b4iFSCvHnVZaNf/Y=", "At/PsoCj03LbwVY56s5FwLrFYsROKS8UKbyRZXj7C/0=", "EuqSGs9bitxqTja+hXE1dtZYCZIwsLF2bGZvEtkqsUI=", "C1NCUDr0Ru+CTfTfagiBlftnJ2ZX1CDm8xKyYo6SKYY=", "CSZfsxSmdraz+CfwcoOh7U8wDo2Q+WeyD/YfRV0qsv4=", "CrkT9l4c6znti4O9XX/ZAOeFEe2rz+YjFN0Q1WeFjY4=", "BAfVhaan77VhN35fOXIxmj5yheFGxUme9shQSj0LYuM=", "L/W7vAItG3T+GEwGTljZZ/Gq0fCSbJBqXjVs/DuBrSQ=", "BtptiMIz4xgsX6XM2hOSwPiffGvsTmDajfgFSAfrCSI=", "qrJ+YnmVLHKR8DaRjwsnnTsdn45OisOA2nfsL8JOoA==", "J3N/zXbdKWwogXZG0wsRaMTQDh92TEVlyqMnbe/RXH4=", "EQpehN4JIJ6TY8A8IrU3rGp6q6L2qdGh9r+rcalgpYM="], ["Glmza5T51yNXflBNYAxJPygQ8OZxEmcsdDq7sTq/Q7g=", "ImuR41LGXeT87hEkRb/yDkpnrw4RCVcxmyhg1Qh0Brs=", "Fo53Hp+PhgxJNn75GaANTxKLqwHBPX3XLOjTa8bR2DU=", "CzRYkLM8I9FnOWxYPRLk89nvyQTyYSAlEjUBkKsZYcU=", "GBXUwuahj08/pTigBBRtf1QPvoCkYFhXcU+6J5VhXfk=", "KCpVX5rU+1dpj6ofwyebuMKMH43IxpMiW9hSDbQxNIk=", "FIqxWXKmkltxRgJxD+nmTAoBUFOsuDjQ6HakbLVlP1k=", "COE8LmHERrUwJNIRarF2yENgDQDmdkAsRkF0UVjCQ/g=", "EcuD4B/1gDsEmitZrpkVs+AEXh22lKbfnenE5xUtGR0=", "EZgWhiyCJunl36vzFns7K/f7PRkGOYmyShbZfJS9U9c=", "DGHsebEG6dxklKY1nxdf9jeDnKU6yOehNHHFZkYYA5A=", "Ho7mQTCLpv5WALLfSSzy8U+YkroQJYJsU8d663vNsEs=", "FrYbJC1B4ZdYQzCaAaNqFDl9fI5760r72SM7RTqszbo=", "E4ItzD9icbcVScLNkXuFnNrDavaEiATRWjVNTeD2fvk="], ["GksYa3fNU/lhyMy3gV2Xgc73pSr2TQv3RstSJRLT0K8=", "CsW4YSjuR5RMEq9THPFFgELDWt/NnltqdTGXNxRVnec=", "DCpDkGcSFEnB7z26a+H/hParf6xLvVStdTnmGCbKGXE=", "BPfx+v7hIbuBE0T3P1T0o1gwdnOd2d/EYrOuY0PJPLA=", "GPbEDjzPiFgEs3RDOvCpYrKWP7mqAei66MyDSz4Xox0=", "F0waEJXpXU8JjI1ggmd2wvc2kds37DuTeDW2WwG6E9Y=", "H3+XBMqxz+orJHHVee+Z0ZOyNK+Q5iygm1pnHCQopRU=", "AfoCYWAkzZvt9kPqNtJi0bJPOKVXp3qCxoZhjDwz7fk=", "LhwpLga3+KbkNE8QVAZ1pjyknkUvaVZfz7zUO6wPOvQ=", "BvvO1SV2qRPmzcXFyW/cj59Okx+pC+60bZs8LXdeHjY=", "LOxn5iMgvGoMoyUY7IHHQ2OkttJZvSdaY0JdbO3kaNg=", "J24mI4KJSeai/ckX4u1F3ODuUDza/8mt2BX20dPE+dU=", "DHW6YPjg9q+hJudXA7g9mQgRYUe4sttF7yTzFWuPGFU=", "CF44CQXrLLfnU9CrD/SRiyMsc0QYtr/hMx3kkvx2shw="]], [["BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "ETrYtGw+7CDJlltaey6KUVKYcdBAG03m9j3p5SEWI+I=", "H8UKFtvfocO5kDj0f4GhxdHvbnsiHUzMpughIgEw4AA=", "EhSp1tcoj+hWUajLgwSMdmnIO17YLKJkL/8B6FKkS0o=", "DUIafCWvVTh4j0lHWDZxKvXaFW+IxYZ1aM2VjjBQJsw=", "Lei6g9K2q2pxH7kjCt7hy6Rt6MkwyG0masuMHLloTiQ=", "Dqe+gvHLSTsbvYOrfKKFvwoVWeoFw/WYJ7OwE9CpH7I=", "Hjrn5XddNSZR1xPr386/nKjpBc+3kr94dCOUUPkUyMU=", "BZQ+NhijLPBQAYpOI3X00Ce4wUrIKg3lfLuQxRIqZLQ=", "BgN1UYD2bpghXWHlNGsRbMAM/QWCdNfZabOvleeLszU=", "GYF9tm/bghXs9wR2xARMP0HXisWlScaE41hFlH3KCxE=", "Bzll96m6jLM6lV1C2lX9fDej8CJrAp023LP76pXWQvM=", "CaVQQxQwhGtmlBJbVkKwBgfzahopSFNho89Cfad+zNA=", "Bo606dbgpYi2GmrVAfOA2g8AkGdmbAhT0VbjPVnENRU=", "Il4AoNpaf3SWtw0JI6fPf/Myv/BpWMwPP61DmHT2Ak0="], ["Gakqxgh6uJmC/lZQ5eeZ+RAD/YtFQAdI0sJeQPBMV40=", "B5MM1SVvird6uSsIu7WxlaRKI4LGbidRRhnvuU5kkRA=", "LY09kk8olxmeOOr7x+EB0X1+VjSIqfMZgGB5auhMGwg=", "HA3iv+r84WTJg4BnqN9jQPnZft8BIjMxWbcU9Fw/E7E=", "IOSigwPdVeXO4zLzDuuvvXky57NTHZQkVMNEuLjBfN4=", "G7Fe5NSSqOLPGxDbG3OMZ4AGbqg0er5TY1enI/bPV74=", "LM8xpXJBK7fZz6Y3cHhTIX59tVULHMMKiUzfSDo7Y+M=", "AdSSw0skW8EpQbsWPFEYv8+FvE80QEKyAx7YZiofb/o=", "HJtcLAf8z9ncazq/4FZ1/Jl+t7jL2Ni0y35nFhWw7M4=", "AkOTC6Ad/TlF8qoC1YiSK0fBvvL/gCOoSbTKZqG/6Ys=", "CPMo5eZsC4ebNsIz9Zi9hXjRji2p8BnwQRcxUk9C2Qs=", "KEovCD7jKmZjCByABxPg8jleNI3OzIn8gap1pdsroSs=", "GXcug4FvwsSblkJ8atBXM0f6SaXfaRJSWSrrw5AFWjU=", "LcWQADnUyFI6w3mUXLm1ilTgHbrNZ/DEuu6F01PT/pc=", "DMN4tE5Y9mi0WDL9q0pJNycx7yQVw39Atd7VWUrvPMo="], ["MCYI11DxZJHfWihfX39qXOa1VPXazwtp1FCyS7tJZ9c=", "KPgUS9rhuQTq1ws7cseUMDfea0hJDv0xd3g1lO3Si58=", "Kqmq5izbhSSQxlD/nifJsz1M1AIMpm9eGms3TmYpNbw=", "HjlNgAZ/DhC6qV3g2ZtOOSBKGHJ9FAG0duyXa18XOoI=", "IL0CjJWNV7eeNSGP405Gnr2qjo5xTpGNWBkfZQRrlyo=", "J/ohIEMTecvYYgX/EU803S284T4cKgqORqHcJ+e2hv0=", "BWRlG8EXkXDjyXr7xPSTYXAXtDshPu7Ya5sb/+Uh/oY=", "BzM8vQ/xPIreH+vnKJLZrUNce0UapyqMBacII5WIKGU=", "KQp65zL0dU4MuRkjySSJcZMmB74ugpFj8RYS/4qVWxA=", "HrUg/qxi5FRfT+fNtnXjZHS4sf0Z4V18c6Kx37sj/tc=", "JZoqHwRoRHJM+ZKu3CY19mgPVeig/axpXs0F+8LLvRk=", "CPeObcWc1GlMQau8oIZWmpCDyozIAL2RNOTUjtnYncM=", "LY7Gra06ZGhDyIzaAShfjzLSnGsQJctUIUIr+L26f84=", "G3KsQ3TpW3t9KM0pCVB/MAboNS1K8Z5HsLkJaCoDIA4=", "DX2Cc94je6LU1egFHFvV4xLSmLZyb/vTr35zKvkd/yc="], ["Gjx9qmtK9WYtDYQHsodnTYPq5bdWNAX0je9JmByYxCQ=", "JHT1Q9Hy8zte8/uxkGURNaWTkMijZh+uLfHT8UQytgg=", "GEimDvyJllBzuVdz9GdmZofjjVm+II6Dd9MZA5IQV+Q=", "LKLYsKeT2Q7TGM219pcZMTcVW8+5Qtgr71WL5fqzWb0=", "Bu2YoYW7I1jzNOsleuXjGDWZwFTBtOICJWm4No2hq8g=", "GrUnYUo3wv+wDA+tNgq6pEesEGP7n8ZW0BSM3OLXw3I=", "C8dpzXs0/NG0VKv/DAC4m1QKYZuHyVREZ5w6xr6E1FA=", "Ka1SNv+7WYovjSOHA2CNt6SXp0U++dV5+/Bb44+PdvE=", "FDTs4gnUkSgMWuBdfibPktmbtyiaXBysCaOM5TtuA98=", "JV373zBVNBOh+PURPWDphYODjRPhHB7gKyWjh+oAzM8=", "Bn2SlLQHKxLDaMKBalO7Frfn4qeZeaQW8tAq+GKr7fs=", "KTyooGxfF52TgGXqR/gPZf8hlpqUKeQAqhd+z2tq6FM=", "JVuWJY3I4WRPG8rs7nc2MvJabqgDzTKh4B+CVzd19vw=", "HyqNyv55/Q6iK7FWPDsosjxcTXWR1F4GdEs7N51CZhg=", "IuvgoxXge+SwkoiF9SRJsBGzln5RnkOMQkzAQow1cm8="], ["LbHJhVrCmsxnk2fb9w8I2YiUB33yQR+R72jdkBd8Hps=", "IXFahHQsAtBXrEH3Q7Fm2gIyKEJWgZUO36/4WBIBoJc=", "DIk4CBA1SdIDDL/gAE6mZV4k7nGh+MHwctXPbheuJJk=", "KEJ6sAemjHqxI3HxO9fboKz36X6m5krlLVIZIQ/oorA=", "BR3rSyNIkOMfWsjmmh5TJFN3Suk6npNg/gCe03eunDY=", "FwzuKYP6PT7O8vgG9A7tjY4TXO/wdvxTC7/uh2yefx4=", "JEtrY/gEGll19GQLGMfQZ+SgYn8YdR3JBgFriJPDUSM=", "LnKxsRTf7n6NfwFhJVxolfp4YHDOYtgGxFoi19mKCjA=", "Io5zmbDgWAKFK91dXgmWbwPEw6/1PGg+svaeD8whwLs=", "GEURMlgbmt+ZbGyuFbktLkwJ/cfWwntEJvMrXmagtyM=", "Dh1+wqVLEbNuZddVHpqHWojMx6bARw58JuGZZwoIWbI=", "Apto5lLerIGIJNoMKhG0CNeoOaLoV2xVv6XxM1/8W5M=", "GG4TYAQRk+EvOAmbDjXnZ6/8NBD2qN/Om8dVZ+ObxAI=", "GSlN0i2mc0cDd9Zx+r30LOzTfsvAGDhqQ4cG1hBrBKg=", "Au088CFPRE1DZlXgOviu4rTZaWHuoG6BM71ujT44I08="], ["DwbuR1WPGC2BC7yyFKJdp/cKVnoEZLNI4bMOyn3pnSc=", "HvDgwfC19nZExIb+zwIjjLf0+mOggqPAMNrdzmWkuCo=", "CtgHGMbp0cZ7Sje54QPbMvIl/kKpumVf8GVhi4e4Kuo=", "LP/DeNLOx2unCAs3/GcaljKLzfxGMPzC8hM9zynHDdE=", "IfH2pjBHHjKouaxLftSwTFa5anHuIKZqVFjGuNXG00Y=", "KIhRdw8aE4IiUdqRyE4SNZP64cnLzmxP8jF+cLtlggk=", "L/TuEQ7hvmLicV3NEZyVuVQTN26I7D3cPwb8nbjCepQ=", "KtNpqEtX90VboxBkABynd50rS5awtKkfFWq+w2aqt4Y=", "JPD6FU/MbWRZ1sVvcR8l441X6QvnuARsngAYFe20FAQ=", "ByIcrTnZtfjbcFqHIwOLkra6+HKEExc16vvs1TPdptE=", "Fzs7NJ7oiNk0runBToic19eF0ePk8etypcLlbEj9VMk=", "Cbw+QL/l9hb71SDziUoP3Tf+spQp/TpQFZUxcd46cPk=", "Kcsx4a/vTyUleKq9dvI6EyCqyQ1KCmbCIl49lMxI0i8=", "GTK8a7SItzbg1L8wbUHmIuZsHWhapFmBUwVLQPdcCwA=", "DLb6Cl4RuRkqUZBJOdRaBa+AVb3qPzefqsKdEwmDDoU="], ["IWbXjZSNr6ljOBzxVg0AvzoKHCiKdDNEyGQ6WNr4y7M=", "J46NrIxWsooj26TZD7qR65R/UJLUp6nseAL2F3hIjoc=", "Ag2HR28SQ/SQJG+Ic27l/W0zGR8FYScUh+lpP8/Xpkk=", "z8qh19OC4f4fy5UOFN8gKgh5PXGFJVsCXVYuuNl1RA==", "DDnb325tJKkaCkX5IsiUviUrqhJ9msdpCfhtwLzGimY=", "F5U4TpG6+lVN7fUVbNeZ4RIQ/9Kv6Be1xjrVuF5/3QY=", "JmbsGmfap76wV6oObooQOWYBohiENyNpwBK0mq+EkEk=", "FXk/McrqOd4xXcW/WjZirV2OGhL6GnKA8u+q2vqXrfQ=", "GIAL2heomDL+pU8mdB2Gxrb7nhWwLnvQZVM8tWYdKpU=", "FW9qCeaoHY7s9NvyFka7loskBnhs0d7dTMcyt1Mvf+A=", "KXdlihDebnkhq540vPB7vKYaclSa5X0MFWkb0UPU0t4=", "KEGBCT5DQZeJJjc25USBcRH9y1WaQ3c/BRhmCKzFQuQ=", "IA+iDtG4cTE5AMAfi2l3YNAw2MwBUP3FjgSg2KKzRLE=", "CNHWi4Q3vJgKp8Wdgzk7FioIJ950Bw0tNLTq7cF+fmA=", "A5WYoUQ8AJZ4YCuN00dPJ22l1iQlCD7GKKFzfozKPnw="], ["KSm+m/4/k800/OrmZdlrHeGvsmvK7qL07cRUxQy8RAE=", "D68zhD5nM0N+mJleb3v6b+76c9dBDYWFkYw0fzz+kqU=", "E0uGZC/yAjiPT+NzVspPDsOAVWa31NQS2JN6NZ75tAE=", "HYckxeZB2W9uNydxsKd2u3Qv08COGuJQQyJGzTvQG94=", "MFYUqs39QWfNG/3Y/N7OaJLYTUpl6G5vfGNJ+3Xki5Y=", "LNomRzz9zRhbooz9qhXn3iNZZGoCh+votg1wLfAJAQw=", "KwZmlx/ZEVKecO+RjQGfRLXJ13RCttGGb252gy1HiEc=", "BWxV31Q6jUBDoS9AnNLEvPQ6dw8+OMP8ea0hS0Lag0w=", "FrEfJFAqpMw7DCVioYokq4+YZDGyRANNP8KVVUArX0o=", "GOoO3pAQx78PrDYbW45/l8de2ToTp61KAX2SDAPJhoY=", "A5YJdzPeWh+kpUh0m3P/fEJvmNnlrRaSBhTTN4l/ax8=", "C51aOpV+7yUa6cJuU0I/m+by78JLsYdWiTqdgOVqCCU=", "GmOlidFxCqcFE2y1IMLxxE13jkkMIS1LcunxU45VVc8=", "HANDgWuM7LpIUZtZsPttSputMJ7jgxHcPoz+i611378=", "GvVuZXUSP5nF16t7g3cPD9YPufQDjClCZEBp48JDeT0="], ["EHbUOcZ5l8N8bB/amjfcL3Yt1XeUbzb8/czXiY7GfNQ=", "K6Q31q5sWIxrcVBsi1CDR+Y0tlzuMXrx+7nMKpl/wAY=", "LASHi0y4FW6Zg9EVdO2Z3HVi0/uxh4JXq7xohS/dJoA=", "D+6PlzE5eXQQCDRknuh6J6ySvno4EDA0YBQar7VCpCk=", "DvmuZeuSJgXUJgqyAh37tHdM1f+u3Bt53GgSCL5vhcU=", "J6tLQJAUZe9ZAHEU7PH7+rYVfCT0AiRrhqYDlyZzCPM=", "K7W/A875M+Tuh/UR3jmFz/AyOre3GNTLyj9Cmt2/MFI=", "HuEOKMYS2dbucvEnSFDD6Cm+XAb1uykygBUqVhDrAeM=", "AgqdV1/qiRMCsQZDmrA6ipUdiy7ytWKZGUbrJUHx+60=", "C3MRnJjSXrbeFCRrFAG+9IXJ3GrM7cI0lLlSajnVMiE=", "Kmbe/PSJwj7sUHmg7OHFNBAnpZ58WS52AYS4JtcNupw=", "BKqOkdww+coxj+JHGP5ZWHH3iX6S1X8th9SxvPmmNeE=", "EzNps7zHPueT6Gk2DNUNjfYP45jtnZwNDQPmafeW6H8=", "BwnquWzGJV8q6ReRTyUIUCVJDEIyhJFuI7YIY4zM4pw=", "Do2cBwfcW/gKLwjDQ8acxlne+GYwrzFBoAOss9PpDAg="], ["GFya0NqHz4JGJNAr7DukZlgioPazsl3v86/MaHzhMh0=", "JKbBkZ+Uq6nbmKWvOP6qU5HNp5+d6/rxGGcNeSfkHbA=", "F4OkUhWAWt6dNZIyEgsYPbVLQ/mn6PuNzZW6m7q7ulk=", "EW8jmr6CBze14egrKs46Rc76xImmv/CE4yMDb1QncQg=", "GtzLiY5f4YtcKaRwjEsRK1bQ+l0pm17cB9b1vABCi4s=", "JxIngd97sF9q6eFOjpnaXCPcd8wGEIwOuwYeXRvpNiY=", "LjenRA51tkmgeZz/63+drjj638fKtsVYXkqE9DdynQI=", "KfNW3Ow7eVI8BYmnBG7wdYSGgoshIUbD9c6YevP9cZ4=", "D5wF9gmtFN6+r/EHuVrM1g5iZiJZkFEFq/r6no4I6uo=", "HGaChVLKwUQzNO1wt/1/tSX5B6tkR50ReGTJLpEZhsY=", "EPQzaMBWf0Bapqr882fj5ovv+VfEsMuhfDDGKz+VSQw=", "JToRxmRjptyv2Dmfyli6J/67wwfYgzxmbg2N8HLF9p8=", "HplRbCQNQryqrZxz8hpGGT24QzNJIDA17qMDmPnfeJM=", "DGegazPPc4grHHFS1FhbeCI9hcd83cLH01lIJMUBZWU=", "H23Y6F01l7ttN7R6HwYxIgFMiIJQs4z46C4+VHHvhKk="], ["JwKxvjnpEET7c5JsEQRxn0wDeqQVGCPOqyTwzsSfRkg=", "BNgOfvfieisTl2eKxCq8xuJmLIgFA+RkP9+6zmcnO5I=", "D8ljAuhmLeI8xcjCKKyKwtzb/EiKWfTdQePycJX34ZU=", "KjHK25GNeLltzVSLOUQlpC4qp6KKa2PlCSYb+ub6JbM=", "GKJmHAOrmw2PfQEJHH5WPvwDMZZ0fjQTnT9cx6wAHpo=", "JoEqzQPbNBLK1Luhrvcb1EsAlNMYrOA2bHnnKf8OsuY=", "A3Hw1JNG3y2IufGtqKyZ3YElz6bDDzc4+5kyqFMmjg==", "J86pxD/gvxzp5TwMAm6DnYCn2GkTZgMQLN32PN8ouXU=", "CV8dtDyCfm8LnNT+kp57jHjJP9AuyeDxCZL+t1O0ygc=", "EKZiaN2aLzaOlVB+/CCF7u7ozpd8oe/1suPZS8NC/1g=", "JaKkPuYSZj29YYFPLesG7QBadBT5mCX4vmb1Qvlaey8=", "Dk/UmHeMLHagLQ2R2PiYJYVucG9Zgzff6788ozOXlo8=", "E9hMp/NYqv+x7o666Bwy4BrcAekNCclFGvNuMa+CFw4=", "B0DB6bjtFun64gQ2nFVM+3IAfcz9JTDy401UQAOuWZQ=", "DMj5C6to5t6EhF2hiZv8UkQL3duUCyCDAa6UqVd3y3I="], ["CvcaUc1GO5+u2pOAPNwDGGx3gYRSUv304BVXCdk903U=", "F/ajrtsABamwoljjG45uKkjz+VUc72gSpJB1rruHhfU=", "JLIuXOZxznnf+N4W180r1jddfsqgFuz1nP6yRtrIByA=", "JAyvbXqy97arPRXvzzB09bIUKh6ATyUBLZiEVICeCWw=", "D4rux0FE0Ao8o4v/ELsPOo2/9K9hl4R9uHl0WutXteo=", "IT0p1OG2wB/A0QnqYWlJAHbRMdjgNLMED3vZw8Nz6hc=", "DQMntZMELeBPWOD/kzhtFgjTOoaHLB0+fgiRIKrHpP8=", "C9wHix7dnLH9LCoBqXvffUWGSEOfrB8oUJtBotyed0A=", "JrwA2c0lEkRCgy2Xq9kIZtP6ekAb84vZX6etUmVI/qI=", "HxSqtaWa1FLPaSsSPGWHPdgP/BiHmKRXDsp5Kz8vJX4=", "GC8ck8brKYZ7FVnFggemrq9Atm6q9XnKa9fKQKrrer0=", "Em7IwgAmLEXREzv52l8eX9YrzqHkk6CArxvSg6uG8SI=", "BaeEZKS2u8pultg5gnv926qdkkhArvZVXeZD3xZ9TKo=", "AqhMQk61j5w4tDgK844EWEaJgJiPqh8NTG5yOEVnhSM=", "DA3PKxNVLsVclxZr40fKL5OwfioQFkCW01P6KAx5aCE="], ["KGZ/nHMyBz4pPIC5jt/64Br09ntMUqtF5J24sw8YLSg=", "HmICkSlJLIvfhRSUWVBoE2FZGp9e7cJEnl8inIW7l9s=", "BSwz/OCNSjn9gFFWyK/7hDSUKLpJIM/S55At3PmwVX8=", "IiTIXwwLQJMBTbHoF9H/FpGPFeDNIxuEikjPgzJMQUQ=", "H1NRSpfotXIE5XvWsbHZVV87UDaBVBVOZ8ITT9MVFZE=", "ITL3GsiYksmEoKc2U/LUUiKto0GBqebbzqDWOWH5NPM=", "BNvEyN5wjlmqSyEW5TlEvsl+1CMJtKGEVh2PMtKR+cE=", "JWWhemvFboewtjZkMZuKR79mLB9J4uySUb5P3zPZD08=", "Fz6AWWdWzZruBL1t2dwV5Ljrv+/jdx2YGb1NREcm950=", "AdNGVbV3biRwFiGstBMkystQFl4Bm/8eZfmDBPfYIqY=", "BC7qYW2QUCUUekgutDajt1U1yYabdtbNrOEY4VyR+3c=", "DPAwsQobQpHlduurs5xYP+oPpt7PqYz/epbcBst32lE=", "Jg7xOsfoD9LbPenrlC7e7z9eJS1MBFCLHhsTAZGtDfY=", "C8Nn/ZPOrLWZxhSqKAaHg6XSfuwfyPoXZQFbdt2C9c8=", "HxJhF6lJ3/kA+l0RGgziZhvZ1URFd8SRqZUc+1gZLQ=="], ["J2PDP1ste8OiMECvvNr5mLsTJUwnKl+GNaEmBqWcLlw=", "FrrndIZ2VuZPyV88JJ+AHxUP1+4o0ZW62erkN0OHUng=", "8NR1IlyZcCu6T9ASdhArXKv/e9TRR8Djze5MB6wxsQ==", "OaKIlRoDgeOq9ZjvEyhTtdaUcWwg24eSPwvPFMkUqA==", "J7zWOcR0gtLci20T2hn7jWPz1sh19v6khtpv8u4R4Qc=", "EhOVAjkx9rs+8otgY+t6LteDngg/25LB5Vk8g+3/X1M=", "KQ7ZrnR5+b4TrxP5i/iFB+b98BhxDkhZ/S5IzGb/myQ=", "FbCFtetnj4zt8hv7MOLWSuHL3XRyRJ7STmA0EBxliGg=", "EqZD9KMnrNJFRRTdRpVR42qw4/JOzDsop23B84IU/jg=", "FqHu276nnFQRpjnjvw6Q9uP3QPFBWZr45qQ6IGlXL5U=", "Bc5/WS3KIUjhmFVP1k24xHnynSPx8W2vPLiTDZRW5MU=", "EQKY/n8rz9rAvNw6/+60Ntezo3dFOud4+r03qayymac=", "FIKfCdS+675vwwVFBHJD+z2rmcYqq3Nkp6W0J0V6AsA=", "Ani1hQPguQFBBPjERr7Uxt5XXHLU3Z2z0YZoRpeaq5s=", "E49n+9nLke9SBtSMq7JprEK9NSzzceQzEbzK2JrMUJ4="], ["D4Go2OCHWOijKqgpJmbEy2uj9fBsTc9PxQL/l/A6haY=", "EPAXJ5m+I6j8PxVq37bFErpBXjUWe1Y797GG/RKkHlc=", "EYPpG3q3Ny8VfUxHdpHur/yeiGP7LYBlcMZ/SxhY/FQ=", "F2INQ4SZ9sCma7V3rdTK3WatOeM3fTAr+D07uhJrKso=", "Dp6DcxFK0lr5fSjicvxC2EkDc8q1ghk7h0oQQo7mzSE=", "H2Zboz2kq52YBsr/d87TnJviVPzExdqPVwCWER+xCbU=", "E1qjgzm9kn3VBk5NVy31WBGyJrq1SwrK7lEdYK7bAvo=", "IryWy+f4y8qBspun34SN1lmQNf9RW21IVVCELho1ocI=", "EeGwr39fyfBJh3FUrhc6GnLHvDuhkuQ4qdD6gf36SQA=", "FN5Ei+y6bKCtshsHRV0sKGTHuFOCJnAm4o8JeIItZaw=", "GESoHU+rV67btMRiji5H/LKSKIPqsLLh3hbySN5LuQI=", "Du8E8kriEO4KlLxWIVdHg+SdTZM2Wis90Gn6/UMFVFI=", "EyhGfIe6cwKJIaiTM7q5f4sk/Kpy9Dg3y8/l37epRf4=", "B5HYMul2tmvar/RQcx/zXZmFlauXSPaVu0XSwP7waTA=", "EUkrpAZDXzViOQb/Rd8Rw577Wf/wn1AfuJPXF+NPnWE="]], [["K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "ER0EwIP1Gm/fh0EqU39mAQdtYfQ1CU6haUbvv6SJPpc=", "ATPFkT8l/16qhg0DGPaktDSf0i8tU1MOXHhbcJiKOog=", "CIdfR9b1GMjC31Gnhr8iB6reKEBnIo9EDn0DB1IKVs8=", "C6n0ShB6gcsj+6ZvK8NBUnKPX1ymhAZkmn7+R8lHPyE=", "BUKDKrI7bHpLVHoQZgNxUqJELpmMU4G6l2mEExU7pvE=", "C6H3ZDZzYJUpQsy27fBRyPk3kGqBZkHg0eni7SaQb6g=", "LgYR+kyjmF17+vUS8hpAgRQfTtDcSwIoNNPLbP2Lf/w=", "Dm8jwO9vFZ3saDQah4MPuGS2wIy5VKFKJQCHZpeJf7c=", "AaeipKCNh+dfcgMCvq18ohyPfC7S3rrO2bixstpGHLw=", "HYAF30jIVlmH27RCtILK5b/BDuSG7MW2cM6GE0WXnR0=", "KBIiVII/iSast+mPVX55YoLl4ScWGIWOdtSdCIbaFvM=", "JBTUrvx7SFffaBMo5opYLSOy3P/Veajmru1sYQUOBc0=", "L3EMctbaGcfYfL/9VWZbRysCZdE+IyapozuW6V03RrY=", "LihUQdC+2Qu0HWSAg2hQ5NdtqCEbBKI228fDwwMgwA4=", "KWSQGitC6a6hplk2Yq654SB3oodDS9pOwgEuNqGdyVw="], ["BpsXed7D6t7T8H0MPmzs1s/+eNdH+u2tnJBmWqLZLLM=", "GHquJh7z7iGzcCNRigcWdcbQC96CvX9UQUSKu2Mqdks=", "FpU4CU1PdSUpRx4/3cnvmUz61PltzH1jbw/VCbjrnDE=", "CmiDDxnApymy+Jvic3PTl64RV79QfneZ1CIBZuoJgtc=", "AYrjkIbuu5jR/F8F+g+H3csUmwr+ONG7uFplaXiV5j8=", "BMXrx3E0TMBhJ2VxC/yxwuYJerw9NG8ElJX317fwbLE=", "Kfqn2tyLfpWI1KYB53vYCq3ycqG/7DxEPKPMrIHZ4eE=", "Ks80kwErvYGHJOfO2iQx6XyJM7+utddGO1Eubo6Pf8w=", "I7NGEufQUvazEsoODPcANK0jLZv2PIiCEIU4O29uxKM=", "EWgMxugLDkMKTNNgcBf6gzHYbE0DqW38GHZ8l8vgoZc=", "H6dy695vNzJERiPWf+mREWKY+PMKLRAQyK5hMqPWkH8=", "LmPxdAMy9X6DF/JZLr2NsIEnFNZgQTLVJeM+GbPJhJQ=", "EgLjSdHXuAWEbpCDTvyRHraxDCoJ6uqintKIvXebFPE=", "Fo/cMtSqjckDStSk+v7onw7VyYDT20JNOPjOXNBMI3w=", "C5rp9e5q1wplG0tm409SGxMNGMSUZNhv5dSxggSJAo8=", "BsIZSvcvrFjKE6Kl4yIxBO9JpUD9Lq6g1nqSDYVnBAo="], ["H6Tv/INJjRmqpZi3dx+IoFVN3dqJ0y3Pim9M93bRO5k=", "DaKO3n9j91WWolaLLdelhFduWygvKEeVsaeqIWY4IrE=", "GZg12pX26yLFkevlFMfyg/Z0/Poet4ff7leBpk8IJDk=", "KvVgYAs+JavMf3ik1uLNP9mby6B1q4K1XphBvve5IQ0=", "EBVE0TFFTyC1SbJKZeyE8bMiH9m0NGHdxtFWgzs0xSo=", "GlF0DNpeRepNS9e/XOVGamahGvtbyTzxDVMJ4H1BDk4=", "EyRVi4pdS6YbF3kBKL6fJEDACF3V1gZbiPCjslN72t0=", "E0cwJLpBn8KndD59+PyDdaqxUNN1OlQlCoCNZvLQa5E=", "E/FbxkU99vk4NEZVBTTcV67bEBOeMFPoO6/dmTVhdfA=", "ExS1T4eGCWJEUyyfBUs3ljbitYv9zrPUjfsiELUptOU=", "BWqOzSMqZ0xj17YD74zQYyHFYN8v0/bCZJr1dkZ/15g=", "mLdAl2wqEDHnUTLgUL84OLc50GFYJUPBx/lcFS7iYg==", "AkuW2+v6ttI/oywsjndYyyQLrNgUMyPFPNtI3Itl+OQ=", "FbvVYZ8NWXkIBPK5s34Gn8kJonltH3fQxiYJ3totAng=", "BHYAVL1dBxMlSL7XZX8XxhwDjrzf3UAlx7gC4IlI4Qg=", "ClSUybz6Bqpyw2/SLZj+ctwU3A5OdOA9F1XzisNAUK0="], ["AWdvXAdBerVMN+yK4agxS97rCZZHaYgVkgQ9/8smv0E=", "IEO/5S0pZOSjstpeMBB3Fsx2T5sci6Rj8hWrH38DSYs=", "Db2GYlEd1wAJkbOdoSn50DtWWgzS8hjW6ru0miXxBeU=", "EbM6nxgY7X9YHKwCAFHeJv4o3AvYyxpEV9WoRHvb1vw=", "Am8vWNY8pu9Zu5UgbOPtMSSIXsIXYrux2x1qd3HsZlA=", "LrbtVoN3tpatPLI3Bk7GjjkMJIhuHxItIdfPMpDcbQg=", "GPqvHJHgAvfbvRL0CL1cW5LzjgLONjWCSCHgNH+vU+w=", "KUN68bFPY3ofDjmVXyYEvyBDn8sqCQ40aqZanr5peI4=", "Dt+GvxsVmf4nxm80lIYtdd93ZAcKgmPPiHePcoeTjY4=", "EzayCOANjrrIMkapbr3eNRBj+j9jWIfnU6DOPinH7t0=", "JkY0HrRLSADVYITLSFAPrEj8UziR9VfpZ4TMYATYkos=", "BvU8ef7Z4JhI4RKgdC2K6EoEvZulqidlseXt+xYCFA8=", "KjyfVa+s7nNaG1FVJkJjhK0EQpH3aRl02cBcY0tDlH4=", "HhbpyiUC1pYCO840JyRK1lU86Gu8TDSaNLphBnxrbWo=", "AqTG0yWXecOW74Fzrl/oe9YR2+JdHASK2pYwbbHjpA0=", "JlyiERgLASw3jgGY8LX3dYwVXjZ1+t+SynkVa9Vv4zk="], ["H057vI1Cd55Yqge/VP8yS4FP5oe0yOuBubfnREjuJ/8=", "J7SKY2o5tRqTiuo+tVIJFVn7++ceCW1RjEDZCN0lcO4=", "DdDBGPFa4H5dtVB336RuCBCZVNmeGNcs0sr2E5IOOQs=", "BFxhf2BMGsn7jXbo04AyLlo7afp7fCriyOxZZtakx4g=", "Jbl0/FEp2CrkxiRuNfgC4DRA6tCZlYZTE8jKkcggwtE=", "GBWJsUDJEJ5JL8PsfYyo48JafOWN8G8T70NWHVjFkm4=", "DuEoiymFXi443SYpKzniYFKYQTRFONZJmZajLnzFI/M=", "IG5NRFMVt2QoDMZDuUefSZRuqG1zBLaixpKsNNfJjTQ=", "FkFkjCa1otwpfaqm1N22ovJYunOPkJTnxc2m76jJk7E=", "GIe+h/ejUkEEgu873PfvF5duCH64mQx21+lxxEwEgjk=", "Ix8smL2o1Iu0ptnJi7vBYCcjWiKh7U+IvI06blgiCfI=", "H86okobcHbYf4REWBq85bpjLU9q1GZdQql5dEVYfsUU=", "D3v8+rF9s0wUTO5EY2verfq0Smv0/I7zhOyJpK6e0gk=", "Ad0KVQJ0OqqfWDvQrTXeE62NX8mPGWHyYSrUwo/Z+fo=", "GVnbAfXIuwz0g0kDc+dbBFG4e0PlkYG+C2AWZ08/Xvs=", "IfZZ/tr2wmF/F9Y3zW9UoneC9OhDH4evXIWRkyzn2rc="], ["D2sYyY/In7+pmgTIyWrl2zXClkefSEtoDfkF1MvR36k=", "F/51o9EbS50qz3hW1t6ju6xireDFATR7FoZPPHPrt/k=", "B8khv0XjVISKYLDl8pK7A8JGlJi5weTTIvSv0YZ0CMk=", "DmGX/lAjKNDvf5uTA1UxKzRyBLh35/hdm1adw08GTBo=", "LUCb94vW9qTspzl9BlAj8LtnMiB5JdPOS+759iHaK6I=", "IFptWqstIktmjHD8tBWC7p6+H/CZKStLxQr4spLA6kI=", "I4CrBR0KxYCn0Rb0qTN+sxCQpMfsvU5jjncXt6Ur8QY=", "E4LDwkvySJ/p79gKFj5lARH12YheWKntcp3KH5p05Z8=", "KAxFIq0P/ZLDkelMcPhxILg0GJDDMprwUGJfK+UvOkE=", "H0BalIMxHhSXVo8b3NbVjNa8gTmCoOcVYbYgADuIggQ=", "HK/Ptikm+8BIV7C9fXOSuNit0WtcvvtUtNUxKCbomUI=", "ChLhYmIOcb7rIDvlZZRBawg+fpTuwj4PRKX/6eFZUIs=", "FyA8TS4aQooXviwn0cTFlg38aqNvIr3ei+VqDNROcas=", "DtLPrns29HCn0faUD5FOjs0yK/1rUPmtn2oiJuepXbQ=", "GEnNCRDXLqzDLYkbcfr1ALy5PhzvJQSvRDuU+LHOchI=", "HkY64/TDvQR6oQSfTwkaLx1dNVDj1YAfz/aPml5oKPQ="], ["5s0QiD4eEcbBkdNjKfMOsARa8GwthtDEOfXB9P71Sw==", "IybD3KeqtrGFJlT7E//0KhUsqWMhJCFsx8xvbTdSKlk=", "H2lNGsuqsOpbwCahhk1Wi+VVuJwPSbYTTpuJWuFB2oY=", "DN/gmeehVCeN+2wDiLnaoej/Mjogvmpqp6hDgzP4ecs=", "F/cyzBNUsftHbnBWjS3LC2aD0wsCQV39OFUEc2qobeY=", "KCOaiC3HsvP/e5qo3p49ga9zbU7m7ZkdXGtPpUAUj0M=", "FYkmuelLEPyzIbKTu4qGR2J6W9MTFYCNOXwclPZQ8s0=", "F80Rhk/Sxz0IZ9NyZLTKFN+TWoLypvQyxJmBNfpfSqA=", "HXcgmLYVSSHbjnUG5vA3LKRPIK8zhuE7z3H/XcDWGxs=", "IJV2vnLbewyf4rgykSXn3/BImo6QCl8UwebkhgQTQmQ=", "C3qx7xf/YjX3c38EQWGQLwPVlM9KDMZ7T/tHEa3h6w8=", "Gxu/Tp9wYFFxag4omQyvF1cwhqXYGMA4g2aWgIsS2OU=", "IqjudDZ0E+zPeqA/3UIMa7YlWm3YIIHWsU7ampdSMps=", "LHhfnYg09c9dCPEG1fmRg0D9QUq+JPCp/yuOBJK0TYM=", "BLXcIFe4gXCnGKEC4MqRd6/HV+4mdzoCkMa6sVnKT7k=", "J0EhkforLlMnoR0pDktDmkEk9IFFxh/07OhEikNz6t8="], ["BCWpZB+wFVi8cXCi/8JOtqUUGYspahYpzChNmDvKh1c=", "CAxEKQkif0qdqS4zI3+agssMb30MQVW96lxlF7BG654=", "FgTeai2xIr3V2DlUChAF7UAkJbrDuF46ciJNM3QCvew=", "Fd7YWdUBwnM/6t3eIv82+oroWAOux6IE9CsfZVO8xlU=", "BA2w3v5rpHl7dKQxJc802GorM+eiLicQsPt6VWiJOqw=", "GrFfL95vU1535hXIwmAhk9RYYMwBWEnfV4+f75pbsoM=", "Jk+tzHkaoY52dRqJUkLDDNu9EZepCkVtwnjhC/C/9eU=", "LeJ5/Pd6JwgjqRps0ar7WOnjqzL9/ws7BcmNVU22+tM=", "BT7YrVUNiZL0uYFJIBg92Dm/NV6sqMx7BwIKImFKgIo=", "J5cCsTXRRO3pQxlSacAL9iDwWL8Bhs6f/zyziyIkWg==", "F5qCt38sy5SzjrWCrEq7sW30KezCJHG+c8x3ZvltmUg=", "CJ7+0A6dmT9fwdWvLytdR6m3Dm1aYD+6qo9lECEj79c=", "IeJfCn+O3DjeJbpgWobMCOCMywPnfF4Lntq+dHaLYMA=", "DY28P8hUwGZcMMSIRte7DrGNPXik9w/vB/JC5FuGXqo=", "F73zOAcohLUizjxQ70cRCRudr0ikM3S9wKgww35dzcg=", "Czp2nIs3FWImA5XuTzSPiLsFai8OwPmOTmM799lDYV8="], ["OXp9dDSwqpQTSN5FrsRCzVytLDmIhJUOgjPFjdUDNQ==", "KxwA6gCJP5+RMxvJBzl9uGXDfTvGxLObgc2TFpb9eDc=", "JZcM4xt7EM7yISZ7sb4WVuwpFG3wb9tbT2/mYHUjqgg=", "LUAmv6ezehmjAKuvLh1cMtvNQiQO2GD2gfYd1tYhTO8=", "KeiQNJQkFKH/aDPW4idC1BBuD1830fKrgOVETlpSycc=", "AytiZvJAF/3hsoHQ/iBt/zC1OdXFuhO1MS5IjY1vGUs=", "LqAUth7VdTkiOb2UEcCmxCArczTPLg3YwwQFKOSj39o=", "Es7VJU4mCp23q+DL6iY5ZoD25X3AdzKnVdQJ73USALk=", "HU+bpP2M5O8ZO5+HD0SVYHlTjWO840T5AWrF7WOpml4=", "AsnDE1z2S4nrW3FNey682B/H7a5jfMYRZZHfIItrJYM=", "GLY2hfb+0qoZBIVjeEQhUd0foBx85hIdI+Hp7iC0JVg=", "KyAuHSYmxnk9aKrPnDqP/7J831oLg/+PNQT5qyakPRU=", "BqeN/eFFjuNBoInBX5U6IZNSff+0P1Us2tWV2nxv7MY=", "IvYuReUAhGlqwlEqJduZJSRM8CFLa1Q9Op+DuOjlj/o=", "LZN55psXggi4SWuKCgqQ1XiyHwkMUwQr5HZ+PBDTtA4=", "GttMh0M9hm6P5a4m0BR345YoecIMjDoXDAcnFnwG0Lg="], ["HWbyCPwEQRoThcIuID3AjwusL3zZ36zN7CDTuTJSrQQ=", "CS8Dx+mOYcKoWUP/r5wE27AUX8IFXk1b6Qu2i5AQl0Y=", "FJVvgKZbAfnul+LrBw6d8nEcuLy1ON2Y5TJjbMYHgug=", "C8y2acsBbUmEZJRPcZLs/2cW5stfiV0nFby7tlsSiMA=", "Eh0rpb2PIy7PRKrPEETNarb5Px5TfX0VQXVP1J9RsiU=", "BONY8lmjMkT0BYoFYRCiaBa77Dx2q2pfe+k8ngyS8+s=", "LaJgOibU/ew1MYIEulBgZj4VoLHk2TlSWNXm7srqj7E=", "DvX57muhrh0SZM8aNuD+S4BDqwvd+bnDIA+2h6jqXIM=", "DVPWHIpSFODEcVJ0rWel1qLPufw8HnkdQd4iyLqEaKQ=", "JS54tIOK1QB/UYu5xqTOUBhx9xEo7uPwyXhM1ksYP78=", "Cieo0a9qBGCuFyTzLyGgawNmaNCoY75Q/MR/7FdjzpM=", "AwSKJl0O60DlpTFjOsIruCX3XO6QNuZqBhvj1NJIyGI=", "A/2U5Ru9poQ9MaKCUw1UJAqklhZdZE1ddzex5afWDVI=", "Lya8E65IUgpDnJ9Uars1oSIqMH44+vw+f/yEP2x3160=", "AUBX0C5evPM8Fm4Y/pBN76njQqGeiNQjNjd/HF5n7DA=", "H8Ju0Cfbe55yQcLHYBdmYvY0ugWpynqFDhhK5YjL4hU="], ["DsHtOuO+rE3dH9sXucfGSOfsgYhaB6W8vZZ+ajZ281Y=", "Kg93uzYk/EgmyaKma+TsddvCFkKhb8xBgtLWXA/Y1/8=", "AdeZroPvZVLzDtxHuegq3AUD3Et02kC6C70syesbClM=", "Bd4QmcZfCKmQrA8fRewvuHLHceECddzPpPzhFGY50NU=", "DwkT607n08AtjOc9HOwrbLsXapISmzSilK3wZiQ/9r0=", "JamsLR74Sr2YkntSwk84eW6mDmOFjsW1AZbX4WnJO4Q=", "IKDj9OEknExq8QDf32P4vcaex4hbzQ0sLpjZj5u50QQ=", "BrfhjQG0f/jk7wgHjoEooGaTvmV0iUkqxBlahUcivf0=", "Es+HJTkT1F0ofpdfK09bkJ0WqH2JyIkFf2Zva6YTibA=", "KafVVOn/vuY5hnhC/Q59QeqbG8liG2VPyzmPcclbZo4=", "GGdWd1BY0JxjnNq7rNAb88J0QVIVb79+jz6Zn7YQ7Tg=", "JTLddIf8rg3Dp6xQuA7DMMb7bUz4hfETWYi/bfwBCm8=", "Au/lKdsd48Adb+f7inHx6qtq8WQfsfeq1PK4jNE8n+U=", "Cvgl98oktKKF9UR2LZ3v3JnyuFwbifxf8gedPVDm1Oo=", "F4GN0CVLKR0Nj08aRYxqIdiEEVNmGBK76YaxQDzycN8=", "EBdftvgbFkNq8waC82+6s5bt23gppQ6UbHXyfiYJh8c="], ["Cz5gHjal2C4CFDYshBlHTcHMLA7YEmU01po/eQsnxgM=", "EIO3QtNTMqi3m4Dn3ASnL36GaS5Sm2oexWhzNLYH2nw=", "EkF8ABvoYZcBOytIccTpsNzrg5kZGanK+s/lRmb1kK8=", "LEZdm164UteTOLQnsxhNlB80BGFyqCzOROK45cQ3lHg=", "Cg/mbA1N4AzHdhAIcyoAl/sU1kZfnR34NeBCP7IH2Xk=", "L1IfJLwCKGriv4SE+7w5hDiGdV9Sv+x9PdXfeNNAch0=", "AvHT7tNgGPlnlxHgML265RIkte+4sesc3KiriGIS8Ps=", "I6p8zDdRt0DuyfNaKZhryVik28fEsS6rK+g3Zwbesg4=", "KwiM0woQiZurwyW7oyqjQ9Mp+ah4JGnE0l8PI3/2B/0=", "MFoMLCxNNZmOmROCn1YCUENj8hvXIDRzULYEGT55vD8=", "CL2d3RkteXoZ3R2gSb6zn6ZZZZiicDHqHCsolm2WGAw=", "Es7o49HKwcqEUXqz3vSHxGCuwFg0j/IgyAG3iXmvnmE=", "DKtQSyKjVz0JUJ+F0/vZTpRBesslOSNCus1oQAbDcYU=", "FgWQloQp9ID1VhHGRIkS/fQj03v0g8NqzMwayaKdKlM=", "HJXCkXNTxTtM2391Cg/obOEPjVvbAYAy0/eTeX18CjU=", "I9MANzu46/fbzzFKPAsf3s1criP357uRW822pngrV/s="], ["Fjy046XskuV7JbCVo6qoz9xM5ZJncYzGCQoH4UrxCw0=", "BT6V+UVbxkmdRHts7dC2qtnLztl8zxAGDzye9R4o520=", "IXH9EflEhUZqgZ4k0KzvCLDIfXi0bZO7lGK0Q/pAzcU=", "I5GAdcj6CSm+/CsXH5nr6d3WaDWU75qD+E1Kz9lZLVk=", "CJjtHsGkNof/aroy3l+BlDRSigdSs5KDMYmbBkay8GE=", "HcP3pllTChOsytGBtuJlR0EI2LFGkmZVLfvDjLZ50G0=", "DjiLsQUkJAbjcggOmXoxOSz0/72caUFj/DZurncOQ10=", "InPDcOtYEMA5A2BdfMlNWpKvaqqnuETzUYnndAan6Gs=", "GZcv/d54mOyL5Pso5LGe+qQ8fuIMiOKQluvocuHBlHU=", "Bh144ZU9GUPi2WgzW3PhX+zviQdelslD05cCshTdxfo=", "GUGEqCXenptj7Xp70HElPvWQPh51pQU225PCYxGnIBc=", "IcDRh03sr5BhMYPqgnuRwbKVGDn3HzKcucmwdT/67+4=", "HLM60rp90MIGNENDKoR7zM53Wo2vho4MR0kFpPo21w4=", "K7Ms9g+NRp7bG2xWST1Mkzi0BRriUU1LYILvGLHVIoo=", "AklbPBv+xgdBgIFJMz/EPwTXnexWWCwpKCn/37PBo8Q=", "DwQX+mI3Fn50FSUmEwbBdmTcPvqSR6oNS8//OOid7e4="], ["LcqQ8+WhWymJX0jXoSkNejNka4liDdCozN46o6UdQcs=", "BZBNrjRw1AzhJ0myfWRuYg6FGeKxfPoBbK64nZ407m4=", "Ium/KqAv5l48x0+z2D1OM1GGm9MFKMN4lYr0Yu/WRf8=", "Fdf7piusV75dl0UqPAbZ+nV/FE3xZkee5zBpZ0gKKH0=", "EeCyND7zcdLW0igFl08lObblENdh4NoXDQ2pAJWhMmI=", "K6OYRTk/zHdv04PlNdVnYhx/ZABag6b39IIivJAgkqg=", "JRQ2ScE+CNSwC/NNKqGo5FD4l4jid2aJYhcEcVXFvx4=", "KnMQ51+v6QLiAoepGr44iq6EILHqRmDdfBWcJrljLNE=", "H6aURwP+ABKhbuYEJSn/AryAQxPvjG2LD5EKdeb0dzk=", "Jh+XW6vXaSgiRzuOOflIuc+YcwqXhd45MXnUu5nazcg=", "Lgiyi9zEF9lkOzAICFon9KmHZ5LTkVyLnaNWem3WzoI=", "AX6e0ZHFZB12iw5V7A1KhfblQZ0y9WaNOX1bbLgFOH8=", "Cq830fU90FVuNH7HBZYjeQd81UMZjhwnWT9EVFISYfc=", "Kkpy6d/lvyX2/edQoYR+W0Qpi6WPtQS+V6WV5/zNxAQ=", "Kt7IVJ3/3nI4sr2m53MpkKkRcAyNNSiLqjnmcBWVMjE=", "Ho/SCoAw/dlOLENT2PgrSyEr+Ie8WWFYFIkLD5KkfZA="], ["LHjuXqFtOPC+udwHM8S7GJPLM/9nG3N6ESLWT3Kc/yI=", "LlY7ncWj1NWpP0drRm43EBnHf9bupQYSak95J08va5s=", "By6i9c3Io3ifvOpBSpHnsnu/sxUd9RDQgP9O98xz8Nk=", "Arbxb4ErqQOQE1WVXMTduZ8k8cbiZDCUflGBGmgxG78=", "HVnVwQsMndNHiZN32jW35nfH057xtJFmuXSn8ryZyUY=", "BHMP4E4BCMmlFFpcSOYMVFfkcIUiFXv+D4KvXGZNbqI=", "EuwkI5uhsPyflSVQoiOlLSCdjSK4shrCSIGicZJ2vg4=", "IAmDmXJe4V2T/9PkgeSnuVyMUIP51pv/FxTup8fYLUk=", "GCN69zO8REGKyE5iP0g6a+KLjyHQM/vwmdZFuiDx/CY=", "Hj1s7zf5vawj0bOBpsWNDs8Gpuv1jfp6mVpEPtffaOk=", "KOVbC+1ZGRIW1dvh3QWyLACbB53od/1UqvVAHSyGfgI=", "DGyewxyeO+B0SRn8VVx3wMElknvRbeKAdxKzXKJt0EU=", "KmB/rNOTb90OhOm8PktLrIboECwrWtFcrlUNKLNlTnM=", "DFCaS/SK126QQQvqNKiRl0Fgi7u2tVA8k+cyA28HnRI=", "F4B0MDuQ2JheN2WEuLjft/lS+PTPhNgV+Quqo7ZExMY=", "GFcoJjhd/G7spNPHHRELBKuuATxUUNnklHo9AZu0G28="], ["KvMk7E+ed4bc8AQ5x1opS/91PjKSu/YuZkcfpzDxnHk=", "FFYAg9mA0XLdQMlCbP9BRnrOpB1/SP8RrF/MCHui1bg=", "Jg91HHgjq65huPN0jIR5HAvYSs9+toVIcCUBeOmlLPU=", "D2Zzt/tL6M3qdKqngCycc/8NU6mOlKK8YGhdiQok/es=", "GhW34t4nEl8uanT07HzSRV8bv66xFV8a+Bm9tf5UJB0=", "B1oJ5B503ooqx/7ydZHnanfIUeGlEYXzHpm14I8BzHQ=", "B5wElE1QtHd90L6+lTYAZFzsqdZfugIPlzZRRr75xs4=", "AsorrHwaoMZOaEEj8P/iIXOSMFK2oB88Kb6AE3/Ylyw=", "E9kDWg3HmLBNzvDwjt0kFST9yg6VupysBdIHvTF+Gc8=", "HWZX15GDEWnFa26aIB+LeyQCRqLQ+FRDBIm5g0VAMtQ=", "HInY+XXwMEKCrY971BwSw7GKxrgOQGX8zaQju7P/p4Y=", "IIKe89+cGD+JZeScjzFcKZWmRGp2BTVD63UBRfGndAA=", "FKK9Wlb4cAnbmBVGUzIC86+BLS701rA38oMIU7n5A5w=", "GZcz2kru2NbNFIRhYX6ORt4i03IEMfwWBWGbEqf9Tio=", "H1/AYAKLoH0R/JR39Pr/55qBBA6poExWgmdkSJXmc38=", "IIt8jB/4Qi1KG9E6AqlGgc4hfZJfQNKHX3Pe8U3noiA="]], [["GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ew/FRHf9lTN3/COrvXpBvmdkiSqHh8dZwUQP4BM8hS0=", "LJyR9IZhdxuu72d0V4p49pw1XI6QcVb98m2znSRGQT8=", "HewLr6PoGQYh5eCV73UeoDyDbbuARbKnP405fPuBUZI=", "Cl9SrW7EqKo3fY3SrjqvbuoMaMY6HQNPvaZxM8oLhcs=", "IKtzlL/as0TLtvISOACg4jUI4hJb/nlatKdnzstNkwY=", "EQ6jIrDCZHbGe/osG50XE/k7O5z4Mgzg3NS2Qoi9oHo=", "BU6r5hMWgfoB+8bb8+fVNZXQ+ICZhxghQriQrIr4nL4=", "Ik2BH73vjsCgBtN2oBnlfJO9WWIToHgjt9Srzh/Y5iE=", "DmkfykIxKKfUr8qlgrGpR5m6H10qXVO8K7pWu+yyJ6E=", "GJ4nnJLeC6tmcH5ubjEFJOYVzUxqrMZlNyo7jjctjOY=", "HZvLvRe5OxkT0vec3xKEREEjcgbwKUdG2T+OW9zrRyU=", "EXkYRjWpeA7hMS3MPRXH7wQrGK6UCWcOKMTH8PubYI4=", "DkhGYYKugzOvGJGmqhlzZ0HtBoDVfJMe3hP8B66C6Is=", "HJ1W9xwvIsRNOowXv1tARS4FRx8Lbf6f/kcl6yn3NGQ=", "IjRUb16FQej3KteUiRlQsysc2JHMZndcW2NZYWQunBU=", "FMCdFVxdQoGYwjS1U9ozjyJ8vBKw5C8rnOcVY+4UlcA="], ["FEDcJXj0RpTRjCX4ktmMI8/bh6dyIAAg6JeCPUvITTs=", "Bl4TTLjYREfW6h4XkyvUo0Hr7yVoMTwkWU+vnX7KIRA=", "LGsTPoCr74SQT6SnX5aPuqvviQKG1f0RuHoeUrfrbQ0=", "J8cjMvWaABNbqpS94pSRHRNdHZX1PFLrizuVWUN0kG0=", "CHSI9zWx/i+jxscUjElo5/NHmxQYoaVmdDwcohXc/Pw=", "GfDi4UGJbq5tVtGCtoe4psZMu1ngMbdJ81gi/H7jU/4=", "KZxH8ePsxVerHJq+NvDSug7OAQUeB/CFjpepzhb1Zk4=", "Gkvv4RwCMMYt5E/6/qDekDujKMbWevc2gDEraPms/9o=", "FAdi0wxcOgsHULFACoap4vXPwlMbcpNw862f4dzUP5Y=", "GAqkur+nU5dT2cIi5eM1mspZ4Gu+/Hzzo/+k+WH6HVs=", "FyCOqc1Nwabe6+ao0noxgatfhsanBub9AH/B62eOneY=", "IAB6D103eYeJ4KjvaDU22c9IMaZWbrcntBGR2fKXRxA=", "Ip2kQaMCkpsLrpN0G3x14RM3x5flch+dfuWSNc2ppAw=", "ETe1xhuWhL7EHk36p2Q4JWYipDeOpOZGooRLvIW/gcw=", "ETADwdx7rzXkU2+V9Oqy87rdosehxrWvyVYjSt4+cSk=", "G2FGj6tZySXxmGGGvLl5ZahYUjolgtQ0MZqVJa5xFY8=", "EX/VKHcPsX9xjimi2Rpj7Hw57x3TA58JQ/cX0YBCU9U="], ["I67rDGSZuEv8Mq48Qt+XKHmP0u93TxUYuHC8V9E4WQA=", "DnbEA5K9X0WLwYe+VAmTEqD+//RLRBY3Ag65JnCm/PM=", "LOhUbLWfQg7eYWkudk4On2cVsWosgEfNgTHJdkb1DSQ=", "FuZGYRRNgWiFsy8/eAlwNHd4gmjVfBSx2TmiaynLfvM=", "Bs8NuS+GsnMu5fuIHvAXYBLcSt/YSbm+TeF4RqbOXZk=", "GPdUqVsK8ORwb/kCS7E1Fkq9b8Fu5AzC1oUtiKL/yfc=", "HMBTpqTW+W2nfl5zrbnUm8TQ7yzC9p+t5IBAt/jXE4Y=", "AeQGZfW7jFwNycEfOdR+nTPnF6+jG6dPkvhzelXv4TQ=", "CXbXw4RLyN7qDwM3+JsqExMC/9LQqHAYHKX9X7bU+2M=", "LFQofu42jV1S37BoKC1o5rCbdr0bXJMzs2hIrCd3RPU=", "Ioo0iMq7+fKe/AvOIRoJAxlys38l6jWsqEDcIzGgzzU=", "Frrkn167H/6Ia2NNIV3mHr9PRNHNxPhGcN+O1pMQv+I=", "Liadx49w+RA7K87T7b1B4VbmSRCIe03d+KPu6WD2Abc=", "H0uFVSuWDRwYt7j2avcwWmdz2bBfr1Hg7RpfLvL5Xn0=", "DV+5sOFQPyuSaXxHO2nPdtOPwSkS4sPLM5ltuwzfqjg=", "ARKR71FKENbwZR5K0NpdSkieMBiSeHnalC3v299wHd0=", "Eg50FtdDCOJAR/aCjGiuKLwoiyFuiiXosOvPc4SA45A="], ["HtnT6Sdqy3tNrlProUiAb9m7B7LdBhhyEvq33L5j1yw=", "C5gXZeyuad1687EP+kJLiusgbMT0klcmXGdTscxU688=", "Ctrq8od2uBPVGPZFx5Ple/FgZ/2A65Id1aZ+iVZGycQ=", "IBjbOGo+Tlfq2o2RQIsVUGHfBQFA+yL5pPNPtOLQJCg=", "BnxEEXRdtsaqZZ7HN6WGqPShzeA1LjCqAGN5SGX8HAQ=", "GT/g6bSAEPoxnDO4a2sY9CjzI/ojfKkYo4+qqRuklWc=", "CVWOzFi+5PPFePYkid2QCECpiJCWwKYhFKotsEWh0DM=", "I8Sr/rgxkjYqriGy6e5c/HZb8QAPeYw65wEzVWq8eL0=", "AVJgQgHKffBZlOnV8FjztnSc6mOqDLW04cOgC2ZnlY4=", "L2U2GkrtMg/NA6RcRN2nQCE1cfOXXOILlr/9lgy8biU=", "IhIsYxP8mkxtD5RNPOI4JyvzUUext4iqsrjbzrYCTHY=", "IpqltUemN4DY0SniCf25L4VmJhbVnakIB15mj9gXgi0=", "Iakf7YvtFJFMT9SRtvpNy657O4s9RWMDr4hsMoq/Rpk=", "C6ilSRSIb64WcAwC7993Z0E6C+xaGe0M8KfYrGDB8cM=", "LhZKUk7iLrWokD+uHzWjp4+ILz46mJK2/0dTuqyTSUk=", "LfL7LC4yHjzOE9FgkXBaQMXHlfi0G2Hf1q59l9Y1eLQ=", "BpleUQ/XZpN0w50nkD80KsW/ihRkgH8wi+9hC3bLaT4="], ["L/V/P36VsDQR23kKhmR0Z1gRlxJNIXUg7y5jMqWzUYU=", "Dk+wRKn8tAh+NRNB8l2YsTmbV24tZlRTTzSCGaCs34Y=", "IIagG4FkOKKkHFnkPXP6mqzwwk5Pa6winWX7pZkiVUo=", "EiY7fj895giZosIv7pGZcs153Ciah/MfG0S68kOdyHw=", "GZCSQcrFAojA0SND4MEs+bl5C0Be8KkAGqa+AokGOqk=", "AR/wkd1VG21YYgPuDK+uL3ZS6SOrqCV0pTtjKgZvSIQ=", "CT19VWPjzNC18VqbCT/muGOqzM+a8R/+qbKVt91CsfY=", "FmnkS/AiOnf0j/+8n08gtYFPYYWuEaIQ+P38tfcdYD0=", "GrbY/jn4e7DuW4g+6iclyqUsV1dA1awwsFj3cRPQUjk=", "I1vxeLW1YmLZiL/GJwiw+F1XOFzeK02s+ebVkt6yr+Q=", "BmSaE+ZQI6cTqu5Th9OI42Ca6bFLpNoQZC7gt7ShZjQ=", "KaWx5OLyVEVJat7CMO1To1mTs3YwrstdduVmCNG3jMY=", "KfB8Hv/GW1WJ4cpSy+AL1l716WLQEgAwJnC23Oee6wA=", "MCiclnjAMw+Fz442JoOmFE8iuEGqCPWG8hndntrveLw=", "AfncvefQWBNKUQpxHQNtHxgA5HOmOzOn4PsE3C4J468=", "Abqvj/lrsiJLw0z4DDi/EwhvHkKbzuwSCQ2KfDdqmoI=", "HYFLPBdlbCMn+UzAJHJ4C4hriDlPGly+NNxPRP8TT84="], ["Ffrvv4WEo4lptKcZ/+XwLCGRqMztoLd1FiID0wuAIIs=", "MD45yojo2m5cljVkcS34p/hQGnr0qZDkzOwZ5fj8gF0=", "I0hYDeSarAHOj8taorRn9nh92Klszs1vtH331aQwc5g=", "EOQg7cttp2Fwsk13fOnTFhLtsVk+ptMOjP2s+2l0+ZE=", "AdJblLt8ScAXDuH7Klgktw5FVLzFS2yPjMDMnXTxml4=", "HaPgBgHKP8DZCxl70qR0tG7+Ov87LPrx6+Ffoa+t8ts=", "BF3AV5ymbn4JbU3Ya4guaK8tNdcM9eOxeDyqoOxCQlM=", "LVs/UjqWaMvkiHiBv3tAGE+XhxPjWN4nDYemAOXFyS8=", "G2K6gDeoPxJhVEwwfwGdvqHMaoTUgeqJYLD8ZwdF6K4=", "F5TsKw7rIvvXU7IfzZSee+2zBfFaWer3SpYcMEZjX4U=", "HtTJXGKDtF7AzYj1EZdvBj6ivrBpW4r3zBBYlZOnl4w=", "C/znsSAGi5owAp29s2vgHQcegWP6FyTxPGyom+Kbcp4=", "BQanpd5rVuvsXnCKcKPOyzos/SXnog7UleKVqTAjxag=", "BIkASPzb3mNmdhzVj8xqwKM2DZpkIz0+pNjWvooj7EU=", "KFsgeZlwtYxjrJ9K9WTODyggm2GAIhTaW/r9DPJMZxI=", "B7DXDM/xtw2tm7SwFC4/bcW8ldN2av+tN4zFBCSE3sk=", "A7kNo0sZjLyhfjSqyYsWmHXs9zrrXG/x8Ayf5TWqmQI="], ["Hm6qsRkVk94NicuyOZq4qpVdgprZWUKM1Tm+MLcv3pw=", "Abd5ldvzDMVfnUzUhJztlJNJ2oEjmgFUQP2zi4dqvuU=", "H7a9bfZQ0n6MrAWsC0Xu8HAOMIsptL1B7s/1gCftxFw=", "DryzWPlfhLcZxjHUBFzvA6xvwjj2g0Uizr0C5HQRu28=", "AydOc12y+vGGeHUoJUJy7gGWfmrp2CUUE3i4NU2EOWU=", "TvQZRVWcH7CyEWyyvh8EO/zo28lv7szNpHy/aL5ZtQ==", "DaAvZBDiQFih6QQSzVMCxXGX97GvKplJb5z/P/1YgI8=", "EMGFbygvVW189tSik2IVBnJLptPFguTCYYQvKkvbDsY=", "I5q8fJ+GauwoaFwm9OBGqS1DYNNstQiQ9CLhjtb4p7I=", "CD4c1ZQ0YatQWyADEb3kAD+09+0WqljIvCjy4I6faSI=", "Ff5ippsEOClDldob/JMnLYh5fO7vZmuiRD8MFG+Kt+4=", "IAVVaLMzZ7wSv0rtegkJwXNYildjxqGnWYunxsfjwqU=", "DAKxSPShVZtZfNMg8AwCuWp/x8g4Eb2GoeecwxBrIgE=", "GkFi6KdwREe+DB1NXPL3d2cPSEHqJ6wnCc1r/+7Szr0=", "DOPdcn/dEai8cxUA7/ojdjCJzjMyy3MPn+VxRu4gSBA=", "EfKO5dqA0Z4xWBtWakOVN0ZtnKf98UtwhoML2KwTxMs=", "J/p3oGWHkeZ1V4HDZ2g/nJMzpBNk94cO3/GTWjR0hdg="], ["KjuwIMilDTEO9bXHfMQIsHf+JIFFR1TEVo/2aP5fCXQ=", "I2Q63TC+IEc00CnPA0yVgURVEGDBkBxCCijJaI7DaoA=", "A+lxgjfBcA190hPgJvMH6AALOFFGf+2eb1H6UCDCNpw=", "DEji8wT3MNSOg9rlx4pGGIUAvIBApJVC7qXvGiG50iI=", "DKwyA2LiNbRY1tNkzQ//kU88BWrbsDjcKoYaSff3DiQ=", "LwU/3xpy1q2Mnfl6BNY3kW8l40JbbcM+mcp8rFzH5Mc=", "Lftt1ZitpX6nGo1o5pJGCPDseDiAhojuSz/NUh975tI=", "IsxDSfa6o6jgth/ECrlyEOS9Oz3sfwW7jvg5yEaSr7w=", "Av7VoDIAQXZkU334+jAna4XZG9LtId4z2QH7TYJDmFc=", "IqZ6iHdpgtahX1d9z3gKxIXrqub99vvlC5XqJmp7YFk=", "KweaHQm51KdtTlDEXAH7dQixxEOo+yHr0oUz4F3viGQ=", "LfH/hmRPzEKhkyzxXTFO7UB2CCRvFKgJhyX/e+gJyH4=", "JKRm906ZpgKJT0IQEPQ6gccIsbStB2QlGQuFNH9oWxo=", "LpRLRJwTac6XZvpvT5modjC1wfLWNnekN6U31htsdHA=", "AQeXRspR2VGKDDCSlspIIGKSeYkQSUJ3viu2WmsTSzo=", "E9ewPo/J+mR/ymzcqXFGkB33xnWhZJE8K9Kjtu48tA==", "BtbuUxuj/c7QXiTPkQPQli3SJ/HeaSwBmUg+kqskulk="], ["BR+BXEVLYBXH6/kMKXuQ6WBM02rMavB/mbXlH96zIjQ=", "GUaiariVP5vlWBBfpRefF152okQp2tXVMsLOs8/qBck=", "klrzWjNmgBrICjHWP3RfqAe9oQVgNFrVcr70zyzg1g==", "52bwOvu3r2MOqor/T+YPOBDzDz9EOEmO/gGGMz2twA==", "ERHtema6LM1L6g1D7shuo1q0AlOhIJ42N/ED3LhPxCk=", "Ha90hCx+eRBDSa05lZLFxMzhb3nhqG9Q2UFZh3LMqVM=", "EFcGK0C9zx/iqu9FiYyHEUZ5mpLIfQ/OZDAta8gxct8=", "EtAZ43zRvXb+4GW7c4CpvYMxpNvNHJx3Z5K8GQRcI7Y=", "CZbK502WJ8o8VsZGCV85cwJ00l6CxCziHPeJJT1Io/A=", "LRGI2efmrCTEssncPfz7D+R4LWifMblLH7Fe8p0R8Z4=", "DDRJan21q7MwsvbOmtrvWubjCMj8LFY0CXrjUqp0V9Q=", "HU+w8Y8xyCcLRjbmtdejPkVbEFDeEWQYLPy3OczpZdo=", "H+4YiIQlcklwvSiXtUx/qOnDZ93byEhNo3hk+v+fkFY=", "Itbnh/RNqmtlk9/eVXbS/fXcBEfmWh1edxLk5iw73O4=", "I6hdT5Htpp8xDEUdfUgML0DA1TOC3dP8qq5ie5YXFw4=", "JEDnhheaf7z+jSmrGND8bPo4PPt0f3otFbd9gtmw2dM=", "HlB5Ib58dhJIef/OW2LdDpYlnpjMZMJyCNYrQL/j5II="], ["KLdcKsFn/fGEclMXx7u4CD5axbupN7z6bO/LaeQEi/A=", "JItTP4deXujnUc76Sx0HMvzTAVHDpcxKu7sek7RlXUU=", "D4aS1kpbaalWxOIAa/7DREd/318MmquGZgmEK511Jp0=", "G4p5CdfnvU8LzIADlo44SsLotAWtBc9hA2TT7LmC234=", "E+c2zHC3yCijjdY5Ts52ucza4spPQ5Y0MlAv6MKtGf8=", "KujajQsSmiL4NNDSNMiRfC+Hf/ANwWIVSY1LdI+0DfE=", "JubRiup1qUhhoCMztTZM7Oqnit+7dCgXIYyjr2B7kQ4=", "J6o4+gUcQ0GJ31e6/YByPuKb3M1Z+8GqmvEYkdNyLmE=", "ME28CTaGI1bgAksqMt+jCFq+29M38iuJBivmFNg8sIM=", "JlxDyIbwfQJSANVs0kawFnCz6Cq0gvWHmxBgjMBaN/w=", "BP/iepLLQwDndDiO3DFHq53MSrNUw4D1HKei5/4EY8Q=", "Gdbx0RDZ+HPbAC/y7YKJBb1sxdeSHCONdWnaqbJAHTI=", "GXEcQddvZKNxq6YvP0ZxDe4MOq0he3ywC9EmE7JO9Ss=", "Dgjdtp1e/ZScPWceTnjk/HYoxl7Bz7wYumoQGqGdv2Y=", "JAZX1n+SteQmGs5DT9KGIGwxVWU3jOi4FmFSPw5t3FQ=", "BWFJIhcSuI7CkfwhgyQULQKHPN1TGZZ5/OTfy13akRY=", "BoGtrqec9FfbVwGTHw7i8V7LsVntUM90ahW4XG+KU3A="], ["AjrzJFmWg9m3G2HQk9Y9y72X5ElXMz0ml/3QYMHktYU=", "LnocUdph3SFKF4nW8e4pV/adIbHxbR+UWOslpAZQC9M=", "K9/n60+oA7wdwAUqRthQ7j4JHrqKfxJXloL29v1QRNQ=", "HZLkIT2ECjMOy9sIaT2/mpcbvWIpBH64igPzNMre8ic=", "HygFCEl2sUL3x0pBb/Q5/xvNi457BXATAEB1SmG3GRI=", "CZsKYzCSakoVZN/pT5oRBLuDdLtRioneCMWRwX36oFk=", "BWW5ZlkCWTXZwCXHqyCxYR2wC2fsxRQms0L4x6F/7YM=", "DwuTNttcFtRy/aP7msE7EzlMCaufSE7PatIGAhe1iWo=", "Kn3o9f9HbYHTk/HSdGNsqVbwW9QivJ88wPrABUtYywI=", "DybQXpOPgxe9YI7/CJXTUtynErZTsUkvjC6payb5OB4=", "KLc7M1xy8HdIcaIDDUROX7lUl5wcVo4RL7kRpGxmZ2g=", "KCoB6PLOCcvdhi+Y/auj+a8CRD7cliyzSALQRHfeHiA=", "J3DRSiIBUvpwgwQL6bPNOMis6eIHBzSGvPr8rXBnSLE=", "J6VzA2UJqKKakOqjTSra7V7R7GsgcnTzxcoj2tOIDlc=", "I4SjhLzCxKF/98nj59Ex05FzxDEzOpx8HW/XEQ4lkCs=", "FixbvIG0RCe+ToLF5SU71mwwVPXFtzsospI4SHhJp5Q=", "HmGWFHUIvy7chyxOiXqWd3ixGfaftDGn9kbSAY6rQBA="], ["BaB4aKfJX1CgFYef583x62wxfk1InUUVII3fQKMjKeo=", "IGXjdO2x88u9KRncBNFK2wcGLdAewVAbhVIufg+vkl4=", "E72swTe7z1HYvJ0oGTHW5xEi3G6T5//ouDXjOTd1w9Q=", "DTs/uGpEt0IkKaJJiEyFZErxl1ZBIG5hAHDALvWp9M0=", "J6pQoOXVWIwUhujn/I3aZUif/7hmdWwhj4fnKAzd+mQ=", "C5rr8EEUbBGRmXV+qM7uWrzqnsQs2yi5IcryHoSEeFE=", "J3a95SoSWUcsHMAg5xn4IZHew6t2mbfQ/Xad0/45KZc=", "J1pvWWIzVNcdOLTiAM4ulnaqt06ouDZvzjO9vEfQWG0=", "Esb2yDo1MPrO1gyI8ZqC/RK32TinmGTtIKVFpS/c4R0=", "JXaJpOIvaodoqv5UIY0x3k5An9v0IxlYJTa7WDMTo5U=", "GVghuZrywhdATuWC4piJByujzZlLdJVcJhta02Tlqcc=", "MEtnkAjoofCUSEI6BYieDfZjorZQVcqe5amd/hP7mhY=", "CN/+aEqjP5EdNemmRLS9v80VpNpJtlMYFrYOjOT2teA=", "ByNyCD9iGVvMK1r6sQOBmKPwVGti0XHqIcN8jzFVEXY=", "JVR7UbLGh05FOMqbNAk7cUrTao81bkx44NZrHxkAOPs=", "F48qqN+aEe8zVY3Mk0lx92l+Ymz+8A/83rbzycGn0Qo=", "Bo76NbxiASSrfYiZAXG65BAq0h3937OH3w3gyKOhiek="], ["LFtKZbxVrF++695Tzl+miIL67SqSp7P1cygyxy9/LDA=", "LzZTWoOgnPCfw4ogpyVHeuxWZo8DSjZKn0pWBf/9M8w=", "B9eM4MHIc5GgagbIPTANUlJLKfGDiE4wDg6t2s0F8Gg=", "Jcfo+vbEihVsuR2BqZfGZz0yaUo/3WT16VlOn1BLrYM=", "HzzG9l2dNDcIJaOP0fSPUJ98VhcbnnpiTZsOzfasTqs=", "BV7yceOIJ4sayjTTywARa9b3y1hLPGnw3ip6/I2Y3rg=", "DBoyTEnRX4eTGCGYm4yEN+qetG7Tqs+Ilf0cwxEFPmA=", "Auu2cw17r+rCP8C0V+qCTu6jxV7KY0vySyrCqaIUg+E=", "IB4D8f9nJilHOiTzLS1QKs3I/dKIMBTedMmPQKGVs+Q=", "HtxX8XThMitifG+dvieuJwPD8Rw2SzgYi/QdjKDBcJo=", "IKVvzjcSK3QAq2GmXqyBXdGA9S+tKDX3/ZZJBjUjiB4=", "GZgUftrzqSqxecYawsNq9crz54vL+2hM/qFdsXuDWQc=", "HL+rfLBeLyglSyML/OAX8AX7Ty3Yk1rRF2WzR9IANmc=", "FR4LwhEOQwDdgqTJJELEdRxlspRCbIwyDGnmGDGVjOs=", "DlnhqZDsAPcu3Dckg0nXpab3vK7xWBEEUPHlmF8KXZk=", "JK/ZL4Dld4j0D7srefKUVNxIX7r7WnJj9GK3yEtOUAs=", "GwEiJKTwUN+EESLRfF6k7e18jsIDR0OkMqLO6JOXbyk="], ["Fz+JXkcsTrFqKv87jgQX+zK4PrHjIzRxx2oFUFBdBgc=", "ESPTyX/45rWJ0Ri8QMoLmsEq6QlVjyWCVR96QjRbRiE=", "CYTBMrKaBfK1BsoHwG/pplhPNruHUG0tMWpPNTysXx8=", "LXr4NMnN8bOMjP7SGPHvDOC5kI3p56p6VRDE+5F6AoE=", "GxFxN5HqTLLhfIxYZ1AgQ9Coz5VThMHHk8UGt1/A2yk=", "Jvvxo1GWP7vatZDb12DOYoQnNSWhtGxB8pImxlM59LM=", "J+aFaOnP/Qf5JT7528NWJR3GstapA9bHBGtekOG83Jo=", "D/IV6x443GdDLiYt8n7afDqpQZ1bbimb2UjpcPw1pi8=", "EYw+/pIMnD+QfIZ3Q9NdLMv/fInpwxu2oXxVLvkrbAE=", "F7OfOGNtXv9eBu/wietWBRpgK8j0vxuwrSss0QzwcTg=", "I1EykS2y2gekdQxe1d8lkOcYQErvxIvmlTQy9kQkBC4=", "AopFcstlQmHPk1hDWSPmWv+PQDk3UnSLdqz9Lj9XVck=", "IdcmmlPTcSsgVDsAOa7MlGZSATPSmehEIACzMYSjnoQ=", "E/Gsw4nE+OdSzH5LgcN64hMMYN+ci36H3F+3RZyvSRY=", "BmxgkJNvawVPF96pFoKVQzKz4y2PIKCuFx1BcxbTYi8=", "BJKuX1rCpRAuqW5grIN1VTaHFRrkQELb9YmSMsjyEAo=", "II2BQVG83N38+DWpWMJZpkd7/kszknEO352AeHolxdA="], ["IGywOMwyhSbQw9xa8ZQ32DIZdRxe6PYbDp4vWIE2a+M=", "FgswyHTZwGcEySwmbHpbf9lmpipdsAjxv/30Q7EJmoI=", "GwD6qFE2sb/EluDqmmKEyuUlqpZhL/7rUUgIlVaTh54=", "F1r15Q5Whewtuxz3os0l1FaA9s3faNfAeV3smLh/anE=", "EEVg6VxJ/rt6Awhi7bOjPCsqPUFLBTay5U4lqzbo8oE=", "Ev1nhjsuA7b7RSJPsEH/KA6TZ0K1TI5U04I+CQ4UQWk=", "HbDn4BciqtIQ5SlsNukQPoLRV2XDGBNNF3FGodn9U1g=", "JH+cf6YQMiU1/rBnbP9UnxwXfQ050/Hu5kLpJTqvuC0=", "D3Bf66XwHLJ7J8EEvJPwyXT1Yfom1WFPap2eR9A7xlU=", "MGCU7P5jMAsvlbyYoEBseJjYaFIzCntp+bBLVASz7vM=", "EFnbXpfyWCawu+/Wv6pulJbFXvWoj+/pcSaR9vvfQpg=", "Fb2ZjCcp2+rMwptdbk8P2WrQpgN8hKGhp4UWn7M2+24=", "If3lgKGYhrEzWPGKMtWv9oW0vXfZTwZ/RPbnqTNQ/So=", "BoI6m6pVYjcysC+icLL4h/04BKhcGn8qNV3z++/GncE=", "GyVmKEOwmGqxpOmnZhk+/KR8cNSTZPA9UMXttbVRfr4=", "ENyxH4FcfinGa+HdPF92AsmOn7FofC2CW0h4nFIfvQs=", "KPkB/KqGCw3EGSre+OpK5Vr2zkMsheDOTQc+UUqyQlI="], ["AkDFeJcWFmbyjQALiNM1OSHZZ0IPQBzoa77kK+KHpPg=", "E2HSfEKntL1urrmKM5WSYWwNTY/Orf2xZGgWK9+ojUY=", "GeHkZTZwTOzqw+q5kb2AbjR75AoLeVbc1wNzUv28Q0c=", "Eh9KGNe32WUKq2JevoaVqAeUOfKrAMCQJ53nRyYjTm4=", "CMRfPExIb2tTeMd5xge1FyALtwtVM72s7xhRn2Jbkls=", "YAzyZjWy1UZDFQdYlzkBDRt1fOquYXv5W44e+phkPQ==", "Cu+KTkfV7HYOBWWues2r5+jpiXLeht0vRHqvIWq0zBc=", "KtC9n3HieFCEqguEYWt9raBTIHxBjmX0A1vmagzcjBI=", "KNMnocLWAS2eaemjtMEa0zbTwNzf9MXITd3fkR62RfU=", "Ea/syFWQVDvS34q5Ur4WRnCj8yWT6WLUvUk7zTyE+E0=", "CwUMiCBzpYHnZyI3Bc2VEMBMMBaMUP/gyYdaKLaTgpk=", "B83zMJ4TD5zt3WiK84hTafus9tikTeTUUGZ8DXZBIT8=", "BSMr+VgH5IrYKh60vEgemwcg6VGW3+Nh9VxNHPx5Jtc=", "HkGTbmvAw+1mXC4kZquSFrmXP+E22fmq2Vh4wbVgfG4=", "JkdjVHfuX6nnrFmD+S2zTXM2ZGxjxj4t1T1guHFL11k=", "ChHVh8t11IVE7sZirSfKas/smPeot5Y6KU5LsymxcN8=", "G9Y5h5cxgjyHH5zUcU48xWpusZiEtzZk7tJLEZKRGaA="], ["Gq78Lpkl/NRTmW/agEBj/asnazfF9R39/vklW07BDMA=", "8ej4aGDDtceLwU37Z9Isa+uJkhI2WIQvI/da46kumQ==", "GcJUC7sc1OCPEFQ3BjyUXP7yiundULl+C3lfjcWuNOI=", "IfCPmzwj86AlGBFKlpKbbRBW600dsUfODIiC4bD3vRs=", "LSGTxne7zVanT8KuUKtPLMaap3zPwzx3B0UtWtrHfts=", "D1KPWRK+SUVdQyOyWeMM4phNgXBgHutL1wlrRzU6t/w=", "CMAMTls0Z/AZAfZPn4nBW7C5CRjUiLcwyswylmkekgA=", "D8PM7wDWpkCAq77U/tkLacXlgDE0witCzcoKYPA+wzw=", "G85n9NyZVH8sr/G1xtY+PuJWWkBBkGZFM8HGXdnY1TI=", "Gouk830jFTichWDXTaxXKkRHoCFFUWKHBT5rnt77yi0=", "EV5gxOKTfrU8bkpUiPgBJm6E0HVHoLHNkbGPSe/vmSA=", "FS1HrLmwbJ0SwhOKMUFru7uZGmXcTU+O+Ro91yjmO2o=", "E2AmRriLoxwNVEx1e9kYFyeDXb5pDDBYOiPzf1L+Xj0=", "Bldm0pgDMaVcCjnYO+eL0Se67nfVOiQmjgZMcdqvK2o=", "JtsuhakAbvXBHNZ1omfULv759a+QRmsqr3XuqAJLALs=", "HdawlctoRZ3Pa9rdQ0qoH4ClWgjmeCxlOpOv2KZfMmc=", "HT7oXwePvuzaJHPvwr7dG6fsb0eV+q6uOw3kjTCAxiU="]]], P: [[["Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "IOPpFGMZZOOU0mmuWfF+/uP+zuUSy7Fj0yzHYL5XS9Y="], ["K51LQRDJrpl3guFQmx0P2yCnwCu9i+pzBUYrn4Elseg=", "EKRO2d2c5WhWM5RjKDPYYzaQ0ymuc3yMciCpsZfuP0Y="]], [["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Hm8goR0eMeQ/g9zt3bmgI2ID9fJK5yySWop5pmgx9R0=", "G9jFKEcuV73HIqFB+HhWlEhPQmclQDriQITjAn54JGc="], ["Fu1B4Tu5wMZq4RlCT928vJMU3J/b3upV1sZFQ9xJA+A=", "LVG6gsgHPG1rrPGtXlZlW3FDYlsKnpwxkFJ6Gl8FB5o=", "GwfW1R5vfpfgqxD8LlHqg84GEflA/wcxtfkn/o1qd8k="], ["K5C7oA/KBYn2F+fcv+guDfcGq2QM6yR7eRqTt042c20=", "EeEqQNJirojoN29i0Z7fQwk83vHM802YWj5T8LxXZaA=", "IhwXDk0Cokecbz5Htf9VeBV0+YDYkDgwij7zfM6EY70="]], [["I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "ArJX33CNLz1nhf85Epx/JowTrvh+6S6Qlr1r2NKYmnQ=", "Ikp8xw2vk6Z7p0wPLYDFsK6n7Bux9OF+oh/xR8WLChs=", "GM5DxC+qV3iOZrEbWcmDY7aXDE++kgagmGrHpEOLlsk="], ["J3aGSU92RLvEqbGU4Qck65Z/HcWHGOWePO3IIbKnrhk=", "J5B99B+id9jHTDcl5bi+VPSzXT0Lbleybq083j1DGJc=", "G36F38/gE8RXRthw+yEUmR1DEx+tv4BJTAHVsQXUSl4=", "LBWX+B3JUfCydEBWdnasZOobGE5l6yUpLMTaYdi/mCQ="], ["Aj22h4Tj8MwLhWGIJqmzUFEpwWR5lzsKhKRSnmawnGI=", "AkYKAyz4Ts0fVwlsnSH11I0bIavG1wJ316dZRpl67Rc=", "DHoq5DltsYOOXLHuSQp2jBd376yRkDGSSrJC0ZvpKAY=", "CMIUf5V6FS/8N+7HscsCnAfs+rzIRIlQKm4FKqb5Qog="], ["HTWdJF8obBLVDWY7rnM/l4rwjNvWMBfFezp1ZG/zgsE=", "JFazxIQaq7zEvLSVDa5KD45gzwUR3suLZ6/avsoNxZA=", "Gi5FuSq6jzb5IRDWiUHON9Of4n0Ct5TVP3uWG37Td8U=", "GC2Vtj7HILOvOjvG0KYBLUiFuldU8yqh8dkroTD+V0U="]], [["JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Eoc2WOzxiNKZuMzVaOsUpNQwfFyqlWM9wpbwXPyWZZg=", "FTz4Az2OihXN4sXmuT2kAYxZVNAKknTsXsbVEB6iJ2E=", "CfFaiCRGgj/cpvarFd2OJQ2QyERwUWZxr737DegPsA4=", "FnxlW/bPPg+2TJB1dzvIYrJLTOL2nI7BmK3SdYos4hY="], ["JftQtlrPT7BHy9OxwX2Xx/4m6pyiONbjSFUEhukcd2U=", "J/kWCAbenvV920JD+Dnkt+i7KTrBdv3FtUGe1zoHmZ8=", "Fvzu3XA7u8K8bx15LlAZORBbBEsbkE07EQEQ2pg8zcI=", "LqqSXQa29ad8DVyyBZh0J5FJXOyEWTpX7p/EyRFa58o=", "J5syRzX7yIPiTxkcpwOfmYYRW55vz0lGz0XwjO2i3Iw="], ["KT1hfX2nIQI1Xznr9i+RsG3rUyXzZ6RVbqHjHtV2eDM=", "CX1x8f1Xmg0PQ2prNhZc0jqfyrA60l54cs2wm0oOoNw=", "Gp/SZhESjVktWU9RwlHb9O/23M7Lzy6/MQ40vtZhM34=", "IeswpX5ZEqsG0YVz/FRrK/O+hA1fXt4B+R3Su7V43MI=", "E6uvcoibMTcrHm9IdZNx72W8V9KKwvYObSJ+sAi5bO0="], ["EE0ClasAyF6WARGsJdpHQ2ZZnldam37fYUXxS6bTwcQ=", "GbuKv2oBLMe4uXQDnGvm3zFEalFwKzmo2Qrkvn7DPsk=", "EQdYibwNzJ1vBq8wEvBKrc+QSd4E/Hdfj6CRcC5wubs=", "LkyyVZmj2/B94ziCeyjRa5yPyrj//o8qFhYb5qUho1g=", "DHpwCzP7I/xkLg6Gcd64TQXe2My8lo0VFxGC4VhoToU="], ["Cqo14shLrxF96j4zbNlqOXkrOBOVT+m/PtW5Dy9pyXc=", "K10o6NZIv/4Pq1njx9mDpAmfoKTFSN8ABubQ9OICBsE=", "GpbDfEYauKOO4VvCeExQltMNFILlfC+GG6uVWEuQ2Eo=", "Db3TFxMIv808uLimdlkoWLhlLpAhQr64/kFFAC+6jg8=", "F6xIVfKVo7j7jO3tf0s5KQZHoBRa9WsDsB6VeAjWb6c="]], [["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "GM51o19yl8rSvMJfDtG7T3xZLuqMaQOxmFBRHduDJ0w=", "E4+TNhxlRtaQFa1I71CvNPqeGcbmhEqEfrqdkIVyBS8=", "ATwpskwOOOZaG5QoYiukKTG9tl61l15m08SWx/5vejA=", "IRo4SF8enbQlN59LP+nCBHTJaKui74pLu4mKhCDQ/JA=", "AvpNdzgz2US+Rux5j30W6f0C9RwIYUGvXWms+X6agLI="], ["EZJPAv0ZsJJVqqHPRuoFGOPXv+70dCFglJEBHbC9CwI=", "LAAetrN4xJ/Fs3qkHBP9ukhr8yTq4OAGP/g1UYJ/M44=", "BRBxGDuhuP3gVbjycwBQVvs3aEskH4iFGltVDtDLxFI=", "FCAQVf9UEvg012HagBeWEhNmblxE1sWoI33rTQ9zTXk=", "GCF320GOzamebpmZw8BJL07Ceomyq1VNyBZdqbqMl2I=", "ERHS1NKgE+M/ytSNV0WH49f39rSE1/78+TPcgz0Tvyg="], ["JH+n8CIwShmU/1BUVsIgHvm3FzaUmNP/zkRmAe2d+EU=", "AW506cCTLHYYLKJf+n3GrmKyz74ZFCss4dlewIOdf6o=", "GhPnvu/PpVrveBVxLHs1C0ZcB4Wv59azVjQrYQR9B8E=", "Gtz2PoGyKtOIEbIKphdexBeE65n77g8+VqFd8MGsUXk=", "Lzp2rQMHt0D25ueqmJM1xgANkwApvuvug8BjGztDUSM=", "JN0cOOw+R89xEiHNr0ssz8CZGheM998vPRuI+Fh2PEA="], ["A/17Ge8shh8i93/4EPVOJ3vJTrdsAtedmGvj3N8FHD8=", "JN4AjEsgxN12mvo7N34ucvCnQzn1PD9rqLhLCoX76as=", "J0q4GVMkfxiiba6Q2T3rHzPqJDr2qsTgXhF+IzuSK9I=", "AWp5bEMQ3bwsQ16l7w1jgeFjJQwzSFQm6XpWarbyuwc=", "G++7QDfIuEfScRzahgDZQaFYPPL+BqiuArvCbhgCWbo=", "A6Aat0iNbKxp9wuQEB5ci+t4v2Wnn9YGjJAQ7C4P2k4="], ["GL1BI5w+cVeaZ3RD7P+9VVqB7u6mk1Kmi2fIVjwMKgY=", "KijyQJyzZNMbhYhEAjJ5QE4s4C04QwvneydVrrkZOlY=", "G45s9hrwZMmATxiIpqg/bOp8V+V0win5eKqSLdzNgNo=", "DKZ2nUODOY0aBNPXpvNRDYX7p/X25tKH1EeQjRHHEVM=", "ElQo/miawL42jIC2fosquD2BY7owtDkZJ/NSs789xbA=", "MFFv6IS+m62IcDKxWoPJHYQUfUT+FckJNexNQh9e0F8="], ["LXjDpdKN6f81vwoldjUZblcwyn9ASTJ3B4zXXai069w=", "Kv6xpjs3SlAhgGgBVnSBIaaP1wAhFHM7sDn3StV2wNE=", "A931xh/C6uFT6Urfq5sjTQeyYa0ihUe6khjEyvbLquk=", "DC6MZz8n9FrBES2SzIuB70r0JlfXoRTS1rzEt0u6t8c=", "DaXt7d0P2smvQdWFgeWuyv7mcaUlMCMgWqmit+HfhCw=", "KANkYSqt8x7lsXbMxUtKX5Ycx4IWjI+D/yq1tNEq3A8="]], [["Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "CQ3ym3DFp4NSFQP5KkV1PIvKA6dGJ6JMRNvKbsoyrEI=", "EaSOn6BkEh9SKXFi/RaeBR0VSg4gNYNiShbHNTRDC5s=", "Fjb9mgRXznWu3ggh4DZ3PjnDet9v7cx7LN1yJU4ux8w=", "LmSy4L1vtHVZ9YW2Po3RW0MAWKY/IHZjYFLvzN6pjsY=", "LLeGOIbMTuFkAhDSmkoynZOgQO1F8nRMJXMcj80V8Pg=", "DzISBG75hEOJicNV2wmE+T6kv5neFwDuAYWIboHy70M="], ["G0vFiF0c/I62kYdTANtaDHNirjgYmKyvi2PK0E7LNsY=", "LGKOIaIgCHM+FPgelTpQByrIAFYFVN+el5caVsUJIis=", "HLHS7KcZ3o6jUq3Mq83RAMT929OAhx4hkOMzkLi6se8=", "BqAXXg2Ko+G5lKF3r2mkC99t+uCcQdL7PYxZnHbn8Ho=", "BfxliaHR01skc8YawpPG1sviT6sSqQhsCu4fjRooqIM=", "JjQrixaSgygSPXJwFIIvAPT73izUUEb127a5hu3+tjI=", "DXVlmZ/6wSMgPuWgaZvUovTEkfz+BWdvkoaUcX5XKHg="], ["CKcvu1Xd4+k8WBhXGkJKVJU2lQKe7bz5Hq6wEnUcf4M=", "FWfY+HEZScA2Aw74CGZTUM/ptkjxPGdTea7dg9m4N2c=", "DJA3sbXLNFFZW0+KHKgMPXLOuT1tWN/o66AuiNIRsoE=", "AYPQba4aDOUxcaoJ8l8l7jlyY9utUwbdG3QohyuqvV8=", "B9qWu/X8RFh0HegQF44ZqJYxqV8uDNfl8ng80jfz2RE=", "Hv5LO/uzIOFax5+pq9RuShmyHzm8QBQzUTIfZY9s/nw=", "CQBQW95e4tVfW6qTLjiAW9kUr7zz/IVCGc9B0Ue4nbk="], ["D5U1mh9oRdSSGJL4PlALuxs9N2PY/HYkAK8Dmwq7g/U=", "J2MNMm8S7tGa2mCh9sSWaAQltFf0LomZ9JZ2rwtjemw=", "AmkgGUYDoRcnUlxeeyZ6tlgKvip5Enie6gd6VffsMgQ=", "EOXdeghixKuiTs5oTlAtPWEyqZ2QaQiyDrpPNGaBLkI=", "LTD243G6b6ZIU/ykWdDW4O35QcPoF3rV0zPU6uzX3Hw=", "B+2VL3wzcOA4gL/KY0irKtNbvfm36cJm54hbWA7dWf0=", "JbekOLfaxPCzYYPxh2bOUD9p1sHZzSm5htfSuLRL5DM="], ["FvAXUc6YUyiv3jTYFhne+0Pmx7Xa31LQ+CRy+853cNk=", "N+PBbb00D/gPSe5Pfb4QmLR0F2qSt6aWSmPy+7is+g==", "As94EJhe1W2JgVDdy9Qu3Pq2RC8NCn9jdpP2djAMhcU=", "JZXfvacz0Ed6Actmk7k+tMtxG+83hLX8nhfxs0LrFdQ=", "B9nrgE8KmZ7FhsWBZNqEZ6SBwZdeJ7lR9vGEEadEDNg=", "BWuN9wvpV3+UtvwqOpT3NtnHud4pE0/zpSTkBuMUMoA=", "JYoNu5Yfxhv/05dk/m08aHoQYbWa0A/oXRwYWUt+cnA="], ["HDkWJjKEV/yvpinz5tM+JVXo2IXjwHzsyK8fTVZZZBc=", "GBQjStZvFqNnEcnSd5wTWO9Y9lDKtc/ZWgZ4rzYiTJg=", "JZZbTblbxxBL/8xu2Zr1z1MoASo6GjXNy8rk7SRwF1o=", "AwkOsI4EotI1wWS3GlbdcwxrleWiYT05z9kyuQryOtA=", "CspeRteX4XSKpDjS4pZ1aZkt/NQZl74UPD69KoI7dmA=", "GObMfGulDmGTPeD2Ff1EWNOabDTC8kGky3jaud0bQoM=", "IW/lWm8ujaolI7Ze2lNnrTo6bFWFbFRH85iigOV9ZTU="], ["lw9nG5ujXj48ZC0eC4AyAj7VuskcLBBW8DllpCxSlw==", "G/t5dc+pAi2b6irK+9AgyFzT8QkXlNKEE1EPLXI//bM=", "IMJ6ucNlxdLeZgubMdSkBpB8UGtUiHh7vi3hgbduanw=", "KP6z7WwZQgClef80AEC+FyFxwfeYDmMhSgs/dgPWigI=", "EA2KGn/zGzByUZBYTIMLFcDMWkHZ1TDtV8C6tGQ2i10=", "B5HSQfR0PetK/UHZmJRIIg1aHRAb2W21qylouYGq1IY=", "F0nDmZURXu8U4byxzNTN/FySj/FOB4s49a8ybtax4Jk="]], [["GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "LteVMUxWLKC21wcHEklUI65r6iGM2UZ30G4QQzJ9XRE=", "HHAMIZuf0KwyPGfwlgz6lOY3rsSltoyMjFedpSEjdSw=", "EmWH9N3AALBpMf1ruSwkl669EL99ABo/ZkxtaTQiXx0=", "HTIgJacfioRFt8UNgCDz11W37O9GWr6+wW4NORv5u40=", "HT+lFeVuwYfKdlfSee5hPg+ZOtFG7is38S0ULrgQjgc=", "FGrN4BZ5rZYu3hyus5g2tNgYxo21Kpoc3ncb4ksuXiA=", "BImXzd6bHsbzvC73CLJ5KVltArNm9EOGCTEIcD9KYQY="], ["Dh9OTSbp2l+O496vSLSTYQvmHX09sdl1T+yjCHmtxkQ=", "F61q2zey/cNuQ7qoAPxKD8qYogov+cGEqDihv/W69TA=", "FFgxQ/5plU6tdmk51pOwGMnG2Z6GuiAC4pYGQPmT8Z4=", "CWZM5GcNuEIWF+75ekYZ2ZFARs7RdMWQfnMFQkZW1GA=", "BRMBdS8S9t6MI9wxdFsrGbm7fDnMHqCNCHOMNqXoWIU=", "ImI4ooZUrZc+GiWagmPGtK7EIJCTzo5WOz6tsPEUQXA=", "H9mKfO70ptOzLeixJMfgJOV8N0mPvsXkUbkvVmap5EE=", "H0cdJbt0SLaTELl1Z43a4qqQgO9pEkLcaHHmpoC/akQ="], ["DCmMFDVqWn8ibFpUnlkYSQA4Wq/Y6kHZdGcplk73XzQ=", "BO8xPKiOakbrOMmrqATsQmT3nx3QwFhXu99CeobeRIM=", "EXv/sJlvO4eWvPYvAOk83tmz57BxgHIfLAHlPJhQL0I=", "A200LcqeviSO82dNE5nVywKlG2zpLv7Z3jbyrfyDfNk=", "AVIfH62GHu6ouwaCZNy+aKk6u2B2+uL54XBm5P9b6Hw=", "LWuvgszr9gsPsWMpkNm/+HbOdAeYpmEyA8sHipyhpTI=", "CizkvCfLJWgvhOv84EjxRonzG0XjRrcT3+NXFrlEdDE=", "HhucGuhuxoi9ri/neItzERFKOo1vjX/YrE15o8uzjk4="], ["GeBwmC0+5nXhYiyiDROyN15Si2dnBoguuPGv4cUEXqE=", "FWLls9tC5OKMnDwIXPyP5lK2jovOGC5uHISrAmYajP4=", "Grr2N2mpqDeg0J4dxu+y3R3DErDBxKjAZmY5mK4EvaQ=", "Azjl6YkG9ooXyxhSu3e19C8ofLdOOv2wZv6WaInbIAw=", "LXTmwTsIVsDdhRiMioD0Hcoel5GxBCUh57rpS7NtSZ8=", "B2cvyogWkUg1zM277mKqQiqV13EY/lJES1ryAK8OALI=", "J2cY2EoGWiiBebI7my2P8/blXL+X2HOtH36aLMiglkk=", "ChvZjCJJUDaa95lB2GCRS3z8ypWWiZeG5r0IiUgmQb0="], ["AzPikjmS6J3uVwplASXtp1ogpy5p4QhjoZ0Xt77qkpU=", "Ghl2dNQMQ0R3h+YHkni1gSzLF5lkAzFeDwYjDi2+AWo=", "GuSvdNRDIAAbcKCiMDJ9WGsDGdU6g59f0n+skWkIUWk=", "CxafrRZLx2kMut0f+2qy5nvkY3bRZinWY7C4Pqe35PU=", "FUuCp0Zy4UM8NBf5zRxT1OwOTvydTCZV7uPCTkRJZV0=", "LFTLVgWNN736xZcI1UoWwcfO+AEq5dHNg9hxQOpzres=", "Cu29Q5/IpgxkHlW6DxeIDgBCC7vlrjMoVee+FGoKCyQ=", "G4fr2/Vm/IdH0kMLPEXt+o6k+Ml3AjD/QJH1jWz2th8="], ["GUSqxyv2+83sBDYSOMPE2VENXwdDmhtv9B9lKZC+ATk=", "AyqsJgXXcvH6bzKDecqG9DaL9nmjmTfPxQiljpgtuag=", "A6OLH8H2MsAniUwXu8RwLUVhZknY43WdG9QjnYnJz6M=", "Jkkspgy8gD2pkwv0CySrITapJ1+ospnPwmdO8II0rRE=", "A3o26RTlaPPeDWvoJPsksQe/yMd+12fnB/iqXwGZsgU=", "XeN3gFvKeZoW0HO3n9uwemcudZfRbfJzk0WTiiDFsw==", "Lux9dJRH098fHC2kFc/EtEiz/NRzuctYkfNtscM7XBc=", "BcU5vcC5j98j4sVo2KoDn41OIApto3TI52S1MOm2XS8="], ["J9gCrQGaQv0EiSrRZ9noNZanMGBYkEATGWYWdXNjWfM=", "HoOC3PMYzQ1/WLp3weRkHtNBKkgPC3ee5sm3MUewnS0=", "Bf5WsufyzfBx86WI8cYEsqtizzT/wdLHLPioYHnwH9Q=", "F3vQRYCRl9e+25la6F8hPhnB4wGmRqjKr3yfNJIEKw==", "F5q5MAtproubdUDyVsCUe43uDlMontC1t9DvCf0Qgmo=", "LCrTVXnwHSG2HIFyHeXyeHlQ+ssXVavBLmOwrenGbk0=", "DnjHxaM93NKsero287UHV71+hn+eZ3W+9QyFYy+HCVk=", "IBDWqqKhzCFBWnJ2ChqdjhqoIRHD+R4aNfKr6LefIIU="], ["K9BaBAoJh6xrwB9nJC1Ut6LFJ6lwrSgVsnNHHrliPnM=", "LzNwaKCrMvuZQ2K+VoSHpcmXTZ/yA/PbEyNIOMgkZGk=", "MF/E6TzRyCMGjlBj+pg/1xqYBIZCMeN9YQNb73X2AYg=", "Fw47EgRZ0Bfa7UMiTID2Ql9ZyiJgF4MhVDu1VtUBwJA=", "HhzuwsEJfEtHoFI/iclKQvUvLgEdo3m2oOV60Jlz4W8=", "AT5yuSDX3wM21kP/R/N7xEiIuY9+qAZNXJb4050Rg04=", "L6nYz8BNunx/gOrhFU1TVle8cBVFmj352+R+xwROwAk=", "KIrF440gtRWdTDc3TYynAt7LxiZbY5bTCywpWa4q+bc="]], [["AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "c0H92LbXyUpxDnjkeucdii0sRb9I3Nb+NG0vkmOtzg==", "HENQu6SM/1GrLgxWMBudOyiab8R0S2H7kN1b7DEQfr8=", "DGxCYhW9Eyzi76445bzXy9pcu/+CkyD5m+nb2oj6ij0=", "KBCwMXq9Y0WiNPvkZhBwybvRcSxk0EvIQwhH5qVDWiI=", "Fsz2AASGzw7p64WN5N4Vr9oCgnWuhjmLN6J/FYYlf00=", "F1Y4O2srHbdeSU4pGATFrX2UfWx537xecgCfEbacNQM=", "BV/oVoAY+C/Ufelwgo07XzD6f2cWcL8bYV+KtLXfbEs=", "IbjLX8q1rB5KjpaOlaE0cx+FyftIjSAJmMEVL0nTxZk="], ["H406nS0xqzLZvbY3UXDbuon2+PdNFuT9AvNnXV/iuq0=", "A9hgJ5SFRIS66M78mW1WZZTRZsmOjbtz5wwO6CnaNdY=", "HGt24NYOYo/Xyg19YN5zgsjH/9q+/M6Y1FoQQrQzASE=", "Le7N42WcsW+uU2sqHYHdxQ2kUMHpbBAKWBV7CycHrow=", "Hsziw5Sld7qZmCv0A1V0d2rp+/UapLIYo2PrC9G3Q7M=", "C3VHmBGczSbzTeKtHK76T8WG7E1ryth4ioMTMYAr6+Q=", "DyRjUrKGQjKor9iQtaXBEUEn/56A5Tm12SKz1TtMLLY=", "HW+2t8ibuE1ff6d/zECuC9uRQ4j2V4dH9i84g0QTnOY=", "GqtPze7smfc6lPXoUDs3c5Tu6hPJw0XRd8e5eSOxAU0="], ["IwxpQTlBb0BCLXE+E8BWxFw8Yxs0aFRSOXDq6lijffQ=", "IBUcZjZgoW/CbHRS1oOxrgpL/iXgHi0v9oLW+MWtkf0=", "ItdG4YqOtgWdaRPz0iGf4dGr/LIZNr9EYvPeq7hsojI=", "Er856Ph5t9/vqkvn1hVzaVeXXWs4bAzIm7gaGzgfBdw=", "DWOeQnaqcfl9bQYZKeCNeLaQBU15M5B8kZiYkdfgRJY=", "ItYhQnsrZUB/2iYhRiWqjNqrXie/mcuPiu9JIDD9QOY=", "H57T2B/xSUo+VV5TLOwUCFp9KJfKchz7QWJ/04fUxu4=", "EgLDW1N4lhto9BBBMnDGxetIYfXwFokanTEB2mfyTCQ=", "H8aaPoBqtQB/uTCxwOiDdSnzwYNX10Uz8UwhUhR7aog="], ["IGOkYa0GMVrlmSpToUu1mDZ2JK/CgzzLuDr5LKD2ozQ=", "FL4snupnCLgFV4T/em6u9fJCPs08mHUH7bTVf0ImPIo=", "HJTjAI5/scz5s2o7JytOv1aHLp060J/H/si3Pz7cjb0=", "GcM6G+8mlecs0TKnjEiT12JUD6LrM8VqfktviKFf/fE=", "ASnNpNa3WKrn1jahE2TwgWUYe/t8/99RyQ5/b+6qRNc=", "FP2RN8MIYSE9kIGYLpweNicYA3G/e93mQs6CErcKWtE=", "GDXDjfsPFrHsijQTl8+2YxfdVDxIhS2OqHWCfi1faK0=", "Bwpj9NsfY0d6ckXQV304+Oy72f2KJTrfXjbIbyhVmLw=", "HEVG4Pan7HaSM9DsVe2zz75Si4Ru0BXkHQY7ndQr8f8="], ["DFdOYo+EtrqdF7nSv9R0fgbdaM2iOD1kzjZZJwmMBG8=", "IeEUtQ0RMD59XjnWmrw0bYwGKzvHC1qI4NBMEEyJ5XY=", "FcS7UzzgVCLTIBzQShLZdt2NS0H/t328X1iQTZ/uA08=", "FPRfRJfEpnyQ9QvvWK4TLFRFn6z9qaav043QYRO9Cc0=", "FUCTskuK4+TH7LEc5/bRAyY2bEEBU87DVDuPjGlvX+U=", "CA7zv0zw7h1F5uZPtBXHa7kBsa6ALH3cL4/PmnxKj5E=", "EijCP51se3U3OhfUIfZLWJ1/SGUR+EaxnVtaekroiN0=", "B9TTrnAZwmrHA4uGbrXwuZE7VDFdh5BlI2wg7YfD8vw=", "Ad+QQhZ9uUjpwTffNliBohN7qor9zHX5mF0uKlT/KAg="], ["J2Qo2IBAo+D0QkJNL/y40Zvs8/tsoCwbXGG13cU865A=", "LXZPP53e+gZrRJrN5060JwuBnO4QpBJavrCRzcogR1Y=", "EGkTvE44u2hoJHo92yP3rBK3jWiN9MtMzg4qACcxf8s=", "KWjeOSFvPwUQf1cVyokcjMmiOIk9fHXoaEgT+bj0ifc=", "IPGUuFPDua73p1HTki0XQo1ZWgL26VYvVo4s8HySiuA=", "MFk+UCrJtoVhMbqNGH3+jVOtINTOejuNie0ijJEEVAE=", "Atra9E/n/KSYjVd3+TJKsqqGBt08SrTOwxjg36nQLXY=", "KzCwsl/FejfLRnWQR+TBkGotZLHaa8gEjWg6Oq4QWBQ=", "KvYg1Jm5CxuL37/tQ31ccf/lESsi1TijPJURz+Q0z74="], ["JL32EBsvIjF06GnWrsvo6lsEoUw4/fFJQ5PMb9s+QqU=", "GogDmGr1qE+a6rSfBIxn7m/7RonvMctR7/WZd9JQxMk=", "LJXqIvbfbAl1FWsI8WUWypBagoqqL641xUZbyZ69Cwc=", "AXqpEZTqPDkDDhdgPZuLuA/f0nH8YDGAvw7AtJIGp2s=", "D2iEiFo3a3W4HtIzKUNyz2XK2uMP+aZXq5NZLOuTXJU=", "Fqc5hZj/xBT3nW0NzBHrODC8a5eReuHZwEhvxqFiVG0=", "JZoqzI6H5KCKOEGZ7jvcA996OhsHyD9J//B7TaSeTuA=", "Gc+oN/MHSfvTOSXqvjsiJFLcT0VpyCbmAvI5cAfAqFg=", "Ir6aWtnzaVEpE6siE1Nu8eqSfZH0LGnDW+kHHTII3Vo="], ["GA/KGEFQwONUtLOkoHWCTUto6CdJQ/Tdiwxk7KJdxo4=", "FUDcMKG5rtrwKeXul7Y6Y/oaR6fFkwTivR/nlHzmd0s=", "MC+/ZP5wXuOjTjMhGTejy0h4OPOml+D3fBc5mUhodrQ=", "IC8/KPeG8wR/cDBCiHi2c6MVLAUAh0JjuZ8qPzZS7vo=", "JBRXaOYWvfFrMJngnp5W8RTD7m+m5JUTwsTys9AAK1Q=", "CA7LEzYvRFECht+Y9patUb6xJAFPMfyMvZ0trf7eXlU=", "EKLdfGvc/8r1sANAcx4toCn4HepyccjBmCUGDL5dtts=", "F7sSXKutnqU1MlYpy8pNN+XzCjvDx/EtGqG2MyaXT+Y=", "H1V2UFq2z3atuIuKheG/99HMs1aREY1BgANP75DSqHM="], ["EHJtz/hymchTIVmXZgdjPxvCrSRFPBurJrcmuC11brs=", "DwjUf0kXH9fWA0YUWAU/swWWASo0WspebI0wfF72gTA=", "Hh5Uu1aCZSmjf7a3v9avQNydpw5va99/yJeHp6LtB4U=", "J1wKwwRFyijHg2dlyYd+Q58LEwjluLW8ML6VgIybfAM=", "HT7NhiTy+8eu5Nvrkf9EKgGLmmCyPX5gfqnrL2q2wjk=", "I3UiRm6K1lxxVxfFJz1lgVoQGFSYyecbSPtEHZC14+Y=", "HyO3YFhqaU/9fLonV/k1reUrGzWTlorangJozXH27WQ=", "NggxJ7SpoWcZVMTsNB2rjYQZMixyIGEHWGG0HfYxqQ==", "I2qBP2I1VGAUrDpH0gvXW0tjV+BD4fuhigWsWamt7Zs="]], [["Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "I3bK6s5orH1VBMM6Ihn1x8WtJXhM6mKo3wCMT8q1DQc=", "EXOKoFTboZSy6CAT/rIipCV+rsigHxMfxlfudm9AjQQ=", "Img6w8acsRvAh56osqXIiuyyItJcaKZgovSZnN4WZlU=", "BxPHnZDqTwRJsBAx+2FJmU/Jt2T6SUo7C7rqUi1OSNM=", "DDchB0AOH4+Ok5ZMhNpG14GXqgRWFKHdcA8dzmV3lDc=", "BaushwvKQT2074THG0Rnb/fnx0HJtePzyO+qc+RGwCw=", "EcXrng5cFmnfkCNS417/RRcDPSoqlGqOX9FJKjoUEik=", "IMr46Hc3IyuMQp1/jpyYJ81/ypLLwVmjGVZ+ZGSAx8o=", "AYXr5ax4gHT0h0jItPZlZKWB5hWz35x4/F3bcLgEddM="], ["L+Qp24Bo5huCYk8ldmJzzZ/mNo/wl+q5eqoJvkxjDic=", "Gx0dAkOF6KO4HENe+QeaUtzsPPgRJTqDMl50MkQ+wCo=", "Cl8vGcSdmubW2KyrOpRLkyIaB056hJOd6tglBgYxIOo=", "C6iQPFo26e1n0hsil/BmFnYNi+s++Wxp3JyEO/UqMBU=", "KoULBxYUZJ9ubqTEOC16qZgXNoSMO9wM68zzvXlcZd0=", "IAkMjGsuQehBeMBwDJ+BseEosV9lgGZIxhZsqHaaswo=", "H5xcXNWKaCphVbLbOSPKzBlENiA1rLLu8rQh/lvZH0Q=", "KiGQ2vnef0a1yAI1oKRoxoImwZP/hsyKb/qnAzYm0JM=", "LatHgYDUfhl8yR2i8f8wvA+zXak0ujjI5Vh+AFzcLwU=", "DDiwVk9gYQMkJoB5SWzjZicdVpPtZkamRwrO9Od5qsc="], ["LnUIZ5QkOQgzZdIf52DH3+yeNZPGfeEqQlXGsBZItpA=", "B30hwdsN9a78SoJEIWXcDGZxv3yK5wjI+bbUSwM/ITk=", "G5dKGzl36L9nk5TaK3Auck0v3oqk5guDxjHeYQ0e6zA=", "Evd8MUGQ/2SexKYIeAw+970GWQKALyvUGpOgZm+4qQs=", "B2JsaYrNweTsb9JqoZK7M02WoPOTXlqIqNer+9reTwM=", "JpqgOlr4pI4gujFHlDwH4dGsd2DtrVjZ0D0PRRV5NdE=", "BF9ceU2XBrQ71x8qTU83a8u3bHJ22o+pQut2aVXFPvo=", "Bv93xMRkMw3u2RED1lIzCAnRcEXHXMok6LGwph1XKvE=", "Ap5Sk4HM8/gPxdVLfDmt//jC67XfuGdFy5dKIelGdFU=", "BrUPSQElrgvCh9AY1gxNZ1LqP2GtPpOWIsF3PfZ6f0o="], ["IyN5halrF3/3wBSGqw1gPSmZG4Mkq9awfbuW9cIboX8=", "K5xA6X9Ofm6vTTQrQg/K57/evDRgwSC3pLmSQOoNtTI=", "Dd+hYJeHHbsTN7XteujSvKHlukTkgt8T3HrVk+8npbs=", "Fl4goqjqA4L1bfOa3grMqrCP2duKdle3TuVLEUOTru8=", "F0ub6PNZhjmT5X4h5Mb71LSk0znZQ+3h2FJV7kiz/6A=", "MEuH/N1nPqCuWLunXCkkn5ZJE7IXCqnyPU0DiUII7Yc=", "J47DREmtHFGCOVpE8oJjFNufr6Uz5RilvwgglsJISRg=", "MBy+bkTpA6sZNTEmF3CSXazHG4ggfhj3k/WfaaQ0d3E=", "IDNDKEkP2Ggr1HBmIAt3+VCacqEfLZHUViIMYpKAqkQ=", "IwHTr0LUe0PIqAUmRsBp4EbufRgMYqXTblLdbyFb830="], ["FczshXslk0/9Qpr5LJENsx0A3Bw/uDdFox2BMepbqoU=", "JlXJ/SlNQLnbuVZmCcJkyeYCx3fIcBsbK1QqXwjPl20=", "KYmK1BcTDEcuDB2jsBf3Fm46PrgEge+jJQPoGjdy5ec=", "FoHtKRc4HNEhegyaL2dTU5gqQ4yz6RCPpbIEjmt+Mt4=", "DcB1CS+PgwCe5zzTXlEawT7t9eOZn5v1tB7z4aFaj80=", "CDf9dVwp3CwpA2xJf838I/lce/+5CmLbXMQ6JeIAVMI=", "GdSJ+h+h7GRBuCtzXb8LhHiMVCJj1MGuUzXkkpftS80=", "DrJdGwMiYkGQ22ZnWds8gryXGKmQKI2GURZ4foxSc1E=", "GQhM7OSUVIKUfP5Rofb04uIW9bVHQrnXHMOEC9y7qr0=", "A6mb4sdZidzLJGvzGlj4jfxJTOJWnF2LGKmodjF+zvA="], ["FxAq0tmAQ+VQnnbDMeayLV+2LQdHYIBqpnV2RmDrVtI=", "B5XVkU2HwNyPuu39Rq/dZFElj4B3kRLt/N8acdI69N8=", "LCAlSKMmytw+5ZWhaiwtVK2neTkPe91MT8lBfT5GPQM=", "GB22RzaYQetYzrehue+EGn8zWMxvIkFS3HrTwdOxweg=", "JueqLvTJHuP3BISfTBgfuDuGDaFfYvIlDHkuDuZsCuY=", "AXGJJJU3Yw6UL1rDnBSYvOOZlsFUANBS3LbLg5qkUyI=", "I7tKdvebd/n2tJQO8lOMfWDWnx/pki1mz7kq+dzQhno=", "GrgKi1+9eSPwz3lwfVb3Z30Qcekky0l0hnZqTEvX9tA=", "H49MQKDP4NBWA0M6DtLUJMf9BAB3sKFkLCV5fCDSLRY=", "KRd/aYvFqJfvmqa5FRifaJ78/Yjz2o5guEubzMKuM7c="], ["Ck7Kq96dHqEcgdr6jV1Iab7nrQv063g5e3G4+YnPmBI=", "DAZveh4Q0A/T6XzYxnISwotDQjsDykrAPvtNijdq4Jg=", "GmlHxOh8oMMO2fRwBOU7ekVFWxTaQfeQRcJAXS48uFk=", "JIH/Se1iWd75+mRsFnyIZAYcBM/AIgUfg++KPvjbWBk=", "DBNpKty4ZDeoYNYpbXS0JT55DK5vQWg7mcF2DQmSHTc=", "J6a+NcReX0ay7KCu3Zj2dji2ZFrOz1A1HFqfPEKLDic=", "BGYK9OY9HJ/28Fm3Xdhw35OJgOQ5hcVgejjcCsjSc/I=", "LrgwLxOB2RGNnHE9UOEX+Sg33KioYQ6d51nnbo7ph/k=", "6fkx3ZI9xDmKwSsQGqe14qIvCcqkFv+HRYIf8WWwfA==", "IJlF/kdfZ2f2aKvAReDEeubLJc2x79VYbabE5lXWjoI="], ["DsGCFkj93ESKFRKuzIrDdxSSOYGUD1VCc3pGjU2IfI8=", "EEkHbY3UP/xvTqEKgtzWDc9NYKISWhtNjE/5VOfaM4A=", "GSobyOfdYgMRagxA1YERhQ7dW1D51uiC0W+V+mp22A0=", "G+ri2qKml6/ZsTiNvNbJNzH7tOqg+kOfkr93d2kFUpM=", "GjG4dpqDjfAzSOAUYrVk4IhJlV77lo0fQTQvAv1ifeA=", "EvG9kFhZDKRaduGbWJH1v9yV1lM5SttPMgkMYFBd5Ag=", "Cqw8ggKAx2WDId96r2knQDL8zSG+lhdFgqjAyd5YAGg=", "B8IWGD8DpLfHcHDGizeQsxtfptHfWuQkN7aiKD1biJE=", "DanSEKQ6rk0TYleCNB7OHQIhvW7g3Epjm38TptqjyT8=", "DA2O4KCAIbrKeleZ7XsDc05Lm9NUMCedP3su1HPEjG4="], ["JVpJOqS+zZ0TfrdpQcQSB4TBIz9sX99dZcCDKvVD5BU=", "GaBdxb3xJDtXR0UZs3W6Z72D4SKwleQnLBT5ZG5zNmY=", "DdMTRxNrLron8FKOrhwlpxDDcHvenf89duy+M/GIuwI=", "JIzfJll+B0bQHYt6sOn4iqRS2Q7rA5269YZWOUWXL64=", "JXGM7FEvoTf4pYUVEMruDdLAAK9Vrwne52fiCEeWpxs=", "I2iLu5zxO7e7ly0NGNDgXFG/+WulMUvvCvLZEtxejR0=", "HujFRmnm8KsftqVMgJ0frSE+j/t6e0A4fvWUt89Q9PU=", "KC5XitJ5nKNhkbN4NYibym4ui99+RBJii+1eOYhdaI4=", "CDFhaYkWjVFMD6FR/Dh0uM7c+I0nGF5+A3y+kzkQIuc=", "C8U4DzSQF1so8B61zqORSSTfKx90XTOp45q4crGcT7U="], ["Eg9EZwMBsUNSSSlNmDPVngFoKvTIZYcZcnZ4/Zq37y4=", "KiW6xmDZDYXyL+gavcgMQDqG511PFDS6LtoxhNxfKDM=", "LRkzTT61qXgfO4EFsLETHuldQBLn+qz3GGR2K2/McBE=", "JntlXyaJY0FJKs2J7ceultvMJBYdHnOsZS6lXWHvw+M=", "HZyK2XP+rN2tFtor4u1+yiNbO9oBUh2pVvHIp9ZepYw=", "Fbn/xmr1rCqvvy3LGZpXu9M0yflx2QPX2n/WXpIMybw=", "JYFKgXQS6GG0MYmF/zy3BttuVt7OCMLG3CBYTtb6bHo=", "BBkOLhz2E2ArozHQGFtDyWD/XFe8L4b1yLzYS5XHiaQ=", "DjmZ9S7Q7H9Ib/FQrMhMJmru5yUpI0oBCYj5WhtYhf0=", "H8/bQ8vXmS8AiKmoXJXkYhhzZmEFUQ8lrldrwI1/IIQ="]], [["Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "JUooJ5pYyDj3OSA0qiHVGuROFElDPZCCS4F+RLkM0is=", "KB0szVIbwGDRUiI9RhlvJ7BI8zzm/7u7CITz1cZKYGE=", "ELOIzgx4YMinDE6QPmGzv5e4fjJMkVDOV2qt6LLQah0=", "A+0dRrOe1lUS4+TI1TzB0s8RDMZeHWWzfx5eeFpv5uA=", "C7rEcAVz+Vc6EjrGonNbY8SN+Sp8kc/R6IGGoGGhAtY=", "BAg+I/lIeDwy9nHK0DlXlKLPqKocHLagwBBVkJBLJZM=", "H6gDR+G7JOCFmXWMiVpaE/vGPfFN2QY/XuI+XKwWO2E=", "HkZceksSOYSTdgWqB8uMuDBZHiLiW02U0u/vLyXBfz4=", "El/r46cg7ZVvH991ZIJg5W5n0y0OeFeI0c+X72H2/2k=", "Cj59NnGiE7MYSsROp04SCFz1OAxoitI+gwDmkzPBI6c="], ["ARoTGjd4w3dCM7xUCWQZ1GPTq7rhgyKn53pRGIFmX5M=", "EfPu/nYp5lXqkK9wYbd1vf+/Jt/LD2elV4d05LI3N20=", "AR+JagjwOcP+SBoD4LjIgO2/cbeD0Wn0v/FL7V4bXxU=", "EnJwzmeaEKm5NkUmTtJw2W8Qnj9lpDckDWKeWe/xss0=", "DoGr7bz3fQcGtqSnQ4tanEIlexIz8EJiJcjUEN5YBvU=", "G9QOSxPA63useNJlBYalnyi37ia+AfoqZ35zQHi9whA=", "IiAu4+LfZ4JprDgzuH/SedHQRfxC6zrnUQcYitDjm8U=", "GWMBt2gf0ogu4Ib2GoPbR1oDABf5L3Lc8+vq7bxXFSA=", "DLUX2TN3CaVN2VjGSvxsithPyi9Z/jCY90p1N96+DS4=", "DZvkLOi7dr0knTa6LYxacLUtIMnIaGt8/jRtXHK9wVo=", "IkDi9ktvW6zbLWqgtESIepHRzg6xu8vdWOpxSZt6hdU="], ["KhirTcR3fhPLg1jBxCMVNXDRy5CVRCQ6vazUVHyOw6o=", "Hxn5uRabSXE7++WRVM2TqsGdA7RmhzNHP++sbs6vmmM=", "HmQlvqnbjuRmd37HXTEDzRGtbtJCg6CxiLWq3n1JbNQ=", "IuLWS8RIQblruShpcEORUNcMVfjWX6efGkqzS+/fPBU=", "IupxKpcFnf2K9gTHUuR4uNiDMz5nSbKs5ThfC6hpf2c=", "DBn8U9bZRq89f7edjyLEbfLhsNDyz8mDNF2zKHxEhT4=", "F3gA6JLN5tz2bcscM3tvf29s21Tb5+Lid2q7/aH8Z68=", "Ez9wagmelQIeRreefw//2yENh6TbHRKb1vpfYhE87iM=", "LFQKxFO8lfthrYeaVhJtX+x+2TANVFk4vNgML+7no+c=", "JXUGHJoGllShlf5BVUrA9AgNyPfoCNZ28/M8YVl41ZM=", "KD10h6o7XQ7enHQf51SIJ3Zwj5v2jHRavdOCUM5wwog="], ["FuvXgsvPbWPDi4eyfbKkpa9YR6mmCInEz2qjGNaGax4=", "FbP+MoIWgn6TWY4VQll56dxNm5q0IfJa7j5JvGBn1rw=", "EcuWoJS+QJ7KBbxC9titD2zwnO8rKG/llF1YfMNoYuo=", "Hlxs6lWYPJkXYc9wynf8F8N4moAj0nUlVLSdC4/Rvn8=", "JX1FiiiDx2CyleWyeJ5qlCuNUPpv0+sJOpargamqaT0=", "BGA8NcmMHjebI1ckuzCYhem1YoSmzbHNDTlTJwEJvtc=", "GylX8MCF9Xi0obWKIRQ8VR5UUexGufv2/90M9uWGoAo=", "AXu6qLDqgyRpv5M+xu5ZQaG/l/C3sfawzj9wjUN5U2U=", "DKDHdLG9HCsA/o9mmMsIAi5KP87PE9eZU0hckFt2+Kc=", "GwJlckoA39ugAch9zXHlwEc2phghsZ8w4CpLU+tZoSw=", "Kd3HNrHX/c4b9qL2hHAnA+hXs76BWZ5IWTKhwD9PoW0="], ["ArftR/rCddNPhC8JsB75QhAU3gQMJqWRWVsie6e8b7I=", "FaGvFfH3p3pebnYEcOe3zE2kjz/TWxsB8Bk4Q4HjcTU=", "FYELqibLqAnCknXeuv4oWc8jUBma8jK/kgSWxTFZR6E=", "ChyJmDGItSMBAsITzjWp+kl0PFSQNW+jBahXjHFvcgI=", "KpJDxqYbK3Rk8i4WAwCea295RvMctxz9TSkWAUWOw54=", "FLIW2Hm2GUnIuy/21DvH/DxjSpC3ZvInawpcawmTjLI=", "Kyt525tb3GoYRMTlx/M4BtRK2GRPoBF/W7/XGDdUuvw=", "IPVoQ6tm+GYVJ093Aw1mLh9s7CEgFeFIlhOf9tKBFtU=", "Dyox1GEldszAywA8V60ttyMAgAewZgVNEUqa4y2OYE4=", "GiZauWKjeW0stO4pgP87z6A+jWc41ZyM+4mct3H5ph8=", "BffKQk8CM46BknqJKMDwL8eOsdGgjDv7iWXMe0PY4FY="], ["DF5J4xn7lTUHPwf54FWsyvPj8ko13LRsq2ffxkjvrzA=", "HSK1WgtxMp7gOtvXnAoefTLvxNdl5uWB7LNJ4pQPOUs=", "CCWm2ozwITsYH7pJSZXvH+3x2Gf4x3fduT0Qtk8fO6w=", "GJZC2QB0tu+J4QLu/v1p1NaeEGzG13KBuXExX+yj9sQ=", "GXa//hBWIIWGLMWGo8v/jSYAVeHKOCp0MyMowOrOyvY=", "JRldY/O8MMKJbK/LzKH1tz70t0kpNZWU5EIcfJocj40=", "H1I6AVJvG3g8LjdgpOfpzPit5OMrVgAtFbruTreURlo=", "F8tnd+ZTKefFEBQqhc83gboz3jzrmKS6Ah14PSEudJI=", "EwjCubpEFjq3GQxMFRx/RPLhnrGG3IKiRDRGly1mfsI=", "MAb9mOoNnbKzMUT4heIBU07c9MO6bpbYoi2yvP6M7Ug=", "FPJB7NzKabAlEI79D78A7TREjnvYBNXoWoNWGXkUaKQ="], ["AWHkrlstJM1ji6XDK8Ixe/kNQE434APxBV2aluQG0w0=", "KwTtn0IijwaALAtTfdAUIX88REZwoMb4iztc4AGwGXs=", "DaSOuDAEZh0B30iegVa3XZtmHGGp7hMp+tA+90Uh3vc=", "G6HLXfD5sjbp98T2N90ecHhKKwf44GIIi3LDo5LUSy0=", "LCK+jlt/fJFJDEbCegnpGHLjYcHmYoeTuWdFaas8Cx8=", "CDUR+ZbJ9BXb5WeG947Jf9jIT11P+9pFSzxNWQHskqY=", "DD4TugcHVnNVIgl6QakTj1pEy1hWZI2vcLyhANI0axo=", "CxQzkwaxsuMRTlCwYHIV0/krpoRpDXjSpu5BenOTPGU=", "JcIEW+fZqRVWLHi8HqLZVBVaAon5AMdXtxOFlu3Z22s=", "G5CbIN1S1RGEtY0SOWK3+yLL5UiBEXJw0nlALEBW3Dk=", "Gv74SXUA89iTRZdMZ6IfHhj6kw99eKHKaRveJYxeLH4="], ["Ijx/xtJPxT0bQo7bjxxS0gzuxZIYfSx6awsUe2KSuB4=", "CL1ghimxMrDXQaMFugACuewUcEmfXArojibyae8AMg8=", "I4tGFA7uy5oyxyiWJraS3OE81RvDgS8bDYZpRcDgjkE=", "ClyiYxqDeaFj/UCTbmkTr6YMGFC54EtiLytuEJ0Xns8=", "FlZzfOtjotQ9Ri/9kCgE0RKDggNWABlh8SOaHnzSMQg=", "Fo33QznMXGElU9kc40tE9gEjqkDoSG4xd874SERSm/4=", "HRzqY5ObIZQPeE93wPee1SO+tt9UMpEZMIeLWfksf2M=", "Cido7g7fC35eaac05N6BKRNrkm5a0YkebPV6XDmhTaY=", "IsV+VomCK12THnSN7EbF5kwEBn9XnZa4m2CKtetaHjg=", "HU7pDMPO27mXNgk4LFe7sbdin8U5i6YuL496nFVJbKY=", "D5xw1u5bojfwRZenEnjboDFRo+/MWUz+Yd3xa1zxciw="], ["GuBg45szjQmEXi6evrcL+3TNSvkmIX9XMr4rbLf+cqY=", "CB5RIXnCe2MpT9yVisNbkcphyz/Nvk5mHORl6zsGCts=", "BkvZUgh+o/ck7Kq3q4kccWQUgkez2VNFCFWfKQqyxFU=", "D0imq6GBCetBUJ0WDStuK7dbc/LTYLFC4iU+mShaYT0=", "IUR2UFOQL7wVd1eOzPP8GZDP+8RkuNWVXjh2U+Qn7KA=", "FJF4824qg0ginU5fgppTYghkt/jDgprbHOL0+PYZipU=", "CeZR4Q7B/pi6K9I6oFaWxLxazSM3F7cGkGmiBjAffhY=", "AvmV+y/ppFfpcAMEFreBGpOzGz8u18cwADTPlYV1s+8=", "CY7MwRB4BtkFE59arYfE3+n/DR7swd4w6MakzqjFHc8=", "FyD0DWH6wPZkCAmbseNOOkiymtBbiRCnvCV+Ad4g2+U=", "GPzlDm9RZE4JaMRK3toy5ovCTCXoHsN85eh3E4PLduY="], ["BGGRq0HpOSnqUfGQ/U53OsjVCDMo1LLwSCjco+aQmMM=", "BmLyEiOkHTdmhASnWyeLhoq2AuMT6MQjeYtHxH8fVqs=", "DrrwAq0xeCdXpY3KGylbLg7A/zEVqMkx6/dP3c+3NM0=", "HhVnu4Y2YmNXUVpAsNXr6zUUIuGazJu1t+39qRZJhBw=", "D9zrOuLYpV8Hgi17kgJu+D7ovDJuOos1Il1Ye93iUgU=", "ATDgyYPeCtbRXYdwaY45+kVp84hI7gV1eVHP76HzOP0=", "L3viFhn9X3wF4x2QYHrMVeNvy1tsVflwFw5mDy2Bj+0=", "BTOOmEfU4paS8i+TiHXcxWEEZNc5PG2H3Xmbs7v4ENo=", "DcClyb8NWzh4XfWPsi7eBnCerIXyMGOQVrvxMzuaLSE=", "EM550DC8EqQ/C2//DYhMFcJjETs6bOOyQxjwpgFk9qc=", "IykmB3qvmm5C6IUpDGrXNvKc7cmw7VxaBTDkBdV3VrM="], ["FLobU4Pjczxj0Awywrv/2OVFB+0zv3VEyGOIGR7KPkA=", "Det4HjDs7ZE8IDI6o/hr5YXUzOf1VqvSwqCBW96Ht3U=", "qHfYaKwpPM7A9VnUjj3O1gyB/vgN3/yPcJBWZLO8Dw==", "HWNdEmelE8eL5yiOWEJU9TASs/eVUUfscVNTJ2DGydU=", "EgqVZJzPiZ/DqASOxK21moTT/1wpIyj2zzLuDBTYIno=", "C89uba6gcqU5+hAwphvQxvQl6Zgihu5GiuKre/G40RQ=", "HEpkZMhn1D61/c6Kcxhn4blzCrII++d7ycp8oBCnQZI=", "BWLmMJmnYwMj9wHS+jEsZUqJHmgqfgklQpwDIfYVViE=", "G7KspEWUR2DrAuVzYObT+ukwVtw1f/DdiILQiYO+MyU=", "IQ8Xqdko609CzI2/jWp4ZatTvQOBgMmhyaUGotuwYCo=", "J3QlpZcN45Kt4T9u43UmAAUIMNO76jVmQ4kkrVFZ30o="]], [["LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DIlKFQtwFU7Tx3wXDflHdprG/Y9BcNNBYT562u/GBcE=", "D3hMJdNJf7fwWNk6964aGCvqAOvCgGwZN36hmnfbNGo=", "Gk9I29oiCJUAtAJUWGfjQba28UvO3WarWaHxSC5PLYw=", "D2GwvH3FkRun01PiAaH0gM/xFqsG2ec14BiJtogHg0c=", "FfX47QlZSMWPLLYwubiSsSiUKcPGFp8m1FActLJOfXI=", "JkTIAf+823lqvxA246JAUUxFcI8LsGFtyfVHWrfd+Aw=", "FVgNLYC68Y3TELvOQOBEfHhRiuq9Avw9Zr0PVzwbe0s=", "IQOncEth7O9CPHT8hk9XB3rp5o/t+TxMJLMZHAVVLo4=", "JUMQ3zU7LRxyB2802zrYI6o1t/zqcSRxS9UkPZDHiK8=", "I8KlSmRYjTZy4eEeBEn8o3NJAT6zBHKYLfiTWnJ4CNc=", "DiVUbXr0JbWVQYWmacY8n6JdPSaeA24ncEUdLLrriHw="], ["D9VHhA86MKUzqZTR/bP2CuUHP0SE80vpUe4Wonb965o=", "A59eO6c2RY1mpydqP3/BQ/TS4QzOd5oCiPoEJHf6gRE=", "AoNMaks6cGiylZIEvZ31+eshWC2zAKxsybwGGIgU4YU=", "A2Whg20MlwrOpqZbNLQBj/v9IzS/wp6gUDAPvKWS2ns=", "B7L+fLJhKkuM5FqtsZJRRJCtmFsxaGt1y4lZOKmcNek=", "BMcsPpK888lFAUaSGVIFHde5MuBFxW0rjRIlxVegL6Q=", "GNRZZVSE3qSvXeiSLrZvrmm/C3Qq5njmrF75N/0j8UU=", "KNV1vwl4jmyfQExPKkeUxROTyf0mPOvCqrT1daiMHd8=", "FaeMXx1uAXbtTpMeJapCV259FyvCY7tbIvviod0Ja3Y=", "JTr5bcGRsd3MfaOZz3UfBTHi21z7rM4+/M8j6a7gY10=", "C9ZHek6Y7RtqBSp/5qPREfwkeLOBe9fC2tixqBPdlEU=", "HDcfQpF2Of1ZmS5t7bWhRLB5ol8kJXiyG6o/1v6YtRo="], ["BQGWcb2gJmcMf/qQgXlRBZY/Vs4yf894RR+6K9s6wcY=", "HJgH2biWjY9iBkDVkPFR4JFEBq8hNvkCUhuPTaGc32Q=", "EMvsrDMDZnmSxTfFTersWKNFKKL+BBWRqY5kqNbaVYg=", "AbwyMErUmBKgUYhviQThrwp2FJIj/nLpZSOTfzOaXZo=", "FdyR1vuYe73KmceN2QpXs4bpuf9+Sk+vcNWuGPQx7c4=", "IrJqdtstr+/M6nvnbw4TmgxWjpKkR60oglfvMQeU3yg=", "HHZlCgUn/pKb5Up+ikfvxlS1FVR/nNzVjBRqC9EYcvY=", "I9O53uy6JIKxB4MkV/u+X/ZwphBpzcNKZHDSKTRxIx0=", "K5prFw/5ziIkaqC1CRp/M6xaGzmQS2HwpzYMQ1/qpZM=", "AxYlgnHFwr5l1eQbC/b5kXyMYJRNG+f2CJEjbN5MJnY=", "AcZ8tNyY1fAuuW0g8RNBdzls6g9P5MBPhWsOLa2OG1Y=", "Jaj0SQpd9OHrE+LhRuDetN49Yz0RvEpUDFpqIZNLlMk="], ["KVLBjBVVjymyrnf8OeUaOV8XOpCX20BNt2WrApBrJ9w=", "Hn/PUUdoq7GAD/T0iE/1u2rx7nWBuW4phMKyxAMzec0=", "IYKNYD7gx2UcCjv2sYIX4f4z8oO/6qH6nvnuo7LDL7o=", "DecS/KnX314PZ9PrcxpT38fRp8vcw0QR9hONbeYPo2k=", "DFijN0ZI3jDtgqnuD0KU1JNxD+gT7fpGsJqvRLPObYY=", "FL5VmCISrlTLjwzkKhYqfstECkwMTXMYlSjksS005cg=", "CdpweeP/YyMp7XaswovNKT1p+SmPoludUjH5YR7OLCI=", "LYZfd6OSVa6hspxIPrSjrL5/3ZCc8X2RoBABQ5eaGLw=", "KjmjCCMVgtCh0AO1JE+7hViN4d86yGbbwv7m0dgkjA8=", "BHTFgsWe9myym5hPbkvZe/61pBxkhaymfcBVXtHupho=", "ZcxQWmka79I05XJkD2xzGZOq39tSmpq6S/Y3euKLaQ==", "Kq7xUsQTtO+ZG8IoJCgi4qY3eq6tx6wi5QLe89g58tA="], ["I1OmCva9YeXqwsmkJj1FH60HOAZU1HkjeNr3UuXMM/o=", "KNCZeULDs7CkrjsXujgsj6ThgJvg7HAdAVAfFCqkAfM=", "Ds8A9xsYFM7U9lJcR2WEZECqPTnnug5ORhC3C1o4IJs=", "EljVpNSVvUvmxwSZLdw+ifeuXGy9dDABRJH9I0von8Y=", "MFE83DFJZjmZA2uHrxDEoYP3FyJXK02VjP6p49ymGMQ=", "DGWKupDeFVOEzU1j4oWsLQBM2VouldoVQO9/EjfYUa8=", "E79QmMwFsQNeLyK9R6tAQditvrU8QKugSnX8XSQ130Y=", "IznGgrcITQTTybYHKyC2OxIAPlxSBDxjNroiI5cmmlo=", "LNNsS9glfPdINGY/zB44viw/7WT3tWjh8OsMJpsOFP8=", "A3tb7uzwYMtz1uCOu5hOtdkHWzGxKPo+UjTpaQNqtcA=", "EY/FHuo3VAs1vCrXfZGvFNrMFS+G2xV/9MSNtY4yUiU=", "Ke/NeL9ba3yYEbboOPVWOzSWBqGVl1HWPSj6TBEktb0="], ["DtajvUgXTjcLTyZLN0iLA6Xj9MD2HPMtMVetPjuG9r0=", "KHzYVblId6OW05wzbazbE0Uu/1kXqHftzhQSt6sk67g=", "BPBrf9zDGWBdA4iBy0f2F0jx6fFNR9z4JKv61Hpzu8o=", "BO7wiG45gWO58ACcggTPLZsKSjD7AZs8xGzKarP/5mY=", "L7BFZ60npCpMouqQoPJ2YOHhCs7+Yt6WYHqiZYNpWTI=", "Hxx8a7vey3rYosipG5g7B19JmPxiDDbijitZB3q1dwQ=", "B4o/0YDXbuqSLkI3/WW7g+1FYbJodRog7JfT4NdGDSc=", "Ec6NZVQpR3fhYc/ZHKhqwvz3G+pCKPiuqFcYfVebYG0=", "F2B7M6EEO88DTEL+q3lQeoJIiAj5iP0OE/LimCzlXgo=", "LJBBjHdc5E402d5y0Gp8LJywclGL2neCix6C/R0ZUl8=", "HPzttThG0JDnJSORTrM9bSeBuxj/GnyIXqwTJuk/ekY=", "Kk2EZDWAhIAMifb7uYv2nViRZPmmSPSNOkKqyMXL8Xc="], ["IRA6eqIMjRVQG+jCNQTGqRLGEAxdiAhcwuQqUjAvRIM=", "DHg9umkDi9FnO8O+1Rr79R7N54OvlQZ8FN4S9J5JVw8=", "HPgL8G81JaqFQW1srNDoJRvxs6dxvkklO2DKg/SbI2k=", "G25mOqEocJ2Dx+WoYoSSeSAEOSbPVWeLrNjuAyIXhJU=", "BhRvYrFMJcFawI0XVvIwI5VQUTik7hGEAAo49Mf1OQU=", "HF7qeGP8pb37L0o9rX4qFlcpmDKatpWt7NE2+6T0Bj0=", "GXsT+K9w9kLoeAY67G4huol47yMi8tZLtRLr/HvCx8I=", "Dfzixl4iCZTdLequ9uBFN7Ne5H65LNu9fGHMYYmtP14=", "D0tx83Y2ZqPfznUXtnRqwDOyOS73QkcP9zZe5Zdrz8w=", "Bvp7YwjkSFc/P90Roq6ORNM8PTzw2f+GAd8gxVxqr6Q=", "I5DRY8LAtdRhvlrh8tz0w4wqpRTLIrS14QTbtoifips=", "IckSD5CYjP/QMv6xqsFDkB3pz0LqPL6DAV6SdctnkH0="], ["L7IyVz6F1oxTbRAMOm6pFyiERR5new0c0PtNxMJ1Nrc=", "JmkT2lOfQN9RI+Aft0iyQXlfGu7a8feuPO8OVyjSOq8=", "L2kQ5QzIoU3dmbZnxiVb9m37M4bmK84NdMu0dBnDFXI=", "JP4FiT9eequ0TXBf6D+zGdKbUR66ALJwVWHGuwr9ezc=", "HvUnW0amX2ntzLOfUPuQzFeM5OUZ1UyOYcMeauBxCkU=", "E3VpUm7aZaMf78NSoAW9CxD/9SzFaS7cv0bMXwNTjqA=", "CFUndKiTxNw3XuTvyk27dCJ38H2JgMVFgbXU0Nwbdog=", "LZsHUHqd8qWHBW+YjHyqRGk6EY2q5mYOFgVh0nbINII=", "LJC0rXniMW55hrdXMEGP5dKx8lLneBc4XXjr+jRxCv0=", "J1++F8Zm9h9s9UhNsuUgg+hWxxj/K49NThfxMNKYnp0=", "F/V8gTdk5yjdJAOYaQQIznHcit+D5T9SV6w0tkOj7BU=", "JwD/AdzgkoB8PxQ0GMEaL522vub0eO3PcUXWmvZuE+8="], ["MCoIW+BA/5pwmtDHMjiw0eEeHRdAmrqjT8Rd4ptUFTU=", "DyWaO34YrdkSzc2GdLD4+pEP27+tlnvYFrM8d4/to7g=", "HkPwqJZ2TELrk755H+JpKPkce90ni3yBCi9YgmgxS5U=", "JoCUq9Y47gFFJ5kA+HVeVeGt6vLcIi9ALR8I6klTq7I=", "Lhv6Ghrqe0TIS4ZtnnRF5KysdfguDqirAzJiFMhPqg8=", "Lh4uLyBllhBWu2PwTBdcFoLv872Qc/1/12598OjxLUc=", "A6KtvKeUW5pjZ3maIMN5RFlzMzIM2BXQVKV5T2hGDIM=", "K6M4MIgg0jLN0BkVT8SXdLDIhMf4K5rrzm6iEdspSZE=", "DPyy43RCee+shm4CKMGzRkpASPSRDRcEK6GmuM0SyOg=", "JMs4ETVXdb+bvmQxMF/+rGHH3nxinZpe+E2WDMy5QN8=", "JXVA5XGnT74+xST/WPGD7gVg1Qao0Qlz135UydkGEWE=", "JlLh4De//sDXvhNV3hEXC3+RbRSKfD7juo+kSBfUj+o="], ["BoPmQOYVTvc8PNax0PD9huv34pLmP6hM8KiDwvH6qLo=", "AQAXGI/0ouDpsFU2yNB+J9DxlM8Gidg0ryviuT7PIKs=", "Kv08QCiyraXRlMWTu15OJxDMXDLtzVhltZ1MfsA34lE=", "Dr/hx060nMc7D2w/MvCWwvpiiLCgSCPikM0C37Xl28E=", "K+lrbca13A946/hEpS9sHVBWIjjb57lcR6K6TrwOHBc=", "Lusn8MWiBerXbJLu0KyKESwXFxGx0S0eBm/jUnF09rs=", "ExVgt3nICtjN0iqcO6gCkMdt52Gx3G54j3+Uk/hNQT8=", "BwOdXcdLTdL2oHAaMXm1ArISw6RQNVfm6K8Bk/B6Vmk=", "FrH6c2OWVJo4B2zdnfNswzhVQKwdfkLHmqDJzvxmpl8=", "D1AIyqW9/aNAFEZIKzzokcpJfPrEokyiVxoCqOzW54s=", "BCeUZHXARgsP/0rZletKnGCOJgAHWJ1xlbXPuJK65PU=", "CtLDwIOggJGpVmvynrdQaVLS7SftovwPUYlLXS4ortw="], ["Hwnz+wf39kdvrJiUa3N1CV4BSyjyOgesn8cHcUSsOXk=", "K7AH65aFv6Nz5oi+U/XW2v1vh0E8mAXSDFeZM8arESQ=", "KyKt7i7e3UDD3MjhsV04CB7fWQqafsLrYwy/xSkvI4o=", "BqyCN8UBFq0zaF2EAFrnJMxS4P9K3g1HsZT3kjIx1n8=", "IXzvnhHAEXjaQn4rn3/L5MHxUl1207p8iFAZFUXlgpU=", "BG59iJWDekoCiU5dbz6o1RrbCtSJdDSrDQ6AeSU/L8w=", "H0eJhvGCAgPpkkeyP5rgZSaghchM0xZV+CwXA3sd5f8=", "A6H+5PXvFKUK8nigtiJHpmaVcIWKybIHTfKLCk6TA6s=", "GIojwrRI55rzS5tIZslU5pimFjq5Mm8l8t10bNE0fTU=", "HLCfrGdjI2RdMiwTxnbrRkVEZjjYP63LN8TxeIrMElI=", "Jj2ZgWHwYK7g5r+5Xxl07+Rm9zlxXpLCeBKMfxitXn8=", "JIi4mvnYVuvC+QU7434T+eHlRhRhmLdk4ODteEEV2Uo="], ["BZjDjS4seN/kkHx06CMlyxkdUmCJVbWD5YJuvr0YV7U=", "J/56OHlyf0TaXQNcHuMP0StKbTekiJgbSQPZNAtnt9w=", "EQM5OTQcQVzzEyEhHjUXRMCDFAP1OmWDJpSzWt/qScs=", "D0e88Yno5LobSGKQ0MnuierRgYUNL/Kbl7ypFRjYwvM=", "BTCQNwzBDq36CdWGgQzQ2l7XBwgJmfEhHwCUEI4bPVc=", "AuLIAUBO69MCl/PsDd9eDdnB4KqwVSaOZHw/1HEt/IQ=", "ID8S/hnwb66qd7yLr0mDx2MIGnr0PcXnu4P3ieru5bk=", "GIN7ySqK89NyFMsnJLTIuQTmQWYOWkj3muSkmnvDf/k=", "CfBwbqtX8VGyPkuWi6C2u9T8gnAKzWATMzgnV6Fd4u0=", "Hn1twV60Zp+RSJmQHn3qqR0QKk5NVptAuaEdEkEWfvE=", "C8jQksXTjQh/nzT6rs7DpV7pFkaf9eI+YZtzRo7o61c=", "K/uW9473/gRzc9EYwKqgFA/0Pl3KvaJXzeI4VqZUtvs="]], [["DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "BdqYfxehdjIKghM5GJ0k/3g74H9aatuoTqcvoNf6qaE=", "FCtBD9+B0kibR3AnCEIrNanGw1gBROfz6UuXG/B5WF4=", "C5hDejEhUNgXG4GxiR88/HW50URzMZp3xwQ9jS7DIL8=", "AviMrIK3d8HHt1ESngvB0DhIESnFRugAB6amtzxSx/Q=", "KzevHbKdRRE+voiSvUG6Q+gtBF7u/KlTkPSn+BZjlBY=", "Dg/P7lvWEZ6hlpkrxY38/7pjLLIOB9m9fx9MBzjt92c=", "H4AfScxys8sa1tg0dLPpjMmrQnrJ0YB94VH/WRwtmPk=", "BauoHQSWiOxQn78SqiQCl+Ckz765HIfk0dcrrIrLM64=", "HvrtCii62XElccD3IA7TMuwTQsCKknB3TthIF//olD0=", "J2X3oKvnRlTJGCeHp9JS+WTD44yUah9FlXmSOwYbIG8=", "BUA4Ou4vd3l0LKUY7U1NdSmA8rXf9IM5wSist52viOE=", "GY0WDx+A54/R6TxSRNY21yGFlm6T5i3ND6jK0bdy94E="], ["Ky/18nUxtvPWqF114+CPOi8NrDaApsJtVey/gDyoBWk=", "INyzlWY2IgbUs47QQid9lm8DCStpEPOgXlscMHH0oHA=", "LjxdW5MbpJyZ7d7TLk9ATuvvfrCMqWaNgskSy11ChYU=", "EckA87HHcyCBB00KWAkd5/gmpPEGqTCJnTeYxrAtdzU=", "LPxMTzV1pfi/Xy72tRikf6yf6FNVjVhO3jQLXjLv9hw=", "B7ptLs5BnXWzfIfamwD9J3JZtCMlQuqsPWx9hchneiE=", "KtGGlxerTFOdrB+VCZjFN9EBUEsAi0a0fSOe7QcC+Kk=", "BrIbboZpPeS0PyZ3GqNHMHvnj8lYWpH8KLbw+AKFBXY=", "AeVOoQ1rfPBge1IkeX6vw7ZRtJKqdMkq6acKaSoZZeI=", "AjtHJEu9AL4ZscgEYUVia6x5W0uiK+tpKBC9/0eUrpc=", "FrobD/VNrMnYj4X6a7aZiKBjOjmY7/QDvVXzUqGVGSw=", "AvyhY1R1aSgOlTqUEzBH8/koGyILDGM0ZF5DIUPtuqQ=", "JizCncdDmHPoYulLGUjq7xBo2lLYvUk/5EqeSLR7iN4="], ["C2WISc5iC77v8jO30SJYAV6p+HpTkPVhSYHrbky0pfo=", "KBb65vzTkFPAnfdbxi91h15jVHLnkOKVqu4MgViWEXQ=", "BYSVYgBklrOjKWahpT0p8cZnqA5p5EmTEzGERW7MV6M=", "I720DcKlByx9DN6J4brKg8U7lj9BKUh8Gmj/o2z8Rts=", "IoN2fvIe476Q2sWqNeLVw5972uAUvWO2MDnRmwQvtXU=", "Gi3DWzwpx2OJXme3yj67nDRIRDHNLRCAVEzunQMZTBM=", "3yO1TJ7i/VC1iuEEPMfg3DoR8YPuD4Ff6al8rxhgMw==", "Fgpl29oLbxGJBtxQ4NWo5kzndl9DJ3AOEedT1zhuc5I=", "JLOcqyqBVR1dUp7VeYa47N7QKnZQ7t9nkl65761g3CA=", "Im+Oi//33NzRmA7tb4iiVmzZl9T3vsSE7yW/juhuuns=", "KqosEgK3Ty2rP1jb3JXq/S6knV46u0fzszy9TqE0dMY=", "D6oG+6lCHAIcYTO6+QFp9l3LRsxH7lMpidXO1UFV808=", "F68fi3HDZW7H0yYkBjmYZtkUcOS5EgQBMrkj+JHmNyA="], ["EYEy+8HNg/lRZ8tEc9VMa9LEF+J4Ll7+oW5y1HtItw8=", "HfakxDvFxpdjGD02wmtrN/vV5CUt5LXDwNprgdK8AOk=", "L81ZU7Svmkn9kLIyKRmNCfyPyM6v27U1mbEz0BAj73Y=", "JMZreFbJpdeIGXcrNe7w3oiuiCwZrzYDn3haSKdfRQs=", "FpI5TBRK7OMFp/AnSaY6NV7W/gJL5TKvIVKg1T1ZCjA=", "Lg8q+AbEw3qc7gudMb5iYWp9xuul5R7ZhUwb4dnrue0=", "D9qP7XQcQ4LGm8P2PEjAUu94S49nrVc0UaQY8vZAESc=", "AXNKAzjAplLRR+psJv6qN4WArJHQyIAbOwak9QtYDQE=", "I5ECqnNIXSopFjlhK1PBDIpynwnb9FmE6AaIMyGZmQ0=", "FcgQP8MeruH9zOr1f/GYzqbuulI3lpsDYTUITNFeG1c=", "HOi6nlNTvFDsinytofsjimQ9bRwDRJpa0baCaAeCF0c=", "E8xUZzbIWXVrWWus7f2INE5M/harzUTfq/EjTfGft+A=", "Hc7LLcV708uO2a6uT7rk9A5//I3tty40yEqTGNmGNng="], ["C1lEdo1hwbNWKldJ9PBsTdCFu1Yrg41+LvFKIf31JMA=", "JR4YBvGVHCoz62rjmv35vmuXHakkrpkgJG2YvENdnFk=", "KZUhLPfasNn+YJq55EEhjFGB2R4+L2xbageADIaY/t4=", "I/ENYjV0Z8fnHqzLc+x81cRNaav7kYSVWQCVBPgapX8=", "DUNeRWTTNwS7F27gG1lJnfhRq8DdW71ks+vfljXKOaU=", "/7QWWxueESzXfADqgfdR6aLUbjBx5b0wB/w6mH6ELg==", "DFU5Tw+6z4kjeLv89EuOlHWvfl1+I3O2XCBdqbG4GI0=", "FWPtJPRafmC2WgN5343IcaqrG1y9sk+fZ12utvoThCM=", "Jw3UL3MDTrv7zpGCpuQfuAzap4wGYF2zw0LA7cwi5Xc=", "ESk7rzZsB1489myfFKSJnh2YB0YPMK+UjkTAbUPTdlM=", "Db6S8dX2NeGCNUoGZ1a8EZwUBgVD54pGdQeYOnT5cHo=", "IrjZPXaom8NvC11qHsPGBTUQYicT4rgzSZunc9zAwhc=", "I7R40uTiHkeOp8hZ2j36cin2ovogou8fQG2fsKf2Lyg="], ["KwTW/7r3FEAS2SxcYhKAPAtbzA17GVC4idH6bz5WRFo=", "D9rvCB/6QbKjxvj0wjpZgPhbMwG/w8NCyTgZnPca62Q=", "AzoTXzi3YAKPvUsicHkZErDjAIwgB6ibMGIQhvmUh50=", "Lh6x6noWhEhs/Pz//4ySa+JnDyJr2IPRFZGt2+p1rdo=", "KL9HO+ydiEK4TN9HSkNdpBCCBLCco1Etbvc8GdC+QLM=", "Lts5euR4KRufSO3VBmD7wbXX2QaUf93cJVunh9ArA2Y=", "D6FXggpgDUp4OQuL6sgar26NFgfX9Oqwr6XX7mq8YFs=", "KD+mnQawcuuLJ8fGVbccrsBXEkqhZpJAlxwdBPqIHDo=", "Dq9bpAJixf62RsTzLr580qGuOKg8SKBODB1FJzDWMFg=", "IwZXdXijrLanwHDvBkm262fFgiRmKJXUcFQv/5hPVXA=", "LyBGFJlBZtCp+r9r9dtfw9rwvBZkXw8gKYnenfl8EWE=", "KpPpaOr+LvVrbl74I+KdlrVRIh6ZTwiAbxSMjTGOeSA=", "L09oTR9pizrvNKk53asrgGlvIkahMlD4l41Zemog4gI="], ["Kb4qQoNK4y3jMg+w7ka0wQKj0a5ExdzhUv3qtUUMnEQ=", "AuwxfUAv02M4CmPCBd2Wbgqf2t14uLlIUnO2kCsX7Uk=", "GsIe5MOvX41g+3jQx2Stz+DCBGOz0KvNO2AkCfJ3B0M=", "CILoXRWHXso1DE58TlmoIOR6g4EyHcXH+PeKo+GqaMU=", "KQB1u51I6g24noBfJpUrzbb5axUHWAtFz1bhjCGHHLY=", "DcKcQTqjLCGZot5elgXhEpseaBFjuA+Cz4RuxfVDd/0=", "Lc7ZNfgsky56KoN+KBbKxwv1DaOq2vt/gTa/lzsNOYc=", "EE3l+OWfmEif+kKSaoqpcBxCLk8Tq+kFBxBvKlpg8Os=", "I7ewXJlslj6ux8WBfq5tC/x4wB2cXahO9KzeUgTEmX0=", "F3p66bxY5kobO6oZdcaCTMgdMjAnQHCbDG+sDtn8GVg=", "FVK/APaWsew53r26UE956hbJrHVFhYjrioeZCMgMIsc=", "C8SoFww2igPED9tlEjvKrN7B+asFd0fVolYtKPR4XM8=", "JZMTL0RLNzFGl1X5p2uSuyny6J4mTOseKIGkru7CdR4="], ["GUb+neCpQ9WnFurAhWHNkfkDH+yC2pq3KIPHshixHrc=", "C1z8KiiVpvn1zpe/BbzV+sAS1nN9k74A3xT5HQ5ujUQ=", "EXbrQGyCcJsA5siut0N67iDQ4Us0yRttR1nUJc6kcvE=", "FR8VF59WLm+0PIU8kDDH2V2pu8yTULQIYjULQzn3QyA=", "HYPb1VEbbNnlU+guvOWpHdn0I7yeMRohHWUJ4348goM=", "Bi7bTOwlngB8Jqlb5Xb8klCIzUhyYLy2f+iNu6mTFgo=", "CjkOJ65gajUwdZyHcYbvJf2pd2QFKt4wy1Uz8K6HiSc=", "F6lhxMfwIRBeT6zOIBG6H29+TBjGUiqIebNxvFPuwW8=", "+6kKMYDon0m5gdfy02nxSzVPWGymldW+UdViuyTwHw==", "Gxewb5cnVQr/qRQW3KZeaUCuYmbEJvRqWypyIByb9I8=", "JKq43/aQpZ96FoY9KYft/50kDEaIWl/jnOFADBxmOOU=", "BI7SEy7e5HLZs53m7dqi7NfBJZr3xk6jaOZogtPOyxU=", "A+44knXGT2SODved1++NfEA02LD/kag0cFrTgyePH30="], ["GvPKYkClWrpV345Jg1uS+hfjmtVwHvcPgUQQn4lL8dA=", "JWbbuoURDMcIcAdDqqXHBhsXQ2Wo77WTi0vNgup5kpo=", "IFGXCY1oFBAMz2yQjrN5KwKUKQr+R5SchbDMBUpgvtc=", "DM7R+aNk93/kSzBsRTlXX4scpFdYxPy/7iNOjc2XO6Y=", "MF4g6huTwPxzMH9IJegEcdohHJgyPyO3J5GbY+QlAeI=", "Hkc7NXN3rrbJ7spK2s8Ou+ct9yC7UzBV8FbrnywT1TY=", "BW1wOvLxmCpILMVgwvTy2jLvA1bHPONfe2Z7j4JbJFE=", "Rr6t79HHNTRpeU64H1dNOJEPctgUMRWdTFMu7MGNZw==", "KtbONJiGTwrniGZSYvi5l1aZfsy+UNcDOOzWjdHpJSI=", "CLOXZOOY4p/+Oag8BFoSGANmU/6AcezTd5zG555kP+c=", "D/sHqd1JV4gYz5eBvq+JQHZNzS8HqrQSP0yfAwUT9iI=", "LntGr+9SYvYEQ2adUmuZmDZ4I2yPVDPNEw3vsGo5Ajo=", "E8cXkG5oJ5/Z5X5kGZhu4s/flrINIA5K2zE1OxmpFHA="], ["CB9YqRpODRAOA2n92BoZADU0L9BnfuG/UhXkf45YwsM=", "DZQoPliXjOGH1GPFCnJ3zTyA4EThVymm+OwEIvLvi4Q=", "BECm4S/vwevbgrXmnEYePjMvvSl0dMGKZTkPyGSaPVU=", "EhRu+wJJjBOs6sf+1oWw3Yj77+j1mTwMshsLS7hbEbc=", "BksHEvoVkQSCCsB+DScjo7vB0Slas5oQji7ugjATH2o=", "Hg9i94VzQZTnbPztLpFgBxbrRvpNkjXyjkfjZhEK+Y0=", "CCBGkCFtHS74Ud7l5O3Z+/5m8Jj7YcIxoOibu9npR14=", "ILrFiamVk3CGy3J/wlYe0FJInu+1jPzCYO79WFArGsY=", "H0vSUJP6/qeKnbkZZuYUXEZHKk7UavcQgmrMrCA0/nE=", "J4yFzuoj5MBAtm5BrZzQmn0KxtNFem5ZbfFFBfBx3i4=", "BF7mnwvN4T3Ml/WRDYIoEksWlFy9842zPP05M9LBXJc=", "Be8MCAPOYx6B/PhqfCcN7ZDoEnSF1CSr/Pp8Sp2n2PI=", "ErWERp+MuLXCAL1yG7LCmcXmNCLXMKO6pSJ0CT+fwIU="], ["IqhSr5BoCoypaItx7SfBV9ArQGvWx/2BIdfHeTrSMF0=", "I5o2KsTwfNiI+s3F4y8LQufOZIXpaX0U+0CJu2B06tE=", "EBGFsKjH0UK7IhxQ/JhA6cWgvxEQ6dxxezVPEAtRRCI=", "JxmqnDiKuX4IQkERD0KHIsj3LeI6buM/cEDHgfpa5HY=", "GKrL1K+d20JBhkgxSlOsysSvRzy1Tj2tkGoCELmLzfc=", "Ao0KwRFwz5rWYqLzHQBjOvF7nw40WInOmXgpdHEgrvY=", "HHbMqOc3Ltxzf+F1X3WYakZYY6ZlORQ6XyH4/5sPiXA=", "Cvp6fwIgBEfA6UPdYMRo6m0c0eABUFzhbrvMlyl9bNA=", "KO+5KkS35CG8pzsnS8KLz3T5THIS1yq2kTwXCThsXj8=", "GgOvAAzcRszBIGfFYLvaKpgRkEG/mtPM2QUyIv0utMI=", "JAn2w8w3iWb/rijrSt72f4woLYqQLbO6Rx2VQMADlFE=", "CtWQJaoefUoCbR+BlpWz94kLPZYx3Qb32gCr0OzZSrY=", "B1kdaaoo+/tbZdu29EIBBvCwkGFRMHuXb2uuzP/ixIg="], ["Cye6gqD/uYNomBc2rpJ6IngomFwAw+XfjBJ2sQAQiaE=", "LOsXgJV4J/nU+sOSFKToLomoKnYKn92FOTsoXe29gRQ=", "GCWSchJTgvEHoEq9wNlo7+5SfSJC4mMBXhIfxLCQtYI=", "EMl/WLnKWEJr2JpZFzzoST0uqNPGzIJ+ziRT7xk77a4=", "D9sHEP+OxZnnrVCGop1TqdGDThpMcfC2hGhJ6w38R7w=", "IAjGfiNl0uc6iC/j/+QW6ODt9KPEkNuwXW2vVrTaBUY=", "CHTb/cbXA1ZVmB+TV5i1i3Vcep2Ch2NSzSYkRRjWcGI=", "KdKUrn0C8jcaFrSDshAuAFUICVa1MzGqFx9Q3l2Xmcs=", "KqEO3TZ5i/RsPLe9dJAXhnwCmlTg6tVW4vFc/v+02d0=", "K0V6Xd/BBfID6uqv+a9RSeAsbPgKkyftUCsp9MNgJwQ=", "KczI5r54Uje42ZAJ3/4DeXnH2nmrIvsGLW/B9Z1Ipwg=", "DYKeo8EKvlPwFTtERvbiolDb15+e98RXRVcoJlSRCeg=", "DLNoCtJaNONRCJR0yK45tgkeVTvktnwr0fx6YqBCh+U="], ["BLRlJiB+3HCg0jyEOLxJo2VjVVLe4kBmGize75ZvIPY=", "HOce31uTWiMbDqYEArp1aku0XWUSDMCEX2wu4roy56s=", "DqhTcyNMgVziaTpzT+KHBdxv0/spys0Ln07baUwVZyw=", "EOYLAuXAq7ja5H76F7BYLflKO668UrzOiCD4WDQdcYg=", "BnrJa3rhYuXQtDcV9MJLkDHAgrqmisdjigD4WUvDsSc=", "KT3EULDlxWChWFMSniOLBGpBmsbwyOwZppv4xAmnPKs=", "B6Lc0U+wF2dJZeghdKNd7NqtdeQqzz1awaHiNSV9H7k=", "Bc+LDzgNKb76XrdaDAMre36vqJXZjgvA6G8D7QZsmHY=", "LQDd6XtBUBB/2b2FnFgyhE5r4NWpnMZ1LZdYW1YMSyw=", "BvKyEHM/oGBaDNdT+2rICg2JOyvvLVRT5fbPy8ahQwI=", "FYjokvny08an3OifEys9vsFCv0heIUKuBdt/tdfOIR0=", "FMkt+qOh+DCyAVAJP6Zw2+88DIB/UjIeX80ogHF5zKY=", "G7RVXYxfi7smg2HV4cIvlVX3yfT6uqJDVclj7cJjr2o="]], [["DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "AlJdok4dE02emJg4MEr2UmC8no8xIlymA0IMbyJ4KjE=", "E49C0wrgGYLtaXvlbakjAhyl7An9n96v7K8bgVqOtE0=", "C2jq7WYM0sr9KsRH5rX0SkrMCsxZN5+h4dbWwj4p/Rg=", "I6h+/32sJnVgSLipnO8Wu9Ttk/CFF32hXHY7+91BOnI=", "KYsiS1NdDTLpcZd7n8Kz+D3wmrVQr4C4OMLhMIo4iv8=", "Ah/X72bE/zdOhbVS8MEWKDGvfy4f6qMOTULJ/+WF5zA=", "KnXsD0O/AklFbvXLHli0cW4TXhAzeRtwbBGY43DPWRI=", "IXAFMW/5g6mIq7QVDVuJ/Vj15++V0nUgevq5vHNtz3k=", "DSAPusZQCJklMpTsM5T1/CN0yj4yQ8NM2XxfjzH3jts=", "Ilgp8XMM/rl8zbWx30GLrA92HVcpOjnV7CkwFMePOMw=", "F7CWJas6sgt749pnQOrGRQly1Sl+9V/0vuR4V4QWheE=", "C5jZzLXNGXmgxFqf+Ph76PFboct1jGAnddKlcR2rj3A=", "Jsalltz6sR8F3ahhIgNLbyBGxRwAJMTGc92Txj7Mpug="], ["EhhrsiAArYS2vykXmt4tTn6U/wflFifglYBXEGH6jOg=", "CUXAWU2WBS9wLRwMjUI8xfBUvKEeVKk5Ux5cZhZpaoo=", "GomTQAuv26UytC/mD6cZ7iu3B0TJaEyHQxrUYrafYjQ=", "JxaE7E7SVkaU3Y/X985S9XPCLHLoJo7P/bPzJWz5TYY=", "AZnV9E35LELN7bddqueJSL0bgS72PnLG0B13ydUTvDI=", "FVTHp46XAhLbAqDHR4wCND3erzUNUq1GCWbCGYR15dU=", "Iiq3vlIJchBjj3DRvPOtaEIjDgVh4a5VZRntbkSrVqk=", "A5HnTZzpREgS9Cz74VbnQD7ADBCIi3FhMsgZVCmC2jo=", "FF9I/eUaTH8EacyiogvVxXlMWUwI6gY0ErguTCH7Z6w=", "HDRtxHEGtqnA408ralmqB8DiOn8NzXL5hpi2u+JECp4=", "HYgfm8bApprYxM+K4IVPXjnX8SBUPucvx3YVam3EHiU=", "HWQFx7vvKbZSbfdbmzpDdJ9Vp81gwpVuYc41RGoUBV4=", "Dh9uB/GnMQ7Qr2sI+6V7k63xesQK1bM0p7W40rIYIrY=", "HcARGZh9KgJYmL3bHXk4W5mWDpfBACCLXpktncdO5gg="], ["I5n6pkiu35Akxqw86v6iSCFuJKnlbK9azSnOJUap9rI=", "FKD56Jp70vnpOigRMlb1kJ4YvY8tTGpLkfp2T11umBM=", "IjzzdE+oAu7LbjO7XTRaTi5JTi4IaClqB1AQ2JFZbPM=", "HK4zKWllde2xyY3xaiDpeg26mYhgH+JKasMnIz7b1+8=", "LS0tee7bRz/AUnBavQe119E6qaUr+go0spvMsnaM6BI=", "AT2V+UnIPgnv7HRk3xj5Ww9Wn7Q6rPLisrDRuNakrV4=", "DbNntQyWxa1xQQTlNfzeXMLZinNY3YW9mM1Oc5iYWHQ=", "JNVlODlpsYjykA7id0HkhQDfqrRhllzPasxykMXAezg=", "LAjTOqB0UuyNMP7ZrF+CGIhcGN5ohXOVtzYdBtXVDGQ=", "Lrlp1ZYBBEMtvsTJJPgpQRvNTrJYJQiET7RsV+S5cd4=", "AYmdPvamZlGycDX0egAw13CFuYi/sllTktRqCeymaOk=", "Dc0Bi1QutRRy72NWZXMZLxZ7ikGyQ9L5z37+BCe9x2k=", "Aedqv+DgwJB5g9SbwHzSI5LJqfuhytdz+Hh32FFOQQM=", "Jwd1tXNiqW8ULPBWCjwfKPi4+EsWlc+iCycSF8uUYLg="], ["A63Sn+OY7S1E8jMSXs0VCePO3nfmvgi5SvT+yH6z5I4=", "KS5IXCV3lO+OH+xdrN1spp8WhAgkmm4gOFNhUIDNLNU=", "IqJsJeNjHxVMZEe6LoVDsdD4RUvQJxaOcV8hyG0J05k=", "IBPv5d0sBU9UfVMv1vONY7883AfBs76uC4MMU2k238I=", "ELmbBNeo4JBZ4oxyPbFst1UolXhYw/mYjwBQ0Yow5mA=", "F+NTKcmqp1TDRdbrMXw2h4iwk+0dLRNnFOobL3k9pYA=", "KOx9qOpDsordZp7AXAhmwkmP/pm/377IlrvXDQhyD2Q=", "FFEVUY9N3HqHjEpMOgzaNTFCtCDL/K8vLrfWfGgX7Rs=", "IclqItYPRMNPVDtQhqtPzewDaygLn1pko6IAOip56QY=", "L+Z6N5K/pGVFujYzwtUE2XNefQO1j5II9YSj/7PwSoI=", "DCfAsvhoVrI1AAeoUBIi18fYnAKRnSoxADLE7enabVs=", "B26wZ5o7xZAavxIE6SRi3QBJyLgPDQsRDqEsptnaWAg=", "KLbKXXJ4yiU3sxZ70OjICUoG/zRT4GCh9S8HfOPA+cs=", "D3A2QlyfS8CHV2QZ0FNGmK3vaKDe0P2pCyEb3NpuBdU="], ["Ehr2H03FuySJCr65JR5c6pR3CrBi3Awou4mV3Y8YNjU=", "G3W/bMMmVRH3hmCRefGLWCobYmHp5qnwWsfppLsBWjo=", "JrkL68KVJTx5u8jQMkzsmAXzcwp8fjyM/nIgzJCy6pE=", "DKNIkut/o9e7SXBDvoRiyzh+0FX4NWaxZafavHW8xiM=", "HOD36jUb5qp4497Qo9adad44kMq8G/z0BYMibezDLVQ=", "G1ufmsJqLgVN7KMkyckr9NZLC3vnKWMfI1DE2zIjJ2g=", "CUcHFJ3FY9t6RcXN2ACRw5cr9Spu4/jq8Oa8xqwOOXY=", "Jc7qLsn+EZlNXWwuKvGWlj376BEs+820nFuAYVy93ss=", "KVLzLYRqLP8VyfAo8C+2C/zYp7NO0SCrbjk6HsJ5Sks=", "CTAmQ0Pn9a8rflpPfyXQvoWCVmamjVwCxagT6VjDJTw=", "A/KJ2yCXbB7BqvzQ2rqcOG3Y7bjldzEd2proCCNpiRo=", "GD4YbCxy9KNcT7se74I34aqiN53Y1h+sxZ1uX0TaCoM=", "HJIcRTa+QqqKk+wKsRo3Ix3LwMqat3SePVz5kTre+os=", "COyqV+VdIQ9W2cgUH3A5TlkYViXfV0Ne4sySRgIhIgM="], ["LKj/7i1Y8pRSl7AM0LUR2hZwgNU5SbPx/OrKlha2FD0=", "I4lOAlpy5P/RWAv8R0iiclq28hSo+E5A0mblGDxtuO0=", "JgDVbp9yi5gvI3Rtp6KZO85XjnIEue3R9HRAW9dZMQM=", "I+OzVoeYr0OlYWFK8siu5A0iSdn1hFKEfEU1lNyPONQ=", "IUWglZpGs8Q7xVm4gR0wnUikUkIwJbhcuz/ryyT0Bm4=", "Lxcqz0/NJvb5ORV9DaFby/+pge9rIvdSXGn56/gBGS0=", "KPUpk0zp/s5kNWrPUj8yRDF4Zp/3egrW57hgIOQTyk4=", "CThczdAy6HhL3kQSiG6aWQ7IX/XL/uAqbF2vyuuQJQ4=", "KkueuLL55MTy/TNBhaRdDSNJFjvNe4CIFbLolUPAlBI=", "A7sqW2WfH1wsgrvlgkrWSiYOIeaI9f4BxhYy/No0its=", "KeDCKg20RlUkA6GEc6Ll2SPw0qgbI/WTh33kZX+x6Hc=", "C7hfNSrVjY5ZmMrFeg+6HUk0mq5HFk+6M0OuMsy+QgY=", "JOnHHFYHUZFpAVzKXwvo5BbyEZT8fWEKONPkjfVt1A8=", "CgmLZ8wjHtaityvuKfgjcCtn3QvKePcxZUMJeFa0eMw="], ["LJnvXgZBR9qXgrkUopS2wU0h6n7sH3LodhZxBp2CoTQ=", "FgWwvZamCvbTzk/uq6dJhXG2k1lvecCaNIXLbjexSA8=", "GzIvSpLTNvsrkuE0fg9zA3ZVs0T6bOsSde2luqv2HdY=", "DeRJdOkd+BUdON2zN9vvt7JCP4wtszyVJJZkJWBJRH4=", "HL8uMuSDCP1SVLyEZu4bRIglutzQ0DgXHTnXe9YcEis=", "HiWu+CiuG3U3TRgGBTODo6/rTCR7s/T8YCoxJYEpCI8=", "KHlq8rRuRIHIxodn11Wy8owiKYksCT+qhuptrM9PQDs=", "K5wogb27yrYMopgcKLQij4rUjmSns5PvTtCAkH5qF3Q=", "DQDUAMiAnhbbJfLxWT26QDzqu+PQuGg5m/EsHOKmKE0=", "F3ZxaefRY24M2rXSlYjpA+HUNDAA1bVPPlI+lWr2/Vg=", "EuSz1xB+i79zwifD/gTdySd6roz4sVp2nHA50oJmGGY=", "D1O6zenJAFOB7XvQ06NQSPmwTZm1TK1Bu//JcEpXSrw=", "JB4LtIv2MAP4WK34E0v+yQIUp4NvevG90mP1rJGQaAM=", "EG9wtcgrakHkAfs8Be0NSlwdarZqsEjSqSijI1VmMvA="], ["DX0HzTeY9E2DKmVxwhcGdYaT5ek2hM4tGl6KU+DMZwk=", "C26kWaPuqZEsAQBawCTNy2DXffA79tV/nekneFX1Zpw=", "JvdJ4DmxtY6f1xTgte263SuiPw+uzig0irjrNhJuSns=", "GoB3szcPfmXUUODlNuHnPJzjNZYCPeHLLU8TIYlvUYQ=", "L2eE+gY2NI5bc9UjB8Cdx94o2sEiVplbfS2AFL4VEdQ=", "G059dt2Mu0LB6QV0tPgyoHpTkS3HSy8Zg0QCUsIyqwo=", "CTZ+zVM2NDJ0NfuwMXv9TecgJhvWx38jSPBUfU3NFV8=", "KQ5/36eWyaahs8Lm10ZgH0n+vaKvDS5+3oBLgiQA6Bw=", "DVMsRCnXfAhnnstUGGX3IweHOBeG99mNYqBuin8z86g=", "B47GsZwdiQSaAeoalZ30Ul4forXG2cf+AOzYma9bhpM=", "J5MuqASIXZAcCokQPCmZXvIH51NXSn7WebFiNCxU8n8=", "Ag/dJQ/UNKX7kHLFl7lAzJb+wphv1gNSayvsxY5DHIo=", "IR3TI/+2vx96DHR1l1k8RAU8PVrUKLEUXQTwpyj0GZo=", "BDe5Surv/45jaBbR90hOEt5g3pGZ/imMOoRmA2/ekFM="], ["KRlRFxBmI///sK9SXIOGhtDZcln8c6UZRgmse3sXExM=", "Fr5KFHQU/4CAsqdEc17oXiMnw2ReJqTSGEa72g9fasE=", "FTAgBCQvQYtwxwG4njWFrB0s7ycEa1Esf6hB4cf+Vk0=", "EDCZ95RSzmyISOULsEtQcjr/XvkV0tf/oLj3K/u2qQY=", "HN3IR9L42ebCD/VWKMxOnO/Fmig6OIQkYsvmCpodAzY=", "KbtVeqSHac/4qdCrDnFJ+DXFVS5eWufmOEBDeQ5Fwe0=", "HLL3/amKGKb9IN5vv0EtB/D0H83yCI380OC4Uv37Gq0=", "DN36ltsCtA1490BxbWqibCxs8SV3Kpg1yaNKkEZwLbg=", "Hw9zTpWkXPB7cLhYRrZf/TwerBCpXguRfyfOJcDuSv0=", "FOwiK0uVw7YCwiJkDY1tyuIdq78egFY37Dv9iYRXfAg=", "GPMdpCdCGLJpGrqWEaeYy8npQF8REmfL9CSmd5nvZ+4=", "GKOPvAT06FpocWFUSi4zI7x79QSlzjToukM1dny07t0=", "IYuPZ5tvL2BwUZZj9J1p/ZBDum0bzXt7heglq/i/7Nw=", "Gj1XDVozGuQck46B6BVd7TRdGArVukm04btw7qtGejY="], ["AbYtSxfeZzdbWPJIqI2/cHzJ0UkbzgCVZEygIZoB5Ao=", "I9/LQVXjeO99EnOD1meFszgIoyI+IqImo+Og97xSAKg=", "G7ol75DCdC1rq5MJdH/BTMc+QCTIA9teWMfSUlg5sq4=", "BLPDaHEREHtrOf3h9eq7DeXi+vtIHAhF8Onj5fkAV7c=", "GJrrRU9gch7t4BCgBcTOVVCfFS5tDpPoxfmpptOtu9M=", "GFcgkUZcq+uWdI9UgtN9OSa/fB1mgNyTL0X1WnBCsC0=", "GlzPfvRRoUs/3FMaUoMXKPXsJrhrp3yVJwHbKROmmN8=", "FS84y5gI1clCwjYkq+iIUqWfKBM5IDD9t7F1MCWCmZE=", "CeVDpi6TqjAFvpESpJxTCPW295WRtIJPY1WuEjAJiOg=", "GhRfSa448zKtZ72Qc0uL+dl9vFkSy6yPV0F+M08UIw8=", "CIV8iz8LmnZJgFNxwBp0yExnV12aF74OVZCqtSFDN34=", "Jf2jV82rTKEwMUoB04H+v4EsFEc+S8mxPOiEnu8cv5Y=", "J7gx/ScngC9qhzEJrbQZbs5In7W0gRNWXYETQnqtQtc=", "DrjG63sqAMtF22P1jlXXjxEw2SpWCVtIXGYr5pJkRzM="], ["LhaBvHwi0kxDP4HdOjJv0CQr/H4r3rYwfk0qyjKt2h0=", "IkFcoQtlyDoDnxp0nmSfvaDP4v40A0d6QMEGia1a8Vg=", "IcktI5wTe5ooCnKKy9BYqMdfMh4NJUw0au8rDzOQsH4=", "BB/ECeE6Yo2WMrhzhdJL9PKnEuNkKjbJh1y7XpACgGU=", "BoUK5WCtmn6Jv0VPQwDKxfUYRFOv5J/TVS5j5E5yrFU=", "KR9LeHCK8ubSAhvGe4tDF358BTOuHYkodhLYXL0WpKM=", "IquipvgOkbK0kSJAxymD8CekwViRDAPMHP9mxUX4dQw=", "IuMxFtoiKDFr89aLLxUGu1tbh+1Vaq/k8cFjj3I7Cl0=", "J4hfzWbmob2h9VWZMovaU/Dbv4/jnY4CX9UA5E/9zuI=", "KN+2bfCJlBwbZMQvAeAVtfO/h2RFKt2bJPQGW30nYkQ=", "Ll/7STz+6e6q4SAPNggp0MLAndtZLTfQghNjr/bs4pk=", "IRV6KfR2E6gL38d00cgnirw/duFZN86bJBduG0yeO34=", "HMkBRQYhFzCvoenkXJ84tuYhjsZG5539OK4MuNlsz/w=", "IQOWwb5yJASBPcoPBS4yHhg8AN0WcQRLGL3xVgsE7W8="], ["ZYUNEdDsqHw2l7b15X94yoaVK60ckEfb0utr6enbMA==", "CFT+wcRk4vutntZzf0UfTqJ7ah2XNJlBkotZEbW347k=", "LCQK8sztGm0NWu3cNsh106jnQyV3J0jOHL1eAYAbGI8=", "CASSFoR5Yzn0AlmFXrUfEYJi2lTB6tA2Ttc7e28yjc4=", "D+pWpZpoqdMTH5ZnK+BPB4k3z64BuxhcB0vl90o3siY=", "EfYaOGBBExbu5C37c1sF4KtakFokeLnURqzQ+xQD0A0=", "CoD+40WB+uMYisXyxarJST5tsS7nongqA2qmXtifOCU=", "B1yGI8REYuSVrEtiU2x5ComHXp+1WeKftRwy1mAe8pc=", "DU7nQWP+OJAx4B95OzzX92lxZJNy7wdd0/JZYzPFpvg=", "Kga94TfrD+xYTP4vEcLKQ74luo3DHgUiGRy7Y//FC20=", "I3J3RnUAplifII/ld6Dta72AX1ux/AVDoi8hy5i0YQg=", "DiDNk9hVx/FJebzbMV0vmJHgnkCZyrT4K2ZIHQE+rJQ=", "Et+vKgWMCJC8oLyJty60pXXxC0OgCcauIiBxSYhLRjg=", "KZKYMkt7Hnz7Bfp8YsLEcbWo3LIz+Mnhvs9n2L3LRBY="], ["Glmza5T51yNXflBNYAxJPygQ8OZxEmcsdDq7sTq/Q7g=", "JY4J5AjW9mLzU5pkmqFW8Yy0YwL9D+NPAHtzHbBoJaw=", "IEn5zxLQ4hCn2CpWaU5Yx20vHFrFcqr5tvt3DAn4364=", "LUaH3irUNgD2hSwqGRz3TQw+SnygUG+XRhCDP6IBpys=", "KAPgVTBeRfm6LRVCBkOcAqN+ilw/qOs42IPHUTfZYhY=", "B+wblqBNTrHwco8foEkwGcbxqVRWmXulADvCv9z0O6A=", "HezivZtRWHXBFCRtBV+9VUkqfSaqgCIicZJgD7F8jII=", "ChlzYZz0NLd0IlNkd2g9CS1xDGijZElG4R38Xa9MPjU=", "Hkosg2CQpclgkx8CC9YWYp6Tywk+4CKF+LnYUKdPi1c=", "KhLLt1+s2FSPDUZNhclhrLFmtzrrNCLtzRw8BACCRnM=", "K6JSWIkZBmSDcjcGc/i5cBp6F/UVnCb4Os0D293stoM=", "GecP5L3d29GiAQ3X81rYAgBLhIamoSlrdf6HwsUkaQg=", "J9GZG2vleEDIbHZ5L9nDtEzJvFZWnY9deAEsF8nQGyA=", "Jqa4HV1MPk316TrrOSZrVqU2wVMhC59N7BDs424/ng=="], ["GksYa3fNU/lhyMy3gV2Xgc73pSr2TQv3RstSJRLT0K8=", "CLOfcClJoKGlkGM56D5mNRmyZMMDmrpGiL8uN4iz7LY=", "FSh3xZ4HNQqp8LNtsAxDYjTHYkndAJlgewNWe05/BW8=", "ARVqVf68dw0+cjN7TbG9L9aAWUqcna0Id3ql2JhRDlw=", "Hizb0QzX4pk8CkH7BzQA/5OPWQ4ws9toVfEsEp1oHxI=", "BPCJyHy3urrwMaTQ0PXAjgC/yZzHvvzbIuVSVhcM/qU=", "Lrw+bGGuaQHTBHr7UJXV+GBxooAmpzUZRdb8RibC8fk=", "IwlZeRCAstJiEx7ntDwt6UIqmzpZ7hJB52L/DaOAhWw=", "EL8ucovsN0Azwx4WurZ3IFahrOQ7tMMzOghiVuDtnY4=", "z2oDF9yYun+8sNzvU9gEJxu5MiJc88L7jAVkuJjBOw==", "EwbkNxcVb7TiGsZBZdxf0Es/Xcv1IxT8DITQm6W2V48=", "CabgBjwFZR1j6DZfThdBXwq1nQffSRbp88b2ScTxAlA=", "IRo7TpPeMghS8GZowZIHnD1loA3ip8+rlmzg+/kyLsA=", "BjeB57tk5A71SkrBfUd4W4+uXaDEs73+TejtvacCm+8="]], [["BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AxLjKYKXzpthPnVSIBOKYfb8tEnp8pe9KrN/pLBgxPg=", "I37kbUj8RxnzsMdNHOMtJe4aQGyGImsUljWX1307Jtc=", "DmQ9PU7ngSi2UkRFHlDap2k1PWdbcM2fNkISfHCvwJY=", "J2JSrcX5rdBdgNTZdapshQbl82Fa0E3Rm2qP30RVSBY=", "BA5FlsqV/ECRMsFJfM55zhKTv0Wcvy4LHO2hdNDlPmU=", "Bu+/fJv0xyHLDr/2dzCkHrDUSYJRaBWT9U0W2lzy4k8=", "BGDlxZ1ikvqk/+pcTw9bYYwwKR72JZ0tW/dW34el348=", "E2tynyLRynTbD2exJRKSWrhZdGfO31Lm0olAdWPLJTs=", "KKqhUohO3zGUTXLcMYQkwNo0ksn3FU3I+8tlN81+Brw=", "I/2sN/cfl3Obmsa5hivku0B1ox6dIRjH9KxQdL1/JpI=", "B2eqH7xOowOkdvBEI0WKw/bkVATJ8iww4u5dvXyTSKE=", "DMBFLE5c2VbvGjtK5bvKp756zUwvctItZQd1h6kcCwE=", "HOuIwzw17R5nOLntA55KtQa/erDwinqvfasMrxPrDmg=", "EqmYuvM9b79vr88DxGLIpe93BLGBq/JBS2ifnrCFZtE="], ["Gakqxgh6uJmC/lZQ5eeZ+RAD/YtFQAdI0sJeQPBMV40=", "J9yFeRNsDnH3Wxz29Qg92DVNEVv0FN0fpUDl8596/HI=", "IEKMBE0i7gvNej5vq0JOi4CvUCd2LbHpb2WAE54rwJM=", "DReq07b71P2LrhRRWeuiphrBJEs/tGAiIWe3cTnJ2m0=", "GA0+EU4JOYErkfsO/z4LYQkEPB1AGNHS+cvHnjhGGOk=", "DPITsdP2/gsTfkUkuWO+1AmTQW+PGxdP5pf9VQefM0M=", "GQs36Mm3vV7mDQqFN9R6Gjd/elZ0x1qZVAuu5gj9jyU=", "MDSwHC+0ephnTXMIGEGYKUgDlN840zGt4nANOROKQ9w=", "BrHdKl/Sfvw80azqsZafaOSVmzag2lyltCwQq/DSMKg=", "BIijWct8PNQGOtxv/pGuRhP3KmgVNeNbe5a8Jghr2ik=", "FToa6fANAmwxs0YgAaB6EUtCdkl8gUTEKvk9Ebs4PQo=", "FsSZwkP7XOxgp2wykuBaYhdHHqz9OrK5W0CaNn9ad/4=", "DsFxxHYmXEh32zVU+p9IKo1rZHI5uJ5IqQl/F01cW1Y=", "BEX02fSdTcsa6GaVbDdOGjy0VBngD1g2uI5a0W1jnus=", "DZ0GWlPsnqHy8Iwywwo3zyt60WFOYKrzuRUIo/+zswE="], ["MCYI11DxZJHfWihfX39qXOa1VPXazwtp1FCyS7tJZ9c=", "KYqQ2k9Lzp3oG+aRLG/7eW0EwUQyyMQKEFoosTWuJzU=", "FgZWBKYM8tfkBjEKUU5CinNLJ6huLe9v7bP3FMFnnFg=", "G428qFDoSZQLFU1Qxu5XDDJETRLIR8IBazUUkjA5UGA=", "LpOv6xs1IAWCRb6+DSaWZLEucw/EW79Gy2YETVe1urg=", "Lu0E7y6X7rRzgYdxDTw9WY5gp7nmSE1LSi8Jg9KXCUU=", "G3bzd2Igctqj0WGbG9xpIzPVNFtn829DDPUW7xbtqTY=", "CiCw/JEHCYV4Eiru9N0bu37zU+QA/3DTgu6Ku3xIHgE=", "CONKDM03ntHGN/gnKjpMrWSTdDgEP0un9eX1sK32h6E=", "HUi27+NyZm/IUZ3g8BqOXTYHCOR9rc4fwBAA591FJ8Q=", "Jg+KYnZvDiWar1N1d7GpnVC8AgdOEPYk6Rw287rVSRs=", "An/8pXTCbNpaoJ0HHFiU4O2VzZMDbiGT6EtOXqffBrA=", "LXI+cRhKusiVB3+EyBH0E19Nes9aso9TKZAYKkOHODM=", "J449/CNeewTK6xBqFEYN1qdHG28Z1EHB9ziqYlxF8o0=", "IP0M2sRMW1wizqR6wrDXVlgZoOgRCTLw4EwwDrMrIj8="], ["Gjx9qmtK9WYtDYQHsodnTYPq5bdWNAX0je9JmByYxCQ=", "L/UING3w1AjT0RCbJhI73lxFWL2rJtnPPGN0pvkpGGQ=", "E2dLXQ10nK8tk3JNI0yaOnuaqM7U+FS4U8B6bVdbf/I=", "BSbmnHMHBkfNXUVgnm9Ve7s7TNTO0445gv6Pohelwiw=", "JupqeTLemOhdrzjGqadcxsAWqp6zHnjXta8e85Ns31Q=", "LqfIMN6ArDBPSkNCgYysQI++J8gRslqebBws16OmPsQ=", "ITsXeqytqCEjHGvCCQ/zVNYpzIlhfVKjQGc0l7DJspQ=", "F4zfAV2LyO1SlLsxtimTRc1aM+XqMOTwP0truyqrsuM=", "KFSMi7eG9HeRyYwg1pIdOdgqLJhoHNEPGAXUszhGBcU=", "Kn2a4qkVVhpiyIT1rHHvEYFfpzRfYUZquq6bsXI4JGI=", "ExEFxDgbX1d6YWKaU+B0rmahINfvm7XCesZ1v5BnYVY=", "GFwVICTE/Wr9X39vlRNNoHnOFhSp9OA/IEORQoEEE4Q=", "HKnwRfcV0pRYyx+9yNhKZok4t4m7Tpg3zHotzPkMxWk=", "HyK+JtUWfvS7ABF/jm6h8oZuYCqYYom7pIS6Lx6HVZE=", "BLv/YYEduHC0K8zpvhFkLVOogkPy+CcbYIl1ZbpqamA="], ["LbHJhVrCmsxnk2fb9w8I2YiUB33yQR+R72jdkBd8Hps=", "E0ev5VKfYP56c4SURVE5mU75diEtrrAolzf8F9Z73DA=", "F4MqV0g6tGgI6URJVAfYS0J6JQ0vTYre2w2iv4sA8hw=", "GK/4/loXmLqUYykXrT4Z1Njsy4EZU5XYm31jHPKWJmM=", "Cj683m/OsSWu5wKEBksvNSS6gWwVH7YkXgfMM8E9l/U=", "FyMGZu1np3QL3Xapaz680p7KQwHoJ7IY6iSkpWzxHq4=", "Lvr2oOYi8Q5U4I4OCs0eQmPM3mFk2AX8Uxf564NBjA8=", "LxJA5FKHQk3ZSmYeVrifDloRueFfz4ltBLdkBO5TFI0=", "K6tQZWnlW10Eznr6JDSgldO0PwMpt0UZ+IwdY8cF7EE=", "KAxyVr1ndfSXyVhJ/1alOozZsBpgIF/UFwKhBTKnzrE=", "A952jPaSI0l/0uoYFwh1G8tCoOjPP4WAun0Khv/xKIE=", "Cs6z8DBFBzjizV8bAXeHKmMszgR86YYduDVVSxvZ3oM=", "FLcR0cq7pGddF38X1iOCSzooIppVHzILM1Wp4/lgjJ8=", "JLsJ6Q5k9cY9U1gLUxB5eE5NWdKHyTPWE67q9ZrdBr4=", "ITsipEdJKnnTFS8O1/817X9YBZHLLfuNke6dvWe6ZK0="], ["DwbuR1WPGC2BC7yyFKJdp/cKVnoEZLNI4bMOyn3pnSc=", "D80v9cjwvSlHtvvwDQuB6/t2BkzVG+u839tiCeZjS7k=", "MCs0TxOzDKBXi9brUq+2bAMbM6IpsYphqYOVqVzEp30=", "AitFGsVvOCRQFO7kAVaOXMUIvewiI1WrH3GUSTrX8IM=", "Gzv3NcyPTTjXN/f7bYfXBka88v2qqioC+9DnWF0k83s=", "HfDh1zvuVq1YQhE1Lnyrt8dI7fEHzYxXUMYpPvf6HYc=", "CZSw+tmL1A3mLGojn9IWJKGW/5XSu/oi4EFr5WlNZ+o=", "BM12HzFuzBsDZo9VtqapqCui/Xl+y9VwExdqyF2FF+w=", "I5ivoZcJaUfVZ/Fqyr7SlWu2Ks2aXYmL5ffhVLXOMxo=", "H2MBhEnG+YLRNktHNzfgCdAASDfptBfRAK6u9T5Vcb8=", "G1MXAf1rAraArJYSU5br9N9/g6zy7f6DOJPutfLDqEg=", "FBLvFgJFAGuo/+2uTgoar/t9pX5wEolZpbXhUDtOQIc=", "A+pR0NPq5vgUJR1kiJL+WYUBlkWi05u01JKOa03Z1wI=", "GBqCkrCDZEsDV+XFsP3TFih3zRTZjDro5OAfo5sZ9Gg=", "Gq7KjACcBYjSX1a7lFeiyyYLFOiMjoE4lHntvRdNc84="], ["IWbXjZSNr6ljOBzxVg0AvzoKHCiKdDNEyGQ6WNr4y7M=", "L9hlVQWZHXMZ6spMS3Nu6Bl2t7MlxJSrgMadsTLlUZY=", "FLHEGPPBI9keCE84Z91iucc4ZqSUwGRgVPfRUoJMsLc=", "KecYOkDxgS/Z5pDMaZH0ZRbGoRttY9+ydb30XC6DDa8=", "LW4HHJqMElkoJLJGvFAk9o1/FXgLjoHLkXAy6jRIx3w=", "K81uzSHQKKiveCaGtCOlSRvgnTEei4sxGnbG+jtuhGs=", "Aple2pbwKPDYI9OQo5oIzsiETrnObI4IHFcyY1Bdvhw=", "AZDCOCzrd+c9ckiO//ekc5TJ6rqlXpE7OHb1x0JeUHI=", "HLaNC1p9Hl7AHQYE6a2k6LDl1lfgw6S5gdmolYW1seQ=", "AXJYJU2ODW+SXnwBhfIJjVNK+wdgcGVXwRzJNIHdNNw=", "BVnyN95iFDzljD8//G/UXLpcLMA9elsAQySiZz/21bY=", "LRuujAx7ZeYJElyZAO0BtP7gskbh1bQPJqMhz+liBEw=", "C7B8RgHtoV/6DH7T6bWnMx3q6SYJFckw05dF2mlN7ZY=", "KaMyj+9T4mCkP4/eiEIoDRt07ZbDIzxQWPz1dIRZ/CY=", "JpShnkr3wrh6lNvM3Rs6xhGxNzExzVqdcLx4N9j4IKI="], ["KSm+m/4/k800/OrmZdlrHeGvsmvK7qL07cRUxQy8RAE=", "Ge27epg/zXaPsmfZxKH+o84LKiubRD8KqkbwblidFLY=", "LB3bQ5sQoJKzlxMYytWwjevo3/YDvvRTJXfElb4ack4=", "KESXGP0TdHC5z5e4FcIUDdHJcrqZji/kgit8CzO739w=", "HwZVVgsjNFR8uUjZ1rm1kHx4ijjvhkrgZzp4CU/n7ns=", "E2+kq3nCjgvpu0dejQL+mRpMPhlj+PAr2Z/Aj+uK8Gg=", "ARRdxnygZ/VA0HH+8Jy7keHT3rggJTC+OCn0p0uXyDo=", "K++itt7lFHkFT9jdGFiKR6QC3Vw8TtygxsX+PKwwWKU=", "FYmWPxrZaFA3pQkOCnJrRvDWjgG0H/9OUden7jygOE4=", "LiPK6xRocIkIVcbjUBbo+8VHVzM9hNmGSHGTNBppQrY=", "BXScOa/raH+/VrZ0mm0kIsqjtKSpi3AqSVi35Oyy038=", "F4iA0fb/L5uOGsM4ySoMj5KAPn9MJ3xYnY9NlhAr19g=", "JFjttjF3zUa1H/P1BUN2p2ZAtJXVmORyh31O+2R6Yp8=", "FaxMUG8ORRaDQZGjpqqM2jCis4gt3I0GPsepw4xNwBQ=", "JKX4sW0VCpaD5pw65gOTEZJWAHnrJdFB/3wsuqtNycM="], ["EHbUOcZ5l8N8bB/amjfcL3Yt1XeUbzb8/czXiY7GfNQ=", "LZwWULUoOY6NUtvCMzU4TlSu4kMtY1xwoC2WJDygsm8=", "GyxSBtUL4ERZjFiX4LSwIhvTe1EKQ3/lobTBxpxgG20=", "Lt0fp3iWpk27/O0Jd+CDN+5L9hP3boos4mQUVIsjFlM=", "DLuQh2JRe0HjBraQmDPVoQdjRCbyKXP+g/ALDhfxMpY=", "JMuzyUoCanbAReTG7fuxNn0las8m0CzAlBLtp/Wafss=", "oL0OoFkWLbSdsAyyqUDVe0oXTeDzqpVQe7+L3f4XsQ==", "GysEfp5BPXSFU/md2K+bJe/MXiLUX+iR3Sj4+8L7UwE=", "DLlqzoontD+eYif2cS2hPh/c+PP5kIo6HCajWgWxSSI=", "KawBrjZWknEZX+B13o3ftDgMOgLUPXNCoftRF7jeKlM=", "BC6++cakzb18bLBNRdLgwqqoDer3i8H1jvQJBs89AhA=", "AuOL8HwWsyA728d0b+X5F5J3zKg2PIYBVdFA7GNnN5E=", "AgfpFXxUrOpO9Gr3Ic2bL1dEftToe+iTPx0LbYFNb/I=", "Fn/ahgMnYP5pa0kgyB9T2EP5PW3VNvIw0gBOtBS/+t8=", "D91d2toLBFpEWqNEvGGxrAUULhtWQa6352feFau8m/U="], ["GFya0NqHz4JGJNAr7DukZlgioPazsl3v86/MaHzhMh0=", "CZ/mCdzpGkHxcgF74nVP6Z6/bBXMV/MbtvW32Aex96s=", "DYuGNtRZj99TJiNdF2yUYo5htOfILni05WSFDKKyN1o=", "DWWrikKJLb9gWHxwHU7nmIUwGGcEWpVOcJoLOaluNDI=", "Af+VK+vzDXBidpEBcqPN/K+wmUgAAt0PqMaCiBiP+0c=", "GzF72J1P8TP3WrTT0Ldqea4BsN/5ls80pyUZbOcDwX4=", "EkeU14iF1ZNr0D/3NLXBrayKSllq2fghAsANOmhN18g=", "JP/WI9qrn+E1iKHAC3+MjxyoyqUwoccTG0ZtlQ8lGMo=", "KzitGntlLp+L8O8yvii3RcCZki63VaNBhqyQkFZ9i9I=", "Gbq8c0CRo76TNCfmbDdxRCRefbEQxqK6qYYAOUeiQMo=", "DQKJpAzwKSbLyydHoOHBUY6cT3BN9q6hQnYhHCQIYIA=", "KL1mxeEzj5cE/wcAO/x0S8zDn3zmyKtaV33JA80mQBY=", "Fw93p7O5yur1ZZ/OReraMu2rhDUQ8MHBkY540PbyUPM=", "BL98UOuAg6GxrtLy6x4+asbayUCIxSZkPUP8T/1nUL0=", "LKyvgOjbKbqAgHg4lUpZpYe4Odrnf64mw3ZhRK8cFzE="], ["JwKxvjnpEET7c5JsEQRxn0wDeqQVGCPOqyTwzsSfRkg=", "E7TeyDa9nM84pQPmJe2OI2xU5pbHRjeuajaGqAVpWRI=", "FxX3Ps9z42+OUTscyattgsOO3CAAh29dG64De+XJlxU=", "EzEFtV5siA3f3yh0dHi5zuX9qYx+uw3adQGieYOG+fI=", "LHKNAq0RyZmyubnqnlfUllcoced0MxrlY3TyOAgrJ60=", "I+8nffocDg2UvGHLLou9zqMPTUAkUxORpMPpyrRUOzs=", "FkMa1YcbyuQWjCuGHvSwsBk10Rl1jbmq4GwAvTDbTfg=", "KNuTsSMH9b7opsC3vMqLIwW2iAIHQNQ0X64tBO0lBd0=", "IbDvHlJNjZ67/GwsdJ0OyQ+ucI3lIDheqL8EKFCMXVs=", "GdE8Yz4mAwWnFSivTqqQbKRCeXfcDHR8impFA/70Pow=", "I9gJ3hSwLBBpw+FN/1OLkQ5ISv7/QAssHST7DgCZy+8=", "E/zy+rS0tmol2sDNUX/sWPWsGFDYZ7475K65hU6zDvs=", "FhlnrvGn95B4F+EK2tN0aT09H5gexEQ4TE20OBldTa8=", "FpTVq0c/neNwGiVCQKAqR0PtUpG5IIr0lWQE3bMKQ4A=", "HHEMAzMY3LMhdwMgdFgKNQTySGaMfFPeVntIMPdMnqg="], ["CvcaUc1GO5+u2pOAPNwDGGx3gYRSUv304BVXCdk903U=", "Bfw7F5nlsZElfHo7x16fqXsWTz9O3abqZknIMme+UaU=", "HESXUhJ1zYbJGFUXYPTTW+zvqO0IA2ycGNg4Fan8f4w=", "HGXBuRIobFsidDh/p5ZdayhDtbAbgGu/zrWQ2lMcaOs=", "KdQgLkVYUDsESSQklf2a0jgXBSVq/7uoARe0wihxdfM=", "KTMSTO2ElCxwd7KsOT0URk1RfH2PHjQGlO1fGsvf8Sk=", "C9WA+A6nkTaptSDOoERh2oRtnyPmInfxPWs6pqsQitE=", "BXuI2DgI02dboZm/xXgGM636pEybHjJGPWa3nhxt/zo=", "A6bIfuNM2uHd15gs0xg2LhonjcnN8c0d0DtsNq/4Ng==", "ImkvtoBRF5m4zuyW58oOHNId6Q+UhWrPM0/74vwmIFM=", "HYUDO6DF3YBMUjfDGriwloTGNbi3V4xQwkaxUxSSaHE=", "K1LpoKmlNa4F15uLVV1GHxSNsmn0njjdjsb4uNoQaqM=", "J3P82c2Zbzgpe5XaqyLB558Xn0x5/Uv29Kv4cl7NUDI=", "GK1zEa1jrxAICPZL3GM5K/qgo4gasDwxV8qBQIaKcOE=", "GbiDcsVEppMhsnPMYqlbAGkxpkIiyrRTbnl+V4pWMF8="], ["KGZ/nHMyBz4pPIC5jt/64Br09ntMUqtF5J24sw8YLSg=", "HQzqhJ3HQJs7Jt41cVsy22GGkbwSPNnExeb0C0oeSb8=", "FhVW4D6UxxVmB8umTAu3+gC8qhJt+K+11Cl2wDt9Xg0=", "BBnCCi751w6TBilZHq5MYydsXXnWlI6Y8sN6zCnxpKo=", "HUo1hOOTOr/+CXcXm4wRLyzwjkCdMzYt9HddE3P002Y=", "EEvRtMAosoesP+oezcur36agZel3J5HD3oTZRVQvwgY=", "Jn74TmKL/4qahd9yTkwyy9MjfZG9ZcQ2GNhlAgMqNpQ=", "LTYe+o/GWwPUVQfPtTVJs7JqhKxQs1k9vAUoBuz1n+w=", "EoXEhBANcMmS9raVOplV9WlX6aF2QWeb39OItr9g6kI=", "DhpGpSc5RTnDnp8eRCbTGIwNkHcCF5BzTsASbQgo+8c=", "DvIG8hZY2wP8jV1r5bGDdCR67kOz8ptDCm/tf6UQKoQ=", "KsPbB9gxtGHzggSqBFSx7fwaDeW3puFeScY7xxQMMyc=", "Durfm1/YX5QFmRr39Msr2oFuWsp2EDs0uJFQL5IdYJY=", "KTHTh5Kjdp2lJJE0bHxvjxBsJzXvKhygNyU5aYOgBJs=", "ExFUzW3LubRpzWhguGFpmEWrzEH0KDMbHSvuu6jOt2c="], ["J2PDP1ste8OiMECvvNr5mLsTJUwnKl+GNaEmBqWcLlw=", "J63oEKsWscnZs2PUjjl638ea86SDbtY8ZQBTygV6A8A=", "F309RN1UmUT/V3LUdCYD4WMSRYPPpLZzzPGiVFTqO+I=", "AsDeL/bEPB0DRFnchFgjfYCPsO1EXq4s9+lyyD8AaZU=", "AnrEeEYXX8qmBNaHzS7UHyylKQWy7vp56qhYPrrnYpE=", "Flo3eLicx9p5JUL0yabbqSuFF1pg02Yb63eFKyOGKbM=", "J+CKgNxEig6gjHnJGY5XUSlo30DUXwjCasgkLRJq7cA=", "H9gEymtdKjzHauHxJaC+5FZ2TbelU/SLtH9GjzxXqVo=", "F03nyg6+ahKQrGqAdtUbhf6PtAItqVpZpunx/C+7Lvs=", "Dz3q/i/m+66UF+trFEiFBR5dFkLkmzdGnTmmvWy727s=", "Ds//R2hgsQQQCrTQ3JLZO5kwJKHA1tULM5JD6a5nzLs=", "LO4u+vkKDnT+vNUhy1/GEwStpfh2CtwETLaE80G2Rsc=", "FAIUGJv5pAATEfs2ueXSej8866MqRXE1o8ZtduhANVM=", "KpD1rQdPPiOTRcPXW3CBgEs0/fwvufcgpkSIGJRu6XY=", "HDc3EIVikGYPOLlq2bqrpIehAYMmDh0G+bmTXTbpsLk="], ["D4Go2OCHWOijKqgpJmbEy2uj9fBsTc9PxQL/l/A6haY=", "DDv4sEKg/JsBjmTVAEhO7MyAhuyREBLuGajpTJex+Lo=", "EFOeO63L4DhrWDJ/pexQ6S1IO8uBm0GyHdfFTtp2qZw=", "Awij+goterLvdGUJ8vt20aXbmUWGpU6dEJRI8YsoGzE=", "A64E9QB5QDp8bxPALQ7LvOdjHu6y+fKE3HwqUvv/R3A=", "Br9BBa63g5ud63GTQWnMl1RR+Ndvg0SZsoHrbNacBx8=", "AozVtSIDFfMqQEv5GanNAaMIL1zx7W6S3XmjI7/GLfU=", "DbJCEoXqf1l5EiAixi51LhsVxJHMpGK05xt7sGYZkMs=", "IA0mpdAKLBVKp1A2/E4kiF99jj7N+hm+t8wVdn6y3os=", "GhxkO40FEGdsiv6npMSvmEMkBnMQRsqIKkl7KafGF3c=", "HoDG23Yy9tZHZszhC1bQdiYi66DeMbYnHpWslM7G7zI=", "Fsj32F5BHQ+bpoXw+4Fcb/UXq1Rjx0u5mE396rgplHc=", "IIMOmTOrnIKx2ZNpIHOZ6zR/7NjYukMLWSUDjMMpUFU=", "JWpNgWfA9gL587Zj295KfNPUc1NYewF/TwNidlC4E/8=", "EROfemiE0MLvwymXJI2zB7vAy6SAN/xRhHjpY0/MdF4="]], [["K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "IU6GXi6r25/l1WOhQc4YuyVAKeDgTlnC/ssIULX/Vy8=", "Hg41iDsPF5TbAj+ANUqDlRODtiKC2rQSnbHRnmBcMW4=", "BcUQgKdLjSi1CxQijGpt6K1Tl8uaS5xs+Gu4B8rXYHQ=", "JE4IV7AefXqg6y7zNP3lHxaiQRq/7Cw762xi96cDYhc=", "KgSFKpC3QUPzgIoVDp8TceAXehtucsvLD7jx3c6KjQI=", "MFoxlyWgt7897z9xUXzCu644a2UVUP6UBc7Jje4hsdY=", "DZKnsAlGaYX+84jKPXDH4sDCZw0iYN+DZZ13YAKEMQc=", "Kmfu/Akw+CyLxm/61awJwQdAeBQTHNZFvBjNpv/09S4=", "mWdHNJGM6TKUCeUPLpBBvQcvnYJ3N95gHwnHreGdNQ==", "BEkRISWz8QpTssRl8r8Rg/A8E4JedtQK912gS4E3eA4=", "AsHuOHqMFefb6SAyokKAHR97QRp+Wja/xPonSaIsrMo=", "HWh6TjHGs8keZ9ydndnEdJPIObXhPKGpMQ5roBFCHPc=", "HceaXZ3kQ9tETeDwisZ75IJtAY/YYTnunup4H030iTk=", "LVz4FyxYfAUT8mEFQZ9WMZdjxctCz57LXifZqIxdFsk=", "JbrKvkiz8DDIBqqHnyUkH7uxdTTWhr2o9dR4ZisqWrU="], ["BpsXed7D6t7T8H0MPmzs1s/+eNdH+u2tnJBmWqLZLLM=", "Kfsk/P3akovBj1TVWUoMI7uCLCd/4ruZngSjeDDHWVs=", "DAXC2O4CLFlSG9RBqhX6Ld9D5u+YEbEP6WQO5eiIw4g=", "EiygSNfG1LkFO1mrZ2UNENIlFfE2WyJnwIbcehaN5lc=", "L7t0191KsZDmJEI2WAMUyCC7/jQEX0POFNHsAEmvoYc=", "LK26hv9mYAzygAXwrEhwkUEYxi4RDjrgUT3t872EbSk=", "Aw1DaxAfz8KdZ9f8RHMhg2DxpSu3MWxKCApVwNAacJ4=", "EEGoiRo3RS2ufFg5bSJah+8ZhflEhbw7uUWI3QATKys=", "IOhlbLXWjPX1qr0MvCOEsAzRtl6nexwElaZfMnDk2IE=", "FxBwlmFLrO3xR+yLqN2/8dmdXsJN9UlSeacgFErQDdI=", "JhUGD5uLeXKq08BvgAeXAO3FkdDnAaxCQgOmp761kx8=", "FAbYb59u1ScyiZSI4GLyk8aBdnZFpjbY8HjdQGcuYy8=", "BH2+Vfd4yBXNjHnax9WVJtx2Vw/vIiSpNkDJh3DAVs8=", "Lc2wqXHFqhIMPYc8vQcgg6ZJ6QMUXgCCmqggLvCb6Ts=", "K/cSRSoRsGdloNjH8K95BSemZYYylKMs+j12KlrKOww=", "EqaKwzVJ9pArEoyzdsL1LP8H8SeRBjhrJv3o/EneMes="], ["H6Tv/INJjRmqpZi3dx+IoFVN3dqJ0y3Pim9M93bRO5k=", "GbFXep5f5n9x5zNzL/a6A127GNEp9wGlZgaMSq0yFl8=", "CC82dKOGDYA07uL3BZM8Lr8jpevHo9d8RsknnfiTApg=", "EBGWO1576V+7+ihI1W2gXWIpo/ApLFB2ACfPuYV3ovs=", "KrhmNfRH1m6l715TOQMRl66Ohrc1B0QGkoDeWdclZIY=", "FPw/4kRb74VHsCOhztO6nhN+FvsONkXeyBPN1+WE68g=", "E2r+mlOs1eHWjPx1xWMNOXAcrjdErVqiqjT3NeqDBwM=", "GL73As0xeOtLpYm4R4MHHO8mjtaCj3DJYON5UIuf8eI=", "LFxHSmPBcuptah+ovpLkvGiR506HxaZcQrYapCqark4=", "An45Q6yZF0soKf2P+rF7FoN/24igxgYOIMPlxy+0IPg=", "KIpE0a+2qSpcfcdm1M3kh0sPScw+eY/CUpLNE8/E69o=", "LSVdTyi1bbNWdzKTy8o59vnAa8TLUnWDlVXbdyqWm6Y=", "JiZQ6bFmezGHfI15pYFsroDiIt+X5ItXS6kebLUJ6TE=", "Ir80/AKqLiFcmTmUx8/yYm3LchKXX3/88RzZCweAjnA=", "FAeO9jwqEGyIlRQ3Y4JP/seoaOgLia1q6oImOymBMu0=", "HRbegGlYG2KUnz5b/BGI4hy99dZ6W9QDkn2jpm9JxrU="], ["AWdvXAdBerVMN+yK4agxS97rCZZHaYgVkgQ9/8smv0E=", "KGQVrLzIq6PluFSmo1fzALpAN+uLfF72u6yGjRtKVjU=", "Gu8dM3ylHKXSxcEWonWoGiH5DYmDS9GvYbOqa+1lx8A=", "AX6GSwwOutvS/U91F3uef9gBvzwGZGQHDGUn8JawtOk=", "JYfC/7g3/MW+G1oNUg8PIUUAC2eXqaUgWuMCQK9px6M=", "KtWze4L5rDWEjemnsL7UJiswdMgEfYpHNpWaIZRvfbI=", "CjLknszJDXE1yMZvuxlTvtnaBEACIcxgZBbw2wsGkw0=", "JOLIYXCltKjJUGbV9VPqrt5lXbqQwy5IWttTw9ufZd8=", "LpCVWmXBGqdA6FkslKmDtUK/lb7dm8JGc2R2h8V6QZs=", "Ec7R3DUfC2e43jHWeNp0DloMS7HprbBLEZ6N556QgoM=", "Cd6Le958KqKFOfw/MbHyhTinZsU8pukqFjm/FwY2lII=", "ElUMQ9jZsVLAOYaMpMUvB04C8x4YNJeMi1VNr0NjLYg=", "BA38ZfMTOsxlqWHfxLNl0h1Buegs19ZaoqMjijrFuS0=", "EvcSS+tiyuNcCT7ZaXWrXfyOAPJmjG3bo1H0WBJ+lqY=", "BTCuMFx8ipzmGUO6ob/AsuFhmamURp9BrsF829fQdKU=", "JD7+F+Rhe8DCDstfm9dvSKjdeW+hBYNm9VgmuAqml5Q="], ["H057vI1Cd55Yqge/VP8yS4FP5oe0yOuBubfnREjuJ/8=", "I48Lh/IyIppcdInhx+3J0xn4FsIeb+QD/2XGDByksXg=", "HfkGvXVcapZeLs19MnaK4v2MUi3Q3cuwAjiekPXGpwc=", "LaR9e1OJMYmQ49brn56T63QEQ5s2Kg2E2iTYxxX6i/E=", "F8Yj3vLSYQWIs8XdI2rDECahY1Tymy+KGwlVw5FwH1o=", "HGw3uMryUZikqcyTxVnnO3yQym32rHIaL1LO4D9XIhs=", "An/q9btX20fsMXAYlp5udn9I12j7E4aYzrSq1HTxD7M=", "BOOSEXOQx3euk+4p21OXn08OFoWV2dxf7E7tGOoOM8g=", "Chv53e4HI0f0ZSRGH2bGVYLFUzvhg8OevFMlwuER61U=", "IzgsdWIO2nfBjj0Wb+57dOMCAq6DCYkAEISeGnnLkNs=", "I0wz3HwWSxh3RpGTAUA9dcWCN5ZWJ3ONn0jTk6RIKa8=", "IW/7bn5TFt24UkBvETMcJPcXQ58n1XyhXeBllY6kRGI=", "ISaYAMa1PfBIYQ810bNE4DoP4V8KWyG3PHmaSOTQch8=", "CG7HIjDNX8bHhCzV60/Wt1wwUakV3qrrYemyJ4BXmnA=", "L1QWHEzNk2riw+3CBGN9wRTU09bZi9m22L32A71LfnI=", "DscRgawr1yJklf9grbIKPJp2Nt2frxTbUzXYxMG6OgY="], ["D2sYyY/In7+pmgTIyWrl2zXClkefSEtoDfkF1MvR36k=", "ElZ+Z6vJs1r0/7OB7TrPJEovkBmDn1+NLwtEL1G+iA==", "F4ORz4+RoeOwD1RaOkpTMf6v0qDRDZAnxWlUyKP468Y=", "Kr84ssBZiUAsdexSY+Osdb2+mvDB65KIPVzaVk7L3Dc=", "KixeWyR1HkoQ6JPsL3q5b4OpcM3zpUOyCkg1fMfshXA=", "DffUuDI3NYL9T7zffzxJdJ9u+1n9mfTo++28gZCg2N4=", "ByARz7ivy9i0MSad1ddKqZ55XGYo3B3PbC2NsAO/tDY=", "LjabLclmCfjBelkvLOBjaD0UggTCkSsOU6cKPEa/qbU=", "BZsnAotPCUk0XtSLPnmdEIE1B4TgBCyZQkMpd0Ti4iY=", "Ii3dulxyzC0S8Ko36UCglCT249Z5z3Jb0Fm0GCOTwI0=", "HU8kJ2iaHcXx18aDEc5bClapYbPUKnRvNW3YH6FHaAs=", "Kyn4+083aR05geP8SV7ljCXs11jW4kw/QeXFYiGmT9Q=", "Jnuxe7oNobRX4vxxST99e52k710Tpi5SXe+j0IC3Zr8=", "LmUw3oM8Ox0fW9oMb2okStgoh1CGUTbcIrt1LI4EQDk=", "HwuQxSNYqKFNoRJjnH0uov8d9Te0Eif008nr9wFMdeY=", "DZrNcXgkKRS4Ehm5pg73oNbdD7VxYJ5DNfjUGf+YLRI="], ["5s0QiD4eEcbBkdNjKfMOsARa8GwthtDEOfXB9P71Sw==", "K7+tReWpLS/M7MUUZIupRNNavKP2VwlY7alqsuA9gJU=", "H4u7erB4DVv0Bw3b0bme7N41d1fzdzzmqKM8ttPWBgo=", "JXiGOnULI25Zdd6D/OuRcntPWIxFOpTkAyehg5ToNeo=", "KChPLrTvOO9yn4Y33yMFMuOkEBhtu+WuVJfGmnyvrHg=", "HFNf3HER7XNN75B0ckiZvqhSXCVxM1FZrzOvVzEKjbQ=", "KQN6gSbT2B/Kra/xmVoV+eUROyBcL3wtC8A2HwapZ40=", "AcxTGAornPtJeDOdCG7VTHSKX3cZDjDcKHmnahB1U+Y=", "L9bQECTNrE8nnt2ftSGbQUgVFjs4T1ArYVU34Dz/KyU=", "IFiFGQxtAMFCAHThpKMWPDgvcZN1T6X4fduYo5PQMvA=", "I8+JlAtkGP2+1vhLv+DF+FCpuojEHpmFVKSkEj0K5ek=", "lo02/yo45q7KMG/ihFhxnmm6Gw/Ha7Vh/tD4IlXLqA==", "AsmBTJanL7MkQtvakkmkEvmKIzBKhrqYSFZ8WwdUVU0=", "DBGrlim8k1Rpuf2zP0jyLbiV9d1eGCV1ssu7IhEF/Gk=", "K5jrZLhkK/T1KR/85BYQIIi0carD0vgNpYW1/h8kWIY=", "K6n37+DWHIRgCFzcpsG7eKp7wIZTPyDzAeAQ1Qme55A="], ["BCWpZB+wFVi8cXCi/8JOtqUUGYspahYpzChNmDvKh1c=", "DZZNomKH8JvBkOgjVBG7m8kGgAP6bW7gMind5l2wf88=", "KJwMt/hNYmOMKi838Q8wpY2L2LTFvY9aPKRI6cZo9hU=", "BmIr8opfyzYeC3vf1/oIcXtRZA0F0fb2upS1DSbdyrY=", "KsqPestZIzvE1N9lucbzBHnppy9eaCGGCzm6ncTQP4I=", "EzD+KIvLStJ94270jwY7qoqzC+ZZQFkv2XYjx/rtTlA=", "Ce/MaSVFcDvL62QezmJIgPc6EMDSwuYTL5Yk619BsbY=", "KujYE2NKh7AxuwhXO98jerNwEhW3fumk5qLAHBwdT/w=", "DCubs26KtpOGayiFvUSC7VyJ8Gmz5kRWVdcPTWaH+MA=", "GmBjcnJWmOfX86coBhf9ht6ayvmLvYlx2O5TkywutqM=", "CmYyYTv8qK/Ik5sz5JEt3xiwNL5iEQataV69UGWv4Aw=", "JHl2nNYIOMwUCmSeiTe+KKySxxmA8UnKqvAQDR8QI3Q=", "H5JboAAUKf5JP0jqQEqO0oOrLMLzJ17P4yCv6QQm9GI=", "EjH+B0t3GsZD1uGI9XMsIJxxt2hzmyJEfmtdz0mbSIc=", "DtogT0NKNHy8Ve9piu+yPfBkxX/NTNTN2BDgXs5lFTU=", "Azv4YxQbK5rqLlnPbE+vEUZnAKpcODr0UdQDycUxYL0="], ["OXp9dDSwqpQTSN5FrsRCzVytLDmIhJUOgjPFjdUDNQ==", "FJXpkIZfVZ30x71vIScrgQbiyRy7Gp4giZIsYrKnbKc=", "ElSWh4Eg2f+J1wL1gVS6ghWOgY25Dj0S1qCMVUNTY2g=", "D4ulRE3hjRmaq7xUQsHXwByvr8ef4JXaMZKNd2v5hA==", "HuqjHavWtqnvp05DFZF9kCsCdgoEsE7ttX4mH6LGYyo=", "A3dqfWkQYRik0i+GBg6n2wycjzzjzNbIitpD7hdcyBE=", "zvdyNMQlR5V+lQ5FrTtyNzXAEe9Hzu6LpCK9FnWb4g==", "Ac6+rFV9IzfkaHUB+fcfrX7LFK0JVQtSQXrDPC6LyiE=", "BlIbcAykfyIuouKA8xk99n4aWWa4zr/7AYkKo6h7syg=", "EAqF5tpKC5KoHxUScQyIminI7T4GlbwoWnHKVhdwX78=", "GmKIJV56VNQ5fKQLO+csBGm8SJ5m+RbBqQR2gWoveRw=", "AzEluc92ZROo6CoNBDdP8YG/qBj2esHH3UKYzzK4XnY=", "D36CcgE1s1J3/FTr3YigJq9UW3RfwgRJtwaMaGXqwf0=", "qfKOYhFy2RG/+tO16ktzpJqVneXIborFJ0XVWKb1iA==", "AYqTtdvd4umcI0JT1KSTSDEuWPAz6H1ERpRXJ9qDPFQ=", "IjcyTeaNGNQH2z/OKkAeivR+qMW8Cdhi0SuNv9OvXzs="], ["HWbyCPwEQRoThcIuID3AjwusL3zZ36zN7CDTuTJSrQQ=", "EBS1QNpFlVu+dZ38nsS98yqZ1WzSdC0mn/hpHZFc8kc=", "FyAXRgYiRminBnw+jFOx7mg0kUSvbWly04yQv6a8pjk=", "Bmk4k7RaQLxzZpJf55eLuA+9W5o+onydy0VrKwRnDE8=", "JJyHUedEPpbG47a3jX8ojooAwF8SWXyYT48Os/nA1PY=", "Ga/m2BAx/hy9/ysk631pGlC9a9jamO9ljXUXFIDNZkw=", "IDSVfj/Dc+lNd+CgUKioS6SQlf/G6zp3dt2GlA2Q8B0=", "HWXy81dMH+AG3y1Q/tJXu5NfkClwx6rhMaQfLeS0i7c=", "FWO7YWKeg5IkOM8HI3Fs1NrtNq6UjnTFyF27fpiT1kU=", "LxC3j3RBBKVKgUkgDK5Z5EPnTtqxzDy8LYwXDM8veIk=", "BzltUdGdlMs0swSsYGtUOZ6JJzq7Iv97trQz5HLOHo4=", "HLuPpL5On98Oyepn343ywbeWKR51209CfIQyFv5Ig0o=", "FOOmkgpBLagdkX57nZi7qEnMFl5Ab7PEOsQh+a3gwig=", "Ko5IavqgGqju2lcVQdIZm1XI9fcwylw4efJGwieAnJw=", "erw4FnoBtrxYMVh95NeQ3kPmjmyp6ry2S4r2iVrZaA==", "AeglSDqfhQgVkMC6QAWf6nhhcZ4rfaETI0NzE7d7ao0="], ["DsHtOuO+rE3dH9sXucfGSOfsgYhaB6W8vZZ+ajZ281Y=", "HYOF6Xh9FFa9o5mqTX9cZDz68l1u1g4b6a6LmPvt6R0=", "L1dLhSlgRaKxMo9IKj7GdHk+owDggXcg5pEtRn3wZ6U=", "KR+xdOXud8BgYVp/WnN6V9VuIGCESu3QqoYym5s2FJY=", "AjYsOOpTjuiYoSxkWMOZ0ocL3YgmMH1W8Duyjg4w0J8=", "IxcTQQrpqNoIKEwpuLl1QQ2rb4T1ZHXaN3ETReaNXi0=", "Lvafwac32zq8iV9laBHlnn2HM1Wy4TQqpRNNi/cCrJA=", "Dvtg+xhYT8htiO5WnacQRvdlUmsR9sIAmabc3+68T3A=", "CwROxtFIY3pH+ReUT4HpyLg7DAxcob00YqTg2qdwPaw=", "ICZ45DFkgXJxOvqr4sjqFIBhIFxjn2ObXkXUmL4VUNc=", "Kh4ZVOWwEEQMFnlxnloNsnwKp5V7dV7PLJs1caiqCg0=", "FU2eew3I+mfIIBb8aHg29hKEQx/J1oFAXt+zjM8opvw=", "KnBNHZMlPLEJYHD78m1N8rr02SBX2HWWyt0GMXYmeRc=", "KiTU39bp1kNeTKGZTKEa1626KSS2q3z3xqnvXn75riE=", "Foi5qcvDpj3zoqNcaSOqCUmBbLV/76bpXXYnt2Y6Yxc=", "AdHKqESdpyH3yUnM3DjsjGE02X17vN9Y+jxHHFGmcqw="], ["Cz5gHjal2C4CFDYshBlHTcHMLA7YEmU01po/eQsnxgM=", "DmuTbsuKWSdGJFM9A3Rs1dJm5sVJDTyVraIvSiLoDjI=", "DVbN1zDhQB2df5PaiNbzv7jrH7pEDFUrB4uziny6VbI=", "EsC5PYKf9blkHZ9vLdtPksensUe3lBObzpith9aA1xc=", "LeB0deGXYutbrMrj6IqhST010nbE0FxnBpe0OCSkFkA=", "LqCUoi7kdV5d+DUrKsZx4jHCR4XbNDuRRfnkQpezYaw=", "KrRoLjL+ulU3CzpHetg/MMiNs4e7IMapsuVn9dYKSnM=", "GnDuT9HkXEmOdx6dAhDdFBRcwnQMNgfgROPGi2pgF9Q=", "IKgV4ZphmOOi+Ki8JjHFUlIRgvY+ElR3z3ZaJ3BwNaE=", "Amb+BcYxt0rhzOskFDqW4On/9ZME8E/tz02z2hNQhXg=", "GQ3Vioj92IegyoMGgayllJ6okFD6uEtmKX19FNy5GnQ=", "GuaG7s12I2VcVRVKqMXIITbrVgIPuNEZmv9ci8EesMA=", "IK1GeO6BLZblRP+OXmXU+3vxXMalJObxneavmDyZewM=", "LK9nDIT5i2jQX07mcqE4gwY3bniG4wvSsWO/p/wVtEM=", "GjNqht0LMyWTMjilO/aPIf816Vaf7xLLth2KucH1CuY=", "Dl/HwdF4VKBnNHnUWJ2oXm5h9IzJULPMUxVkzl/Kh08="], ["Fjy046XskuV7JbCVo6qoz9xM5ZJncYzGCQoH4UrxCw0=", "GYU7FmlTS4L+5lbwN8M69zO+14WrcmsIJd7nm2KblwY=", "GxZKIjjF4QdpaDSsWN4bIeSaNm/2MHFZ3UYaPdQML1M=", "KSPCpUZNyZFzPkYSTbdMQF4ys/2d+yrLfYibGaNAzpw=", "L6GmsMaw6daGrWCAHHKVXBrCVtI8VFFS76gdym/hSA4=", "J8+HUBl2MAIu+tkgPmOuovGVMVodBlo2iUpb7TK8iUE=", "I/nIP4jOfHjQxsuAWfuGwhEMfCZneLqBabZl2v2d4YQ=", "HTzlHRGIWqzJp6O5/SgT5+1gKzPTM5+9kbuGnGiBrXM=", "KT8YqnfYNyvJylNmiphw3mOKcGc0Yxwh7a3bIMSmuF4=", "GXudBpVkRUt/JhZu4WFIlvFT7RH2IV8GlRuDTE2jgEU=", "ExxczmQ9K42dKUsyq/LJAQ7GIrrW8RgeTa26lUVoS/M=", "JVa2G3cppSfywBVEq8WFrW2pySs9+RIfN7sP0MA9LNE=", "BaDYk4CioqFKy4YMO/MqtrPJc9hLDWGjCMpzJXwZzbE=", "JHhcgfY0BLRhJkNq+yf9I0ASLpqYpYxGf/FKu1qQJB4=", "Cf3G9s6vJWbuOmGKxNd+hjJ+8ni5aAE+M/CBMZBHKzE=", "Aq/IMWYYwVM1D0uiKeM4IkXBOZsu5KyiVYAin8I3+U4="], ["LcqQ8+WhWymJX0jXoSkNejNka4liDdCozN46o6UdQcs=", "GsERlfdNf95lfQk6MTFx8Lw8/i+5ZeXDUpAPqsJTBeU=", "KPrm79Vdlkiw2d07jG6SjBGllB3W7CNakBTG3TWtMVo=", "EuSWuyaAt9FOur+4eX6ca7rGikDIuP1ltd+xjjjJloA=", "GQSJ7060GC7KUTMriVh11sy33QYKo2TB0oni4ad0ERk=", "FXdlg9fSYcboszjDs/pDI6veZu0PR30DVRGcn/VILrg=", "E3DAF4n3EihCkO8c/8XTMoj7UExXY9KAGFK5YKuYr+A=", "B4brtx6SC9FuPd/et0jgQLfxsaDwSWf1UhC64vdrzPI=", "FdTSxxPPWPSAUAxuWRb1K26hrAcHcbDIOm+hfPbJuQQ=", "D6suqOUArtZGMKUfi/nr8EAHPiOjzxiWOGVtbdGvhrs=", "EzihpEep3y/eUKoJdF7TvwnjLk/yyuobO3NqZmxxUBQ=", "BZ3xseZh0xfQGlE/x9+72AyRktM63GBgKwsLnUXghTU=", "L4QLSsXJInwKZIaTh4zzfpVaA3h3vV5cy9jvz6OEZsU=", "CES1dT/WEQj9f7inB+dwr4keyZ2p1d9osBOjqHWZ/34=", "AgSe43Epkm7Nb/OgjgYyoAfMqtr9DUAqQJVhos4JW1I=", "H2Vw+zkkdEL8A6UTmURWfqRvb1NKAhS2Ef07LTuHg2k="], ["LHjuXqFtOPC+udwHM8S7GJPLM/9nG3N6ESLWT3Kc/yI=", "A1Do0u7YSALf0U14eLC3fNkHd3jEH/dzPSzmiJYaSzA=", "Aq7nydhq64dEudO9fOxcKS4cZctjPeCvwQHp1v0qNtU=", "FrpnljMvtWBQ4/xBEfMgzAUlXCkvNNtx6BZED8xFK68=", "FK5GUpqh8redqAh4OCqGM4Mj9qKTrb2RzVgnBRP0tpM=", "DPM+3fxz4pu9eFA1KD9ugFEzvx40u548wvkV4GsnLic=", "Ao9wQWLDvVId+EfUqKT3VDnmaO94FqkRAxWGGf1S5e4=", "HCB9epCB2pO3N1MS5Op1RSPZGYxQH2Vjj1r4hXCNI64=", "HMKbqO7UOqL3GDG2LspxwaRqtoAHd3Z5qqjWEh+qW1U=", "s5WW7GXkU4MGUPjdh9D+iryWy1ljYlLid5eSDga2og==", "FizrRgCLBz2oyBGiWmi1baARgvuJOuHGsD0xCsiUT7U=", "HyUmrprfzNIjq1fp3n5Q9dPugyhKjWKl5AFI9Nzq+rg=", "KP8xHUpEJR/u4FFRHKxIMuF37cigMFPhM9IG6fZwT5o=", "HDYgeKEExzi/bF/aDt+c4srDsh6yd55zTRTXJ2qOUmc=", "BEWLiLE68PnUXCtD33Kr5T1um1b6+x0MFc1FoT0zsF4=", "I4l+spSl+k8wARD7luwjb4wOBJ8p2lB40SJDN+JW5wM="], ["KvMk7E+ed4bc8AQ5x1opS/91PjKSu/YuZkcfpzDxnHk=", "EZMMqKiEFEHdeZoOPnjhqUnwW/mWA7OC/3cQIXcPktM=", "G9IQtubCB02U2fMQ1pBugYkBdeZ1zI3WWcKHQ4oIzEo=", "FLuJH/3/K6ayIjMnZKcgWUBOWB8ygmXq/OT67gY3xs8=", "D6g5m6d1qemOo/wpIx4a5xd92PY8YW7U9IGfDbmCquM=", "F3SWJ62vPqHzHxScsP2wMrnC8XwmKu+jXsHVFuV35tM=", "F6FMu8bD5w5QFF2qtYzNogQW+noLBWQFbgNmvhTZdUo=", "H/JzdHJ5zOVChPv7thu9BPQDr7oQdQf3aBKmRfqft3Q=", "IO26dbNpWg+TTGjJDU7xnM8dix4wQtMjYrUjixDesnQ=", "JoUv4/2tBLBeqrYqt/4V/PpV4DQFNOKOLYo9gYGxyFk=", "C7cWesDDSswdPguDIS9Q4zYOtOlnAE2lMoYai7Unq2Y=", "CVdAG7ZA0V0E2T4843VrXwb5hp5RB2sT1CpTviija1o=", "BNS3LGx6WSKjyasLAVTXsSxF5Q+KI3qTCALkxkzHFjw=", "A4/TyXLY7XcF/7+dRiOBYoq2VLdq7fT0uymi/GySLLw=", "CY/y+0a/qbSEOSlM6FrSV2jN5VEMhRdeBz8UFKZeTqA=", "DIcvEOJMC5kpRIYqvVIVLA+qCqUIr7mabpo9LTY6XB4="]], [["GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GX/J+yEwkhjrcCuTUEQUbNM0B+0zKRzFmTQLJxw5lmg=", "Doq5ct907sSR5LjEFrSpfD/mWjjU52CT6+0F/z59dQ8=", "F69xAiOFMcmI3GZTI9PjNIyhPv99AGvhgc/KVzvXfnk=", "GwteNdZZgeg2Zjq0k3lYCmWeHdoNjEnBibgHi8/dPw0=", "GqMDxtBVLW+gE98n9/SqkH0Q2py54Ige8tt+wadKu/U=", "D07qgf4RqjIyKLQwovkCHiY51mWWs4IeExzY/V+voKc=", "G0cJeoY0YFHS1C1oEO6PP6O5krkMAJBACV/oNXtr4k8=", "B3zfl+IEnhdk5xaapOwR7TFLrd6ehCGLz/OA/+vkU4I=", "C01oeaVOvEt0Qi9weJwbekdpT2vA+IYkrQFBchqJ9zs=", "FLqR8p+1mHodPcq1XjXt0Q3jrPQZnYd7XGYjtabvjZs=", "H6vAG/EJG4gAHoMrfsruJuXrhn+FuPHAg4MrHbV1N6A=", "tNTCkg7AMYfR/1MbTMG4eccyExXXrqwJtTutlDnskw==", "IZF5Ltbd1sPqiuAJz9EXT7nvwBSCSIwQFQLjTblTgV8=", "FisFoSBK5myoDQqJ4QQm7k11f5s0zPCMGqxpfFUkWYA=", "JRV1UAzjUm9LGQBhNh6yV2WR+e8vCn/5pwBe/DxxJjw=", "BDhFkuQqzoyAFPcocErZNpXlChbFGZ1YFeAM6BjtgIE="], ["FEDcJXj0RpTRjCX4ktmMI8/bh6dyIAAg6JeCPUvITTs=", "L/FTUbFNG4Uu39AajvEIqwAaEMjWboh9rxgXoxUoklk=", "L9zewQ0zVJU/qcqHaaN5nQAWJrtxXxmpfncvK6GrxCE=", "FG3uwHc/B1F1oghGmvuHGZ0bBjyZS5gSXbIuhYRPtFU=", "IPAIgftTO+ibkkZ4DfcqJuyxA8VUubb7F4RP3cyyNfc=", "C0Geb8k0jXxp3BW0n6FIIydAY1zy45kEy1v35OHIUpI=", "xjIdnwTf2RpPyFCrfR9/pm3jjWf6rCZZmsYsgHhDGQ==", "ASeErjqnYfOOA15+5fISQuKN9lI12oWZ2AqTZG39y+k=", "Hgnd0Y/cPEbHsqr2z9lCxicgzRYwtj3KcrQrSmQJxaI=", "KnGjpl5JlCuCUkWqEnusjd4qb8pXDINl0yUbFG3NB4w=", "GX0Xiw+R0Sv67xj0AmNVVO+6faWb9F9tqvPuukRMO8E=", "DPaSexWxud8WVlgcq9CQm37i8dygJY4YOwewMLXbMyA=", "KEFRGRsjAxIpjKDRzG+/EitDX36N4l2dGScyKwtahPc=", "DLj1MzCZcAxtN8eHxnv3+mrV41wy/BpTmo31e5ECV8o=", "AV1aYduOBml98doPBpFusy2Q6G3cU9F3q7x8zIbxQYg=", "Kptg5K4Wnz1fy0vdcF2J4Kk2HiObw0F8MKQs5kXnbWs=", "CIOwtgZpWwyWpnzPIhqwFp66iVNj5myohCXONwDA59Q="], ["I67rDGSZuEv8Mq48Qt+XKHmP0u93TxUYuHC8V9E4WQA=", "EB5+NYCJkejNsGJ3lvMxuJ8mRs8CY5JKpgA0YLNRqUA=", "K7VoqZ9VvqhLv3bb8PVNXxMx/6H2LWhvNwmlZmLlGTE=", "DO7Rt1svbvFDi3UeitTeok8aIPHZojWJdy20m6+ZMvU=", "KvUBMS4bZTFV7H+ODllkmy0Hj1zlEhvoP6cW4bXasr4=", "FS/bq/4aDe1uK6VJfhQOzR28n6jfZwUjf8jHZDF6x1E=", "DfZsQ3y8zSaL3ESMu3BvSxeboiO2u4epIQlCV7rytp0=", "FeVSHFgLn6ozfZugZRSsllw3Oi5gQwW477Cq2ALnKiE=", "CaCakDzk9pq5ndR8Fgh/7Kb8ISbrxM/Y3vegJTMD+GY=", "K7UtwgKOmIeyqCJxrEb3gA3RR+cGNw7l7bNblVDPcbI=", "Cb89Afl+ImRlBfdv3TlrAmvIvLoOBSLtK6MHnTAf3Yg=", "JrcsNosL0BA8t9zKCOaLREbueI72EU9rqJkgLx8ZtbE=", "K8uujVRx1WLohbSxhbVq4P4Rylv1RhoeCkEgVWhSX0M=", "CAXWhiyvz1AwqzAmKgHyxlsrcxKsknm67VDBd1Fr0N0=", "K4saqZS1TuVhd2bcgS0V08q/GH2NtKuNqFEw9z8B50Y=", "H+1bdbAen0rwHr0wpvNV6LLNiPGeSYkqGUA6iV/PKE0=", "F+4ANL73fLsRX911vpiAAIr1aO1jPreyq9+DYcQ1dQA="], ["HtnT6Sdqy3tNrlProUiAb9m7B7LdBhhyEvq33L5j1yw=", "LAVjiuL4PnOsmxusIgUJ4w/1dXNCzK0XJhpMMOO8Y0s=", "Dx+gjkJORpHGa/ClJLgeiG2iNLpbv3jMFoyKEzU8llQ=", "HuMqlvjT6P3o/7oPzXKFmEeGG4FDBS4hK7VrED9vdC0=", "IBktit+EHl3BEJlCOBgCZ5VN4pyJU3OK4ZZEessYKno=", "JBmmCaOAFX2fbG5kriz7bks54NbsBmG1RsFVKmIPGcg=", "A85Y8UfGgXKPKir1hhRNRw4iMegBYflyALeqbWJLi/k=", "EqupY+QV+bvJXF8cqK/9WbbGsD/Mzcy0F6nYmk7r+zI=", "Fn8m7trimfDlYVfIx/3aHstI+Q5VPs29TvNbku+fOfk=", "BIahOVYN1w6QVDIRlt25c+fbCTUM2s3jwceBf9K4pG0=", "HkpjLDTa1BhzxUHFyu2gK/WPISeZS8oLB4C86uQJJW0=", "CkceYG4lbjh9XkTY3lXc3YM7NkuvAKaUtS48EPIfgUw=", "DFLxIkBmwhKjZnuyvu2hgeoAKUxaq5NI5acdaWyPzSA=", "Gy5Rvwr8FhiLfsYzJI6svcVQ9ZLHQu3JGyBNSd+sQqE=", "JdqR6b5Q43Yu23epBwbfgCRhw3SnuQ+yrAGJMPOyNRg=", "Kdub2fOUA4Txd9djRyFFHd0MaoaP0EcWHCNY6cMFrSQ=", "cGLeNPXHStWCKUj7fEdiVf0DoT2dh4EmJxKUbbIhVg=="], ["L/V/P36VsDQR23kKhmR0Z1gRlxJNIXUg7y5jMqWzUYU=", "J8p7jDMgfnWkLLoSN+DFaNOzH0dUJNI6n9C6bvGI35w=", "G2ruxJ5ZNqI9IYLeXKeMpW1P/oWJ0+d9B6NGkqfFtEw=", "BelMG4G74W53x/0tslSUkEbLhYNMNODYmGv/cu0i9vA=", "JKAbiAGyhlw6PSC28x35U1D1yqnqFYs6wkDOuByPbNo=", "GMZH6rxvtF3sYb35AH+Dhj+2t4J7I0N+EOSbr46DXKU=", "BSPL3FeHwiDaJ7zVF9V787Mc/55OLpcpnUTZ+DjZZGU=", "F5mYnrxPvLhOSHtOQvDkUAwwnC2Q50DQP4+bztoghhY=", "JU2Q8hySPjD8tHFoj2SmEV8PQ0C3RMXXMqB39f1rRqo=", "ENjxyQqU2xCntzDYwhxp55PMmF4e8sYriBXmXF+pGWI=", "EDLM0g1O1FAt9/quCy2b8sU2gwSiRhFZfXZRczBTzkY=", "A5vtIVLBzDj9igrd0ibCtdUwl/g9gm9+m5o1VqMsgAE=", "Jh1ow2iu7vwWfWs+LSK+SEIxtbgAtROUEzx7ru8vh5o=", "AoiTMFJUGXvvYDB44zPbNh3sGnd1gTvZXTnjhnKcxmU=", "L1cMgNmepJu9dsGZ6WHba/WbpuCkdoOSNxb54Q6RMiE=", "IxjzofnvXGMmlgAU5iLbVtit/IhePQvC0G6G7AexVsQ=", "B5RveV+2JRu+BBE4YH8O5uEkPcpx1ZLK1T9jTf/ZHM8="], ["Ffrvv4WEo4lptKcZ/+XwLCGRqMztoLd1FiID0wuAIIs=", "HdjFL7zW4Gzt28Ei/8xlbkwori6IuU2nnzona/X+Ks8=", "KRVAizt8LPEnmZ7zqEoKXC3nDnW8sG66xnxzrTbNcVM=", "LmVffmJ38hR2ZaQUYy6zpBis2Q9qKXSOQkn2cT1UAH4=", "Dg3ty4mEBuw24a0uOZK5nItFfMq6IQW0Q2uoQOib8NA=", "JwqF3PycjyAs3KNVJG/ZiVUUlexX+LZTM0Ljr4oebYU=", "BJS0xicxuvjzM48swN2TT4JgbnaPVjp1XMUBUEpQqcY=", "AXBh/aoDIJfgbAA9nXGdKd9MMBCdb7ht7zJENegXa74=", "D55Wpa9ThsSITKfQ53kqItO5aoAfPo55pqxleMHuCnU=", "JKdGgZu4V07tROIzGc790JwOjC3Rzmkkpj/65Z6xqQU=", "BwO/7HtTK5E19yp5TZ46PG/2ZcCNWQZ3AmoGzaZgVek=", "Ib8egmo+IUGtLNDGsoYUa1MJJ/Ddyln6eNBqNlZLej8=", "L2eAcMg9cZRQOFAcdLpZaLExk5pq9u2yl95fNF5mkuU=", "HDCruIs/t//46X2mEHIJ1gj72fLbl+YddN/xnT42870=", "KhT6v5439El5FN5YaNqmKO8zR6YR9nXZTvZ/wxfigyg=", "CeqNggxObuR6T8v7oZzZTpFd6d2iWv0TmckhsbdmaFQ=", "EG17Le1GlFs5Ae9lEkXVGa6TuNLuqBYJcO0H/Lb1gBU="], ["Hm6qsRkVk94NicuyOZq4qpVdgprZWUKM1Tm+MLcv3pw=", "EvF8KA76QN8Pr9txSNeuhrZAH4I+R4VLfxHAqH/wC/U=", "L9l8fU4zHjKNPtoEemimT3yshntr03leKTLzUGRDdKQ=", "LByPYLY+jLugFtR1ugSD0AHHBlPB68JWxR4Yl1Nxzwg=", "D7LWRrUFxh3FT1b+neZmQcZ5flnoYFKK61KGequvwv4=", "GkSDXj6WIKE/3AcsEhLpQu6V5oPWwH7wl1J7wQYWxiI=", "GS5JxiZTDVllxT3G5CCYVtcSJqpQIbnqqheEBEyLqqs=", "gPqd3fmFE3vP6WUGhEnLbrNrHdsXBthjKGTpVPWsWQ==", "D/E1XZY4n3x0snSVCz9wo9dLv+mShgx7ptkGblkmDDA=", "I39PPXlL06I8xSx04O4Q3KHU7dkKOlGa9UlErJHerMU=", "HJSYVQcVnTZ/KqWhoEhXvUTSBe+EObhEOGsCWXZka9I=", "KG+xXpq0IkwDGa3ToWuMgtxxkx/jvi9LP/AomlMZxKw=", "I2JiQ47TrLv0vVbDnRK+Zf3AEmVivNVGiknaa6M/yao=", "D2lYeSldYQ0e2w2nw/pDw2M+LQLS5q9nmaLaQeQcNoc=", "IpSdJ8Nz5ER+mBTW8YnQZLOwkrRID40hyMEjQqlWzaY=", "C+Cl8FtvLesvtr+DaAXVLZrSJOi7ivbg/7GUpJzgJvM=", "AwcIiKYu3t+uDXLxRLirNw+KVMUll9sz2Ywk7fHaug0="], ["KjuwIMilDTEO9bXHfMQIsHf+JIFFR1TEVo/2aP5fCXQ=", "E5mCDd9IKaJL+svkf1a3kxF/WZ79/PngQr1XgPq8KcQ=", "IwPC6JoUgooZqfddl/F/4ItigvvAkObdaaTXgAMmJLY=", "H3pfj9MLH51/WFXAhOiZU2eImhoHbaF4Wc27/IMBr8k=", "FPeenpxZmOjL9aLx3hjKdwf1YntWN9zZYnJfjqGATTw=", "AQGZz9SxzKHwytrPy0KbRLz4PhPMwJjZCBY66qHPWpo=", "A0RZN2/kJGx8pvKYGAwhUDZ+wF7eDa/cSAbTTkTBgPw=", "KTPrNCeWp1r34dwVwEkEtfaLtWrAR4qFIzpYhQntrg4=", "DtSU9vtVmKsKCnxlWJDd9KfAaE8kUi0q+Y2+sCBHkeM=", "Io4x35BVZeznJGwmGqW3APYPbd1dfCSSZHSKs+Uhog0=", "0292aaUiYNpSOziMYI3Cg/EH6VeOC8vh49QgG21b/A==", "LuY+o4zCzuDgh4lYHLMe7psRLdYeQDKovuvtzraqr+M=", "K+E3RtSxm3cP44K8fnpW6AXBreDJI24+KPkKX6h0KW4=", "CRYkn7u3UOQc5vlHXmz2M3ykrOY/eko3fBT9qceyBa0=", "F4Vd9jX+jn/HkZQSEG6YUuzFeqC3WbSQz8R3MHgBb1M=", "DrtI9TeHc+wEisPrXITUTLJYVYPORf8wqTch1w8onQw=", "AzEGu959An2y9yiyVjpi09b4oCrhFL+4olk8ai/BVSQ="], ["BR+BXEVLYBXH6/kMKXuQ6WBM02rMavB/mbXlH96zIjQ=", "CkQAR5T73c7qx4AQ2IshRphMdVU87CYWR1TXJZg1izc=", "IkI6rFoLURkj10cUjgkdGUXCUqd+UbzGLuFzxUg/gKs=", "HhTAoX8j6UrENbt/YpxsCrZvyoxNsIX8Vr4K2dpUWCc=", "GVjWVHrM+4hNUCKaT9WyNKN39cZx+4ZRcNCjk2gLo94=", "FLzG1Lgybma0U2keXJSKgKYYtPfs3Do4BHjUPdQHWrg=", "GTAlJWuYceKv68lm7WjzjS+QakhwZSgF5CRjU/Vnxbs=", "HkIAv/ucpOR7snCgno/ZlAk9vUgFxMwVGFztKP+HLhA=", "HR+lqDdC65u4Uxl/VqRzJiWyR056rbkxHfvcD0GsYb4=", "LWUNqofH4cCbU7EFlbqx4UwypnFCCSh2xXtLpo76/VE=", "AzMZvVtSR6PLf2Pa5G29gTbz86m0qgojIwkHDXGPfUc=", "JuVrGeVcm7XfQ2wT623v+rUFmARVJEI3C+U6lRsKniI=", "Gg8JMLvqZa0JUXTtiq6qhGKNNUcb2tN73WJNLu22vxQ=", "KXkhCIqUv+7qIzyRSDohvFmYIDTgyHOMZSbNRPmhEwY=", "EIKw8mTGHze3H61ATLwCB/gJz4ACp+OcApDYikgSA1Y=", "JcxSkBrryzX5zkdFe7xFB7uiGciKW9Ein23EbFA8dp4=", "KuG1s+iRF+CLtzheC3Ed4zTo/cu1DqS7NxjV4aC8gHU="], ["KLdcKsFn/fGEclMXx7u4CD5axbupN7z6bO/LaeQEi/A=", "BOsv+sHeFiiPUqS3QQHLc9U63dVrvtMmvsGA7SNjwiQ=", "K9UqNg8zKNXJimst4V3xUemXzJLCxy5UKBnjF8DuHSw=", "D/FHgpBv2GZYS7XpPNGGeMIuMg3cZtb+DpF+GN4QlPc=", "CkoFP/tB+EryFAfGFR3FSWqWUaUZ4xdmTs3tsBfjxQo=", "Gd/PU15yMyet2V025ydq+0ckCGmdchLzSr4y+Ai00pI=", "FV3ZyniYsFWbPkBxSebdZL7W+YEdWbHOynSGoRDsmao=", "LZxbzYTJd1nijb/b6fzms8HMfLyaLjXyzoqL3ICjFUs=", "H/PQHTKnD6CRERnrvLS8/BtPwwsuwimIMvXaTc49ek4=", "BEzilXRd7Rc3vgv2hynWae/Bjn6bVebvZfiV4vnpUFY=", "EXN3Qp4ThzYijYdiyMZWepNpgLfAQ4gq2tOVG5mGhZo=", "A5wX1QYFJh2rx2Z2EgsriJrlBBOLpyKXbY3IIr0a+XQ=", "Km8GfPydxAhQ9VKrQtbAltoEX4A5RT16ngKMOfLxN3w=", "HX6WEVH4odH2CS8QKnyREZRhijuunveN40mpnuBe9HY=", "IEMeXTvP9L2QNyoetjfARTYxeoGwK0i1o65FpOg4BSc=", "EWsNy8NfrnZpFPwJz8NZBR9iYQAVHusqdi16BzgTKjA=", "CrNAYE6B6zel3L8efV/96PIiHWCzgtQ891oPE2DqXHI="], ["AjrzJFmWg9m3G2HQk9Y9y72X5ElXMz0ml/3QYMHktYU=", "CxFmAFbgLX+EW3nUm/u2hVVf67VOqlA9mHylKZUh0W0=", "HyCTguP8tE6xscA9wr4ZWz+S+qnBrhoLV8TfaeelPVE=", "IuJa/PI+wYo2Rx1ZPryNkzcjFc1mbbZr85j3cwKF+a4=", "GOr/TJ1dANNIPXsMdFUaRIfEUs9nLmp0yjl7449deT8=", "Hrufe19/DFU7A1UtEEaTUVzMF1KcbBpGLAwkRzYw9ng=", "EhK6GsO/4MCAlsUDvjUbuuqSqj0/bCZLc8fO2n+L1yE=", "LwJW+bRyaXkPPytGp+8lNthmHa5g1QphurWDRug4hcA=", "G2qEQuSLcJeXpRTjbB+GsTpBPrH3/vRYiHgz70tIISQ=", "DJbmF/NjkcxRbrNjHrihjU3RDRcTW9k/RQ72riqUURc=", "DtncFcn0pg+BUONnunGko3qctQyQMRlPVYUKHl4yWRE=", "K4sgHhOQDmOGhc200HwRCo+OjVAM7oNWaqczYhzCAjU=", "I79OBE9ni6H+9izgcIl9Y3ORTuk2+SovTV4JiQ4jjjQ=", "Isk9RZrF21TytqTyZ7XwSbl2qT0Aa4ipil/A6jn1OnI=", "GlSwtH2Y/oOsxN+vg7i/fZcmhJI9XH3OqYlLagfZNKs=", "IsyzhCstdaM7ZUZaXc7OaHCvq7PjQB+utlBN5AY0iiM=", "Hpq+rN0v91zKCTttiCakbY0sBeMNHTmV2nakqMqdKCQ="], ["BaB4aKfJX1CgFYef583x62wxfk1InUUVII3fQKMjKeo=", "KMU8pdtc7Mq1SNFU6mBx5HynO2zU/afkI0A8toTTBw4=", "BlGkh+nvkdnE/XUXjcV6ofdu31bExcK6bqfG2RnpFEA=", "FtIW+XveqfiwECXLR6zV0D6EadxrVYojWiPSuodzxx4=", "LIpcfzlLBx0PMp1R5FHIc4+JaiuPh8brPqrscc4c9xw=", "EyF1zNqVSI80i6N7bDZB37yp5CR+xDl34nn4RDMMtpQ=", "KOunhDm6KEIp3iscYST93jYyP8goBZiFATN6O0iuoEA=", "FA9VCxz+QHn3xE78ymUV9wqeoZDSy0os8RZxlzexViE=", "H6CBQsTPSc6xNTL/bxxFP5rEA12OxVFPTztSw96puw4=", "BZLPReWi3TgvHG7LBZyZIy4rUrrFR1wQtmaWmMroiCc=", "KJfM9Pdd8iWrWxx53kd5RbJPLqEnxcuzeVQ3BQWVejE=", "KI7EMJyBoNLs8WwDdwbqTVJtcXKFrgLaAI0Uy46iPsI=", "Er2IKw2K+AGuJXmohLEfgPG6FfSHQfYWCUZr8E9ozvs=", "K7rKQx4dRkKBoeb0g8tOmyAC0KC6H6cLYMG+zs3bHnk=", "FzCHysEj4HoDJOo8IjHMqFnX5NESyOL03JJJVRyUEAc=", "C6vBqmqg17I0/oFlH3ttYWYH+nZlNNW67m9jvwKZX+0=", "Iz9SdKqx0QevS/fyt/TVfY7gk2AFo1JVScv8dWl8pkA="], ["LFtKZbxVrF++695Tzl+miIL67SqSp7P1cygyxy9/LDA=", "F9Xn4YYrNwjLo9QcVWsHDaYLc/w+8Zgify2tWyAtXJo=", "HX74Vkqax9zpRUd9UprOY0gazkY6hsvcEUBkXtV9Czs=", "HtyklgWW1BVIGZruYEDTnYFORWJJKgcHMJgvl1VhURc=", "JYZVrplq5uTeum/s8RkMKvv8Hb6CRUVYoYvcmBlELwU=", "J5pCshjMVWEy7K9WZsBOiZhPX/ukIlKB0yYaSL7G6rk=", "AkYFzkqqM6C7wI1YbK/XC89MY1vtz5ivw/sN0ykJ6P8=", "KSSBp5Ly3Ul5sEgi1z7sAukMHk6kLKVBSYm6BMMVKcA=", "Gfjv/NQXt5AWtXOYp7q3L5Ruddhij1afMn31xoMpB6E=", "J5xx23zBa5xya5NFRcL9t12VbRb4khCu39fbtPHZ7P4=", "FvSvxHph3zN0pwLygAo6OftEUKn5LhHiQMxtdsJS3kE=", "G6fYsIPrDoPPkXjv6FFOYSpdOQXLnkJ5scCa5T6M8jo=", "Ch4uEqUXIrbgrLlwXEQ9FIsTNN2JcYXu3UxOhxcOQsM=", "Ada3u1Hrm6cZeZCW5eDBqqWURWy/CLK/mkeSefdSTT8=", "ARKfuWk1UlPnyzH6lCl42zS3zNO8DQzQK6aknhWdHMc=", "I+PzFHlVDLGXI1rxB0HDdtMm+FiB0fEHaILJKCEvi5o=", "GsWiehouoNcDX3TTqbVLZx5YcR15yHtW0y5AmDtiyNU="], ["Fz+JXkcsTrFqKv87jgQX+zK4PrHjIzRxx2oFUFBdBgc=", "BQCmdsXNFZ5jUe+NK1Z2RvtNTGHTwLgo7CAdT0JZkc4=", "GrpCITqh8V51UMqUHZvEheGVrCBMUDav7pkqln+txQE=", "IOvAXmINLHw2L415Fu1+PhKALN9ByHsGeQxA9e/fckw=", "GRUxwPosVHoetRywJuec1mOr9Fii6GMOg8HxGHauzOo=", "Af8Xv/R2BH/ZpGaELI+9cRwbPBhB4QnGh7pGIOvEmWk=", "F9fvH091KVz+IU3Of8Id//E/+KPHu4YiTIp5VmA3F5s=", "C8RJTj1YzWhB0KqwZEAOauhZTDX36WcsVfKDhp4PP5M=", "F0pCGcSq3sWSGuc4t8tAoyGe9d7I2zvf7zmzc7Ik04w=", "DpidNil64jl9hbgCW7ME/kK/uL+TEImW0roTlou6mHQ=", "GthOahVjPrqJBQzBXZTkWabC1CglmG+cWAPGbwiXYyk=", "BvDu4BraQJBYqBi6g2lJj7qVbnE6fpNytCIO8V+VSpk=", "B0oIpxp+NLEDG2OXjjKb0OEq5jEQDyT87LWmC+9cPdw=", "IYXkoNJVcMQ1FiJmtWXB2w8jzk5huFuLihhyUXdUtjI=", "K82OPPmIiR5Yv4uNOiWc5S+G3gG7jmxNSdyQP0s+zAc=", "AgJ/512HgEWZ+2bA1lsofE4FgqTo2Eu7yFxkIs+17rk=", "Hi294jVaTZxhrAwNuHRHxn4IVQrJG/BNlnkBQtiM3QA="], ["IGywOMwyhSbQw9xa8ZQ32DIZdRxe6PYbDp4vWIE2a+M=", "JV+9JQ5mKMXrVAwxGTaygsUiBPVv6B73XDmNnwrevhI=", "DhTZjehGU+Iu+rKSYcmjbCB/yfVlDsGlvc5q6ZIjnoQ=", "E0L0bJ4kCqjrLx3Wxh0Lx5+mzcPdj6Z9eXKbAjQ7bfc=", "DkHNwNuVrV1nlG8P8Ciq2MOjyIrPEFGec2+SZc4Zoto=", "HMbTd5Slv5ATQdtoXnkM1/dCe2aQaeTTIO+uHVW9cVc=", "EXw55Goa48kLJrDfhQeOvctmNiUVx01RzbGS94nJz8A=", "K0x30YZ365mpZpE/e6e0eMzaFZ0PYaWHAugPSVKzcHc=", "JQ01+r4x+3/RcZrgwTyvtk5waTL+z+R+R1A0KJRD8kA=", "LHEgdeiEiy0m98jG96zLqBpJgA7TUVIh8D2EVAex4do=", "HQTSJWO96L/xtCXpvxE8/i/RXcpma5Ew5WURRi6XFGU=", "E1zOA1l90jWRqm+ziy5wykHvkcoFmXrbwRNUzYMdV/E=", "AkcWrSlCwiaN9QfiW+JV5FwA1dupYJPfbGPIpN9zPw4=", "Ec3u4bqHPcYYiK/3vlT+UOA+OkpeoPMsasrn0V2feXk=", "GuWIYn6i4MBG7U9sII8pgDolybLAw4W+KUucJaMofkc=", "CODfInyloXqQgcYMrttUNaiv+ZNxpwIZcVsFgA74EdQ=", "ChyzV4JhLHmYr6QNxGf9OciC5rPaurB55jwzC7yOXxw="], ["AkDFeJcWFmbyjQALiNM1OSHZZ0IPQBzoa77kK+KHpPg=", "B8n4NslO706DGzEmwGqbS6GcEcfohvZcDWJn4HiC3Fc=", "FW9a/Rk6EdhySfNCKRKYDarLj+0iXGClvd58TZPVoBk=", "IDpzg31XfZENO84bFf75bBu1ItTwLMQDK+y5B4ELyF8=", "AhesGi8oy3vSUJ2Q7kwDqrQJTj/vR0HPQBXh6CP3HA4=", "DC5BvgDZio3/izD137zicIQS4gBoK9WWshYnAKZydN4=", "H9VnCylM7XgYjP2BakE1jKMrvo4CSiogD+EdBg+MXho=", "KIT9V7cKIwW/W5TDJbAdA/PMLokBAU4L49q7mEUUhj4=", "I+dy4HJe9zqhj1n5NNwRvb9frpzGf6GKIxnqE6abnE4=", "EiNmrgZCQRrykVcaiQTwtsb7EdHOdQszFqw18xDl3O8=", "HQsMM9g6QEEs2vQst+6OUELZpz6xeg1YZ6MZGurqYdc=", "CO77qywcUiNn9UPDNADPJU/gdxH5TpA2p1WFZecwXA0=", "IJ7V+u7vTR0Bv3U3BFdNNP68ev0pmgRDC8D48Lqv7cQ=", "HLdToPTv5hsF6V4JnktVZ3CzZIc9meH3fjilPpwmJnM=", "KjLXcW66HPk8mOm7+AWw5NJ81+PybFYL6yrqQcF4LYo=", "KTbTaoabiyMYEJQSvvPBoEB6jguYtJWe4LYkwRYEBJQ=", "KBrUrecmI5S8VbcaiutBNa87DCQzBwyw69nsjiDccoA="], ["Gq78Lpkl/NRTmW/agEBj/asnazfF9R39/vklW07BDMA=", "Lq4X3FYcNwhOmQ/RvFBX2W5zZ8S4AdJ/amrY4NDAh1w=", "JH7lIDGsBzqB9WqVeQjCAEd1E/y5hTlCpisG+27qO8Q=", "J1YC6KwRNrJF9VHLBT1+qtff9IjfP2RZB6XLFRxVNSM=", "BhQ6fJepGDiwrWgGU3C8lQPT4MjRHyqECywyw/4uebQ=", "HzrtA9N/exRimqLl8Ia9+6yGIyWYjE2pQ/iPQxNkffE=", "GPwKyh1KRZePbj+8SjWiV5pMEutupwD3m6VnJ7q4cRc=", "CXxPDKbfwHPITpf9Syw0HsPEW29xZwDP12R+Qj9eY04=", "3ldlWTKAoyu7FjAhbljR1mm6V1t9J2okMtnG7jAqXQ==", "B0dcK3Iji4ew2M3JKJDwN9rQvWejx0HlZyvIZ3o1wgY=", "JE6YTG8vITPvqdXbvBxgRj0m93SGUGWDlSAbNno59VQ=", "J6VfUQOtCFRxKHJObCCkrnrza+A1Z+Tv3sqYgCFNQqk=", "FLLJrh7HoMFZPvKeeCsGPtSOWA3cMlXAofCB5ptjREg=", "Dq9w6xC+J/vNz6fOXhsom2b+aKMRQDhSLWG0NfF+8gk=", "C/QLyHo5HAUqVuQ6rdMH33UdvEfvfGxa8+e8TODclC4=", "A6+5YvjqLNGv+1KlDPWc1bHwjwh1N4WeinNSTDx3WOI=", "JAARwn2lgbfpHv776PN6v6PG5FasWm2gXUr0iEKHvqM="]]], S: [["Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "H9INy1hQOJb9UpmNalvm8S7DOzy9WQx5PkXegl/4y18=", "CMgpXfC6EYYel/DN3o8gKnCWweZFLTPWShG1vk4KHvs=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "JFjubXxSYHPRZdKwi5XPiUfiDgWna8ErQBuZZCHomDU=", "GMI15ucjOQqmW68G/6VXgp94ov4fv7RO74TpOCCckvk=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "GGjhBmifjqLpxWG0sZKJnQe1LlhZXDk0NsN98kl2pYQ=", "LVFhgE8OxkRcuJBK0+jp7CEVM1DfQHXJy+hAt7YJypI=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "A1EFUN32KSNVxpDwO5uBWqstw/SRRhLafst53c97C5A=", "CaLnuzsnih1fJkomNFrYNl7+AFhAPYpSkJzy1fbuYXA=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "E91BSMSRoWawFaekIz9OSIrpSg5kOb5m/hSbULVXWcA=", "HS07Jh9b6z/AEPQuw4JWSdkBUO7kzlXcn4bd8RApVVA=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "IhtEd2eNrU4qvKu0frXnpBKRkLOFWuTuzYumhkP/d+U=", "FrdkSOmFXxZfIEP18Jvt8YMKSZj/RevCXx1A6Oj81uQ=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "KhC2osuulXgULPZhBLaeRI6ubTvVOshgI2NGDiKGyS0=", "LbhNukqdls6+lN+x1Z7fpYzPqHG5wGfFIuMZSbafK+w=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "HKm78mQCI4KWrYl+waVbT8JzzyDB9o8D1cFJvokOe2A=", "KD03+l410lyD0bnTTssAzQOEjKcwrOUvNn4Ne1/eMNY=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "A0kFeUGxQc7qWgY6D/irIhJx5hihdOXYAJq1+ceR2WA=", "GvLh2Yw8CZCFA4g9O57VD+iVjrHl1lOAFsNE1ABw78I=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Bbe92s9FIrCqMILiwFRIlidD0AI7tkAikfWS5sHaRnk=", "H87szzN+ipA89qDCGmRF2n/4xKC8eJCcfnBBMcijUkE=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LzCiX02EPiiv3YUPMdGSDuBY37bZHDIvyWBHPpF6Z2g=", "GlUWC/SaSTa8xZFiYXAmGUV0qJ5YV3UbaPPAj3wHzoc=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "GcZu6IerR2OxdXO2rRkrffGvJPVHYZmLA7NCuVcJBB4=", "GoKCi3+H66f1+GJLMeERVQarPnIyZnd7N4nJEE+ceB4=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "D1BtMZnZYIPen8TnGyUIJehKJC2BrjqB2Z3rx/rtM4U=", "HKx0gtkfrvZX25ByqXVn/xcjdNmZh6iySywERyqrn4M=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "JJsmsdTjM7I/MZLw5PUohO5j1InuFT7MMhaTmnKEgVA=", "E9GusQsiXiqLlxMRVEB9G/FFly3NOgBzM53KM2GA37E=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "C5D3K3/Phn6y4PlAB4fR3VJyDLwUpwlXhOQRZiTRbfM=", "Al40bt2N1VFCq9ITWVE5gjDwyNCLxcNlxabNcAEajzk=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "JjADuO1QJXfGQnsLRYnvbOuHtOIbfEJOWH8mMKe4aKI=", "LZLva4vcU90bbFsckuWoJI65wSJVuRD/icCZYewS6tc=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LrNrbQv8WTqNbZRZp68E8LFbyuQYG7sSNUOHDBExZoE=", "Hki7WRFG9GHB0vCF85eROeN/SlwjVJUsgzsnkfWQNOA=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "DnWZE3UUGIcfA1HuGAykZs+KA/VBB5wbUbsAFVDYFio=", "HkXhlLFpNsWx+Bxy6w/oxi6FnEZhsUt+MnUDz0nspVs=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "KMi1jJ5M+4MKUa9FKTGLYmnE9qwYZ+0RdM5K78V/vrM=", "JVspP8sb4n2eWq/UzSjCZ0b8NSCIk2fu0TVcLEG5MBY=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "HbE2eo43xVl4NTZbv6Zvbs9A2ndaVMNdXJTacEFVRP4=", "DN2XlRwvC4he3Gg7nbdPCN9hKGV4ppmJqf7XyjTFtM4=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Dk1OQsrLn6Z0XG3TYw7FpMyoqRK37ChXarO6KcVzBsk=", "IUGpJcJ55MTjUWQXRHUNRwLZDvITfRkF2toLrjx7OvY=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "CPn5s6vHnticIFl8+/5JAhEZzFBkjOQB3FDLBCpU0Wc=", "Bq9sByMT2GjNlFyfDrfU6tskyNR2P6BClSuZNT3ysjY=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "CLQ8l79KQLTzdtH6DF5uaVXL+bowH4eO0+rkrIEredE=", "EeDmB6xngco0pxTmxbek+DmFI3dEZSADJCDiq+FhFac=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Ldfw4bMD9CXLfmscMMpCizv/dR57ZRFS603gCLLADaY=", "EH1/ktHGokBouRcSD5k64+6ENJqq23HqpBKLNJgS3ag=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "EKuejk7JrV/bEWbGTtL8MiPH4W3ZgvZtzYIKeGGuFGM=", "MADTs92z+4ZMzHKZhEaKcxc5dxMwNUSoTX3h0gnSXLE=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "F2EDWeYk5/6z7t6AmaHcRcSgxrLevC3I8gD6J6Dabr0=", "Kv/OW3p9jFqsBPbCcIeUzQGoQ5tl1031mC0krSqUTrg=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LUOfvv6NK2XtMmWL0h/FYEQI1ftp4fZJZeWJXKYcbgk=", "C1HMKhscMp/XKihtSThUDbPPxDIN42Oj9op5Nc0ZOrk=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "FGjqKGjTH366/nivjCRlajGFljJy80xR1eJpXEO9Mkc=", "KVU5STJPJ/T6e9c0kg6b57ZioOxXl/3U7T/hlGSHm5U=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "DZeA7n05X3yXf9S4Yyn2zXIAR6f50WctGNLPtCg0Ovo=", "IQoJiv1FH8o5l4YOIgEGx0h/RxaDHf/3gDbeGPF8sx0=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "HO3P4nUbNg5z1u9a+IzVt1orLZfFcYiaDdqHoN2QrYE=", "InGfJuFnI8G9RaYZ6Rg2w0CjBPNkhnL5DeKwR4gK7gM=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "CuDOyVnEx4WfZw8Zx0kPju9q1mNG4EYTwTUFl74AC+I=", "F3Vg3nMUgr23MWwji8OPIKFs0D7douA5OxxRXsZLByc=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "HxmiZ9oLj8K0hQpPRYrdVRTt8KrW96fxda7wuY6BakA=", "Had83v+c+CK1RQkDHqKIj285gFGuGHCv03cOdyTAnzE=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AtHheqqpZ0NmWoaZcCVcJnujOM/UPsmzPsqnZPSPF6g=", "DDdqj/HaOd7JgDFuom72b65chod6j4ImbBRnACQynRI=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "u4VgSO9Dp3s5Vgres8epp4PbXK2OP0IklaacVmgKeQ==", "HYGAijxzvhuyyZtkA/OsSlMsiNKa1lLLsgBhZWAGwZo=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "FeUq6Dqds2PSTMWQDfj/C4HkRdRAmg4qr9MiPDVK3WI=", "KqL8A8tfcuI399iO9m92WhWb5TM1T/uIdRq7iIUgOtQ=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "EK/trYgaHafazlxpVG0IkLw19BmSsQYqfHeJsDrJMsA=", "HRgZNwGXmtJAQkRulH3+360ipufU9r3odf4tjIgshYo=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AvC4RXaQ5Nl3C+sDAKCfxwAc1BcGHoJrxFDdlteyTzY=", "DcMYl9YdcOFocOCwK5d2vFO4uYSL4wYvjaGP+dmB7/s=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AgPJS7dpT5za06FKdgPjy2nBQSAP1GvcnrsNXXNmNSU=", "K3eKIx8h+KbNqjyENykz5hDrmF3Mga+ZJv6LCfGvyB8=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LIoDdsdmBV5qnVJyokZqKPqn41nbER6E2YshOMjJ1dI=", "L/2jP1uFpP3ha6WQrgzUn85K0B4JX5T0kTj+RKqox3g=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AxivU8/YIuwqf01AYU9y/Gyyf0QGf7WNFXibvhVESEQ=", "DSSZdGXFsj1OdDak7O8vkc6fiRC2+opKO6b4hL1yBsw=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Aeo55Nnt6/ZdZI5CiAs5amvs+mazxeR/+aM1d6PSplg=", "FeTgFslKAm/Z7em9zxEmj3c1z169vdSgkv2h7otQ8v8=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LvGFxLHNtwcqgv1D/kuxRcTb0Elz+z73bnV7ADkurJ0=", "Fc7cik729wF9HdPZIlW+tU8dfR47sCBMsHq4HHFDWQI=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Db8UjuiYPbDBF7ERJw8cLIIZVlczaESU6vXOBkXldJo=", "KEL0TdwF29WzGbHv5rPqvO04C5n/xC37CIBeorTEiqs=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "GqB+f/pKA28bfvsuEk51AoQm/fXx5PuLti4evzKYryw=", "Hloqve2McCKoupfqaDtgXQnwF/1D6SKWZWVh65bSXTI=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Cs86sCwBhXO8PTawy3PebfEejMHeoiPpiioM+8Ao0q8=", "G6tIrSwx3OxfzG3x8C3EFk+UkgISJnOwYQX3/xvquyk=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AaNq860cYc3cBqKkxpZ9wAS1iaSos1je0Ro4zOan8xw=", "El4OgiUUz0lTb6ZDpm4dL6Z4jLW0gFyc08tppYTg2NI=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "CFvoSG7LPb9x1jlA2NaJ+bFCQ0oU1dT4yT19Dxe/y9M=", "J1ZRNg2IBjsv7q2LxxrpwALV25giq2OwWPEeDVBrF+M=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "D36yRVltmsXswhRG7ZTIAonbHh+fYgwY94FbJHsiim8=", "IhhioEoA9Aa8Z/dnerRZydiHyLuICRUT8PwvsQOtVJw=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "G9V1YDtwha/PCliKX634cFzafrHUq35wE329R/wm46I=", "FG0dF2JF/3ctuFddmGqC6TEHneYeZxhMQVim9i20RvE=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "AiAuwef9hcR0k5NmTwJNV405LVnLEqQuLvT6co2kzTo=", "AcDnJpOg4Sv/CrPhKhIDyEa139ud1bompzCcaXA3FCE=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Kz2HM7tIcrbLsL2DN4FjqxSlhdv1rZdYwHlI3gVgceA=", "GF0SqjCu0aBXW509zuYzL0+jRkOkKc/djeD9yHopZA4=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "GzlCJzAfKL7im9Pfw138yOHGDsbdlE3TNZOpp3Z19kE=", "FbHP1SK9xBj2wIo96xFKT/SIVLSkllN9Qes6Ml8iZec=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "C8o670aDPoowqdsKFrWavGGYANLaFdoB3VoHE/9Mu7g=", "BSkGJZblG4yiwvjHz0rf8IUxUAFeLmtM568hJQD15so=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "Av2lF/QmEyWnNmpF2h6EfNFQ0CK+KYLrYQXc/DH972A=", "H+xaCc6k0l5bf/nS+6tk0mTbmT6Nhim3FUoVOdEt0c8=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "LYd3bu9d+rvlYFCUdRrxe4MXF/o/jgGUO3TRqaQusbs=", "DSV6Q3kQ85la69Cvub5YSWevpBiMRoSVj2jDn58B/xk=", "Bm9vhdb2ioXsEDRTUaI6Oq8H84r4yVKnvOynC9KvetU=", "CY8KoGCS7Sy8usAE+QeZ5uHDL8JKnwtgZvjXKJcWruQ=", "DMV827CFB9Yr9npEk8wmL7bAnVVwE//x9XP0MSIfj/k="], ["EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "A/CBWrRj8bdu4lqbh2izIxqJdS9Cf08GOrcY5wdXazE=", "FWSL9G9g2ClUx+MwKbNhc1cBKj07HTTI4AiFnx2/sxc=", "En4AwiU94HgYyn8ur911ZNBeqFDPYfHaoM/vv3+/uoU=", "BmNlr9GKQe+TgvwLHSZctNPORwqMu7h499SAUWMHR70=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IZ0U+CNRMUDcaalvf+fghvT6JMhOV9zysJlxXEQEquc=", "A6ML+78suG1KamOoBQ2R+fFPTTNpbTfrrvqawjAhMtU=", "ISG7zeqjOjWwJw+31cn5TtrVqE10sG4zhRBLC0GTW8w=", "GWtUT76wp5LPu4LCieV5t81VgMLjOKOJ0FPviz0Q5w4=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "KAnDoVR8DO6JwdsnDvR5wmlz7HPttL1OfZB+oCAvVg8=", "EcNERrCD75LKFXWFoCuLNCpMZxdbMfS11A1Olt/FyPE=", "JT6gszqL87I2fAMOMonL4PYkKtdwnZC4bZ2AJuLjmSU=", "MEZ9wZMPav6QyJ1AB60p/E9aGcAG0QMEOMFt+FY3vV8=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "L51LVUlffjd+IOb1o6iK96pqU2RYs4u+E8jr+7ulT0Q=", "HZ6dXHNuMVHxHTbUmefgk9juI1O+GKrVTP0D/w/qxLg=", "Ekthe0PlmPnr9iL3gjo959G/7bh+CXwxXzQ94wHlSEE=", "GY58/GauRXdAVc8HO+3JRaX5xbGcrgjXicxXSP/hmbI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Lqwls0mN+t/9EkqzqtV3ieuUW6V0QwmcW7bCftl3/iQ=", "HuAsF1zf4YcbN4MFwbuckE6K8dRFTtNVCzxqtfT5ASY=", "Bhb4w0xgcmaynqj50t+kf/b7sdl0XEhgn6mDAdD2edU=", "GB1osKGIUElYufGcu9uXKoU+Ue04XkiDpDpCgygDNws=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LVOXzoY0ZKJda39bAV1XkYHRzi8ky6v2BZ6TJ/W6cAQ=", "Fb+BdJG5TXHokSlAzAuAJ3cT59MtorZZFyTY29S8Jhg=", "Kny9EUYLF3q3b+qyi2lIWsjMaHdAvJEJlKOCfSnAhxQ=", "D3zV/6RmFzCrVuRH+uXMF2PLRi2oCoVhTCN7KQ3p1QI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "DgdmAEtMQXbrEyc1COtldfdoE32G0wW+ZEzgRTEAgQA=", "BiX6cUWBNIH20Ui+a5yLt7VO48GvrAAQTh92MAC5kkw=", "fFRyUItFmRbuD1RhqtLgsZzZx7GE9RW2UTYxjOLGpQ==", "BWc3VHDRibaTrHerP7dVcjHVMHOVHUPFRoWHnLeon8s=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "HQQGvL7IP41RZfVsBj5CEIrSH1HqS/xxYBF0ulx7i8w=", "DAKxju8iMy0oCoqh+GQF8zdfBjQvhpbufHO0bGMnLLc=", "F8H8F0zZpuvqp63S+AGmZII1Ca1P0bFarQU6Va1tpM8=", "BfhDwjAk6x2rfrvIZwmgIaqmyvQz9+0lighjjpWEsy0=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "It8kIGl8ootcxRxTFl4AJye0XM2QpVyHWJ95LwrYyzc=", "LxQ4MDp7SdRzQAqu3w9IAJ/Tr4BLdr6GQXWI78TXMCo=", "IyPV/PLaiWXGsre0+/miS7qn9NzNNdXKYVXFRjCTsjs=", "AmyFud+75I/oO3U6XnM2ufQPe5YenFT5TjdwAHPU0m4=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "AxURAAJR7Ib+s4tatOM18HCycd9MIJeVKOQdZThMMY8=", "GOWIMkqbuqy0L6aeXZCgwOJ80WuUHjSmD/XfmibAOvE=", "JkK12OFrlTsHBjV3XI08lJg1fWrZvvLn2Z8DwQ6h+V8=", "IfwxO6EcYOjoT/YNuQag8DEYmwtIM1xCIfkJrvg2wTM=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LTVi49S0K8aJC2mMxquJ9zESmLy6xuTp8vTZPQba4VE=", "CnTvVB02DoQuPgtv9+XHx3k0pfZ2FvAcGJ2Ibf0uCAg=", "FAVktT4KgSrDmD1uO0M6+kP0NAh9nnVJZ8LJsbAsr4o=", "FHCeMtmK5M0YtAAYHnGrl1nENsjoP6aZOttvLba7qdA=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "BzSyNmxZ45RCPxeeEmbdOSNy208tumUfSmGaS1K9wBA=", "EfstcFyUsI1a0+PF+2Ypq+lj7ZKRNkLH0C1+cQiP0tQ=", "J9A6v1wfKQ5dcV66GTcQUO9ut/eP2EvoNOTMNhgFlIQ=", "E+2enmtFLfJ/szU8/CzWPr6BfyEqOcaou5tEGsE5WGE=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "ExnFHPN6qhAkbNqqBKEuiHld5EUmBCY6fFt5q5nL0jw=", "C8olWI0Ye3+drYOfLIy1JqTPRE7rvQ5xW2zqAZrD8g==", "HYN+oDQcWWQYEiaHS5I80BoGm0k/AvejwBviPPUdWT8=", "G0HOntNjTL1CxCfOTFyDd0FJ4qbb0l8kASCQ233k5/k=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "BnHw47Z0rnzdx5DsxOlG9LynS5i3ihJ8e1a9ZnPxzh8=", "AZ/Ac3l6ObJy5AzTBhX1X+/raCwawUFDBx0ESaVCbk4=", "AXvuR9JipJf9H3xcbVp8cPpCCUgL9dlzEcUJZhnp/RM=", "IHPP+S0xQbSAdjU5z/KXikx5RHIcyTe6AMyFJydEceM=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "A717PiwYhYd/QxgqVakdSPnFjRUucw/ix6pGsfpmO6o=", "Im68mlOLW7r/Eo7fubv1+gzrEAcZoUyN/tn/u7rZtrc=", "DTlfCwi5/t4Dc6BuFVLA5jSklXKvHYMNxuOU6KXTsho=", "KCQkObUkVAow1Jto4Z4xulKEvTvPHg8vQfd9UzH5n/o=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "A3DW+hnqrBQtLeA0gBq4XgtFfhKekfkpdUtIxhVNTfY=", "CaFvVzsygPOQdiq/JpV56qN5ObwMdT/rCisuC8veFlk=", "IijjYPtbFitJasRD+YEn7jwAIaaQtxsmjZmYE2gjHZc=", "B+QsLKYz0sSfq/g5kUdtIJQx402AMrahuXZ188Vn+UQ=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LOEtcmlmN3DDyrhaYhWjLu01/aHY6ddTpQ/pYJdySp8=", "A9dCdwTGHiAJ7rmxtFoBJQhLxNr3CXOnugsiMYFbFd4=", "EPir8HZBhYYcEmf89LSzPKCW+03cRiZzLYaSHlU+acY=", "F8yvbyb3JnoCXXy0VuOuslGhpiCq9laKXJVkTHxZFMw=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "BjuzBrljEAUThcPOAMqCCtDjZRpuVXVNWd5t8ozqTVE=", "H3Ye5VU8XobywwShgJWrdAMkLgtl5gi8kgz5k6QWmXQ=", "DcXwC7/XwdmiPA5maFm6ZWS83odhtFcXzWvfwJ3k6PI=", "Bt5RFSDid7ffB8NTY4HBPrRM95CiMKvDkQiXYL/EDvI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "KhNDSMhmDvz571SGPnBSih/USBtQof4h8kqMBuEMygM=", "CutQI7u5pkxL2ACJ6Z7fjtX28f+2On27obM1ILz843s=", "FBptCBA2auIl7LXwv9yZlUBsWWCrJhVYNvxR+3y5M9E=", "CdLqBe9U2tu+d29ATcpmJswLJTmZC8C4v+h0l/Hixbc=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "HlbSRKjkG+XRBNX473CJHSLUpUMkQb/o/xoW6RcZzd4=", "HU8CDFfE8UrskIsvmbXE/V4JRH+oXC/Wi6TVxfUMe0k=", "B2ORGjqSpPDgn04UzQM5jY2CoeCduA+w7h6DN2TBj9M=", "EoVydb4v5rm6LsaPkGFkPx/F2aLF5H5VaENm5UswKUY=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LtEczS4uI3ZlX/6alsS4GtwKYDU8XYPU0Ov1DRu/h8A=", "A+Md6JWOgmRbMg1ePpZu9HJtWxws+7Ss0oiiFUPG1ZQ=", "EeiA3+/b0IhYrokARlM9WNoopgjX6QU2bsLKSjbnGWM=", "GDWydd6u0tAHBKnDzCGrekSjRmKXjVPBkNwl6WmlB7I=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Bot1MV4l7UrOWkqUgOHYLOXUT3bxMkJAQZ83L/jTw/U=", "G3730Ersc9YrBS0q0SuSpCaPzNeVyDnWmK07IoIydNE=", "KMDISAIqkGBvYZP/VQG1cha2cHJ/S478wkDTC7qp8D8=", "E72kkpbLzFFoanv7HDnz8lQ3CYWhZmDv1uXYLU8Gjhs=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LnmH6oIEOJ0R6xCzQmXjeKlFcp+Gw+Di/ThJDTpZQUE=", "CCbUojJK06pLK0XBChkP7e9wKu/9oyJs5UFf/9A5Ncg=", "Lb7uherqqfo2de9UHJ33u5ZKhUNcO1loX5O0NANt7Q==", "In7nqUXtruaRlBjssyebEeb6RPX1xav7lmpL5ZnLhsc=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "HQptGpUZh3gFrJDWlvrypf+twjmG3oxpjVQUccckQiA=", "IgiqulCK6BbaTzM7eFT7vNEO6h2yhOw+n03gKyX26dQ=", "KKWJAQNbLJnjan0ptYeiFcnlkmji+OAaF1cglxzPBOw=", "ARL22NQrCg0SOgeGXKE3bfMXoqFP/AGRIm84qK39Yjg=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "CMbrGcAW0YMxdN2hgtJm1ccn+X+00B8dr5BrbTxuIwg=", "E1nS1si1oRbQs4uV+cZC33WxvppIyGmOz+qRA/c/GHk=", "EMUFLsZ6ubakZ8HMGHjZGqoHqs93Jfil7UK2mcSvPKc=", "BYPE0pLVTzzbcIgD5jOPxq/bGI1dTp8GAZOCNoTJbHU=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LZShxVvjghUaQFTFuWMi57zR/is+B24W7iwYv8BvV7Q=", "FeNAL93odw+5lzaVecGxcD73fGcZJ+rYDbxk3SIRw+w=", "GFvph4SBfyL3sh5rhn1acbUAC++LuQLrMCZ34gpye+M=", "GNtDIcchwDZm7YknyJiQqoqtGwDAVFR7XKFM2U3kZ7Y=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "KoUrYkf11h8MOQs/PXmRiFKISbzSzQr/TrITSgObUSY=", "JRCu7VG39QbmX7mhjuASSqUnb23hzXcbFlkwIE2ljyI=", "DyB0oy64Jg+1vTojbwOke0e3+1TcrR15d9ZIZRO6tfI=", "L0xpKXhmvUWoJw4ZlBkmzsNTHJ4SxMLISXFAS/oEQJA=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "FUZocn0tut8F0IOmUJPA0Okt9f1fP9dem3ksVio3Rz8=", "Hm/8XWof9dxP13/Fq1yMTo0+LjdbzRGUqR5bD3sTyt8=", "LPGh18RDCRCdday8k5XLg5jIstQoU4Vx+vo4naKZkMY=", "FA+zmonyb22Hz3bNXOjaR6pdigI+JM8Bbs9kz3k8mIA=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "EonRPVihe1vwcSsgH7PN384sFtrBWZkLgpipOoWJ+eg=", "D0XPl00snttXgejT0getyDcM9WvFIYdJYQkg/piy2y4=", "EZCcgaFlGARree39JPWrzFhagdGzM1aLhoehyezrRNQ=", "KZCyPIGIL3cJ87iRoOPaTWkXZy8tWhBB/Xu9Z5IzDRY=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "BglVGxRxbKPNVWDggh5yheCgg+qaFtwQLs9GHkrvcnc=", "DIwavfq5nQP9k9ztJGc1S2F13hdV9Pk9wIgOqgjQP3c=", "E4vQmMSSO5+9AvM/i+xscw2z/tKY7An3inpV0I8uCxA=", "LmHkvAIWMBFGc/D3cWGuVdzQtFzgfZrj8hu1oxkPFMA=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "ASSGCRPj349lqcQGDOMpfGJqvRwiQByQXdtAgmDY6RA=", "ATgH+Jw5ShM+wQSATZVcvhJfJMVwHZgobGrIt+0FLsg=", "LojRppOPB4gTKqnursCNL1mqREBQyPTE6FV4q7D8L+U=", "AfPSTxfPxgUKDL9k4fF4fiJXvjw7pgfC6PzB8mq/MQQ=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "H+HLDirhafg7nU8TPUH7Wz/mx2qCqRa/2bYvgvD40L8=", "DveTUSKUCc01MykiEimCfhmUbz2NHEi/XjN3+RdwcfM=", "GPsuRvwbkP4cSJPvd6nREVB1UYgxJ4YOiQiGCDc77ak=", "B3r+JXn0LsFMMu8HYeI6PMCtYmOmjFy2GRa9VxINGGg=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "B5dpCS2qWnUmQsBMz4pupU4qyYNv3WXSSLGG8UkLe5k=", "HYvyKcGZaPAlTrbgnFyL/WfrlzRga2drZjx2z3a6tKU=", "KjO32FXn/lX5NVbknks3c3Zk8UI28XJWQo8p9uwb3a0=", "JbAzHX4rFa9OwWHIboS6arIFYHfnqnU2NA3DGHzMqLI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "B2IJj1/iZZjMv0XkgQIRsP/PjMu5LBbi9PE/IjQkdOI=", "DiNNcg1wsohtDaTAB7G9pCNi4UQYXHBxbezithcsJRQ=", "HYK+3M0ryKBuN0LnILf+wupyGC8RwMYNE1yBEVKqS2A=", "BIAGTUs+sK2l6aPn0Fkwt8M5f9a5TUgTFL0caQoXyXk=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "EKiSdjs8yp73WT+7EUDtyMjkWAVoVgz0GGf3Rk+wwRo=", "C17GRUjqhBrJIfmyVTaAeFl4sxVmeuRxTd5M1/Tei5E=", "EFVKyk40jllJdhvXEx3669eAEO3QMOGpzjxlyduTHUY=", "Fb5m842GsJmLk2VUYrH0dbm+neMG4VDUrGSPqz2wz/Y=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "F2rTYA/TSRGC0YKVf/rQG/bCbp1KsMI8qvMI5CfT2+g=", "K281Wz2/ZfCTNQAdcFrBJeO+sg9PwRvTzoK1zwry5vI=", "AchcBqbV1A2B18ie3vsy0ahEjFEoj6KWtt6f94jHdFE=", "IOHodsR0agy9mlHXay4l+CNhw4nkP30fUacKqsJGDXk=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IORiGfaEGG0qAktje8NaKe47CM5zdwE5LZh92pIX+gg=", "Lqcnnbnyqg9lTph5Byd8JEgHZjZ6i9kOKL4PLtYJE2c=", "E2vip/GJJMk2IJbUcrx1yglp3Ad8kXGxZBvpUJF4D3Q=", "HKIDNQG6o/cwZ8QwD7D1ERntVzb7yPH2ySS68N9aDp4=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "CoLxmcJQUnfsqnXklfNONSWCT3pKnZ+h2oEIMrSKUMc=", "Ds8QSFMHtLrpL++w1/d4Kp83onIuftnreSWi3qWAt9U=", "B7ZCE439am3RKqIvCKgpbWhhXIR48Trxauu7szmjk2s=", "HZ3aQ6JVk//SJW00kh+4btcOdgunbWHpy8O23Q8aIVA=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LxryKFIMi3UdyRE2yRxrzNU2frCCE9OSlYzi/T19L84=", "H+z+gzrVQEVcbWwas95KuuYa2mJaGitrGFUaRabN4SM=", "GPyOYIxzWys7DXWDRgInV1ZX/4p3q+Y3vdOtKOSiPIg=", "KPdAvBGC6XBuvwPLP1OrqKQ84LYYeDpVhjiKdUf6qBU=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "BHmYzAr1omuUrTAeS5mNKelgpIUc/ROCK+01txRpZqQ=", "G18VJbMduRHdpD5BXhuaOpclx7UuiA7hMKFKaSt3e3A=", "J1qD+l0ZtFNfZellqQ6sm/dwrpvR17GvlF+lftXI3m4=", "LoeJJX7Sy8zLQwVo5JvJ3CpWM1mAjJiXzj5Apvaieqg=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "CSf0bP6A/u/rJyGkwJ6dF/YMNFANzW5B4pJaOcjix8E=", "H4aK4EgypdvDdhm/5qtql/2Pss+8Hs+eDkhLv+dpgQE=", "CdehHifS9TEJtz90Wy3v7WXZS6gPMI+xnObVbJtF7/Q=", "KC2FfP6No7UQThwoI/t8W5p7JZJP2lmVsMNRqiuHnf8=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "ILqKn87IFbE/NJ/4MK5mOydXbhNcB0T2mH+w9v9Jwhc=", "EbavyR4y8cpFifuhLmV9Im1XtHHd0qsbZqiuTcv7E24=", "LmZkAqycxYgxbjNcfZPbNEeI7sLHLd8/kIFBc2zrw74=", "F1IuDp5k95WiAqEQ4oP6rXBXrsXJ7ZoadJIPJ5TxhZU=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "LS7Rf3ofPuniC0cMrUzHMZ5q20Di/yS3h4y5h47b07k=", "GoHvsZ1+Htqpb6J26J6F0I915UqBNvTXPJN9oWx7+fQ=", "J/9XwcqEflchCntE5S5WMPKZxfRRx6DVFaFrs70z4jc=", "HBqOIiMKvNE8W+lgMb+hZ4QNEXs8aloKEb4mp/X7GpQ=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "AqHD8V1JJ8hDYnqc1TPkJQ2B53dNLDK1nVg2+cGaVlc=", "Ldu3I565BNgcUkmbN8tL4a8Dc6EKwRLhhayyGYmTV+Q=", "Df8Zg5MIWnVODW+uxUvoHY7fi8Je2tq0iob61toK+2A=", "ENUMJHMUa7x2J1/MWJ0DjeyNsocoeJ8ottX1BL0WRco=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Bh6DKPtVk/kqU9/UDhAi5iMbpFlIUGKCU2sItEdsFTg=", "G1iSQ4RxmN7ZC2RL7jGsWAZ96/PwfTxRz6Wg3Z9tl4Q=", "BLAMDaH4UeWYY7BTvUxghxkPC9zO2Z1c5vZ6Qgo70fc=", "I5lBpGwrk9kSanAWMAmnrCf4qNQuNQGLO+yM3LXd/Wc=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IE8mynmTsDrCw1N3ywo3Er/JvD7Av+y06H72gUrPLqI=", "CFr/nH/a26A52DLYvhZaHldHz3MI1RXjSO8RfpJtchw=", "JJBCqNwRHyfErp2wRMCws/EOV9BeCTFY79N13wDqIGg=", "BueZvN8rSnRUKFTzApgD4vhFUGZSAzJ7Pggll3QT6Ws=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "HLPK7Uv/tqyp9NLAApIbw//+0zPK4SCFxhJJYYO4eZY=", "C0fpdV+uSAEooSi/1Pqmo91uoDyrVmiJ3NmehNMQ1Rw=", "DH5M6jZcIGGSCgyf0sNgplBik7wCT9HKPwu3MNqIak8=", "IdofcBusd7y7qjDZZNb29j2+GyDZ1piMjc17pBhyFd8=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "Ca5hLouhyhNwkF+2eJnRDbhrR70Zlltu3RqUhuPGzFU=", "Ji4eC1bKxH/BUPKESRGQ5qq3VEWwyZNz/h96DjuVzz0=", "I0v0p9znWHwsh8KT47t8nip7+l8p/U3eql0/Z0kdNL0=", "L2y6xpTIhrAtClJ8rHRPtljSaQ4hPXQy7uZ/bLafcMI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IqzLGLfEm0t7uMn994t63tUqoYQv/4GNmjMAh23sOtk=", "CB4vBlL4mMbWWfItLHe+MC6r2RgqCz08v2I6Hff48vw=", "EsCiXnDQBuzOo62nXWabjFNLliiQ8//AFrMYatZ1uTU=", "EO+cI4SBKMwv1vyGnfJNerVu/TSe3Vb0n41PI4HfMlk=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IWHNKAdygZ3UqBJitx3xvMLB1BuUkeBiC9o0eWKyQPA=", "LOuwrlEIMY60BlkAQbUkgpJTM2T3mbxBt/T90Sy404o=", "KyCS+GtZeaf+T3wi2VYfO/KFIoOmVogPt1nghwmgpi8=", "FWazQC13S4wIFGGIQlpEJFDPyQDPZD5zgrLYUHoGX+0=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "EaMWqjFgfyaPtMVtbFe6AWJ8NjX8z409GhY+YB0aAXM=", "DefuBpyTQla3gmSLVg5ZVAil6ENGRGCRUuNT2cKHTkQ=", "AtNvQCkkVwTMhN8Cl3CMXlhFw2rnBscuZxKLiUnqsa8=", "AbjMMmte4WD1MZjCF/s06Jm95GzYLavcKE15UdVG+Fg=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "J2JdoPc+oHEQaJ+yGHtxaUy/kgP9Td+KluzoVAdVDrs=", "HNgzij5bGtfNwNpYGmlQ9t6jScPt2gbLmboCW5TkeQ0=", "BeoC1lsgn22nY4VslLZDjHiortjT5n6HehCoQHJ0GlY=", "CffLaNTjiPhTZs/PKEqJXYtiUM7WJ+gQgXdDzgMzClU=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "GMYjDdwPiWgnsEP15Y29GuwTmVogLk683+uWnp1cEhI=", "BzphFLmXKF4akcCg/czaqEUuTwe/0uGhBXgjIJbbbc0=", "Lnh0Y0CyptIixqH8CDit9f4BPzmxZgzno+d0Ky83vn8=", "B6on5xULrd0GMDrY5eS/Qkm36oRlU97yjmdSWdPlyFE=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "C2b97CEOpOq/Yj0nEs9Nn6kCc8y0ZD9oDLyYNFcV6tg=", "L7ainZ85SlibYzuKTWvlHJwGAc4LFAvmQazqQcSapeM=", "KQJcxm/QQcT8hF6cHCzRKIVp+yQ9BJvWdaadyImyzio=", "FQlj8KypvL5BJiFKucYnpvftcxz6aVFouF1TSxe+P0g=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "DtWXgDAiV2Y/csG/xmVut7W8ouR77A1XmKCKMqYaimU=", "B+GcuKiTNps9MK4YjHZ/ORwRiIowAN6/yNMMBhQ8wIQ=", "BgDH0raUY0Xl8e7q+1647Ctuz+Uo0sBSzYYK+0o6onI=", "BZYIO2yXK8EwIqHzPWUjtHc/LNCkgOGeoBJRGfA4VwU=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "IQtcNvJ6B9l/mLnYZj2F2y5kUTCZqOHvbbIQQ2MeJMQ=", "E7snZL8Udc/Hu589VjxcwgHCSJh06RWTJqj0kwt4g/k=", "ICz1V9YlwmCA6wgoYqdnVyh4crGB6JmXIZ5LdXbiTTA=", "DlYcP4vU92521J6XFC0iBgH7xaA9kFpHKOoflf2IJLI=", "EJt/QRug5MmytwyvXDansZS+fBGtJDeL/ttoWSuoEYs=", "DeIAl0gOdVVHF4XeB72YCdV92Fm76CcwfDOunteJBZc=", "By8qYof7mEu4EN+MV4juvP0oJWE8tyu4DN6O3XbS6X0=", "KWnyfu0xpIC5w2x2Q3nbyizI/dFBXD3e1ilAvN4L13E=", "FDAh7GhqPzMNX55lRjgGXObNeeKMWzdTMmJE7mWhsac="], ["I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "LKe5EepPahHaC9XnKrPMYhxZCLWf89dsYJ6pwvuo+kE=", "LeXzpbvlsg13umpvj/4tsB/1AAkBuc4BQN8TM4X9lQY=", "ChUM2//jxgx6Us76kDu+5NOEbSQzn5JsNlXN+fgfZ/s=", "ICatfgNjbe70eTTdDV3SnYcFbRcumTv16W1qO7MtLpw=", "IyUHo9SMoWPF4bb1vzkRQVJHM9nO+A1AT994OTyQFR0=", "Gxa5bmrsidMmpabBgzbsPFbnGJ+MH+dMXEYHS4ZaHYM=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "D99dFUJkmKyCQR/4p6OISJTwLFJC6rHdf9/KHP2r01s=", "CXz6Ehj+ALTt+M5hzSC0+IdepcgoLZD29xU8lGO/vZU=", "D9Hr1nlo0eSZJsOVKq+W01WKqFasv+SOWp/bQoWtm9o=", "J9XcR/Z4MWaV1UjTtP0bACRKEdTLdT7dkX2EnPoC+4w=", "JgLd1+o6KAhgMhpwqoBlYqV76/paD10ncPOhabiK4kQ=", "L6/TC3+semaZd2iSsHNmtA+jh7xBQeAJ7kIHAzcIiok=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "AbKsLJ+X6zJWDO4LjoMg9ShmsXBC0sfBMXjb2WOTZRc=", "DG2xkRjoN2i84k4VVqudODrbD08rY8P1QNW15N7rsfQ=", "D5TK/BRAOEXqV0mXv3XKumsgFu5aEN5XrjWSPJxqImE=", "CRRcM3k4rD9xt4AiyA/NzkwXQvR90hkMMcPMWkGYD10=", "CgykYtiuIY4jW28k9MF3R4hlJK3tfk86WWMUl6T5iGM=", "GFEojMzivezjp/aP8zsAy5YeYpLyrynHdc32zj/gd3s=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "Ca0zmS23kSTtrHkcgOgods86YKBD7fzXv7WpPuP+qwg=", "CzINEADFBDmpiYhsTBHnEb0mZn5hxQr7qdNHy9SzEvM=", "JhI0iKTwN7p7KlE5HyX5FkKuUrrhQ13+MsX0fOY/aKU=", "DXpEA8NAfWT/X2MnWt2GwWEYOy8eiNq4QmB6jz/KonA=", "LK1o+0vmnKE12bN+LTCEVX76ZCOpZi8fskFQsxDHFyc=", "LhIt6yArDixqJeFSJsCblWTMV6j8DTZFvnfDb48n1P0=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "I+CQhFsXwYzBL/g8596y5Yz/Lzd3HDnNC2i6FPTNZaw=", "CLBBtA5H7xiDowpeYxyx4FllQ/XCQHAQAr6dSV1Zp3U=", "GdCtYXbNh+YQm5Lf8bhjEEGC4shbuqxTMLK3pLVvmm4=", "ESluH/Z6mN/3WNAj6nTF+r43Knl/hqYhusS7zfMYeL0=", "GwlDwEzEw4hTNWJKTfVV/4nkOaQOZpHV20RzKuobNqs=", "DCy0VwOlWgUOV8o+Ub84ayy6TV2t6xdJ+KbgR8XprB0=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "IMBhoPcGknSKsvYbflLl3dXnBOUd4WXrGTEnAO72BKk=", "Kust9qEsCZtCwD2sFVdoHwOUfs12Qm1suKdJ37n5ZPA=", "ER+oT4mWd3UlkqddUwg8MYjZenLYqhvjg1toG8aBMnA=", "Gq037WohAsuJK5ineD+wGXUsyMAycZC+VErXYWUlH5A=", "G+bSYqWAsQlWzWFj7yIfPZsNw+XLx6sEs/jyoP/oa+k=", "GftEkH6TaG9ZufF8AmbIE5+PTYpdISUDvsHG73JAn8o=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "DMvQfxLwB9jzDGFQ45Xaz/3k6uj6Ub9r6h1qfEIaWG0=", "CaNCiwEIFD3Jx4YzqjuzeAe82WA0Br4hG7KG5CtYy1I=", "Knq2ypCk5m9S6GPEsPUVFIeYrI+SZhsrgWkC6RXYInw=", "F5I5y22WEx7xLwmlj5U1tmsjxDZ7z6tofpp8PIgKBA8=", "B/nv+M1ikHtdYHFAvQsJRNF18Xq+Ky7tgUtkY60puM4=", "L0TNZnQJnq6M7lxvhOmyXP18gB4LRXJ46D/ktRFFjI4=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JB1Ky1PlHO6Hi30jIj/TMxH/Cq6B9PqgeBZUbrcy2Nk=", "EwFraU9jJFqKmy8JqEvvfAcRu4g4s61J4LeDj29kRWA=", "JAo/9HwuczJTRkelov4niv8GnMR5+gANfDGnjOKSm9E=", "GlELaD7SlbGb6BrOPfv3zxBhsHoYV5Ml980AHTgUbDA=", "IMTs66QZsFdaleKV2E5xvRqSjVzMpdeagJBZ3jNCyc8=", "C6+YmaUXI6Vs2kPBrs1sCWpJm1euGJPhaiiQi8Xc/2o=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "FiMVw7MaTVt2ZRD0aXT/iQcUJDZP1pyb+6G24L7Ojqw=", "L2pPlImtThQ5yAbXV3mf1u5Yyl0FYNFaj2WMbrhvR9Y=", "D2eZmgHPZg4ZGAET93AEHMFHozXhn1RePzGmG7a076k=", "CRRtfwNdN5eJRWVC09cntZOm/GclKmMexAcFNjVHj6A=", "LkSm6y7+3gpXaNhJHkyGv81jsO4vODt01irzEc+R3lo=", "FgYxvZxUdJGBgWyayl/gBCYO56Vv01+1aXfvBJEdXnE=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JvfxUeN83kBdqU1bfol+l2iGKvKFkCtZC2NuErtDx68=", "Du/9GDJfh1TRXbit+Y0pCsgWyrDkMVMGskGAaOeN0C8=", "KEJ3tdKw/WbfNR/3A0GdprGupe5AW7oJvUo2nm6upJo=", "E1hMUWjPL8d/iE0RHgX6hRLnz/7GDdOhBVAxltaCyhI=", "Hr1VGQu7quDp3Rr5kerzrhOvDnH6aGMSIkyIbJfp4vk=", "E6RJrOGWAorqA1rwzZ1bdj0p+NKSRDp2LYvgax4Tbfs=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "IfpCTPkL8LcVZWrrPQKswybLVogLzZFgLvrPZhZL0Hs=", "JGlLW6kgBgO8qPUtc9Dz/qJsDuGTnSzsipvF+WHNaMc=", "Gm2Y90T8pZyRDfsZrYnXwl8scZMy7buvtsyFwZDk4XA=", "CrkEsSJEJGwt2Vxpooq5HSw05kH2l7U2G9kdFiXJN9w=", "D9h8iSNmjM6SGvaYzaZxA8BIhkEplUgARgN03tW4Z3A=", "IJjOBRLKE76hFB5I8UvGkbQQz4Hef1l9BiRl4UMcTCo=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "BNlOvacxPOJc0N/NHd55kkOdquYwwFTXz9bWkKhcJ+k=", "CvL6J03VseFlaPxGE+dsmrT6mdCdEBBemL2bkrgupFU=", "GRU7dEHEjNJwtJF2LpbkcIWHFOllCqxlFpV30vx1WvQ=", "Klxp0DAkjXj3BnSvZdkqkIp8J8NPMvn9JBdFDgWFJUs=", "BDbYbxOTgv+2EIVWDiWSKQUY7O1SMIlLSovN6+BqiPs=", "I7QOfxvQt/rozy6gYIrOkpm5A6yNmZT3RIvC5GCQr5k=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "IUJ4Mjcf0c4O/r6QSj/66UEULU81znfgZOJWq1k3ZTo=", "G1J6FfNtTwMBWm/0g8+1wY+LMxp8r3kjeZj7kU3UYUk=", "E9hH4ltx01eJxs3oGtmtnBr6as557PNjkg3CM+VkYzg=", "I4sTNlprj81lgP+fS/JnsBNmpB18MmyCa+ff7HUb1IA=", "L9wasiXfGHqP3s4uFBFMtx8B7Yhwhe7SJzHe0ZiClms=", "L8n6AIMOJnGzbo7uxcNpprP8J72WkFtfwiD88EWNHD4=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "EBtw3QS+ZCqgc3dhDj7n1jC9sS47JilYBrkun0ghUcs=", "EieHIjHxkvHIFEDHn96+WXzorQOJTLB6ybNCPk25DRA=", "HQHXNLcJBgMXSVH+bTOPs8zMAMCszyrI1FhZ9FFmMFw=", "Dlk+nAF3l29MqpkeVPx+6uiX+3I6n60IqBGylvPnsQ4=", "L+m3Y39U1wYP92ggX54WGkyzvZ3PFKi7yzd0O2/GDBY=", "JqwXm2fbLDk3OaRQVzAiFCkF5fqn6O/dHHF+tgOm2cI=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "LibxmXL/i+3vt4A+MoRpD0/HgoywvPO11Wl7gnFKFxo=", "B/R5CjAlT2VPsKRlxCIXQhmYhDaT4sIyDljN8xp3zuo=", "Fq29WVuZWbi5A9t98VGH5mt/b9Qz/S7Tyg2rjUX40DE=", "E0E5lVj2l+njtJ5QrTiJp6asG3oWn/4VdaMXKk8zx1o=", "AsjnFOyZ44cU4dAbmE+GPA2OBbjDt/9vvKIMqs+/O/Q=", "CutBIsqWKFxetbUv4sJjVdtBdAbFZ6psNd7H/Fi6YXY=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JPXmHKwAG3jEZkzcdc2Ndb3mAuRcbaxpjzso3tWnVgQ=", "FY2ri4X0QS/a797k1PH+yyL0M2cpZNLudzCwNmM2Hx0=", "IQp/2JTkg74DLI5odpV5aPIVKp8e3tEcPNJlOasSohM=", "J92D4XiBf+IuAiwi5iCvuI4C+xU0YyK49wuyZIW4E+0=", "KLYMO83UaTsB8RHauWnuXfpKiEDe/b8rvzhgTOTiPnA=", "BcVvaD6i0dUHZ28DxBGinJklIVyl2Ofyij2nPNe1E94=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "HvkT0zsY9codAAwiCWRngMRYCGkWPyh8T75TficMMIs=", "L3d2dDe5Jictze7NRUFqqliFUaeb/rFfw8dtk40Sr8s=", "LaYsUPktjcwPb92QkFFwiwyPIflmrVe6MDNw8AIJ7SE=", "EYwZJLaH1SaEJK8jhi+V62KeHGmafCfeJ8WBxJXvFZ8=", "HCDyC2AfidZqvI4YVNPylInemlWVhLnfhC+5iJgBM8Q=", "GQeLpQNw7vdqAPbIkhcYO7qdpY/hXYoHxWXKoBkUd3I=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "CQ1pfDK+ANi3H3NNH5AjzdEaWHtRWB52O6xbPHZsUEM=", "KDCakSr8hoSLZ/fYW+lgPzTdzqxDhecC82YrPCvc+eU=", "CxAPNqwlTqY6a5KZZEUxj3BTYD4YEmHQcFFADzAtw7w=", "GTFZf2361oGTGZohZnNsDH6HQYnKTU0lVe+dlksGyT4=", "CyaXaZX82zVOxcbFDhspE5/DwKZHCcv8L6mS7/qDOAA=", "LdkZwu3DAuVuDs57hTeQX+qoxt+mxhMPlNaPc4C8oBk=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "J4sCMc/4W97uSX9idP2l4HzvqsGrBc6J+GPbP85e6yk=", "Ce4dyuedyQ5M8ND7Xmve6W+mt1Gt3oItMOOoCxpbtQY=", "F2n1D7lhulDfi54DoS/De8llJl/Ok/l2KydDKP0Er70=", "IKmdpDI1orswsO9Y1wjQd0BRD1F7Lu22eKlKqk7b3u4=", "EbcYHsD5oUhdhM2Rw0L3Dhkkx6hfSKM+e/i126K4t6k=", "I0U+saXkTiizEQfyncanv0gYp84VbSx+gd/3XMAuk3o=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KryRJB4ydeICjWgTD1Uz1sjj0ewpQmMvpLkaSfx2KIA=", "IWU6iHv2J8ugtaNeuzMp9GAq/YRAraAFDDGySdli+G4=", "L/7lJUQMuS6vxRixYTXKAN8szYE78fm8RYJS1+5Hje8=", "AQS85zT7AyLempEFj/s0DjXCEqivXFts4YFzRNghN9U=", "Ets080FFGV5kRVopj+WXzot1dCZ4TMU5de1aQ5uRwSo=", "E6mmHKAAjBuRF0j1WTu+r2MzCEKOToU3ghS+BK74ixw=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "FK3nzviKdybVHrABNX2L/OjR2Ox5Ry9vJTHZR5LUcHo=", "JLrukhorgn/paDU0a4Wj6Uq3W065/KtCNcucVNCgd6Y=", "BN+0QbF5kiueLKlFjebTqgxlO+yi+nMXpdH8QTjoeCs=", "Lv24TDxvrOsPWP7978CeRH6iMCKR06sREB1IfzxnnuQ=", "JNhhZQOJ8DoNqdcg8l3256s3lqtZftY9OAVUMWVbu6U=", "H4smCfaZn2sVV3aX6Q6JH8e2kcMMJpUngELC0VKqwq4=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JC/tVRnwEHB1Li43eXV+XfIQM7qquGqfvbGlTRHNTbY=", "Bt/445L1EwL9iGTeUGi5Q6KwT7CyOcOLZ5+vaJ1p4ak=", "HOXbXNJ3lLvaD3IVvZQE9GUC0rYB90/PLLGlt/1ED7w=", "Fq6oOOyLxui49IMJzW54PLSjN7knKPZvcB8NXvsyqAo=", "H9Iaj/E/DvEr5aElv71elS7x5GtPN0fz+9gZggnU6pU=", "ASUViyHWd2GAdoVJVNl3w1pjE6HzdWTja/bQctJQDfY=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "K7jinLMj4+KHnZPTbpMSuzw4qSLMa8wWifcnk/XUoY4=", "DQ4uy9COJHrnr/G84rxUrRYD/Czw7zKCJwH+7r9Ogmo=", "Ln3w97hCSQs/OdDYe7s1qQzyPzz+7zyKT+RxakdplHA=", "HZ3WCaKUSqeC7LGgistcC7hXx0iZIGRPaDnJPBCzeDc=", "Ea0mlHHUs2+yOqJDkEoCkGCMMnWQIPCCzai01Th1IQk=", "LS9UbL5gqYIuIFw/P9GHv4n23vd0w/mI3obk65FZW+o=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KBE/06jTuV688p8t21TG2eoDSlHjvRGY5MH08dzwaNA=", "EU7UbUmzibFMICuhwGntTYNsEx3OwkcvS7ePgDuQAls=", "FKIXv4c3+zVw44t1y8l7MWuiHbij8xaspaJu01wNFCQ=", "FsnnpY3fFBl4IJVh2TAFgjO4rbueOuyXAv9nTCKwCdA=", "E4i3i57AJC5AKQbXW+QZz5Lj28KlFS35eXMY4ARjJ5M=", "KkWTGNP3FW2H48ZmqPdibP7Q0w/KKO95J1E7H3opSwc=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "Hz3zyhxLhUeSpp0Qe7fm574vR5vjl96DyUyzEOjoIcs=", "KGlEemacr8IPH5AXAo4wmLOKgv3zzuWdneLIiABLQek=", "JezL3K8KZ9XvFce6rvi9Kk6qGm1dcDhe13fBDbR5b/c=", "JMJpcOmZ8n5jUfG+CjIRwKF3zbd46tE7rqm3tL41NKU=", "BzGvySKtSKnwzp1jXia6ATp9SujVLU+3Xw8CQJ2DQzs=", "IXBEq6o8mrbFGSetEGHQwc7cY6kLAbe18cEJdOZvh50=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "Js+p/yEJQ/awfAhpHC7dsbsdIWekF5EuznJHBrXCCw4=", "ClUJtPpbyL5jCiynxAmAkEcTsZbjan6fg5xEdAN+BJw=", "HE3HiLYTH53RMsLt/8ekbsULAAOD+v9UGTkvDSkcNHU=", "FQvatZdnpi2ZTON+3yw81TEavQv+VB+zCWjhnuJgEFM=", "JTk2J6WTcw9M8loGiTLUR8FYHyUfmnt9hs+eOSrKDTE=", "EFmK96hM/bTEWMp2Jd2LGFCUkecQnbZb2KD4DYd4pq4=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "H9W6WSLXEJeV1dune/tXumrvG7au8LrsOND5FtNeydA=", "BDkCbiaMoPqFsfbe0nyFRVLu0mKd21nmpnnU766m8hg=", "HV1H62V85RC5+aF+mknW8AQPfzYDmdq38FP6uj8GKG4=", "XPB9zYMcHFEGLqJxtAKUGZb0bdnfD7sicwWlUPQmlw==", "JO8WFa/hiw/5mL+eH8af7fONtmsiV/S6x2rcBM6S4Ck=", "DOHaJsuXgoFiQlpyNsI+j0t3eL2p19UUsbj8kygIfCw=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "E1XkFbDbQAHKAVA7wgIypJ5n8OgW3JD/GKQoBDfp6bg=", "AR/JZpy+O/F22mXzEuQJ1jXb7j+/jz0dawVrSEc8tFE=", "HWwZECNniVV7TELfAZHSpGzd0oOOxqdLfDCPAj5x1MU=", "Fib00sx/LUbXyclwMMG0INbC1VAz977Op9N3VBsZ9X8=", "IQxLtD1xK0ANS65L+N3kNnhvyIv8uCVws+I13cKYIRU=", "IT/SOwTqnljqkVwf20YPOgrEsAQa/oD2yhup4aDhOCU=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "LqQw7+juHyxyrACSWKGtmLh3JcAPctJ6McRFBGu5qA4=", "LWlOI+Gz9rYytkZYTnb7ew01rtpZj6UGnXPHUTa9AnI=", "LtdU80oi/gT7s2NXduCJTSHNv0zG4DuL8zeHiDwaDbA=", "DyPmTitZ11C+O9A39N9i9/vxaJlADmlVS4k/Sv6qQa4=", "HNMBh41td4SA74Kyo8ubzDY2LRmORMIE5JDMUkorsrA=", "J215e2fIs9k1px0vg0K/fLvWjeU34yxGb5WgGlogfwQ=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "AW6Ktc7TToHf4Awkx/vQ9BiDUb4rGya21joeArhK6ms=", "HK87EKxYFGVuwtWFK1Q5+BDI3ApP1uvoLZ8zE09gx6c=", "Il+Xva62pWU3LFR+nWw1TB94+hmYzD2SwoIS7H7bY04=", "LYKKy6nljg863yOaNolElRWhuiRME7AYbIJ9YAt6c1g=", "H52kBmpi4M8pDLg5v2LJpJz3mw6hr/4DaWBiq4y505s=", "JAcG4rgbW2U0O0HlkzBmbStAUljEubF3SVd2wrG2gWw=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "LQ9DApdQ9YviLWbFspY6xrFbGMbp0Am3FwRIWf75YY0=", "FCNzkrYDUvbIqg9cCAJL64gquC29PnkM2jiYiGqj6bs=", "DI87A2V77ubh+UyYZitjOc+321y0MfuYE1h+4/GU0mA=", "GHALUV3hmzJWUTSCVmr8v0kOVWM9wLpXTC+0760e8Rg=", "HDsKZkXQAqnR4YchqW0eiwAhe9vqdP8TQNykfmoybiY=", "KXnE0h+A22EvqYqpC71l4s7MHqQxhJYSAFqQTAi/0BQ=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JFCd/jV0cDCb4GKwfAXdPfV9fMpiyqJgAZkYIM46+X8=", "K+3abq+JAbeKDlPiXazZLGBnMEbIbeszPOR5i8+TV+I=", "Hx2YTgaCWj2lOsQGbUkQBn9uD/E++DFSzOOXfMsnNAQ=", "AfWSlGrBA/JE0WiALDUqfi3FK9LlPT7y9KdXGvgQYJ4=", "GpdcZoh0QiCsHj1SlRJvjuDbfKYoOhdlhejdW84GD/k=", "Gngxn7YtmSl3N+nf3M1X/m/+AykZW4/3E6LW0zWWpvY=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "AvtML0FSAFK9RJi+h/RFs8Yuhsp9hy2uj6mcZ7WXfRE=", "AxYrNn6fNBgPIijVBeVNu38vI6Oo/uFPMISupJD78/o=", "DaXLlJlfZodj58bs+W3GvBOUOr8+ScVacC038295EU4=", "JXXN8aYb7+n7e4PogOjMI9gmAPNVmOovga0b7BvXAbk=", "H4PWwgZGp+CJqP0K0nQCGvL7JOMV9ADcs9JqmataNa4=", "LHdM9If3lmRYAhnJ1ph4Eknke0MnZ7DLr1FppQef20I=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "IDwbWSVv9cAE5wwsUSXtUcxT6ZOQqN6QGOZH4b6NmIg=", "J6v7LgiUxbQnmzm5MZ+lTMur0e/FCbMdkGobX3ZJY8E=", "L+ov0PNf/6T4SJS2Uls/7CmcghpHZqeMgpwufmnvvws=", "JFHVTcSMtgjy6WaYuW/VRYFv7wncrqdcmSgXk3Omb7o=", "F8XUy/cT0z63wfkV3SsOQ5vrxVEMtAlZSttD+Ut6Dpo=", "Ann79DguSyvEbBqPcZBj3bQia7CcEM1oAIs3x/MtRpw=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "DrfBGUYA5s7T2NyIyGiXBNQYjf6Jlw3XkLuctgBlIyE=", "Cg53bBLNEIzFibFOhJPcdD2FBGscTKl3FexQH8sWa6M=", "GoqEh8uKYLzld09k9i0LzueR3DLTpvhy99xibkpzKUg=", "FvED/bpwjbK86LWMRnoFu4h4k5yChSkh6U5elVqgnKA=", "J6VzJP+BkycoM1UNgvdJ0TibST+YyNNHPxqYkAN2Mls=", "JuQEA3hEH+imDRpTGaq3AHbILMIDUw2C51iEQHDASGA=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "BxhGqpnq5pT6F9c+rodTTwnEU5+lw7eeprxW2IjfqcE=", "DPdaAya4yj4q1XGDS8g1wINVVYepKP70F3MGViF/qi4=", "G4BwLolNdIIb/vii2uNvcdSAKUD2OhT+ZLMIE0DE8Rs=", "LMSfsc6RmLknqwmOyfRU0gU0KrSWdwN/n/fwjj8HznE=", "Gm50vvSwpbNWb6y/dwoUutmNi2/qs+RZlaMoE1iI6SQ=", "LvHg8Lv/kTErLJtHEMoE9Ol4BhulNlfpvBiTvbLnx8k=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "C7d6eVEZCWgQgdoRoTx6vzEHNzukE+y6TUfuWgwoj6w=", "I9iy5oadfQUQHTh8G4zea4W3/oYOfu0pRMUNCZBTv6U=", "MCOovwOoA+2jgwxQDRwOBh+oXEwVtyRZR1494pBhauk=", "KyfEGpQ74NOW7TYwCY/3AYdnFh/Bok0l9Hlp8aROIOs=", "KnO87tnuKnJhKQyFkOL/Z5WCo6bFmIJU3fbxCPEQPhM=", "JXnEe3bbWcYgbvAjtZiE+uCO9qaXrPflW28TL9dzO8I=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KlmTycKoC+D0sKb5xDLiwGBM9Z1b9b8kYJVy19CsuQA=", "EPrqEDqjbn1ce/dgs1Xg/TgaOT/so8BEUNf68PaiKAQ=", "LpjpK8mQTKksPm1o/deei+9hI61RdPAdXcBKJA2PR/E=", "ARmTe7XV2QKfKQI565T+hgafLba87c2ooQKOC3pDRCg=", "fGekjyCFD8jsjHNbc+B68qCPUue8kAhOlgnpfwcM8g==", "LaeFXeC9q26ZP9yezl+t8AxdOdWPZZmlZDiqJmPMNe4=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "GmmjhAdiN2w6Kuwb2KQ08qXkEKfpLSPbuyCgmRqtxGs=", "BX4nrZIYoxHDYnolNFyHlQj7hW1oucCsqQJ2sd+kvxU=", "FDB4UcawecTzsmaJ3F9iuKwraczzPzgC6a2iZxiIGDI=", "Jscc+1MmYvbmgd0xD+EScDt4+M4ePDkYPV1Iic4wQnE=", "KUywwTmhpaNFvAlNilPyHZDoLPR7uH49Xlu9dh5tgqo=", "CEEzuzXRzufxCi9hlTpMd+CcRmGlVlZGZU3bf+wL6QA=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "GAfR2RDPVCAIe8V1t5XPe3e1kLfRTT49IpizAsh1vBo=", "HfAB/TwSYjWL+hGYEWIp3BLhErzZG085YsgTbALFfpo=", "K0JLiN2wri/3TRSokJn4lC305zfGP2H2lezqSEL5/wc=", "GJsIa/u7naMIhfEf+cshPAo1NxAVPK3ZYgPH+XIDeRo=", "G9Ryq4HrfWySgJwHo4ex2tQ6MIP+ZYvIjRw6wWcuLsk=", "K8sy3jLQL0uPix0QBFn1N8sOTh8Uz+VyRCQQepkpv48=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "DPx7rtRJeiJS1Uzer4zm8jdzIJq7XzQcoqthbwUWGV4=", "HL+2Yp3tJkDIht1QSi7Fj5a0QYObeeVP6rBCYOuQsSg=", "s+GYEd8u31VUmsME+yBc2uMmq/8ef+vSDzUK+HUvKw==", "F+hcTG/oCFNBJLtmmV5cZj61oZWsGibYoJbbZ1yg388=", "AxzevvrN8rLccI/4fO4DFfNulzCDaeME6NJlTDQmIt0=", "F8M++sEv1Wnh/3wKAWXEy40jwnnUQue70HPK2+T2ZbI=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "CGag0hQO04VNWCL7pomFdkEmNFza+/VH69M8Oa7LiVw=", "ArvR6fMRRBPDR+5AN9CPkU1MtlVhfAz6q3e7Cc7TmVA=", "GtDV90gKeN1OBIxFlHnVYi7WX4eID2dcvSxNl+e8eEc=", "G4gGbpm5k/cDBs3ofqR8qz76bWmMnTsbo1WyyfNFO3Q=", "JfoM0N6hV/9O10Gw3HbgCVpR/DDHmVAOgNC4IarXufE=", "II4NA3jyx9h6bOiry9S92Xmk2dyAJoy5bYStRA/Q+Zo=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "C8snqeWQunYQL4v6bxxkcmVY9XoAJ+bdvEbVZOuLCdo=", "DOkZI8UZYISadbP4/Rv+HZdU3HzUgUT5ZKDJGk4I3WE=", "H6ySwpXHY/5rHjwPNgTwx9YY3vITPuL4adKh53S0JF0=", "CHloolzbuWzUceiPwszL8+W4vRA3tO5TMq2sBwqCoQk=", "DMjZ9T/5ju3W/dXF3vNkpF0SrOH/XjYm92B3O13g5iQ=", "K5UxD+YwcHDphdYTkKNRyl4cSp9eLFOWAhNvzQgPTmo=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KMCmzNlYfUHrcyBiOUk8kVDlIlju+lmDgs9gnUVZsug=", "FlxsMT+qB753J1sjW8zL8wrwdAypc9asziyvqUYkkdk=", "DN6wR9jlCwAlPpJt/1+VtCeb4Dd2aZCNZ1lhLLcyWeY=", "EBQNX4Xy8ylXLCybdTV3a3aV1i1jYu8nKFSFq7+dsBg=", "CVATQMGW2gTbB8ixw7wUYcIo6SbJ7ib14mNk3YlLFGg=", "D2B4Vbf0JTD8GfZDHVMDWnTrA/clHXFWeYJFhpjJOsA=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "JVvnnY3kFoxEz4omUiOR7Gtn4w8kdL8sx8eS3SWkcEY=", "Hst5I5HMdGcQtYaAAjQmetzU2YQcTo8edt/F3RXq7JA=", "KSRwMH86INAgWhkJHLBEqPnljQFW8DZLIfO2Altl0BY=", "DD17A4PRN3SJhD6ISga6ciRfBJjnEEOvKs2oNTpH7O4=", "DGEMsZcaqkrl+H+xTtU2GYZIzch2x8bi9THX1dGtYlw=", "HCN9yvEkvhV8WJeWD+fyKvRNRB0tRZACige7JJcR1+I=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "Kl5YPkAD5+dHodOa1gJ6nzR8felGo8/QB1CpoQLAXjs=", "FszsS0lg0jMalggE7NsEQuyxvN25urQrMGxHNlEGdek=", "LQ2zCSsDpUvbhhwpHBofUiES+eRX46UdcxhR3VmxNl8=", "FvFGmTXvB0qxrhkilN1irz4UriLx4pQDIiLFrhnirb0=", "BnxBBtARqvUvJTm6L40f5lzprggYWK1im56+gUjMCHg=", "EsbqrcxprDtzRLgpbqSiUfrMHJY1bIToExtmLz1fNKM=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KtmDEGnh8RNJXNqq8YczqkpOrh6FDVjAZmWhx4ftYEk=", "Gm0rX5KNnwqcQCK5Ug1wfl7KCsnO6Eknpxc3oDZij2w=", "HZLTaK4fQiVr/nEpCaA8aaRrzSB8F0YZhqbeAOCVKUU=", "EK0dNfb49JnmTa7wMqKCUbUMYiooQp0rIQerN3eE+q8=", "FQIlr8lfy0UPqbK3cjR57PfDFD7aDqolffTxp5jPY3U=", "E8VC9G8kXHkJVf0wyM/nElU0689t97HZvtvnIF7duYA=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "L+oxFiZr0wBbBWSbSMcAieVyoHftD4+XMLY8u5E0o2g=", "G8Tw30SFKzkrKjaEYDD0L81GLECwTQyQ5xEp5iGEKvY=", "CDskTuKrgZqV0MS8252RXau2gytN/5vefOBRWCfRnPs=", "H+kVkLaULpxJapxpbAZ7MIb9cHsBKQp3EdTzmJCMiRc=", "LpemOCyQB/srasdBhgcO2iabEFBujkp0uoInTRVCaMA=", "Gdcx6YHT3TdDYvS08Fxe6WALU5ZWdhXD7pTgqAyMxKw=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "Epnsg1A9zQxqrs6S5sLPeHG2HkMxjcgqGDpQOQRP0AA=", "JwWdsFj9JTtxs0HQdyRimXNEl9wx8hWZGMZKeBiLheE=", "D4wt7nzcjckOtX8CUHYVehgZc/Y0cxj+6wyZr+rghdA=", "EFPYYiGMeth82jEFrCO8sSyS6IMAbD1E+j+RZugnz9Y=", "FELuA0O5vCrpX4xPWcsyu0YaTHtAoS6JtotpkKS3GTM=", "LvFH+pCOYYb8LtVPrfIFVe8qHps7q8toY4ea34SjRys=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "KX1/n8MDoPWD+ZL3NH9otQtbvXkay5Pi2LyO/cTBq1M=", "K06LQM5sZKvByQapVuWq9eu9t8mBEOFxraxXO4GxYZU=", "Axb+BB1o44y6pdco0iXtgY8Asqqf+xrT2ewkvN/M3Lw=", "FoxXtyVzH+MVnXPg2UwOvzUXHjz4jhJnwrVWpUVq5sE=", "CQZm1lViKzdXta5Sg0MrSurs6DFIo261eCHSQbPvvT4=", "AskRZOh/yxvQcUOHAobsqKKd82eHaLrlCBdWn0i9e98=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "EQ+QHSRsLpUcV5u+kUZ6KVDmns8kHYtoxKTJjwUoSyY=", "BITn/u/umkWbKGEAnWAH6LFXIa+0o18+XJpvH3AzQJE=", "ETAN6ua3Pp5RKVlfCZbBDOACUGwsIHv2cmdqEwq6g2Q=", "DsS87Fn0P1tWU6PLBEDXERjOMbtgx1ucZ2a2peBSSWg=", "Dvplpms4sDRn/jjYZpIH2fu584+q9w0Tpnxr9x4eceY=", "J4Bog2hKAY0R7i7Ku5cd2faQzFoi/+Ns5h8XxupftKg=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "D0t/Ip4op6nnvwGbGM56NigP/yL3qZ5gvYTRuqiRzRI=", "ILU+9U69JdfCItQY4Be3zF4Aqa5SIRkaH/Vhse4xd7g=", "FO/FWgjaX1NjVSDiGJDi5erwzB+h/dys8TAtxl7gWcI=", "G3AYALIuV2UFn8RSW7Sqz6yN7fLtNyUxYLqoGGeO83Q=", "EYZI11n/2S+1vLhqz9/EvO3a3W+xZ5wxfLvPaGZRxn8=", "AmAVRKbmf3hBWgwqbo9GZfWRCQnFi7LrA/eFRRmvFfA=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "G/222i25RLS3n8Dvgl1soqzTUMu4f/Ehh9swoXmNDc8=", "CWnOYsGPlutsbj0MWnvHsrHeDLeuBHS0fRZEXy0GfLs=", "E9VKvjfczy7t4SDuqrxRBbmX82R4dBec/rwcmwIrghU=", "J7QtCjR68EgBfNbipXfpWcC2trjCrkBc2bBbeTomQ7M=", "Jzd1jsM1/LRJjVTSEMEbzh0s8bl7fruDXEvRexz41U8=", "H5aW3wu14pPcINBXnboYZq3vj25tOEb0I4CGH1tUykY=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "L6ndKJ6rSPBCSkjJorT1HS3jrmzy1eI6ELA2aThUHWU=", "D8dVFB1Val7r8e/MvLv3Lq1e7LWtk+mBS3FcTTiNdwk=", "JhJwcihpicV8ZlCQsg3IXF+pg66AxBL7LYrQIZSEOYE=", "IpZjrd2bmeIlUTp9DtG0PAsC3peldGY1XmcK3ZrWNrM=", "MBFhPb2JWlap3IHKT2GgP053wYg0xsIKUb4B1O+QYtI=", "BVmM13B7KEiOKg1mmsFOhGSATlFTfX07qkWnyA5InFs=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "FtwfWKLlT4941KK8Z8XdJCdE/y2w6pUzqfs94q+oMeU=", "KidMwe992eFgVBUj3WssFZ/LD0AZG2Oo0Kh3d3uN0GA=", "Ho8wePL9CwQJRgqzaaEA1ags2Ts92UdkSqa7j8L0+GM=", "Luga6Lm8DrfUQX4JqD3UZ8qNy26PDIdYuculVRI9rGc=", "A2fLS2A6In5rArpXFz/nOR6T22B4vi1W7y6RZLb9JyE=", "GEY3omfzKN8b0RkZH+DRFY6reZcT6lN/Ab6/pPu2QPM=", "I20TOT74XMSKNR3Xht16HeXjmUIpYSf9h5RyI65RCK0=", "J2SaOh21uoNRGy+fs3hdvfCD8fXUvtOLdv03lUXZygg=", "CPhPIZeBk3p71+1a7N/7ytkqHTEmL+UXYclKDxmXMoM=", "FPZdlfc1m4+fNSdSe6lyIZffPmmPdzzzAnwAvEFg+Yk=", "KnWhcVY7gH21Jb4llpmrKP6bx/sfcJQ/8Em8lw6EGgw=", "IHBnnnmHgu9ZKlLKnO+CDUl60u7Lqn5C82az5SHE7UI=", "L1ReV4ICyXMkiFQOQfeDto/wYT/Xk3X4uos9MJWOdnc="], ["JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "A1HVgkhsOXJmI3UEleKXlwsOGXh7SRc6k4ig1bCHiKs=", "AQ4aO+ril6Ryoxo7UVFMZkq7EuwtFYYKKdKpNS086Lo=", "Ejlfq/HBRmT68+zHKoRiPB1ct7XldE5gLIhqV3Pl8G0=", "CbkYcxUfALKZoXOltzb3P74s5UPwtNI3VlvVh1iTXP0=", "AdU89hj5PJCFIXLHcyZLj0npOL8ieRz/gp6V/2lCKZs=", "GnjkhFB5iRjyVDlvp0F78sX/aSWSAMKo1Tr18sTYuh4=", "DT1MHrmCjIev7KjqEo0dUzdQz1Vca3DXCoUgzPFv6w==", "A68GL80cpxum3gykQ28aWgaYo/Sau+Ts89qg6i5NyEw=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "GtG6TybUAZJLJWV0FCVrWXZyhKaSiXulzVOn9TIgBfw=", "ETNpR0fSy0iQ9PWYJWTqxgGcpakJGzAtLBC4cpcEHV8=", "G0bEL/GqR1ly4m9VmogWQCQjT3s5IDn7KiFxvmMb2N4=", "GVSqCnnxSWjIFwAJKeLnRCYocQEfI42YYIbn2VdJNrQ=", "B6ztiY25mul5b8cZGhA7neTHfw4I7OpqpZOXT2UqxLo=", "GKWgmNkU9iIXJtQq2naDoWBeICF6CUicmy2Ew83Sw54=", "E+AM9Ks7HgKBZa+NQQGcogohrrQJJlkqGA+YBgg+taA=", "BHj3KTi1KOx53v4JIVtGMggB+3Ut3IjWOKSHkFYbTis=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "CP9DsO2iE0B3uW1+TMN6aHElSRCrTFikvMeMG8bOOTc=", "J9f6OrnEOLatHsWmDorZGq0C5NKQj/cZLlrAzr2R+Sg=", "HprIrnzytA1imZklG+UNl3E5EyamZN/CBvKr7I775W8=", "LWtWtISd6CtjbYHy6YR2u2w1y8iWITe2Fb/4b48mGXE=", "IecFZtL0u4co/bN0namaIUOg2Qu2wbDW0CElqh/mMJI=", "HAHAUN2bC47I5e4ersrBFxv2mo89R3637DpgWwENTqU=", "KC6N3nOg3HTuEIFqrMHboQwUIQnBSteVTre1bKJooW4=", "B2fPlrFgNaltGfzFftzZLnRtImz+hLczRUx/+aFtJcw=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "GJdLnyU7a7aB+C7Q8tPmtPcMqFhGi38b097RpYHsIdk=", "GBU/6JZqv8RQolIipqJ/YXX+hRmJd23NIRGlot6Zwto=", "AtoeLndVOUkML+LIJ+ZcAOOCpKXWxJqDdDgdOcYn82w=", "JghYm5zT9MErToMuBfxevctAPNZWCo1+zo0XrJTnngY=", "BbSwdO2xNm01vxwewUUaNs/zUbQHqNMNVjRxveSR8UY=", "CFbMWgC8N90CF5INpmxXZd6gZEVV41gi1/1GTZ6zgJY=", "ICHd4+0ZO9reRXydtat5nms/ymQGadL2KVtIUvVNRG4=", "EuN4XwXza7eXssnwPFpV+rUuiLBVC3FV1gE7cGV01Bs=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "EYCEx20TQLOYCt1N84eN9P/G6f4m8LXE4vlXnub+LBo=", "C52sroYjxRTGIshXU+97mU2RAqtGYg+VbCbpxi/lMFA=", "Da6m0YqCa7K6lyrhbcYhy4/fns1THuPJ+dC0AS2mdp8=", "CPKl32Q34lO1eZIfwyCLPBduWhjd4mek+Ft6+395zu0=", "BqkdfHXjT9Q9mqU7fSeT5NXXCl/sxf1WU7FiuiYxqmg=", "IHV54zw2ry0g11mZbDE/eNwzmHjAoonV21i2s9YGnFY=", "JVYlQM0SCEszksjLjNqV/8nC3W+KdQVM4WrPh7qHG58=", "u/R/7KYLk90FAe4PwpTCqCsQOBe0rPCvaXkYOvzchw==", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "HggUziI0U7JIBKGrTOOYFeNa7S/p91EOYoirudixVxE=", "GPmqJyHZWWM5muGNbZWm+Bt4tSjnUFVOsmE9bau9cqk=", "LqMpgirTAquIMcVZxkCA57pr9MmOoMr5zd2Sm7tYdaY=", "KZENhrwns4qTvKgGd6NkfAHLUmLtGc0MAIcpJaBGozg=", "AhwKBazkUBXqiV4B1jDOa3Qj88IR0m6LbvVNPfwGYKs=", "Al58RjBC9SDtL/jGi+ML3dvX6lzdepEiS8ajKj9cD8w=", "DfW352Yxl/kR4NzR/0I3/98IAjTpuSIBU4rn22tqfSE=", "CU0PzZWStHcdK5v7wr143v7ztsqSPGg4JlD51jzjfIU=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JwNhEIln7QORpJ1LfNavm91UTovwSGWMT6s2qhJAcmM=", "GLv4nnyukwRMhHvqZUEBkU290WVkg+VOB64zKFeCGWE=", "BKpHoO3mTs36g1B6K4lHtLWHdY11I5Bx9rTT1md3vB4=", "GC0w7JiPyoA/997xRwwGqmpZb1ZxAYSQn9oX01TTzgI=", "IjwnFx5FaEbf/FnLGlPHYa/d+FWC5McOuv3fEOsfhEg=", "B9RtyXVUol7beOpNhixIvFoI6eoes2nFyMLgkDEUyRU=", "G/RzoumC5RlSO0htJklB2OMsu602K9v3NtesBMTSqWQ=", "Eid7F1v1TD8rClfrGJ53cUzyFjCs4fz0TTk5eq5bbaU=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FcCiz/+sf+q4ahhQMfSJqfg+ieMzeoS1Hf5vu1f+sVs=", "K4MZnsWEGF3lIZD1pBXB+7nv1LuerkxOJ2Orz5k1nMw=", "KGAbmUCjEsZbAq3Mt2k372RdTkUclArUJBsrD0kl19o=", "Ghh7SHW+JKJCByngFpAblOwFZsimk2l4w/IejWEZlvc=", "EO0f1Eci0QvH5Egk5kl4025o1W3ipGWgIBuOMQZdXFc=", "LEtoZxealJ03epv9Pv5IRW9+cPAthZx4aEo1c0htwic=", "FcssF6q+z3qg9hZVqLs1p6/YfQ4grDj+IaB9p7OI37E=", "BN/wPHQhEaqz5h9BZqcz6HaZwf+oifzheTFuOffYRew=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "F7qsh06qqI3nDMktWnLgC+TsDl6Zuny6wrDZjOrTlKE=", "Hbozi0d5kZovsiupSaBQyFpzmD1epHUs1z9mT+BfYkc=", "HjPn/MQfMvkN5XcdaeWPRIYpDHuFa+zVzZZ9jnc59xk=", "EId6188GUqL/k5d9OGLj/7XYfQwEDwKk+YYSr6/JtgQ=", "EV02dYVv9Z68yREN77nWxw32r1M9Swh10OXuxDA1BZU=", "A9dLlhupATqHTnvNx4L0eNpgl1N1Sdt+avRwLKdJ2uU=", "JWNBHimGdQCo/Rjk66PJoreZLkTSY8KffgYAD3SIfN0=", "KFUBxODuGzw+axspFg1uwPGvTcLzakoeZUt7R4mXONc=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "IJGUSJyGiRsXnjMQOoHZacXHXpQdww5yKMBO2LpocE8=", "LHsoNct5wphSkmkAzBaLIxWq8DqJUy3Z/BYsL33a2EU=", "HfGBxCAwjFsL8A7iHBbySO3/aG6eg1hp0QItzUqKY1o=", "H/q9/+4kgdjMEjNQb3CNmsq8HXWLuZwykULIZu9MdHQ=", "CJVe1Vwr7AcCfkNVppSptq4dnVASZWOynYoHTqZVQPU=", "GrSySk23xXWEcYRus3UWPnWHeRQXy8NVts6Ttk/QHaI=", "JaNDnSg4rUWScLxjMWTzpoIV4RIX7vHWBez6ixgFxgk=", "BlJA1jF5roMBMpWoJR++F92YjKXIR2HMtqbssr+/AqY=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "DBqR3cGyQRO/h2ou+JXDMVzRsQnPpWm3nzFV7hKxxWQ=", "FG/o4oU5rjaukhBp9K+D9nXxtoOZ786xiYnKtf3Task=", "G6jDz6RkJUEuMHkAkJgNsTmBDv7Xvbp6OK33XhoNNkE=", "CDpYydiJt05mY2u4QY22JHJrDxN09Z6vtNJpuh7SNNg=", "K4EqdupSbOGN9gMhku8DNUGq+Z0cYYOaDt8DNhQqJfM=", "KV9tNfueV6UKXZE2AFOAMLqMCeAhwWqoY0SIzI7rpkU=", "HeaboH47n5DIfrZ7H2RmDHG+/lE4Bh2+u3UilgMlQuY=", "JHNPo2PlLGTuAWKoZXjKiZeW6JyqGjo1M7CWVmUgj1k=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "LV+2fv6T6DhvrAcf41Ir4drenb8dEDBBentR4xIhEfQ=", "GVIukij+rnRz4xf9eVigIaCwQqgbddptv3VouFevq3U=", "K8P28N8McwWv6D/Z7wtwjhKfvoifzkLLaVszspBHk0I=", "B4PlY17qDmI7uMQGkJ8Nt3rU+TAtSCi1EBXWUSgYaQ4=", "LWGyQ/AuIe2u1v0uSWnduVptDajbF9EVqaOw2IhbzKo=", "BV4aCfS9SAmobmf5knn8BsqJpEaN8eol12/grTbM6hI=", "F4ce7SKwzdLeYeVbpcn0432mPtA3ZCC7Hufwd6DXqF4=", "IP0K8TKbvdcNTYNdGMkV2YlWxfCkJSz7gcH+Av4TAJE=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "LluEDKj666bsNhPiLrewcdljPIPO9lntlrL2qPzGsmI=", "BfU4VwPt98SjiM5YWoH+fMkv9J6QC1YBhlo1LGHWsRE=", "Ieg6teldNpzNMMwcVc1YRMscx4/88Mi8kcnA2ZN6P6s=", "Cme37Zw3lGMGrFJVl/EnWzCl0ATKUCWMPZkihNkNck0=", "IU9S+fc6LC1UJclhBGEwPYOd/nGJFInDdsLqO12Giyc=", "JB4NJn99HYmWVpKc3r2FD3Cs4hbZrBAlOrcgv0DaDH4=", "IikVNHW3prKC4RCxDortH7wqBaNzUulU9A2FIF+9i+8=", "DzDQt82O8Q6JXN+rP6pPTBphpfTrpohjRUBhnIR4LS0=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JlWJo0DHHUnhZg091D0YaUCBdti5EQrow2kHjej/eu8=", "G8rfhEvRouf09GSZHdZRufFWMMlJd9NevD6FgBJSrC4=", "DBErHFbqKI6FGMwDn+BQZJz0C3q5jej9vFbrfva8/d4=", "DwILnvda+N3VBc05R+EaBCcL4V2qy/p2+gTZAFKDqnc=", "CkJmAc6UFeZmrLuvKnzI73730HU42EsaU9okwZxgFog=", "EKGvZVA2FDgf4gAxI67pAIq5fWlzncRi5yqL4EWUYY4=", "LXkvn+XwrWWN3a3+OJPRWAEthLODe3QV4YgTFZWwYNI=", "LapC0E4LYvyzhpAxvzgsO5+KmPf1v3Qh0LY8JZj19l4=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FEwDlRV6G/z7XMQYfycQlnhNvNv8tqKMMc6KBvkIwKw=", "GvjNug7MyDwWAZYiZnUnZF6Uyc5krdRBXff0BEYnegk=", "ITx6etYjfnIRUwwhCo1vRqJb7kM7reAQWR5q30L82QY=", "Ik8cokgDwBGa0ObEGmSWjgZKg/WCGXLypcnViV2k6kI=", "EJRNlf9aNpnv3eQerRM0STfjsbk7pzoVMSRspLmarSs=", "DLJQiwozlfq77uUobOXxg5wAbrvAnZT0dZJJI9gHnsI=", "KEoUsQB/9sXA+PfY0OSxn+LUpwlBA5EhNLD1Y6ZyrNE=", "K8C85D1Vv+Gifu1CaYDPkFWw29QujeUW53WAudmpBg8=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KOmxiEpGGbOLb4o4Q2jDWLfyEPNBLESBomrilvc8XHI=", "ISPKHxGaNefU4bMj/SlC0S7QIMz/OnrWtlr5BFfwBhQ=", "BKr/sLoAj7moL8BwC+qrLOOe+olazcKAJS8B4xA1uK0=", "Hx4W+OySYcgkQ7mzHNkIAV4sLSMUYpoiY5rx834Qc9g=", "E0ko/16+XgGSFO+Te396KCSChdWDYT6ivt/Ga14q6SQ=", "CH/JnhHmPe7J1VBHrJgDDFek8JIoz6d0mj4cerXyEuc=", "CUKbzFLWxDgU31sH+hFviHUplQCjbveRtZKmTifMpIY=", "Imex36XSbm8KgLyLTAAm8CBL1P0Gx3JVRNd2A1TkAfQ=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Fvs823bSHTRIyZiPQo0ZjI5aZAA1rCyv96p5ZLNP8d0=", "CA3Z0mOmaYR53wa8mPxkWUR4AothBH/5PEJbKbCS03w=", "Fl9PLTAqJO6l9Gq+7EqwPSHj0BOGUIXlFb68smhK80A=", "Coo/Or8o9FfGIEV4n9zTAvDfEEm27FIdsrfnLo2VFss=", "I0LxA1h6AFyXdXixKBA3j5AUuugxgJz3rVnvOu1Iquk=", "HRMI4xHnq4RuFYdpwSITAT7KN385YGGq2mIg8p6xt9g=", "JWOUmuq/qngr4H2tkD6/9ckTiTdht1o/hAKh4r6lqZg=", "DLNxiY2NLh9bvDLcIXgnBKc+QV4Mn2OHFXtIdGu/br4=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "EjHUDnxv5b1HAQ6+T2PRhjac226II67BlAk6C0y8aEU=", "AYlDaWpNpVF0cGglX1egQ3ug7DatflySy+2cSal3W5c=", "H6WPN4Fg3Ur0DjsBv+Mt/TTyzcpSeXPBlKU68wvEBnA=", "DJdlYe6t5TPFV5BBvPXoJy5K+V7+OvnlNyJQ/cWtiWY=", "DKz+6uGoNZrp/Pgx8xWkuMV21Xnq6GsbCYI2ViMdO/8=", "EJsGRymOrsNU5KFVMIGStfrPtYa8L+Y/BzzSIaIQb7Q=", "Bp1HRKyiidEjuqDmdUxSMiAtvN+t0O6NFN0Zp76jl4E=", "FWGV/iffI7gYT8WKMOGpuvy5zJ+pzgcRY6JtzPt8atA=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "IP7TWULL3IbfUaScomBVuyXiMqQkdu8GmXr4kRVg/BI=", "DPIDQ5V6VTRUI900UML9dAOfGoLGwCRG3WTEVp0xRx4=", "HhdxObBdvjilbED5GdwfBxJrrQMEn8QCXXe0vDTCXr8=", "FE0ZRKhJ/cKrqKsqQ2jVeRHpYU45VtkybKSTyDBQ6TI=", "Fi8I0wX+TxsKm7Gs8SI73jQFrsvyNWUIhBuF8RgMvB0=", "IdaIaFAqtZnHxfKlTWW+QO1crsFhOpiyqYxfgRdBXZc=", "CYStsMUmMZO+QCfGjG86bb9+Is8ZncQ1i1KWiwokh4k=", "KIPzqUCowQ9/NHqAEbDw1/bgpKgu/1aP/8dSQjXR5PM=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "DYmjQJk749O6B9L6hDLUEnMOjr8rv6y/k3jAxNPR5pI=", "EF5KEoNncL26skyF56Y1csd1Vv/6/I9VoOP25zg/ewI=", "BLCehRu227/9B4CvP5nLtwf16KBzgQsosbWXlMixF6g=", "LIAxkHwQ4d8r/dJYndUCoBKiKSIC5nlUCRylfSGQbUE=", "CIo2DPTF4m+t3LopHdJVOQar2C/ssP+v9PP1RPZy1wM=", "Dp6Ni6YnEuf5WEC1ZR8ykS6E8Ua71XxWbBeAhMuxVfg=", "A4+66n3XN8ZC7EFHWb3spCUNMdYBEUDn5F6GwSxvb+I=", "CW3qbg1kEd0MGOUWURsD2FBsSQHFLbwncsPUe9v0Yas=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "LWD7ZvsTOwUHtrQe1/vVJ4xLqfoGedKInalnLSHwcDc=", "JWf0RM/bv013mdW1DIxYLh0gOKEZabPrK2Cuuvse/Hs=", "JAHZQbT6/jMRvGzZ+wvvYq2bWecxwexOawyl4saFuyw=", "KHR3QVeSg4U+1OZSXacKQxJ2n3BA208JjrfZIU/I+uY=", "EQSJn94/Uwz5lQDyDE+51HnlEs1woV3vRCpOqSvLl0M=", "BN394bGqyzOXfUswINtRuDT2GXoYUF48z7N/qKOodkw=", "K/ppE9YsiuoEzMPlAikiDv47mvalaBlOzlbAZePKyKo=", "BcuRTse3JDbPJa3L0FUMLbPJwJqsVl1G+WrBVvpyqQ4=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FF3Mion/2P3fTlu+N3o7dkmrb6rd9etYDO0+BCG3B3w=", "IfG3wWmgdE5JcYNGy9OQ2+Mof13jiXrNqvLku8Hz6As=", "DurjS16OSNK6a9BiyAPO0d0RZczl+PBXT/fK9Obq9rQ=", "KCcXDDCn9XChLzeqBDTgGkrtm1038YFQKdXeiaj/deI=", "DjKBYaKcA3avUmyABFl/vgGDKNbQyJUD6u429ZpM7oo=", "DWYX/ymslBp3n5B+dJYDyzZ3j+9mRLhoT6QAVcjZeMY=", "FpUG4Idwkv3vMhCcBk0lHE1qUCV6ucAyvXmAH6IwlLo=", "CMUWdAR54ahSKU6Mu8v4O01wlbaXWKqp8aNoAE3BdCo=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KBvOxMvO+p4Yoayh3+rNf37FJ99d62wAL1Qe5MDyvNo=", "E+pYpqgr9D9tTCYZuH2gznYEELaLd/aUaF4/NP9HuGw=", "HtYEVpv1gcceQYDVmnjdSOIQMAasBFVm5EFiZWw2CAs=", "FdJdGfj7k8knLxDqUl54fHWPmMW8qITmMX7SGikqv28=", "FpZwEUOr9XlPNwoSL8YNr6TwwkHoYHmDIivHLR2NFDk=", "FHHJvqXYgGdv+1MlVIfBr1egR2t366ViBKSjeAsQm1A=", "HsGOlTkJ7m403L3eZP1q6LmYF//vSBFVGieSS3FMwA0=", "CJrZFcZescwWMyKd2X8Jii+G5+pE7m2U8/5fCGgsgH8=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "fjuyKl2PUXsStC1oq3B9gJzoNnHdmpMzE9JRiJqdVQ==", "FCtChct6xySZdd31nRd67tGpTgQSAC2DhhzgYePzhiE=", "JIOcb4+t4MLvHiSPZMTYHjJMqk70BSkWoxxdHaSE7EM=", "CsCHmshk3Hv0CVWj9KGc83hG/PqSia5ZyPjHwXTFpX4=", "BEgy6x60rEMZJAbetKN+ph4tEQRodi06MfAfPGwfggg=", "Kz+Uj7KJhgom6ZXRTG+KuiCJURx7pYoxDmy8tTPy3KI=", "EYv6fi0ThjAfGHwbHtovSMCgPeFeNwtb4PQxoLV0aB4=", "E5n7NSv854dNIuD8skVTuWq1m4U2TAw8mwE11JcMI0k=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "LyXQCJMA2h0obF78yc8i0JWvj2FbdsvuCbm6ZR1zcxE=", "CE6q96CwfPSZLH0FeQxCzHQqe+0CHEj2FLmI2Z8UHj0=", "DLtTUnrTTL08TVlQT6R8h+tb4HgVXlisPx5LP0XdHOw=", "FOjg2A0q9u/TzGB0HLwh9to6QuJCkyK8IJCXsdItJrQ=", "FJ3GBfOtOdS0cKEyGR0nOd8q0Z+3HgZ/bt4/naMXKSI=", "FTPN2k/jRvCj5TgXK41WNtO0tQIEfLJoAVsgiPErmJc=", "HaIatHUFse1DWBYPPNJKATMHGLuQG+7d6MyjeDmAXGI=", "Ew7uYinmNGCW4SG9pr04kquoXDY97aFq6MjvxrpyGxg=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "HQZpuzy4OthwKnaFVRCRjvMA3yQWzfBKgwYakVpvves=", "ET8PDbaZJnBVQX1JlGe3UC4jF5oMI3h7foEwlnyVCA0=", "KM1m9eIEZ5lAWpwUKCBw72b9QJUHlx/LrBYDJJm62mE=", "IwFz2BRjYtKMDMm8LHKmSvp3Qbd2U3JgF5MoIcHclQI=", "BLI96RHzodPzI2bDWn8pODfh5+goe4q95COys6uBwYc=", "DUvN1f9EFjf5d9um1SPvH2F4uiRc2nbkKakbDKmU2wQ=", "CTv7+qjzqHGGAwZjIc5IIZtVVY8z4PhkWpOkHm9NPi0=", "JOIeJfCz0OdUv9DpHmK1/NIy51arNMvta0q3Cd/KVRo=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FGmQ//DhC41wpEEfV/nnSgPSrAEnshZAC4LIxkQDgwM=", "Hdrvq6d7zZxboGcbCjSkyze3xom9yhh9kCEvGIukqHw=", "Cnw36Oqyfl7c/D1mgrAmfj2SUP5HCYCVb14+WZPdqq8=", "LYH2mEtn18x0s1qp1nOHjwXVFwhYEhkHmN0kpRC41rU=", "B8RkWOReFc4TOLvpjtPAcmZk2K4Mllvw/HmuMa0Eo0k=", "Ft2DVnxyidjqDmLfhiDfdPPJh9XxYrawokqwmDe10to=", "IYGbnXjvXgXFNag+fXCfgPOrXo1zMUYTkBXsTjSynxs=", "I0Cink5NTpIPOaajIUm1Qwf5GKLheebHKIzQKDTA5Ew=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "HO14QRiqyYgMn7vuKJckU7NqvD2WeyDpsKiGr4bWQwU=", "I3hIxrDIf3lLMMrVo86/4sbJFz96JY9OoTklIzij6lo=", "J8Y2qpVnVtnuBLNVq+L62NcDsXIfz3Oxend1GBPIq7Q=", "G0A1g4ZpjiHUO9OVDAD4HWrjQO/5rAghohP4+r0ULQk=", "BpVIe5WxX+2nGIq5vYBy8O382uot++BllvjAN79SFFs=", "HfM2gxtnRcjyKoDCUroSsk4rsef9NhXMlhRdiY2/MiA=", "Jkt6ZvzUGZXBnwIbcfyxq9WZhsVTd6gq2S55oRZeWPU=", "II3vshItUyJKrNqYaCUMo7OfeLE8nRUKFNdaiGoaQrw=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Fif+Ef6SylsIQc2ASiERUcpsDScGsqF+wXp/0iSkihM=", "DUg7gqHtDWeI7HPCV8rLqXOOrnIy42XfESsVqTRZYn4=", "JMSQYSoWNrQ/kCRZhRr7PPw31x216f/SRxFtXL00+fw=", "Ly0IyMq3SLBWMHBmFBg31c8ZUQRFmpEIR2hUg0bIWT8=", "BC06T4fXgjJrDAl6A94BrBaYlUyPMAr3CPp5qS6EeQ8=", "KwZPs/q+nesVk9JT7MehL8+uMZPo9+FuxWOHb5Lkxiw=", "IrgGDYvSlcOiAWVe84kaSB4hdIVU3LdhPObApTJijlo=", "FSYUj4XOYQZnqpavIAWfCwLIqdTUY7J/BxHbcqVFUDo=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "EtKkLSVYdb1nHTduSZzXk5PbSMQU+WfVM4j2C04YCYY=", "ItDyfGdntkrfLrCe1ZXi8sIRo1BKjeZqwBmRyBwOJmk=", "H7zfPKby4HObVxJIqamU6pEzddsGXtJVteyj/eWH3JE=", "BAK3ZA0Y/qwMcAy+oNj1J6fD+0ShEMTXz/Id6umnDkA=", "J/bHbxtRnnHDiI8eznzOTg+Z8jHdzMd5ijGw3uDGggY=", "L+kIzSCGmcnY47DAn1wP1YcW0OtQAXqn0S3wi1PZY/8=", "GSKlmsg8Highr8zxYQql+ws8+Os/4/SVe6xgTBd/z/w=", "Em/FYJ2zyyVKBZGQNLin+aD4XsWrveb4UGhgclDqCsA=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KNs14XuzHlvpVNafW/j2g4ZRu29cgPdQtrcBdkO2wow=", "Jt1oQogBUGVyjF4JRUU1oz4VN3Ydh0ECvU7NK69As4Q=", "GJXTOjEr7MFwkORd90mBtPxLIg06qjRsfoSFMRyrFZ0=", "KL/yXrDypcbQB6kqfE2IvZwSxWItDsxaUJxAQEi3tao=", "EwE28Hx+CazUlVbzpr8HOcnvwKG+c4RTr2ezHoRcl24=", "JZxFV2HmtkINrfPWtk62VJP5ifs+VpjnMHptYHVxTt4=", "HJrEZPsIgo0CAGx1Kesej0Xu9UQF7Sz6oTO9aX9hiSk=", "Bgq+ZSB+/Q/aeyRxnTUBj3YH3XMuccBQdxSPPQRt0YA=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KkHzR7X27r6JaWZwcZJpBaPm5SG4WokAbsL1AO9CsAA=", "F4QPo6GAF3cxvONA/+taO2pouU4/hwUB54ftxalNtjs=", "Fh7JTD9iT5KOrbDi8s9rFkMPumgKWlBZDYkAWmiNmxg=", "Iti+FxtFcftbdzw6VI+7KGsG4nAc6Zt2MIZuG8puLMU=", "BSRkycetFFJTgKrqmwbnbwPbjt0iD5CwOp/u8v7PuXg=", "C97oOyDZH/mgQE2LBZOHnJD3vlqVoiyOGxV9ksPPR0Y=", "LYQjW09OBCYtjyRhI7jmMa1RpOEFH0HxyJzEK2FxcwI=", "A9a2L4FrxLRk4pccxqfBpYXlGSZsRiexNnznljz5PYY=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Fsr/b8wWUWiz7ZWNOqyNCfmPZwvbuEfsDpCDoCLSdpI=", "LNS+qsWcUwa/du9+Bsga3/beS+5zDNRnbpZttF/AZ9Q=", "GxGr2O5zaDD/7aN4L8eoJiPsxa+pLA7J7uxYF3zoYIs=", "LIDTQw5kv4UMnhCiL2t4H9UTryDUcFQ1vIcOyMvpPO4=", "LS8g0uwOUu7J/C0OSf73okVKp3pQVev8TURJ6Pg70BU=", "HlHFWo16BL5O2uT33+YTfpY3DuKk7UWexSSxneZG4LA=", "E9QyevqAnibI+X4267W+HTmS7HLUWXYLvSVll5Bzj0M=", "F2Ii9H2MD/noqWeSA3Z5Pb253MOnm0T9JeH0OnVea4E=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "BRk8vLWXE8eAEu3pPbgo5pM2oZf90wxrfQOxz83Wrfw=", "K75mD9NPasPyVFy6n3F9Lq6fjGAkKFFlf4ZhUEpFfGk=", "H+WcPSck9BWEg0BubNYqr6EhxFHxPkirPIV7IpMzPDs=", "JJyJP53iCGAd5FyXaeutBx64ZFJAA63QveMf739Pkac=", "DCDEoSu9dy4Nu5KbabJHUdomsPqGOQBf94aiWsGl/pY=", "GgdQ+x0nvLMmzrOjBlpIfPfVE9iVTzHfsXT8Xtlc5Vs=", "FtQMC6enqiMu6pl9RexPBWf7aBRneyYqrfrvyR1AnK0=", "AlzPhg/HI3zIchqvHHFxkNtAzNZb9l0Qixb4Uc68pzY=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "GiWxprgZJulo//+mOXnJAMHoJFLJhq5ZnvmRuiFOb2c=", "KzRLu1BADqdhUb0LaMMTmVXxAccB0yvv3c/sHKct8l4=", "EETmmvWU7KX5yn7ijMONFh0BA3/iI0EuLxCDi7n/0eU=", "EUX294OvfR4O4ziPEHzMJ2CbuDFLziewPb+NAoQ6ssc=", "IO1wCaYJOxYAIDGLC7+8mp0U3mSjqiWTbd/w/+OjvEs=", "JMxe1P+dhPzpXBUI4ceFL+YKbe9ZL0I7t5wikye+dic=", "H8MbDmfN+e+pwMMSr+VLUVitoVEXGcdpU1h7dy8cgww=", "H6+ZcDLLutwMbTD8gE0Gj67MvffMkBVTlbc54BcIElk=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "EZfEAuXwpJyPm5pBr2+80BPPmt/oZGE8G97LYgHZZR4=", "AwJdaYRi9M8jx9TYo+7Eqo4aIYSkMCASLbZTr8bQ3rQ=", "Ds0dQC+vo2AgUqtYb4BOwV8ZEFQvNcYI63okfVqWDMk=", "MAIWGdDAtAK0KdTpYsw8Ki0AxiwTEUT3s9f4rK5pdbg=", "K80F6Im/D82dxPX68hxQbN4VwxaqykdyTnG60M80sn0=", "G4kLQJengZALQNnB/6BqXozQWuj+UuBA2w5whcpGtGA=", "CAgbU6l07iZDELJ5RoCTIYzV5e3sG32mshqzViIkLkg=", "5mMujsl2zvylsWTmwHq0CsYR/HI+jYoUiZpM9L47Kg==", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Bjo/jeqdAkpvaoUezbIb/7/iWawX9nk8kec4I6gvT3Y=", "I7LG7Jr10BiOdbqrmZD2Y/jpKbzayWzAnEwGJidGkqA=", "CaQcBnMP5T05XGAhE/Fgf74BQlGQ1Q1W6fIVZYrRKMw=", "FlcQSPqSAkqTRaD/7MFZ52YCRVpxvH6cnAHcUNiqHWw=", "Klp+dtx2rXiHiz07THSZXizne8Em5NF9tQcWGwSerfY=", "CiNzjhKcEbKF2BwcAeP4eYnIdgByfnWTr0Vgf5j7GOs=", "LOjW7q9NbHygkixHOOgd+6In6Y/D7STnaW6+nCcyof8=", "Ai47+xPRA2jO5RdfXioswgXSgCHK9fsomN4jiRIxeKU=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "BmxD5xkDxbdO6OkOwwodjL/32MhdPHuZWpdgNu74xLc=", "L+XfzckzXwwN09CPTng6X/bC5vt+KSiECCHm2o2RVwo=", "mszOAyV/lnokwRznGPIRZ9nXGhy2Ck9Q0CKEGEKDAA==", "Ik4qhTFrZ78txkVJxQVyGnhYQ4oA55P+drlhv7+2cpE=", "KfFEe0USj1wc2xKjNFCeCpkcDSyTYKXPwor0IML//+A=", "EwGuVmW9PofLZH9Wbrzy8utb7EslencGGhXcx7izSr8=", "D8ZZnqlX4C9pscpYXHE1QlpoJYZ9DN0rBgGfPJOYuk8=", "Ai6RowqUW5YL2H17DYKQ3NX1scqjOcQa7zI74bqcck4=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "HHw1nCbqtlWqRp4PmozD2MeoFJup6brsqSM7ft3dHSQ=", "Hd9lGl05a2gIKOrqHyUmJdsZiFBHZetK6uMnShnO8XU=", "CrSG4+c39AiY0/3WurCSE8AFbC4JCpCsx1RXRzkVk4U=", "DQuBe4mVkT493Qi1dpUb1HtF9TZzn8nMeC52n9F+ACg=", "E0cavTolFglHkoN2/Ned1apYZy+DgnReOgQMKstGSXQ=", "B7/2cuUP8fIClrGDjlJwIpp0dxENmn+1ZYA3HuS6OMQ=", "I/ke8bgYLoDIoPVMOjWtUcuaO7YbB7PjQ4bxb39LMr0=", "FsOQs/3wnGxC5QtmVXUyzFmYy1qMFURtMYE+e3BgfsU=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "GXbSGu5095xg1E5GAppbBPwD6/ub2wmgtdu4n2d80pY=", "BW583Ai/+Ni8EtxyrzyEhY3eaJGc2ZG99RNlbrCgz7I=", "IreZLXwO00mqt1Md4vEtpP3PlhIVugbyt1d/XUK/qF4=", "EPl/zHV6DW0NTi1YXqWWiz+rqdZFjRa9Nm0IGrZa6Vo=", "IbwEbD1ye69uZbVoZTo5iu7YyVtzVn/so4hKBRrAAaI=", "DnV/0LdyGadxcj4HHJiWBi7tuz2gXNol056tPN9zhJE=", "HtU2xJf/NvYS8ybz0D6X0wq/kWBbpoavNuoEwZzOT0o=", "JJE0Ds/tP5jtb9VmA0JA5koI5aOaRox4sx5HNKZ5vWc=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FEtzxvNhpMIyZ0oIYWs2wz971mfcruw1Uwouj8tmED8=", "skQUNUCiSIQLpfoWHL+y+y2rlzMgcwQsv4qTIUTSew==", "C1vt2BIlYMr1qdvWn4L3Q5VDu605fXz7Tvd4L2TqThI=", "E4bH6IxcC/iAso6yc14iHCqI5/hxyl1yDJm0KHxSimc=", "J3FkzcUYdhOwptZFC1bKv8go8g3X0HYR7cy/w9OBybo=", "AWvJfuGsSxzqj5bnMd+mECEq7EoZMBW5Sw8qFlfUHxM=", "CzQeQ2HzFzSvmVHCCmqs4Io9yA9XN5rdlpO1awR7NIA=", "JjoGC6Sf5IYt+ZeZQmHmZcBAZkLGacMt7krnoVP+Hb8=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "DfgRtwyrMsCtCqy1dv2VsjQk02hteeNv7v8h0aoEfrg=", "r66XnkHAz31mK0zwnpPcpwwJRcZ1nE+NLJNaYITs7Q==", "Ia4S8duxUsMyE+/pzbYERXSz34I2vpI0ETFDUVIRXl8=", "Jy/YlVp1JKCfd8KM6J1YyvfYg/nkUDrWo3wOq2vL5Gg=", "A3Esq/qw9vPSOse+uBUiaIP0CdYNeYJCxtXp2ugXj6Y=", "FbxB10axSIW6k9x9AFlOovF0s7PbwazXdDNUBcGLFU8=", "Cd3tbXXDN1S+HB69Lb7Qd8Hxy4CTjweYuy4lsFSlKWI=", "HZ/X8nPhQeSNeuglptd1jjUdgMTtUBOaZZ1S7f9g0ic=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "yiy/7WJmcdbg8uPRtrLrtekEjC8ScyI8NP5ZlCnh8g==", "Hpuy76wAQBSFgWZxDaXXZKs2uA5Ol1ANeE/lzCMm/KE=", "I/ivgbd9LwbVZusNkJbEsmf0mPkrrGnWItvthbyKito=", "EVRoEWQpZccbOGXYMICbf0AuAtGYDDIZxLvkjovTeBE=", "K4csQ0MgrFIaweFIZ8BdiGkt5u4GP0AsKMugKt6vnFE=", "H4Do0JoE/7IGE82D6jX8FZP5pdjbbIRtgNylPNS6WpQ=", "EXxOFwcVZbUaK5eQjzdcoBlN1ZXp6HPowKFYtZaErHA=", "FNqUub462zxffNBN1cWPY+dCRdWh5vzl3j0JPUdvCKQ=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KsliZHcd1bF2IHjVEy2yP+uw0u2xnHskhI1LZU6c5nA=", "BaI+i+X+jgGxHQx6HchckJYCYEsV1iDHpR4rAX3WODA=", "FyYjZ209OLLGi6KzDBLFgY2HTYOphHjL7AsdJ/Xdfs4=", "C2Mu4ehzDVCWkVgIBbiQNxyi1RvOCD+u0WFahFSB3ns=", "KiIO9Wbk1UNz4aCVIxwQkFovXnLt0rYlm0bqRXSSA84=", "Lr9DQO4FRg2CmNUiYLTrrjiTV72FfLY4xBsnCMwzPcg=", "J+hzsXUJFjZtLnkG/+T0Lm3XVFv1NK3HOgK3QQ9/gnU=", "HucMtRrW2kUTzkL/IA5G36OZkqkER/EAR2VxHz9a1S4=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "ECEoLvyEZp5KmJVuMK0AQ8bBnf65jW0UvwJ7z6VV+K8=", "HxwuQkverdJ3Fi1w+us5jWYSJUFKl1pZvmE+RydLc8M=", "GnHkFavFzNW/JoEwBw6JseYZgc1U9uWGS4zE4dULshs=", "KXmYIOKLucCnvQosbWEF5ckfj4iygj2nxXglBnIU27Y=", "AXN3ywGVuVtHNgbIGmvVyAeyKHCvpssjChBI6VFeMds=", "L3PPnyLgQx1ee72Qfr64VTtBF/8fxQ0J/Ht1k170ElE=", "Gc1X53qZMoJgvTH7mT57s/0n/cIbIYf+OkusCtZkcZw=", "DV/xtrXzPW1WjZGX0N9A0Hq+3iCuOpSgKSwBwwQBJxM=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JsdhXgS+I1WvB3P8DgJfhrqrX1nYNLoAXgmdlTMdYbA=", "Fw6mcyxtGyzjJ58tSZCSb7jSeeSGTZZs5u5sMZc5wvU=", "L4cCaaUG81H7C5qdZ3utG7xearQP8K/Bdy8Cujlf3Iw=", "EZhnkKHMI5ySvUuNihubqnbh5J+Efxbt5fY5iqg+l8I=", "JRDC5aOc1sJD/1kGIZQbIh0qLFp57W5buQ6xAIIZI58=", "G6XAWoKGCbk6fhUTOGma8LiwqpbT1cyefTeFMz+gPc0=", "CGSMA70DtfTcOGisHEc2PZABC5yxmTNVT8dYa5e1+9o=", "adDHLFiAYY9mrVjWXwnl/EiGl8cdkhNb4pH1XUlstw==", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "CRrLNKoNA6/Q6kfB1WllqQUbBe6/+a9x4HxFVBhPRio=", "Kz916MpxGHdtlnb+BYVl65m26ZvSNQWo/vySfhfPUzY=", "FtmugsAHP+Hc81OEwNzodJSyQA+QJ84eZO5ECkOfy6o=", "KhG+zZMz60jzAnrY88JPoaDqZxoQICeK2EyGPDIugFc=", "DVab4pXV5EzP/Z07qEqvagwXjoY5aJqmxXIU8ApqnZA=", "CmYCXkUED9ResTbszGPi1/0jeq6bYuIzCqqgu0Tb70g=", "LNpoI0x+Itj9cl2VLTxSm2mXto3AIGX2oEe2yr3SnkI=", "H5qz6AKa/HL1avAs7VprFF68gURO0S6Cx+pUfprSNlA=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "GKLjK7aSd+D16CwqYKAIs9tcrzxTpmkhXAs0k7c8cTg=", "IkxPLpi0+hDU3cg/Jq2kYeW09BL5Sh6xU75wdHB0b78=", "GyqHh+lU2YGt0bEjpvbBAKYJ6BNcB4Gsmh5+MmxLD04=", "LaKIw08y2G1d/AstyYkQkdOW023p9wWJt77udpoFhiI=", "LiTTUbDQ6U8+D4PrYPLUdri2TctHZ0KQ6Hsn7afyAYA=", "FK8Bb52i+YLoKuwf9u6AlEXbLG2FOC+VlQijGDDc6dc=", "CRrqyb3pzmSlTLrVIwMhgMITW1HsRUfrzaCIJLyc354=", "DKoH6sYtnwfBf2P3SbcEfqoa3al/VxbXbyOv/W2EXdM=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "BVTwbjGxZNnXraPgHEu/RS/cysEhynh7CK1Q3Sko7UI=", "C/j413ArHogwvxJtxCAVimJDWQZ6D2OFBoOQsB0XZgE=", "FgTRgbr0iNzk+Zv2PAZe2TTuKfBkmvTcyawqKIfoaQw=", "CslR4pRPdTLU3c5y0xyOkcB5XN+rgt8zjxct2b/9rkM=", "JNU9n2ZTSMEr3DQlwrg+JPvqO2awydEZFG7V1aHR6fM=", "HuAaiafrxrjpPyrC5guZCePj2FWFLg4ROnKhGPVuLaM=", "K3jDFxo8jsYjG7fCCOW3wskKhZVqfyofdjy2yIMFmTg=", "B8oeMG2QeHRhaW/H5KOThxIxJJQym+dsjitALMDWF+E=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "H+vCX4iquSF5rDzv7qZj9RVi9vxjG7I2wE9e+FtGR4Q=", "GxsGXrYNvTmjTalEFP36RBWTOmvbpcLeRwrYzO8bKP0=", "YPzr0kzAhQOsT4DA/7h9CJjzS9zkFCDoTZQbX301Kg==", "KnsW0oJEc1embYP8Wq+rfT7byz8BEF8ZOVTF7Ulq4WU=", "CsOfWedrnilu9TkhrgQ2qwEhdJP5SL9uyhKxHORmeLU=", "CQs4qq4d8Yc3hKiWbx9itou9k9NLD0xjfiCPmurt/CY=", "G6YBuvgTyy1A7VZ0dHuePVdgFDUB4PIeMafdRLcTXrg=", "F2lexiBPEAWa5cpywTMryILLe04WGszRup73YLc2XV0=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "q1kwoGu2uaeOZk3FMI2gtk0eCebGn6WDvHNyRcWkaQ==", "FquaXeSL8In7pgDccNJ5DODo95wUMFZoAvl/7kO8Tis=", "B1331c23zMF1Ri361zknv1pfRl4VrSZ5MMXshG9Crl4=", "I+SnvnTQ8JMCeVha6qQytcKKSish45kKpFtQkvCNSO0=", "KYeVqK+XuLPTeCeeYLJ2uVIn5m104txmz/ocSVr5jCU=", "Ez0UVbbqJ49KzZHGWQa/dfLJDkHNvvwnIbHpatxe7ac=", "JLcirxlnzdrGoXRbcaynusctQ27UZOK4zlWqKtX/NQI=", "J2y25Zz0oG/2d1pTeksExrQngMnJilH/Y0gEsjrPrCs=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "EESw7Ws5CWwP9NKSwYYyyQnRUZFJE5sc0ZLeAUhdzj4=", "LckYq///zus0yxeoy1MviJ196pjprSaG744wk27NsDo=", "KlAwk37FaQ0JCtiz2JdUHs0YfS7hJvrFvmooD71KpGU=", "AWlhwQX4WSUBDg/dRF7oQNvTNwqrkzzPy25LJKiCYDc=", "FyYtoPjkG2xCcH37q+wdn3ns390loywqZA08Wko+h3A=", "BZk1kDoTXP/HxejLBt56CtvG/k9msHp0Fy62WVHGo0U=", "HqIii8Xwna36vwJePRnbPMpORI5g8pc2BdJVmiezv/g=", "HjXEc38Z3i3r03YN3IHh9YV6AcQshvTiZLoyP0Fl1e0=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "BZWIdc+xcJEFin4py/4g0NJC7N+9NjUnnNHgw6EUTdg=", "Gf0WWydBMp3BjSpbA9e1jrPc3ywrCHBzGpJDhxOQM90=", "Ec6jdThoASA8YVd1BM3GhJNxbQI9EWNW3vmtmCW+WIc=", "LpEUCCMa2Dq0DkTijuCwF6gvfggKDUvBtCxS6SBe0To=", "CdPwjB0s1N45O3A6fdlN8FQMkbWbKI32wa2LoOUfF5o=", "DYusksEoB6P7SyDsEeCDqIuVMHDAjBrpvijIDN2ymlA=", "IoKbd0SRwOOt2OfS3oCWy1WhAJrpzpg7gMFJcrxouE4=", "KuyRqHoXMfay9TSVWu89Ccp+LuLb216aDRXbIyVXxiE=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "KB7FA1UuZ3j7r9cnCVHP7xU/z+ygUXQQ5JXGK4FlX54=", "CYoxg/LuGJc5Q4VsKODc60OSrxR8qLUo6+6XV3F4vPE=", "B5SnjlG1GvB4CLZD7Te60x5tbGjl7zFx3NBt5ZjGwp4=", "IUoZNIzXzIsfmFKH5jfnmHo77fojP5ja6XdNqupC/Ok=", "EwrMWElUqQSFl72mOVvSW6AvzlYQKSjOp9Wm9SBoPKQ=", "AdCeEidDSkvPctjpH1QZ/9baISodHMsqUbA+gKolgkM=", "EnOX8rFWugDYOEfwPdJCAH+vMmJx0OLNT23ITJYbGaY=", "CXGj03PTXbjxgeDXsmwzz/F+Uz6PVg2ERpT4U+cZfkc=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "JByLzEY6yW48HMJAzoPETtz5x4HiWKLa0J0ZdtncbdY=", "GgtIm68KGCWZ9FiJeqNA5XmG3N57/TRziFEJKnWubg4=", "ECyIbOY4Enb+UtFcUdvVcelJBKjsTURF1FfVlkQuRD4=", "KJ+KRtZ5JpHKrADNQ93nSUDxIsDlrCAliDScLu5HP2s=", "LtFyESMkLDPyP4CfbkMVEVlMELBTOv3jMEumKvxV9ew=", "DHMKm+t7ZPCQo5kpr0kBkA53Kw+BcJitrOKHzCDdnoQ=", "BIDrL0hSH0b1BJ+NnWgtb0Bg/2xBkLKiLEDCfQdUuRI=", "Ih0wu8y7Obwj/+LIVxqM0XY81I3m3+IdfY8oBdseUGY=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Ai7/C61Uz0+P2p4Hv9rjZxNSd1bP8lWqSBtzC9KGzJA=", "IgxvTCPsknLq+1IgVUlKGvTeb+dFaznF24UeEpm3qG4=", "GNZrQ/0BqcyI3RSxtdbA0jsprCh3X/YNPM82A53gljo=", "H2KQFTfBxW9nH6u7T8Mfp0PzI2wm+fXJjsvzMu2oF98=", "EwvuzmKUUSAKPeIuq0xFu1kqrWZ/n8ZymEKXHUqAL8w=", "JEEayyycSBxZrcQbxU/bD6xljtbgs2Ns2t/RLDhvjJg=", "I3AFmSOTijVSgZFVqLOBb7kMveRYcfbBIsGQon5/3EM=", "IXzLgjWCv37b9KamRpLjeSjysC15tDd1q/MEUA3S2kY=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "Divl0/nuc1V6HEIf5Cyym9+PSlhnmmFJa/ilpPm7o74=", "J2OdfkYXMvO66xchA94rxKJnCGI5GXg/5Ud0FTvbWb8=", "FZwAW2YMf7NVHL9iSq3OwEfOcmJWc8hmxfson4yGX/8=", "Ew04c0tUnoM7UMVQqQWAxTJIu5ZzHAkhrWNzMW39qow=", "E+5K/RQzRgK2eRp7j0nE9JedSFuNGxEZy0oqfDGnTzk=", "LSZHt0xjV56BpicK/HPmNuWImWdFrASZ2+tqfPgKiJ4=", "G4hAhvo8QXO+D9XLHIZsh+D5rkw9nx499jDLTC+lmvU=", "Iokyi121srLQDnb/eIFWlud+sZrNy2yEJ55l/M4p0V0=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "C70pMwDHD2Esj1t7zGxBBiRtL3E98Cd0opdCwx7+tK4=", "J44ok/u11ZD+YjZS5QCG1YqxjTAVpZ1qYWArQJJS7Cs=", "L8xB9z3wyDWwtRTL3Uaa8eK0lPBSadFaY0OvNGaLGMk=", "A3gJf1dSVnS5YdQqL1epN8H+yrpMZzvc40UFDZgbj+A=", "FaZyfm8YGl2nlc4XPxiJ4H8SiS4T+InE+PbHFyWrn2I=", "Htw6WGc9NkulkGw7Of9/ZUxdQvT/lObnXSxQCEKEZHc=", "Aa7dvnQ8h+wQ/kR6XQirXHODbrIU75WgjOkRMbjhp/g=", "KG5URFbxFM5gnWuAWzEGSrZUglhWmckbmz6Dp1yjhrM=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "FHfoja+TSOpflcsIQm9ChcZUqJeixIlTMwUv4s26NMs=", "DJkYu9CJvCbJN64uCpKh2Mh89EgLBV5DgxpeajrL5bU=", "KDwk977feJ8xRlaCNH/4a0wPu3+arL5WMAIbQVMveTE=", "Cx5fDKaLr68CZDikaCpVwd9dOHxMXz4RHq0xY+tbJ1Q=", "LZ2h3yHxTOQB/4S5n7oHMRqdo81+/CAGlatVsSM7kEM=", "C7YeUN3Agh8MA7O+2UdvWAoCFXtqaaF/KvsO/18eKjc=", "IdwTWPYv89wkz8iW/fuuiLAHQyPfx7NtaA7bqJxHDks=", "DcdYaLb35uycJiIWN+t4m55MK4ks6BtSfH2gVifsLcg=", "JR5/35lZEIAICwrxM7nkNp8i5XrOPNf2T8b9vPONfaE=", "CGBuKKzYsu5MI6dXiG1+meQH0Xelj7MbQQ6tf74e8nI=", "L3DTeVE85FgjGo7mswKby7tIYO9IwQTdz/5lYD2BWS0=", "FTFbo4ueTHpkoIRJhee0XbOersTGO0kM7PsZ8C4QJmk=", "KhUp5LHKDO6XzeWK8VNsSCP35Vi9wT93Tk7z7IRUZ1s=", "KnC58dS7zNvAPhfB0dzbAgUpA9xmCeppafZhsut0yDk=", "L2mnGY4fvMfepDJlMGo37VW5G/9lKtaapPqEeJcNQB0=", "DD8FCmv1rxUZgeVePhopoTw/+kVQvSUU8a/Wxfch+DA=", "KiDjpKDlfZL5fJ1hhsbD6nxeVcIBRiWb4veMLMwuNZU="], ["EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "b6xhoTxxOaN2l6ZX+v2cEmEfGWtgqrI0Lrboad5waQ==", "J7S06iq3C7GnkbQ8BXEynubkTaSA2PC/7U60MSW9/cQ=", "D84lMcDdmxkGUT2iHMZEJhEiL4wFtbtc7QxdOSobQlQ=", "AieK+6iIsHxlm31TfvTy2knwPkLm/U9rqQlmsr2JKR8=", "BFaowBvNzJG9qAt8l/fpAZAJFjvCYTRGpApJ+6PHD/E=", "AuTEa48+vklBczTKdvPa14LLFdQL1PwUPfmTeq5f3Zw=", "LBPw98QhyWtHdD3wW6CoTTAoI6cvoBnCUcxlO/n86Ms=", "BXtrxAXFrX9tulVhme+tML8zOAz0v3TsIyFO3RI2dqM=", "LRJ8ejRs38yCIHbI32eetc9r0Lah//cPdT8TF6yq+K8=", "Gk3GlZ1l/aYEdTKld5ChQmSZZy1nsQ6jYGA7zavaBuE=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "GrU5JCuxbLLKSYS8ggAtB8b8Kb0NmnHjSGaexPkJ5Wc=", "FEvYtLolzrvMRMCEeET12UXjie+2HOvO2Kx3QBBOLak=", "CDJRBtr2knoYLE2D4LvgOf05DiUHo1l0epjTW0G/Vw==", "FGnFNlwTugyxCxTxCdaJProyOXOelw68ULY6mHDaDt4=", "ER6Cvx+z1EWIKcsdhStm98LOQHntIQyIN02suIxpwlI=", "K9Z3gFnCH41d8+glRkMZuo2fD9eyvcRSWseIBhAx6rU=", "IS08xsIBLJIv2Tcva+WKoFGMOSqeJTOAcUAdqiZ+NsA=", "JnVH8LAMMuhZV6Ql3QWWGgJiasebLu5BevDEUGRv+Zw=", "FfEBLrGKMsaaw5JpbMl0Uw9xEQmhl1AbQ9m0nERdnb8=", "JOWRZzjv4gtVSW467LypI5BjRYwsVi88DCrUXsuaDCc=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "BTfp1h4yqRrJgeVEKDeUKDPv7UbCW0AJ1mIsHVzWcig=", "JAmGdnQCHBPCbbEtxGhyWMinuMOeqeXw5TjJpdedALE=", "Et0K0Lva1yGiu3lfS1TgiiHk5QQ+MLsf3x42m0Wru4o=", "GU0okgh/FIVYDb2dsEc0P3PXF0HLHWeSZNDxXyIBGhc=", "zh8wcFdypRty6v/jB/c8WdFs7FBeKKBjUv7ISXOYtg==", "C0xCv9iy7uQinca0tq6TS2iCpWDcCwVpUs6pXgToTOg=", "KDEnT/pJNhyprQ82h/H9hA20OxP8S9dH/LzOh37Xj+w=", "EcP6rqV81TL5UvVtrEKo0pxyyNGylFnsIY1SgMN04UE=", "DQFECv5jwotYICFaCggv4paudJo+5hFpZ9RsS51Zt34=", "J/13mUN1WBZbhmwbiXYqC5S/fbiGsVjOYt0roB3G/Ug=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "KqWi9D4PS7i1IEH2NeyBDn+9glSNxyJgW/LBXnsuBE4=", "EJ4X+tNjaP2TkXqcSRmCCshiDFuqZNgT9CDyXw6XoIc=", "HGF4oSwtT8gWB38OSCX8rtm23bygPWZb5iTL7z32wQw=", "DItUXzujAFdC14Z7QrKss4lYaGMNTRypvS59GLIvex0=", "HPJyz0Wjmo9HWZRHtl7Y7BabVk5las2HIFUPeLGuqek=", "DtgdTyuMx3R2etGEuJwC0c867xhm1LjfVxqP6sfh+yY=", "JcIpFtfD0DC2IH7vM5pDLS8qSFqYpj+sU75qk9kM3Mk=", "FAwvZYidQ3oHNqzSFkg58alRqh6e4YJYtwGxnQ+ICCA=", "Gbm/A8R853T/RUHWYjKjphoet2fDfsk3MMLSm0PsLQs=", "FGSi5ch3FLtK/BtcuQ8c1YesfzEz5/Sl5F0EJrr6OUY=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "L98Ilbbn3QgRNadEZmENAuwvXlPQZfjyj1Vib4mEWQo=", "ITamJUFV1TcMZUvgPV8uqDOrrIPz7iqoYIC0yBL22e4=", "LCUEXUrXyrwUV2Vu/jCRz/oUsqPDp0zeFhllgBXWmj4=", "A17fkO5e4pN6IljgKhHZlr59ImPDCoERqPRhsxth11Y=", "JKYYFZb+/Pa4nHmSGEZwASI+/Xs5iA4LJBusMA0go60=", "Kdza7XMUMNlpW0YxPYRxPm3se1ZfeblLLPo91+nk6lE=", "FyT0qbFpar5V2V6cDcBI0dRzOUzPmD8ZjZ6Q0sc9G4w=", "GvacdKrkGND6jZwDDrxowE5gjlqMwAo1sZEN28b88UM=", "J6B5MHawnCted1yLc49IihEXHABmJ3SDr6f9jB3FvbA=", "HU/2x18XeGFeMVJaV/zvffpbXYQ4K17+ePyQYl+OHhI=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "D99F8RQ8dlAXPdv0H9MrEBrBBY3LNg5PVfsELYazu+8=", "KGBd8yHx10qThgSTrlgfrJvV36uHVTc9i76jRmAaKhw=", "KJRWjbfeu0f9tC68unu0wr85HHPA6kNf9hGppyGiqwk=", "GTiH3pmRTJEVSc1MWkArezPmUO8ACdfJkHW+4InuUy8=", "DlaIykAO6naQaJWth0E245DHVFuhfQtkudpIrs/VPZE=", "LGDbOEOuIXGiD07t3/fmzTvSsGzY056X+TuJWkCWNxs=", "CPtPLZ2KEsZnYlt99nUdJdNAnfBENBHedPd56QEJ/zQ=", "BNfZHjZScF8BXhTu/DqkEscHqGFdfcM2+i2nLRoYAg==", "DGDKcL0GcZvLUcOoZktz+LkhI0ZWFo5o1P9ulVKAjVQ=", "HtBUq+nztOGcuKQ5OZxf9fbekMhGOgm4LaIlxWfQUJU=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Kz14hns5Cy/bZU1oUSwxbslZxbjJrsSdX+dBiCV8O2s=", "GfcjCOs0HzMoVwzcn3j6ODjmKCYNbna7OwnLTlE2VFo=", "VMn9/GuxK9IGGxU/Qz2CjdLd8C1W5NbrKA8ZWRWX2Q==", "IKhYzowA/kUjWay85N+REP9siaNi/0yMzH+dpHASShw=", "GlXz2ufU0UxuuFHkRGPuDabmaw9WEUuPRt2p5xepsfo=", "Bl1S8yka8joA4tBYu2uo4XiJ99A7/LxSNCcq6GYKvzE=", "J4cVFR0GAmzdaPS7D+5LBBzQqMYr1fr3Gzk+qdw7zys=", "CcbshjGsWkF/BB7+KVEDOmIrrwG58WMMe8CTzNbz/GA=", "CcB4sjEOGC9AME40LF+WX4YFECkxJUlVrqIxli92L3U=", "IvT69O0qxpRygrkmJT2TdRqxEYoF0UZr8RfchT3DxTI=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DyTaWXt0w2d1iabPFUJiGc0OLBpgyay0uXZLjltPtf4=", "DznpFwHZALx+pjt/DTt1PMMdLPZmbu94amQArQRRXJY=", "C0EYfGDMO/8QIPxOZHRSupQKWz2f/dG0erYTpRXfZuU=", "Bhn639fLqonn1VWMTSMnVmVTGSj2L7FMxKpCYF+XobU=", "KF7TKHNnM4vJOHyD+4mHyt8bTqfx3GsXLpJO4P0v+4c=", "CFPSnX4YAQ0EYH7YswiYM9VRZuv1iu9VizZC8pri6zE=", "Cx03N8uXxZAwIhp9XRErt1XQlth2YkIVjQutB77Vups=", "JytgMmNHaD++bf8rlyid/vob6COFJsgGfuChJpQspq4=", "LH70ILK8oYn215Ka9UQDNUkz1oRGCW88/M0S52gYsjs=", "EPpWBeC2gOBVF1ZkqXmuoaRcRQV/RS5bkM1hMBK3BQg=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Ktb+ZvzI63Pi3X3GohhsMRB/iJa1+Mf567rJus/8WQ==", "HbI7SXYKuHwiI3CV2wBa2beSumNkcDHy9ejQxmyiyDM=", "K1GrONgWCeiFuNjDznmc7awf697F4nogXKgrAQs72fg=", "K72N+YYRQwPVm/ikCJgnltbxgJJpuYORC7b8u/pyr1M=", "A1Fu4oiianVV17xmvb7EID50wQVRPNi+h6mcA1oXbCI=", "IRYbKGngvgfYXhEFGsDYiUBEzxtHFdXe3VfL1qpIskA=", "D0cjwWnnh0ALIVO6yKB02g2ZL0SoVYoJVtVj5zrAPcM=", "CJDsGQTJi6Wzzva+2BaFD99nNJUbFD+qDCxkOhwTaLQ=", "FFOILr0j4s4/VlXrTy2059bc2JKhTj2mVcqqX0WidE4=", "Dfae1Orppv/PVKd9jYuhRUGvnSdjJ2eLcefEnI3rQcY=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "CEz6tSWuEts8MCIPl4obSLtlLC5H0fX0vxyz1epK4KE=", "Ig7iqsTsUM86UddupVTGlgvv4am5Rr5LWM/4tNihZWE=", "CdYIkcwGwoXDyjz3p4434lFuTQ/1AxeSNOoSZFhI1F0=", "L1EzgYPfqZYE8b4ELMHeyOluCMf697s7frhg39zdKVs=", "KfuCt+HqSs+dLKizLyfmjRCychQ2EVZ3C/pHMvheGwE=", "JNRka7ZmiLMzZ67sTP3P4Wt9IfR/G7H4iiWJblJuy4s=", "As2uzRxWU3acCV+asuC0Exo9xPWBlU+pESDceGSl1bU=", "Lkjrb1qd2DC6sR6PSfdDGoUZODNfavVHvc3juaJZWRM=", "DT1ynD0Ex/mWen884RwFPVpVmPCEeWbcmEDu69lnaxE=", "LJx9j1wRocv4mrK3lHOaNx2Bj3fMcb/8bKVdRHJkjys=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DzMP63+iTL+7r8Lq5dEJorvp1TWOx6NANdcoxqUxsX4=", "G0r3K2W2aRMBMmPDfZf/rdu4qCSzTUWBkCmwhnzPtGA=", "Ks4f/UD1bxRc6p5nnbbFdzIxU0NCPOAmqOknXoiDB/w=", "HDKKUWjQTNvDFRngN/3MXEJvmmmQ/oDIddYliAx9Az8=", "GXCSLYHJzZfTAw1Tcz4z49BGaEIZ9JYOzdCRD1quVI0=", "B2/N7d/KOOa8TF6HLusWKMryPY17lm2Xlj84uLVahqs=", "A+Jz8fBVks4SDff/m6Mu/xwbwGWxScLCp5hsFWnkzDo=", "Kx+N/sBejUSV/QdZR0kyoAOxEomjRAeSpI4st3e632o=", "Em/YC9j5+D8AzFHN6X+eSjvVQMk5IejzYDwMsT+JzJ8=", "B89QB6Tsrp9M10aJEmF12KgffFGjF6LBZXz81TO0pXo=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "GHk7bvIPvgd88hLmA7Kkkbi5llUQv4HIW0zvh0+6YJM=", "Bbx2IXSBMcsZrl5+bPpGg0TBFt03+uAeF4A4H5sd3rw=", "GqhZRH86yv9cFfvCS/fBZPrsqEa1VbAmN/qEpSzJ77o=", "KMPQGRX4VpPgSCHk8sp5nGKx/cRzkSPY3N+9HHdjbB8=", "Asf4Un0q19AucEbb5pCZfwM+NR/RjTVwiemI4EEiPxU=", "EmtmkkTH6nPTQN7Vb17c42MqCmm5zd7eKXrPLwctucY=", "JPce6SDBzCeQES56jp09gkJVQgYE/jGzMemNK+9Tl4E=", "GC+9wk+Fma4pGz6Klr0VJROWqUFnyONO0fhgacBn8D8=", "Dqt/GxhyGzwVT7O3+wZ8T37BilD6OrOqWHOkCNbYy70=", "IBL9/U1TqtusPXq5FyqCZwXVXlhi0b5kPNREnhzGsG0=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "FASQupPUJIFjLpkkpyXGW/Wffkl16Y+99Iapdy9Lbos=", "Kt+04KVUSGCaBqGsMbxdBtdMRaTdI2gJI9mFuGfwVLk=", "IDWlJnSLaGrEYjFpfMUvtMbY5IxDFMsKHuCOrrQ5OMg=", "JC7GszzSxiXRyigzFZBToOm+6zfFnskOUtQMmD6GUJY=", "EPiAjX+IYgmY4/FEBGMnuVIqByIKYseYbevyggrMthE=", "BdTYpgI0AbeYobKW3ULJAQ2ggbnmBzqnPb7XqYvvRBk=", "IL5r5oxH3aQeCMX4WFILJcA2kjuXj6i+bocOhfzBasg=", "A5JA2i4UllMHvZvpr1wM3aA6QBn4bEW7vqkPQK/PxQA=", "BgRXJJxP/7BkgblUV+xI4reV3EFNa3E1CtCLVs26fDw=", "I56/lfPVkJ/xKCAGYFnxuZn57llNwDrx+tbgAV1pjnI=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "CQc4g4xwiKObRbe4Rm4APB0LhfwMlRU+hfn+6lUsvtM=", "DQqgfrU7x39qfHd/0z0R5O7FSvuX2nafk3MQ95ffJGk=", "Ai6H4zhi8Qavi/GmrDP2nZlM4G8CGtMiNvVSnrOZqO8=", "FqP/hg4hENmOzrD155RtIHJz/5pPHgiKAJ8arhnFsMA=", "E+Nc2uTG/zWmgRGOz0YSUDCBspIKWfVMv1YDxWkOrXY=", "Edzcu4D+Molj2IeqVEOojmAnZ6/P85OKh374tea2IIQ=", "FECsPPOhynhwmiqXoCVdCIgrQK4oeZRnDcfVjXuSnHE=", "CREquj0oUDT9eAjOXGnK8YiqIZLjFDynPOOtQExQOpo=", "LI6xtfIcLzIJQ7rbCXIa1o8cLzV2UxcTmBqQXa9BVFA=", "BpWswa/CBw6rry4ieetvEdbiTHh7N/OjEfK9rFzwsWA=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "H7VdDwf0ePjW9aWeCFatK7mk4Zh8uzbkN4lSMGhc7vU=", "JP+hm3FwYfKde+/mMyFfJ3EZ6omuwTJvn34vs3c/Olo=", "Fs9zo+s6hv50y6erK1kez1fWb/rjETEHKY4R8h1/aeU=", "EVxxJOSLR545+vJNhTVAcWzqG/L9wZ/ew1jR90DB+HQ=", "FYfBZcPVWS5yqERbq3kScc5kAyv3RtZhlLojpBMRbK0=", "IGd7uawCEKBhFVhvIf3NHmso6KGoZk5IaBuwd7deABw=", "D9yzQFbvHYkyh60HT/2OTXZ+0H+ayXtd4fNNjj3RplE=", "GewxMSOg2OY7hToJMcmpmxTMd18cMSu7E9XVP4gYt5w=", "GcDrF/cn0W3BNq+ehoiICLhwtenl2eOjw/DZQxvdVyg=", "KxWP0J2bsxfOQ3jPbg1XQ3RpDULMRlEArD+aa6ybaQc=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Z4leYk9ywu5z8GQ40eOLOA8CWeagQEfcLuR01UPfdA==", "JNgBIzpYsgFrjGr2u4jNsX4ZT72MYZp9hEzmgbkz1fE=", "GLvPb6de9+aAcPOIgVNh8Cis30HI4Nnyr8Yri7uauU8=", "DY8WzB2sMu4kTMGDexullMMqOOGllKbxNnr1RUY9t6Y=", "CFsEZS9EJ+kiCXYDLOSq5+HspnbwwWn5Vwv5EBTsPWA=", "KbbmN6vWSqJead4byLwgYQEKUjpjGdScjZCMRsLnYRI=", "Boa8RQMWoSLDEv3mv+pxRvkpCRliu+MiV2n3Z+6S4fk=", "HH2ygROP+GFkMBjKr69WnvpPfR3V/o24EVZ5ydTkZLo=", "BDS5rfaU7ndmLIiP5Qo/JPmmgN8vtvUBQiWJgAwSPKw=", "Jr84MYEbMiKtShTzuaU1e3VnAhObfY5+K7h91gNLNS0=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "JLQrrHq+6JR0/zKLy2HkrV8Sh3PgaN6hG4j8LqarZrA=", "GZ7QW77hExxNu6klg6Avv56jCqWcfy/FvVwIV87bRw8=", "K9ZnD5Z3gedK0AZI4BWWq7URe3StuVc0reHIH9AtEAo=", "FxJ+EUUZCNpT9nqHhZNztMbblBCGCRJw0193QuKGu2M=", "KSAQw2/1VLAvVqEoBx9UFxsjdZEIf4BRia9ithYgUmE=", "Avava/PCTM0ESA5kkAGLSJKEqVHwZ3UPTotGEpBALjw=", "Ef9ngLjaNnKouezq+dWtJAvw8dkQKPOrzlFH0GCESec=", "Da5s786mHqUswbzVvdDJpPHPEjEJzOc1RAXdOAVKiy4=", "IjT+Da090N7Xo5BQ9EeKxDvc3qyZy36nXWGmbCOCw18=", "Fieip1X3f4PQelzFjcKq/snOSKhUJ/B/gT4hfn0+knI=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "C8lYrF+uwGTePeBw2WBRNbs7wyH3S39Hlc/EzdT2TH8=", "AXYZcvnw19Z+YvR2yItSHr5gz+PhqvUFgKzSD0VZBQc=", "A65oVJZABysbdSUbX+SyKCGR8jX/mnU/z8zJlaPtNzQ=", "AdOpWyRJ4dIns8uXhUvfpSSLeL+KzBX+7YcDanSCmxI=", "G+aI+UQDAZ6yC0ms2fIB1bdlhTMB6fMJQ2R82smKmDw=", "DUCix2f52ILrR4eT4uFGr5mmIK9KdubzQp1iWRSTEb8=", "IHXViNmW1n4Iysr6J737tv8IoNl9K2Rw9HW4fANPrUA=", "HbWsq6z3nu9OYHkiL1SPxIhDivTgT1+OZPN6gO/zeus=", "FAQv0nBEJUlYZl4PoO9+wVXJB5FH6rb8VcnYw11DOgQ=", "IcpzyU4kXtAOwT3LuUO/SrCuHCmw88LdJ8ftQUo5wuo=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "IN21P0FgqoYgKO+f/AyiTtyOfOMEYCvn6Nt6fqeqIqw=", "GC/N+nWFi4ZjHqjQ4DCPPhIC93yrZ/RIwRjS5HCAwTc=", "KM16F7DzNJcAJjRQ9jHYAzf29uSQ6HNrTDIvd8brlLU=", "BKbP/vi/DbjHae85HCXIFirSWI22jyAq3CfyPgEZn5c=", "HyCMIIVa/lJSI5Wqc9lx2x3BEdxTGt7xXySpH9bPcIU=", "EH+gxcWu6yZQVmnroRlWjE4knXwW2m+sFo3nq+EbRE0=", "IQ3OWaRvxUjqYDF8cySbyFBi8MLO8pRN9EhPlnxiSLk=", "J4zY2DMj3khpXD2lfM4CbgAVJaPdZbxXyiYSs8bxzYI=", "C5y35NvgNqvHywcOYQuW1ht/4r8ppK7lnV8FG98blC8=", "KqE/onMbKVqZdKq+grnPND0nNzzs2zqD4D4Ko68Huqo=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EeS6Bm74psslGpcE3SOrtejvMf/CBI1wQAq0ApSG0cw=", "I1eLME/Xs9KNiG49cfApyEmIXIT5SI5Wh+W+f7wtLk0=", "FDBoxgcUux6yawmRaBqRF97PNwqeGiT/XSFj+2yLt3A=", "GkLTryG39y+u5DDwhb7MhZjAVxJ5Bzc84pfhwUk3Fak=", "Jg55yWfA1bxyD5XsensIgFHchUI/eYd28t4OjCZgYAI=", "IxSwFLtcV6Qhf0gRLpyRGGvNJ/6qmh84APxrL7atotU=", "EKtzVg8UXdYdZu3xXll8c4cagM8GRbcU5ucmi8G1m9I=", "LaeA9D6XKh6nhEtc/+diFfC4b3CMPQ68dYAkozKMZ88=", "JuX9LBNCOu5sGlQ7XU/uka9c6D1076hNzmq5Mj0WRM4=", "CRz4oNmu+Xw0EkGskvreBPHyHyDJr2fFWmpjYmtzvv0=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "GsLaMMnbajSZXWSXO6kTcoMUSxCLlhn2eM8/SpXAluM=", "ETdmYL/I/nEEyUlibTUPaw3Bs3lzgZ5HlwF0h2Gewl8=", "Iacr/CmvY30Kdmgel6MQ6a0dyLR6ZlmIB+iP00pGqoE=", "HWHtDQIhzsBavp0ujA9yy3TPTsLfPtWC1Kz8KvyXLxM=", "LPI3fyXxNM1SXdwKIQrh7cka3FHPvUUaeygNMyRj++A=", "Eo2HHMnWna2a3Fj/hD0BIQUnsuQ0+yGzdwqafmOc1V4=", "GA99srB571An+eUXBXthhhNrZjFVbtSXnRFXBK0wVyk=", "Jx9i5S5KIYqm1q89VHEXwEtMCCwklQcU3/idwMpwzr0=", "HDNBnstvcGZWfX/Frd/zAQhS6H5o+J1rbbzjiFBAFSY=", "GnWsDrP/T3tkcga5Jquba3DlSBXH0Wnenfs0tNm6+ew=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "FmJBffRkcVAFzhIoJkxYcItipU6z0DAMfi7RAXgo8bw=", "G8PYGJtMCZNAf1haToWf8tA4tgf2eGAuwu5a9CPa41Y=", "DR/ccXfic7tZYvit46pdhY7X/Zu9IrLZhWNIOC6EgeY=", "LoR9krSxzXGY3y0r2RuEXFK50fJdaFu1TPQ9fNwGqJ4=", "IRb/O74TC5sb1LdvHLS018e0cs77TZjcCHidyZOv8ok=", "EFelSt4kDqVFusBelwdGDX8OGTDLBORg4mGFKlrulqE=", "JMZpO0uvoZUA5zUUBp4njCq/qoNw1iMSrH3/LY+XMyc=", "LLJohQ8O2J/c4ULIUR0vWDoi5YDLs9B5DkG8fkdCAzE=", "CnMelvQHy9kuU11KGN2Zgc5cjkqxW/f17M0p2DGwcS4=", "Cfnj/QSY2GMI6kgNX/uoDjZ8GftKeLEXEturABHK5Ds=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "BGcLFG9jdWd1RhKuzuK5v8uELn1nhbeQSjseN7dA1MA=", "A8Xg+s/dX968AlWk94r1/BbIKJIDgTcYbbVodHXuJso=", "I6NNw58Le99jH5yI2v7bS63iABXIafxGOiW3xIMlS1c=", "IKkZ1fH7myKrzpJHl+wgTXz1NKnF6QjlcxWZLtwGBis=", "BB8diQIrzUDfzZeBkbIA+KK3rbIWjzICtPLczocm2SI=", "I8kU9Ah8Q+54m6a+nEuZ+wMre19lyp869G4U2tw4E00=", "LWGlWfgGpeOCBBrqsdVFbdISwwGP/craUjX9hC83rg4=", "LlRX2y+UmSEgxckFSmpFl0JwEJ5ca1pIMOF1yBJUmqM=", "CfQpLOaiJBXH+DwSC1YTubZvrhO8jRsa8phBi+QQecM=", "D4KilQ/n8haadutsXOJG3tZU2y8DuifogDASTZztp/A=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DIqbRMEbQp0cuezq9/VQHp8KQA+/Tw/z+7X5d2B1Qvc=", "EWJ13lMetPSGGBLV26XckawCfRhwcs2aq068XDFuqg8=", "EPrOOfILcXB/6DVpk3+iDM1Sh5J5a6/QHcnglLpzNuE=", "Bsww7VOA4+V8sw8870DzxJgZ7r13hKew3oFf4sAHlWo=", "EeYsfQJ3PipL9eLZay4qerFyUU2t7OYbQWMvYTM2IAw=", "BWiLJ9SiQ1+0XI1fN0Owsc04C6bdyVq7bxF6rb3INzY=", "IulTg9n0vJTp4r4J7SQ9YRQEH/xynn7cwjjdgsfVrRk=", "Hc92IAlMIj1z2uAWJCcqdwbETqUclZ3zAvtukecPJQE=", "DWhtZAe6byBPuSezYoq1vsxI3iHzl59oGM8St296icE=", "BAWeiDXslYdR+JeYYFmsBn/sxe7wkRtxQXDnPDiRafs=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "ziKm96qRaBUNBkhXzm+JHJdcMZG7/5GUdHAr9MjYEw==", "GU8gGKvzRn54JD42zpcUQLnoqryDaHoIUcBI1+6nJyk=", "KZdLydQB8SgEn0cy1mEOufJpdD+ijbIx22rOVSFtd2Q=", "I62FNHUJDGFAP875HqLYo2r+KXQVaayzny5TM5IXOdI=", "BO/naCbzjRGnp2F0j5Yi5CEN3DhFS7UynrnNX/W/RVY=", "CKLkWyiEs7y0Y/WMo6fk8ufxaq2hemCbw1jjOUhupvk=", "HCKrJZKALI9kp2y/CDB019ct6b0/jZk0Z7AN7CfG4os=", "GAwYtZ8NxDwE2iH6R7S9/4/NbYRdiG9xhVwhIwdRT3s=", "FGNGF4yuTwv1vJ3NuOG/4hoP8NgKvzNBjHJJnnCqoiU=", "MB3k/srXEyYKV9Ts7IOo5JZtG4l5eAXEuPK2vpVh0d8=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "CA/xvMx4aIJTEZhh+pC0T9rC9dJwihvhIlaW1H2w2no=", "LoMAJDZIuIi1mRRQm6IZZJ4/KMvhkMw9/rscCDp6f+k=", "DNoEXAf8BVYaaGz6noLJ+gd08X80RQ3P3dwdFfiLUqM=", "ITNd/Vh0wjD5A6piSfZM3/ryswoZtPi55C5tx0cvNSE=", "Lnv9jW2QPNDSci7jP4KqgIBWKVFt5tkJGv6aFhMYPAU=", "BEOwmUKc0zhkc45BQ5HDfQMt/HlTeOhDmv5i7rxJ0kE=", "IVqBz0LycQxI+WUT8tHuDTUK5X/wHJba8+r70Ldpro8=", "AVahYR/5kzzPBp+yFWFZhRyP0C9/wnvVutYa0Agmxys=", "CQ06wluAwPaemzBjgNPMBBil3mMP+sNj7Hk6D8VPz5c=", "D1NFNBgJgXTjpiFMn6i1l5IEjMDJY7Zo/rS3n9/f5Nc=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Fn3MMvxzEffF35odKVWpKPtqHOdxAZJB+kkcZVxpc4E=", "Khkbai+PltpLsvkc03ezL8joSqqFfpdv7LfcmL9RigM=", "DC/UiH2LcEZitiM5rvU4Diz8Huz96aTJwUq8UsKgqMQ=", "AeYwZJvDavIMc18+VaEOGPsRkutTfa0rI5MgeaXj4Dk=", "IQMCoC3XXy04RtoW6nwwmRHqsDT7YK3rW6acGzG4Rxo=", "HZ4Kxuj4ub/He3Q5s0W3cllvjNIzcIVZVuQjZtQqFy0=", "Kmz2HLNlhIBhe+fapAcu/kwgY7l3fB/HdIzwDrtnAGc=", "LG0iX6rZ9vCVkWOkJiHSbHyRlBGW3axnphizkL+Ete8=", "LSzqJlZvrowoU6WXYHW21z2mW2pxVqswVAqp2wXZqik=", "LhPDEMXoTlW/ZFPZzGR/h8kNwmJfNmpt1h9goLOMo9w=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "GPjiUIvgmDpq1N5pzXl9Xzl0xfLk7S2rTmfbexPpEZo=", "Eio0ytqvhx2/FKJia+d1iC7kZTvu7NktdCVBNQ+SnBA=", "HqqcVidu0gByZ1dzg4z39ylmpwU3vPyFh0ghtAu8t7Y=", "EOC4XO/FdI7snX66senOxX1YCz1m5bR3crH6omfrf9Q=", "CWHZbMTxIaGEp423jCF/qWwiUh74jp9FSuiKyTSDJjM=", "LUDrgVdJSpGpmmeVn776EJWPL5YRHUZGHTq6/fP4lzU=", "IYB+Loik+QapmMfZxqOVqrLBoJs4h48EfNWaLmH4+F0=", "Lhnqyl0WyLu274kmE6rCN+tHtlxk3rLRZ5BNcZ7ct3o=", "FnFCQse354nUHIKkyXItV+KU1qVm9qSM3+eRI/jB0yo=", "BVZtOHkvBnHOEMGtfpNTQHX0IvYZKOtsLkhX4u8fokI=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EykPJLEF9I2sJ3NHgvB2FR8xksD0MtoI9z7glXDBQ9Y=", "G0uVOtqJRUyCsZ6IffzMAXhPpoCCu6mlYb60lvJn6vg=", "JhPuu18C/eVWDi8artvnrDIZmYP/m6LO3aetmm04Vf0=", "GuxXvVdFomw8AhnvlvpsaSUL+bZYTjccqyqivbeuSZA=", "BnOJ40jDQJtM0pnYvOcjmEtfLpWwvlYPwQEy2O+NPoU=", "Cw4GoefcVD+Rh6up3a8uMtMsqLil2oVZfm7l/aDJ7vY=", "Ch+0y3/UkTguLPM0fOSsikI0KnKv0aHmTrD/lw9U1fk=", "GXcAO6YU6o6BmR9vDXnWL+7DsPFdINiZuHOC/D+xOqM=", "KG6RL6SwGUjdexzAJRCEqpYBf0+/zcbHQ/6s6x3qdTs=", "IzcCMe9V9Z2PN1Fa08rXMGJeeTJfuDnh2enC0WMObss=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Cxz2v8/rPPNE+NEDj9x7n6+UUCf/W/cQ0QKG35y9TKk=", "Ej2aQJ0UyZa5FMmlbFSwLCX0ozo+y2Bm/sSnfGUlrLM=", "CJ8hSYYwoxKT7ehyXaQXk5bjFwh1T48mk1qVk6scIH0=", "L1v8ZThTotdO4DVH3UkJKngXfGvBbu89RRNwkEBwUgI=", "ChiwiBHdvgBqyFFrGI127W6Ku2NWl7tXb0OLXrI0cp0=", "Hg+xhIHI2VNUEFYbTO1gJWVLdNfKrD5NSHFD10FV9+g=", "CTYQbjRMd6RCXQrpJFUzQCFNUmSr+Vn/XD3kzBY/rAI=", "AavrgxZDNl6R5yZhNWByNfzkhBSc3OFVH6RXd5H/Yvw=", "AiiSrzfoBkv02IMiJWu4cuDXM8Ay0fe+/yvbdJ/Ax9U=", "KbgwU054DXIF44yi+bpD6h8eqrfQi2BgqajlLhzs37Y=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Aq6Y7DKOkVBnmiRiIrUSLCwuNdIET+x5UIMrl3SQC8s=", "FVSU83IX0DPo1YbGhS7FAcbcztUJZASHfHiPdfCcleg=", "GRxs27rLvfZEs7w1f6u7t5BF4yAPLRD4JNxHYa2g20E=", "LQ9o3FpzHjCu6yOnbC2YUzj3z3qh23RSq3wF9rlqHBI=", "CHYa4xsAhRk56/gfMgFhD1NwJ2XkI2fRWlpk5Px4DnU=", "IiWWBsxGtodu2ETENv927l3HNHVKkb+5d9Kun2IPc4w=", "ApADHrPvv91Wchn29ptuoJjcHH/xPbV78ixpnZBhkj4=", "ARoWTuMh+uz80oPCS6qsUj5gmtTdb2OHIG6Ag9i6LQg=", "FKakJIdrhuBviokYJsM5O/mpNV8PcF1hw5v2UgSkiKA=", "Dh2Ncr1MGSry1zJ58rfMiTygvpsxP5Dutkpftp56l3E=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "JyCzGws2h6k+ggOBn5/o9BWRzGe7oL1MBQM5wyfQpsk=", "IuoIAQIJTcwB2pfsF70cX/DmHxr8NWe6Kkx5En4W6Eg=", "B6B0DvRRvFFQVW0Qg7UQjrp2YLpH9c75Lfdq0M1T/dA=", "DBkenR0qw2SN9an6ajR8ntPAGkF2CR6R+BkUF8iFtnQ=", "IaZgXs4mLr9WWBUxGa2oV5PGjc7rVgeCxTPnFDxTQ1w=", "B7WFwA0ZdNrdhrAazBdZORQ+ZvDf9VpyY7f3BQcpT0w=", "MFcML1gHtWzDnO5eEWTFhQbZAqNI3UAL4/O6Hqm5GMU=", "JySufLfq99ObarZx351womD9FpHP+BmHRg0sGfIA+5o=", "ESh33On28XnqsCeIxE/J2j1kuZlmpxztv8TVzhYG7oA=", "MAZIUhXACQDjxCx07JxYxvygBHgn8jhDHjh3cqMP680=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "LytCPGcynMNK3HXvlV5lpuz1/s2t28zHxp3joSrkVw==", "KAIN98NqvKuml2KpTu6IBjtfEy78m/magoPU+jSnodk=", "HB5H4JWRweyRt4QKMHgZ2JwZpWfW4+svj86Bi6+96aY=", "GoSuFpJLUh43j222GdCglAZiCfGEkrYExqhSPZV0pL0=", "Dx8fT+FvY2uPt9GqTOzRhGuzf3OICgnrloDvLcSdzko=", "IDOxm3GVHn0YCFHEwLVMuOPR30StVeCN48EFVf9DTAs=", "KYSX26S1LVDFKLCJz59RuYx5e1+fGJPfi9cdZCeVfKc=", "B5eVCbxCsL0YVcL+60iQxaLlz29suth1WLEbguQ+urU=", "DAJ9gGW0IqXQWvaVMRnNFFHs3zscK0kEi6yf+hmilXE=", "HNoDGPVtoI5CtglzLyOnYoMe4ivYc6hWWikjrevYjnY=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EJ9Gfa7a0rvGuYSQK+ApqgfnJBpj7yQpZtucW1hMOdg=", "DfHhpDGB0hAJyYc8sip2M3yoS4GWQyzujuyZdcPBucs=", "IOIgLAM776bTLxP2tEJuQBIcQK58+M5XyCceDX5fExU=", "CPvJIG6Co/E5yLhv1dojv4ai9xnGt7fbQsEMYqAoC/s=", "CvzTtB7vIQJTrj1oSh+Bb2dysvJTwuu6W0RLjtwFt3U=", "KtfguorPA/+y/YSzD4kDMRnT80I235LRqYXTpx+vVJI=", "I1uYQDBsm72n4RwS7YgF+y3jEnVVM04ha/+N79rz+lo=", "EIq8Q5JCrCuniaygyhf3Yaqqp/kL4TmGJ91RpbU4X1A=", "Bkz+4qBROGSEkZOCGPucKHA4z6Dyk5foPpFPNV4Pbvs=", "FptJeAE4YYpKx95uFk8fipXc6Nu2i+Nze9HR0XYBtYM=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "A3wQEBg/BdO66yQHxxBVObWTVehU7mummtDKk//jBKo=", "B2GfSnFt+ofEGAs3d5/BVsE4Clk89GhrkvUZ41QxoNs=", "AwOmFsoMAhtROznVUYd7dkskHlghQM1JxmZQ7XSHQvY=", "4KPGa4knkqulk20hLFEKkpVx4mD369fk2P2he71uTg==", "AtuHhl9WtZ5tsY6foj5Hl0ZjQeMRT3PQSneqlrBggok=", "FrfdFPN2g5g5sz10A1lZ42QCnLX/xKUZfPL2ZU4H+c4=", "EoLS3ApUGCBdOXyjt4iskLYXq0h3ej0HVPKI4QW/CqE=", "E3SU+91PaPCJgSMUwln51VtvLqml4B0x3zaVO8Z6bNE=", "J5OaiufNW4iR8e/6JgtAA8XR81iMpBtR+mahX771h6g=", "IJ00LtEcnGqV9766HWrmBtu5HVPHsSUylUBjKFaYCBk=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "I3TtRMK/EAYf+HIRJZiwSDlkM8DpnuYYqXjXtS7q0R0=", "BQN88D6OQGC2JnG2s3OMMya1dGLS33FNMS3Dz5AuNJk=", "G9xtcnadVtQ10mZPwAhn0IGMqQ8weR/ZsrHjl/AYh54=", "ASViahByXk/rwlJv6o8o7an8n6zcP4U7/zTfLYcLZ2A=", "BtS/8/kKFDb560z/Z2i8ldB0gQW2v60+/EaQBbdN3mo=", "Cn59C9PqurBq+CbnaShfRzugczZTmHLt/kKR59EPiGM=", "Bbfu4Sb4VMlBkl66bQLXlpR+q56841t4+UtoBouOJXc=", "DHh0l7iKjfV+cWIkq/uCOBSe6MsrQaMEUqxcjJ6hG8s=", "EuRuG4LcD8RREi8Nc8NhULvaxCZgkfbxboh8KearPmY=", "E/1XjAdNuB6jUssJKFtT1+jpl5v6t82+lU8uvbAUyfg=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "CdiezQ6edtU7qx0ATd25YjNljPrDhq02bGFOCycPl9Q=", "FmPOP9joohnpVZhSTQoU6V7C7dvqzrXJHjMl8DuBHNE=", "LXZDpV748ZGoOF8mt5MwaL2Gkdi/rMApjt1Utdo6gbI=", "EO8wTAXQZBAECSmIICvRAqG3ahVUaev0GAS4VWNwyig=", "IFi6pFTDX+nuiwqLbDV54A2N6kTbHwNvKG+MHFpInhA=", "D+KXrhmO1+b9aDa8vGBnDZ+kDYGW5IzV5pGwTMdmh0Q=", "HcRYnxzLvy5IOUqQzTyxIcO8VldjmOFLN/EX81iOYVY=", "JTGqiSWk4UaiF4RG1CE6/itL9ZU3CQh3CE4Iq7MrRvE=", "K41vsJ3ph8af0UI8pbpox+R/JDJpl+5uwGsnu4IC/Xk=", "LPpxA6TmApYpe1zrLVpZrNpbDxwzwZyUGgW5wxDyWsc=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "ECAr5DBrXsKe9XXFIUo1o+u4yOgIxXLIfr+jiLE+lHs=", "G1qha3aSbfYnrB7G9sEmAlIOZ8sjEGxFYGPo+qS5AqQ=", "GakjN0drWFbAiIUBSXcgNvMRpf+U8FRC8KFfI8XE34E=", "C+j8SY5kq+k6OJHdabBoogC0//aBzRrByLbA3saEibg=", "Gg/EKqJzRwyvMFglZBhikbjRItwDYwllYwPUipw9VUc=", "GNsO/Mf2DKP876mAkUG/RsNlneASdg2KEAL3ccd5cbg=", "EjezvY6SGJRLM/RepMnnhyvkDj1x3zVNC00iQkFSJ04=", "BlwJYlG9OuC6kjZ6nbR1O5C6wWnnu+LaGiOuNALkXSc=", "Hcg+8Gb7MG4iLbNrGzaAIO0x0rFYnLbsLoTkBiE8jgQ=", "LBqObl+8KNlax+eEIorBLS0ovjLE+7r78hxqsHdvRJo=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "AXygRhvOCKiohTqPSffp9Sq489iny4qSXU39g0qSAFw=", "HJDJd+Ha7HTB1+bT7RTH1BoX/sbRRA/LPP3klFukO38=", "Cfau4uQ1cP5oJUTcr27+UPJzeENJ7pB6faCM8KOJKgk=", "Gp6BCgc9eYKlCko66X4W7zyx4jH+Cq0ijd7/QV6HPTQ=", "JfrbkimHcUrBNUV6vSU0af84eEfmJaTzdqIfYMVKrPA=", "EbZdWk4Dk3M4SLWhj1uiLJ32Zn6bhwdd4tzKKmMi6YA=", "IunnAMyCCsncCA6UQHucGK3BNVNXAsNLZABYA4gdNVY=", "FgyIYF+tetZaW5JtwXf6l5nJUa4XsGftYrBmeaTPA/M=", "HcKFHfbQlH5bPJOFVE0xJ4NG1FgGMoFCttOyVwK9dRA=", "CKQqycZRx2HaxM0zNNj/hUHsu6ORy6BPIVBVifObTQA=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "KJ+g6M6N8MYL6TPAqzkC+YimpZrcOd1Nh0VsiJgu3HA=", "HnDCuR09RHd/3puGclCBhXiap699DtGz4IJzwC62MgE=", "JiAu/b3ZP7witZu1KwAd6iB2/0nBvZqgrA5zJAb4U2I=", "BmUTCxCgDMUIhRX44WkDujFW+kIoW/C50cuEUglCW+M=", "AgoESl4aQF4a1ddRSSUWaEFIs3VbH6xwX9a262Zv3io=", "JkDgIbkxPbdC5TQVizc3s1V3nrBf++Yle/OpbM0Ovv4=", "GTfwKp6n4XANp3cxKfMpEdmR8rhy3vDxChdgVOMy/1E=", "CxmODaAks9qz1uefHhoDBMYFWo6j9Pk7DOJMbt4gaHM=", "LAow1RRJ2NtfPf0SxNrnhXqR7ojilyCNwVHM2L5PCHA=", "GHxfilKRScYlAAdzCle6McfcBGHUD8wXMmcCAgoh0z4=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "IIXBvfkdZLiPonz8TAjgfvoxrt04TUZfVYw9YP+wVls=", "Ja8lQU/vQbx+XzMgy3ixrUUyMZRzyqfLrQzr0ad6kcY=", "Ghslpsr9O9KPl/MURWVmwF/xU77tgbHbEX8g/5fxMsw=", "LZqwWVogJfwMwIULAny/TXeN/bNrP0n66AKe+y6mPx8=", "LzDMmw5bhb8E2ckhwmGVx0MaUKb+3CglC62NXP2uHTk=", "Cjeyp0vRQHLv1iyyhe/ykBrnj9kNwX5v7EZ2ywTyRKw=", "HEJHiPygJd+sZskBGLEcgnLU1o4xWHmzutcrWVAWsaY=", "IPUkBGkzLaxAFn7jdDinW9gW3MH7TM4qx/u3etq6W+I=", "A4ci4GubfWuoIy7KVTsogiVFawipT4wHIhlmVEMLUiE=", "BW7sW3VtaUXX8eyOUUfKJ2Xqm/kVOZ1xEPFbypU8uMQ=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "J/CADdysn6Hxz6sp9Awk/H1MpbFZDyYQUg6ItRChzLQ=", "GmqPb35hL2N6sSM1XdodS+rZ3/ZkPDXVQHZSo5LnA4I=", "Gyp0TL8OcyaIWwhPkH53VvMhITbWB9B0SG/krHB6QT4=", "Srr3Icc1DxaWqIqJiIDFiWKBTDghsS/vCSdnf/6tOg==", "LxlLf7ZGF18+yBq/0QvDPF3ra09plV2ON/kNVhm7H5Y=", "FFfQ2XKf2ST5igq4LDednh+jScmexdQIZpYUhvnJRB8=", "JAIt67LisevERHVQY97QRyFq73pT7801fDO88Yq/fXg=", "LxqfqfotBsav37A4ZYBvrB8I1bZKSkEC3Wm4/6oW2fk=", "KjnIr/0sNpUfLWXOKFg83Sfo0Js8RoLZqRqObaIPAY0=", "Bs1KgWK0QHqQpjK8xuE9Jak1Ac0n3ziaf4JA2p0Pswg=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "AkC92HiW8Wn3hwLy/d8QRy0eVrDI3KZow76cW5/JIvg=", "A868jXF4hqWKLCorxXLj9YkiwZ5qgCbe4JqKqsWdkXA=", "DyrFwvisaB4jGmIwNHB/q8XoG3x2bBLbNZV15UApgt0=", "LcUMt1Uw9TxYTw2xiF1sH8AwCcyOj4q8ULXqCW2MwfM=", "CUyJUv3jbEEm9N+FGOw/gx/dgBKfj6j/G4fXc5794C0=", "GA4pQz2Nw8vCapsGMIdnjlt1ab11nCFzrQYiVX2ULA4=", "E3UTmV+aUqYMwI7FGqXv0fEIKFh86psqXQFniAIb0OY=", "ECyLkP9sMn0WlSrRi8ZdnW76fcQhRD/0FZ5ysCrizy8=", "KfHpTtKPcgI+ZYTbxKTAkMbF7jENi4Pw8ZHKmjgug+M=", "HFKSvzA0OJrdyVTTNJT0Ix7pra7lhobmMFSP8OymMZE=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "AUMNeVNXSImUWyhRJB4GbunWtc0RwQbh/SCT1pGhZOo=", "GzRI46OLBbhaaR4t8XK0bHUB88opK19ITatihvSiPts=", "DblsWFnSFjo51rO6MWlLYDcGYzrM9lKVJu1XD+AZ8AE=", "AhtZinsfGZAIGvEikq5thRB9MUwFU0zB7Tn3/KMoD9A=", "IRCZXs1PfK4X27kxF2YQQKUFm9IGUKmQ3WeB5udzeQ4=", "IYk7aitKZjFrN+t0nf+MpO4XyL/4Yy7jdl9/j+VysMQ=", "LMrzCPkS/9FLRvMNj44tRoC288ohdYekpsHBu4QPNoM=", "EL4ovlP6ignNqfZ2BpeAExSd1426/Dmz5OwP8ux1stA=", "F+gm1Le0ogQPy6gJJ4vt4M1KecCw2oE0IWMnChQikxo=", "CeznFzB/UtF/GLe9IEMkIJwBHa+e94mXPmn5+eCZQO8=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "IcUSuL5al15YzD3BlfKEqQqSGiZMZ/hyOlyfx5xO5ZA=", "GpwyXpajR0X2hu7IsmiHe6eqDUSxH1m06xGyS6MKsfY=", "JWxe10YTM3MygHmUVliiGSfldphcjCbEL7Diejeu7Vw=", "CW3QCSQcalomjVNfXqE8sfMTc1zZ/72X9YBHclEHP6c=", "G1aXo0kjRnU+O0G19pD07Wyue8JG6QUORhFU2mO3I0Y=", "IS5qz7MFBoKG7NbSu6LMukv5Ukh9fbhoQNG8NdGJCDQ=", "GIlXgZ7AVp0Z3FTGox+sd7daicgZDqV3IKf8P35qSRc=", "BVGzCqCFoBZAE3BCTY7HtylELZXCY6sHfvH3F9gF7W4=", "Iog7A7pGlMJgLF4MFIotixQtpzLy2uNAJzJSfxpX/NE=", "BTpMSyBVpYxcyw8jRk3jfMnDr4bNI0fYIWEsSwF+jiU=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EszqkYOZPl19/Bb97ybZ+EXu0Q3i+6/mMAjinTyotQc=", "WCwSOB/pLODLQTktmM8L/IEallGdcXr1/9RcbKFnmw==", "BHUn/qDRoZQkD52fTFGYvdYg7lBB0tyl20A3X6bsEbs=", "CYA71SbUnjHcD6QYjjBpt62B8tY5GTTeQd9K787UsIY=", "IdOwAiZtCJOl58GnvHrS8q7cY7yhKwEHZwsnEBDCwXc=", "AY97CeBb87aAQootK6pRKYAW7yO7cayVFSv3XIKrTNI=", "AYvqQlLL14FeS8O9NLA5viAnwia5MOq5ywcUwu6AE5o=", "EA93pAVOtiWyITCDjM3mbSHGa2pL+MixDtzR1IZltw==", "Cci5ZQHqdlKEZTsNRkRFsBIIY2bvM9V+Op44jnQCM/Y=", "BsmsJ8z0faKXkjCxtvZwSgijACl1Ksv0mULBli6i+do=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Bo3+VpxZ/hF/BMpNBN+aWc5ckyeriIlPYKhDPLO7x+c=", "Ap4hx9Gz/dBND4njvsbmbEE0cYP6pIeghbzxrSpEYxk=", "BhrAtbM7jWZyGfdmP9aMk3xUjTQrwn5fOYuPEsT9VPk=", "Lo6uoBUm6jYrcw+nZpfcq28CmP2R8O4UXO1QShZL+8Q=", "G7pmOexZhTDeJwbKQmT1tC5u1TdJk/VRfUB/Oih7KQI=", "HadKI+sf19sbMM1ZQqxUDDebx0o9HlHVsL3dIIftEAw=", "Kg4xAER8gYcXvK3N0LfRICJNIDyNnvSAZNe5f2qr5ZM=", "J3U5JaNKJrijAchTG6iIFal24YNoWOBU+Q1lYcQ3MzA=", "I3DYYnwn7NMbK2qTwzrUCaLnhch5i8RE82HWZ8WUF+k=", "JER+mEyugZAbjBZo6KEdlFV7Od3yrsdO9FdwHgDVHms=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "rAhH496OXwB610J/JVVRXkB5va8LDjS0vl5UH0gvMw==", "CyxHVLAZJSctG6Q1n6AsOZvauoBrMvUcIoXiwWvzMW4=", "DTP7TKGgE+tl/wnchQmJaXRwg9269OAJPYbynvOUj9c=", "DwaqQNASzSdjeMNW7dQUwCp3q+xru+hSDZC4q5a+cwQ=", "EWILo7WengJAGxAj0ONnXBom2JaQiTH4isj0h81AjSY=", "LReD4x88JCR2MYQD24Ufsaa4JmUa4QqiyMbO6Lcem7o=", "LJidkzKVqBnjiMu3NvHfwAioE7EVANel11w95FRDx98=", "GF1kXzGGJJrWsg0u/rauYep63SITnAbw+xQ9SzZCimo=", "KVOQ5DAf9Sy0zCZWhZAHGc94X+Qvs/x2Bu6oQC0sO+I=", "LP9ZF2b47QM90QBKIWyVRcsb5cI19ZrAGJhFo/D7Yj8=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "HS9WFwJIe0PZ9/ZYP7ijQsgvFQU7U8KVKn3S0ySR2IA=", "FDG2U37HbcLDDudHYwHoMnAM5/Y4VT6EzW/OfW8U1+g=", "CfaOlRLPQ2igtSaq4a8r+4GGVcUOiofcFX+D15tAmgA=", "AuBwFeOfX4rxfNLQ0Ep2kXwbbDDws7s8NaJNCZJJsX0=", "ItOTZXneGxU8aCWPNqFXR3x8dG+9xPnz2NCrB9ZRwo4=", "HBURN1Eo6jS4dv3xephMKPn19VG49QCKVZh11ifK7mI=", "FCiCF3sI21KNPjCsYtMyXOzrWFxMwJHlBwp5q8MQX+o=", "GhaNGYKEyxOGh5omQr/6unu3ZyyRvNbFYr4D46tjYXk=", "FyIdUMebBoEdHWbmN1fAY85i3s6LE1nDiTK1PgwZlAE=", "DR1Oci/HXD9JMXAc2awkChcqjjtji6+6HJn+mHSSgJo=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "An2wc0h6Ek4u73Cdz7tBpi8H7jKqlS9pr1CsSGtsqn0=", "JoyLvaruE3IN9hdQdRgoPhdYeIvZFvpUgCZIXHqpoLI=", "H94Yl5BywCJQlcc9znXJnnwOoxZM7axO6YX03QKbnpU=", "JTHwd8CnfGzgynAkxbFQpBSJ4GGAaIkEmXhVd3uqhPE=", "KUpb2M+TvGh8BWjE4p5RbZCs3fpcosffgesJKGWD/LY=", "KU4yIXDJ/yBpcEgH5kyu0KDp8xaDZBowEuhn9ekTVZw=", "Kzrd1ssPI9sA1s153IhWmS2jbmSOO/DuCycV14XVtLQ=", "AxNeeTFKdqE9+cv6Iqfuqqal0kQewy7brSOWwnDrYAM=", "FzpWLZ7d+vj/pofDYuK9w52jbbSoVXptyFEFWixIorw=", "BhLYZMH/c/ey14ByXP+tUpQmpuGqWTaHW9mqRy54Kbw=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "K6iTAev8EjtCIMbHRIgAXLdSxy90h7yO9jC+u9Qb9tk=", "EP0pCfn38ndHIM4ZOkwAm8krq38n+VmleEKzyy8Q5iI=", "JJwbM83jFE+5ub3zDkVUTLmLuTBO+s8q2/EnHVm8AOs=", "B1cn1rhNjkJ7t0LOp+iACcKG6DvWbh1pUd15Kdy+NiE=", "G93X5TeZJDjxAJGyWlIl+wYTLexN7Zy/7rRRoDSsxnA=", "B+9ejlX69dkSnwEkeeEuCINLXho47SiupYPnym67poA=", "FLcUF4/IAx2EfbLgVVPd7UcRFFVnRZg0fc4c6LjOTl8=", "EZ4csqfkzGiFaem4eVLUsim+ImWljtbmGaqpPzDDjww=", "IVdcmK+w/Y3HXOiKBCAcNq7GIPcz1s5xvd1sTa4YnAs=", "LmkYhZSsq96ojiV8GbCqv8co0ZGpMdel9Oftg3DCT8Q=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DTCw97RjSRuT75ogVi+vNbTu4bDcqvhJZLhQw/qfUg==", "EE9uwo6sT3cVdqfsQQmAsv3GPDnRuQw/DnIYRyCeICU=", "IBdTugoKiItm7FFlhPMztM0fV8Fkt12iJRmomBHc8Hc=", "Fvx28fX3ZE3mvHnMSE4BDdHaPQYx70JxTPXdIfWev/I=", "EIkvxe7F7QD8bV0JdSIdPYcGhTZ/IRyldnBs+wg7Sfc=", "HFnJtoRN4pWErJOnMCK2dhsZbgBB4/oy9Ug3OoQwetg=", "GIowZMcu5uO1Vc41MT9zyRoVS9tZ5X/byV0obfQp+2Q=", "JadHqROWmPawkHQaxVyYuj5VyEXcivJa2D1uSMlF4kk=", "Gc8O94x3AG+p9IScz8wsUt0yamRqV4nNJfee2E9czAk=", "EUUYcifeYy096x1iWk5f44hvUQOuRmFajwfmA19lOXs=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "EmBvUUHLwbmjSakSHlQpXRf/afL5Anus2w68im3S0Kc=", "LR7IByY9eDc8prOqj0xRrpRIeuBMufX6bLemFV1Ez+A=", "K4P/1y+DzNTBjdFr0dQGruMI/Udb9wbwDMKH2dzZcoM=", "I3jDWgQoJks6+voLeCMSRjtySk0oGgtWumA2q7nYTEY=", "Ddun/uooVWeez+E0MrQghYq12TvINcmgrVm4wBH8BYo=", "BgoAkbWlClFuMbtq4wI9kCoj5X79tMVxwUOtYyEwRnM=", "DQhCHYFfkoEJSXcjfGqn5iQ6tc12442d8Z3StKYiEdA=", "Flo+61R68Va0viiFDCRYbAczdnNkQpoKG33NLn+Zgi8=", "I2dkMkLzKkBXRIk0UpRgQTVGmjYuj2+HF8OB2+9dQOI=", "MDoJQfGKoxZmEZdhEeQ6lNkvUfb72qB1V7R7RoCiGvQ=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "Guz13vCbpb4szZaJlsVWQUXzj2CqtBkZeNuAif2zHN0=", "ME68b7UlKti0LKWDVnmejGlhrIRwj4tGUicQMlmRMkM=", "JqsSiQOqSLZdEoaahWl9pN19u6sJrtUIuDOjmIVeqik=", "JFVnpAh6VYK7Nt04A/cAhZasJRSh1zgNZu3inieCOUI=", "BGWF2n6NbGzw/5K14zlLwEmYCEQs3jKNE2RrRKacrao=", "Er6YvAolcW4lRXCv3gjbReluFZqG19HGheHrKkWks+4=", "GFM3nBZYBnXXc8gIQbi259sOiiuXY3IEYZRyFF48p2A=", "E4zHeBk2T9mDo06xCcUyld5lPx2QX9Lee2+AgU/ozAs=", "LbL+4tSWiRMyIYputwmEioGfYrhyVILFkbzuq8Hj/UM=", "IulcOuTbHP5eTPtpeBVpfNnDQhHGURG4/oUO0llYBX0=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "FPDwaZqpvYMmu+xd3QvMvjp8rqtoXZzniD5RcWS9WZQ=", "AYFXdGddV2gX24SEC7n6FrcTRy1y9Lwkws68Ca7wwgM=", "KoIRekMDBBjlK3COtparAcmrBDlutTo+pBlLmhmCQjg=", "HwLVFSBvPZo8IIay18axkATMhVOneQjVNK0K+DpjcJc=", "PdUkDOHFUw/aSZPa4TvAe+5MeZTB9l8mOiuKL3vJ2w==", "DEFMoe0vcYBgh2oh3iAdh7dvb6Ik+vJ3XsmcwTxTQRc=", "CrSAQ7GAFNeIRawHprlyfP4LKDtEQE4gxdpGKqok980=", "A/rFMDT8dIznz5Zqofa/FURctPbzpKkpyyft55KGZ88=", "H5Fzcmbpe2M/xj5bDhyoK0hmgM9nexMqt6a0rHX3BII=", "JVbhFw0k2NqYBGQ3aFCTizYeFpmfL2KOEoH11qsLE/g=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DSWMrRCXQlD22jqeBo9oMNfGXxJTriUDJL+3K1DulOg=", "FeK95u7pafu7It3lMKjmEX/WQJcnErZE6+W0vwhB/JA=", "Ix3SpY/CSiAkO5O27Vz4uIt6lKQTeWGFL7haIHtuhJo=", "BPz0i6hkk6btev270bdPqRtxWgyrLhyyfUFtHP0iAlg=", "AnMTwvjU5d1nZNZy4ab5UdUAg+TkBLnBzSIzTn7tEvQ=", "HozDb8p5oaMxnTTbIwVHjOWHF+NvlxCHNSixbU8MGiI=", "Jm4/NVDu7h0eKTH/O+M+0ULfQTEfZQ4HBNGjM7C//1I=", "CIrMV2t7sf0AuOF4P3pItytIpSnhMPtvL2VQ9BxnrmU=", "FFU3FyyzBt8CD5EdRu7sgq+BNLmC8A3K2DnDwQBzsfE=", "CJfq2ipR5MwuVb4rq5HGig0TeKqkplvZheIsxnX66NU=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "H+3oRisH0KMF0CA1aDzym+VypT7P68KMd9F/9TGg6HM=", "BkzdsmMFx591MCzu8WI5GBP/tXWyFSaiqZ1NBf3ZBLw=", "BBaI3f4l5vYn02X8GNdO/kFlnZIT8lgIyB2kFo9GXvs=", "AmMGXKvVA5XvQJQ6+T31NwrS9tF7tt5Zs+jnEV7Fa4I=", "G+z7lDuJhZkaZsB1gyLkw/ImMsGZwXN/g6fcJRFkpzA=", "DgFFGx75LJl+2sgmdmphUlvJo0Xc1mlV+f+ZEbZT5zc=", "C58BBi1CaQQWjPcJLVfiyG9mYBEUdfmXj2sGCK0vIng=", "L53I6zhTRlLT7qXhuN5/CIw+qPkBWuE0cATDEiJW79o=", "LZfpRA8fylfyJ78HaXKdPbp/5s/3+93OvkkuGx+hVXw=", "GwVT0u6Rw6Y3MNaG/xpToEeGgqc2Pd1Ofs5Cug/gyy4=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "DoMYT/bkNYL6u01iw0bJV6NlNYEjhhtAYWcHIHA1d6c=", "DOTLJfWU/ZlsKNRXikqOOwWBKZpvFliC+9HdsthbLdw=", "BYX1gnmX74aRB42KtjXPEzNYISNAWZxR4b+iDJMiYFY=", "Kbun5MKDFtcLr8XQW6Wpe9VFGhJ+112e8hNqAvsOdfg=", "BejOcU2F7KtwJ9xK0Sw6XnWiEedx2yOd97P2YWWNTQg=", "HSQ/K6t3EvXRL8x+Qjmzm8Uzum1+H+mHeaXO2H3PD2Q=", "GSB/JxHWW9XMfR9a/HcNdO+63wV4ZeJ+/m5h2yqD8e0=", "BUU4v7C4TnB+AA7Feb+415YQbaGl5Kv6iicxQdb27Q==", "DLq4WV7ua5PfDZ8lRdYUFq9a4txVpPMyZTr4zhH7QtA=", "HcbKSr1U8lTB9AG4cVAeAixCAGiOZhYTkmpjzhn3iUU=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "FksYPJJR4/EDoIxE/5vf3uSn+LhghQ/DsN2sERviwks=", "CAQ15x82h3RGbrJ2t8+l+aekuQqkw04ZhPxJmIFqn9M=", "JKglMpAs+YkXMZ7zkuScvRx5BuvHjSSkZ34QFM65jIM=", "CflhMi/7C1zoRgVMTG3HWFJ3bcjfoML4tmIps/ti/Oc=", "ua8Hb4k9k5pIkC8hB5duioh1qlNpgG5X6MH2/B9VJw==", "BsQCOe2uPnYA39AObP6Tnbiml5moJqtekfA16XEjLNk=", "JHAcZ1BSySXyuvEPZh1PcZvxRYkzYmMmBa3PvfWsqrI=", "EQANiSyzf7645BXAHhz8Jcs6JdKHrrZ7JH0O/OVsPCk=", "LKrM11ejFGMAAhBQNF7/0anltkGC4cu2dlOZew45EIY=", "ENm1GzoIa0ErHNylzhca2mU5UDa63Mee8z+Eqv6Qi/4=", "EkZm+AVh7VkW8vBwsb0kjG1T9E0nPZVqDIe5F2kqTRg=", "FHw53drthjC/G5IklgABb93cXp9fCCkcoWYzWKQdPd4=", "LSXTlmFAb6+TXTQPsVNb6QhlmBIdlthfhMtYaIBRf8E=", "GiZDycxvfnTyfs3C4wFYtKZRB3Olrt9S/p/vWiJhwmM=", "LV1wEMpn50yaTVTFAYjeJsgCouAggNbTUv09W1aCyDo=", "MGASG/doKk9RKSkzAxgYRo0FC4TCgJroFvFDQKY1vBA=", "ClFKXCJ/TOyV36Ap6N0STDSJWqRrsnwJEfN4DVAVVAo=", "J4u0mntORK6kbrD4gstpKAGm5g/dW1wjxjzWXMzk/go=", "DDmen2eqQHB6ID/u+wuVi72tzsXKNJAdJT0CaiQZ9qI=", "HWs9X26jacJvgl0jYpM+qjHqNewKd8H72eAcoVI+RDI=", "JL5RAJVDYgbdCr0LDLuVyIOrMEqlJZixppMG7JgaaI0="], ["Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "J3rIoxeKNWuQcrt7RpzNV6CmPb8I/Q3XNWAI1TB7s+Y=", "JJA73105aKjknGv6/A4o1TnsHidW5pMBqOONq4fGxAI=", "FOAlpxMcO8i9LUhQiqT3kcjr0QaI1+VWakH6DBSbhgI=", "LkHH4yDs/B2G33Zf179D7Str8nq4t8dBdO1h1XkFxVU=", "Ebs83oLom7AEGQfWbekQKbNanIyQ6kTeFmHqKs6RdFE=", "CnRgsoCCivfQpb9AZbK5ZAqc+D0ZiZzKAXH/ary0l1E=", "I0vma1mhajI8s11lFsWpL0mXt24U5laoxB8p/JSSWw4=", "J8USzYVOSDZneS14XtHtfjBWnb4S/D/LDIBBEMk3rf8=", "FTKCG4Qt86TmRXe3yJFyGchvqC5ohXoaW+QFbodjqGQ=", "HsFfHOjDzWSPMl2SrOkDUh17D2aKAcbSuStD41taxYs=", "I0dIpeQV17XNC3W3EmdeculbHgLOb0jSmdWjpImQXqU=", "FAN/7tNboJHOPbtOYDMJjQejzFEumBpJPAeI44J6ZpQ=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "CnxJoytaBabXT6re1Q0wPAZuyEOhDsWdyQy9N7pLG2s=", "B/4qSraLlPAGvB7TavRFkFyNI00wjVcBHcHTk+a8zoo=", "FbJvYdUa4XAXsbnRyQNKUQg/JbM/R0yWvKW/R+imWPA=", "Gpw+1bj1JOji3hZ4AC5zxj6+s2Bv/8Ka5Sf7lMYPX3g=", "FTqvz0kjdCcI7+FpxJBRRRaiI1NyRayj6iBd8guLXM8=", "I5y+xMhK/CGXWkDilhDYPB1xo3jMWJleUF3vAcxryHI=", "Htsr8c52pJxIRLflaSAYtSSzDBZgouADtXaHh9evbTI=", "Iid43Fv4NPkyDwN/SEfOYqKuY76MuEal4Qo8LrL/Iu4=", "F8LvRoRKU2WCiQSsc+URT5vCgzzzX2Wt3hFkkbyG4MA=", "L/+clChyfFHGvWxlfjExRwYjdjPly3iuJE1dTDrOSDk=", "HRiBgupEOlpc6pgj8+7nCiweGEWeQwXvhiZm0WI2sLg=", "GU3+Izn3qgQoGKQ/TG07Wy+t9ki6DcIZ5W7H+Ensfl0=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "HHqm1koSDWV/vrBMhAFxZkJ9DwLwQGwGdImRGK6zocg=", "HcGIh8/0VFsH0SK5CG+AucRk7lqvmOu+6KZI3zt0VR0=", "J8KDKdn4UZoa2Zc8vHEGNeXNAf+IThwRPMp7NXQleNk=", "KJzhVLsCqzOO3jvfey7+jeH+IiWUd0dZhzhlRPPrXLg=", "IlfjaLJml8muG+17XK4R77nUgTja5bezxJmjfN4obQM=", "G8nV54IKE/nwRfe1RKuy5LlUqNm2048Zjv4yddnX7dk=", "GNESxTBaBsFfr1VtWLhN3EkpElBdonvIUA+9MuTfnDk=", "LGPoAIf5JJGdIAZ/BQt9ftvari8wGP72+M2s6XaPqnU=", "CHezlfr1DV0QgSHim3ymTGQI28CPFzJ46/bei5aF4RM=", "BAzfLngo5mqZEhJiszcBzJZpaEnlUy9JJIbWmyd56eQ=", "AW6AofP+m4KEk+g9GjFCixxYaz3VTXNe7dJXkwovU5s=", "CZSpI+7l5v1qTKoxfGkm/0vrgsPf4DPzdDPTGJimDyA=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "IGCUaAPxjAhbb95aPYdQ2A+bIe05Hifhx77RgNcI6H4=", "JPpcBoPC64OwhkhTze2dV9OPM/rkloGEUOL2xJlo3Nc=", "AWKCTiAL9StzkUIZ8C3cWXhUB8VY603XL/mxGSGjUes=", "Hts3KEqsoAjBcD3eotpOt5UhzEzct2kq40S+K4gPV08=", "IYmtrOHFpwHfqcU1TO/NggTGAJX1uFaCMt0BrLPAlog=", "GfGy1k483c8o5xh/FvOpDJOXXiVpYlrGieOHiy3nx3g=", "DGLPmGaOUXi7m2smHzbhyPF28ZDTcpIcm0b4JNuMYZA=", "Fu9pXDLQXIxDQx8oSjOgE4RV2TQIyi90KUTXHu6Fq6Y=", "GRan/weVbbadcSRJ0CTYJy4tn76UKNZWLFA7mTN7HBQ=", "FVMD15pJ4olHdE8zQ2as2UVPyiEmHTK93HbOYIbo8ao=", "Id1HVtIhe9u5tDm8EuXa9ahmGx7/2InGQstJxIOc1TM=", "GXIy5Sz+mt8VOU443DBUjXz0lcdJm83Zk8LfWZk9cqU=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "LxeG5PfYGHeIrm/CXGgY0uf7NKiJZBSsn2uVjeSB6w0=", "B7kUyxbYFzh9ee4j/pl17JH+0k0OFj28tUGNlrUEwv8=", "GVhFJwWvkdSzvlu6uoVgZ8rgCXc1OJfFrA0HD5DjS6g=", "IPR+0P/T+i3Y2/2dDapRSw1y0nDRMn4zhAzxeLJ2N+U=", "K9zCKA/lCsqoUVNudDLzfIiKZQcWikt54leNc3L124I=", "EAyiP42OvPZW0fpcsiWTK2J3L+U+LFZQEJ5xIxw6mws=", "AdNZuu81RxE2N+0djkTIkWbrQVTRkNOKLG1Hr+XMEuE=", "CniuRzJGHrobkPwYsQDK03Eti2hDJN1XNDzBJ7AFo7s=", "GoQ86R4mXkts+KyQw0VFhNTUgYEyR98REkHLRAmyay0=", "AUDE7hx4v4VVYCp07Mw8P3HgUKXeqwPM3h2EMcFRvDs=", "B2loWa5svNQT6KA1qRkc2nnz0E5sPRhlhDTQVVgk5Pw=", "Ln+QBNwJFXzrtOQohGIuAwf4X+LDf6etJnSwmBssDTI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "F2B/67mIUy5secMH2QMFaiJmc1t0I9qDhD9wcj8Jpb8=", "LAJXlHKHeHDIw0V7bTsoTu1srA1D6Tw4ryGJYansPuU=", "KyTusmF4YBiegytaUL0Xk4sniIWOWNnqm7y36hdeoBI=", "GMN1oSWFT4+/MLChOMy0x3Hbz/ZMd9HGK3nXChPjB/c=", "ByUdPoYxgzM/2+nbpPOrshd3VV7H+ZbbljUjEc2fx4Q=", "Kts0EwGzlI3HAOSVOE3MEk1TcexhY2Fe5yYwCfv+8do=", "FHLMQhvY+pp++5keoGXsHIIrRP5gFkD0aZXD8Q8TI8M=", "LDqRkS3CwqeS315DE0vG1+WC+CKZSlwqY1LniZl/klg=", "AV6MEG5uo4mKCedmDsh8X7IXJw7pqOux0FLmTz37FV0=", "GWtoIVND4iB4GlK7CjJOTKdlOU0vMgGnab672THb0u0=", "LqSi1RiOmOxXDlC3DQMD7eUge+52LuiTKkZr34kaMz8=", "D79lqkKw2QDseLaN5LIEEUD8hfo0WDAydtmYJul6J4M=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "LZPSOHBL7NdsAiD8la+geD+WlQdcXZizY/kc0knEeiI=", "EBFgjsd6EaDOi4sbNs4I3k+Tr4aC+gJrh9iieVtxORs=", "EIwECV+Vqfy70DjAeYQpQNgQXFCccpEp986hxelo4ZQ=", "J7qybuq7zhU91SSJ2y+t43OpNqxSODA0q4Kp4lI4HnM=", "DSYR5z4n7Rc0ndUuE6kK3smDCl4scRXYgj0jaIuk5XA=", "HLTmeAzXCgvLRmLt/ou4KeFGpixEYcJx/xoNjbXBl00=", "HUKbElflFPrlRhS0ZI1icWmSjdOklqPQIdjdeyocv7Y=", "CRnVV6gs1ylNZmE3CQxzSNpTw7kr+jNGvxSQOhLl/8A=", "G5nBTLCJcrWPHnIWkz4x4uZ8ryn45umY/iscMOy8lHM=", "DwQ1q/qwxOD/saaH3lzAzj/tdM+bsrVZtWmlUujshtk=", "CZNmorcn4VPE4zjHz/hO++3699v0x5BIVFdPdfPY6Eg=", "GHtB19oIV1m3HCAo41mQdAgxnoxq2ELHm7IC7LQZvl8=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "D4ravhRaV0Yf6aWDZVBGp1oDeFoKKUIiGuIABmSTbjs=", "IbiHjHW0I8sfgOC1dLP2LSh4VmOqa04MqjBDppO+9sI=", "HeyZ2+kz/20cS2KF+MaHcbPuKXr7tck0qih0dl9k1gI=", "LSPtlsUevJxRSJ98h95PoVHNg3jLvHAVQvVL1PTYCA==", "Cr/vn7AWEdhuauHBzi0/6/QTeLqQo48RFmsJcYcnLog=", "KPYCOdlFmRuDfq60aT1Ja+UgJByLc50/Ice4OO4PlG0=", "GK0f6R1FMO8V7nfp/wbi07BVZKpEYTvvOxkfaxLhvYM=", "BThE/dmQcRFZCfxRj5LH0Nfukb6xYYDPm9FY0zyGecw=", "KPmXE0rpo75refbzJXr/JJh3TRuxj1U7Ip9wB2yXnd8=", "Bd1XSR8JbPRDmeR3vXjCD9hy01f10dIQhz0B06AUv78=", "HxqFnnzRzCBboaGzzCvwTgsk0ypi2+2J5Z4hE9VOCzc=", "B1+YryEvEeHeiGGXIWvXgli7dyh5N/CvjkZPkW185fI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Eo1a16CIWKLtjBYZl+1VyMqP9JXNJ+pHWYPRcVzGAtM=", "B1xJncDfsM4gBefRPBhh5fN14DvPBpUd4yOdS1b3ho4=", "KRf67CLATYuHnUSQqK56nZz38/zdM2NKq+GJtQcQ+H0=", "Gobu9Owbdaddl+YheGY/mVz2/fORNZVjIQUoS858w0Y=", "BlvgLZTkQX7cuktraGdbEHolRiCS6Q5+qIeveHDA/8A=", "Kh15na8eMAq+t/WmYmQ2DHmE71LJsVPxVBH5xirITYc=", "F8A2wZ74CFRJ92CmNl6BSCPycLpKXkHSzkrhxlPwh90=", "IVHLYX2fMjyjfOcdXHeug8hJAFe5y+jBfxUJRYkzgrw=", "JGJKjEv5bPUEAfc2H3TOFixHrIA+2UJLe75NdGXZ8g0=", "LAESKmPb3lhlB4d3Y7VyzP21nyBV/xXvIF+oSH+Co6E=", "F6iHZOZg6RlAmTte/H0xfKTQ4o19wWT2q26MD9K9ERs=", "Ioe16SnpisOBmYc7FChFwBW7IIgM2aHZMWpwJ6my0gg=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JVJ/CB6rKzJY7Tbgpy67+82HToHEmDb6ohi5TAozC4c=", "GGFp3g43wB8xgh4JCbxMe+whKaz5o0lIz3qMpYybV/k=", "BtXSh6eo0JZQl5/XJ2RhTgOEoily2G0ZHRJVyZnT2qU=", "LB92KOiqruJhxYyJZvXMkOeusd2mTVkCKOYd4Jjk7Pg=", "HDdhyMeh7h+Yhx6/r4GwuJpb1TpplmaBaBuxNS8dT6E=", "FNF3QpPYuyFCH7pZKVRWyY4+mv0MmFjWrvMFMYcH42U=", "HfLSxhTk/ipsrgWL4dyeVs4SFxx8O8S50edrGRZFj3I=", "Dyf9kyKtx0hZ2LWOS8JZWydgYbYGrM4wPyqQrkBL6ys=", "CirrmSQ5tuNypga0bpW9S1LCBy5vsowGiehLX0RPepk=", "I+Cxd5IUSwAiUrwEkOdkCj1HeE5321OvCd4vPdZQ6bc=", "KuyWMUkwgthE53IyzSICIk/Diy6w2H5+XmLBHFr10AY=", "ExhHzyeWN6WjN4FfpPQNUSUfbgF05Zxf9KxMs14vIfo=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "HI9afr9S5FBNIFsrku9Kh8mb9V/tg/5C7fAWRTMtzsg=", "Hu2WKjkayqilnZDTJKmthEfYmPS1FttKKJpLwMVl/cs=", "K3xl8CtgDUy2Skm0hIQOuxHtfpmkPbkRPtkrwH0qxOc=", "KyHoIcNMJfb+OwJ7P5h30JZu405yJMc48OH0VK4+bVE=", "IzGEPsgVZTLl/BKbldEpVG/l/5kovOCxeWSp+k2NFqs=", "It/a1cvtwBWCn6FN9jVsYAN3YaAY0M944T04BUZCc6w=", "KSxwGtCjv0J6M+G/zQc+3Sy4tebpSZBubvqTVrRxzWI=", "JT1/Hw0W1KIbDRTQS5J/CtltNI54p+NhB6nCSB9RxYc=", "EvicDYCPcpwZbCX1cNICeSX6N6F/B9nNhrNmeTtbico=", "KHOf7FznM423/rmymWh34AxMXW8Vh/JNXRZWctcn1Lc=", "KudJLEqYZN4xMwwTHAb53l1Qu/pLbuIRMgaNQ+ANh9Y=", "ItJMbFsN38Fi/gK2mFkTjyQopU7gTVG30o2z3R3l/nU=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "DOVW09VyfU5i4nFliPhzvVlbHBoxSZ2s2WtyTEt6CEg=", "Lp5zDKS+GdGAvJRckoSgrBmi0bZSO7HAukwQViXkKPI=", "BmLQP2rlkojf4gXKVMJPfzNhXEIhLp51m9xRmjdXMhQ=", "Ew+33445//3sUoTKY7S/otRQdX7uvIikh29FOL05jQM=", "FqiCzlFyNK4JMkBNNP1zBw4nqCTjN+HpnrcavVNqlnM=", "KcCAKsNJuCO1tjJnqwf7SsQ3F7/dNEoizk6zR9/xC40=", "AmoE6nQGBYvBsIks46hJyk1GktsT4e++0i64hG9icA0=", "GQQBaU7WR67cIsXdz6flwGkBgtWQHGzRfnLQU6y83RY=", "IQ1RSHrBU70V/ZXnDOYcF2DSyk7TyJBKhae+ch3CWT0=", "CwsvG3sBuWklRTjn408xyZq7CTRj30gXF1bLAFZBtkE=", "KMIc+TIh5A4Iije36MTk9rTso87aQO5LcwfJlAB2IG8=", "YTGs+yNx6tS0ffmm9ueudEkxIk146lXMZ8qvDlgErg==", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "K+vfySSyigTq/aGDR2oaWt0jB1ydArZ54QZOYelIIhA=", "H6+Y6I9TBmY7Mf1OHjRu6/bjocsfIRQuLCI0TyrbctU=", "IstIjaQk1WuYeGNKx2bEijBjcasjq6uwaI6fvCvS8wU=", "HrwPT1kBrnSBWxWdsQlW1Y2PrvCZKiws7GiRnRMaDGI=", "KcTs8tjJ1pPa2grsnnQ7soOw8Cv0zPsKuPw/1/6jgbg=", "LEoJK0VmDweSd8gd+fjzp8t002A7yDnusvv9eYOYkZo=", "FFxWq0cg9q1AEcqD56Kag/sR9vGl+fvCeC9/9Pfxhhg=", "AoCcTXpqpiz4Sc1lbJ92x+voFdUfGA4d7kXN6XFCYbY=", "FIgdToZZAU9tvbnBpF8nP/hv1kkacpwbTPX6qtg8Exk=", "LhAQSlS03uKFsYbSzuuzxSCm8IsPLcPvBxqsGJ/5Cmo=", "GqbZGFJWp9p4PpZz9HpXpPGlOe858/fxaGmV5/bekBE=", "FDOnjt4kQvKeHJCjXHWUUHm6RyoHpf/yLdYyYR8FFNk=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "AhEyNemDslNTTTNz1CWy5lrXWNmFAQmQ4MxMjAlx/dw=", "K75WacrH0JBQwEedO3frnZHyKhl3bZ45akx5uQzbbIA=", "AlHc4VulPy/N/TlEjjzkj3S84dlswrTKwjg6QPRZGMU=", "Ja87MVecLAInzh++qAhdJ9EwEjbkpGnxVEIsDACjtH8=", "EB8kANHoFNAZpHrZvW2AC4IcLeX+wDkUJ2/XQTBxqj0=", "GXa/43k2VBNUodZhl+angYMTyv3C9Iifdkf4CPpKezY=", "IjrHbe/wamMHYszY25ORAjp4Pihlnrf51XIjgStqvSw=", "Ksg7ZDWsRnOE0/538G00nGbRMnTUDDdibA4Ybtc9o6U=", "EHXnRL1x2EzSBORlKvqyNvdfpgT4M9AuKsFfBuE++So=", "CWhGhdBjGyFw2q6w6Cr0y9XClF9o3HWPBdoUg8JjMBU=", "KS4KeozBAiH2fQKccArAvBqeQdw3b9H37lKxrO2Qjyo=", "FZLdj97SewSZxde3cGno6y0n7U0BWZVduQL/R87FDRs=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "EWUw9HgpkFQskRVrg7UoP0ils7lvTMml7M/o24lEY5c=", "IHkqfAfiNcCNLMnVtO8qk7erh22fZG0PRTjHwf81T74=", "HJNCk/IovHP6S41a+dk7wht9s45lTA9pqC5tU6O6u8w=", "CtrA0aDriC8yW81Jxhd3gXgYdUHD8rh3yabi4gCxXCk=", "I3iERqtY0Q5IVy5SV3EIzw2f4zU5vQ6LqNY1wNE1tAk=", "J0W9bQqV/lviv5iLhv3H0XvdYyN3f/7UsO8A5pKlkfg=", "F82qOXj32SQ6zZ1m3oatChvFonZyBtUGtD+o33ae4Xg=", "HKz6OohQ3s3WWn3mD+PUsGO56vqoWORFXWsNpRjGsiE=", "IpHOEwh3uqzs3h4ZMhQ/l9pnpcOyv6meoJmJOTL9Pm8=", "Fa26L8OxTSCFLSF74HRNYzY6xb3Irvpr49lOvKgyw+0=", "FQYZsJH1MEzMfTZ81I1Lh4ot4G3OXZ1xN61u4wfpyt4=", "BrzUgrQKVGPQWknPrkkHwFhyOIaUxFSDd+8r6TwrFJk=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "DGeL97Q2E90sNlRraMoN04kPeJJ8W3iYp58AUaq3GZ0=", "BNVeHvhEb9/dllnQYYDddyutMXOGVIKeP2ilRiU0K2w=", "F0UUdNCgQ/Ls2xwRMR54SGN8rTErrbSWZHdtmUeiVXg=", "Fm8hFs9oRshbvh5MeLyquygj4NTAwnprzsPxwcOksAE=", "HS0ARj2Gt2R0rFbPvQ+7f1Bxx5L2EUXx/9FWhkXoPzk=", "BS+mgzkG+sY2z3obvjttNl8W2RfleGzNHzA+/4Q5RH4=", "Gu4uBttdTi698WOo0e+JtwUQw3rLtHtaFNDGSW5mZp8=", "Hk0KcdynSy1MDEA6jJnNlYJhFBJ0OUTSW5fuQQgCb7k=", "GjHqAQKzE7yWy+VY8PxmJCXiX8X5OVpCoFHpJ64/ovM=", "Ln2Z/EYxaD1ntir8IUyOib68kbStxGJccPxYE4QLm8E=", "C6AuZteItNssEOS2M0TlZM0kwaPn5/O1yMC8UPKqgFE=", "AZOObO4JFn/k8bYlaSnsiTB/6mI/8ApMFZk/1EubmuI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JOqeKyXB0Qlz/CdYEUrATWIpLXVjPlqY2H1CJF0whd0=", "C389rfgMW+Sp/nJNjH755LRibZ6K1hKV+UgqW9wcZhU=", "BtmiX176++BzjpwdjikdfcxucENJc5cWNvv5VzU1Rd8=", "BX0I2hlMZB0cGVem/26lA3ZA9rKRD4VGU8HRSQmnO5I=", "Gxw/tccWDYfK5W71qAgwilGIq/lLTxJ0EbNjalCYpig=", "BOD5soHwDiRry38+UlnkVU66EUi5Kx1GRyclkme1mdE=", "HzGluu/wN+3WkSd5x5tWbGiRtVvwI5jCovH0CkGyqsk=", "JOyqxNYCP7J8tYNnlOH4IfamGSTRSBDsiC51e7UVBwk=", "FR8Tg3mkNBz7Gh+gm7P8TqT1jwwCE70iE5cf3PF5E5Q=", "H4/8lWtfpfbFcAOU6GM0He1Fy/ZBmRhUJWUeklZML+k=", "F+yEt+yT/HIEkV588WN5dFaZLItb0c44ef9yONYGJ+0=", "A6Z+ch2iQTnGID7fZe5W3r0ttRArLBk6yhDJjnDMI1Q=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "GZqMTGMEj4ySuW4v5zw+8b4eKuMSvFBM1u3K0L+Wlns=", "INXVMVYUKRxDGh8n7mN9CYxrJFXgGYcqBr+psTIrvFg=", "IE6HzaROUNcrNsmgvviQarsUcctPrqEmK74fFI7ttg8=", "Aa4NxM+GFe/Nvmm/fmWGO5iEKX1zILPSyausgK7fUZo=", "Gd3LbnA1IDl/VmyJabR2BfkH/XM6dTEzAyn9B9Daq2M=", "Ik+HFJCxInFUnlvxIFrBY2T4xvnL/aghQGi2nztYylc=", "MFiI+bcWwKrVTwzk7hx0BSvMQiYSMs2pbq/SwX+u5cU=", "B5dha246MbpAkPxGvzcIVEg4RkKOUu1Pu94W7NtAft8=", "ENDJwZJnLeGpq4a0acbJvfR0/UwHf6KyfnAmESleBrY=", "G75MBh6Iq5MUTwzfeHOs3N9pWr4BcSQJ+UJRe/J3XCk=", "PzfFKU9YGvDgtAfh8WkazMybLw+rBPxo2WhifOOPzA==", "EP0crANRKEkx3xiwbW2Lqq4Sh5ME5lZ+luAkJYpj2Ew=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "L0zpP6b2kXlZhTAHXC3+2SSA5AtQgsHk0IhKblqXDJU=", "BIqh44pmw9ZWumcSSYbyf79B4W0a6l1mtW1/94alQR8=", "BpMotsl2EJm7lOH7r/RqRkOm1SwoJgOL+60rlqqAClU=", "GMXfu5YR30wXYDT1OLszVcTqmjRCi1aLPVSEJk/i7H4=", "JQlkxucW8YjxoGC7/MIL9snFda7Y7uepUog4deNGnl8=", "HK/ED3G06lX3RJmB2VLiACQqN1BWs+vuxUL3QwKdNoA=", "HjRf0nt12p9ztm19Ef5Tv019mQcZT//5Jrb9c2UOqwA=", "H4bBmk5BYixc9tKX8/sJZtHd8owUwu8pbYEdzXJWVrs=", "BnqcoxTBuYmiWPUwbwIBd1ZnbIVV4V4zFnTf4t6WCu0=", "GowsOTxZQO5mqfy3dFxxEYPd2NUzbNK3KIDRU0+9lU8=", "LQ/k486nbYsz8pz4XrQmjgCXJwuVU2l4Kt9vO1aidiw=", "CD9xwWV/RgNgrOCItWgjV+fVkbMxvso53nDnwFesrs0=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "AQKbRljuXQPJR24d97fsVEfcqRDd9n5hAkdpUUD3rms=", "LS++i0qip45tFbRx0DSjHAcQqMsjzWS/ihBbD19sUIg=", "LGjROgOPfMIdQDXy+uPOLkSwYHZ1XmTbyVpI74/TLsg=", "JVQz5EEBPyi2RcQ5q9ADzyFhlc1qyJ6cyjomBeKvr+k=", "K2Ex79ZvoESVTxss8HmMRIQLmsX5H3O8HWpDXRksBgY=", "DFDPPUerxNUJTk+qRe+JUOnzD2EllTyqvhJAxw2sVMQ=", "Gax7sCxGbBT5V6hoPy3HoPiI8LufIzrK4FaEk/NTtDg=", "E0kyeAhVyk5w2xidVDkZLSV6hWDaqwC+esK7BaX0PUk=", "FGUuPwGfGJWPboxSH7WzdfdVaRzbTPfMXeTqflRDhFo=", "Du5Ls8emKP44vRTfpY96d0ABJh4sGwATuKvBFeQFloU=", "GtEJZ6j6O9NthmIdAhxG26cJ/yhTh8Bkrm8wXLsNx34=", "Bvw4M3GKTok38RUc7We9EFmrOG/8pjWWEpmA/+DOuUM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "FtdRpnx5+ZFIURVdOG4TsAWLRoIoPaLSB4cEx1V2x+E=", "Le0u3e5Yk70n6FoD1lAaKWiz7xiiDs9QZC1SAf1AJS8=", "GsdnC6VffuHC7lboJegO4tqBHvj6CLkNi+7tvuEEkps=", "Bkz7ZYq9ZnBqAS8Q4/J+DYybg7Po5SNHdN/sXhICcS0=", "CAbRaWOulrrcFixFlfSE/GqM33U9GNM2r/WyTOEwPds=", "FIzQafV49qhkySyjj61TQjyah5KWfkQ3gwVznDnDlRs=", "FROYTQwcoLJKt5TthqS5T0dQo6W/GXf7b+rJr8hfRdM=", "BR+ZgJPk27Tn+OQQE5pl6kR2Tw0q9qtUYbNHF6lWG/Y=", "H4ffTYTs17Vb0Dco3lB6fFQJiGgRFSY04WzS01oY2ws=", "CVbzdVRvCxn20vMcW+QnlbF5BDQVlNql+YiGutRCEIw=", "DxewP2l69lZiwl89xD8fXgUPHs8AmrAE8/xjKTgTAzk=", "LUAybpTT3RPAU02wOw9rpu5UuygK+Z/dBdHMfJTJU20=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Kw7uQESTnv7SmwpQArFqsOAvddHhk6IXh9an+ToBhQg=", "G1nQVe2EW0wwT8HnE8Yi0d/MfsqP2qV/ONcYLVKxtKk=", "HS1K3+i/c86+/gegiFB0Eu71oe/AIMfjyB/JxqEQNqY=", "KFcSXRmukmhWo8z8r3Cs8rJY+frXD+JC9xaP+i0C0uA=", "Lx2grU1M29hoaRplSVAG6zcoxuQQpX24L4dGcfddfIE=", "KU00NQqbv3Jpkr7mKzzX0qMzACNApL/tdPYgnEthc84=", "FuXzdAZrIjylokAfEC1l9ef71neQWy4X5WhhL/lrYCw=", "F8G8RNcHBkFyJcedzJ21acefvqZsAY8ogTIcSHe3/DE=", "JkzRMFezY1UY7kQl+I7bqYakl3bpR2Ck1zsXkCzA01k=", "K4+h5l/bRZiXAaDyMRFMDveo/TclxiBwqddI5arpWCc=", "B58W5276o8qn4vJmrns/G7tUpu5XFohGPJ1isXrP1ug=", "HFpv8IkwU8Q8VSz0G2i0indZ5j0PxgadLuJHwXD3HSU=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "J33LH4KBDQkbfb0C66bo7fXJewhAekacStmewKeTiiY=", "FQc1fOM4pvHF8BkHqRxiCC5uUYLNi4xH+QUbLLrNUjg=", "ENn7TcYLcGTo1uxkNyfDlNpzGCRMV2lru0c+K/wnPLA=", "BRzbevVa8Ug4Fs8C20d8XCGi4WdgrBc5VBevySzHiXk=", "BX10kZUdv1HwsbBUBuWOo31hUYpnVG/UMBeKR+XDTcA=", "GlEgOZksDSG9fyQ2utMVo5VbOAl1aMMG+pLmA9QSnsE=", "MEf3UdiBQIofWD32d6cxPzQdDZAVCwAxv9r1oXwacaY=", "GC2V1kfF8nNjgYA5Unu7vPI/TBQ/a7mLBk2qXwnRJ9Y=", "JZc8hYE8fseLJr1jOV9SLg+M+w+mqCN1ubZe8OJMKv8=", "MAFuTpSvogTVxCCQjxqhj7vihqlRKg991JKyaOK9TQo=", "Deh1mRXnqxugNH59POrWZjRJzz5W37yHsjH3hKahb2w=", "Kz59Y/KGq0m7PMsw+ajTN8KocXmQIGgefB5RcFabtrY=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "IvbcUV8qbYRKSU08MH7HFctKxDmrq3ut2fAITOF4Vxg=", "HshD73/U1AeNPGjz9pkZfRgYozIfZNFdlA6mgW2y1O0=", "J0iDVbxA47SBdeIVu3k3QT6x/ilvUSZuQtQh0ddEhZw=", "Lly3hs374MdLBfzHAO6Vk2ZYY01ruRUiUeGtOPPKZmY=", "CS9LizDolUQu4/SBEhoEVCywHppFjz5hx3MyjhuIf1E=", "KUNSX3tjAty9q/v3rFwnwBh7sBYGnDOzlHvsxowAqHM=", "IqYWUfaeJjYBlBHULt+8sM28w7HA9bvuism69msbhIc=", "DNQ+pkPBnm7sREj7rh6mxA3ZZl2TsECZZY9OIWsNeSU=", "Dm+5rHKjxHVN5Y1bTrzg8yqmUds9FNWturDt9510ZkQ=", "Dhi/NlfOWQAvV+iiUTHjlTSt4Q10IxPYHwK+yjy+8E0=", "JNMcpGLZ9Z3+bxFLr7vWe7yfsV4mC+01UuBuVZvASfI=", "FmPsdM9n27jmaNfqxci/UcV0LAkPenB+KX1EoOMAsJM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "FZ7Km5I9fL5b2Mp7Pe0Rw85iJhMKY8uQUong8CpTUcs=", "KrvDO0NbrtY/PDGqWD6/gGEjbUIzIebKZm0zoBWbEZM=", "InmJdClPrvHjFL64t9/65GtQJ2IwsGyYBpt0LVvHic4=", "BWhBvLHBinDdKYraFCxXeiSbfKMB0QgKa+WmIdYE8V8=", "GCOlWIesr5aWY5nTgb3HuKeS1A1x5cXcJKUdAvmUbNI=", "J7uahniwosvZEeYbaPSmko7G89uQ/CiISvjiDvcRhCs=", "E5HrNeENsX2EsOfdRRRadUl3xMu5DtG+zpZquJ3nHxA=", "HdqtSTD7nP8Br/4Ma8IDSsvCDfCf77T+p8NG363Pmdg=", "CWemRntIZFC1HKjVKdauoe+xAe3zHzZG7+HpaVNaaow=", "Ju2tkbysIgJgbVedNoLucUF682WlvTze2hYVjQBZ8y0=", "Ccji/YccNfNEjuSdfnUx3LUwGm50iAnuY5sVKJZ3OHg=", "At4lQ0Dzlon7PF43QMHRzu4m6O+HxkyLPvXuricSov0=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "IprUxxNUxLKuLwEeN03gX3JUiqx/QH2PUvAN23TyRWw=", "FdGunj1hX4Mhvhbbmb1DuSMdxR/KeunvLB/1DMlI1eU=", "GtWV62DkS9oVkaSn6m+ssD7Rjo5Mf+RKpJScF2s/3ZM=", "Ica5WOiiTd/VaG4YobHJOEPqPvuhOGkwL0Y4LmpX5Wc=", "G0ZDxHvjapYIryF+2/myE4BF4pWwYt1LcgiWxVwZgOY=", "BEQV3x27rzQtEdkF9WmmilPN71jOK/GVA+0NAyrTy1g=", "KxsmbUEK16iZDTUOW+WxvnCCL1zwWRz7wAMCxqFQT60=", "A8+Aamjp7iXqALV6veufS1yhmfmvNCiotcyH2x7+ga0=", "EBPJySNS39CcPmrKr/osRJI7NUksVpG8fp5zQHL+6CI=", "GK/JI0Bkng2WCKpSbS+Ghm1LxSgMP0Wt3GVnuDOSht4=", "Jlz/Rpgy/yDjXS2k5QUFuOF6TurM21FvNvOnH8kWqC0=", "DIPCud86pKh0SU4ykgaWi4myOwLzUlh4jpuvtDxHyXM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "EL/AD+UmnSgwGyAHVuJs8Sgb4nHRMAsR2Yip68BisQo=", "MDweQexGFFObTt67zkBWUkdcEoLupwjPL/ObqK/0pN8=", "DLj5y+lCD2rfCemHqLtEFY/7qJq9enOO1UrGqV8XUAo=", "LwyzARx2H4TcWwG6eokZSRnQb5QwT7mdy8Ctenv695Y=", "EBUabYwuTU3SZbPrzA53iq8FagITn/+cLvJZaN0qutk=", "HlCDi7TcT/IWq/hFW4WFAQEH4tZNH6YA9vNAhlXTb8A=", "BSiFD/LHzMzQdLqoXgmJ5XznbqYLaXuP8ZyX8fm1dxs=", "2oO+DhauTt69H7vVswA0hvV4O9eRZOocak+9lFooWw==", "G/gJqvYQBaomKVLhrCFB5aCqWW+52CjPLuJjm1kQHmU=", "IxpR7IVlu3LWeRu3WPirvlOSzgimVfK9A/dZOgJu03E=", "InqjvQhmQzYp88/SKOIL5X+EmfSlWX00KcQOrbI48fA=", "JytadvRc9u7jIQym30drJVX9ef0GGAs/frVGvfLp5Og=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Cro5ORHAAbbnAbRHJqF2vNsnbQLT7/XnCwzBaqdXCVg=", "KCwVf2zHYUIy+XTrEQIS94YTSpZYcv+e6UMM8Fp4JqY=", "Fss7BmVOSZelQyhOp9Eu+nuCHpaImw3+uquetwXYKbc=", "I2TD90o7GLwq9fiRJlUvy1jIDs7pwFwPy045My3tsgU=", "JnsRE6ofIPRdW9HgQikMjR5+e0tWKBhHBLgfiU0H/Q8=", "vRh8M36tSLaImz4gAm2/YEcp+ydGD8G1G3s6A+mBLg==", "JpE1GjJmGpCASA5R11jPDju7nbxD4QgpNXbBU9u5JlQ=", "E8SRUtlB02ZO9iCkfykim4tBBgua5YgGWHcqxhX2xIs=", "CsXmiziBDVND3MwJkHa3rJOIwlzWorLRgoABVq0YtDg=", "GKfl5uL22SxAn89rwZeNlj+oCTvYNmepXxmEHxqCYCI=", "Hudvven/gz2GCr/gn0TM5YTO3lpqIKp2WXV2TZfDw48=", "KROeGNFmZmh+lQx/QXrKFFiDVtZze7ctBERP4x4VwpI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "J/9GF2mOazlc7W0OQLsyek3aVGeuAB5O2ChxPFjkz3I=", "H66qJrnUAWp7BgoRJbW4PiIXSsYTHIYNd8NM82jU1fo=", "EWuWGS9UO4UDEwsb9oSpvygrQfQAqtAEF3f3Qfl9Qq8=", "Gs5A81elJIh8vAdI6cwr0vloqH75RGg1nEj90zPq/9E=", "DrkOdPM+U3VjxML4Yz5tj40jBCZnQatbDAyXqJxPdrM=", "FfaStlsOSicp0dB6coApoi5qry2AE6JtgOovTtcjCy0=", "GZwljxJl9B8DjSNCSdeanXzQ9DU1X5yfnWcdErPYE2A=", "KqSHDcE7xIsZ89erXfKC+FV4PVyxU5zzWNI1hZzDgyg=", "L6luCNRhPreAY3dIRrYIvgtwFBZd9CB7gyFyKdRSM2s=", "HkXfZQirtBt07vOR/mA0ZeFC5zMcGhHm0abc47WvRZ4=", "FXMm3j/CeKOrSVJ8O71m5pRAZaBor9qzQmrOzaL87To=", "E8uxhGhuToAMA9Mrm7DoYyLAVH/3C9zWtt1iL+nPdyw=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "IZW/Jk149ZBVEelG+iv4/Rwx4lFAXyTtxnn9wuKMSTU=", "KJGgTIyTM8P4bLnCfbDNRZC5FXTyg9mNh1iMUykHD/g=", "JXdMpH+4HpgNYCS8t4SeEL+Ql0cS8cFbPF5C1IqZCzI=", "Ga/Bv8pE+rbdjPNH0TvZ1nmmY6uGTddHTAlYVaaUiao=", "KoVfNHFTUDORr1zdjzO6hNm38zDF1xo9TRMIqjbuH14=", "IWmpF7VYaizR9E/Dms7ooK8hwLBVH+KCNmIIe1DT4YM=", "Flw4ObRvK42clM/RrNqf5MtLN7ZPdTAyTkSoWbgsCD8=", "Er+az5fF0bLCNyNUFFX7+medNTmHlDQBCEPleP4zuiY=", "CXPUmQq9UB0kalvqK11GeuB/jxQZaLxwSajX0QC42Ao=", "KBoPEBgEnOVWCu0RkZ336Tw0F5XJ+x6hfKf25h9WRQs=", "AWB9x3ZkBMUThQ/e/J8+JdK59ukLT1ZkGPoUK3h7odI=", "EAAQMop3bR4MU/VceVVvEr7p8vyQiwsZshUlO5HAca8=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "D+bjNMAEs29qmqehaVMluEE8w6Un/XcJOWDW2h2meL8=", "GSx6VWbbqwTWHc+vlnXMiIM0d0c/B0LH30WNwMckkvY=", "Ftn3n04uMolem306E8uj+QVcIu4A+vr5TPGiI3J5wos=", "CzyXDDq8gaXGTfgXfWnOYqqrr+THl+rab4ck7VmSSWM=", "HjSAtrQxZfLp6YzcaxdQyfhVI3XHRv2TGPbpjd4YgUY=", "A+2ZeNaYAg4WJ/veePg9/XJnpSUxXQPCf5NKBJAdcX8=", "FPli5PF4aITn7FK9pjRCEVVQp1I+mEDtYOjOHZfoHCc=", "A1Lvm7k6xT+/DK1EpMnzWdi+I52nyNpRLDuPM58euMo=", "HX2vPVFpk83yq1GZ9/oDjsGLe8HXZDGR3KSQc0tBFio=", "GcT7nHMwKSuYWcRHHAVYaS7wFcvVjH1rn49qYXAQVb8=", "IiYcLKeY2+oqmJtJWabOWaMnoaWBfvTQyZFH154RnWY=", "HIqCKnzJSbyR8yYkKCwLkYNa7OvMgFrdk38sM+8rE+A=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JB6vyi/9GolQHfuO6fa5HCcNLt+yK3f12WtkwHSXKGY=", "Hr/UTTKMEg4lMxNZuVDpb6o7JNgDz+v8P721rsfT8h4=", "HUX56VW+Ob4ptyQ15gzLgs7KTdHxuyQspARh+ZZtuhg=", "A+aOmCtvmhMXqMctFRnI2ZJ0cQfNFkf1XPhvEnSSGTQ=", "JNWDEMI/qI4SdnjP2txpztQ0SqYt/9pdF7+1zGz5IWQ=", "J3FZ4xmW3NtxLJoDCxS0DkVwTJ3rv2yDOB0juYJ3Vk0=", "A/yf8Aumt7FYTspfubwkeSieBb6Pf64ISElCTLCKFBI=", "ECcxztPFHxO58MVxoDJ9WxaYQVGsOIrnEAjgYrEDx+0=", "KuxiT2ENlJt+BQ+SQL3GfrALF5gGN3Mak0ARKbq8UcU=", "A0i9CCL6Dlcz5Z03xsJTVKiZKGIQ3RGwBrRQhriTbmQ=", "D3tGhd405F6OiEcmgJIC1xcACSbcYtM3Ps3I9tYQWjs=", "Ipq/JPwzPSZDz1FOyHfDFVufXUVjl13e+heeaecorgo=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "HpqIJwP5/BfgubDhPBM2G+t/N8BNAKs5HVm/9Oqcxzg=", "GK6B3l1WGSbElQC0ocgX4Sf/Nb2S73E7i+zYypNOGO4=", "D2kcQkFkCHHczAPjhqWRyQaHEbaeNcYYroITp7l2tGc=", "HdOngZY+rLdiPxpTmWt5scXb3u9julCdJkF518fFg2c=", "4wuBUcWRKfdKhoWD8to29/Ms8H2Toh3LikGJKaO6tA==", "F2pKf2v4A6Oy17Nm01Ro1EkhD0jzF1P7Y9TFClIvBO4=", "LQE4oKX2AJZNS6TOg5HKr2EOe5y0bs5rrEOGWOcoRgY=", "EggEnsZt2LNc3XSMa35Uw9/UzmOTeo5fXXu1XHC8MlY=", "HJ88Nt/iFmSvrrDx0pFm8olkVf40o+OpN3Z6Peb7kro=", "IDyohVVN3aNcTKWO0hUIZ/Z3yZoa+keW++xMPqU0t7s=", "Ag4o9dkBxCXrbUiYDp+GshKRH9lN6FBmPkvEBCzy+44=", "ju5A2s07qMqJU+t3E7+cZCMnu5b1WnIA9/GYUaJRRw==", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "LeLKwE0j6PhEeAGOQWChzzTWbs1rTLjKZzebDf7RcH0=", "De4QS+KLqaRJPgXRQHIiNhCnfvZV9kao7B8lQUawc50=", "GYVG2x+bMHPFcM9JN709cWM2uCZ67/2pXeuq0nZMkbA=", "LfEMeFR3zPKq1UhzoJn3pSRbeheX1LdpLfNaAaQmXgw=", "A45rgDtysi0H88TU2oXVg9GVLavm9Mv62K4W/+Wq7VU=", "IP9mrZ+QVuigxRN4X38aoa0LU+4wVCnF0pnss7fT/5U=", "JmLkzm7wFM+VrhBB6O6PJesC0YiiNL28/ypP3NIi+g4=", "F0KZsn0YDQrFnjH/sQGmjr7lteF+juJRthzcLXO12Ws=", "LNc8bORsZkurdgxNc6fwUTLh3fwOwRPps3+RRPehoko=", "HJUaUBXr5FiTqSrxtbUWiCmPu7pHSHX3ub+X+qppzfs=", "EpKoLsNI/GOfYcG51PSOGnKfjk0pconEXeudeSRafGo=", "Cg6xZJiVtwKOeyhvFHzUdlX9k4CtlrEvJdTVATTxtiQ=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "FTh5Jn/lheQSd6RwlcLnGlVq7MibiAVJo+ZZiitnmIg=", "IFZHFe0XYB7eRLDd6qt4wHsk18OEsqJ4rlkCrk1TrCE=", "JEp2PhCw6/3qStbhFb/GKUq4WSUVoPEDdQ8j/0dF1Ls=", "IxPeXTUKCPg6BvYDAWJ7UhcGeOxAidleMahc5jnU0/o=", "L2HHo1dWQnKmwx8dSiw31o+Ufrrl7wbwAD9Huq+LJVE=", "K6VhggIr/KqUsoxLrHT9e6s2ji8XsSOsp8rTwHN3un0=", "CQPpe4awPWO9qdAVz6xOHfDH61UxFNZgPh2cxt71or8=", "F+8TallQeIfuN2ydAxVdVjj3NpWCm991PyAnyT9uD/Q=", "DSz5eA07hmXwe0hfm2HJetQ1I7UriaIWF1+0eVlrQpw=", "LLEMZxPJwEH5iOHRbhl02zu/ZPpqDdcWZU0vPX7j+gg=", "Kn+sD3zOFnflNGUgNHjrKof0paz9CsaxCyQmGWfyZcE=", "FQ8aMlHqFCzpyIY62t+Qj5i29Oyk+ox/YINOvagF784=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "H1+fCp5yJiQqumhUWbotCHMF280VI44NYVN/vLTo6lQ=", "D+x3g4i9KfH9wBcZqirPu9B4c6TGKMqt8E7UYaSbVzA=", "CPu4DYrWflIDDFJRLzlH6w+iV+emvJfbwYhI7WhD/bA=", "Igrm/EoUEfkipnw9IZHRb6cuRIWIH1xE0HrRsw/3JTQ=", "DCTbFE/tdz2/SihfaykvCX5zxCELZPYNBHEJlSYSUgc=", "FT4z2l+Tk/sU3l+Nn/Jf7GP5woRWPJt1SFuMWWVxYCI=", "KBkO7IkO1PtRF2ohZDyov4pMbR3c372nC67phC53Hg0=", "DTUtMU+KZJvtrJet6cvlHLtMHXYSS8t1P/RhJK4sZx8=", "BYlFQiL4gP9ns7Z3GslXkRXvmLSlKRrR9GbDffWfegw=", "BweWizYyfre/QtiBkyIl0eapy64+mp6xo1c1dbCBUl8=", "JNFbkHWEgi2U7Tz7B2RKHZz5hblKwI+6u79QcMo7os8=", "AtUcSLY9l2JWKPwanCZaKfS1rBodC6gH8/HWpyno0Nc=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "DF0+FoGvjHMWNaZtguj/pS1v6a5FUcMdnOXH6fFILzw=", "GfVzx7uvSvV6sRnZw0qXbHoncOmWD4Mkv5OOZ6QLtiE=", "DdU9k6FYgypjrgI0bPsFD0qr2T0sN2ppQyK3ACCvc5o=", "EiFoRxvkUeH+I4OhqCeVZoCE1GAuE2w1MxVq5OtE5f4=", "GBFx5q95IeJo+OTKAqad8C+Z43TwhkM+LYQ4RluHj6Q=", "IP3kJK+xcVFr26WroTAvPECtvG32AJlBzgl44QBfFXA=", "DJmaPAdpfNbkYyEQhioOPNbyrn6tWgxi+D5X43UnJqw=", "GB5DNQ1kt133xXgIBgqKRnMEqbEHZkJll/tIUBZkLRw=", "IvlBQ4+2OND24QE9gWchSekb3XlIFqFJQmgwoUC6VSA=", "J7yW3woD+lQDSd8qRmMzCbjg0pNaYkx6pRzYWTc7HTo=", "DaZXSjHLCwEEgN+2rTMBVwjnHEILjzZkGGh2r7i0i2k=", "KpMto9ST9dIpoA8YvcaxOgB4PvEFEO8C04NqlyjnVlM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "GqhA7HkF++1LImdchMvVJyGNtr3SHpVY/vmIYLwzdgc=", "LFEHNTwO3I4FrTayd0d8nTqy0m/UPdIlKHjKgUxIRZ0=", "Gs7SHK53HQKUoWML5nV52BJFCT0nMYmKcrgi+Bhe8/g=", "AaJKf6TW1UmK8d8vhspmRxo0DEdHoeJPWSqnZnNGqqg=", "KJyvN9xMZP2MZnGAE/w/FJKzx2zRynExlq7z2VKB46k=", "AoTENQXfj6fd1vnqdGTzysqKOztV05USo4svN7dDeAI=", "BQFInnyRoTCGyFCnF0hI3Te8t+ai+FccowhkFeIqJJo=", "HZEecJy6lBHPIhOSsdjo8pLTiV5c8lCXf3vfckY356U=", "Jux1VUK9RcLElo/MmBksrCW7U5z+y3wWySbt/rwN1Kk=", "IRs9gS+Wh0Z9YjhhkJkJ6KV55mwTXQrQ02A4EW6FjOs=", "GDX1xEx77Hv/HIFMONEJVycC7oWGDCl3ZQ25EN1VXbU=", "IrsIAQzddErOhcdYxYV21rNTymMm6d6MpZTFe0Cna0g=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "F4vb2GPf0kjbfMYIgbF5lvqMsPWoBro36BjUk91NBNU=", "LC/uvCXD6ZEfvNfHfd/I/toONrMEXoYFnrJQfbhLINw=", "HY8JJOL+k7eG6hyjLNfdJoCX4RROXzhoE+QNfeY4VBQ=", "HXtCl9W1g7wA2UbqLUXnm8o7hp84iaPvi2mG7oBRVgM=", "BrKeimzYJXEwZSPleoiuLxxidoivalerSt7EgHHYZK0=", "I/cIAmoHOFEiSMBaWlHcDwtky9UMmPLAATAaja2hVkk=", "D7m2dgbRtwpZr++ZzBW1HM2s2KxBKFjjf9CltoWqEYc=", "LlB7gIcgCnsU18hGUOVoPveNflKBtInUNSQgbO0xTNI=", "G+wJjSEOBqprgARpclu302HajxBuPfBv1XiLO0I7/s8=", "Bu8reEVO5fQziKfqRyiZb8rLjAHGRFNPpZDeHahkIXI=", "DVZi8lVpuqoLENZhQjePD/MCo2VNoxi/o3CBK60qZvw=", "K/d7bAqhSaecaV1n1kAFyQ6Sa0SJAIWz/mMbSo2mR2A=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "G9iXXJDKTjVvHDfxL87A717PSEc283X3hWa6iqnoZCc=", "K+u0YEPGddjUsT6dPCQ/SdpkZAlU/V4ZQCLIRtac3Wk=", "H7flTADjgjQ0ggaxNuF9tIdDoeiDOkFG+QUROWAxS+E=", "D6UNVE8ENN9I09/c/dFkuevY5X16YL5muHkpSkCpw5Y=", "KD6mE5tlMmZmrwTZkT8yAPm5MGeGe+HyQxeW6a3Vvaw=", "B1isKjBrsywQMFeJIf4JpdQNg9lo7BCq0xoVp8VtqLQ=", "D0EwiNQQbopGv3y6BG0fR7f4p0FAB2iDXYU4MOoA7zo=", "BGY1gGnVj0eGssp4LcT3pnhvzoiYP8+SdbmlhQ+BTyg=", "E4XyOALWvui3Z0NWTdVRDtEgDwlK5sFvA/+LTO+gcEc=", "EIBy0ZfMebQYhDagxQhF0kXMv9FICkiCryzIg1HVQZ4=", "C20pf37GZ8aNXX/3rvSCWd3mLa6sJLeGjg+tkKs/Onk=", "DIJBj69AO96OVRVU9Mi+lFz80feGFclSXTxgeTCwq6k=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "KXsaHG+xmp8EkCJtI5NnlsqoxHo5DOXjQU2RJDrf/fU=", "HY3gXdM/tlE5Yva/FAbT2kAgZOLTIADc+6Gq4dOaLZc=", "GawKGKKXYf5JaLqi+NTU16jSQcX8XLVKE5l4c6S/jw0=", "EwCaLhvlCzU7q/v6DJ/Eg0ESXJAoqT2ZsWwxg14hkc0=", "DWYJlYQs4ZFHatBkpVmeLFQV9Izlc5LmbmcaUDowsRk=", "5Vh65M/UFu30NKJjybq7RdeTobUi/JbnhFAF9RaUSw==", "EPu8QgQ0kWJh9s6V0cp0l7gjcUN1cIneLIEziKzDBw0=", "GQ0VUHdIs47F2Nlsu0DLzNPNAE8fUA86j9+dndBc/8g=", "Bw6Bxc+VErhQh/7EsES8rN8OvDaTng4z8SCVkpsVP6c=", "IFdxcazMFx3hKCzvgnpbP3YgwpVmWYBmA3lH2hPcCfw=", "EFwC6r81nJ+xgMERLlYLyJS8LEU5QfKeG1LCjA2MbDE=", "BwGYYjKyRx+btwxwlB8HMsWbnRwdes198rXJo9EGM5c=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "C9DPrqy1NDvHGBjuxLqj6x9z5czfTU+x5YW5MmeU2Ow=", "CrbOn+mtE77u7bU1+cx73VGp7dQmpUqbhbbyORHby44=", "IPUCPR5S/v7hJKtC9esooMGM6oh+Ogu3xGJu5pSUaYQ=", "GA8O5yNDszzXCYmQqb8zq7UJ1FRwD2AtIwZ/AxoxSrI=", "CeAG8+hYhjcLwRosktaxkF2i4dc4n7v6jOKww3l7MgQ=", "DNgooXM/f+hOtWSCsMNzt7+f/unHCTOnB4LEYQSnq+8=", "FK5QQ9lLjyNtdw5UNdNw4HvkcFN/qHNKpiRT7y26g+8=", "DPxG3tyPFTXOq8dQfLW8fcJ6RLaeuNeZ6gN7ncDLSb8=", "E9EM05RH5l8DvMJ2V85GuPS58NbQ2QUuqnAKqsTlYgQ=", "AdGdQQZQOhE4OWhd6FL336HM0hMVUuGPnmJ5m/29OU4=", "HB5X1i92+IU5q3/XO9dXfDWKrIv9vgwJU8zszvVbHHw=", "GfLax2I5IyjDelpU1MuYA4ORgpcHjKL8z4YFxS827kg=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "ERBAltUfEfjbgGhTpHDh8oOO7Cq+9XCgGnvIM6J1JvM=", "IDhGFR10OU0yLs79giAsspNhGS/GaS+N5MB4jlNkv/M=", "KjIU3InYeUzDCPCy/tEkBCbpCVh5k19Iife86bBtEiM=", "KWyqOvq1ev8M6sFuzwW2iHrmmBwmO2C0nqrbvfUzKnY=", "LKYzsowTQ7fDyojDtvT52hE9qpMoBibpizx51pMtOTI=", "LGJzK2k5OkSVFUIFqbY2ZQogEnHaYLZUM0Ga6PRUPyw=", "BUog8bzhdLIGP1WBqGkT2e21trMN52NIqIHzIK/NTA0=", "EtvI9MFm7cJxbFdiSK9oG2ntlP+h5bO0hFnJeHzjlWk=", "E9cz0BjtfG9KHkcde4pvNgR6ycqTFn1/CqZ08XBP57Q=", "K6obdSoJXA11Ut+2XPL1aLR6Ey/9UADLonILqKxMGKE=", "Dcl8+s1HcbQAujXTPL67pzfHDoTwfQyjfboJOiRgyUQ=", "LrcbonZKclAoG301Bt6vBBZZPsNCjfGp/iMS5mVB8xs=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JKay9jKC7Pm+CYj5nQsReYyjPyyLzE5Wabx6JWqzWUs=", "E7B0tU3ljp+hfOY1bTpto9gAQZ2acXDjuxMQ2qT0+W4=", "JxECOuLwPAOZOZd1qMoBjnuR5Q+0x1KbuwnVzIjcnZA=", "Cfvx8Mn8KOkvIED7exMjc6Vb3vB/kAnDrv0T7g97Npo=", "K1oboKRwIINCSwRYaa/4aAOIKQ9LFkzC8CKxbrDpblg=", "EpLHYq1qOr119erWCLjy+Q+MUot3KkLXUM0kTXTbLoY=", "CZKC2En/rJg7xs2ZgnodNo3sQuf7vt+1amlHhU9Bd7M=", "F26sfdJixD//PZNcDBHbPSOwVCpuXgdQLbzqYzrkMQY=", "D6ojKh0M6ygcOkKPPmeq/g+xon+9WMibMUP0ht3l2yc=", "IMyow5FWvp07fzyqBBr1LqU48+wXPMzAs0l6oGi44aM=", "FGeZvuFOlsuTFl4wMG54vjItEbT/AIrzFihpidZI69Q=", "Kx16j/wiJpPqDVOYAo1gQry/vOaJSq5secAtM5j+Q/A=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "E6FY+dZ9SzXoGH90FRPoGMMqFenOPXrRfl4P92hhBzs=", "K2SiHZEado7Y9CQJLYW63qChQWmdQbsxtE0FynZ39iI=", "BnIfwFFDamBN8KzXaUdCbdlGQDTHnQL0NOvq4nC48RM=", "H/7urk9Udde4z7cj19rtCU4YlJUyu39HY16nKQ0nt1s=", "CU1GXEE9jza4bxodLPJj7IGiWI/jeErWx+er7LLlmFM=", "IF9f3q1c6D3IAAsDIHQdQcnSxyn/Wn8M+KzCyHXNMlc=", "GXjZkIwRzeX0VuIObrvstNBvzX4x5ecKwO+rxyGqio8=", "DbUQkvtWVNBOJNvKJn+67lN3a95hb0+Hl1uXWc2DMgc=", "CpPAK/2+TBeiBQaxpcVsrzda7G3uOwsqCISkixBMAMo=", "JtS9AEf71yNpyPSDTtgUTF/yikKuFrVoGLhCubTWudw=", "F8icmA0hShJziik5zH/EJUBq7ZvpqTLgxCeZFhDAz3M=", "BJoj7pGmwHb+WxNctvkqgIHGBK3MIcjWRWMy3oBCAmM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "E/llWl8VMiRNTgMOeCyj+dI2+NMCryibnAqUY3a0Xz8=", "Jx2K7kilqNxr2/KaSRsx8kxx4CNVSpJpPq8LxopvAnI=", "JQ9L9mVyxNCJxz+Q4f/tdjiuD5JlIylYkc98dlq8wOY=", "FVwg0A6EtjTUiExCNZyR3y++HeL3UAZncEHA5wvCOsw=", "FMLGogmnvGqm2Xj7mU2VZGYTro5rDg5fXMj1cHdmx7c=", "DxK+JhGe3g/dtjk68i24OPJYE28gMf3SI9zY4b6iQ9k=", "Lv2w7cgrTc4DIwiwR0XdHx+7u1ZAvyixiAMeDLLhwd0=", "H/NIQlhbhNK7jJFRs/bGX0i4Sk40sH9gGSwTps4Ip9Q=", "LZ/DfUoiwfGVg4gDlB0vYp5p7u/FZpkJGZdNjnqpaLs=", "Ibd4EgwOsJdJcfWiTinCBAQvi1CmG3hbdhG4wOzGvYw=", "H9Nv+betzxs8+mqzF73+kRVoPalbKfhMThE/puVca5A=", "FRz0fMLoLz7qCbjWqoYDfKr90M1DqF7PX8PTFDgOmdg=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "GcjimVKrTQmEvx2pIuJEj6mRDAEjqZmlkty0c/KWVk4=", "IzMfZc9opzO16BQtr0G7LLxAssM0t4gg6ShSY38eh6s=", "Kn+TimzcZb5sBxyIB/9t9MSKNr+9kvVf0GwFeki8iv8=", "LBIdQLlFhVQ8uziYCqPjIPW7Rg0WX+2Q42fyeZzB6K0=", "IIJCfui2UIdi0I34L4RJxH1LSxFxZf9Pof+UTWO3TX8=", "C782RzcVpr/rK9RrRlCy5ItPq7kFnB1BZ1+nbYgO3wg=", "D8xFCV7Vo2FmzkAz6RyqJEbZWUkFtlK3tWv8vn/gP/Y=", "JwyOneAl9EYDY3MNeJwfPe3qM0NFeEHbUW4Sm2cMJa0=", "Hpz7Ww8d/SRl710nMajV0mtUecxrbkOHgyMeWw6AX68=", "GIT0755yPMQF/kmANHPr2lCAcxtIeOHTpRCPsgiW0Us=", "GCuJMvuihbklt0VDJ64qGu9zmwiL+0fc1nVzC9Gq/k8=", "Ii8gdb9X/AWaJH1eczs4KP7BqsaFCaLA5KjKH9rakPw=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "DvTHbkLffm1OcbU2hy72gW1i1kwGMivarEquZc5tWf4=", "BOKMWSE8woz7eyEJG8mBaYdeRIgYi3CjhRl1iAJax3g=", "LWnBpIwb4reY3XchigZT977Ea977f1XN4+bSj1ZScmA=", "GY0r9EGW+B10dhVU+AzBaero6Bf0TstYi8ZPYnfx1iU=", "E8i7tWH+EQlhKGXuAIeGxdUBWOQtnpG29SsCUItnh00=", "HrN2Ba8mLONohMA5Z7/DjY9iXggMe760v8oH4lRY0S4=", "Jc2YaXX0y3ZeSo8XcGzEQ4Z1v4q3sRBHDYjeoaZPZq0=", "Bx0CJosImZKo1iJA2U/hcb7gg7Gi2bvvzjzHyM/1pXc=", "Eu5Tz2nJoL47495ReJ0Wy+81lhxhFOSwEkTYFKXO06A=", "CUrMZF3C5pKQIvS0uUbo9RrFlfsyAAdM3iS4ZkO7/EM=", "Iq9BsqVMz1WzAws0TbyC64SZyoxnwZHUtoc7zbdjn50=", "FMhzUv6U2Sniau7cJCHFgSt/u8sAp7IKeYd+4IZBZ3g=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Ic3RUq91ERImfKWF+YsqvZv3jq57xATf2ejTQBCvfD4=", "INOdu5xRiGQLbzCr7WDvp8YUM+b/7q981zu9LXE/Vbk=", "JkLJi7m8926ztuP4bDCbQA55Bx8Sv0YsGfxhKolyK2U=", "LCViwpS2VQXw/7ZHbe9pwD5tEyT9Ltcxk2imHH/Gctc=", "JlpWeYXqIhQmMokZw+wbzPRiUW5lJb7gHR2BDBcuiOI=", "B/56LlYJCnV1elSiehVxHJt7NFFTa2HmpVGaOgc6Wp4=", "DqY/G3JYgxpPCHxTgnmI8KUDMXAYZhnlE61HCslpEIg=", "HQCCseKro113tB4/ykakUmNg6uLR1J175qRJjzFb5sg=", "F8exjY5TJIZ2U9RKdl809mU6Q9J5WwQJAKLgtMA7ryw=", "KeDKjcc8ovJbTdXHVr9TFrJb5sCBHmLC9EN/25p+J4s=", "Hx5+JiAeYZYp9mrlo8Lgms3nAENsIrH/UFKApi2w4kI=", "L714kwWVBXn3ArqHd1NMJwgCinhFFz8T4Yd1LNxdmMQ=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "KojGwDk/Vvpj6ONA9wjvr0CsS4Wy7mgdOe4aoN/jluU=", "IKMhSXqp548WpZV0kuPqBCjSJEIFZkneUtEVscc7EHk=", "HwDV2ioEmKLBNB8WmN8aB4DFFpERp7Av73mw+vMtZJg=", "FfGUoYfLpQGJGGSYSm9Sz6LUvGO6KjX2FInHDNZR6bk=", "Bc2F/g/Ax1wCf04/G8YochU5iOqgssogsMtef6Omh+g=", "HtIerxaz1mG0TfQAPLNjYYQ1PSXe8ZuwS6ypM6MULng=", "Kze16IzKINK7Q/FxgJG0D8GrDqc1D3eloM6QVwi88t8=", "Iyx/LeEc/n7jxNyTOgvQNLMsmXm0jiypZsamy864L/w=", "CXS7cFIzATYNwYH6/6SjHanImhWNRGz58dDdB41oGl4=", "BiMcF63N5ost9VEtUTfkIHtasSe5ieVRcQp8yHVi/o8=", "JpTa9dZ+Z1HDhRHVlfarUgyimdxS7qR4OhxvuvhehDo=", "LrVZYOyrq/RVpJueqduYAaR/+Bghc4G3kbVGsmLfWDY=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "AuN1yk3QYjWEwL4geGUsfg8Zmer4T4Dob2Fh0SnOdvg=", "IG9xYvXXcAt8zmmB8HSLoIaV3PpUTrGpAyByIP66vGc=", "F2qLabEqWjJp7n75ggRLmJW6rrhZOJANfvNaifk7h5w=", "DFix0zGSYOUozHEuLypsYG1xHMoLKFajDy675X1fxzM=", "AZsT4W3a14I+lwch6/x+SnxlY6fj2S3iE1hz4OYOdQo=", "Ck6P1EREit2hgLDGo//TICbwZEkRp/T/hXl9foNPs4M=", "GL4qwmbj2Yg55e+vfvXxer39a2/HKeHxjYNOmjg7q4M=", "DFZYMHS9bDpn/dyU+EDPe5ezUlbgCmR73X+ZLnMeth4=", "KKscgPjYIh3M2IGHhbmVqv8F4X1P2PVWZLNylxX2dxU=", "C4hrL/BtbT21cLIGCpW3XjoIXXTG7Z3YxPlgZat3xbA=", "CEHXRz1F53mDponIvzhAFfMjg40y/mXLmZF4TbMj4l0=", "HB7jsTRq0sKYt659g32M+Yrxz7eir14dBvDJqCarG8g=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Eeemjx3vtHNpp1etHUfqxP0S7FTqpMLzqE4rl+Vml/Y=", "I4a0LMCY8ngZcWPqIbn2dYx78eipf8mdDUizKckIaYs=", "LR6PERZ6OImxlMeU6FZruS0cYigH/FGURbsJqSwQ0Rs=", "HpmHB70TYlyVyVmbrjJh5n8tUX94gFqlA1a4peZ5JCc=", "HGty+nxHFovAwTtwryGLXzftmXfxkDxkxrAxfNG19zg=", "L1D3nCyJahJli6FEkCPwTE26LGjjJ+5Xlug7bMe8chg=", "BLFdvBgLhjRpH3Y6Ahh5FrIfapsjAwLNsibJwgsfVr8=", "I8CMd8wO1ZfFN60SMlJOf5zekiqjuay3qODuyz8J3KM=", "JGtVy5tATnEPVDASkgj9L30cO3G41dGjyVTKMm/T5+A=", "Kjx9y3+Ppgl+XAD3gfJ/iEx2xreuhb0Kcc5Tf9UDiNg=", "Jo5ut5V4bsqvA3dS0hSiQi6tdPSNgA7X8U9LF0xT920=", "Baw5UmGK8zlGbLhCjDCs/ZN+diV2CdKZ8TRtcvh+2Cw=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "AbK3qswluUHkoD8IWgmncxVPkIueXC0g0/Z3ecpEiJY=", "Is3KgeMj2xJu7cLTMWl99fIVfQUuxPZuacFzB73RVpI=", "Jn+WYe5s+u0v1OTIFAw+Fo0WIy+yajwqJRe2pImdxRI=", "EM6GPZOkeqhbQh4XyW3QsFUQQY5BxXazMXcKEL1NC6o=", "DiajXmQtViCLyBMZHnmAvJuM8ARMpWS0/32S9KBBCUI=", "Iw9ulfFwg2yJMy5o9FItwm9Wvm+3B5lYyxdXcKrDT+g=", "GDizb9bw1IjZ1wKaUKhSBRGuqXULppyKfwjHEaxfnKk=", "BPGb8Aroi3yep4dC//dZOGd2D61G1lPqQHcmtFLNxAM=", "EzYZ/VJoocA7JIbgp6GrTouD6yVAwrnwIVnD5IfRlgI=", "DWJoQBzCUJpjPc6RdAf5obVpxvnlYGMCIYPkvnZRoAY=", "A2XXlA4cU+3qCCUe75pVKckzekCJJs4n811WOJ8tDWM=", "El+IA5/34N9/Jl0JAYgJBY0+OMd5B5hcTIfHXYp29RU=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "D6If4+AxTS50hqleb+742B/V/RtuNKRWBUeH/YVFPmg=", "KVGYTHr70D2yIkWjfR3wVesQnkrHNEEn8sNdz77Y5zs=", "FWv1MQ5rdqPMZfdMWFk/8UqwUt2dD8CavutKlf3w3hk=", "B3T+Qgw6sQX237uOsMxu1PWhMpnLy/qabiDQHKX4NOs=", "E6fx9PqB2eXiTWI2EQ/TlSj9PCFvDchqDHmyxDhHBkk=", "EBnS6GRu1/7tz8dxafXp/C3XGNrOX2+LmmdjfZM6MEE=", "DGNlP8Xu98UM3n0MOFb5DisOD8ycWxb83dHpdA+vmwA=", "E0P34o7ekMmZ9zElQtD8OdG8DTxlZEC24XCm87w1sPU=", "G8zKK9CIBZGyDVUByg5BNMkmxdDZe8cNokxMcNzGFwI=", "InAGB48AFCHTSI8b7D5wpp2KUUgO6HjPz6JqjKr+mts=", "K63ZuTNJV9QbKICMzuvj48VYB7v059GZfYt6cRIXBLY=", "Ffyg0ZA14WT4/ss2gi8msH7+Ev+y2DHEjl6pzIJYt1U=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "IxbDKJhOOo0l8qJvpcjSn3YvcLZv1kjH3xJIxu3rzdg=", "FPhqRINHGWClBeQAua24dJYVgsQK1PMG7mHKFfdp22A=", "IkSMxrWBAcJmuUhJwnbAtGn0QMxWmQmCKP4pOj4VYTo=", "CemM4CiRyX+vZWIM5jqSefxcCsS3rQBzoDuK6JUWIKs=", "A9gNFOhfCevmhA9axPRnVoaGz8VqzvQlUNjYwzZ3vzo=", "A9hXppimSAFzCzwRRn0Xy4Vo/bYmy9zVpVhpEuVYwCI=", "F5PHs/dfkR0Mf0xkt056HTRKUkOHdNQpIqJF/VXPEOY=", "Du/amPxWsLLyRnq0KajlE7XU/8ork1Xei472RbFHMqY=", "C378QwL2gmOsaClNyJYGKDFyXkvbHSpujaJXKqT/hHE=", "LEs3CgUGJ7ymCyZ+4xVPBwaXW2zZ3w+1vnYWLczSk8I=", "FLNfUMTpEDo0Us3Gj9TbAmd7/p3MnXYZ72IZeHgXZYg=", "LlmBVfo0rKPssOZuKQ2ZuaoIBTn0YelzS7rOjHK/LGA=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "L4POh73neYZbTMxe/znZvS6L0OzJws3qSex0cpdtkj0=", "CTOhkxnuolxS8JYgf22KLqkfpTEpH8+AQ2rm67Ktoy4=", "JjQ5ox5ROoK9n8jOngdN9OJ+WWgzggGbdnnKvlVhgzg=", "FYTsu2Sk243S1cRgjtJr2g4MOMETCyjMbBtDCNz0DkQ=", "BJ55BEatcmI8rvm8UDlSmdAiHCeBaGoEQVGQ9StRQ6M=", "ELN3dfGO2VjcXa5AtEWyiyxEE7X/1nJJEzS8c0cCdLA=", "JHAdTOPTIGBnfgfxJn2fflXUMytWN5cAzPZO6dV9HhE=", "ICuPsiHN7EoJKgNdTkVFKOrwsxnWceYKBj9MByTNjBU=", "HUN2i/rlUokUhdY86OHD7thlr55gizGpJfSjGphnWGY=", "AyuUc2EXJW12tvhaAfOv8eTZVOqryaNnthyg2LvULDc=", "AyMbRDTfhJNqgmt2Z6oz8WGoZgchlzC9eBQuukvqDdQ=", "D0XeXqkBZePaERr0p3dSBNSsg9ur5OrEGr8xhIex6ZY=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "LKLbZa0iS1Gosk6AQs24dWk4l/1VA7x1HYiPaV2WB+w=", "BEko9VKFQ8f0UOup1Mtdt+WLgIG5jH91IWIwOhavHtM=", "JzMmC1eAo9t8tj5PyCOGSRohfUMSx6k+VHB4lOOyDaM=", "JPcm+xk+YnyxDe5km04+IkK5SiUkl0JCg12z6Wvv/xE=", "AeOPbY9jBq6t6AJUUACz2kWrkMm/0kBdvHZdGEuR3wg=", "CK0ajjfqThUqB81p3mtg5B3kmtEEf62RlKoyhJBSuOU=", "I11LQljcmC2tnLmkepYwiKWfrl9zAJPx6c44er6Ddlw=", "KwHakZn6QiD5XgDJjKyZbWURP1rxmRLLMxxT+cUjNPs=", "HtpFt/jt8kys05jnREQ34wZwu95hP6y58eRnaw0/PTI=", "EZ+BXDB2KId9XiIru7/saINPexM4v6doitr4xujBMqg=", "Bflr8FMte5BlUw1Hd/qYsEEOVWa2sEi4XK4CnLDkl+c=", "A0Cmw3iKJudJK50gdU2WqhDshG8HrtfMpJ8jTUWYjWM=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JRX7ZvgXktE/+LvdXAOK6JWgKP1VJ2RflklqyRDUTgM=", "GN7oIdCtUt1mQfoCibTKdVpwpgPGv6W9SR7FW6evE+I=", "MBXGiLKUqWV8bKEsZbM4ZbG3lVaDi74/S8Gvg8HhzI0=", "FP0k6Bqg7tiKCLTKlcCK3b5O6GHRc9zlKJqmiX2CgSg=", "GdAstxEM1h3BmRuSUyAgiYXg9k+hRdMBdTdHDHeBPes=", "BJbMOXK9E8nw3ScVqcxmt3BpmwgyqCSDNP9dITxaexI=", "BSizQeNTHZ1IsKZcXWMW0v0hzYgBrfvwBQ4M9vD3RVM=", "A4jNlc9NBJaNNEPOrcf6JCq69OylmWHPPIUO+xMZpN4=", "HmWIx+5Ju0VHUEpiVQME7U0+Wv+lrI8IuMDNDuxE3UY=", "I9YRrhTbWiY4YJyCEtKfMnzglWA4A58nDv4aEFNzY/s=", "K4bZKKVLP3yYfc9a6J196ZQzHyADgd0J0S7LhGp6mxI=", "EwVbeWl1274eWpE6WcEa4parYLvmQgLBXU1hCNCG9GI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "FPONH/pRDysDMkdnM/n8XHnfmBtVrOpKjw47TMYd11k=", "HzEtTW2aPKNo49yJErqzI2bXIEvQ+90+vFd9Pya8QHw=", "DQ9xLoVwWF4ZbKE+ix8aLJYwY/J9YkJ6+er2qtQ45yM=", "LcvE6EkgAd2Z3YAXV3HVvbswhDb6oI458ZtNwhgowTE=", "C7/VCGszovDlr9m+RPfuMmfWKDOuMBmTjEQNdWokWIo=", "LhHHACIC3s1DQ0yXMEUrjs+1Q82JJCn8iNszxjxAQ4c=", "CgTKC06zpnv597aZsXnQM5iDeS1L9IAIAq6hUxi3wNA=", "GQBL4zTdg4w8/sBSi/sfkdstENfT00VKXPNbf0Mdn5k=", "Dw21UrcEiUQnqzraGp64gVBuWSMltz18pL0EAC77wlk=", "Gh5xOxr181q0+n+b+hmwmA7iGCGv0as0RTUs94S40n8=", "F5+OkiRqeiTVUEW0O1FSACJ8S+ngCH2zZUo020RdifA=", "DfVmYmlIEowVAQLmjHHmzGDVIRK5aZOh0VxD8qotDV8=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "JC07FwISkV2DXpdLjyTGTIZmEYMs31muoPnpJp3Y9hU=", "B4CrPLe/PP4ctP10LvHeodr3JdRQX0gckIn5pqGq2xA=", "Ik8c0lMiPNh5d75BvneTC/ZRrHRNOzYrMC+jbtD2w38=", "BGN+KH3y2UeG0HWApFcBPY1UpsMUGNPz7Uz8WC71cVQ=", "LXA6rWe9z8mFXmX0KagSDqk9pm2Hfr7KGsOxU48t2W8=", "Ecnprsj7e9q782ls3UQSB+F0ng2P37IVNe+UD2jpBOc=", "K+KqqZD2ONzYvtGNm3ZGWx8yarzeGsHzu5B7NMYCnCc=", "Fqb/NHjkAIdjZtzyxBZx9MpsriG8mF8Ek7TOopSOg/o=", "LVwa0zWHILSG/yH27Aljd/hWSlRPVNs26fy1QJMwIvU=", "JwaIPDSQOyb8IJ1ZoTzxLqdROZXyJsgObrj7aa4gvGc=", "HAz9tCkPvDxTvhvtKn4nHtG6WqXzcq32cTKo5T0s2ig=", "BdALbkstCi0AZ+DRrTB4nC2uZXE11idIWm54LIuc7ZI=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "Cs0RdfOYSp588Iu/XBd3zqHnJW3vuVsZGtPYaNgJJTQ=", "Cr/6Xo0/NFVyBp0R8lrU5lToAGEC+NR1kYigcgG0O5U=", "A8CgE42s/2AcnQYx6DuJcNsUyjlfg8wYx6ZNs162Mo8=", "JsyhdLp9buP87NHhb4aLzUIoeFJSsrfelv7+pxMG1dk=", "FUYdBEZkmfoTfFJG18Ze8lTiT81QtdQ+ydXgEviaSEA=", "C6YWhvKsHMrnlGokMWwliEioZllZFGhQeHDJmDwnJ1k=", "BAF99K/LG6MRY4W/RjDpz/SVObHM68H0lCtfQ843Edk=", "FCTXDLudp6ugvmv+YMbtQxDv22wKc4nsDBfUpuOQ71M=", "G0rf6zqB/8kIirDMUyBhptPoiDAXjzdx3PegJTRTLo8=", "ChIkTinLvFbSj0m62PGMO82+lWgae4SInBuPNW22nBc=", "HSeYzxeYwn2J3l8HqdpeRVU64nc3Ag5R1/bTZbrQSR4=", "CZkhzCdvmgDkWPCRg7NZNZdAvNRT9lL8Dm9smhc+5aE=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "H/FhfhQBEgAkLZbJdqm3NYXMwRAxRc8j0eK5ItA9XWo=", "LCCipdw78KqwuHCT+cDprlEY2xFzrfT1EXszdjvse2g=", "Gl+dRNDTDK5gD1WSSS7E0RLpwKJGMdS0n24UzmmDaFk=", "JQZUn7Tx/bKQvGH2l3GbQY8UavHPjWHaFjLikyMOMC8=", "GXYagLBluzgg6kZtum81hjfzopjZhumlAkqHARSewLA=", "I/a6LK+s/2pif2Dxzm3FswpMr2T0+yHCJtTC2Ee4QcA=", "Lm8cqgYiSAZfAqrXEgz5HTqcKf9WgM1GOBRNfyypXpc=", "KLO3TLmK94Gw9TRMfYUmqzFygGl+JthQPv9nTO5XWaE=", "JxhY2BId7uA/xFckWimDhLmlWzqDWacZDOi9I95Q64Q=", "LdWClgW453vXLcS6KhLriprsRsHSU+Oo2vvOr/Us/gM=", "AtMCBKC+3iNqi0FyHsA3ZinrVY9rzppp5qk6ia8KY38=", "Km6GJTL8WYth7YxJCs5wLl6S70AxEfSpiI5x8Fi5iDo=", "Kr2eFre0gomqGc3+xyb6P6FcwWJRAq5RG8pF850zfp0=", "CEluhmolFn9cYfOIVQxJv2Y51jlCdMxJ0Tao6krvjwQ=", "FOjaf+7+PXFuuUC+38t6P2z/HvSeRZw9HQ342aQD4d4=", "DbvR1zRZo5XdszwSABjZaSiXV437Z61mDWKOOkbNOYo=", "E0JlXfY/rETUONb0obEojmk8w7UwzXOz7rWI6PIjbLk=", "AxoUG54sty26p5K1spyKfHSMXLTxzW9cBWiGEmVQT2w=", "KPl5aEKLipRDKGHX/RIxOghNPHUUiG+m7TBSHliAiLA=", "H+n+tcf3x6Qmv/AyzWoxWCeLbGssxXqHEhP8r9ZCeYk=", "zbLbnk+dcy0hfF4xFIIRZdSeWi1BVWvNU9DE1DMiTA==", "CWZCFspWXBpE/CuYNH6os2kEs4d/IVncyZmJWt601ws=", "FGP1HUpMseuhbbwRVWaqSP53tDwkTJmIo8ZY0vVkk9Y=", "IU5BeIvSuZA0fH8qj0dhLU386xoebaOBZYc99mzlH1k=", "BUhUFyT2TiASgmCJmr6PvN/xhKGVepOF+3FZI78Px50="], ["GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Gqrgi4kfWyBGwOaX9IHHDzSwxx6Bytx2A8fl0xE50ZY=", "JpO8KyN39E99jCkfMypr8YTZkyiURaeU/T+BWCTHpKo=", "D6S4v1iXSCTts/stJgOJdfScLPhAUMggjqejCuwc3wI=", "F0YCJVWDHBQHZe6usIoGvbt+LmX1pfcJd9QfDyoYt1c=", "MARDDMF2y75/M6p+rr0BhWsAnykd8FZ9T87YNTgvaMo=", "BkBsc9qa7yR1cYo0B1lw3zUTEsUgNSbQ5VuwCqyQxvY=", "J9txzHHIoi1hMxcvGbi7rw43/wdypYrsrNJehpZ1w9I=", "JanLcA5d7NbcRUS5xeO0nA4EqNH4VX4jHaUdi8IoCC4=", "H4spN2jQULZ9tf1QvkFOpjf2rFGZiXG1fs9OTbly/bM=", "BTf9B7OsB1frRxonRe+8yzJ/4A352ktLN84nmNVEE0M=", "Dz0gjkL9PUXcC/cacmIaOh9zXKqC+vDDgp5maIkhHM8=", "Ibbsh2/ttcq//Oj0OGlm6PG/0LusSI7Xw6nMc6/jY40=", "CVEACRJB27v3RGrks9HMLgD9RcclRW7fuu10ERFo2xM=", "Dxz5EvDZ6L4Yjz0ZOqkbCU55eAURw6OFO28gx3GhBR8=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HAs1JVa2KbHmTG46usSzScBYAen6Q0Of1hqDks8YZQk=", "Epj7946JZzWRIGcHWPOCqMlRqNIYa5bjZOmyIdexIaA=", "AyUp5Js3IbpZO9BZ2zT8TAG10DbSSVttMiFFbtsC+j0=", "Lb037WMN0jSuEvTD3U0Qbid0l/ecsWpxtO2HHXCHKdU=", "DpobnO8gyTe9NpZH+E4qMQvV2D6NF3ypx+pFcWl0W3c=", "LyWxZMBhC1zBov/D6WKlSrAeBjKwYuh6C/JJ+PelHPU=", "J7c2lLg+CxwGBpycwfwg26HQN+SB7yFhow9N50xJefU=", "GsqYFjlhqms7S7tA+oEshoIpSL+R045ga79eHbtzLyw=", "I/Z7h+211IEmvUK38qn4vn2y7OAgb5fYQNKNw6SWfA8=", "AtcQT6qRozAOPsk0hiKPNlewqqcnfwr/R2DQrtAsoHw=", "L5SJVc8VlHfHtBGwqGi5rppWokDMIOQM4aCXpHSUZ6E=", "EFFRqtbU15YP+vygXU+KtKwZMLIi+5HrnqrgfdwYuoQ=", "A8szedBFANGZbO/WHFAyhS1D5B6HFI2SMpvZgAP+XYo=", "Esxhd1fIV2eOxxbtlAUL/hkiFdn9dr47+YtlQB6NEqQ=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "DIcW2N7QqMUh2gGcJFlKG4WeU+hTEe+udI7JMSoGl9Y=", "Lggr5Zf84h5+1kHCpQ/qtqSybGBQy3czl5ZW2acZiPI=", "F3WEn770Us56CGPnFaZ61DYbmityoFVGkzOwuLgXWyE=", "H8jrrJpcq7EOzU+2Yzmi/sHuivlR5p9YN3dc30q9Pgw=", "DJLcFsZeX8dNFiEDdjrDnyynrWkqqdu/kTK4169AJa8=", "Hlt5Y/edK98fhX8T5mfp16l7RgWEbbTwomuuyNr2kaM=", "GRctfkSsWxs4HCyJPdMM/aCMRvxid904z+GxzE2qqLk=", "GEFU1IpsbL+WE9VKYErr1YIMUwSXSfUzwO/RaOToPmA=", "HOCT2qKrcbEy3C07wf2/uRKSw18IPTUO2gJin2bq4sQ=", "ASsHhH6nmC4ObfsbKGSsLo8E3ffXZsM77nV0kBWpE0I=", "G5bAI5ybZkOFC4plNIbg3x1Mf2Z6We3jBk5LUGi0QgA=", "CwUzZYFtnMYbfoV1MepBbqM9YMTYpSkxfimnOjqtQi4=", "H7myxQqZzXiHF7NonUbAXg19+hPFj3JaVIUbEXTCJ4o=", "LDStM0W/9FXA5GFYe3My4Z4KkWU3UiV2no27IIc5Hv8=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BgcY83qUgMCDf1pefBPrdcB/YKjYwc+f8wrhMiUSA/Y=", "T0u+o16bkAHpLWz2kLKOnApGM4LLdsW05qzvYiwENg==", "MEo7MNIwDHvNWit+zqUZQrebfQS/NG+Vlh033M36ojg=", "BibeMSTCyPBO9VVmlC/9Okbyt7/ImO6cUxPlCjgQo5c=", "CuuZRdBr+2ROMQsxCSl/A/KsACwx3qQwsqBmZvTZPgk=", "C5Jk+1e+VimM29IITTeXIDddOX710Jo+yQ8pmD8KFTg=", "F9vveHSY7lQcytV1FmMzDjeexjIwbmics92JSArfWCw=", "FeNqOCn8qibOyWVScwF+g+YhuEoerHvpp2RjggKhcks=", "JDqGdmc0Bor+dlnweNc4TirnpzwuK22+3hLdCsK3GnY=", "GfFxRh+0vKdxrbElxom99RlRncK3lgtafK8HwXAPCSE=", "H1opdOq0C3h7X/tt4k6TnsBLW8MUdc2AO7L+A5Wm7Fs=", "CW7gbodYlo8b4Gf7RYLIEGlKcgXTmsciR8O8TnT8AqA=", "C5YDYQYhAYY7YAxnckZm9x/1rMZ0Yo9G2EAynuwqINs=", "VPcrGq8fBTHq6pXQFIsFJa84H1mLB19W+GrA9+2tmQ==", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FdXeHowPDRi3qtF5J5cn7s6dL/c17knjY0Fn1NRASRo=", "Ft9o4200KZj6SBjgZcUNV1AS9CA6Duc+FV+2+cTrwEk=", "AoPiAVJehroP/iALtphoOjXVGBC3IzmqN3MhdBGvHq0=", "KJ3dTHY1KHurpR6+4lt+QvmMrVMuL1cHPdfoRlrOQJ8=", "FsOv2FlthRXu2CyhAknSaqA2xqvfqibvt8mIQbJxnTM=", "BNdgFvYSaY+ROobcB0lka39FF9PmaJA/du/6qVNR6Q8=", "DQIdu4aa/z9P4Yn+MBXZ1YSDk6pvduzv9/nZpypzaEM=", "DnaSSMkt0D1G6easWDUyny1fevXPxdG9kg8Jc3lEPpg=", "GJ1u5KW0RZR+DvoRaQ8YbpilTT5kBtiAt3Bvfe/hZ9g=", "LZvKxG98qUFbE3Wcm0ytQqETvBlWWgHLiJ4dLWmMdtE=", "BoTC5UK04MWafwOm02E2ml9kIakbmLH88KwbcUTmMbg=", "H2YIvaIJ8p6i2cffOpJLZhqmFOH+A09v8ewYu6ehTzg=", "IDxx+51PGIGEXyWL8S3mFT35nTX6PajNoe9OGN3Apl0=", "K92sVyDKXGmnJ8Ap5O38OT5BFfiYudqFbwZDIe6ON/c=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "D0FWUKI67XgpNqMcwzGzhWtkdo3JspyaaKiQSgiiNmw=", "KjJyiWli59P7ehx4PiStFBeB/NWI9M3DGbPerKIfee0=", "GqcpSQ9pdWj6jMdYfJ2SvRlhDYcS6z0xoD7pplvUQ9g=", "ECrvo8o+FyKYDa5WQSLqxu1LFTS2XW7/5VA7YV17dvw=", "CP7GFt8JtHfELUTKzqRcGGRKaMWRg5M/H7Z+yMRSAIw=", "BrWyZvH75OqSN6Ix+MKOoZcjrbR3KbaRO3r5RU8j3aU=", "LUomTnSLSZ2XszIM/7VmSK9oYW/XO9KeEiXixFwRY7Y=", "IiTmWdHX9VqAQG0nDevwkvcT7sZ6oAHrUM2LFzp2aYg=", "ICYOwloY9JIl86zPECCAX1mC80tljFU/X3RNNg1Q1XE=", "GmkskzGauq7AZmFvl+FMHVEehpZVF0llQMwDkUkLG1c=", "IYnSVdnKgorebO+G9d5ib8JomQTbQCphMQZrQWFsI8g=", "BDBZtoV6/6hbkNhl6xqakfA2qr5aEsmgPorYeTSZGgk=", "KjJDfNqmoyoKPAYMKGWrzYzCp5utfvusHLjN7OQSvnU=", "F0YEbtv0+uIQo/AnO9fPWL6rukwhCzYXsDD3tR5vj0Q=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FmNx7obAjX04pZTNcAEeoezQEVQAfVVfzOV5bf7DnjU=", "IviSE6BYDlZWnHMSjIpBNRtCEG0R8ItvkA+MYeiePt0=", "GzvPYyLeQIU7Vkf5TOr6SxCd7FHIHNeji1GtbZbs+o0=", "L+15x4KLX4/vx8c/MS3gc5yaIIHkMs8vYnMaXwL6Fso=", "JD20Zd9dbTSt5Y8jOCnO3TjftXEB2ihNQiB+tN9px+o=", "HUnBC+4HmYxk+sw3rlDc2RoXlmuHMfLRo0s/eFWb+xQ=", "LXxKdQtwAKKW2lmficTqdynPuFiDA3Mz4bRSau05fOo=", "DU9NLdB220vWesJ5u1GCaoJ3QpGNNapSpcHfejrF0zk=", "IokB5TiKXBBTHUEi9+B3J1nR5NAmN57BZnb0WmS4GO0=", "ER5/WnRtBG9NfBny+0nDElW6BF25iM3ez6DkFy/LLW4=", "FZXwL6578rMoaAvAroBRlP6e6D9P303Q016EqymhIuw=", "LSLJ/oH+LbZPO6XLrElX+tofDGpqTMiD203ZItNZBu0=", "IVh9SFsmJNBUmm9d4GwAntBsW0ggHY+adQxeWpj/Ga4=", "JMM+IS5+nT+vDORKPLIRPnT/t8KLRce0zrpcHWlEpk0=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "GH9dtSZXXBgOityr3aNOcBRjv4sVlhMMDGuBXfteeiQ=", "B17M+LDW7LGE4PFoxkQE5Q4BPODfBr8xy87yQh7XsOk=", "C/L4KhsU+IjEiCLhR+Myoryvd+uzLXyzzd6BPwsaNz4=", "H1h6G+NhUi+FaNIQngmE8FmocxejX3zNc2XF2X1EfmI=", "JKae/9qFLH0g+0/Yw/QT2xtv85eUCeg5InicyllKRi0=", "LOZ866xrwSrOhr7OcK56WlmpcCPKtts1oPjLcRBVKtQ=", "LvSFL0+nOwxAw3EY7iaQaS8ecQGnijh3GoaG7NNwI6E=", "BOpJtPIiWly+U8FXxW9ilz85T9swdpVLu98weG3r7f4=", "LodNA86/SVeC3tME0fN5A7BsP4NPFw6W0mgSvg/1JGY=", "I6ze+6nlz/NEshJina5h524DqKjuzvTmwFiCd/U9gfo=", "EXOAjic1S0v6dta9kgz8gwnx6emfmX93MZUHCEPtoYM=", "Ka6jEIRbSlBeo0ky57wqjyuTbEf+xfImmjyZlBPQSPY=", "D1U25EILiR9MyCxQqDOhfwyruJw65Mukwo/dXLAuPSs=", "ejV28Ch7KhwNgyvheNQ7aFikyJieMAQcwUPwniAS+w==", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "CiYNzZjiILYcIBLcY4D1Kt75ahHTjnNxxXbVRWP3v7k=", "AiQCjBWLS0rcU66RPP2epC5EVmkL5d2NTEWXeZRRV+Q=", "FmFRxD5DNzRniIou1L2vMUjY6iQy2ZgWL2L4FZzsaQo=", "BVb57Dm6S8d7GDz/AGoKWCrbVdUt0PSowfFWsziYsos=", "AgFnC/bx+mIFARB1S1Oz0GcQhhVtmJCshfQMaapKopc=", "GKeO/HppS26VeyCcQtYESvMZ8ZTcFkUcbaJ4AufxyFw=", "KO+sqnmgr1+p3dccxqcRYpeIZkhJuW/wtCph4uQ8h98=", "HQf5CLKsd4Pw1zTocaQL57LhZK/ohdtv0xK87PTL6as=", "CPl/s8xkDQeK89F8Vp83qev6b0nEjbdLPZSKhnXbluQ=", "JxjnKelA3S0mxqb8feQLiZJ/jJ3wMs3MBu1OvhlP1ZY=", "LGjqQSDlq74R87YoARmc3YaG2+zcUsqKlFi6SLGapqY=", "Lzn/r1Sky/AICf9QBHKJUwcyJ56klgfud5+xSbh+EMY=", "Ew+zB8bOxgmrfF+b1ZEKntmVj8EeRDcFYJ7zBmGXqac=", "EpocZtHrXoQhHEgryvcHiebVzEc+EAHfvaBZN597WOE=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HP+XOvIdiGNeya+//YWxzFlXA65b1fT6purUideu6iA=", "J6wNthYj8DPdEC4RjUfYR/NP4RgmvJ0j1+PkM4atFqk=", "Je0rIrWe1Lrtj1yVfK7R+1JjCXEJLQrzrI/+X+OhOQQ=", "C2NMOr2a2OGy2oShRCB8Td62LI9IYPZaoiCcHA0NfnU=", "IVjqzaRQw01i/m7V48niEcFw9MO/QkfFyvC54jQOQJ0=", "HA5xWsZNZFNfyX5NhrlcYSBAH1wmlzMrHtap6DcQr8o=", "GkkaB+4d+auwKqMAZU5ZvTT1k6FbdDBrQcBOi5UwmGo=", "FSPMZIGTHoVhGxhEgyq7+HY/q5yFEw9QqzB1+k9gdi8=", "KBaSbBKfXJmpcHM1cdXAG+HMGOwPRbxeRgaPDRiLyeU=", "LZTIHicfuYANMzIjoUHJ6QRHbewfjx5tIk7UlGfhih8=", "G/irC4zv3u2sQXOFmdOMyu58A5FDZOthe1Qh6aUaCyc=", "If1sWbD0F0U/Kk1mmFE2T1FWtq3xBGJfhXaBQRvQTGQ=", "Cuo8UK/AgGsReqmMEESZtNhL7pZqlIZYlqObn468uRc=", "Kah5Xh+PHifn4EsjeIrEDhAlNtVrV6qF/RAVzCGXD1U=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "F+Ssfkift9phBQZTW84EGGQmci/iSiYaPiht8vNRmzQ=", "EK5JAeRD73ZyavzPHJCZ/BgAH7v10UTtchGWrJ8swTA=", "DmD1iIS8JSCEyToYtP7/JFF1cnwDAD8CUQDUNaDeu2A=", "F94W2jaSvTSsQGmYKh+xY9oxGcwB0SxvHr9k23h97Kc=", "B40U829jSdGvbZKvyN2YrnMi88EZk8WaIlsHnHrL1P4=", "LPw1bE9geB48yDR02nRge5Vn7ToIzdckL/7Hb302zsw=", "FTFEDbVu3VIcaP0t/7YnFVEw5vOitH/eZb+Hhc7qEE8=", "DJ0lsTdyzaEWEH3AxP6YGLdPJKUfS7ylpjvE/GRBmWs=", "KKR1F1VxKz0z+e7oUMzs6kfrvDKh/Rmfwla2nARFZQA=", "HrAM/2gUPPrTdqqOyDIWutzWZNVemQyy1hH83aUuRAc=", "G7zVKMxm63aBYTVwawkOo7RtRfDbCK+WLxffTrmW3uU=", "GaQd99rgUrtYIapPMukQPf91K6okuftR/L5DWYJ/jNs=", "BvNP5JCt9KB/7mOYo56EoMMsBCWclpHaulTKS/aWrF8=", "EM69nJxLlBQlYZqs8kQZOA3/3Mf1Mm52bTjnKDi+MSA=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "IUrqKFD+1yI6+ApZBgUhWcv9B6MHNq5dlea2DLSYnRQ=", "FVla6kWvvKsdTS5zwKNsrp0vtQ02zf1cDBJ/lYYq3Tg=", "DEBVuUjEqf55r/GRkNqJleqnxTeiDN0Y9bylNx0MiV8=", "IC3FbWTNTdFrouUHgfv5N4A7zK8It7qHM+rbQnwTmJw=", "LvQZG33rN+ku3Ub5Zb/MZrxahTmVfzGZWNkQZsP+Fdo=", "L2lC6RituxkWAKUX7bSGzJbjVXN5YcheDYWV7PV5VSo=", "LNYLWhXzeHG1UtgJXNim/68DO1Ode/GuX2ceL/y58s4=", "LgXERUnBypmoqp5cz0cmJA91pAYK2KcQEt6yrVVIavs=", "KbUvs9V+4FY0soZOeyl39zk5BsEukDkxUx+VxfSuCPg=", "GlZb5U070SvJpGoeKFOhjtJtZ0TJjlz1PIPmYAzFamA=", "DIBvmsICJeVOov+CxzxoCUl7RthdUaSwXEb2Z7s+1ZI=", "KqyLEnIIXHmGASvFx2EtW361kzqRQEmDWbJgEWKQBI0=", "HvG5Pl4MS97tjUDXToT7DsXovVKvPs/qpUEF5nRhGjo=", "Gh/jE2haJHsDzJq/DwyhM+oRmtAe9qCQuvd0SRoAEpY=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BpQoel1sL4x+atiZ95YOoavTqngpQipmvo6KGta6/As=", "KqG9SHji74JS/0LVldLQtZ13SpjjQ50FaCzShGPhUQQ=", "DsuWiFbZyKExfHVtDkjVscNl5ur5gJidPPd9EQI3MU0=", "CKlQ8QeSVKokP70R+7TSX7DLigw5vqcaOqHA34CUOQc=", "LKRBqGfkDKB7UwpAuJkFJCe6/RfHox1IQYj5bqIcrcA=", "BgEX+UBr3mtS4K86VERP6ctpvJ7yJAXiuF0iMFGFLCM=", "GM+/EbbCC9fLj6Z/9MAyw5/Cs2EM2PkLyj5hNsawT04=", "FK3fLAo4xgHTC/lqgtP8ui7jabDS8jKt9do+K9KXCkM=", "JnfYfymiqUjKfo9aU0G1aUdWO+SsyXxG5Vf1xg64REI=", "L0IxAMLpmIts9em8sbKqwJ2SZFi58Rd/hBl385EJwew=", "JUkJA2m8yiV9omBpQmW5UcFWQ8gQPJzHP7trBl25eag=", "IFwOZ4nvH607jxNnz06xmbQAsWSZhB4f6sHPt3RBLZc=", "EWoessr1as9zCLW3p8prmCJMk6ZV14ynhno+4XCzP7o=", "AxmHHgg6biz6amn0gBIXh6cYU8TG93L6ud6i4mfzV2s=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BbmKU0qkBBuwx+ea5rL1wWQFO0wKZdun+jGKWuqNIrY=", "DdW7zc8Nb+memrR3SRGjBJV7Rh4+LYCXddptnGb/LPg=", "DV4T53si7DRHrbJIfBWkztZxB28NDA6OvJBy8djje4c=", "IEaLbcOEsTSkU4wlaDtGjId88wsTIdx8OeD8lC3GRFA=", "Div8E6wGXiUcqnA6vVNieDlB7QBg3Z0bgfUMYw3Kg3Y=", "DzAPJ3FloC/xI7MHjofmJR3g3pPdgeduj4GXuUmWDg0=", "GezJjDMdi0QEAOWnHhyi+DBTaxkAWAszSPO3zpP3Wlw=", "K2DiAStnCUTOtQvhx4gI7EVox8RCkzsh8SXpzfp+y6g=", "LD40dtEo23CrqJKkbCBh7yTfCsdNsATncxsWfzJpdFk=", "LroHAcyrwKsphjx0yA8es/amrnl5Ikn05PvsY7YoLgw=", "G4IeIDHM/vV4h46+NIHJtdueffkpdVuYBZroR7eHGh0=", "EkJORbiFBgAC9mEY5Iepe7sQypfuBBRxL4XyFUpjlaA=", "It1VZwyRNEAXVYti8yxTDvDzOHc2UUr0TNQ4EsPDgw0=", "GMYHZ18KmflPLnsWHGk0cspZY/cYI6Yry0VFJJ7RFt8=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "LRajLVyWYxOXCfBUFZzXz2+TxfkTMAe07I3jmDIxvjI=", "GvLEF1/xOkwnzfb5Hm7i2B5WpNQtbBP14bQdj3Gphfw=", "JEEA/J8xrbTljvPlbC+jK1tTTUKiJogNeOs74gLJ3Qc=", "Jfq9I94iAJuXigiUFN2AWDfMDh0taPkZpQt+F0GPIVE=", "IvMtQ8NfXLM6hXrAbV2Xd6QrkiaPDAaybWj3VCprUOg=", "ILRHiPUEeBqZUeCbSX8cHC0vcjuGS4TnTBUjUn9I+ZY=", "Fxkt24pnvSzLuUBTKttuN2dZgA33QpxF5aCTFOZM97A=", "EWtmGbQMYXL1cmUKlWbtK4CRZLmU44i2/EZ2N7Ycwq4=", "HgEz8uStvwiTipzMgvo9NpMxaq2jsFL7Au05AOHXMK4=", "FmTH4l5afS8oUVbe6Je0rwwURqMuV1/OTVajyrI960Q=", "JRLI49fVJe271LsDOUvErnrte6te1Vzj/Erq/DKbf0k=", "D1gAFkrLZ+0PbvxSe7zbhR5mmVyd0+oYzdm1Qln2S7o=", "Hk2txcpy6DpvVNwJfwwvctUG7XfVdqvOgAhY1IzbnMc=", "A5iyrYeplq7I25gBI+/+v8We8dNb4Oan/ay/OSlVG7w=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "LjUf5YtfNjid9sU6zhpTZtnAEqLOLgxKncswz3X1mGk=", "KQx7XnScFTK6NkBhq7veIicrYu6Q/xm+WBxOpo9YxfM=", "ExP9PHYTBzENMPWqY8sHMyRHljUanGB3q16jQ+mWp3g=", "LDG/037RarsVg8QD8J3SoGTk0D+Uh6B29JbgyMXbs6w=", "EMq60r7/7NHXNbcoQDd1OoWEXm/VtyR/O0V7qcyaMj8=", "DgKpbi+uxz6RZFj5QJGYWaFhtrhYlKvlrhRupNNzbRA=", "HW4JDwrNTaFDsj88zFZVZ730k1OzQWIHryCWOJt5GwY=", "BF9/FofWLqru2/4/1PclyFF2loBpr9gV3aV3hWOuGpM=", "KHStLV/zTYVEkNL0HreSldC9m+/dVFgLJX+08tocubM=", "IBiU4PQdLz8hpmQf+eOVlYSnSWSPmMbGs8PcboKFI5w=", "HlFAnc+BvGYWV7bwysJ+3qogm6/7DIYv3nwNBhBQa3M=", "LPP1SallHbmRp5jHOSr8uM//MHrzOM7ipQHcG+dAWYo=", "G3qo81okiL2h1u5BaovgUDWHL927lvpWZF0PY7rQS2k=", "GCEy6tSwX54aROdCLak7Hg6U1ZBqePY0ac+hsP/QagI=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "CGO/ge1WIVn8kVtii7duO65mPcEFVtrpzUMu+N5Qtvk=", "Fuuas2ySwZfJnD0R720UaanE+Xedrtvpmo5fJMj1wPs=", "Kg8XKOing2MDeNgfFQnpS7mAOkehEtmfeljGCUPFyX0=", "Ags5Hv6CN5cBoPhq9W5dIs2IH5jQrEM98U7ZkIgctaw=", "BYalLL4MWooMRUQPgNx/xSRR6BXFsPeEuyXwzjGaHAE=", "BK8mATYMu870kWJojxNAny+2Am9BN6C5+F1OInIQZ2Y=", "Ca1S9L4T7meFNtxk0k6wGdoPXPs21MNbZnx+9Mhe2AA=", "F3oNMYtcCyJsFa+g69sPPVgsr5Nz1F5zwl6m29HvDo4=", "GtnZnedBfOw6XYMeiozE1jO6dwEE128ZdA+Eg0EbyDc=", "Bp8k1ZxNvCNR7e83poxeATPaYOr07IXMF09VCeRnbyw=", "L4eoqKQhCB0XSA8DYwiOZgR4BWLsLZeqF4Cnvh14CPE=", "LCMYdF0Unfu3lqrtUASCJ8sBwYhasu7smJdCPYJOZbw=", "Eo7FhqmOSf+7KpjgeOsStMUERI9Tp8WafilEzmY2rAI=", "KrfeCu1eYwKHPWzw9kLsvPS4TSY8X2AxbqDkNPUY4nA=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BkLnhoON21Obi0gdUJIs9qy6gMu4zXTZFVi096Wc/kE=", "HgK+wlvVP8xr7O+iNKt6WR4U1+G53e2Qob+L397hrnI=", "Jhorr0tlVnX63FftKTaegxo6I2dod5wmNAAH0Ejav7Y=", "ELVtXM3QvlORxizah+ympw8S+EZatABMZ0K+r6aa+tM=", "DR4TcQ2zkjDldgE+WzObZpc0m2ECqRWZNkiyCXrSFtY=", "LQvQddYiqf+u/GmY4dOoRawH6IJ86yfaHref82OGvpE=", "AX+EC8Vm24o96+rAh+TJ1dsH5OzNCHHAnFMU+pNSQ/E=", "KZ9L7shvIQ+ifXGPePrk8tlKfQseApySuw4zRWxXJQY=", "Bqp9sADz9NkVw1CQrJsakLJpyNkOdiaQU779NLdsQaU=", "ENyJzg4+ExpZTzvZChJYZimvg40t182VZqZnhc/HuN4=", "FOSxzBctI+DV/H8hn6Q/wwG+jYcC3BMR/Zf3hNDR13M=", "JjkJeKZbkX7K4CQq/8RQ+RxGSRObEyqusUBrd6dRIW0=", "Ga6/o/orTPg289n1tnKmgrIPgu+cv48JJgjCIyfxZj4=", "KRfWy8d7unOI2MQyeKV7r4bB/FT79X0NyYUjhnjEBKQ=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "KWIGG+86C1V/YKOvjKC05rRDNjWbv8nTAUlDXe7s4TA=", "GrLjvYwDxW0wNyhnoppQF/yV6GjCKMRW4xjrsqfC3nY=", "Dc4wce4hZNRl6ILB8xmqidFp1CFqKzop3KDXQkTDal4=", "HH/3doNYnbHADlMD2VaIlMJAIBdhtUbSqjjmxjgxpMk=", "DaOtkBbRQTIO33j7JC/DhmYvyRg6JQJC++cpl2Ru3oo=", "AQjIWFBoAvl8CooAW289DnPlat6D0+HvkpF4POvrAQQ=", "GKBBrZlBV2ZTXnNdNeJAbZn1AFB9RMEhGUq11iuz3HM=", "CATXiOzKZPzR3G65WU+46RtfyQJ8LgVCNp8qElsc05c=", "B3MdFllGgbeS8UOuLvE2XpTH8P4VpHKinXGu8XYJYeo=", "K/o8uQ8TERFGyJOFr4LZBRxOAvc48vmW0qXx23Euxrs=", "H93NSxQpE0V0tPZsICzWOkIUWA5lTnOez7+j/Dv4tB0=", "CIbCWN8CMYS9fJQsLycxQINNhnuN70mPsQIYr4DWZCU=", "GcyuHbGpMAeF8TRwLTscjRPZrIe5wgE+UoUgnLgE4cI=", "B6S4FV63Y2PgXl8A/5Xe/L03uUr9kBwTBFl53LY9atk=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "EVJqyDMcD7bdTjQjPBYwc9gzAGKSiGNHEzWbLc+vz/A=", "LuW3zcth9ZmI4nlDEhkriv3dj4+hz4g8mY96eCiR3Hs=", "AriMNen13CXdyBvCCSFriPtSatlMGJ1TAMlHbQRFQmo=", "GUf/68OsSsPM0dV8769hkPHBA1vFuoRwbczkTZcG8bw=", "CZ+Mxk4FAzVOoStaZ4FD/XTxtNaWVMmourodWBAaMUc=", "Gv/9jQFweZ0WJGJUmSHzxzRNiifupVtPk5fFCfWfDoM=", "L81SOZVJNUhvaFFLxMuzAoKyUXG7kiesls5eyeZIZzI=", "LKKhArZWGuZduFLaIsO0hvx3xqL1WDUGcgoyijrtjiA=", "EALcWL/sD9hTM/uAWkTqqhtHiuJTo9SldoFZDQtS3fs=", "E5VX9f9mTbVNa+TkLgtPerkrR9nYHaEwckA4UgB1kgU=", "LInFyT6Q0KcDnKY456HqXLwjWOYQRLagnRA8/JrE2cQ=", "DNDXnFtMbnh1tY8sYZ/HJ6umPfmRyZ0lrS8kvsoN8UE=", "GEs4VmlZXdj6d0MR5ZsqvgT1lUZob3T+xwyVFImYlMY=", "HPPlKSr9EKkEFHQe0yhyY/SvlRW4yuf0HUXkEJqw/wY=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Audk7Zx7zRtPemTxr9PvrVR27s4MvFZmF8xSvFGIXP0=", "Lm6xi3W0kIwGOpIEFH6h6XB3kfLG/SAdCBcDtM3Jfds=", "FyuZ2EGf4IWDgMIpXRVscRzPhfFQ7UkX68CUKrpK6WE=", "CGTuoEmh+VEJSaEtmm50U3s6rJ9nDFDU9Lt3p7aNc/A=", "H5p3LS+W3tBmEVbbGsC7t4Ka083gw+Y7uVpaR9SiyiM=", "DnLOAHZQDEmJlKeIeXBHQ97xO4ehx4u2BVdZhlLoQFE=", "GDypwzHULhWBjg3Z/kzqmQeODLVAE+tZb3mMPcIsTlI=", "DPTaV7mpwH7NFCeytDdmS1ouiF524esI4jTHsSdhvro=", "DHrrGVcjnOvrjD81+Uqy/kQyNNiLmfoad8xmlxdBCjA=", "EgIY7AawcEXtawecL6kbaMq5yvcv/vWBbEu3fLPcoSQ=", "KQq0rLsgyTz5yZ0Hyf0xid2KOVkoz5vpOFfzvnpNz84=", "HaJK9EZRGuUpcvbLlJDfX7XvbwQUtRQ4D5xkWnjIUR8=", "COrfUckF6Cn5NqKmh4akXAkpawZO8HZLWeBTmPdgHWU=", "GbclI/Awv7MR/ZTGbLINEFui8f8ki+psO8MUzUVYAF8=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "F38LgKHeOrVuJL9PjmO0WzFoXh3B2l4wVT1r5IK60a0=", "BbB+2YbC32ipekDhwifC9y1VICcWZs1BMmOUciuZMsI=", "JNLD+JVbegaM+ae/HNPMH32t2/Kpm1gfOvSYD7HReJI=", "JYOCmKDMS3dLa8idySP50zBZmp0SJimqlu0lG1vxC/U=", "Kv091eD8IfDZopJq5odF6Me9swel55DqCIcuh4zTvcw=", "CA8vzjurYobhnZUPM3LnjUr+ItKydXNzJTtCSFizfm4=", "Ka0V6ggJPYHXTG/vnxiu+hppFe6wXkf0d5yMRLsXyOg=", "DgBEUQhQdeQE89qsNIGNuIeM0C8TRZKtvtDMCBhRWZo=", "LBeT9ngtODeeHh44Z9tXv1FDIMDjf8KWHlDOLNOmHII=", "C/PdRr6IAOwLdFLGExnCqjZTB8m36dlVqnqhBX6R2tM=", "LcdP9T1heZKVlQs06j2vcGoKzW1c0qt0YexwbboIJAI=", "EtC/i4/p7Lq9yUZIVPnff8mVA4ip9ov3kgrrtfAoWiw=", "HpOWdjR+7uqpbjwL1R4UYE7NlzNvcusFTGH6cTCeQ8s=", "Clw9sGLr8shMOEWIsOl6DSQx9zNOqQBkNvZ5WrpkI6c=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BBt1wVhvBmSmGKvC4ZIx9CMHYfu/kHRvp+wG1KUXMR8=", "IC6wDt2ttMB2GVMlUZXuVa8yygYh5AinPuyW8IDwfR8=", "8MvQImfWAbkaGmLl1UJG8HszfoRmHJp/QN55+FJ+lA==", "FPLCSBOQWd/p9NlwxmH9F75U6Pyzp+LPwRYCiKAdOQQ=", "G6LF+V368t8YmF9JsL4cGJK1nfzeevz1U/veQcI5cYM=", "DgsEDowEN09P+cVOauHL15z05GpaMtZErjX5W2ySRUA=", "A9AX2GsbYtppmSCwjgvK3nxsNl7bO5su0o4cxcNzUes=", "I7eF1pBeFC3F+VWi7TtPV8DxjHm5WZ0fIanTcNMjKDw=", "CGCxzLmAJmtcmADVY5QGHko5uysx1QPpFcjk8meKZsk=", "AeMJWITo4+gqQoLTniAgzT9N1MFN75ihuz5N+6Tzcs0=", "HABj/fIyx8rK6q8yQ7Ss2FEfi3hBKcjWp/uspFR3w3c=", "LeI0Vx1FUCO95ou64ftptiuAuInIyAmb6yWt742p+Hk=", "MF5gl7GpzQdh4IolCYlfLW6/RTqn84Qb2XgJz6mkZjU=", "K8x7c+VniOP3BWW0FoJIsDIfZdlBhA8ZnKhJQCvVKXE=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HUN4grVwKMiMaeq2RQeyZJ4XBes5ekBpeBrBAVHrIlg=", "GvGjaq57GB333b+zTjSlOuQOhSnCJOyUCQf9vPl1IuI=", "J4VRYSMyZlhIfO0qnoZNKpNy30pIDZaoEPOuEkaEClA=", "J9R24sF04u7LeQ6dlqyvGxfGdf2F+Ekj8L0XRKD3AM8=", "HrCQSZ43AERkpe3y7u3uxA4sK+zbMUJpkvOCoeEZd1M=", "CS/oSq9sG3c8Hpr6h3XbAoSKhb7URNQTPh/KYBxsaMo=", "EE0Wy4Fuu8dgxLPij+jBiu2XLa3rlIlqIxD/nWHUTjs=", "L6OH9rsG8dnNLni+hChqfVjP2HDFwegxUjI2HytEzQ8=", "F2tk6sQdreqkA/ntWRDxGkGTcv2Q35O+0kDI95rlxVA=", "KtdroB6U97uEEvJxuS0krS1+/l7tBrCFLY9Tp3AAIrM=", "Goky8bTPrJKGzifeP66t36BzPQcmEpejjM5jmdlvw44=", "HqpVpjVFhtAIfh0EKFn2OSfPJ970SDCvOJBePYdv/RU=", "A0x4F0IfK8IT/Wys7ZXxz5sXZHPochoQCxtu70NIt4Y=", "Ax78Mj2D1N7O7wZ3Tf55jazExZRmZLBDHVTmesu4QP4=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "njiGyQAp/iYPSi/sfS4cmg0Hq+eeo1mKdYrWPCDoBw==", "FSXJWuCL1ZLi5CiAPU5qSTAWpHlDSIsCp48tVS0WxKc=", "CxARqQpFLuOmutiqnkiFpiRy2il3HruYzucRe6Hw53s=", "L6XKD40sUvsrRXjh77bhp3//0bxSWAlibTU1gzxQAbs=", "HbA5fk3dAsUJzy7SXfe4Hfxa5Im7lBXMtxJ6IF0+h24=", "J6MBL6bufBk+zm/XaS7pa45MiXl3kiYtuNbR79dV2+A=", "J04jwsCXNz6aDZUvNLcAIOIz/S4KZ8TiByml/Bf4jA==", "Cu9TSC5+HCX7ZkdW32rmlQa15673GLOxSGrsZMQHirk=", "BFc2XLaN9zlBo7qA7a6fJaoiUOY83To7hrAxzKITTYw=", "HKJioZe1QCrQZA6RlQgXajmIUZ07z5G1WTD+0fyJ6iA=", "ITHCrk32tHnc8m7YGh7P1H41HX3HkO6Qbbr72AOZHEw=", "Fiv4hkORsSorHa/LZY+5TL/JDgvd8ZnLvGZWRVADaCc=", "DHovBjmfh2a7wxOi8fvaBC7KS6hXNLQEDbJ89KwejvI=", "L5+g4zIOmsPPcC+HULW9HHHGl6WDw0z0F3BnODFO6tE=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "CfkzcmcVYTUE583IcA+sZK/2HNGJm0dUJJt+Yb26GfQ=", "DrzAOwwSP0cb8uV0JiEWRPAJiqw0fIH9EmIccYe7eH0=", "JGrtDoX/ymUn158uIjw3tdffApxS04s0C6w7LT4iV7w=", "7tHgCrWw7L8zftxj0nz8+RNZl/hg+WvvxBmMVuWccg==", "BN8aSqVZkiRc6VXTJcHAioQfcnuenOEcvlSDXVdcVv0=", "DV5Zv5/ndVAjqvNEKYRAmHeGVoqgaqnQP4oz9wsif94=", "L/5W7QeMvgdmf35I4aNg1HENBG8LtREw+bkk7uAdwzI=", "DRPtQHUVmymk1P9Pn9fXaPvSjdRIeivfKoE1QL+5mQc=", "FzUSR3y9bSppgBFD0ef846bOec/jvCouvu0ku35mcqQ=", "DL1Cd71zchnYc55OgYzs+2ZONpeC4palYpACCHd3gyk=", "FFiCZP19H91tSuPjckF/wevX+kNPuUX63FXugFuB0+A=", "FKzQzGYFwMciodOZrVQz1UUGFPwyMdWvdC7Fkmw153w=", "FDINjLE9zAlnDW6TgZtp1+ZlBAZvkJXtT/JVZtOgZqA=", "Gz5HU3qJcCapieQz+3xOumIUShB4FUhXfePzcENLZXg=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "AmPUJMiGQX+basHeDiwbsuMrhw/mcbEeghl2DRrkrQs=", "AVRdLDLd0eHjcQOt7rEW4JJ1Yk6WT277piZ4fqCxCJ0=", "KHGD0kb1QmXSKDtbrVxNxP8+V2UCXvtkPtkwFcHeinE=", "C8JKNoM7ZMyqMj92ItG5vtzCBL8Zt/g75MYrh3Gi7O4=", "KsX2Z9NM/DzICjeIQCaWAJ3Of2GtNIO1TeMkbPvb4WQ=", "AmnslZc7ANP5YSXn2soiD369a8tvCN8tOTAbo2xupPs=", "G9px1ukA55GW8SbN2wQlks4bbAwLks19hru4YTwu4O8=", "LdUfogRadPEOhrgwEhD1rPe8+39AuNmE7SOgDjJoIZ4=", "CB+LfAUDCzEOxa3+f27g78DES2+suHAfsao4UqqinbI=", "Es18krfvx7UIEK1BDe5RHhN/PJleS4CA6YkCxchiRS8=", "IiuZFndoaGbyBZ+01mvRa58//1tl33x4J0fcC8ff77k=", "Fx8+PCVi8SCYLH3ZA9e3RmXz6NCF45jfxNf3OoN8Cuk=", "G3tL08VuF1GLhQ8G8VNB9uYQJUtCDb1IcwMMDzCcPHI=", "FshLpsSWI1LTBz+++pA09dfRA1dz6E6kenC1z2FccUc=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "A5KLfB9SNKPvTK99GbgVwM5kqOiQby3KxDpa1Zwk8Uw=", "JU7Ity9S5EyDc0tnKzO2MOiTHRUi9bJcaSc3hLmXu0Y=", "FwhMHrDgzm5LrylM5A1bJMpEsGzmVRuQ2fDvelyvQzk=", "DFfKkKzuFiT5MVJmxIxlO9REALlCThcpU/BEM4p3sn4=", "BceqFYSLUlDv7PLu+4tnWHUfDmntHs5Cb+b4Vma2pac=", "Fe19NzOr5cAbyUkeCBbRGuwQsNv6qG+0cnnXoUSOILY=", "L8yjPngHB9uEEC9qjx6aZSh0hFdpkYdU212Tb729xdU=", "LSO5DJlbOylW+9tkSBle1EHnF6eJXcHkM4FbmoB30xU=", "E403xczf7+BE7iiJS7Qi8p6fOGAVSsLd79yQC9Wx4u4=", "CAFYf1Y3vfJTKYvbjI+lVrulH0DGxHE9c+MaDw5yzm8=", "I89AcVwmCHaiTkO1wxTCoczhbh9BLrywkW8v6hjliT0=", "JzPVPfLM/xbIfvx0ERTjnruu/58SugN2uTG0AmKcUlw=", "I+gB1fY16a8CLwd7GkP4d9tyQQVdPHG3cf+nXPbu5K0=", "DQlP6T8r9M1K9h0Qp7/isUVpLLlDN+y/+ckaqI/8+JA=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "CTtA7+bAaL/eTAwZgXGmDkluHYNMKHZcmv2gkEBeSlY=", "IwWVAVCgucLK5xBhZhwYHBprPVyHmAuRypWUUOXK0wo=", "IQe6ZL5ed5fe8pvXK3K4vwsUKAYu6JAqqljwZ27QOu0=", "DtS5GwDLW/pZTtXLV9cDQkqPLdna9fVPb/905csBmNk=", "LH3wGmpwERXG0HdW5OA1n/UZG1gwDbWKqYzfPJhSUtE=", "BdVNI/LWhODGCar1bOgW3p1YcZJLpH6nAliFZ08r1BE=", "JI82fGagWpOtwn02rMns2s6sYzhcxTidAajXvtk4hSU=", "DvcXsUjiiRlLMy3sftKsgkMX5AvrQNdKx7/dsj0rPMk=", "AVWavlmBewokSScpUGytuH52+1T5IUrIc0b4ATwwMrM=", "A71c1vAIBhocCy2glwE+2I0oyqEN4ANpBMoDpLz63nU=", "K6nau+D5/cjv/3BgFC/iRM2i2P7/6Qf/I8xhwIthnag=", "E58K3VRD375kL09gpXqyUCovrq4bbxLh5eCbGQkFD70=", "CJZUhP9VnR5oZOOrrbXY3UAq0YAFlHO3bpv4J7dUJGM=", "JAwh+59s9/AuczxmCfl3OXAJitx+IbBB90hhVrT3jjw=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FRkjpQXxO+5NNo6fRxt5tJmXWwCqvviWKoYefIWPKZk=", "IPY3Tj8o5WZbQojHIlUciY60H9ZPKHi0f/yRiIEsHjw=", "Hyb+BcDs+ZhDzIjCi/XHuw90QVP8tAXDfUyeXGDf80k=", "EBo9aIcuKiF04ec8xTwwNFMsy/yGRbqb0XdEoKm3x6s=", "EBXLwxLTVsDOlhMbWVhLB5SqcX6hIO/JlFEsHf3rQiY=", "GntT0H6/aWP+hxZsJvXAQQGfIhD060g4PJq+mKNcPHc=", "j9ig4qHfguRNqD2Ra4cJYPYhqmKlM2uc0LsSS9MO2A==", "LEPO5mQJrCFXQLyLH2hJmWebXiQDAfgDCtP+9kDgXFE=", "LCnb8iNJ/7FjWwGC6n07pBwHSP5L8GtEpAHNFesO8zA=", "HBO2tWUabX85KasJRiRvc2b1rdydNgvF3c41mWOKCQw=", "EBcbkW2KFAdav+fEaLAdI5xwQ6j5ffEDcB5xa/WnPyk=", "DFfD1saMnS2oQ6ybN63PHEaj4OrHxC/aTf4M5ceZrl0=", "Ex42HlqHJdAeV8PHe/on0fMylTO4LvSwGhqz3a0JiFY=", "D9ngdv9PXcca+7J0PHTwgKQ4U3k/j22AqT883TkBL6g=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FXPZptF8+K+UfBJdpfn2RRY0QwfRW+AoYA1/u/OpkIA=", "K2ZFaV9xTIV0L3OIIsIaJsiQbBvBn5jgw0zR60Y9pIo=", "L+x3CuY+dZr4bQdCsEnrdugdRfaAdyjmaTDQDLnhpAQ=", "JO0CluBmVgyNyyOefn853csYmOWDZUP46Yrsy29hRPw=", "Gs6EhMDZbQUK3gkdvPDGzZvvhohLvsb47lbKX/RrkyU=", "EQp/rtUYksc+VMZU8vo15H/SZH2Q1uXlqK/vbdpNpz0=", "FJGqfzbYmsEz+pmSmQrykTtxGWyw0MNRHDSqUq99T+Q=", "IMsMHNGt7voWSYtGc8RZazfzT9/oOkEGXB+rZsQvNLU=", "G6KSU50VaOxqPiYVE027UTTHPmsU3spMGxqZP5RByDA=", "IbvnXXyFislIYj0N6MNZJPKPRm72KnpHPWobT1kqAH0=", "HJb5+0xrwz1GiS2IJr0MLyTX27842dvs8J539pvXAfI=", "EtM+zdZIKSj4qsCYeRC7w3K6LxB9biol/uNOgvEL4tU=", "LBthDOmHrL/Noyj9QLVsIJtqlEv1eB46d9Gvn6MLqm8=", "LXfD9CCjHVncDPg8RRhyHsoD9MiRP6w3G1U7lmz+pG4=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Hggcuekf8+sNER8r5Z9Ow/69lAemnssHeNc1XtMEjO0=", "LgiIuVfg/P7MoqEVfddMsBodhUXRXKJfk3xVQZXaPJ0=", "FENEh+Ygie12WYcDRvtKyr4Pn56tKhlleojKw593O74=", "CSmYIcD0cMxZ+2iLbldSLX9Xr/HlidwVcihp7edgqeE=", "Hxziy6m0yarWvK878D9pDiZ6z34zWGOlTmmHY0J5udI=", "GZ+rlHm3s0Lftt/NitzbXvjNnKzYl/8Vo0RTedhv2CY=", "K8/06ACK9OBPAsM3P7NyR6qHPOe3yqNQMPunNgR5ptY=", "A7KzfiiAkP8RzYMcALn77fbYLpdUDFYHtZoaWrTjBcI=", "08OeuIDN5j2aT+yCpoMTyRKiXUY4ofYXet+dhB09hA==", "Eh2jgVfhE6Oz5AYKyrfhtAs2zi4qZ35b71q+vW1MlLE=", "Glkjc2wAfN0xMRsm1WBhX63H4B6GJAAz4fJGXpPfI0o=", "CQ9WjYBsXEsbXmFUK6Eizx9dSu05ZsJlCNgkwyKOl6A=", "INK3mHwyamhhC6POzQtNxUyQOQ3wErfZYXDZaTwpzQE=", "AwILFLjhUpzdkoloDFrUQWJ2MsqwiyBnWdKOdqD7/pc=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Gu0WJ2+JynZtRQL+IczOBGpjzS99RKCqh3B3Hi8BLu4=", "KaYbcbWjMjeJnspOf05A0AjJejK76wx8CdjyTWyldMY=", "MB2rv9S7ypFNFpQ8u/w+vwBpiMhrBU1rYT8Hrh0JKvw=", "KjxtEmPkcMyjrlMxBzObjf7XcAyRADmytFsrxnV1+fQ=", "IP8qa4ISc1zLgv9ZeYhihU4yRCRMsFZvXT1Z40GqNtI=", "AuXat1/2nUpC50UofJgQfKnD5CPcb0EJbAOeuXJLglI=", "Lw+GkMfNRzfpE2U+vYT1HV9ye7bscpx4xClyqjTW5M0=", "K+bEpe/kg/4Kc363ffeBWmWZ8JHwIRMe83/RkjBcTFM=", "AvGEOXhred80YPQ3uf7XT/pdiZ4vx3dKx4r9HHXX2Ys=", "JX6y6KeTm+a/xZ0/xvunXaNQSaNid8N1E94D9srpFTg=", "EvgpjEpoBw8Vyq9QCHllnQLDqpt3EQYkGRfLZjhggTM=", "IqomMYLxnIq+cn6Hoikf3Wr3AU9e5axsGYoQjc8C9Tk=", "FM7icVoGG8cIM3UHuI0Jkmf/19cZYuuhv30qEXEGsRE=", "C+oJsDteA9JWXptPfEOpHtgTfebfpB9w7Hsk1Y63sbQ=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HAERQBPi0swPRS737ysgImzGnlewKEZOlSKOlR0c2FU=", "JcfgQS0gcgYmhOlrZWxEEN1dd/ZExksbHIStXogs3mA=", "EjHp43XIXEJMX6x5YA6RkE+Em4+3HHq0w3p65YwX1eA=", "B6CmPWtUQzgkOunIRrVCshPGclYDanGaRKRRuOYh2EY=", "KJTTg77MpaR3Jj4YjTDdgdekHlbvXIXBDZejCbjazP4=", "EBwOa8hoyS+ZYI2YOftiYzE8Kubv5NnvxkLVd1dwZrM=", "HSqE90dbplvzGRBqtXHnNGEeCqdC30ngPJiBTCFVgvE=", "LSkT5h2EI9VXkg0KTOIwo15vRd8AkuGvOJ1CCQIpXis=", "Ae7QGUECCjCZZo36gbKlfBY56mxh/9LPzon2lueAI98=", "JUFzBu9CHY0KBlFcJBti26LxY2i1bAoJ+HaFDE0AhiE=", "C9CVPWQFUiB7DfN/SrAM/uL0WFKG4AjVPrASRGT9VQY=", "Kb6zHdSvRaWZ29p+MBTIi0sBc7Np6WdDEwIuw8OdGHU=", "JTBbqCHU7MpoJ1+9/lTwaKjjtUNbzva3vEqNpn+RKRc=", "G/7Jpdihxe2GxOf9u2uW4wJgLRT1VIixuYZE5hIggIg=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "F38xcBxc2GwhNcWC+iLR+hAFrRSOElyABGpS+Zonigc=", "CEtEA3yoRtw2OmRzftJeroHkdSeq1CyLhg0vFn/IYpk=", "Bds7RL28QrG08myZ/hos9kXyjmznElPZKkBt2Gpge88=", "GHjqlDMh63ZEoSYV6oKGD/rU4oQoI5kCp/T7L9M0ZL8=", "Ek30co9kJwlovaWu80JDk7UehLzGctt1mDzMpubvsS0=", "I2UOHa2dIeO1oRQLF4+dV+g4oJOL3IitfCMlawliT+M=", "IBpS48KzZTKklutCBgxhUP19w6wtty34UMOi4/JUZUs=", "AfSXjKB2MIOvCVhIrxdXdQ6oHXgtljhWZd8LYBIe3mA=", "C5j9uwB4mluVkO8VfBkHo+m9PLZ4h7unolG1jNRYZ7w=", "Ckl9/wMoybY5v7H0QVhrPbEcCXc2I728EsQM5UTZBQQ=", "DrAW3TnIeMCwm2xuhsZSf5y98JkucdkphV8NRSV3UAg=", "GO/cBCWcyhEwrtxxZwl9Ju6pjDjbktaZ9xQNMUi3gqE=", "Em837yWMqs8UZixuH2353E/G0XkqF74a8oQ5trfJjeI=", "KIkoIDsCDZ5qV+6eFawp1k4nd+4IBJMHBRfBozOMu/k=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "KW6k43YO49HL+r+ctzpQbXzXi5oo6pWel30FbLBxhdw=", "CadUIDNxOrmMrns1BSgEaoGNwbxNrywhGdOKuy4Id6M=", "MDRwaukkUpLSrvJBtzi9OwshF1fkwuATfixlwePGfRc=", "EEyiEa8stEuu4VJenEiHwcqW8tFHFI1vjXCD75dbT9c=", "G1I/iGfsFFwZ/1DUvbVgbCD/Aas7zgwHaPwopKPVlaY=", "DV7er4TB514NT2cMCd+qBw2zNkDnRDNsYLGNG5uQSWo=", "BRJLQHyPtABn/4FjrziKyZsWgDHswiqnQj51b+9sliw=", "CMop6lCzY1SvzpUHB5oG8GdTo+ITYlmcO3LVQgUMSdw=", "BMNibOLbxNZParaVxZ+PUfODoYPlAzcAr4P4PDGJwek=", "FL9m/kbx8RgMJPFq633sP0rQDBtumYjFZCtUlgmzdXM=", "Bnsr/nvOLfv+uQ7u26ABIe0mIsONQETqbec539X3XRY=", "CSh+ufs02f9D6/NzRmQneVOTgj+NcMiOp229esmJvW0=", "Fv9Z8NZ5ro50rq/M0HFNlmxP4ZNqoMf7r4goFohQUks=", "IFHYzmxdzrwtf/4REwdXvPfNFCgxA9P95T5/eogKhRk=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HTYO4xFvB0QobaQ0BgSb0bghz6TD6CN1LADwRRyUIlQ=", "H2zNx3Q7pyMFoEkaMGqs9OOwNrDwYC2qiP64/YzGLKw=", "D4UHGXFh+iZ9DGjNOB1CPziAylbr0Nfs7Groj6aNei8=", "GLSleGCuX2tawtT4ySSyuzhy3KPbeDuuAto2b8hLehQ=", "CvcW5vEobP392T8UF6BkzXaxp+I0fWHZsYIeuKTd7rw=", "FPEor0cIDbXRIq4ai64nR1wZM/5zz+KoDYk4CyFHkV4=", "Hy+XzYHP6vmrgDIOaI8q9Fyd/Ep09yJ8cgX7BWl84vI=", "B6mF/KYcM0agjo/DEWdjZQexOIWFC5y8ZHmN6bdsxXo=", "KA59mKlbnj684aTYMl1p9Crox/cyWgS/381TGnDQgWs=", "Aczhy2krjGwCx7ai4g0fw28DG8xE/2v/DEq7Wxx0OvU=", "Ksn9kC9La8X5FyKFB7QDhZy2cHfsK+roTKGGd4WOVoY=", "Abacv29rzsUOcVl8Y6YqglOmNBJhLOTnmyYnU4Mblw4=", "CYHstnTE+ZlqD48BnWRSDJ2TOtDGN18XpkNDA1URPKw=", "FPqo+BhMispGNjgm+GSHdyICADWXDb8QkNTTkR25qes=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "GmkG/aGbCUsr1N70sl6vTXmc+RnQ4Ug9k4AYAGQRbPE=", "GrbclFF/GiNdEQeQK2wDS1U1z76UypCWv3IzC+BLF54=", "FWabXk3NZs8ptsBqkwj4Zy+I0Gnn6OrHyxGAi4KRMDg=", "Ey8Crr7n239p/baMqPvVfzh2ZOZCD+IAYJQTRP5bY/w=", "BG9S/s9ud6lbMSJtNJVPKLnQ4ugAjeWz0RwnTX5E/hs=", "K2nt4k1ON/GowdWO3zXQp/mgcWw/cJz+XPpvBp/H3NY=", "DcLMqPDT7/TSh3IrocULkGIjDVtsdIqk1wAzhexUJLI=", "DRsD0AmmoClc28nyPvMrwpM/MKi68jYCA6sGS2k4gzk=", "GhlyQ4zyn5m2gC2aGyTvxQFznG1yeKXzCxZnwre/xdY=", "ID3ZLzBXk2Ho7P6eCEy0HLr3uT+tbX96vJ0Pc/ukQHU=", "Cdb4at/65eT6bV36ZE6XpbOCocfpBRS+qOzR2kJ3M4A=", "EtQFcuHb5HM0oWxzki58TalnWnbV/gmQJ7oAPO6PK44=", "DDw05zFYkYtyZTFH0ePQWbJWwWV/5QQwp3jmP2FAVQ4=", "BpcwYPcl365hrLzzFx8XrpV82GLob5/GpH/HrOJKiGc=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "GzpVErGEKIk7SML+kVdW58x66qjKNsLv9tq4FWgmTeE=", "KrlnDBj/jtwchMGrNspoaZDwfha1Z7+WQhZe2qWmNG4=", "EGYNUIK4/Lf19OsFH5JumaX+29cG/hkbsYwm00vjB2M=", "Guy6Gvm3AoG8JyLA2CoJcwXCCKODxoMwoWM/47WclKc=", "DSOgbnl2GQKm7zB0nIaZjD0gvIJ8++LyK7oPSE3MBNc=", "KCtr/7Bi++uqR3L4CHgLALd9ocUvpki9dK4K1J/GLZ8=", "J9SLFbFRN4oec4l3q8TOLYvKuBbcMnl8oGDuAJrHREQ=", "JVLvuezr6eF6gldIhzWfrPXNYasupkvNYMUOBTEkN20=", "LlBWMNtEY/HSJtDh/MW+TORXfjkRvTJiMXpPsy1/jqc=", "HYXvk9nwUkwNV5QA9i2Pp/YjXIYxutB1CdeeINthStc=", "JLrGO/FmB/syxI6ULQy+yLf7GFVPNC1pc6b+OjCcYkg=", "JAOjNwWFXZ1EVneQM+6xk46cm87cTxso+Qx/zj5POdw=", "DmYZCJBPXlMKFuPBGEqs1D7Lv67+a1WJkCa5/JlA2xs=", "DuYzbmb82zpk2GuXm6qwvSNSkb37IT7VMq76CnLlw6g=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "C8Y/QWUehExmAHQhtUfWnWlFc7E0O4WDqt6485ucWvc=", "DlzbNGXxJ0P3HvX1BOalkn64JCZqgr0C3wNe/gjpIfA=", "Ggr2lzSqsuQwTRXnppsuZJVrQhTDMNk1ZHsrEn9q/ZQ=", "IUSRX25vgp5xecXABf/mye46eW4y3lV3IlaWp358OB0=", "JLYnTS+UW9pgWMM2a22R4zdAiXxubxMzBEh7Y78LpDU=", "EO/ER1H2ukkUUrhKkllDNsb/QBIJj5/oVCAkLN8IK68=", "A268am/LmO7V0Nz4cjlDOHnZms9vvcVwUQ7WyCUFXeo=", "F6GyN4/qlNCxqW6nAFBbtFxDGMm5EZSacQdBT2Nqkcw=", "LkVadRjlTsLg/c3Sgh5IiHfFlPhUEx5qmu5zLblWZtY=", "HnOXZE7U9Mu46TGw20kE8pECtQo8qDnEOsTAw5nJqK4=", "34jvHxpno5/rclMWcmyXsISYEwCklmGaONP++202Lw==", "JOEfycTHdjgp2AHdOiBTWbs3ktou+LJ0GrOyxUrOyK0=", "BJILPoAPd9fMmdjuTQFBpF0nkp5uSn17xBk64lroIDM=", "IKt7ar1DqI9oQhfvkxwTzBGQhWTIYD4BmTsOJ3qyn44=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "EPiln4Jz6s25FUpzRlPk/3/ODaQE82sv0AGz8He6aLA=", "FlIVPjdezSN8IazcP5bTkIj9ZW3/jWb4Z96HhHD7OR8=", "EqR1YRHsBo47nEoUJ7CfmjE+AY2DH3rl7+nz9sYcE/Q=", "ESQ7GfETJBR35HkPibjqeWZnluuqMcws43AP9R7Ty/A=", "CT1qtAqaSjvXTwlxIGVMgv7Pvv0QZ/c7parwMbHBjDU=", "LyaRGyNGbCO9/7uKuoFXUrbQvePRIIi+ytCwj9HcSXY=", "GgPavmajA3gy2TocPDNXTFsoeH+mQ+xRSYMPgezJK9o=", "IjsQwsVH4aK6QfuRi7WrYCqf8hoZw3wVf/rryVusSHA=", "HycYdvF9fM67Iiqj2kzAlAeqtN/dRT8d3PJIYx7sEIg=", "GttYrdcOIt5RAMPxhwV+kwydEi4SjD0RWYdMME3MEJA=", "J7P36h40Nz2Bg75eRi8OxR1dDIvwSaK0jTDKghs2ivw=", "AeWraabwBu9f845J/DS1jRAa6QusyKY4w1OmNqxuDMY=", "FOu9CtHyPix68YuMQ6QehkkhifOCmXg8Pt+On6iiBz8=", "CTnI90zzF1UrdPetKtXQrM8+Aqw7nmepGWRTm88JKVw=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "GlXN9mJctkXNYJDD9SX24peGSlAQQdy82ze28Vr342o=", "J69flsvDLyF//iF9TUeKMV8glShtZYmuNRDoR6d0EAk=", "IhCk8eZgfiO5CkU0XMxWmEvIpiVsZh8EKSt4Ujvcx+g=", "Ifn7D8fqYc1tD/LTV4XW59FcepzafL0+OcRBZvSxdbQ=", "HuXRRWfJQccNB637bdUEZ+sGaLe90fzhh5vc7rBZ+U8=", "JG7Zfk6t6+UMigr969ZZgDDyfoe4nwv3MJDaTZXxLGM=", "FvRN2QDdnydGF+LWFHMyRIOBcb8MiawwJW7qvVyO6UU=", "HkXkLD3OpjsgUYB1wWdFr14gU2mDsW9jLTwVyRs9fRY=", "GfrFzgAoZ0zou0AFgWLlD5+fi4kFVA+3cikwy7IBEqE=", "EZCZfc2w9Xcso96Lh2pL5i+O4LOdbCM8lYSNBzqO1qA=", "CWx9t9AIVzeTTe0mMXGRcV+mx4nePffmjwDor1KFMPM=", "HCHXcc0DOPDAwA/3HkrywdfbgZIs7QmP5pia/n0eTRk=", "LdQ9PEC3aPViV1jcNWaO+zunRzR9X/yYDsCwy6twnIs=", "EDAFn5bXXgS8X4G4n7e1sP/wNhrfBMTwzt6JYw0vA3o=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FjUBkpW2WwGQ/dcYkn2v5MDJZXcmZYAM/VOdVZ8JAKk=", "LBfIkLcVs7vsFM/I8GDqhNfBLfLlHMHopumH9FwBZ0o=", "DI/+pC3XsgYDNCelEjd9MFT+T4+GNXqsWAMvot/nx+0=", "EvpV39ZwMJry2YyN53wwKl7kyj6wi5DycjDwX/QofH8=", "CQCWYqWiiomunW2ps5gXZ9LM7RhnfkJ3P9QzQpfW76k=", "JcrrtVAed/FzGlS+Dgb4wAUXYSfzVW3cviT7WATgggY=", "AZXgBnNHhuWRrNkv0jP3hFA/P9tdsYKZWS3lbXcAKKk=", "BHiFuYb00Qq0RGMEKgv8Ot+ju5tVO6yW7UD2FikbziY=", "CTDzqhxUEDlfmxeiChdTtyGgKR/abzK+6Kqm7eKY1yA=", "JK9jgDEE6DGMPnpBz4AnrTamMeoR1WVSvttfACOfkCo=", "Anxj5yXRfZpE9H/HPwLXuyFQug9gMfAE5gDOAIRArvU=", "FXJwp05OzIu2+XbFvc5wkSz2T+nIgW1i1CsOrNlRTas=", "IZDn6CLAUIxx46txNP2JpAd1vpmhs4wnZ/YxODXu+LA=", "I0881eDPcx2lB8ka4Y0oBhCCrpqlgHRhSdGkj2qNsqY=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FDP8a/QqJUHkDBBKJNXLnUYvtxvwlL2ZjIWTOHTu4vM=", "EKhEXYPzt+xlEoCDo59cdZufUruM5cAkvo4tMA4MxlI=", "Gh2EgdOadykR+bzuAl15BJdk3OtIioJ18Do5hw+0yQk=", "CC3qKBqhFDWnQpRjs/rao7xoCq9J8C7lxA0RD2NzGkc=", "E1VpR/0HFK7SUeD8+RzQ6ND+8trD20/587bFNl7pui0=", "KVCHlCJufLBrwXADLTd+3CENq+vTolTs1N95TWX4z0c=", "A89P7MVLUpskfkgEipY3CbImMM5xmsip6dH450tz5wI=", "FswXMFs9MzJ2qctD1RCJ6tBNwvHhl//wAS1MfE21gpo=", "DDbwMYhEU/zngkvXJPJej+cdPmQLrt2TmKcZ2PAcVgo=", "BQ/0AQeq+pouMOoaJLZBKf5V2oSilMqNCvy5lWqwl5c=", "KLGAOYhKbWna/qZrcjBy4MVbH9q2skfoAdbN1Sx/gbk=", "C+GPsnSVc8W3t1NO88sK1WUagBs8a7h1/fMM+LFV2OY=", "LtO6JD+1YeMIp9ojTlgYmJgxcuWM6Y2alK7ltt6SW18=", "JI6x7hKdUVq92fZab6dxG3CDdBh/qmGsu7bSGy4m3Hw=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "CJ+4sIN+C3yVmMO7XvxA5i/zHmbqT15RuTMKIPnV5VM=", "LBcyTsjYDvIgAWZB8Yu47zrQ0Y5N6N7CyoEhVZHa574=", "I8CJM5Q51mVQfA6VarMgiyfWQ1JgRfSvy+Y2TES/EJM=", "Ayr26bZw7exHRNm+FsL7Bd/9d0KwNcXV40WJ9crjguQ=", "E8uF50h4EytqIHhOO/Yd8YGMTWFBZR0drR76zVh3QXQ=", "LbB8G/8u7sjFuduuWG1qnn3/EpNAUS7pLCf+OsunjBs=", "CYKYeKrRnaGCR7buaAtdP42UwLBGwk+lZBzAeBMDGDA=", "HrANUOOww+zaC1adlhWDujukmj/fYuq0E3q07NFlFec=", "HJLXsquJyVTTal2kRm1M6P40dsqxC8dnFub6FGnTyIE=", "KUEuT3mVe1qkhPiWuqlZd4CNLqds1h4L5ucFqpwxxBk=", "C6ZmjaXVveEM3JrtpaBQ2GTuL3L4TKYAowOqLzgM/vI=", "DjBBxf4Nq/lU5tmrVRnlOJyz7QIwF1XyS+TEAIRKAZo=", "BG+AvFRVqsMiiYb/GRDZiKhgjMjuoYargh5bjLiKip0=", "CIYDclLfSEs7LpCfee9p4kwrDwqbkS1mbPYkuIjXlY4=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Hl2y5ABBrZ2ET8COSTLCqJPxThB6aFNML3D+1IC+7b8=", "LQ5ZRc8f8RuGS4ZlnmApLB124pqI014tJQB8Ov9XSDc=", "Be2hyd4Gsp6QG0P02+75V0a63pUz0HoisI7iz5SL+Cc=", "CSFWvGCRm+sOLCYtm0ypyIgiGxI2g5olqUV7TUdXVKk=", "IDRqZO8nSAECaFw5gzYA8DJ25eQJTrogd0VyRrtbCSA=", "EIB9hHkBwreukLKBv4SvFkWrvPsi/sdiZBgnOlxAYdg=", "GgLlYeTmx+XDO57tR3F2wpJ80jMfB9nq3W7IDS13w88=", "GiA2VIaui7/+Q3//aWx4yzRGIq4NJci2sbHeti/QO7c=", "EPa8GYgTlD2iMA0m8IHKvI2v2SqVMHdXXo4q5LW2D7M=", "HX1arqi/rhmYCzxSn6sI5xh81xpwbzkRWtHPC39X9VY=", "HfHdRa1JTxqHKogkDBqayGwYJliQ029bV/hKbbOIs1w=", "HCnYjFp+RLhRHIeHIPjtvS7AmVbSpHElrQjNeRpyp4Y=", "Ku6bVaL2Fbb7/8zoTGUqP0E1H82huDD/O+r7B10EcrQ=", "HJyhuqDz0kLTmjq3JYCHfBduKKXIh8AEJ5pZsLzx5m8=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "HitrC/eztO1RJrjovmtrBw78KNBi+JFLobX8aO0U7gY=", "KwCogvyv6NQ+faQkNmpz2gt8qxlHhEb1baeim78kq9U=", "BEEHDcllwauxXMTc1maM+lbxEikDMY662+Uq9klcTp4=", "GAQ1Djq6pCbPMB6wJB0vFyY4fvvw328MMDzQ+YOZfVc=", "Hq/tfWTR3quKGz74DYM7Oq6U78n4koalV4nGuH1jex8=", "DAi4lKza4Kuz4cH2U6FQ2W4GZqkuim9zLYtDji/35jE=", "AjF0CFF+yIvXeLrnsm77und6obRGDDr3HKyIqh1NLXs=", "F9zL5z9aewNug/YjPGUciDp5V4YervuzhUaHhbVZLTs=", "qa1wuZRc36c226wh5LRCZRXtMv3wR2IXQVyk7c3sHw==", "ErITAlcgRaoTcotluebaLdagC0nJrPdBjQNDG2Y+wxY=", "L3PmBhvnTQ2+FH/D3hkc9UZX41FqYKbaZQ3KU8bUuA==", "C5B+diibIUc8DmSRdEQR5SCJaqYU2VX6O35z0l1PVg4=", "I8b3jrHzWOTzTXodWFd82K82LI16ZQyccLfO8oyLd7A=", "Af5TcFTf+sfvT/+YpJ8lOhdWLTLusZA/8xcugIn4ilw=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "IkIKVWpACazLVMKyJmumV3bVRVp5ROzjdAXyu7hJ41I=", "GtGWj5khV1p1Rw8i6x8uLjprlzxY4i/zDHMflwZL0FU=", "LXCemdT8TVnp2rS6rRe7110jMeikSMJZXINeluzlkws=", "Dh3x2CnJIOBjzf8yNC8iPntIUd94/8uhgN9GCYjoVwo=", "I8T7vhsN4+i1emE3wzHjsoRQS7ufIPvp3CswQZTMsmQ=", "LsuyrVmCOJgnhHPYp2hZiiLSvnkiwpKpZMlTCArYppA=", "BdupXQT/8GJF0PTO1AephXG7UiVHv7umxhcxiExNTjA=", "G2tHYdGJ0eLbBOE/FwL0oVMV4bQGExJjP70vfZyUOwE=", "HubF8HoAPn988FymPsLFy4XwE39V4eYsgcm0pA2b3Ck=", "CAK0VI2j+Q6opJwmz1g3JINdit1InagZF8F/92hsl+A=", "GjCJhU5F3v6elTgI5Y8UzQ8O251lMCcyzlRQySynmIU=", "ITN3n7A5EsHx2yK1nzqOltOWFzznxavumPBRGbkUtwA=", "GNzCP9reJ25cG6T5akfLpXzLzREC+40GNyNSPi2Bmzk=", "KhuHAg87kFlA91fO5/C0WSF+pCm3ep7SQEz5ZVdj4QU=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "R7vcSDaj/9lArrLIYIp1+zfU4O0ZKfqJMSSocEYzPw==", "L+GIzr7z34CQ8n/UDU4fVXsqE6r829NtU825nsSPoT4=", "Hu/qL0LtV9GLi/dZHd/Q9UpOdDRkboTnx5oV0vh5qqw=", "E5TACatcxD2OoIkoakPTDJBNIn6aFRVJu7f00M+TCqI=", "Kgu5IsWjb0KBnQC+xj2ljVC23Ub/INKjspwcLh4P+Dc=", "JwslJgCP2lFXiLTjjqhsnJ3E1lD/zpY4+RuFRT3t7U0=", "K6Hi0uvmWed5MB1j7N6YjVVDLVvX+KT3agPiD6Mf3dc=", "D1aDK38GqKOhwoe4SXrhDcBfIWkXRQgT8h/9pMDv+tA=", "GVmgljuXSs4dvvjdsJycz/nsv036EMLBdNQtUjCYz9w=", "FI2gTwrrA86ngAni0RkoZfW5nWMGgbcc5x+ewF7VW2k=", "BRpAr0FvT7X58PUfruCua+IQ+bk8Tq0W8smpaoVcQaw=", "IJc/H6uYkO1IcjryNBUNHsygZmKdwdBwMcbKteYKPv4=", "KiiiTvG911p+UBpPA1wbQx9NdVTfX6zYAOzT8CTsgVI=", "HS7k4Y+hV1+z/3I7P5rTXLCZe0NvhXRsaFeIIGgzMUg=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "JimZn7UlFBlxmWhqpMCwlh2KpIQEJBF34TG8I5b9pzI=", "H5k2nXCmO60LdmUupp84j6kroWWINvo67TZnROzs3sA=", "BFEfQWSb6F5FXOdDOOu0JciV+IVAJEpVTJlHvOiObtw=", "C2lvdTYVRih2ue/i7h/tecSb7Nz6Oi0NBKKQUTNMoRA=", "IU8JtVV4RmYmNt5GedzZZWEcPXjo1QossFicPskMmSQ=", "C/WDW0wLxLE6Pb4PvWj6vW6mdJtwRQVH8MLjtljAEwE=", "DEjGQOiKZEKuWsV0Ih1/EOsuZ8ow+wvxac3gBPTe1QQ=", "AaWTV1a1e/4Co+/tuuJuWhMgC+4JlHEgBVid38GrW4w=", "A4a6hqBlZq45tWzaeVgK7QZHuWNolqR6fg6aqZGdnAI=", "8Ad15AC9w+hoWyBPB5ZOKBY+yzxjFl1Gw/Rj57r/6A==", "GmYti6B9kVz3UEzbwB7CpnbtdjR93U4H83DiSae46lw=", "HwYTMoOteTFx+ZpOjL0s+0ZdnWr5/7RZLZApNCF1D6o=", "D4MFlQfIUsl1DVKAxECvSdqbsyjuY9Hazu/QvsshT9o=", "FNHr+8TChPAWE01qtW2t205kdZPKoTJOyzAqd+8LO9E=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BdTEJwwelANI31Ravx55v2R2WNLnnqzV3L+X1o0F8+w=", "J1223fNw0vfiECDfwRBiVPHGD7t94H7+7D1nIrBLxU4=", "DY4ENkxaI6YPRrRUhFnH58ACtz76YwvRZas7aof5ZIk=", "AX8d6Z/1uWFJO+9n8WLkZMQkgeRIEi+luuzsjK4LIZI=", "I9pQqqJbdvDa2fUNsj0S9kpIGfVHAntr9SdoeZNi6D0=", "bUq4ftsPoOoDek9eoVg8QZgSnwZ4KRacBudEDzVEmQ==", "GP9XbqwWVBzqFzxhrrVB4HYc3b77SpDxRIGJR9FgE6o=", "FAjWRJc9ZQL5P90vaacQk6n+UNf4BhrLR0oKFLowT0Q=", "Kej1VpKOCWNP0LlQ5b9OkEcNRePBaxOGTVmMVV5XseY=", "FjetwOK8UTQC86i1MUAX164ZLICcQfM0gibdUO2CVC4=", "BzI10KnpbPhuCXaVOYij2aJgzrWbp2M6QMvX/t54pRo=", "Bt1em6h1v+b2WWujzzXsI0K9A0IvE0q5mrfd25d4uDA=", "GPSRxsOxKs0GoRdWPwZ0QKx1PsRopd8MEjSY+98PFD0=", "LQn64SbRWVLCuR0xGTLJPP+M2itEznTF0dbdEy9M8Lw=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "ECK1f07BNKj35XT7Ygk9QVuHavY4Ez0y02apsa32IPA=", "FNUaJf2NHcXHcgu3k6J12D2BKYOWW8mwXTBnlM8dzfM=", "LGp7MVdfMnAJ7tBfJflKTxc6VEoNj6xnNHQXezuaFBM=", "ME0qRwHEMzOCfbcZddnCxOZ1BWouoem3Kg6vEnsl77A=", "EffGx2RBpnvFlGaHpAoops3L0K3oTDiRFbdEEVxif7A=", "CaG6rNi1V/Cfw15kNOz+kYKgRTcXHuHSvWA/U3ggaAQ=", "CJJqabLVpCAO4294Z3ATl4HrYKfSctMUBrdRBO/L06E=", "IRNd4zNyVmAPq/WQ4EwpxeCHWZGmfRfu1fUTHFZ79Ng=", "FLJI+r277Q/WbImeCoAbu+9OGvyb0Kv+9HGIS/oWCEE=", "CG4g0o9TMyueCcWvgVaU/4PxDzeZN/CRBemFKf1LSwE=", "EnHzC4LLeYZW5EZcRKn/IEMl9f0tLiBPK1Zz94/vpLc=", "IiSo0JY/GsTz6FaV4mkuOGo8FJKqWBJwhuE4W5ws3oA=", "D65QQ0sb8m95DKoW7yViytXSOBMFIts6l8GJOwyB/8M=", "A/KhQuQIQWTs+mMApL5qvvvhVfWthKaE92HnUnWSYFI=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "J01NgzcA7rtc98j0+4HBdKEIkyoOmH0oidm5OpXRh/Q=", "Dpu4yfkwZ5G3dYKhbFOUfhLg3+0MKtwe0hFt1FFZiCE=", "AmoJjpETDg0QYDvgUH3ZdUMZI7M4tsCjiQ+7gVryj3s=", "JtZTzgjv+PFiwQM7Uup+Z7oPaoA2vGTVVqdYF1eWmKA=", "Co71SbkLvzr22ftNuGVrfenPFCEpiUIneMUmkaDKg/k=", "CsOfT84Gon9ZtfQ0564oCNpULRzV/Ri7S5Dk0VWYZ24=", "IErtHeOzFPOa/iezsb1YmoURg67TnLMATmfeymRiZro=", "FYyy5zxK7EwFTxdZ6fMpO2KuX98Y9pvk9s4cZcwcFVw=", "EwQKyi++fAAcFK04bHVrpGV5a5ymd3NdlYYWALPOa1M=", "JnSpqN/7ltOClfbt0cXACOkyCsHplnK50FKJzkX8Zzo=", "BXviNNeKhqtH42kbZ6YyZlGbtimFcB8gcklNY0MyKkE=", "Erv6xq7Z+72BJUdT6L9L1MVi5K9iVI5XfryXP3fZr3c=", "AQOz4mu8R2euuW3qzXcbW2lLTVcznjUcEFB/Yb9V2RU=", "BfkY3ITL1qCjKmWxiOPxxuNBK3YjD8f25bF2EsGr6Lk=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "KOa3NuIzfcQ47mQwmO8itpyGklJQnWBdZ5nOrNKNbPA=", "FzJiZHFHYd/q1c9SBY4lWbTFfTD6aLQWKrYW1N33BEg=", "Am0LmtYXyHtgDjsny3l/Sw3tllUAplSLVU0kRfScthQ=", "GldQXXOK/1mNUbosJaTti0H5R5Myv5XEoolTfdIqNm4=", "C8lGP2Laog8PJFN5ybNsSMJrjy59OT4po6teMFOXZPs=", "DS3ixeIhqSfR6QYX6L4wjYOpBbrSxaWyn/oGGGvWLJY=", "Ks+mkXwlbK7N/BNRO0BDZxYwF/ksaDFOTO58RlwBa+8=", "IwClXZTDTsxHeFeQ1M67PuFPQ/Nu0muKabHnZB9XA90=", "Gxg4bNlO3MU7X8BKT2RjutsLbxkIxTdl6ylTRJ07w9s=", "AWhSP82N5OUfIf+utRlMWII1Dikm9212tJCNPgkyteo=", "Iwg2I2mBJD817KDiXXxzxKrXuLA3XrxTIAxaFp0bpbg=", "FkSTHrPhWsJ+F2ukoO+iOozSzQpJXg/xRZulYsOfdKQ=", "C9ukf2SBBGeGlNHcPkhfh4ITh9Y7QLZDaB9pIO4VPa4=", "KTTudU+Uuc2ktBk8Laer+IVChr03zh0Q+v8lBGZmNyk=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FbynNoJ/4ELXvWT3eCG/uYrHdl7/x4f9pkJ6nBo9eBc=", "FwKqvaOFdcYDSzUOS4iipu9qW8yvBLyfmTIXU9wSsfk=", "D8aUl69xJorjsjJUD4yeWxb+NR53lkb1zzS/fUGJMHg=", "E89jmRw+osQj8Aae72HUHTC3ptkHpsw/cjskH2dhMaw=", "CCEjFjRIA0AnNcZjsj/9FyYXKPn709kbL4biJ6NM8rk=", "HXbvWtg8yl1FLevl3RGip1aSTCa1RngimefJuef2gCw=", "D/R2Phy8dV67cwgJSHfzzrTLDTk+AFReyhadoPgsbBs=", "LuF9I5H14q2mdFsKVsWykVq7aUN+KJdeRm0hjv5DRvI=", "zfzRz1+29ATXaGcxqaMm3Lq2YnNlVevilk2B15Kchg==", "Dfo1yF8jMY+gGIzYzPehdOibMkuUSE6fHv7TviXu4ro=", "MCDnGJqgOShQ+WrbRshHap1ilRCTQ4qUiFiovcNAC4s=", "D309w6HjP1to4rhNnaBecWO0DockxGvvtAMPqIdo5TY=", "IzGz5ffxJ37LbvPoYvUwR6fPv7zQARJNlkN6dVnk2VQ=", "IFM00qAD8p4uukoPEV9JHhWa950YcWFCUqI+wsge4yE=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "BciLJkICOFpIuTmwBmacGGa8/yzpvpf6weK3+xPr2M4=", "A0k40i0CBmDQoAmsal7Ui7AJfN5Hu8DYzpQvsxxGRYQ=", "IhYszqe98reGxjWwvHEyoE92ZFtGffgVzFIel3zE+Ao=", "J7nsnCfA+GiiH/Vc9FXCs6OS3V5XzmhwuQwhftBRt5I=", "HUCgFzK1m8coBNW+Pbov0r6CCPwvH/uaRPvrMIlda3g=", "JaPBa7KWNRMmhO5JZOT3Nkye23P/XUHGEzR/kFGQmLI=", "ImTbXysCBuC5fOuu+a5XjVNMmLiiCJTZn/TMUt1PNeo=", "CFmadmJJ88g2yrVGI4M6+NpzReD5dvxoPQRpnDPeAJc=", "I6TnacQdVsmK9I2dPrTmXVw8uPHcUNysCJX3AXbGWWY=", "BoYzGfmED+ile9dUtYt/7SRm6GNl725njb58SVBUVRo=", "Ek+LDv4RAJyKFceDDawAdDphd5i7q9o99qyHdiXzWQ0=", "DDmSdajT6D6DKqtt+LCEm50TeDdukLiiQIQHToXMTjI=", "EZ5IobSnejpvfGH/tguTyQQoaCg1W2Oz+h9++ly6V80=", "KW4U/GvuO8LZ2/ifJIL5iRzx99+d27f5gpLyvH/ZpQs=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "Jqaa+JWgWjSTBA9zW3VOFt4G+iwEx9mQ+l/1dH+DtBM=", "CdOP1hIQKXNKzMwmo0tsCpxUctkh7x2wVF6g0u5Y38A=", "CSWFJcQgyRWK5KW3L3PPA22YjH3VBwCx7TeWpZXFttk=", "JAtIROGjnUys2qjLlt8XDMMGvTK0ZTmhVakdPexy0zA=", "L3v9eAh2KTGdZIVkf4JnhWrFl0IA2U0WXaNcE90PHCs=", "EMPJ2qm5F1Ivt8a8bBiipwlo7ROaNJgFoiQthYe5gWA=", "BC6DCJL9CaAWqlmYkwoIXyCHHnMFs2HTBpAGToaArS8=", "G9IppDIHqOtnD4eiWRAle01umbpiww6vksQciHuS7rA=", "F5JZrumASQKlklEtaR/DH+c2kDblDfUvF4menzEK2Mw=", "DJSGS8oO+QbOD1ZYanHr+cshkHYQ9V0NWXyRDxgy8Eo=", "G4EpqptU+t7YtuRZSsnGYmj3YbRXm6t15LhFZexhUfk=", "E4/EX+DpTS9W2RPu5vTcg2IBnUi0i8EdVm+xNqA05/0=", "Ed335flX9DSL04zGwreyHbbmiEJoQv4nkN7j5ceXA1A=", "AnPjqZNH2LtEQ/iAPzFEsceQgXYvDImZboym9B4s6es=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "IuFhlAtZd5hwnVcys1t6SmtXONYJQ0UMD88AFfdKl40=", "LcUnC0frAO0KGXiHVShuUVNIYHHYZ23le/HcwMlbgmk=", "GnDM2mCde/3NBCJ6HHs7XcUe2DKzIJrQXP/3+UvRfXg=", "GssuPIhyFxzwTo4SvfSu2YkD8wQnk4/yzirCygfomzY=", "KtrxJqD1+wIYXnQdaUSxlJWRePhL/PJMZsqnBZDQCfI=", "HTJE/SqWo8VHy8tWl02KYobnGt5eAmVEz6aiOeMqShQ=", "G9mYjzq/M0epMfVi1MJrLGx8OxV5KfHTUpQ4aH3cl0g=", "GrLVkrHEU4AoPpIDTJPlouSv3YCCUl8ycoyL72KT2wM=", "Jcsevl741/4gfNFZz3lc7aZVP2gZ8HzPyUMjRGSAk+U=", "MDN3CQkMlust1jVp3wgVadfLCcvfSnyMGpgrGlAr0x8=", "JnZ/5bRPgC0axZC0r1WkzSj0pFZaA/pBLaxUotlT1ts=", "IGoFWZJmO6FAg5+0jd5To3UJ113jz/4F5UOtEOKmqIA=", "JvY6FBCS2XtDGGlDj29PLq/TWH0XWeuNxREpvlfRyeE=", "BlEZD5cO/QToXOtH9rtJGyOR5+TAIpNUvdN3Q13s3wI=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "FvnMZPZEQz5opgKUQw+iy1kycS+88dhnYoVh+QV7cUs=", "JxvQivXsknFmP5h+bSbJG0lpdc31osanxUkLYslAQdY=", "Ap8/+4xvFCUdTk5kea/CLoS1wwZ5gGfrLKhTDAHvjwA=", "MBH5tnk8+OWUz/1JCyJV7sLXyEyvH863J2/FDVmMRjE=", "FZKwMBvHoiW+IF1GT68PJiDJh50Gt8l2MsSZayVeixs=", "Gmy1qnkJc71E/7TtKYHGM3UNnfjmoSJjlkjgowWHDYs=", "MAb4j8coM7g8V4l3Q7va3hq2n1K9h4i0QG4X7EK9rj8=", "JzhlTFFb+03VRRKu2ADmwES9sdT3fNQ4lFV5oD/6FBY=", "CzIfUeZ5PLJdzVJh9EJgo7fJ+cRMX/P/ZCYKgdaOuXc=", "FHe0bXG4aE9kSCAzEKrw+JSMEjLLumTy5jcrJtO5b1k=", "LhGXgnjyanZMLGHGbttvKWSHbRierW/cdnMQRDVdkIY=", "CrIxKg3+xfVtcO/eSBwSIvCHUNl/DzeOMkFtiRE0fzI=", "KTtFW2fvg/uYsJmU1DwwzinfubSZyhfGd07shEEurng=", "CVtjXIZ5wnV6Apn7pDjsVQKYGOPeC7ZnIQBNT940Kls=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "IwKRMgqvgXyb2vYvrcg8jp1VaQ3dxqtCiEEC+7jBMTs=", "Dr+dmDFF/kJ6nJjYRnxkmmtv0GZvgM3D7d4tYQOgvLk=", "G4ovBxrPRWSUkbWM9VdqhixFl47BIauky8KzRPatzKI=", "JCh/Q7gvSoTzolAIKWV+SJCXToMhc2sHQkHW1MZxTMQ=", "As4fFie2QsjfqtA/tGSY1/heuoW3eO+uuyusFNPUwvA=", "Ee4VKpmloN6HdRqrmBgNBdseZPNiFJi+9agh2BP8euY=", "DOYtkethYTE+p+SCcxItahd0+W5XEncQkwK2jFPa2ww=", "GYJLzqbkzO+LI9UBhAvE89QIN9xgtDcBRqS2j2+Im5E=", "LR/HDhmac2aLTQw3NW9XUmnSWKrnGZombmPIirbrTO8=", "AyHCtfiTjfHiyzBIjmFSGplwbFj0I35MYVAL3+R/ViY=", "19oGtN7J/F4d/xQBcuCoSp0UcVR0XyZ4qYqrw/eYnQ==", "L8QfZ80y1+xO5RfItmfJoO4jCPdZ69iJ9qwEPYqoL0A=", "H71VsHpXJbPeGpc502EUyTQKmHseZqwhKxJ5Ukm9gQI=", "Cum52fIQHJcvhI8KK3qJFqOimHvL3PodMA4LeB0toGI=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "GfRdt67HbfG4n+6Ekst2Do9tKYysFn0qq6RwLTDzEF4=", "DrPeOqYKHkPfgTeQp7ArV3S7k7ZUu09pC7v9iy4ZwVU=", "C1Bqu2Xb5VVT+mW8Q9FZO+RAucUif9yE4ULuk2V0L/g=", "FyXPQM2r3aJODLNdEjFbsLz2Gmgas/O2yizQa7b52Jk=", "BbLg3xcnSC/GWXx62gYkgZRx5MTy2+71jO0MLlooRPs=", "LLF9PYpReQ78+u6XHKkVXwB0sudiKrt017jJhP7/p/Y=", "BXy+libBa7Z9fwAAnx54gbU2Q+q/ar8/S/rbbPlng4g=", "AdWhdd9tzaqTddlUxd+Lpbz7OUBwlnojHN91PiJ3JX0=", "J0U9RFpGS+3S+UMSMGTPDWZ1yJRvB3lXdy8y4CoPzyk=", "Dy4qfxQMOMXZMtLW+2lJFKBg7+nmv/4U/B3LuEC7tGY=", "JA88KFvBoccXzAjvIJF1zh770Kr4lFmcYpEU+wUCT3c=", "LcYr6DNiGOuRUuxlPF8tDtoQ/7B6l0uujuWjcKpJe1U=", "FURUlELnVYB6Ofqhmp6Iy+Jv4fX0zSf+aPqVKAam5yw=", "JthTEeW7Q24QXC7szXaO4yrLzSdbIsE1vOth9vzJlpY=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "LVwG/7PSt8+aDceXGTz9qFUGDCHeYili3HPei8flMJo=", "EULcPdi8/P/OANyHJTzhZHXfEact6LNQcOKpR+jfib0=", "HvnV63KTTFEJlATvUvhGVk+dWVamH6aQwaR07G3UrS8=", "H4dfvIpL4BgXCigbP5wNq16RNx7jEB5u7s4V/5uipZU=", "DH6kRVtOnqeVjQVJ8JjszCLnP4mwSfSFWJELuXIm2zE=", "F4HJW1uwC/wMUoDam7wtFq6x3crrLEVkQEE2bAxXuA==", "B9RvSXDwrxvdsLqitF6njD4EPEArNP5EYAkZ67O8Y44=", "C5fZBOVYCOjT2EcxV2YGmxXk6vbkhTNnng0dwAxw5sQ=", "CkJM/JrBYw+BXhhnsjUbyKegV3oGobPuv44cASiDMTo=", "CrSXbEC7yf6RBqdhDj5hH4jkaDnkhO0hYAhuDoPC5Mg=", "K9ROIXubG9fFxoetdlNzDGqcvHOrLj7KZTPOP7Voozk=", "DM6JH86DBhm8X+/qIljfP1ZTw8pgUP2O+zplNkMzTtA=", "Bswmnec5t/daUFOSEiBp9G6tI2yf4U2tS4ntO+dlq0Y=", "LOXa1vjHBqHkjrzZic2255FhBw1Wt/SIsd2usgfYGAU=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "LnfPWrUT4brepcPIkZJflji9FFh/bjQsWpJFLLIhbRA=", "HwoqPI8Rn/XcIhzSHPRQzP0qE6UZkuInoEApTHjQW/c=", "CK9QinvqQ5PXQN3ODm8PuBn24zPxInNzn4IWp94owZw=", "C3sLWtyOW4AijdxaO9kKEaalj6h6sh+va17mtHhtO60=", "KbJyDVcMZI4j4SxwxdkDwIiX7Djo95497J+JJCnfP2M=", "K10BFOFemlJJgeouOOBpdmFkE6lmFyo2XnAq64Gj6Pw=", "AvBOM4CKgA7VAcQ6HMaq/57QskMfERg27MNtufyvlU0=", "B1r95RTqltTd8x4CwuPFm4V+ErvvkYhwNBf9/ytz8Ow=", "KUxqlQ/PVpOoJByVfvc3yw6aKsO362GKG9FoTbQ1Ppk=", "K1z9RdiVqwn7A+5iPP8iMhAYAxyDX0vZRG0TmV68JwI=", "DJzEjE2Xmx1SZ6SSSBNP7cjBjmZ4xS+C4OrULflLw9k=", "Grgcqw0JElNInuWbNiWOfwftkiI5iN4q309DF5C3/nM=", "JYbL4kW2+Y055S05RM9uzX9rAv5RJfwGZ3+jrbXEs94=", "E7I1Kjjb/689Bt4/o3bt9bLuTlOle+ASKdushymk/gE=", "GqTUcKvqojVweRKdEUurEXCUT5KfwXghathH1EMPPyc=", "A9h3BWKRxBlCgqECizO72lTIxWU50l04E/CZLVY/s0Q=", "BwiBgyfkIkfziVvQr5mYp/OrJ1gxobf/osAmYJD4a3U=", "L230kl3iyO7feg3TbeDoO/C6DmZJRH1v0qjax9SxuBk=", "EzPJ4NtoSd0vweVt6UL45Z5s5w+YFfdOx17npxD/zXc=", "EqvInlFk6MGiDkDLpikg33jNDTHGQao1JrU4eqSZ2GQ=", "C5dsY5TQqf8Yw84jSlbPjZYlwR0PzoYyeEV8sI4cSYM=", "JosKTP9/ZxGTWBlrz7RjSMozLhry76dYtZ6SKhNdfmE=", "JUuBJvRSQ/FN2CEd9B/lUWs1lS1WxiZ4wUjnPNutNxg=", "JwcS8YsVGPr+CTZg9JLNvC+3D/qzHYpNihk0vmh5I2k=", "K/w5gaJJrqrsSrkAFyfTLU5v51WY7pZPyFzzDVDfWEs=", "FgYKF+GxH4Uc6rIEZFcrPXjVguoFABSEMQFIX2Wrcj0=", "5zIXoQbEAuTGwWbNnvH9KgsWrBy0Nka8HHJvgxd3cA==", "BLlZygfnGCygjyNRoDVFvXq2dvdAsCMxY36hQ0yFRew=", "D8nMlSIvknFc90dgECJeFMw48xQHHlDg87yexnSoqsw="], ["AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "FS+mdfM3IWM5qSdLl7CNdOug8xEQaIWJuqxd9z0Gupk=", "CmBWDBRbdxIRcfMtxtL6IvuJR0nSaGR1AB4LRWPd9o4=", "JAK8Icv8I6gBFudTUkBAOz562jJtP18o5wcWgNG1ffE=", "JncMXNoaFNQAPLVaySfWioQ7CoGsvfTRhxpmIB4zeOg=", "BO9uNCPstL1BN7K3/ngQC4Sh/0Wc0KH3ISZou5bd8P0=", "FsbU/hDAjGTyuxT8bY1lCwXFb8aJqT0MTAp5q/z5aIc=", "EGnP+b4yRfYGBvlMHyFKOsQ9IknnJdxX1FcW0G2QX/I=", "CsqXTmOUK/4jBpQWWk9y0YTUt/uKFnSnDLGc/WEynxM=", "FepmVDXCjSh739SXi9EnOSzNSGya+plFTpVh+pkgQLc=", "JUXyyyTHp8eva+rHXjTe7qnVMsAwgYf3vTtHsTOnRPs=", "KbNPpWU7OsXz7t15DHuUvhq/JL7rJO5Qo07hIVnpSxU=", "A9XVVjUIW00FtX94CUoTBADktgVI2pz1m5C6q45mQjU=", "K0doWS4Y3uDWILS7PsHwiSOQqRdxCDRvn8YR4c9ZLcY=", "GY6Q4rbwZvmb27IBJYBU6HWNr905ekBEr3/nPr0LBbw=", "IJwlgG/UAG2me4DF96P7A5kNz+CHN1FDp6CcyZrvFD0=", "Elz/cM4WoQ/1O+iyZoNCDIldNm+p03Y/FNN2y61FO3k=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "L8wehzwkYMGaqOoxh2pjwGtrFsVr9F6iOyl5NRZhwGY=", "JlWWIovGxDTSEaY0DEozHfK+Ox5DOu4mh1h2q4OEDjs=", "E81dhNRFj9+ZZmtPVn7pvCZjIj/qmDg9KWaAhKZ++gc=", "DkVGiYI04smYHQb76EYw2S1oVJeUcmlaKu1aocL8AY0=", "FerZ8b6TR2yiqTyDElkYQDuDXrlUfTzjGFbRGa6N8Ps=", "IgmgMBdpbjpzr8uXjFNzGuMYb0ujFe1dyO1leLPZ5Cg=", "BbNY1Gu/Cf+wfwavdwtMP2leNa9fMvRJqRIxDGkWVlI=", "DU7BSshBifHhFK2JnH3/jaUAD7Nya6iLbtgoRR6aQCc=", "ISonOR8azMfn4B4Fho5Bpiogdu/cbulPJsMOXrXGM1k=", "HPP+3wFjBrC75l/aUCNbwWy8sVWcPzTqbudS9LcLSEg=", "BS0+DVZr1Y2Al6jROJ0crzOi8mYt6Y8GUYZwdz90IV4=", "KFK7c3lfVMatycY11ecLA9zQPMEikEb+IXPDGxDv7FM=", "I7af6QL0LDSJBh3oRlEtNGrVTL3h1UmE4mtVGynP3Yk=", "CKUB5NEQ4FnqagYh0YvUNGrydarr7x9AJEnJ9nX+qrY=", "F/ZpdYPUNSBWLQCCk6cJgOLGVkEx+qtW/XHChTkvW8Q=", "G36OgHOatU+wHSY3ljqRYiuklAH9W5YeiS8AEHeBeIw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HK0HuCh4uMFTsCePuy6QlzMngmoJ/nINNxZrunxTrOo=", "CYhyTV9CR4WUkGKlUTOkM+J9jImn7HgBbbXwZM94aUg=", "LYGSHfVFc2FBZzMVW4E1tT9kEKQRcGcOP8ggSgvsLVk=", "Exz2Uw4xs1QbgxLq6YSVubVDWo0y015SR8U/MXClgRA=", "JspN8nCFbX2JUhuFDjdvRshGheuDL/CryDvi5G0AhpI=", "FIgy0UZ0tb1h9FuILQjOELZe7aSo2Qyu2jkhBSaikw4=", "GTlbFwEx5Llp4B2LzRpv1jEbM3XA29HjG4efpoNbncw=", "Jhex9K0v32Fbv4i0761EtqfNXsbixGmpRHHVo63Vd7w=", "DgUHrKYzyqdAUYxu1v+coIS7WafQ2X3s8lMPtq488kw=", "F27VLIqfP3vvPghMLlI1SWohd/NBg2TD7aKP6n8qZiQ=", "Gx3dPtPIJTbU4sxHgg83t3IzW/RTA1blkMaZOMGtnrU=", "E8gwDivFLI1MEvLNlELNutOCNaHjRUG0KidL4BRkVc4=", "L1I5vfDo9EH8Af4IGDJhi/G5YozIDvUI3NQnNCDK0fI=", "AhpB4eLG5JIt4styPWTLuUliFkKaOlo8DGwAGbu92pM=", "A4Jcye1PdSo6Yb5w8/K64KIkFocKj2kiBq7PRXC011E=", "AW4/Zoy37Ywr1stGh9Ed+9AqgmX2cctYp7szoDpSOKE=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "DZRZa+LLJYfkHdWsOHB/SnGN2pB2t0olZ5SaYnvMqC4=", "DaVuf+9lOnUo68sSp6AQgvfiMFS7+UjaZL8uwkUtCYs=", "Iu1EnpdSZgcZuNNPSWJ3LXx7COSIJEIETHOoqtq3LEo=", "DKnT5JhjBPf/KJTBBSGNq3IjkCc8QsQnxNro8p1myl8=", "ELASNb+HSlsuGEqEEKsBEHy/BkgEDtZjPReVCfUEEZE=", "EmIGFl2NlkVl0yIMvITN7CanZDxo98xCrGDR+GGKYgA=", "BIeNUk82LaPjqm3TV/C7fVYV8my3WHR82zBJBwchiFQ=", "IRJxA8YbiTaqFX63OFXvRtWwFYeqihmUeEJPPITZrc0=", "FdVDmrZ+hFofVa8s7U4Gzi1Xein+JQ8egRZQDRFoGZk=", "FqcxghLxdRq+G1xCL/gw8Ykt/XZzfHtJQz54dzWOLbk=", "JFV53nXlCJtPXw3hHVuIvF45X/mgdHotM7jLPjOUqpE=", "LuPXSeA4iJ93wN3IC7fNVd8JNmRxanXwJ0sZVahxKgY=", "J3tk7ZE315FPlEWWnDPbLw25WTjfPNrUbmyNSsmWeW0=", "KMkYHzWd+h7P5R7IMxuZnEvmEDAFduB9hGHUaGculXE=", "GKHsb5BaSQRKSSDQpKH3SpB9t1XR8G0tdVUcbptbtSA=", "JpWH/Enbi5M6MbxmeLQIehL/diwaGcNpngcDo5+CKQY=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HEI/72LX7TsgY2E1vtEvVsM7btOGa03u+Vk1tP2z/Mc=", "LDnpyf/T8azcI4Ia+taAwZneaMclALqa/6CR/DXYsjA=", "IAvkJ61dZEJVF4/7oCKlTluoEaoKDNumFZkYl9MSkz0=", "Bbw671UJud9TgNw/8YBqtolChiakQpOvWivDPf2YVB0=", "GdOnvn9CdVxJMnwIZfffAV33k9c8WgNvO+rfFgItG8c=", "H85ftRJWpN8+mUJS1HnIAGVHv6Jkm5/LrB53aZ8x6Rc=", "JNWygByAjHQwUoD+wdFvCiGF9PfqJwlidFR5fh1pSqk=", "G0p0SnYC8WVlHgYEQjWRApXVvkL15cuQLPG9CkSfRMs=", "Ihqg06EX8xPioqIMaSdhi6/w/HcYiAG5YYithRi0Ge4=", "LP9hXRLgh+fZARn8nBhMeQOr5EbiBqAtGt6ZZDHg8oI=", "DLxe8JQZp1W1mLFRehlrK6FVIcVeS5QLQQ5keldxMxA=", "JD5jjEakEL7wM1tlpeLfrvY+MDDZwgiU1D3VgPs2rrY=", "Ea50D5Ozy7EmLRpiMqTYwyqbTi/M5xYg38tUGmvzCD4=", "AU7lhlInfmDPnVwmkNyDuDPGbbD4o1JNnXO0t4hGsUU=", "G9pENnPbALpNu+CdFUILdy7iLZIaQ9I2NoKF1CvO1tc=", "LehqQ4TWfF5Eg3v0aQkTBKted9LupEIe32S6MyGhJxg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "G5F7hA7zHrfgpii8hffCwgDaosU+1Lp/ap4bJLHd6jU=", "DFT0+XR78jVSeYESrsZdTp6kJcJeT/u/u8PeSQCfiFg=", "Lr3sipLN+j1pCkQZ0ZKLS02T1fkRUhzwYUA0CRNGJzE=", "G3RpnMXrY3EVlgtfcJmDI8nD24JoRGgs+46kPDdWc64=", "DgmnXU295A1OGLiPY6zzqxzlDIAlKjASFSrDj7vapho=", "D3wOUsas/jVu9cdfCHiO3T51y/sglDb3pdDDrJslDFs=", "JQ+rUA8Vn+QRg446wD0lh/fjWMtsWEffK0J6bAdN9io=", "DcyCQdVtiAAKi3qpD2rzpP3/qA2xi/gV/3oLAgMrKuo=", "GjS3iUmF9NayFq8V3tw5jUujk1G9MlZRly3ipk/YEPQ=", "J3vb/HphRBImKvk2qL5wtH5+XTFTfYXs8VWsPuSCuSA=", "DTouc9GZh7uo1yJWAo6nBS+qfpmsoJ2aCL8ANeQCwD8=", "HABxj3bHt7tQbAm24VlsE3EXZoAi/KtZaYSv+XyFgVU=", "Db1fHDJ65bd17stxAJogcgNlwOSC/edeG8E3HlwR/LM=", "CGfCtP6oWkyrKUgk4idr2op0BvvNXaQbbg/di2mi8dc=", "HTk69SUDwKmv+fwdpBZiz5p2rX0yQIkL1FakdzGjW00=", "DE7+9spFYz1OzocV299Lmr5BIaYIYG2XGEXkfHCqXbQ=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "KA4uTZg2/W9DqQ+mipIgoOVnmtRfshyOOW3Xwmfl06k=", "BQ3PlaeztTWojvcFBMyKRE54+LXvSKNIYRJAjRqrO4c=", "He2Qq9rIQ+l3q+vBftA9WOrMlhzILf8DLfHmA3GsvRs=", "DIMRSGL6pLBT7NPfALx7thDY93cxnaZpUhFpbKzHwto=", "LzhTX8odD8tmVqe8n41vsJUcrCgecgQZHRJO4flZcFY=", "FaiifM338x6cm96wqhIYmmJCCz/Dr0wMzVJ7zN+zEmE=", "CFOMqRAHtK8XdHRQ8tBIrfu6atpJMA1GFjphQdDWCiM=", "IZNYoR8pn+YCuDNtbHTI7UXgrzQ37j29c8dBXdlU8ik=", "Gnrmf9K5X6SC5oz7at96X3AxcO9TbgwHyPReISMxiR4=", "LYoz3IWbQh0D60Me9w6ZVYY+S/qadlDLEfjP5FUhkpo=", "I+aGhqTmqwouJLBMX4nC25tokIFucwXKLJKpEmNncro=", "DCeYaEjvVXyGRXVLle2e3CFeUm1S3TacB3fU83hGXQM=", "BuLM6qIVqqv1jy5syzqgYuJOUG84GWRRMaH4Rs/CR0k=", "BMpFXiQqkcohQ64T0x0K0CRVKr45Y2xCFdd3JRKGi5c=", "IBB9Xvorqv3BnNt4dQviUHTVBS13MJIJ2D/q92TvRJM=", "KEqMW4QFqCXYrN0hXBa8UXD7TFRg1ud1IHBHsQn8PmM=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Jhe0s5WSy36wCDTftDCsN+eZ2nTo6mwsusO/908ygsM=", "JgVV/tGHZ54llGMk/xF/H0h9ddiBGq62r7KeAr+em3c=", "KdZrqh20gPoJdsInuL4rHf9iBpgLVDMZq45uRr8a8ns=", "DNa6JAXvnjMwNsdWfg42gQlIm+V5FjPBIEIQbrDdQ7Q=", "C7bvN0oQtFOO8c48DPbvbIhdvC9EmJK/0X6C5/6YkPU=", "KU52stD8O3Muw+2Pc7jhxhbuABK2nWFBekzV8Y+JPAA=", "Ki1HNJev22CnAIx9x87Voz/tfFQku2oSmcJPNz5/Fq4=", "BgUzZ26Wxzo+GD3Y9YXHhCfAy+mel/is2wmIid8UOe4=", "BNOtMxUGMIU52E3nfWL2y2YchwvAZP0zWcxxGga69OU=", "I0RMUw4xiyJBj7ylJ/v5//DCyS1iPzZSd9Zax6uQBYs=", "CEoHNQbaY/ro7pCJZdY02ip4kWDx/3P69YtnblyRS1I=", "BsEBivKrG2KUQNUTpJceYrLdpCIz2t7tEORin7HhXEg=", "/q4Syeo0u/OTc6o8FZ5VPc90Esrxcmmmybfp3FlK2w==", "IfXyOw4/RPh2iqHKNe3PXpGe78nZ3UfkTvzJlpTlG1Q=", "BiCeIDBtX/KuREO//tCUiyurZUh2UPHh+VbJ5UE7Fo0=", "DpgXR9r23m5r5g9+zCjoS+Dkt+jAetISj7zBLgxwlrk=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "IIAvi6SpIkV6Gu/czIBKnDS4haHp8P2URzR5x05q4C8=", "AZysKtp2D6FK0DjSSC3IZmF3KuFd4OvmoadnCCQyv9s=", "LEhEZKgjxDBTETdVhpYQsW5RFvK7Hz4CTWXZIGw8Y/M=", "IK78nNhj+Xbn5fYBECFYtXg1fjByrSLmgChkDlUTtHE=", "ExCmuQLTc2sKUKMgSMgf65jgKUO9sScAxxS/ayVfP2w=", "KKLkewh+mCjqUmglrviotNWjYCD4e0Zyw2oLO+oS0wg=", "LtrMCqaWYaZRAORobkZ6uk8sQw9hx3cH4K08L6xmwJY=", "I7gR6K9OZxub/Swtg6AIgxCOcE39zXlE+kDCDnLjWa0=", "A2z0hgEVIpzGGHB5a/tVq22kWj3SBOHmavOXAY80GHs=", "HtCX/2UmKDWQ7OcxtyW59zSn9RbWqLHqvUEgyND85l0=", "IkLZqMk0vQ8rCX43/uoJi7UACRpJa/aJpZt5XI10abY=", "Lh2/MRnqYiSSwfFdzlrdzeyz7ARQKOmtaovMyFpFbvU=", "LQNPtVJjX6a9Y/XpHujXv7ii8bo5UZChd7K/GqdmQrk=", "ASyOb2Ie2YDAfMpL7xevIy0ywv18s/y/yXGUfmbs/y8=", "BUi0oxurRpKoWKzTD+UjxC6PLc4Eby8SGwyCz1vTBrY=", "BJhdO3/BpLX7xw/TcgWr4x4zxL628Td3lnrF/Aej3xg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "F2rV532/nv9HEwkG2fKVvxE5088A+lq0K9PhDTV7zaE=", "A3/DwwI5X8qXv7299f8U0fcTAAV+fZlP7dGfLXeeQbQ=", "Bnt/pfW2QO6lwRc6pACEwok/C2bE2O7fnkhETeSMvYE=", "HvUKmFEURVI3S4sXXxoGm5knEzfCmpSUUUDrfhqVYNA=", "BKj0EerpuW/O7jGKPYLoOTVLCZnoNUyma/fxEoHIZbo=", "F8kMRHzYPvfVRyCcRkSslcwQF71lNg+vWKjPtSELyJE=", "KzJMWmkUagsdUCk3yfF2R1fUMGX3w8fQp5eVUjVLP5g=", "DNCmJrhg/ME0ZRNPAVM2dAzvhaqRu3yRnU8ShdvklTw=", "Hyuq3nIEN/Wvcb2CbofhVVUqldoRwGQCx2yMV0cH3os=", "HOLM16QVMErA5vGyZVkDWflwVToQv434WlXu6/XNq+U=", "FJjKMfiIfM5kfuUvtLOhd6PYJWNUz7yD7wNJ/jaF0ds=", "Dm4hDxj6yhZ789gr+fnljW4JTAO1bcvSQ/pzfg75O7M=", "Es9FC1Io4beCNmWljBBas3+wZNKHso8RXM0SjK5+RAs=", "H94amn86lYg0gdJe2mAiXz3W9nsSf9LbaQqsaLtT/PI=", "FrLEsaQnb9kNCAMRP9qWvQF0kdWSEY7XIbJmClV2sZI=", "MBriS/0RaypairnAj+JsuyDREew0t/e2KtSpXJVTFDY=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "CIfylw83gJm9gSljb4RwZbgbPMV+Ip0tAKFfMU8bcFs=", "GbOwHLaquxOQH4+13BSQyjYChPJiZy5/DTnbv+DPXg==", "GzpuMov5fEort7YkUdjSHaIh2fed3h0glhpXMBkUmeA=", "Fwky5j2O0F1rZkmfMuYmG4ABvdwMoXYIG3/TX5wqAZw=", "GJlFdVXrVYH921E0BIhWnCtK2w5+bhtZo2KTs674NeA=", "AWT3pG0Bs+0mz3koDWdVhK8D71Mv/Kmwqh+kwEarlyk=", "DqL/3KvpcnWIUmu/1WASSV8dVrBqVzdyYHPrmqcFKqo=", "B+y1gJcZPKY32JzXCKZhDpv/BW1dR38PC6/y/JItAzQ=", "D0fmAegu0XS3FVVM09VSloJRGsjf5Iz38szBCTqJLV8=", "F0955CRUKw408Pug1kUVOapWxW9y/BsAYVb0any3wuw=", "FgmFARbf3iTXy1UQkS7B9LxBb5peV8u6jeY6JVavZi0=", "EKtWW7nPQ2kU8hQ1K0i9t0V+ytoH8JIVyVIvx5cB6+0=", "JZA1OcVscsht/w0yDkuJkh8Xe5vmmuzKnlLagRdetcI=", "JL4rwHJt7I5+Evo6GICCEbMtByX01kFJEcJQIj/eIbw=", "BVIklEcuzjXoDKPvNWNujlJlVjy+Q+UKFNd+0Nn4lNc=", "Kp032bm+wi7v/+waz2otva9QVP1FXDAKZ2MWnUxMJQU=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "D7eEJDw3ICsWSKeEAQ1nTyzMZi4+ctyXwedvD4FZSKE=", "CZPmqtJMTSUqxTkFkHyjYQ7ypebkjrPadSvMpdypc6Q=", "FfqyULY1Bu8Lb75WWxXKM3UEpZYXdR8+kedYkejy+go=", "AiuFG6LXTMB6Nvc87D9U8uJPel6lS7U1blVwpOVe0fg=", "DMKNVX/L458tpagx+XqzHUyXSKMMHAJyhvR2YPyp/Cc=", "A5LLKKL28+i9b4ad7jTYP9hGJfZY0sawKmrOxJlA02k=", "IjIy7ZGFH3Anp0E/I7iJ9z8Y8g6pGzCDYLB0JQ61sTM=", "JHUCE5/lpPzOr8R6sINfqzd4hmoDh/Z8DBFzC3CGtCM=", "BXTneWMEAxqhV2a+W0GUhtty8sxDeY6Kjuat4V6mTLM=", "HRg5KGSFh4XRNLKEjX/DLPkdpgRh78AXMa1Ju7mc5/A=", "K5J/HR6s8O5dMkb+yX8T3bm6LjRBmn8P4VH402bfSKY=", "ApyhlTSHZMJgAHbZpHVQi3+uUtapySGWJBrD8I0JBFk=", "ApGTDN/9CsyHO+NSYAoSpqoFbadiHPMyTnY28l702QU=", "E+blh3kxL9ii7ZNoWHteTCB8uMuZYh9CVKFwTEFHdlY=", "B0xvyVdRHnKH57YGXAPVWrGYgeLKurmIvK+ZfZa5CAI=", "HaAVD1pxBMJUE8g/HtzT28xJqRiBr4s4CdQCIbvozwk=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "F7Smoi+Q7FV1oxtxqlBbcMwZq8D6vtzl38cQi9VHLtQ=", "D7daQTIJ0epRG1ILOtTpbdClSOxtXOLemw7fr2Z78hM=", "ByKfoS5emuxaJYJJs2Z/paGn6b9pJF79xmoR1M+dFus=", "KTRFJ8zHO9auAdSrdtfYIFZD6MOWKOWXWw5orGR+fdc=", "LgaBX0ZhKNWw+hMlqW1vY+UTw8NZD2EtAfDvAv33TvU=", "I4EhnHnSLKI+m7N89/PagSVRDBqdfp4m0CitYfO6lKs=", "9ySHjDeLI0pbxP5vUcAAaCzpVyGvpMgCSY/19ONZnQ==", "KWGspMntmdzF2zOQKFeukFr5JroES5PRuMv92C3nLGw=", "GmYcU9h1AydpqKif8iSzcDhk/XetuogHb5UHiE6o3A4=", "Ag2MhKd9vxh9hz/rSSGF+TQb19INTILUxYgAkQI4mqE=", "JzlEpgvYHzwBTP+aXhsdmQeafbY4YKvcW4UBOMPtib8=", "AsNIPqnoczvC34YF2EzCkDoQpPZ1+APjMJC/G5bXtvU=", "LBVw+ncayH9sHH3LD17+Kui86yYoCtsR8VZb2zI0GTo=", "D48rytorFYB9TkAGY6u3rSpsZTvT4nNS0qoDz6zrqj0=", "E7NWMir3v37YkoWcNRLyGDHSPW7Ua/TDUUdiwqRozd8=", "Do/8RFQisDUgKutFkIUpjlw9Uq1XpODJguS/a8Qwh5o=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Jmh4x9uz6/cluvCbrWJEHCoFqMrIONY3NxvLcffmN+w=", "Bpynrqb+Je6YQDHzCLSR8qVQ5BNHadMN03TAyX7hZWg=", "GQw73Erla5NxgG+ZxSR8f2BxzPclYxxvNDUHWInzSVY=", "HTJZAt2ocpCgexFfNnMgP7sgOc9HDyKYgceG4RXuars=", "Gyk2prsbIhqiZ86Tn5nCEbdYwhKPjVRMTQtcvGYPzVQ=", "D5//TrfiiEW+ang3NvKXGTKXp8wSyvXepvB7Xs6vYyM=", "IOmM/LZXsfSckqBpylAfieltc84Hke3TNqf14Snl6hE=", "AV3fOC9blFhpr4o70aAwyY2DUOc2AKoOjh1O1emom1o=", "CTql1OfC4Lh78RNfPw2UtA1Zuyk6WCAxrav8Koqxe+0=", "CD6gSKL6t67TGoCQIXT6qfGWC8JTHRjeZz+oc/5oggc=", "BISVZ4dK0CUzhyUkBvLYhgsmtrYF6YyHSlhbwVfFejk=", "EDFdBUjG/en9h6tKUj9006XHkeRV+Qw0s5lQP9lmIUk=", "Kbdo0MHAN+LCCxM+7u4BcWbSeXukei5kdZXl8LtDPHw=", "IHK13RAoCHQU02xPy4RdTk5xmIWvj0q/qzn6QE/Gjm8=", "FDQXVAklTup8m5/D3ZMxRAPozdVvnNSDSBmDNMcA/m0=", "Lamy6xSMymeQ9LEihv5WCIDXXma9TGTvjuWNdVHKVtA=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Fr+1/dTvm4HpIzbvAT+EMHJ5YDM7drXrgdrY7yIL0oQ=", "D3RkOMP05hLwiKQROUBhm12W7sGAmfW5ErgW/KzQOsM=", "JfjYXmECvBbPy13+KgpoUMT30EWjYUkI0zJwIyDNJEU=", "GaIwcPivoIxKCi6KEGfbROlYR+XvUzcFdDfraLAj3b4=", "GedK6mV/1CBjIt4QG+VMCnDtAB61o7iXqtsXjO6YMDs=", "KjLp9/dmFcW8LOoBfh6TeZfTPQEcosVD3L8IZk8kdgc=", "LrL5eCtRA8zichDlTG12CtKK8AojsCUqYI7gU2UlmQ8=", "AyTLt/8WxGP9iGClxnGRInAvjwVfch98KtUSHQPMtqA=", "BPuSdD7tUXfnpO7BkX1Iukvy35hk9Hft2ZhLWhs32Vw=", "Iy6QdC1SUe5z4eVe3kiUIapNm39zHZIJ4YrncrHb8WM=", "KIiwKHvQUEJcMkG9fVM2cIwdJBBDTQu4oJQyBVJJl5E=", "Beh4puLctfthdjRfuDDK9u3wYGGkUulNHUmoYrFWNBE=", "BgPnFQ65sGycC5SDLVO/rMmOJjhuLeAEfSieREgzMc0=", "BAOSuHgLsHHSrPSSvGxJ0Dq2an19FonxakcWCSPWMD4=", "JwBXhujRy6lNAF+IIfVkpCUAVi2pmbTEAWP9FdIKcYg=", "L27mRWJW30t7RTT5fccl332eNZqK9PhANdterXLYVZQ=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JJ0uOnLWe5/xwS8A0uLRUhOyw9U07h+n4HJiNdX4p24=", "Bmr4HCcf2yDw95R7p2iVZ/oKzsjodgMRsgBxOjy/KRU=", "LQfzPOwI13KvyKhHJFWD1g+6czsodOPxTVl3Cm7swdk=", "K1dSmS4ZaciO8r1M7ny3TXr1xzssQ8FI1HwAlBY7egM=", "F+7X8dLGxtWp6tSpOYcRloSGgrwq63E0CXaVmcb7mdk=", "KwRD592PpSYprLYMTZ9ImjtIX5vaowSczge5BJQUDJk=", "BS6SNpzEDRwM+gASTqKckouFx7ZMG1qREcB6M9KM23w=", "LVkK01nz9tCq+DF8w1ti2SsFsPXGhcyMOjad5tHRypk=", "KYNnMhejOI6m7BdG5i/QwdKy13TmNWSuJx1326MxgX0=", "DVzhEjs37caF6MI09hjIMOh7G5XBCKg82dUGXOACEw8=", "D5tpJW0NDgg7oI/fG8xzqVt7N47eNtgGbLAkuIILsAM=", "KQSQ9RI3zXqzgk8gV6ei63JflGRCx5h/c5LkyF6NvXc=", "K9HJIbJlX/uZ5aXeAl0IxpL85OV6PEAf1lXi0F2SplM=", "A/7Av0HuGiwKegt85zBTQxom0rfbktQqQZEeYSnj+po=", "LWIz4IGBo8nbCQF8AWDC7zWROVE5kIhLru5SWyWX64E=", "D7yYuNOwtvK46x54DbFtmO9dS/TmXKUY5i3HL2k1RKw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HwTPHKT22zDoQ93Kq9TMcfzaObVVM9sai2FIiq+qunQ=", "Gm9qeFg83apYiYMn9MqOAO1yndQcRk/JqwxeDRsum/w=", "A+cOgVc72lxquVO89BWBz+TGXi08BM8ez0OiyK0lDQY=", "E/tbbI30pSV91nt4JyfYp9kMqSxdmnVYR6HTtrcc25A=", "BNVFlcJbQVNtHyA+GjZ6zaj+7TNpU3yiVX9dpJ8pDoQ=", "E2cdjKfsuT0pyRI7ypYQPiL2j8WhaWj+kDwPMOi9C0Q=", "FIapqDAt83cdl0xWLhsDuW2v8eH8a+voZZXTJgioW9g=", "fNJ519RJMeQ39ZvvUCfxTklACwhH9BF8diziHqZndQ==", "I1hobeRYZH3POHPhh+qpQPylKd2TmNLrACoebwh4rIs=", "GW1gzY3oIRnJNg6auWsbwxAp6mvFqciRWE/r5JStXVM=", "Hhjl1whwKuxwhnJYKuvPLk2ta+AQCn2E9IIuFW8jcLI=", "GNCmEZR580xBrM6aEIbGsaNAo9TspL+lYeQgXu64Q48=", "BB45dV7TsSlyRjVR9B1fFzlDO5ZrdZAUvbnSFK2ab8A=", "G+zZjRkWy6q+oggrjn8XZfg48jNxIbqoluQ3vl1CeLw=", "LREwfSGXm2gRmJn8CLkeAoIs+3xJzoeKxYWEkT1siik=", "JLfWnq188cTCBNbT4jNo/UDbDy3wCkqDiFV7YRCRdTg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HEFAgBce9DU17+2cW6vSJ1uJ5bF187cTFPbFkEDJeAg=", "A5eIm4ARFgR1u01tM3k1G/Xs+QgAuc31e9Ou2yEFPM4=", "JMpU8f2mNPm/wOObDU1qc496ASiY6cK/pKQu1TPlKEU=", "FxWY58qiDJkOQzBtBrL71YeWGaxjkE5DlaU61dYOYMs=", "MF3aW4ADwjbKHXJL6wM10Hqjsq3huiHFnddj8wGbXsc=", "GrLtB1eBILOZ31fF8QmkDkfqqVbmamYp4Xlr3nF0vSE=", "KkeGLS8NBimGPIeK1/599ZK6f48/lOXlqFrKOVgin3Y=", "G7yVkcZkNtxc9LtWJGhYRjLMkaIAsfCOGiiuYeXDCr4=", "Jl6XHJrc4T3TJLyWgCCCjMoGTs9HcmirU0Jl1+Xi6iE=", "HfltdDaqKRjqCCVGqePhSRMPuuZ3ZZCEbgYy81cGV+E=", "EKjIqurqBBTYfAwVU3hLdE/y6JZZQtOCjhTEhPhNJTU=", "Bj5JAdLWGXgx+UperZsFiEetZ7zYUU7aRMppoLC6nBk=", "GvAEh96quiUR7Gu6NLjySKUQaxHWnOvib7XzXSdF/uw=", "DOsXkupj4rrOWzF87/RZfM8wcaZxmWEjlmUOje/qZGo=", "B/yWO4rDcGQ3nVplL5mQOO5KJQ4OOUjLo7iZhAoRk4c=", "F6pmPeMyJ6lHoA660WmZqQW7KXbQyZeppan9pmkHVOI=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "J+fwH35YUN7P88j1w+5TlR++B2ykGn4YB8v8S47t2mM=", "E+nAkZD3RNx1Y8V43PQy3iUit8f5lbKICVfF0sVLJ+s=", "KRza5yire3LhGSSMBkbRp8MFr89QydwcHqrNyWYNIaU=", "LfJo2gWSVbLZWfk0vCF3gRCOYXEPDjxGBBnRHxNm9F4=", "lZ8T8sBLF+eVCTtAj1kLhfcH5UeV9d+Au1ezXJlNvg==", "LYPbNp4rSISKJ7VVU6i9t34GepPx8o253mxlsUgYVY4=", "LKxzA88EYvIcTBVJhP7xc8QoxHIV/rLANVwV3k3GSuk=", "AfFsOxdJfYfGW2ESPRlUcX//GPIcz0yGtK4nREtTUiI=", "IRqFewbf4t9iHTqJpLwF3QJHrdbOE1Av5/o35jiI99s=", "G+vQuB6mz4mRnqdl6m0E0DXXPPd0Xqp1fO3+Yl0QVzs=", "LLZ28MrCPNgLxA8yadJhD73rfyD1p01yIkUlxuP/aek=", "HkeK1lNfHsxXkFbGrGrIdE+ONSCbeggfR6WwwzvxRNY=", "FmnHIgir1K4lFYyccxVulmUE37tqS/m2/jeh4QU7BJw=", "GKlHcfutviaPWMw45I7oHjy1qUuLLP+oytr3Whcd5pM=", "IDQRx+CLvGoQFkRRBisZ4THqUtAtwViNNZHIq9/h/eY=", "Bs/50j0zG+JFyj6g43NVEyo2f1zu39ZMhC3Jrvl2Ue8=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Fnlhy522p/HiU798fQcRvu1p/HNidoIPH334z9EwW/U=", "JRtBPjA5zsCvVK6dDcesXM9f7rnMxIKkpOk99d/26qE=", "IkYbWunEk37/bdDCrVR18gq9TF0TqjiU8gzhzu8FEdQ=", "DTyMsMpADVLz65b25AOu5TyeIoOhmCb5t3DVJw0/IxY=", "AU/p6tZRn+vAEIj6tWvdeCbDWVIWnoxgeC6nRgNvzvE=", "Cei5MCxHC5RrtOJLE7FpIma+g8uw+DNSfhlxq8EWduU=", "Cqc2umgXZAs2E85ch8rI9kunTsI/j1x18Msd0u5VLwA=", "GVxPO/4IoGTxnW+7ZpD19yPM9oUdsB5k3OSbgmQNYk4=", "EL+W32N7mSapLv6RpglVAdsQsQubggfnPuzDFH374Uo=", "BvnqWOAul0RfcE9ovFNbHZ1uy81NFRvyv59rrOmFwUw=", "DbHaWcsLxwr72V5CiGGitwi5iUdJoqiOYlIKdnxObUg=", "BB3CzM8QK7cWgnaBP/DdKjrln0813oqhQEFgvnAdVmo=", "Azsh2WpX0sHUTBSCKJvGByVKA5X776O+olmD1uHXCJM=", "J7XfS0veMtk0NT5Y3CFNAqg1MYgE3bgSqB7/3tZwaYU=", "FsQ2gS3DuynGgNgbvaL8lk/Azt6iz75PnwvKdFHiwmo=", "EHWrAGnoAX7yuEuQNMDk6YHeAJRA9X/8cqxjNiTKq1s=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HxWMbBBl94tfeAUg8DxYRGX/ziatGDpQ4R77lWqO5BI=", "C+bObK1RtrwUeR8B+8Yr8m8gvkatWDndw1avryTbshk=", "ImZDdGVTR3xguZCJ6q6sSuZLMIo8Vqs0PlWmF0kiMGs=", "LoKzQSrbiRn+pmqOLA2MX7Y3aURygiS3nuPtvlYzTi0=", "Ja9t6vKRj+A+2zmJ3AN6g0YQ1pvMNAnhPn/WV7bEBPI=", "EBaMS3ulyFAIpPh8AyXSOFYpUTZrdUJZwGQC5pQiOY8=", "IEQVVazZTwNzK2Bqy7Ja+g48w5x/BgIhTu+0l7SjQN4=", "IAZY/AjOsls+Hs7OOYm2glRtQV8+q2WW/X9jqevK86U=", "CNu9laf+45y4Y5h/Sp3YxA7IwblPIXNYGfqdb8UkVHo=", "FnmAKnDdY4BlV80tjbuHiKkd/JgsZy2cLfBO/bEsaYA=", "GLXuRsnvMLpGtcJCvd1oyKH4kRIuxi6woc5ODv1Agpc=", "F2AEJkjTyI84ALusMsr15f1rgI9Qr5HMXYNPOqm9ISg=", "K8JKoX7yLrUnPmgSoOWXveHLdLZfw1rgbwk1jZZrJD8=", "GHGhNSp0v7c9w1tyRZA8GQahLcPZRIZnIlsdYag+jMU=", "Ff/swJrl2rfiNWRPOMhK9apspC8tI7ZL337FNvnn1fQ=", "LJxNgXoTUcw/ZZ0QRTWYzdy3Np+fWXj0QCW52EeTWlU=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JY9rcXTiYZ48lNZasQJz0hDdtG7KBqIvgRF/5fArw4w=", "B7ZVgKsovvrRZACEoSqxG94yWG7ThHCTeYXi6gfuvd4=", "IlH9HQpb2R0/lYuTd5lr+29+d387KjvsVL79mhm0KaA=", "Imuw9zcEY/cFuZyt5Ep2/NY6diqWhfeiVNm/Z9lxHRk=", "ASWx9oduLNRUjv9abqBZjr5DqgdIz9xTyDmHSJyHHQw=", "DWQAQ2+HSsQLxOPjkgQ2daj4vQceOKxW1jD4EKbDgrI=", "FSVXsPQk+RiOfIFuNvg/+b5xq/+nyuo4/kKwt9JzE5U=", "JBmSKi05Sxg32Gh0U+7ZqsAFphKK6DURCiBM1XZj9OU=", "KN6DLlXFOjdjlhhRA4isBZ+sEG0oMzEe/UUN6osRLW0=", "Gem8untV5WjJg9eXRgdU+tfwTDmk0Hig+qmGhVfzSuE=", "KDkIyLtI/uZKyVXn/LRwQP7kft14EOXqJuHZvqM34ac=", "Jcjqdm+uXmoaGiCvSxeIEsDj4460xcI0Cx+/RGjJvK4=", "GM83ziXvhtL3ya7vDnnwq7AH/uYiLplSyfc0SAv5dKs=", "DUEQaqucppaWquohhGIvgU/gh7EvcW4trlgGl3bhzAI=", "JaFGLx1aI1Phr5OGXn66pXO83SJxsmhBWwX+ETyIUdg=", "LZar9S8d4W1u1tTZJ5A19b9bgldU3CHRH+uU47FwDLg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "GOVhBQLSob3KLSzTi6q8n9ZByk6atL4jetMsctyIDIU=", "K8KhIoYh3DZcrNfVYHuTGBtYWEMHDBKnq+mMLd8LjOI=", "A+V7fnuj5OPKzLZjQWvyC6ffn9X6Jdla0plwpgmLXUc=", "lb7uB2uN5ox5RjbBp1oPH3nmlOlHCvZVfdCnVuzsSw==", "IGPQ3OfA5Ny27ag8HS6dL4+30nVLKhFsgKX84X7L37g=", "J5NWClDLc5UwELeIFknPA0gX04A0EWScg/595sfd3SI=", "CSe4FhiFsSNxvtZ0Pn88/04mWW8mym4Q75tigkxtlAg=", "IeVwzguTEC9TxmIcgTpi3+8ERE1nFH6Gvc9tiZghdMI=", "TaKruCma8z5JfnYlaogpvy6Q/dbhcK6RUU3SX+8kUA==", "Cu1vgzhMXBs2eXIj5bmODcfjIrIF2ZRq1ZvnKlZAGZU=", "EEPfE3WhDKw9eTl+JXLC3lkQybDPnIo2qFlzYuLK0tc=", "ECtSJyhKytZlDeCUZ3pRvOclxtpvwQQ6dmjpOYKaVZM=", "BxuINAHCW/3Ohr5Wq0l6EIFLsZgExXg0tO77aZCwyko=", "7nBthZg+/hUHh0j48ZopkoNzezOjx6dPPBDS6Nk4+g==", "Hj6g2RRlgSCbcBisVmDiDFAzZBwQHwmCPV8wUiDamyw=", "ETX513L879Bzhbt8i1/Av9OMHEGrbeLajIs7s9xroJM=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "VYCTL1EEafcAlsgg2WAa2H7y9mmQyObrmNam394npw==", "DAcqo8E0TlU1Zhuq8IVXWbJIm0AyARbsCzBPgUAqmnM=", "LF5g1tnO5Q84gCNOVLORqrE4yBVQ/7nPf/yD4Rj7FhI=", "DqmE2wsp0M7u+esGUTETfWlrTcvpsp4S0L23Rzb6PLk=", "FGG7SyloUavnbvHqDfVrVVx2h5lgk1MH/Ol+ujGlhVA=", "IXgU8tiJtY2XKKRu6+Z5dgAi4dVkxQJPa3dmfToxg4s=", "LjS2OZGpiu7xFh+cAq3eiW0b5oXpiHr17Jv+hF0vvSU=", "C7UaUymMu1KXQFyGW27SOATJkmMZrpxcfBziR42QxZw=", "Dw8a0EjnuT3ylhfWJWGsIJtIj1gjTzRhKG5ZL2Sh3JA=", "JIVmUfbGxyzNsp/fH+CiQ4gkfF27iXPByH86kz+xo0E=", "ATFh7Z1xMwCL+5Pu30xmd0TA30zuDgrZA4/Qlo9yYIc=", "H/iPKoC0B4qQ33LXBnJe2eRQSI+XX9AGGWII45nY3sE=", "LDAM6SYCeaZ73tlKyvElt8mMwiCEVf3L/3/pgWXB1PA=", "GAFSM0oBXD59QzuS8O0jZTRbobPdBuVW62o5tFuSS6U=", "FGkYWUGzS1pPUpwbWnJN+sKKqYyPgw+LEEXsxlt4f00=", "B758O03p9T5U4/T4cc9i9MdyDToue6zLdJJPrrO+34k=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Db2BzfW1S1NEhcJuzylijp6AcP7JDDS3gKzVu9Tn8MM=", "FzXtn2/S6nKAMITabX4gxHNb895oFWvauziI3VAEdrU=", "MChxgz0DjcYamE2njlA3I0x7LxFOSVRRvTiIebjuFTI=", "Bb8yaYJ24gdopU+b7UiTW2dKyFuz2SUeEHUgfB7cAGA=", "rpoeCu/9QxWU5XRej00+WAA2HoAo6gtLqYQZ+w+1eA==", "K5iy6nV2YhHZoSXbjm5/tKkTgSIWNlsfbSZj3rHwwZ0=", "FcDxkmvWAMlLFe4cAOD/k8fei0qTUCO7WcZk/gHzC/g=", "GPhgNsYTaqYF2grT1CUeZP8xzUNtcrkO5dMVevbXnkA=", "KFQoceQHSQIiEbJE/OC9FghnhlIGyHP2Zo7FGkKfmjk=", "JDIlnn9HQAJL+ytx/GlPqEYJcf+IafpG9Tn6+ZTSPUI=", "LNu7H3Kda6AECw/mPgqy4koe0F9MKUfypNx41Jv2hhc=", "H31sFw96g9YkH77JVDayBHgYSwL/f0zvPezMktpks6g=", "GObxaGItRnm2V5pbvmQZ2Mho1nKUlE+CRqgUFbMOYRk=", "CaPlKk3bmGRM9KcBdmwcpa5KNe8cEaAX3WqhGUX6U9Q=", "E2oDGCMwSrlMk+O/ObGJ4kCoHgpCtgYOOMfCBkuBSPs=", "DYLQyQxBxB+yTXFgyPFwjCWCIu8FOaJ3aiDHQtrgpiQ=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Kw+YslW8n7r/xLCd/kI4c7q/6xbGSjHY97pw2xM+hCU=", "E3/8w3SuniIucz/fnQxRWUa688GurKssYhgYDuxdakg=", "DmoFbpLHZ80fyXCzOPpcc3ckBDLmvUWq3ZWNSPFdYDM=", "JkyaXG7acI2mD0Af8RccnqJ5rxfx3yArsnzFZ3OjeFM=", "GGJhjUq/r54Xbf8t+obxuU4pHuPgLf6oFmN3h+30838=", "BNDSsEK42XFhCzuUM/Nz1pOjBvEIIYajWo7Wp1jgwRw=", "CIVLyvxfNWUWst9G9ThqEW8U3hsZcpAxbUmGnubdAYc=", "BLhpbFCdlVe9jMYifKoJnwAsUQH/bVt6TkgoTjGZJWI=", "ElxYhI6JJhFy+a0lbvbLdVhB0pE/LuKunWj9Lu+oTZs=", "GB/8mBxUd4Uy193Tnt590+VNZVz+ZoGwSd9thfdkOf4=", "AZjxRRthGXO+d8w658dEr3GxyU4+hwVrevHpSeks7lo=", "BMn4hf0baXKahx62EcSp7x4AmwYFoMw777uAZwG2OFM=", "Cq/q3BXd3OayFOOZG6vJOvBOPG2wOuDhQIpQPh7sNDM=", "AiViLTWQKEDtZis9yUgNlBVF3xDy8agZkmCmUBjXr5M=", "IJ1NFOi5GS4GGkLxScCdDJgxofAsNUEvRWPPwDME/5w=", "EZKmJHgKZjPQDc/EmrbKzb49SmL2x9ir/2CUpnhxTyo=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "AjJ47OaNBUr8U8FIkgQADXIMumamOEK6cmnjXgu8bRQ=", "CRd+2fPzNQjbi+jxW1M2Cv7MwvIIvHFDvSJrTIhXhq4=", "F1p9ZxPhb9s05oBgavUAN6x4QZulzw3s4qul2EkYSXU=", "G9L27/PyRIndSS6qur4bDAm1Dpg2WMHa+yvNtppyQZU=", "FrU7o0xSFQE8Ji1iAHg3rhy/rhVbx8s9qEC/lFvszM4=", "LAYhg9SdL9cUBUhgfoarSHt6b02gEJ3Is3lVyGa6kck=", "AiRRq0ecCe7MQIFFuq+n9R+lmLP/LQVzZZA+oxerkGQ=", "gvfj94muZXzvDzQsmUlo9H/tKSYtQkKWTg55Pt0q+Q==", "EROdKZAerq4l/opriycGIEW+IYvjeEQwXKO340iwQ4w=", "DLsujCFs+nd56AhaGosk6hymRGpmS0jVdqzK4WwOErY=", "BI9//a7AohRLKKAP/rW2EwA4b77ueSvjhVK/yDY1Ybc=", "Dgu6JNeBFllFcN2TqTLIK1tnMM2hQXD1i3MQXin9Wc0=", "Ck3ANv1Nm8JWHT0MNaAiJnDFnloGJuNoEbVmRrNFoLw=", "Gh8vh7W0Iht2TkSmiryPVvapeTb8/sBqMCLOAKMBc3M=", "HdcCImtrMf7ejGuAZ/1R2oGtW5cLAjh1wa5b0tVswpw=", "IsQBGOAYY7WG1LybJkDE9skDQQwX9b/8cDJCDUlNUFg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "GLQ8s5nRQ8l9T43p/pxKr/tt03hdnOXcllG5dbkFQWc=", "EsWZ2yYhEb49mELNOfOm805Rq+HBvAcR4S9pw8yXPn4=", "CLtH7no5Ycu5yUposszTz0rJXog291OK3f9V+Sa/SW4=", "L1aUkguWRLQ5bK7BtMQVDrRqGMyg69ccS+KM7bRWs58=", "Awe8lRzCydTv+TbrYJi8H7JSVHKOOQa/CJvO14JvsTc=", "F7z6mO+2ioI2ojpxbSezzEU5yOecqQJqm1QjpkQuLto=", "FHh+90CUjfwGfqT4G8E0ZFP3eAbmvDnj3v2vguuVLpY=", "JXogGZjlm/s0z1SU4Uxl3D8vrU/Mdqqduu/QAFRGly0=", "EqjZndka59yb2JK+LHLZgKtkWdOm+477lqVN1BSQYlc=", "IAvyCPEfekpN4IUYgiAXe1LaJw/KrdI+eenoedzjZME=", "Gp9TBym4yjabHV5pN642XwHd4GwkcivxEc5MpcdkywY=", "BlHX+fvKEGxOiztaHOSLLba8Flf3rtKNlS4ocREywOo=", "KjMWZIy2WgkPD66p04MjNFt9SpGpWHqejRyuYyiW3Mk=", "FVOtggVqjXSzu4C8ztand57rp+rpI8qLSSub2ugREO0=", "EwqhUugTQa5pUuZzKjFdFWfzqxLN/zhEnkLBjuVeOIo=", "IWLJyGiACqvVvjA7eYNX1FMPVuDYyUyZ4JV0AzeRHMk=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "ATjuNJpRJrjFn/zAXD5YBB1SD4y4C+PbLQtyr3ok0JA=", "Llk2TIMepZOq1f4U2nah13BbevlPMxq4U2LEtZQ7i2g=", "JLD1lFxUP2yoEmeC0jN++NyTCht3wOEzxvqU+ioZpGI=", "LY8pxkSFODSo8aYaiWWpiQ/YRgqC7SUgqfszLmoiuYM=", "HkCEJK1YbVjKCgSB3Ai47mP5bIOBddyKZSraiSwpPcA=", "HK4F4tLtAa5Qd/6mmaIRlTH8MJOKWuLFXOZWtu7zO4o=", "HwwXNceCpXswSev9t94yOKYI+2+p+Jvf4ZnD3xwdsV8=", "HJtnJWBXHpalWQxkwsW3meHjF2NNjeW3Mb16UaaNXU8=", "DG570gc+1C6vLbWnKLbU8SRah+YUsyLCX8UesP+qbqo=", "H64d/VEzZyGKIEBt3lfVc8YhlsThL1NH70hhAugJzvM=", "DkCObbPQFvmTpT6GQZje7g8q64MJvWbzP8+jj0AceA0=", "JoStc45hFvPbjczLbGHLsn/LoEC1mN7ZctZCIpngwJ8=", "LMxba/XPt7oeionnZAS6AGfD2Be/Pr+75GNaeJx78Gc=", "Lj3LoSrL8Jvhh/K01FO+XdTzzOKZTxjNEibGPeBW6Gg=", "Aj5w4/c3I6lN38u6cHcc4vWk4VtKj1GygowFywetKhk=", "FpxG7nv04UjL5ktsuKoavun7X7sEmX8Y7TFTRahZTF4=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "B83MO2SYrd4nVph+E1YNdmTx6AUYCuD7vuHc8fpBfXs=", "LZuFNq5SU33yV53w/woG1KmXV61xZS+R09cktOuXCss=", "Ch8AhcWpzUnfhVuS3TCcNoEpPlrwQXMB6eXmjRs0Eow=", "DRN2utwWlGpKXzJDkKTG+wC69nCCcEiAWjawY1fDnB8=", "EG0EJ99/xN16om3ieQc99/oVNwCEvCfhb18SqLAVUfI=", "AcrcpP/FvZ64YffvbnuoqiDXcJxjPJARG5jglK8p34w=", "D/kjs6uVz1o5V82J0DMZtLujKHgHgw4RBzVCAZlx6rI=", "EgKjPANZtRSR44gmzPIbsMVF5mCz2pFquRsOAuMEhKo=", "EWCKpkzD3GNcEZ0GkfRrCkeeFC4FMvklbTQUNp9eMBA=", "En04qSC9ePK1/rqUNGboUQDq0h/7C9BIaDx+e6RXRD8=", "IfeSw9BoJ20QZQpO+MjmEB12OZCUXwROv8b1ESYzLQc=", "G9vXB9VdxHCbWGaVxXCOmXPrp5oZ1lBBgc+Gkvf2Nr4=", "Ej7SUt6fGphjBfuZBmFUTR8LstEuPlq/NhMNaA1hRQw=", "Dq1qutlOeXKbXnCMYNyidDVsPlFCNJxDOCmE1N8JZlA=", "IetQSvlZ8h+cemtQpYv1J4IJomMd1iv99hda+PIrPAo=", "J6fu1NRK3jWD++fd1v5DeWqzImaqP07jgsILmd68bh0=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "FGIjjFhX2ZWqLHzNvniMsGJxU36hopnyjDB6gl6M39I=", "IML/G5m3qUlznqEI9fRioK7qB3MDy9UVvHWRrgKg1Dw=", "KqqZKs6/Z8WsUPzngky/Qeblqfh89Ckm+5ZFBbpgwZg=", "J5f9Nzc1iVwxkq6E7TkAdHiks0Ndikl1Se3aPVWYM8A=", "E1650BAcKnjKGwPKU7xVaoya9TfXe6yvv/f5vGa+m5g=", "L1lGaXidG4BbYRwnyjOloQLKOFSTg2mhcseN5aQIOFE=", "C4+TAZJQKFe1NGJbtq0v9z6U7025Vlp95cUT9G+8PoM=", "ClILftRjMRqoq457j+2y/icSFBJyZMs6D3oy0PuHFzU=", "FxmHIb6R3pWtZOZElbB9LfrkXqZ7LIJN6+/s4wTSWFg=", "ErWRhE7u6wbu1GaRun4b1NZhXSrubxwEDmM0WW7gbQ0=", "Lh2BqqSiLSlKT1fKEZm90XHGvcDOuenk9zcbUL8/yWk=", "DRjkPjudVnHn+AgNG0UVI+ZVy/GDzMy9WHk2KKpokFc=", "CspWzUIERtD1d1HesGkGzKLIjFusbTWi9yFwKxu1bFM=", "AYNwRQIE7gcMqz4lJTW9J5Ajya3ja5cZhun0qCG7DKA=", "EHF8GvIwip1K5SfGNyV5dNcb82HXQszP2cvu+wQSDlY=", "Ipr0itAYQPracp3mTZrGxOLO2NFoIPRktglpMQmYvno=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "H2An0YBvPbNrDikYMF6igAdiK2IoLQqn0tHDi8OhRYA=", "DQI8NGn1M363rT9qGpo8yHdBXxrrt+nlqVXOk/+3hto=", "K3Q2vrHiBaTnI983DyxmmFfv9tp/yFdx59yCVvURxUc=", "LPT1vQOJqNILnPl9Cy51pCnzbQHhoeap6uvGAC5tfyc=", "LGiTFt7n4j0jyzEHC/YiXZzFYvtX4/vc7D3vMUPQc9s=", "Hb5o3/MIjwywKZDgwDADnhFtAZbu0kEKMOkcCMvePc0=", "FqP8wwgOKEY/pNpm0wXVi3SIXcCZ3TKxWSCTYf2kkfY=", "L4TqiTbm8OmFKbzV1mbofYx+aKqheH+mc7iSBmmxCm8=", "D2f1QeMm38NVW1SlqAiQEwhfPO8F3NrgZmy+TRR2wc4=", "IsaKXNQZtDmjZ7dCcVaXzg0uCaSB2uh1HXx3JoNyEao=", "IGMyjAmsImUig9kaUtmFG5GQUYFbta0HDuAVBAg1sVc=", "DnhSekZY9Y2sQEMNTdyQQ+08yRCooOMLA+qQSngbqLY=", "GTX+O86uC8W4oTsHOyZ4BIJS532F85P4Shu/GRG0G/0=", "3HbKDfaB/lw7nM66+GSuSVyPkrSLs9nUAnQVTalyhg==", "EZqoF5F6c9Rt7D5Y/qDrjr90BBwbBpsag61IVrGAnvc=", "AqpG0E8SOMZGdG6N9b0M+dvsr9V9XeT3Q/21kzef8Tg=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "EAFII44Ophxba4H7oyGT1VWXkE1LEiBQDtysga1S9ow=", "CCQ8cuROARQVH9mxAuqqVp+tXfQN+DobUqzO4T/kn6s=", "FWseWDbw9ZvnXH8Zil0VPKMPC3mIIDZImTf6jDttgyM=", "LA4mS0PtbEsMNv72qvGq7ZCR81qDBVCsQ2TWAryenko=", "BTS03jDfWBY+lw/6Ds7wc4qf7IwOxOfZ0Vpmahb0XAc=", "BN/D6GEFlwysQQWcc9XyzlWxb0DPY4qFUh/ycMbhHik=", "GDcg2UQ8alk2Sv5TEgUAleM1shFZhHjHsAUknonO2RQ=", "HdRh/O+zVJupoVHfQBOzI7EYPr35ExJrUwA+hsCNme8=", "Jlbv26zR1YzqyaDnnTUER1P/m39t7bvG2KSPpIAo+10=", "LvMZsTNirE6CiWwIKm/Upkucsl7+Hg9QaN62/d+V0C0=", "E+l2uJGUnLGLRv4RMNT6GxY0LpVHef2vmCWNpxkrnJE=", "CMgEktDMYJ4YHD+dji2pD2g5D6zH5GjSnUmtklf1XCg=", "GqPHx6CNCCr6f7kcbxyfmJuY+WGbVtxix/8eGMa3LIY=", "HRFe0kAzHsKtvQo5jfDU27vy9jkr2wMIXgiNYNfwK6k=", "FETg/UZ7oJ75wcbOmoC05751XQ6fgakPdPCrfREAFdo=", "A86Z1L2QB6/04TwmedFKMdZGezKCfmjyNDFNMBMmYhc=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "ESm5FM7kiQFvw/+NIOK+TJq8hzBBuoK7fneB6XaWGyQ=", "IdvVCvWb3zUjENwBgBWmBf4t/g6OZc4f63LylyuYVkA=", "JaUpG+sB2fE+0xxYh1Xlbl5hWLL0Y0HIbt3YauzVLX8=", "CN4XLFbuu/+wKe6HO/8TFjyy0GyqRhCLrh27LEDSIhY=", "Ad0tVfI4MIY5Fp26YGbgkirWIGeBBqx6EJG3964NMJA=", "GJGRpkyeTZYKfygeN4ZpA053m+esDNxuT+5NoGWbBP8=", "FB/XNsgjr/d6wvKGMjQsJdFKZJsCbvA/NpYb9OuF1Ls=", "ETok0bydEOR/kPMIeB3cybkknZW7rNET2I1abqM3IbI=", "CPC3s4sTNoS3PQH8cx+JW8sw6hQ2RxXqkpIFAXItgaI=", "G/FM6Cqv/sMfRr3OjSLzuv8Plri/oASZWB+tmeYfYHY=", "FLe+M6QeANAzOgkXpylTn9uQukLxJFHGPeZv1BH243k=", "IQfp4oEdaslo363TrgFeP3H4fQxdXFzk+ffGa8kqOTE=", "CeE5fF8512MEC4L8K+GmQmLNWk2fMkka2kNs5De8++o=", "HRoBmGVGoIEtOk2uNKszq+nO3yBgpPZUx8sF0SmKA88=", "2j8i/0mKnP74D2PiyS29lZKOhUY3dwGKDTIE0eUPOA==", "JbdLkK+YGP4P2PvzPlOdwDekWtn0M7rI3TcXtkYAtiI=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Dz1Y3GkibJlK2jEd3U8RF0tRxJDPP92TBHVAvkN8/Iw=", "HZSOfx+kcFta4+XwMKWe+Wb6N08da7h/t01Xt28rYfw=", "IkF27YnMtYG0X2r6xDXZsv3wig8mIqWiDCukyoc4+88=", "D1z+gUfuuUUblmzAh9KpknOWqDzUB9fyKvvqbtYxOtU=", "G3PpVEbVvqrQuywySifdD9xUReqKVTKJqIzVQKeopjM=", "Gw9LdUcqsuWtRIJ0K87fO0XZAXfdUmgLx4F4bqPpa+M=", "AuGJ/ScDd0J/mK34o/SZF+vd/+dxatCNt4dh2iDmcfo=", "B8CiA2Rlwzbw/Dl2Zchqh8oBc+4ZaWuP5+YHUoPl8P4=", "L7VJfWBBLIu8FLlh2WvNnSz4KiXaJQ14YEU9wMNtN2A=", "JaoyTIvayxHoHWEuJYgUvrE90Bp94H1XtyGmyDEBIzo=", "KSZrn8HMp+QdPFhEM2LM53yBVX9W47KpoOMWXzj7KN0=", "FVfjy8+n+ggAFPbOrfLdwizBxt663h62BdDMJ1Umjdg=", "AorT2LqXiW3yazKBtz3lnZ06BVz4TiS/S3z8pKbxjhw=", "J2kr4ioxAHWJI7Swm+PA4co0xi6yh11MoulRme9X4T8=", "JstSOGnpdjVbiy6tZJPDsa87JLn2GWSJdqkl2/ucJSA=", "KpQ7XYMXHtG6Wy0BUfdw0FzxF+KMii0L0HkBEkt6eOw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JJF0IcFjAI5Gi1mZDOnJZZcjx6FD7t3wCyK+qRGiP68=", "IDR/m4YMcxjYq7WSSXOmAyeQ7RRt1RwrF1iQ5nx8FOs=", "DHtLPWPzmF4H0V9Gv/VMfxOCx/zq0vxNJzI2ns9iMSo=", "FsPBW/sJDTwytng7jzW1a/HtF8r6tGISPrhy4Y9AvIQ=", "D0vw15s6TxV6d8t1now6lQwr8I07N+biJS/toRjf62w=", "IHvCgg6SaKxFKelBXXCU9sSj3TLCH7bzSmchgG5gpm4=", "BG1uSUL8c99aXCTlChOQ/NOXH4FBbsMDONmIQh1HHmI=", "Jdhst6sjt9eCnVL7PTwtxC7LdFvHTm4pwA+vLs7aYOY=", "KR4n1laXdIhWgkX31g5dMfeZOzUwtuel0uzF7Yv8q54=", "Dd6NgCMSMsAoO3rYSqNWu/ej52BduiHym1P9lJzTeM0=", "Frm8o/R1fuW9iEwIZC0pRzDbE/kBgpcKliyVbV3tBrw=", "FI4UNKd9War9Jsdt/NDZ3Vhwm0PJkXPOrm3ciZ452BA=", "I+OOP6FxP7Vm4AcXwKIv5+BWBn9/RVz2fCOf7VMTxIQ=", "Dss4C/YHAsAGouC0E7sGCn2v3PTYxzZIPaOBMV0Sg4A=", "FQTgvifZcQAcnFL23avYg5+/PNo6QtwBwgF4gGPs4q0=", "IEzUJdT+dKofw5ZpUCCb1umWaqffH1FeX/TrUEYjcEw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JrA1SkbEtvhAq+9QV3rgFgxAOsKuFUzETdGz75XMmjI=", "B2rLoc2S5MAs7Ga5l/ITbgPIalCZlnuNLWw/pRzkcKY=", "G5+DXv02Ls7WaxtP6zWaWikuUXnsogU2vAX89xzosM8=", "FVS1dAI5oDZlDpV89UiAoF/9oTvUpAuZRtFFS25e5hk=", "Izfw8jUNzy0sTLLy48jL/o6sRLGKTn32q5ZZxtO9Ufg=", "L3A0ej4mOoKfTJUkwFKMV6rYGX109JjJZhi4LW44x1A=", "KuBHwB5reQlnya8V/pcAvxKjLLR0LHXsTyJkNVJRtZg=", "Er2tdTUlIkSI8N8kEeRbGObZnfhrZO5cLh6qomtrEWU=", "B+0Uqd7AMMeauJdGTJwx6JrF05jl/CMw69dH3GJwToA=", "JYbC8IMmUDp8zDlq2hkoTGOB9UAqHd7lkTQDbG+fTIU=", "DijePliBWvgWqg5EnLawtoFR/Dt0yIRLBDP7VW4TvzU=", "Fe2a4XtIcIQEwg4gTeIYRi9cHeemcsBACxpKl9gr4vw=", "KJejxhq34QltWdt9Bi01Cdu+UojoUD63I6eDZo85Nj4=", "GTguAQEgK8/0yBhqOeTO0Sraety8DT1TWjf9jk5l1qg=", "Hcz2TPEEPvyP9SXfmhEIg9twsTu2RMZWfA7VYAaXlUc=", "FPdTKECTpbx1Pm5FFtxfGFbDY83p7MlXRd3oL49HXf4=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "BHzgdo07lFAbaUcPYaMnmvhsztpI78CutPdVzjVajAY=", "CoONqU5qorfjyNJPu9Gr+f4JzagkKv/2kdV6/2SjB8c=", "LM9yB3FIV+G5b5ChD2ZioKFh/vb4VUrP+0VLR1ytIkk=", "LJZHAumYhEp2DnNddOx/wX55P2VmUxKJEOCKHEiyc5k=", "Jsc/zChjWPioxFlA4y2iGs7NJyOj5sAAA7h1ly5+QhU=", "JQO7cWkWk8bNbARdP0C0zSiFpxrfU0hkLYC0S0J0Fks=", "Iauw86oJ3gVp4kqa33hjvZZc5lbk7jBhHQ8GPBtrHUk=", "HmwYo8ooGFK5c4h2Eox9FtL9J3iQQ5B81iRHHRNW0Qw=", "C7MjeXB5vmB4jowlfKoeHptSuPWBKOtJ39jXWV+oJ1w=", "Fu1NUWR0X92iMoqyjQ7wNQo7tQWJ1yZV0ODVqPHbq4E=", "FxnmYm6gPZREHt3P+wDcjnZ2ciSYbEX1+L90b3LjOAU=", "IN0kRNGzCn5FoHZ3a0Nm8E6cXRsypDsmDXBvZGoJjbc=", "InYAbKh9lzwfWEGjtjqp5qT4RGqKDuA+Bo/aI6ii4LE=", "LT59b+6q1/PIcA5ik6DYlgKNQUnVfCGZNUY2Ifp3mY4=", "JvFdS6RzbHN1Ddv/Sn2YZfBtVnbkSenSSdPcnqYgU8E=", "A2NoAyQpc6uR/vhapG3xPLpKyfZTeqNzDA2oi50Fx1E=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "LvAbyiOOpDVR5YV+QSQnrx2q6BuNmqDDO/OSu55x8SM=", "MDAzNkgFfR1Gp6OXMDGoZjfWzew1WbwS+jvsbAqrAcw=", "JNzpG8PfUF8Fk3FZh9PmurjxhH5e6pE0Gp0eg7/Dmr4=", "J6Kqlc572HD9o4X8lF12JpqcttZLhflDQwx5YxHQOGg=", "8y4e1mVmiLQAxC2lL/qPrC0l7od2EuVl+SccHNshbg==", "DWnX2ZpYr4YDV63Lq3Y6ltBIgGuxszUsPdzAeV5r/A8=", "D8oBFYwK7N3EBNdWGm1O58bnuvVO75PxtMcr2UaNgUA=", "JPZd0WIvWZPxcseoA6ca9tmTakX88vEcZaIpFpPECcA=", "I7bBxKlpeDRSYITMVui1OrPMsg4G7XvZTnUsrhPgRlA=", "BrCwZ0+ecMoxuGWN9akYtqqQ7k2oJy161QEJq3OvI3I=", "EZ6jEz3r4SD+tbD/ISi3Ra3mMpwijYyT757KyTPedbs=", "KP4JIfPiUL0NdN+WaeziETMBEbzaZf8Z/ovQJ3nadoY=", "EhvDIsN7OoTPozQHvKCEIcdld/TtUAkVHuYd6VOJBvA=", "DGxtEzxk30o/FI0DBkq2gfZ1QZICP5blxmAYG/Zwjno=", "HzV7AAyOwQYULAXX/LRb7jyoYCrO7YPDJU0VloVNjpw=", "LGNfu4pHXSLMk4jzMpjKMobVXlKdgWfQNsyX4otcEQk=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "AUFuRmaemfY3btnxtgtMHL4sE/NqwaCWGyjApN7WIr4=", "CDuZOgHAaRT643SYBn0cx1ddTWaS6QWnbAEBKCmEjjU=", "B9Zu/5Yuxt2usjqEy4/FP7JDX7B3n9xt4EKvjL9lPg==", "JDSTyi6a78qTtvcpzUjonFtpd9yLnxKOgPIYGgyTIfk=", "JTFc2NW18JNd860pDhjI+7GqiiAK8bO3rLeE8rHrZfQ=", "IZ6fJzduvaNqnaakBqbCNG5ttsNeNjkFAP+90kx1QBM=", "J4T3cNNjwIgTlhTcr+ToL+xK/2DLuUILLe+h5c6vUv8=", "LvCXL3YkosccczmJCzUPcWx/w8uITEjfc3iMs46O/j0=", "JjgAXxv6lR8E0+aWehm6aOeXJh0BX7C0ogAITaBSBCA=", "GZUr/CsVobekTlmk8AcHalaqYcnLT+xF9CMB75FXoJU=", "Ib/r1/Db+pUvYvldRHXAefYj9W9n7BPynlH+pLFCvv0=", "Cr4Mu9rXUunDDGZVRvG2jN0tVW9lnJjJ0MQEjL8LpNQ=", "IMTywpHF8LFeVPrUTVSb36BuhAUUHQdEbs6imb3tWNQ=", "DHA6WvIr6nehY+6Y43mHf8J2ouYKE0v6az4PNnSq2DA=", "I4mKQ/uXBSn0wSvRbpj4ka7WT8tZc4vVwu8df1ub1Kc=", "An3iBeO095iBGHOvDcOfkcRJuuFo6issomjw//Qhlp0=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "A04CF6qjEz/7iP0JutWeRNjw504aZMhvPpqkWHAARk0=", "Dw0pVKNCXU72KRruyo0eGSclD45WZoi/AfdyBrag4No=", "A4rmyVOwX96OwZlxUdYhBsOFYaZWO3xcQsPKPyVOu6g=", "Ep2uPmq8mz7vhBkFSXfo67NZVrXaRzH4ehVYuT1bZ2o=", "BDMxzlvxPiEsNrtgKOpe3JCdaAdjBIOWD/0eRyMz3oo=", "Bu3SvKZZZRXHv6f4LBI5RzZu/JIwckQs0NbLPLlbZZA=", "IY055cskqY/3eIM+ycyclxVKLw3PV242hB5h8qnVPBA=", "B7q9tflp3xBW3NGk0l7Nqrkxvc1BD1FEMiH0PumtYNc=", "BR9Rxu3KetIPlcvQfOnFxRkY3WY57LWOLbRPnakqxFs=", "GNDLkRDtLBPKaXxRcxJlRhqkDL/z7saXcMRxv6uFR7U=", "FRwNEAdQ/T/GSsfKFIxBvyY0wWF0bmZLZAPh1f+Z7bY=", "G63OBz25FWvGvAsFpfmtMoJv+Awg27kJkcWbhPGIdjE=", "HQlhGxHyDDV9pptkt/I16nl0FYPPF3pDFByu45KLyIo=", "FZA8z4vSCq+G3HoMGRmiCyvu+hDuk3O6YqddpdtQzVQ=", "Cj7Yn0IpWUIn6NNcD3ddgdrvg89Q9tr2ySWE28hrvX8=", "FcWm/dm2ugbsLN659GX7Kag6k0Xa7UngwnBksqdF+DI=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "KcR7IcPBOZ3N5GRznNlywq592FEe9NxKsGLeQJBM0EE=", "BdIMPhGPfhY4A4dENeuMT5OfrWaWBqD4gjFVtGY2tA0=", "Korfe2Trr2u65DY7jeE5sEfknMJY2GknzbF/ZNenY2U=", "DPq0lkS7JHNTCRNNjxFgOXthwjdmwTr6L2c1BwDqGEw=", "CXjB4kpW6fSOBKAOus+EqXG/UkqU/4LJ+mzypBReoyM=", "Hn/rCK0HWfFjJ1H9osgDRylqGB8zVTv9EchOO5nk3KE=", "FjbxxMa+mxZkf9VuQYtDLYHe4sCcANFN9SakkdA98IM=", "HQlBx2eKo4FMSZYvgPBqO2/0jEVjy1Y5Jch7YhOSlo8=", "G6eS8Od3DSlJeaOW4sVbIbrumNC+SHBbMvgx8tCfRw0=", "Gt+5C+WZPoqOgkZv2U0hQuBcUHw4oAlVNYlDaQeeKFg=", "FwFBetzHpjUV9Y0/5IQPlte4dka+klq/WDHH2faDnpo=", "AWZpwHEp3voCjUaIhO7EglwYUuauYPWsxKendU+Tg+4=", "DAMNtmG/ZgMrngq/6IzEgvE0tfObE+iqILVA0jpctNY=", "BsKbUAMLn5ZTyM/oCSinbmuh/lOFEJt+YG7wdjTVMTA=", "FY7/cVtjfqLhxDEs/PwVTT3K5tLiQIJueR3GYdQSKg4=", "C3QUv52s/w2HtGE9m7RI7wWD8HlIyybYaWOwRCpHiGU=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "L8WBaoqdVPE5ftbcxwVQXKKKUNYI8tawNR0TPqZc+Ko=", "JNBNK1P5+UtR4DAMa/l+ZVq2uyX3kDZcZJSYdvyOQAo=", "EsLThccG94to0TLRZ38cQ/5VXT2b1mIt6NzmoBrtcCo=", "As/AewS3rGvW/2fMbTKs5HF8vFaXSnC5492lSxdBzj4=", "Db7J6S0UUS86lfG9brh+doT9CZ10dkHhaVbigYNPy94=", "EREMrI2tRTYkdvUFNuA9E5B2ly9eA9uUZ1PtADTtMFA=", "F74IWhlmBfKwIa3YKi/v5sBivyBCU34FRkLFId2m5GI=", "LTBDTAzvX7XdYPa1LAFVaBm+3Qj4fwwZGUH5W4M4U9A=", "KXgEEhmGIxxy1fPbK7I8/EHZCRt/CF7r8JBfWYVK1kA=", "Jjz74oQzcOjyNSu0G1HVmo+d1KOVUpIgIdrpvXd9ZPM=", "GtobV1R7oLRM7BjpSyc8Aq82m+WLpMpd3fwMVMbZUs0=", "GgIuPH8YGlr0ymto6h6GNq16UesuSXef6iq9oIBYzio=", "GlGnQrXiqMsCGU/lRC/oFg+IfXGoxiQJfMdR5vyeEGw=", "Azo8T7KjNoYlKP5FbksoQX8M1bjXAvpZhkhZPLJ/+Vs=", "J1KX6IEVmx/xFb65dB/v/yRfzr8iZ/t3iLz9txDuEew=", "DEMwzwVF/g1NVtzr/2nMdWQjKwupTljoefmoOPpDtQ0=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "B7YT2Mvnx+EE4xRNiDJwUw5rMZBgai35J5H+4vPw2zA=", "Ayi7hgf4mVLHoOGZqRSr/mea/TZvVxYFE3CKV7C8BmU=", "J5fSpCvyw/hggY+SeD7lt36lyO86w0M6S6j4k0/kDn8=", "AjPm9SKhTKJAZ8XAmv/HtTr2yHd2UluyHZBY0B/BBq8=", "A5BWLAlcFgqnhjlAJ0BLvWo4gswRGMyO2CMHxujYAIQ=", "FxBuGsDPzzbp119ko5gHyBLMhbd+PFraSRYp9x2Xj24=", "GqKOSBItCkRzOjcOUDE3WoycZIzEbc8zRGIebNTKXHY=", "GPbnaLm88l03+Q+ui5pMXKwYG5sFxrzrki1Q2ERLt54=", "D6k0Dwed3EdrEAYL+4Uq+Cf/cSxcn+oD9i0T0MZw2Yg=", "HbmfKVsFq0KpRsLDpcc7IlupnuU9yQbq82BnWGfvr+s=", "CXV4rrQ6fWsbECQMCmubdx1lt8WjpVVSJuPORd49NHc=", "GXTDTYiTjWat5VRqcm3Lqb12wx8bTudjrwP41WmPSoc=", "DiWoKKrubxFou9nKLBd5c6jyD02L867AagwkUS3yIs4=", "LhPuc5TmJv/r6qCXEpNvhAJACXGYZVaHFRbyoOypBX4=", "IL5UeH0+bX6R3koFIXLemaJRy4O+b61H7FpWsFNxclQ=", "IBk4bb8VlY7S76vA+BGEpnEOD4I56JMuJYJ8yqu3UA==", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "EZXbRSNeCyhnF7uw5/t/S9XxNGqNbUfd5FUTuqSQIHw=", "Ale+YrWdb1TAIcJ/DDwKfKMiLcXs+ymL7ZhvG2y3T3k=", "L8YejGnxtqiaaY1L05DxrZYe8cl5wxX8Bp0dM2RjCCk=", "BO1t2W3Uunm5R0v+EFF8k861ptxblUl6caOMQsQXHbs=", "EMjX1IRgFNHTfXqicxHc6SV+od4XAKcXWgOzWPEsDdE=", "B/gzQYaX9D1oxnku0bakJ0UA2WwolDE/Q9kYUSntAbg=", "CqH7FBVvnbWXN7I+/azMQNj2CbNGgJ9m2WQC5fmiwQI=", "GjtjWwWgIod6vybFN42nVnUogtMBUqdedQlaSZKSbeI=", "Bf9oUu8seAffjGjMH7hC/gfvCIkuZwb0zLMFnx2AcUw=", "GOk65LTAkrJxziGIHxM7s2nQnjcmlnzrBIRpimywI3Q=", "BfHXH8mf1ujdGk/xxvtNFqrTRFssWyaYqMqZWz7DL90=", "JgssZlz4YySKXJoD/F7HE8HTLdO7F/Om26evFpAxdRQ=", "GZ3CaDHRuB4zPqeX5qouduoubP3YiDk2ggds53+9TPM=", "H8eEHDdiVJGFzxl/dlxQ9NqXNYxAy2nPdJQO6xZUF+g=", "A92Ns8MwddxyTat0FvlD5FrcOeFHRD/8vz++2AaAif0=", "FBXYfy7OJd1tqKm1alvc708jWhtnasT+Ds6L6lTw1iA=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Fz6XPZKwPo981Utdy9SeXJMEYojFvYrJX3EeOEgHpAo=", "Hp6ejwh/5+riG4Q4UBfWMGxz7k3MWwnv4fkbnfY5Y1M=", "LNOeb9p7CnWSYlTRtL0nrWAY6lWSkNIEGmoc1IUCbO4=", "K6vjLGrRxGbAkj6JJC/weZetkSgZcsqWkK13gGx5+ag=", "FnHjrv6tEMHqsFdXfO8tADZTJ16hg/lWWD2rXmcXrvY=", "BjgEC04GjWMw4gc7kELiV2OHLEVktBPR2N89xScc3p0=", "E6G+CGscEw/JsDd79fTHq0Fms03BRCrxW9mtoLMWSJ8=", "6SoIxnpkx+JnrPKKBIA12NcCvA5JtxVxMngfP5EsBA==", "JPzyG7ZgqUZbalDqHg/2yI1GPlwUzILn8zO9jNnp2lc=", "GcNADCJ3itJgjMM9ED11WLkJ8r/+ESiUUCHPo5lrkM4=", "GATd9zNB+rITvRWsT7CziyEAOKswl982PfFUScoJKVU=", "LQMOEE62lfFYIW8tF7r1ica36zF0cCrP//NFn6o2kgk=", "KsKLUnNTbVUg28Dy0cpiJTclafLB+BXrDZjqI73j4Kk=", "EyNp5E+ltJ8wm9tR4/dkgbxxUREsKO58YFjUQE0yaqs=", "EDDY3WNV7w6LO9ITCD8FQBWKE9wFkzWwpoRxwdj5lc8=", "EHVL5mZ9DIjajSfI2IXGjC7FPmaHnvyGZKMThGyNt/Q=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JF/fJO18rG2Yel8QmKPcIJToRF6oo01AnKoN6e6IM60=", "LdzUse8oQp77U3E0PXwao0OUshS6TTeGpy/0omD4A0E=", "CXltocVOlGWJiOHkfyqyoY+1S9EsD2l2GhFCjSv4Bgs=", "K4IAeYKVcuRzf9hLVeANabmEJoF2LWFMTMn0yD3HyIo=", "KiyPLdftcEkCmsWOJIO7ySyp3rl5WYF5lig0CZogbQs=", "LlEx7ZlgEjMwGlhUTrWzkK3CrtL3u4l19OMIm6WY4D0=", "BvgApw1HnIkxjOFKzgwffe2RPLMYaqZ6zHKQs1+UHIA=", "CEjt8nEi6MiX7Oj/Mcdujj2k7CRkgOdpgJvrzbRoAUY=", "MDKn1xHxF4Owz6EtCpu6/2L7nXXL5Qqm5oT5KF1VhAo=", "FWu0uJoVgnNw7VMmvFFvkOgNorM7+pdrTJom9MC8tdQ=", "EEuACq2E8t4BklJT3hMARHlE/wJ5mb86ET3+KCNucH4=", "DuJGNOE3TlBtMYahD2AxW+uKMRymnVlcCvoOTfrV7CI=", "CIb2yGGNRWVN55b/sKcY62XlI23v+ErcST5qSTCFCb8=", "MD95K3feBWM0v0uVxTWyJO3MwdZbKOUtVpaV/gqG9+c=", "LOX5vcZKtIsy5e1BG+EHsoARklXZdmc8FMoucMdvpoo=", "JvAlLwsLb2OKoE2rA/ao/nh1qE/lxnY6qUQ/qr021q8=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "CJXqp0IdXJLbcxEYdf8Ol9HxzxNFTI0O5lrgyGy58MY=", "BaN+U9PF27+c2XK2N7+wGO/Pof1cvotdv583YIeDOSo=", "IVGr+lXoAaXdVfgrcR8Fs+Yf2clNx3IBqeYsiQkdqMA=", "HfcEC99jmL+8XcC8/VLiy2rMHjLqnuxA4cFKFzYVqQE=", "CC2cCZOuShKgOcEarRJ0PF9dKGxkiom0NCFpqkEAuao=", "KV+fj6BZ1U1LWCITll6rxe1veF5KpxGW9iOL4sURvRE=", "ARSJB1GUR08GOZN0EnnOpc6oELzgJ+ZK2QAiXO2Bs14=", "DDCK3JsN6lPhw34G0FdvTtOcKupmv0KawAV1qRBRErA=", "HIrpUh1lebQ1IMPLzXErPfu9KxVD0VZPfZGMbjMOCKY=", "DGmtZElXWZuz7aHZ+DHKZ7Ahsz9kB/8uVocOerPVpWk=", "F95PdIFfs6D0VyizgeLd98EVfl1lmJ695H+Ly4jzaDY=", "H8E7djRBCPEq9o8LyAyZV38JomY2jw4nR5Sjz2W0jRc=", "L60ExKG/RA/lYHbfdOXDClim4m+p2ghlvQN0tq439KI=", "IHZrzH81m/52XOh5mAl6dQHXkkcw/nMlqszqoFTi6ls=", "FOsiGrZdDbxe32ogZRiOqQV/k10Cj37RRynr3WbtX9c=", "AcregcTVYq/4TardYwOStzW5SBdcBkrOlY4MeJydk78=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "GbZJFDdJELrMMzJscL4KhRjnHya04arl0z/V3Ou7H0Q=", "DsCHvDnlBY4MXBQysgxhJTdEG+AQftdZ06lGitqXXdo=", "Jfat5umDNpbE28GcdlyiztCfR/B0XfyFDv0m46i/xfY=", "CEL2dPZaSVk426Ag8ipHaEDgWR8Xl4DXLAAVPd71qa4=", "JLMjLwW+V+88TCKvnMN6c/CuQCifsPqIBjD349AJl6o=", "L0sjDYJaaCUgrAtTJtEwoku4k2MxiWHvX2U5G45/a8M=", "DxZEAg2KbA3eUGjxirGW00gXKq3P1jkcMf8bVPUTUJ0=", "c/2FDKlWH4pkXJ5K+UPTcqS4Ygt4u7w1epfRT1MXlw==", "KE+GuczhP7tv1mDY5Szyf3vycjpJQnjzyww7rQV00QQ=", "Fr7lLR1tNiuUMMz00vGv6v41cq5OqgO+avbxvMBd6FU=", "JUzsEXjoB0DMoxjRtds3td0j+ixEq7fxU1IAYYuboMU=", "ETBpz3Z+1K/GHlkumKY+2u+YJ4ws5Z2xCclO9t6pzw==", "KCnhUytPzbLfkQTMI7MzGh1Rx9Dam2RaSkPb6up30ik=", "JKA8D3tRtuJKiJaQozQfVd6srdr8H/hxr2/Wp23Oi+4=", "JKfCwSQTGrN+1ioBghFKXc5Kt+YrFP9jJwOyOnjzkaA=", "GVKelD5Gbagua66PF1DehiDgYDBtnfWp0gqDpLaPwJw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "J0wPaPZ52lO9zfnBE5PDTvj+Wc3u7PhZ1K1TBpqIeJw=", "HJAMpYgrEHo7iok4FAsSfNP/v1OckUXzhc6l59xpePU=", "BVoyZLEwu0MW9FA68Tfw2WS3U7pXVFanRYG2jGeJ3zM=", "KQAzQkUDBVqy5rgJOnWNsPAtz8StryajD0Z7DoqhrxM=", "G0FdbseJN3S/mlmKhJb4OlQihhoEQhHg1SVJP3XHvKE=", "LV5qkmUHhuarNfOmLFaJoCiISdHux+v4m5pt91za/Tk=", "FbHGx1cX046UJlUj8PZJHiLYt5p5GxCyETnwCGUeMDc=", "H5KTSftSIsSm8X/efwqspkMLZ4XMX2XD4beELDONweM=", "IwNLuLhhjejIiQ/I/uZCIUdUXRHUXkHtYya3Z/8JnLo=", "KrcGxtIeiHtZBtTbNQ5BsXYyPtOfiKdbgPHrJoAWn2k=", "BMEDHdpeQ+8yWzOoDmzTLLIrFq0yT72QzPecH36e4GI=", "HWY9MXBe78ol0puIlCI6fa8Gv+z06OC7hFaC/OCxpB4=", "GMl7xtwu4cPWa9rXBGAZttSrplkoI6Ua4qgFKCTG4zI=", "Dd5BBymTLcr/BJCt7HUvqt5YLi7/nQWJbaQ/rDLhrTo=", "CxLeEnDXiNq+wUVmEUhaaEHN/kEaCfgMDhMoKFaNjqs=", "BRlAiMsbDznFsVJ70KOsTRbIRcI4jNIt7nVUTs6rZAw=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "KikE+SvcA180fG+231Ssa0gqJkLdjnmPnfCRX8yGhys=", "CLwPIrWX+hLNgYnF/Q95srENbGWUayh4kNxfWUdh1mU=", "K7VaVU+bzF6o29TVRT4YgSLGbFB/3QjQWJcGwTNWGdQ=", "JHHpEHit0zX1xIRXeF7xtGlITtaX4un4DQ/HOFJJJQg=", "LM9ytzJMvdShuYDYg1Mu8oh8eY70RkCOiF+MvRSsQqw=", "HDt1qtp4wbIEo1OG9o4JqO1wC9iGhdDjjO2t+9iKWD0=", "ERZOqWI3BOr++Gu8/srVkllwOPwbCXOA7/ykUCV3xzM=", "BLlhw2gnAZasKtouZuRKRECQXv9bWDQTAs6t36IV9pE=", "A53NHdP/jX/gGd2mQQTpu/ocYPq9VAZchecnMC2DNds=", "CQ8n/v/idrbB139qgNLCVoD7hUr5rRvhEmgGTnNQYLg=", "ICkidpoibh3qPDnXkb8o7JNjnHk363viwQkS7olv0+I=", "AWO7GxFZYgGeQb0cfPDYeD1LqhY9y/biXTaMVD+VYKU=", "JV3STqG0mXIAfDt0/ZjDzMaC/eWIWKIHO+S5CznlfPg=", "K+WuzHDon9f9PiaDvqDOYAz0J1nsWUHwdG8SaxG+zNw=", "FYRYfJH1e73EHoXqOsjqZ+0mHNjVAUtCSh3AG6xHi5E=", "ITG+W0OH0ibCK80QKXN1bNf/lVRS6erkKRB6skQpSxQ=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "JUsOkb9xShtFdI11ZykQL9q4kwH8idAp1VN/kibgQvc=", "MDwhqi8XPCkK+eqOChD3hY/6t1GRhYQ9IEmiKUYCaxE=", "BB5uz8ihPN9S+cIWYpBvOVrhcvlEx1dQc8Du6ZYpQfk=", "Ges14nlQmPr/7571usoz2p7PlNWXPA7NJeaJljCvenY=", "EULSLsARqUqUD+ID3rGZe2T3gL810GJ2ZE+Y5I4sn/g=", "D93Dbd6E4WpcL2MUcJQ84x5L5jBbym5cdTxhhvEFn2I=", "BbFLplJr49zBe/fWCaQqrBrf4PRJo9k3Tgwi4mssI2I=", "FhUqsKAMOR1FApCuglz1yidp+78ufrafh2QCX2jp/1s=", "KMyQh35Mzjj9CMGvlcw/iFpcUyj6DuC8icoZBpTY5IQ=", "LfWrmkgLugAHLEAbquQgwYABVbn30aubMel2rYAJKdE=", "EmQKAdm2BWApAGWj/YEq/Aem55VAj5iAca7t8iq3XmY=", "GyeS2Af1Xrq19CdNQ8zbnSPBVbi59t+GlOzG9n4gAos=", "FsLqaHR50lfiamVbXGwnvB9FXu6sKMOzzmVLx2ysOPM=", "JtqP1fxHh1HgZFOw7LbNqr8jGljmA6xK0UcX1w2y8n0=", "FPOj40c518cnsBClAi2fDz4DXpHbOqlH4+vjNm7tJ8M=", "A2YUHREVqvsITPqGbFLvQKX6V/3I4G/C8eRrlnycZhU=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "FWWK/ZssE9S8DGN875cX6UPFD4O2fIZ21n0XBQSU5cw=", "HzGNw+J3vYlaiNvZ48T+vUPNuQZGg/+/G+nm+bKnFmk=", "FBzdXywY1j7sboIkiTXq6sTvBE7nbLfvDpJZq2+T2qo=", "DkslS8Z9OFf0mWgoY6D5W3bp1cyft8LFlynbIDBQKZ8=", "LMK5Cnv582Y7D0Ht409g1jqZhgdg7WAn/hfU+p6xs5Y=", "LggZcT33x6lCwIs+pQrdkuOSFBBBIIA6WAaq0QI0q8E=", "JBZKQzhAoo0mFccZxxby98AffDhUoyfabF23UJf+8e4=", "JyVD8ihJITkXKa5Y2x2dsIB2KdkhF3iwdW6n5PiCl7E=", "GUryeYf1DthzDSZ9z9mKmihKNYLPtzVuPcRrvKHu7Wo=", "IES6VfXkTHBpWQvSq/yyt7Fj1H4OG/LiUkwJSNpLGjc=", "GdN/yhtnt6xiY0nL8pKLlFeGNje6omE7SU2doYzDhPA=", "EjDqIxCE42QYF7dGYsr1cyVWw9lKAdIJ/qH2d3rmzKE=", "L5JKQtTZRGy0iClYg/2tzo3r2lrHJ5Aeq/LYYn3G1pg=", "LadFeFrg0+/xoygddTc4Or/fuiAxqICs2Nq7M4ikzpU=", "cvpjVBTRZz+rjQVxB3krMDnAM9kkzAsVMEl8LIEEKA==", "GdsynwhqUHgbDG6yVSukVNsvy7wSWl7EHtLA6EC9Z3Q=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "HqTz/ptKv86eZVsFxPZKCEkAP5s0m9vzSeoqJJvclF0=", "I8h4VBM7XTknQtzliqAc83bjmD3ZOWNMT+5jJtsh20w=", "C8R3Th6ANJuacEwBcJ3oQ/OyCnW+Yw0bbGVVrfO9oEI=", "FD/9Ct3cecUe3PrG/8GqPZnr8tVTSd9TpUhCyUWoL1U=", "K4ExRrnnD1PjyyVJqR5oljkoxA4CwIcp4P0/WUGz1gI=", "E96e8VO9IvUGPLQqvAYcCe7FEOS2lKTpub9t5WzC8gY=", "MAFd0UPIDRE8KQv5TunXsQy/uTlZ6EZ1HDs++fjQdJA=", "JRXuuQPWU3Z05Ps87gs6TFBR7zz8Gj0d0qJfTd+W4Fo=", "IOxexstfkdhgklpjQa9csV/PSyaUCDI168fqeMz2Qh8=", "B3Fg07mZICIPpZGkn3nFaigrbjaM0UGe8JYy6GlZnxQ=", "LcAfYUJ4iMstWunYoEmcr8A5RdvxEXJ7Giy65zu0Gw0=", "HfO4Bdo7WDzI9zY3LnsW09BAfmNLbLfr7ysWiTIZQUc=", "Ikpst/TpZOYWylsPI8d4WSMmdHRdMgcglrufEhMfAHU=", "B/dPDeU1Ixd1MHAXoJMox0kb8Pt86GrV+1iVlBVJg/0=", "KBbRGPWdPOrRzt9cx2oah4KbLYwfoQrbsv1O68A3OyY=", "FpjA3ySUUWQGfl0NmwMhp1eBigy/rpaeKMdtxHCXREA=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "LYeNARlIVHe+jb8Bo676knojAGXO+haeNM3Njpfv7kg=", "KvN34f/LaQmgf7nQOTfOSo/q0hkMq9prrr1ZQ0RdwOQ=", "EQ/6rodyrHeg/ibzaEhDRP9oGEPvYWxtc+DdldXx8+g=", "CSzeR3Q40aEzW3ldWlrhXQlJh3xzSg7KJJhlrjCkzi0=", "LLHcx4FErfyh5T3CUcLkCElwyUGFXuanctMN+7GmRIs=", "HoDzZpM/AFYtP6y1QBXnL8TPRol71x8/MBW7P4iVIx0=", "IMXZsuFT9Hh6dlCWqnwfR/mQ6BAATudzfCERUMQLee0=", "Eugey371W4aJMnjON8QpQArzCzTBCwrNeG+9eyXDRp0=", "HLvqvgKJ7VlC9QUxpkdTDxBectH5EusRU50fxViM4fc=", "ITxJcHYKWIJmHg6Bj0NFC4z54C29AEbyfqTWZAPtDuc=", "KG9z4U9ySV+7KA1xOwFh/2laIQkRUO5smulu3fNuISs=", "DWSiHOvR9ZgBVRIWxpOxgaqWO84Yp/RDnxeecQWDYpY=", "FLs5yDbADzPqmQPbo9PUNOwz3q7DUHbq/BpMWgGkF8M=", "LKW4jmuxH2Hl3MKk72ZLSaOAEAnx63QggxO3sE1Z7dg=", "LESvBBrIkkKovXUdls4Phu3fjDEuazEnxT5gF8DSLnc=", "FGbSH4SIUPvqVZpMdrGgB4f5l8Gkpb1AZDA2q2hFU9c=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "IgzsvCRxUbwgKoGkVz+SO8kqIgixfhwL8t+6DeT9Jto=", "C3HZObVG9gnMsYncvu2Co02PL6osWXo7Nng2mkcdgXo=", "LPuohyKtN/2ht+yUialuCeiLv2ZJyLcBS93jTvGKZOA=", "DQ3rwPDV3N908hktoGj4djEhOlKq9Z6toL1Zu5m6lRA=", "HSAlBNV6YcTNa/AH5HjZWI2OZYXrxgIic3mq8lu/atc=", "JRJTNno+KKaR07b/8SCfbPDgNzaShyXeoPnwgkrnDcI=", "JgxV6cBvZT2SAtA/HBhPtw3y+TetFXcZaFhj5DOPtL4=", "IAsiRiOYRDRMzohUwkyamxTkON5qPqRFFRiC8jFo/SA=", "Lj5HvkDHIW2dt1RwvYGTw1WLo8YcVSvFbasnE69iUGw=", "J4TCsUK/PoY54JA1iho8geJfI+3KsYABUUxhfNCRilw=", "El3iT0+8boebQDmvOKHQQebDiicLO5UC4QwJ8UlEXWY=", "KXQK2s+dNonkQ2OcJeNnsj0H1pDJ6o2m4S+mRDUC+QM=", "K7nTbDahB9ty3rQmJ3aWeSb5I9+cls8HcI1WWcwErIE=", "Cz2YJ9iY6DMzyDxlgY9/wXYfz2MtG18D7pUIW1GN+2c=", "EKboYHFfdpadc5vTw5PxryxtJ/P4wh4QHcjPelFe734=", "LYsKi/iUt9YH2aSdxvhyVDH2nvBUHevZpBzOxLfBhT4=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "LxJ/vX9Q0T4e0UR2DTejdaUHrB8Edf0focq0Aeyvx/s=", "FXfSekqJg9VKNkmU2yIygG3Go/GuAFlgrby0NSqIueI=", "BSkUzKE78cjde4roMpOTzLJNy7MsRiXqK6bPk1vk8jE=", "A648uGwSW6fiLGj8YS8pKKlhuklnpa/GYe0sMt6T/TA=", "KXeX3vgiRKyHPGTB47BYZyWt/zJO65sVqbR2gj5heeE=", "ASSnqMbkTnE1tY/Ct2BiFxtQVK8N72BE2ZY3rf21tAM=", "ESLNRorlqBF5G7/ZkPXvQw6x4fHG90aeV0bbfsBCaJI=", "JAm+B29rv+h6Zg+GX+WutKvwZMEr2tqTPu14JLonHN8=", "MAyrki+JKSkV4Bp43veuMjUBaU8SJze57Gc58SMnizs=", "DXQ1R70yH70bJ+v8fVJ5ey+XMj0l8aN0r+wZoWMKtjs=", "CVY1UL2sxVIYmE6EE6EibCKzjBLWmsFr9uP5UqeHpQQ=", "GYXIVT7o54vRxls/N1/pnLDBTWDmn8bSBcxUvRc/UgQ=", "G9eziiftvxFRQ3ZNJb2sfpIeg7KZZBAbSU+AdaeAB2M=", "AnZoUHUSVPRPTpPbViGDm/Ds7XKKbSuM/wWw/NqUXg==", "E1uSx2tSrwExGf30Pp/3nLQCCLLHjMzXJ3gf8fRWA54=", "GdoiagPOvqNFyaVs87TH5pgNYTRxuXiUp9X+1vPhx0M=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "CS9KzKLg7eW6kBkW2p4fZ79EWPhJXuojjRczLaY6pxo=", "AWQdLYIPFqfj9I3vEWts0HjeR663gtgpXF9QXYmp5Lo=", "CFIBotdxAsPQxjNTATxHwq3qFGEg6Naz4jGdjmO6DMo=", "ClPXWNAQjr8i2s57u7cK+ib0AEhd7p5Of096t9kplnc=", "Ji2UI80ghSvGjEb+Xq5ZqB0dgUpmpjjIwAEn/i3Zh2E=", "Kt6GeOHE5aiAAfcIc+nCi7i4a8d8FxJzEFe0EEaMjzA=", "Duj/P8JLzTBj6ZWky8009GFCyfOr/w+ORqhnlbW0ZVI=", "K4JfnNRYXvRqXaUCIJwSRkyCSt+xgDJxi7N+RzjLMpI=", "AayBAdpt3sVSI4/P85Mv8utAujjtDDnrWQPjrcz/eR0=", "GrlfIO8NqlzrhfghQTsEbp+4pwth53+PVGlxH1CPF48=", "WA2LeRid4EUAqldJkJh0+LWWjJIE1lEeBboaOVM2LA==", "J1h1qXnzGxyNtH9tukxVPIcyqjfEx01/6fl5J03CfJU=", "E9hHMrs7m8lxYlM2RKdRXZHwjZcFhFENtWyrpi36DWY=", "BNR/lO1ZHDlp/uCeI/OS3NCDESbWIf9aB3hLu1F46HY=", "JovlABWl9GdvIC7O8V4JQTC6tYItY9d3N0yKC59PODI=", "DESnXVAg1K7ROa1ylPJ3YzkfK+a9M0NpHqbhIsQ1b8s=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "IS5+Ls/OeJInCPyvJ2u73tPA4tiATWahP6AgdJxI7MA=", "FY+oYLgme0AReA7reCxNK4eK4mFeMXt5iWG+KKfKJGI=", "He92IuVGOf1AgTzxv4FiGYrxngfYig1C1DY2h0XjzKY=", "FFrUmU1Cymlmnkx4742wZGEEf0l228WtSmzyw/94v1c=", "GX0EY7EKIWSfJWcM3SUEulhiGrkStkMpOzKlFfUK/fw=", "IzmNGAAGBppox3Qsr0xmm4d0K2A9XsdcE9KoNRA6D9Q=", "HgJYvWNofXsXxPo3ifn9ghCKPTjtRFjlCgccS2IoZsg=", "BCP2dEtbla81u5yqcgCIsF5/6JF2VpAQ6WeS4P0Goow=", "DFBDbbbZnlqJM67ymsg/ooFzlcV30Lo+AVL9ODVCCIo=", "EKInJLeDpO116SICphIa127siMP2ttKwzVovgp18qjc=", "D0nxrZ3k8FfrOsrb4iedYXOEwPWUUDxhbIoffAX8yIY=", "IUHAmzDqrJ81X0npiQVDVHa/pS+lM56jD8SL6r7OD0s=", "AVwcK1nEXfwnTBEfvMK3m9dEDXONC0M1GK08jOjQZO0=", "HbO9HWT+CMLa4t2t3CwznKBAK+yLQbdNdJmKq/37e/w=", "KaWiAVw8MXkAAIUhkUccYkQnIYgTEPAeL7C5IVemra8=", "yNwB0/gtQb1gD9B1m/4KpnSgt9CJsO0OqRJ/0IR4Mg==", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Aqgkzh/SqMR2Ej46mJvy1nCdsa4ltgA7NfTppjtBSlg=", "EuvJYjz47fblGfC2eZObdLLktAl5ktLtOCr6fcCLSE8=", "Fr4uWOfHkdGp7esn1kjWl6xZLQhcUEUXysBtzMybgLk=", "EfEOG7+ynvglez8TrdI1UFdrrnH3I2E/+tvaFvduZ94=", "GtSFhRT+pjPRHvi4RgpVy7/yYrkKdwT8Kun03lHUMyg=", "IV9LJJtcXmX6vktIVlanRtVk1EUVaMGUnSjjViTNXWA=", "H7rR0uoY8vd3I7Pc9KzeJnUbBWFcCvnWB0ga5BVbCzE=", "IWYocdaV92vjcLN7MhSlEfpqGGxchWr0+DCVDKYBqeA=", "I++IDv45Z2yoG5D/Ylg3FBX+/+FRSjP7O5RDYM66tSc=", "KCHCQfyuvToAOVAeuTDPmoR2Chd76CdUC6Dzx67G41Q=", "FGviIopi8LJnjRE8HpvGjsmE+8mDWEQYgsMiPF0I3aw=", "C4i/RWQ8ygexDUwtIp2fT4GG5dobSnkhvbgQgtUl/yI=", "CPycvqw4bhShEhoJ8LoBl3xqS0RFKL9nX/pTgin9Cx4=", "G1BDGnSm+7NlOwfLk7QbMfS46PAGkTJjDYXWJHx1SgU=", "HkBr6Ff3+DTjTkNmpkIDpFh+PRXj+2j8580WSL8oHZs=", "FI66dyJR7TUVEY1LHNNdHa1ny0SekwU67t9skHJd7sQ=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "LgQ2BxD1cxWYGQndko5ixExEA0ZHhC36MVJvg/TgJnE=", "Kq/PwKZ4KG+Hm6/582ABj2QvXcD83STv7eb0KrQfOHY=", "DAVtcfvgNnNi7hLUd3nbrGeE0Due/8/euXuRxX9l5DM=", "EVUkqrmRfUSP71NC03c/EMe8M7D+AV/DmFG7avtUL9c=", "EX5q3l4FvF770h3UKtvscBWcQnvauvpd87r+jUgkCVg=", "A4EzSg3fXbZocfi9lD5KVN/R+bfRPFKUT6D/JWIlD8g=", "BD6MQAmrutpqM1C+4+klVjaCRaWqwMG1LyM44c4RIcQ=", "LogWfYmVREh6HP844ZbcJbO469AaIomzgsll4REoy3w=", "HDCNj70E4eNJtODOYps/usMiRg+qOjcxES1Ew6TbJ64=", "A0735OCsDT2F9K21vvIUyWUSrMwcDzoRRwtJPUpueUY=", "K29+xOZvreAUARwneVKycJU5Zun8ne9LzSEFL2IxWnY=", "KoUQWFrkwWKyaTda9b821Igksc1NMjEl8GHckPBv4xg=", "GQCLmbPh2liLEJTzEQ+QMjVNGq+ck8qfHdABD5dMP94=", "JWCSbbRUOsmz7ErWSxICHSMpRLqN3Ee9xJT1ugUfZeM=", "ApzOoh2O3s9jWQWMNgGZYLjgzW4IePg1h5R3+jugmWU=", "IiAMLeh9dVJgTh7MR8Y57Jg1Jf6EhKPSRlXV3sGkujM=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "Kteg0tqS4Q6m62gmS6UC2poKWzW6uWmcvCn9j+LjCrE=", "IFkAI1BRF67MBm1Bwa29WtTL8Om43+r5+eh5nwdTRAg=", "IixG4mLKUBEwF/z5N8aLxaLOZiFuzkJUrD0H/ay/9E0=", "GOdCCkTqWx4T9HeYGLl6IIG+IUuutiZx4NrobEAjrhM=", "Iup8oGjFm2XMBWN0qEisZUF6bwLYyqBEB9E5TqG6glY=", "DToHt05lMYyeGHnDNwV8xxLA9TO6ScHGJtG3qxVZNts=", "Bh1SkqwdjcWKtzoKSPb2MSYsZgH7fAtIwaFkUrVG220=", "BYMwEpYLBVEzybpXKCi5FBTNe6MdaO9G9fdgeMPKGEE=", "LydkxJ0bwUJ+UZ92kOMBpiCmKom9RN12bWyhgdAutAY=", "C4qNe63g2yxiuwm3O/dETAh/9egu9N8lzQ+eyqEr//k=", "G9K0sVBNjERqUSX6l3VLNFzOWWam4OzjWGkzUQBxKDw=", "CHwLi3ue0af5FwZvBJJ0grcbABIBFPbrV8JyyyarCrA=", "IP1weozGHSoDFwnatK5Yv1AyoJtXDnSXw0FVltPV/SQ=", "GjOy6ACuKX417q9OO9BV3FblM/REG7JL/RMLkk1xz3I=", "GEFc1SqVkoDWQVTfLFOEac6FT3Vh4Zt9BSNcn6R4zgw=", "LmoxDtPyTYNZaeQB/x34VAgBq2+vqQ5w5QqCMPM0rmY=", "AZD5Itl8in3PChQqO+J3SdHGS8IvHFVqqiSSXRWMrFY=", "L8S6Ox94caLfGoAbKdHrSU46TQcrZjjakF1fzu/ZPFE=", "ARYsdlsYfiDweaQXq+yAw2m24e/r3ZprrXV3wXIrWXs=", "CaNXEICricQdLFMnnJq5ztUu+5zRUm0k3VizF3GnVgY=", "L9+fgcKtmY8iKeZOCE+RSeo/CUjNkoE2CGEgtormllE=", "F46D1/L57ZLT14MofyX+jQ0ovvDL8jFcoD2jFKrrlL8=", "J41oH2A9oYYxm++l0sVWep+1Lu1gYXh876krJ8KKZO4=", "EI/YvFDcxDr01zaGq/j9cLQiRcGvLtzxEJB4SiSqX7k=", "BP92XDDU4DW8+8GWxkZUH6HSfAXV0IfgHAPvESJLePM=", "BgfNj/m4iXc8nraLikNmRp1HDNfGAEEGyq6VwQxCRBk=", "HaUkz/YLZIVtwfXd4P9i2nsYLaJpCPa6blkK3r+RtAw=", "IvM+ruPEgeZYAbdhpygykI8Gb+Idq1+l7B1Mbpndbfw=", "B1+E6ccZu43o5hCDKQ2v8ZqqQzdFTluoBCV3h0cPL1Q=", "IIS+mlfprbgDA6jcr/1Lt3rbaBUWizah02OzhCVDcTU=", "CzA0SfG/S5LSy8Jqs0tCFbbdevAQdHpwWypuM5iIKSI=", "DAmbxoJDU3ID+XJU8I37fvwJ3o+W1y87Pgqt7UXhi0o=", "HF/ZBg1ODZmSZEKaUATBZVcL0WdbCfl3cIscpI5hY4g="], ["Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GZWT7syFNnAEF35xfYra4JIGqsKFBigUA3SPhevpmF8=", "jdlOGwnYuYI/3k1PxKN5TWMWFqLBkqR/4le/vbzLfQ==", "CgzQG9ezwhVS7nwLqHg60jGAKqT4R9AN6CDpF24id0Q=", "KH6qs+WcHN/OMLYVFUO270mjvnIG886mLbToD+HKFSk=", "KoIw9+0F9+M0+RzyFMe/EoUplgg8RWpQbrMWwknPtMg=", "CjjwiWAHR6a241NCwuMhBC6/aQcmqpQxAxNRy67ftao=", "HVMBFop9rGiRt6n2281QX791Ivh1phJUFJRJhp0xbgU=", "E6uvx2X7LkX3k2QL1/HqL4jSAvDXtCAEEM2WEo0+9HI=", "DafiRKQgI3+9hzDr6gP/9FFWpSrIe5/2Bf8bog9+g/4=", "Jx0xVTJ1Wx1IgUaZrxhlS7MQu5TRJY3eDlibzCpeKLs=", "Evtvkv8EtdXeQclQiEJ5iouUVKmfDMSakq/q1ILoS7o=", "JMv5KAtxP5VXGxd3maduI/VV2ykKEYeqWrfbaaLdorY=", "AY9DyZobcufL1v14GkbBPDggK0sLp+51zTb8t5tepn4=", "HGlSiz35TG9+inlOoDCPwWXxvBwePvCQx6r0QF9887w=", "HLDYqmUSp1Q72Oi64cDw0tsbNFfhvMD/03LU7uPG+vo=", "Lh/OFZdZG7d27xY0Cu3a/9rwOUh8tCv6Z1Kj6gz+GPc=", "Dkhqe3zfD9uIMG2W5yFh1FSbKBFSxs/JjYSwMelcoWY=", "EUHiaoBpi3QtkA/R5zSDnVHk1Q4BdjA6Z1gJrEcgF4I=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "Dj+N2t5UYnhkgJXMg16UBjlysdVcZBRQZZKrV+VMgEI=", "IZM6O8SYk0ewcD183t3q9liKFm5qP5hOMY3mPOZ06Po=", "LKb5RfX3VQOcjhvDCTXeGtMzEqfPMlsGX5EIPPsAGng=", "Epqa2HaBXZZWZgCpfUH5WNffnvlykd5hHSjX2bKvRvw=", "JrjyAMDQNxVYdVCBIh3Fl2evxaTdvm99QDxcy0A1KJs=", "DHxzk3ewrS/507Co+lPjnHAW8Enqhg6BE7BV7JbuPWQ=", "DRejZ0n4+dSToKV72HYYyWnLz4PttLIHyJqlzLP+sg0=", "C8/hJm11dQOIHVbH5kz7vDy2pH705lVWWGTgG5vT+HI=", "AT+J2wbKRxsHrArR9ESMsiWGi2MTFwDR3d3aFubV/Mc=", "JNNE6gVQ13IIJ7a+bAmwJ8jkrRBNV9V3ccJYF3owK48=", "AgjOiZE+YzrqOoVahU59rsQK+hk53B9yjd5rNJ45ujA=", "H8RWUEHYEKdQ4wahTSFpUHTjHtorrwghd0rdFcDi/D0=", "L6IvgNQwm+Iaspi6S8FqWyDyzo8+17w0UxNWVdomlkk=", "JvOiOQPR59g123DzAFs9WmcEP8p+tiqo14lCoMHMit0=", "HOA0P66KEuJfI5HrA4sjd+fAwhqmAQCBhTnWCS7ur7A=", "JEoruHDx5vS6XiDxwiVyPzBYQb0KuTK3M0mQywVywz4=", "HsYekSb0yP1vDQCyjF8CM0wHfpnss1jSU2stMhzACq0=", "GLKrCH4/Cn+oprwWh5AKVIHqmR/93wF/9Sp/Nxwi24c=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "FAuRyg5TEQ6Jime6iFPQSCGVLnYOVt6YUYCXWtI36lI=", "AzhfUEEsxtTKrquarxCZ6MPGEpV1Q0VTShR2FEqcJng=", "DMOW8LgOJjhhW7SiUPhOVN/jPOdjhu3yLaLbsjNUasE=", "KBDY71DehuBM2KB/ZYWgbqvErF79xEEJBNepBuzRctw=", "H4uFAenbZ4zCdLMyRuOeuVY1rErS/3WakgGsDD8WwSs=", "CbEOUNwHA7ZRmcbP+FEKnvIXJUXzZuwqrtuy9a1OOR0=", "FYpumuRNHrx/uZtbOOUTklfGjw3eqWWT/3qH3+ecu+I=", "Bo26PrnxuQlwfmZsHnx0UZL27C2EOcGG+vbTu5eLQqg=", "EAvph3VnXLCGTLVvo/grZrIWBx0QzfhzWMfka+BVxyM=", "FoTEsRYGO14Fy/TrmzprptaM4fMK45eOG76npxvSDPo=", "BnjPTkVfg1n0mKIrh6Pb/FDOIzy72ZmVzCWeQZiZ5T0=", "MF0RG+rz9RChBO2TqiVPIKTFOe7KlXVq4Dvb3wyO68E=", "GXsFUOjgnDdfSxl2OVrmBRZJ1seow5t4Z25F0zqGMNI=", "GQcSko/GrIjyTNkXk0i0ooMnSNz3COAcUO/NMuK4PeY=", "Cne/pBE+mLR+jXBan2AWC6FEujRMJ0dE8TXyB7JJKe8=", "KWKnCD54MNKH3go0NswJPg/XwtljG0k3rBJNWP4/uQE=", "CRpxWXa9meQHd8EZ9o6+xwHjd3zJueUmAliKX/iVg+s=", "Bh40iMySiSUgRJUYr09BM7UkEqGfuLmNPQgS3qJjbjw=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GXzlm8h/Yk6WKbc4NFK5hYNidUunbKvQ49MWHrjKdtY=", "J24uYnKrKFgULw3aoDj0Nun0xT601d/YgSzxDKW6saw=", "CcSYManhxFPQcs6D5QiGZrVt/RrQl3sqvLKqnsg+LKY=", "KkqtvzGhxYomYm753jQfImi8okPrhZpGWRHaGK8Bc+c=", "IbBGDfyGRYUb6I6W7V9nzC6l7gD08wJexLUlNJQQWkc=", "EgqCiHRfncNgyx1YCwErUlQwMLU7m5eskyTfefxG3wY=", "CfDZEfXrG770ye6Wwv7AsMAJRd5HBrTL9k9ioCAV18U=", "DdASTYyde3wgI3mgASY+BSLOSdEIH2OBYTStFrs0J30=", "K9gD4gyzQd68y615sFPfblP1Z4dKUt3rlCJ1jnPPbsg=", "GbK0sOJL7nkPughnhH+Uf5dd3fvjwRtMVm7UZzaEwM8=", "Gs2pfHWSmsEcIcsIHxd6blUDMbJnDmpmwnk+TKS8w+E=", "JRxwqTuBJ26jQ4cJuWNR/YAE2+4KvA33kynKpNkyvWI=", "AokYmE/9/AETjfP7pSIahgTJVLfuQN5wcPsONOcDjqM=", "LqHP8k8giu1vTafPg3gX6/tvVFUo2FoyQwq6NX7vd28=", "FbYa2mgd996AFUe8mTexwudaT5coz7VYb3ZbBYc1zL8=", "AWpK0rRTAG2fzvMZGdr33tbe3/PFs7pP7WkuI1CJkWc=", "DozdfD0zknB3VDvaWxd39jadBodrhjbLlakGDHk2vpA=", "JhUnYOXf6fCi/pAb7V4N/zBJgn5DoQkeJK7k1FdJCmM=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "HOVuFfQcmaKgBazH94tzXoMw26TbTMlsUktGOAEJN6w=", "KzPvEfwmdQ0Ul98Poblp8cAcVVZSIVD/l2kSZJrwapk=", "BH4rVIMMy3rIk+Oa/omx1+rDXH7A8os0PgJJuSTxXTc=", "LoIDMscmavKlndy1IG1ASCfpVjyixd3l0tNL4mnIJhI=", "KPwSP3ms45g4t6+Phr6Mv4mjVAAVvtBZ+3pVho7e5iM=", "EhrnEski5+9V67c4CfMDbbQoUsUvpjv/MiI3vYg91VU=", "MALyWn744DXA6CWXlToQf8c6WkBncN1HypOjTN+AQKc=", "I+os8VnKG4oXymG3O8hLM8pyBMQSDOwIdCRHDdBiB24=", "F55yFGF2vRUFHfeJ3cPQ9IQ3yXMjKEbkIj2vBVKSSP4=", "Je3FKyzXu2aQaS11w/G5mfKuB0nF0nQdK1MoS1ZV1G0=", "HNvqdshldQzrhewX8gyVXy7dRt8J8K2Q0Ez0FrEPyq4=", "Lt0prgVZEkThEk7cGVAzpASqmKhjZ403ad21eXoqdI0=", "LZ0qNCR1zBZi2lsmRT77kvFUnvuscqEiY3NBSkmhNZA=", "BHgzSJBLvYhL48YI+jSSh9Lk1ChLqqybb/7RkqZBQG4=", "FYjtSQuESM+4g9eQuw+XovGWLRQonJRrjuSaTdz3o+s=", "C/EH38M/x+ZhU8fl1r7t0lLRe4yhvx9kmana/qVw+wc=", "IB0PFa7wGh4LQB+Ub3sp5vARR7YlfX7iNcbTGcRHQyY=", "EBWAQANQNmix2/m7yY7qME3N7qTrfa/Ge0GmRGrxA4U=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "C+4+Eo2udQBc6wldnm4OVShf9+3ZbciWVPW4NXBZNQM=", "GFPPPr1HsTsvIYmQ6z6iY3nB0hPnD+6luEiC12JBzq4=", "AsJeUNNjzAh3S+59nmIyhV9tiXerFp44/G/HbemmPm8=", "IczB6Pi1rTm0AfecUe2IHsiS0qfuu4/72EjvFYr8r2g=", "IZOqlOzVfpYmBKtCiqColxZEcHxuhWY++bNyCmhdcbA=", "HTtc0xM6BTPrFc2QjLu13Oduz1txHyU16FKqRy7kydE=", "EfKdNY3nbvONMdbXJHtk1BxC693H715ERceJf1etCLM=", "D8wphNHSt2LW+hajpAf00+7EhKkSl2OGQmWt18kAg20=", "L3nQPnMjF1hf+au2KjcYAFU/HrcXpxQ34iWyBMGPnps=", "AvTxTu5jgt0MVNEHObNUq/EEzxNLq63y3/m4zyhvlzM=", "DQxapLxPd00D71svlhn2GO3Zr7N978xCCwqk9P0UXoU=", "CbFQ+NyTQsh6i36HE0XlmYwIRmLIl4md9F1zFXxP0PA=", "KBSIYENigM2KX9ZkX9HrhqvbctvLAujvRwZaSmgenrk=", "LPYZ/jc17ZvM7fvfPeZAMc0gMjGg4XhBe7zer2nIXRU=", "Ay8WTE9OUSLUOKngMJRZFBUFYhNDqxwZq7Y858A2rQM=", "Kj7971UiCM40QWN+LNYQOG9B9AK+xFLWdL0v4WwnNYE=", "Gp56E+TVfNGrPjjwmR/KpMrFQvZvwqRvnPfSACnKx5I=", "IIcZCKDsBD4eQ+4fUgWE8Vs6fySi0Dqh3lDifKWZ2HI=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "R2fvQjQdOTDX5SGfq7/2L0ThA7OgkFz/rqWi3uc8GQ==", "DEoXhuUVzZvKsrfJcjxZfnMMUyVVADyuTjYTGnIfb/k=", "FH9GjFjer9z0flcRTfDq0sd0UqRQIOc5VcsVDhAVNSA=", "HRMJ+WEQxw2e+IQ3Rna5zDpZn950OI72jZnlS1gCx2A=", "E0KBw4ft3otvgH0lO8Cs56Yl+zwfZbiORTf+v/UuHWI=", "L+wtlyrEuLoUu8lc7irGy4xmmrw153ri99yWLcza1Zs=", "F4LJ5FHL3iYdqLStOhXiPvf02ve0BnMt4FVwxzBAxmM=", "Jhv2qfaOMTCI2LIBbT53Y6b27s2bUG/SuqjY81k7TEs=", "EzMVzKNK9Abq4IDt984nV0+5hHEOTo7Dmutkkbl/mLc=", "IWdjF03bA5UYLr5X5P65G+jxN0bomUlVfgI985fLZ5s=", "Cdu0K/JkWdP5ui7V9JG08B//YiLGvdt3dkUO22xlLOU=", "DqgyqWmtHZT1XLNPNccyf2LyT6FAgXsji8Z27fH3e2w=", "DafcOVl46O4A6lulEDo5kw4oRTOxpR+809fapUIULdo=", "GDz1UFO3mBrFBv4cVv7nP+OjmuBCFx4hVBsrcxJhhyI=", "Fuq/pCNrm2G6GzNs5V/r8cyEND8ESaVIc8zPzg/5OJ4=", "K2LBCD+8I/WP1pRkZJm8uQNoouY3lLHTnbqja/eC42M=", "EezbxHpyE4qv5EJjNW0B6TFUGtSawowEhCjs0jP+PG0=", "DrDhx8rnw/SRz/chbdzlCuuYk15AUxbG2v8cIQRq+Z8=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "IyPImMow9+j86bMdISg9NUVwWnHQzpV3xQEv3myqoR8=", "I3P5scTfbFAHaN2xPu3s8Kgr2mApwKv5Dz8V8uep+Ho=", "K0oeWaUrG4Jfb43KXvZrkpAy2rMqnTpY67RIh/hMGMo=", "MDSumE8VOOIWMUhhd2D2JWkjGmGaDitiDSBiEbIy7yk=", "Dx+xb4PI3daVnQGpV2qNcMImoaQi/66J7guu6zfpqL4=", "BY1YPc+XX5fb8x4y6/sIQSmPdlR2suSDMmCtm7gvLy0=", "KxBgqW6KbeWeLerIGxfUDsqqQIcna31amsK0dZjC+ss=", "BwV58YaRVKbvy1n4W0O5Cv/nVe/V1OYmhq/0ZkbggI8=", "IURNJvneO5/SLv6pXWL1GTw+sLLhprOT6FmWQ5qkOZI=", "E4Zx+S+e2agTH/TH2mgG28M/bALP09lGqpIojfL/nZo=", "HmKde49h+gKl+y+xY6Wlelk7FY33BBP+hoszgwekSdY=", "AQ8PiEGG6ZbBnOSTm/MXs9Es0ku4e7oNO7djq3Fu1Bs=", "Di8GumWix8hQCFC6akiYeSUtDbKvad0j+j7RBsknOcE=", "GYI7Cvn+sz6gdWZJXw3gXn6/pSqon1pdfGb5atYMgo4=", "FrBSf8aqxLRIXd7Qr9iQXmtT4Fbv0z33uPwtPUtUzQ==", "CKWE9RCvSVcu6Gz3IzRgZgAuXnYh5QLpRvjzUAO3k/w=", "CKY0ZsC7vf55N18YHtAmbJfmBXZT0LKFaWpe8+k8J8c=", "KK5pyHSjqx7mNgux/1YPuraVkeg3pLxNgP+00lPiMsU=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "AmdRqikHkqT7OSHZ/4tZZ+/faLH9hZgbTZZAG8Yhs4E=", "HLIV2Q9AFcxZNCk+JIstaspOCv1GzKIZqJ609nYZlIE=", "C48Sy+cVLW8+X7vpeIhKW3vm81/aTAD1xZdRWN8vM44=", "F9bY/l7eG6UxkYwz31xsnv77wgMEsvvuGcAa74Epl3Q=", "C1OtWYpOFESP0ES4zhW2M2r2uRz7gcDagn591o6Y5Z0=", "FeIO6PxXMzD6Uv1C7HtjbijO3lQ3vjcbGZCJh1Gt63Q=", "FU+o2cfwnB/8f9/LWP57kebYGwOt+4+eL+BSL298JUE=", "DBflm0dQ10Q/gDDybr2C0lYj4rjlVAy6HzEIKOXmaYg=", "B9++VuaudJkXuTRxUlJVhT+6JiItReBQTY90eEsahvM=", "CuTNUJdahq/yVjLoybfA6RW8OBWckN/ZRZ4p6pQy5Gc=", "H9nMYbZ9cA7IkqjAmvZ3yeKAl0YwEBJoI8ty0HWDdUw=", "G7NoVrqJkjNOeVYmSGpGCMXZoHbNk8iqDhqTSuTo87Q=", "L5zOUFD2b0k8yVIT20M2U2o6DioXMRzswnz9nYjjOdg=", "FIOe1p/uq0nvEQVW2WtPF5P4yV86ON6ADpyg32kPlY8=", "B7XFr7aoJszxt0DPyKpvAnmrUMPeipj2aSv/jO2+Xw4=", "FC93iLcsX9WpBl6+9Z9ujTLu10WIz8Iq0JYq6ySnvQ4=", "HQfWLuttq+nfT6AK1kK/p9Nmh9bKnI8COkC10EvHiug=", "E+Vcq8C/u57UG/IFvgZ06GaKiQjEEa6CHSU52MxYf8o=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JitEcZdj7ypIblkjHZYkvPHsuV9Xa94ecIjdWn5KX4k=", "Lf3p5epUnVDESX0ltKTOzQliJiU7PHw4dAV/piuHQ+I=", "IaVn9CjXRbTP3acQAWOHGlOD5djrvaZvejBaTGvgq90=", "Hdpj7ttjZLXaH9GswotqV7mkAz7ndJqMKsFSoelNS08=", "BoXiont+w/28vj4BeVM3SXb/hTca6pEJwtdvCuHO7Nc=", "C63UxlQWE0IqPCtxYmrw3384DW8/baZ2t+bdpGP2P/w=", "DicDEeBaZP40+rMBi2hhbwiiv0wGpHykV976TBmfuWw=", "IHgqv3IW9sXngajwNQCZVRxemho9Sz7S2YXlp/Vmsk0=", "ArGmmfJrH8S+sDHfTze41cur94BXL9xkpW3gB0imXAc=", "B5Hk/THryF3y4GquKe3YCPEpST+Fg3MkkvvXBW6T3uU=", "LNo1vokXMr7WI5LN3QBVe29LGV4ADBvU/PtgX442nWQ=", "BrF3EISdJyEK+z7Mp+fHrTv6Ngdd3xtG178KVXx6+6Q=", "KhrYZSnackhw2/O9b8IMzMGZgQLPDXAHprImOZnk/NI=", "LKemkfF21wnIeZtQlNKKaNtgH/tdEzzfy/rp5WXx7YQ=", "CS7kfNWNMDi/gMcNeYUWwNw3Huf8dxXalczdWh6CA0c=", "Lwo/OrkDPoZA6cG3ESsxJCt+tJODe4S73Jz1bOWFh1I=", "K6+kR7T1uHjoEup7JGfHKJDBGZkr0fbjymD5JugS0sY=", "BvmA3sXWs2ZfHPn+pyXs2th0xcnLY+eYf7QedDCj41I=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "LWlJC6LuQ+hBki6aQmpbvCZPF+03n4vJGuPSdeckwho=", "BVxreJx8lYbkyI+/TrYHg8346eWNNWu6HvkvjsNRSqw=", "Fg81amoFppGdx9LgOHjG61UqFJle3KsF9iMnPAzSmhw=", "KheOHY5ORglxBJkkXckeZvN5W1wCJ6K6jMip+IMKohI=", "Lf8kmLUSTjvCWH87HP7028EWjCFy3EPx2AHLdcfhj/c=", "MGLf+DXqHvj2lg0F9XNo+0g1fs6C/X7xLLUlSlXj0QI=", "f4Patq1EkAo74uBJusRPxer93A4mHtXReV/VE/EnIg==", "GgN8LrhfHdgryZiMZ2Ru/taXRE6ic5toANIU6PxSyNU=", "F8ySqzRkoInk93R/y+5QQ7Wb+dfLdENGzC2IkFFGMGE=", "NuxjTBEnQB+aIgZyDibnGYcCuF3rIxSjfB8GIXz61w==", "E+fnSkntlMKnFKRrEsGePtZ5M2SyJ2OuLCi1MxhmlRA=", "ME/s0TMBEyn5iVQEeZVpHGmR6uunFBSUUG/Dh2z4Jos=", "BOhgyiBeTXjw2T07dD4tgtd3N/qvJwTlVA4WOu/nW1E=", "EozWSU7LqRNHNwOxEPvWbWJ0QDhKYYesqAiN4dUaqmA=", "LHERuSWfT8pj4hitNU6RB+gKQ2o+gtYvGAwP8ccFV0M=", "CzkB7Jbqhkd4ppiGaoUhcOrFPsXAXAJDc8s4WFl3/Mo=", "Caon5/0UDf9qIPdpbIVwLD9grljmAjMBK+OZbYOfjW4=", "Hj1RVVr0wzIWMKodETT/YxziWhK3fTwvMGikqYH3lJE=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GbmjdJDJsFB0I2NelfEKDyei3Ui4QDk0MutBw/uaomU=", "B3g/rK+pWyduUqTmlXthRYBsZPXAMF+sEcFAleZ3Dns=", "HdF0k2rTC6c+o3IgnKI9UYaLIeUzy9Ff/UOMUclRXIk=", "H6a9ujg5+v4O9nu49Q8r/MqV/zTM3Qcrz0RR4bOo8Jg=", "KjEW9/BQhpvUsBgSRftBYT9ILPgdCblYmPn4E8r3yX8=", "LBaQfp2C/go3md0H78EGv2DRFN75WSYUcGIyINnZIkw=", "A8NzoGZPA4lwL5ZsEkNVeWo4Geb8vylYO0oziRlhv/c=", "LmcZXFRb+G5XN+TSjb8HXBHNIZZRJ9pK6sE7Sfutwt4=", "Dg2BbNg9/QU1qXBqqNciU0LNdrgtLD3wQlhX2SrsOPY=", "AdYjwFfM6vafRDjVTpVOWffwQGWrchMtp4iyj+CK5AM=", "DX8wEH71fHWXXlpIndLjkFPRLPX/n3S60+ZH1rQnhlk=", "Ay90ZtYubJ3YwCBkrBEgQrkILH6i6MqiZtBKaPnZsVs=", "KkvGLSfnIKnlPALmUZ7NxoTtQiIsBjxpip+gJMG9Bmk=", "LxHa0WI/V760jx94G92c9XdS2rb6dbZELbODTOv21a4=", "B0SLV2Jn3Z10L/en/IMk3fPzQN9XWRfRWDJWuKJsAB4=", "EMBuDoG7pROThygsOIPFln0eutftFk+XDdaX3gNttcQ=", "Awx+FZWhEQEUP4mXt7n2PSZbtp77Sv/+NutHrE4XCWA=", "IIGt2aafiAEQRJ+IPfGBaxQcEbxS/uTDVYIVAeP88F0=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "KIlJ18KbyitS3mepcBks0ZU5DH7QeI+B2F22TJjHiqs=", "JYnu/onuZqZQoncA162e487RT1B1NkBcIakIV7ajyOg=", "KP8AiqCzp3Ms1AWWIKdqnRz4KGpe+E7k31S0NWVvFNo=", "IVXfRnEwQc3mehDYLHwTkh8OOUvGbrePkEd4LNF+pkM=", "LBb7hQWkqUp7XHdXksq/pi4BSzOlR5qBwvyKUugETTY=", "Kx4xQ2K636+EtNJypLZQlpgwUQTif9MX+70BeBN8xwg=", "LCfG2JS6Sec2Wa5mhmd5ahVHM4zc88NZFLPT4AT5NcE=", "JMTXCmLXeegxo4pRAULIiyBxJR8nN9vaEE3DzVWFBB0=", "FyzWxM/KoAhdtZ/6YFGXH++pk0RYpQteO5i+9gU/f6k=", "EGh3b2bW8E7c38bmy5Rz7i9X1nCUHkoZH29p57ymGg==", "C1+9UyCZ3tJdF6i6TbkwoMllUFb6agHFboJYQ9djeQo=", "INYrjfKLnVZ3vU86yAlXcr7+6LK3Yfmkp9m5qnGSCaw=", "q58zLg0MTduZj81tpmio90QmDj6olHtvYYnKgsXbAQ==", "KVNjmqhMbA/u28ceOvTkoVvECPXPO6K8uYulvAHJh1o=", "Gvw7YhhxkOkBhMbx8YeAIPDvz6OCNfWYDsNywtm0pW0=", "AsZ9EuvM0FmzZXNjAvAdqQiPKkCuSdiOWMfsq4BiHbQ=", "I6MpLkBXi1/jKwx8oViymPx9Y5fKPUalAVelKKatppo=", "LVqSzjh41z6J1kXzXqKxefrepkMQ/3UqSKlKq5V82mY=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "D7PPPYL3RC7c565Ywvy96YOpmRv6jFg8yehnUXb19QA=", "FEG5LO6vPpO7dNhIdbezL2YhjSPMJbdH1SI0TIU+ac4=", "DGZQAwiw+/75nY3aPuIZ7n+u62rHyZNXLBOpOxcsCaQ=", "EEKBFA18ZLW9QVwlCDCuxonlhoxYojlsj0r4fAbAphc=", "KX1EYtuXhkdSSLObzcQLoOxmLl53L20HwxeJZMhrtrA=", "CILNafXxsMFPGl8Uc/RJUuBC2BE0olxFoB5NmXdhtr4=", "CmY8EoCl9NKFUk5hY674+DpCrEqP1tPES/AcX3Y5PnU=", "Bk/33Eat/vRLQGRsea+pnQwUymvb99paoyLzRvFpv0E=", "CQHJWUGQuE7nm3KCpqW/gs2m0o0cUT/MZ5tCxdqFcP4=", "ISV7dc3R+snFo4q8FSdN8qoxit+tM6UmPqPNsaGZBXc=", "JVzwqCP6fL+c3mcWHfc3iWlzATjzurObW+NXXdYui1E=", "HUsfurouBk9Z242KbnKrhNSajYL2ovn9Uyyqw1MLvbc=", "A+Xs96OU60U95s/T/o2jb4JqvglrFa3XvCKtptLsg60=", "HwaO8d1I+JNAN6lclLN0CrPTmaDjbN+Mka2zntkMUVE=", "E7W0g1Kbrc0+pQtJG2oEL/6cOPJ2HoNn6sThGoUhCXE=", "KJVYRDgcqoHskDJUGr3z8At3uagLn242PPQ2ngsbZkI=", "Kj/jTQ5ecgRKWvETJVsSnXj90vzMKA89a4HJhdFs0og=", "CHV4JWhakNlHa1vPN27slVbEGBGpwBf819asRPu7ig8=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "BUVNN7qjovmZpT+1lQSqv+4FEIYoN4o6n+tYdmPSdKQ=", "Epp7ivg2QSVy4Gd0OUxpva5AM7FdzCpO/BDVtNhQ+wU=", "DLvhIapgyZeblB+U6GEh+YTmczRwjrBYUHdxhHNKCLw=", "GSWsd4PDCLtapTdp1DTETeb67aYBWEhpPFD9/H9GXYY=", "HiQgazX2c5Px1hkzrt4CwB7L2c0Skp5IMA434d73sfU=", "BCdnN7UZ7eFNsbZS/FYWlAjUzBq/BD2KnOkKFkR6Bv0=", "J7lG2R5EU6SFTCnNJI4M2jKdZ6LqZkUNUbV/ixWd9f0=", "LN7AVK0IyMXjFYiVnmBatbBRhRf9gJ1Dftwn8z2nWAs=", "JuQ0GQ1TEl/HcYv66fNPISTUG7UbssI8N97qhAfaNSM=", "BRnQ5LbBIoNo9CCSbGn/N+59z449xFxOlcghR30HXto=", "Kq4fXqYBXkrPIvlQ9mIM9059e7ejPsCbNyz+Vi5fLhI=", "L/ucYYeZu/A+BxvKJtEwqTajgPdPbkdfVnrf2a3Caas=", "IqYJExf0dPeA0sThHXjm64dWhveX+CqLp7MhKHndY+o=", "B5sJP4DYkWJVamU9vnFJdZKLoQz9Xx0L1HwP6mjwNJM=", "J0G0I0g07KPf061KMGQkbESW3v2Bl+RQuEFuSFICjEQ=", "Fa3A7yrAm6Fom8O/IeT6UBQcAInQCoAiXzmo7mPvADI=", "FoAX/hk0O119hHbAk2oIcKyHvrjvLvmwLLdz2tctJAE=", "LcXWSvq98Im//jFS+ispBybLu01S4+CKtSsYdgcKiwM=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JjExLiptlzRC1d1+/qKOUHPFzBfIeMxZTiw53qelGVA=", "GuL5bfmhpxvill6x9QT/51dC/3+BpF35CGgi6k/4P5o=", "F6S7SKJHxWNJn0txou1HY8V5ujgAkYTzYH2bS1sllMU=", "DJoOvjYQhj8NppkvGaVlkR4U5yaH95jZC5jywrJL2mM=", "LycxIRCQkp00ns/yFJDvM3R9SkAsjBmVuCcpKtKZIBo=", "CbenjtjQYq99DvVeRkN2+mpO8N4ODP3bYJUVY1mCVIA=", "KKux0+G/1o32M9GUCLZuw0pYBUDrknlPuqAz+OsOAbM=", "HiAUu9XS2y+XdERI8tV9Hie2395IYIWl2MEoBY+g5lY=", "JfnvEdT/SFNbkwGjGlQTI2+7UFaHRdRK+W1dMHSQ62I=", "JBtDDFLTIrsJceEn5OaP0/rQqEXyNbPoC7UUoAt169I=", "IbZgOJbS/SPPqbjbj9DlUN7PKe7AFbXP1mUxPZEBS98=", "IGaiIu04X/fZYg/dA0O8Z9P+kCfEUJF960wSarnFhDs=", "FIqyJ3hmudDHLquN8wo6u2+rFhDhZKnyQA6jl+Dekqc=", "IrUUzauOBdWxKJl4v/I+KqdjVl/lBMfju8hgaeA1Ijk=", "Fa2zL9UxlfzlgfktrRklsUxic9Aqc86KIemIlEZF6Ck=", "JlFO0CZpUcNcoO+M4d5Gh07BMv/+xigH4BgxZk60J80=", "JKFAH//jyGRRNVrdf/4k21Zy2GVs9RN3w4NR8f7wmm8=", "U9oU5eeiWJSgsO/bBWF9TwkiOYAi1laxPSSsMcZoOA==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "I9TV9CsZxzAVwMSBRGQW2SlGnfoF7EbfAWO4NbMNCNA=", "DDQULH2Q+WZ3CSTem9AikPKiXX5ifsgLs9e6M50OiCk=", "FWk6yCUBjlKg1MOu90DJdDfk3DMx1VKhyOS4o8nhdvQ=", "DB13AdKxlXgdLsacnJG1MqMmFj7E+i8NxK/MWFQKzVc=", "KfVXBrgQXgJ3DhIVjzTr9H+n7zXyymLeaZUkvlhKF+o=", "FZSAeK0cnwjAP6zD2uvLqEagLNkplNcJrgR74BrhxnY=", "H/+YX9HbDgRdCsmD5gJZK9qtx+41xpb1XaC8rXXiCho=", "FrNwMS4gEsFfoMa5YZ8M4k/wWGwQtL0CWJ0rey2uTv8=", "AjWBIKYKAWKK6/ZfxyGB/5oOy+6a4UjrtKtL3JshbnY=", "LxoXEtWn7u+GR8ejLCyUkcEOyHL7eoKAvV82CjQRz8c=", "I7jQIqjoZtQJXKxHx7pxEUKfbAiVChneR2ui/YNrbPE=", "E5rZbBQypTtv7jXs1m8rnajOS+o+vfvSxKdZYe/g2JI=", "0aN2KQPPMv/7AWgQ6xHazL/y19vWsqRHrTL4ENiIkw==", "Hi/K7PqqMpJPlksCHdVSysQg+CKgpx43woZUIh1HK38=", "EhAplGaPl9iHgS8BURRBEa6xnnSOsZjDp1qZZRdvjwc=", "Astot+Y0NHVCcR45PRiLb8LrD2qrenzJF3VDs+xtfQ==", "IVqJUiKQ5MvBQt6xWE8zatQBqnbQWNpYa67a20wLe50=", "BQjHDegGy3imIlDblX/l7WnkwzW4ZjW+dKBo8gB2ig==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "A/XRDT4t/cqq9dIlG6pufe73/mAW4OM/Z0E7V254Q54=", "BRYLOCiPd/6GbDU+P8S9+vObVPsiwDYca9qmRRMdzTI=", "Gh9TWF53IH3pP/B3QRROkLb4hY9saNUrYslu/jGariM=", "LEirJQFeC90s69GN9+33dmoo11eCeBjChPFTAt89AoU=", "MAHYxrLAqcTn+AyyaI+Qnbsbzpa3q7iE9AUVisqQrZw=", "FLp1m4G4EV0iCzu14Hfll/gF4w2WHQKxMu1tbd5BbY0=", "Ljs9loA6cchG9WVNO8Q/ae3WaIUiSkb2xbZ5Z82bBHY=", "FRWATTlyp5dUW/1RQ809PCuFsYtzT7+mDiin2AJMuMo=", "AhIrFAoX6Eoc6FSg+SSru3lB7riviDHe3uIo5O1GLjg=", "Hv7/uZiuVRCzhv4Wh6BLGEEeI/UwDiaw2ucaHaahbvU=", "CuvgiQyrGo04mtmKxOVrdOEXbd4IzZCwtpA3Fn0iHAc=", "E5KBDhNVAqONEmoNvCz40ZdzV9vvpNhEhNNqSm5Md5k=", "Cv5I8CSK99LzUFdmfnmgjCwr/9giW2IZ2U54XEGnluk=", "GY6zI9WxAOiR6TJ/Zh0VhI358uO8LjRpKwxkT/CRtiw=", "KcYkVqQwUX/K7PGnUqVdvyRaiMzWZOHIJNphAAkZxF4=", "KBemhuWhWokhLf3Paf0V+nO4vwpcXNiTNyp96xjRp/c=", "EtQBRAuwMVODDprbNJ2JGuT9gMu+QUJQ2fPC1xRI2T4=", "D6GxYMYhKQcVUc/cDThLgYZr2gNBWUdc1RB7kgRLgVc=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "AwRtHZNMylovcDmQfnjNjc27UMXoyrE6eNr87ye6VZc=", "LXJKLOln8RFaMqdO589jdgFl/EBWIQCEdts7tls0a0c=", "BmhP+8PppyD3rJvpyGfyUyJA/J7SDCFDDiaFq7rmPKA=", "HkyqL+D1hekb8BHBdVOW053Lww6Uqkrjzu/Tgf78DUM=", "JKlQmQj2sKSu3ERGR9HeFzB42QDSPidwtBBiRHK8/nA=", "CkROszHjqdT5gDn22aekVIKthdbp0JF0hrroKlBH9yk=", "DKrFUNc5p2mdXavqvTvbXjdEnofwe5XMuC+nQkcbjvQ=", "BODGepEfgPk3IM4n1M4oFffE8uXSNMJZ/sv1YvhjEh4=", "H/j0dn2uRxwMKkwu9EJ1qvB+HhVZiaXM8eEFN/hg9y0=", "L2hj2wbJre7bhHCOO3wJHPRLQlECP+j2vvctYVGedlE=", "LniOu1r4cbntXp+rB9p7WBJhCYB+WRXm9U1899x5GZ8=", "LNr+WZ5CkJvAR1q9308QpPFN9aLA9Cm++RPO0xXRFvY=", "GwpyIl2HlmQLFv7BWljhHUvlqaRz0TN/u0la2TtDL2w=", "HLOHopozRbv2zEB6gZWOYf6Y93CPQLuLlnQfcwx+cIE=", "Fe+IuiJlJ4DrFLOrJ2wd6nmDYfdjE0TKw+dxoWkQF58=", "Jok9EkiVxDoaJx5ypfmcT6n85v+nv2wx5JJqTvuIjmc=", "CdxYGSshr49gM72E6fXWlsYC4LtMkk95CyfffbZ1BJo=", "HWWfZ+pHIojpQrqoU4ieR0NQVqLaQ5isucoojCQEx/g=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "F4Es5H7UewnPn+0IbndkAQ5wr+9jqAbZiQoMMRP90V0=", "BbxEjhdElkTUHvOLdioYPR+cC9b2AItMkCyj/aRdnks=", "uPFLrGfs6LH5qWD0Nr/Gp1rlQZRWib94uJ4tdo0bHA==", "BuhDrFcR/l51Ua4lUGh1up7vyTVj0V4D8Vu11uMHspQ=", "A3xZSKb23N1DePTmIgqW5PwnyP2xAsby/gmIsZmtKGA=", "CbtV5ZCLEMynjdrD56iAz0afxBjIsOwOL5YiD83dmD8=", "BUmTjuxO8WrZ2JCB8nviosSvSa6RiYiuVXSWW1BvASY=", "E7QhW4mvBlLVWY6ymzTKmAyxoetE6v8Og+2LbvXFy3M=", "LY9DV3+yZyim8jBeL4aKQpisX0vr+EGfByz3Cbm/aXk=", "BYeCqeiGDLG2AxTSsY5DfzbBabU2LgdXWsqAw7vPgkI=", "D27ZyowZ6rDFEA59/yoeTQmzwuyeGamqvd+k3kkDy94=", "EcO6c0zGB8+qvHPyIMwh8kIqteMdBIGBN3kwkgFaEVA=", "HsvleV4PkvVcl4TXaHJxx/HZlHSkyfZvpBYY0XNCZmo=", "Ltb6Vag7AUUsnjC5iI3qlUTBDbFDVsrOjc3c2wov0iM=", "B5KHrZ22zlTokCli9TQDc1p2+36vL7kuj8fmzsiQiFs=", "LiaqXOVsCBUebIRX4MooChzYEX57T+aJUFi5ZIWdc6Q=", "Coiah1hKhxeK1LjuIjDrwGMBwIz4QH5jHnHWRnB5rDo=", "CcKJEAHyoRnREmZZww9hI/Zb4HG/k3KdKnbZvdQXmM4=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "BR/OJBg9dcTdUGyZt74F8NMmqXJkVzDCp2ur3Yx5kvg=", "EJTM9Nv/OQwC33YLeK6DYDSPnOsYcFmv99zBo7XZ6Ms=", "LUlmZnuDBmm1/NYyxvPO6QaHNB9RZTrsnwIUq120qEc=", "G2558LAD4xO+X8YRFV1DItHFbyKVe9IBpFtThUKRASw=", "DJ1+9weEzBU/GjJQMdu426xYYl3HYQ/UU8F8+N7jtIk=", "LqujHSrUsClI6nbtTZMdWkJoOtue3rVk0GU2MZDnZuo=", "Ova/nH6u3qvgc0h1CZN81zsAqPpa7szY1Km5zMoWZg==", "JNTCEW+vabmchOOJQT9xDO8Q3lzYfAQWacpRwh87Yxg=", "H1yr1L0ilI4sXNl1+S/QhQcxMB5ikfzjZNf12VEVews=", "Ayqq28Hez27PM7B062P1/XW8+UryYe07deBJ1j28Zu4=", "GUgweZRk+O5wLXLkGsOso8SrQZsCQoYFsAgplIogF1I=", "Goi/dbVcCXaBtsB/6uyupafnqEwtm1STgcUcmwy2RTI=", "LHlpBj0fyXqNBjBJY3ymumOmzdkgC5XB/xyUHDkLieE=", "B5oKvZuklcWFn/bhDOOTtQyfBL2SqSYewe9/mfd+Rs0=", "Cvj36fPqyeboK8lW3XxTvfkScsx66VXXNMj5xqTnOF8=", "AfRdaHIjQzRELwjJm84pLAidPzT0djQZ0CyhTyTEsbg=", "A6Sp2ZKGsXUtbLc1uc0Pon1PG48KFSHRjRUX9hSLZ3o=", "GUhOYRgHAOk2meoqfWSBSEHPEVNUgNveg/aTb1q2j7E=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "BoEX8Rt/jXNq95qyrjMo5XapXRK2N7lEzf+bV1hJmRU=", "EYpQTXfMSdIs9FSnyz2a6ASe/pRHp4IBRo6QzldtqHI=", "HiHs1HPD3qzyWkleu0MBCSASUpOBtS4NEob6yJjjw3A=", "Lji2X6sOobgVJ3MgX4055rgZdkJtDWTPSMuu6BgY7lY=", "GUFOtV4rJxfir/5PalIKh5d+k4MZubSdAts3NGm/bMs=", "AfBLMCatyfLwmVYx1O6DrTkQ+rq+TnjciyEenHIITOQ=", "DBzuWsgrC6SshXjJNMQVoPKlC8dSHSBYhTsKWUFfb3I=", "GguGvjugw35fy6T48z0K8zM8w7+3SqJi09SEy9YPv7k=", "Anf01GW0o/lQWSkHtlHFrabbrUP3rQ39uqS1wO2+x+Q=", "LLyEhfllQv4illp7t2jPz3n0zqhFzXDqrA9sOD9UL9U=", "E7MG/UOsrHJWc9KG+6viScuppRlKayBilTt1FJ8CzRk=", "GbtxWxXuEcP5c+6iZWMAwA1tlldsNySwcPOKdkzVit0=", "JXnBu65IqL+cQ95pVXTn1FdsLHM1ixjdFaFnNSj6TSE=", "KbtzJyZpjT6YdFNUvu1VraYZoNDluNBcwp8M4b7fAb8=", "EBuKly2o53f3TGj8SBw38LmZ7w3zyQtlBasqZSfJXXc=", "KNKCtKgOgHkoetYiSXMWR7NiIb6DbCRukXbG4kNiNgI=", "Aw9akdS9OnoAzPuTZhmknJyuB/3QLV9ygerV7HZaXGg=", "AjrrjWdcyFIJpPR9fOk3TG3RvcNMrt2UegWDb484gMs=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "E+/it/zyKxPd41YykCLBDK+U0KZ+RIAgzfcKKhusLeQ=", "IBFtigjvVYokfG9flDqYLZS2PooVgMgaBJrmLbdVDY8=", "LQgq5BQtnPADgwZ2ZSYRGPwgtB3V44RNldKD7pNf2c4=", "EDUgoM82zZdvIkMknSXXS9EbSvrXBQUbKPVnfncm1fc=", "HoIPfbOLJKBrvD38eMR9BAyd/32LoBYLUixjE8EHhS4=", "AnWDKuHxzYYQLdlop25X09+VtcHLse8o3Tj6K+90new=", "Ds5m7BBKOSzX0eWhHxbKx4mViO5fUjuT93m4D1buQqI=", "F0WG5dAS8XJDm01Dfljf2cWOfSntZZp0cfC4AVHezlw=", "DMF7T4ccuRvWOSQJjFS+J0SjEx2KmtIbGlUGnwBbo10=", "JOZhGtRBgwt/yIQU1JAr+pBD5gkzptG6bhLWeVw8Gzc=", "CTkvSA30AnW51jndlfih4KYvs7FitB79tWJckBVf06U=", "Gf0YpqadLpMn+0j8zW4FSTlbLJNirxUtnX6ZAcaBVO0=", "F0vUfrDQbcxfUSGwS8PGHgKiYu88d/EcVIuPJYDmZP8=", "G+WHcDLCDfbXmOi/Jl/lEXOdudmxBCsqmEOiYctaU8I=", "Jj/f8K7QJuO4ZU4nEdziqr3IG/RGlfCmaU7CkXQ5KqI=", "H3HHHrb2g9e4UW995bXw678KWBB3/eVoQ8Dfr/gKytA=", "EVuZiWN5SmxQTdZeG32Z/0zP4ksERitXiMzjKGHu7WE=", "F/Q9umTB64G+lu1kHPeAGzpFxhTMuF2qFKgVPU5X5to=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "HhwZ4FAhIIrD/f4tPxFsjnLd1g+1UwAFZWaD9Si65ic=", "JZb6KpfqaQXFmMZKJXaPpb3lBOowBHBa2hKfk27ZRuo=", "BCm+BjscaoXoSGJ85L22WOsUj4mIewjkaZ834cTWOIg=", "JXHNNnG7e9e1LMGeIpFXLk3Y+NB34pWiKQfRXOwElkM=", "Aj4u369x+zeW2fAL1hjUjfVFTm7bkaUJ0XPEMWaMSUw=", "GptNtwqnzQTjOhDF9BiLe3VG3bS0IVYRllGUyux9lhw=", "ARXQ8nsXfRusKWC7AP6zvkJ+TgGE+PYyTQoG+0euI2Y=", "JBWJWKaVh/HBVRJVIEViDx/hVpyfPjZo7Qbf+/CnNoY=", "HGdh3eeGONc0656xobM6mM7376QlX8NmK65wMYLAH7g=", "J1DY6t5NrpcyjGCmRf08hDHZaudIKoGLCuO0zEa5vcg=", "H9Mrgty+uMBI6SacLlMAL2t/rROqc384amzfweLFqeY=", "BZT8Wf4l0kslRcZlB5XO6Low0q4E3Qe11nawid2++pw=", "DISrd+ivC6LaYcVbU881NOdmc1dAg2qsJCdYf76lyL0=", "BTy5dmLzi7S0S5WNTsAvjCX8x5WWm/sHnmZLh875Pf8=", "FgPKCBbdq6TO+YUxhM06lNbIgbc9LW2JPbiKSMPeNEc=", "GOqN2aJ8pEEKQLyL7NC21CM4iBrEwxo7p8qkDNG1YTE=", "GlJ3SL3wBXcjyGrL5JCUkNPiQVZHqC8UYaQvMpa/TAc=", "FBdfkcDduCNUOgFn/6t72MUCcwkK6tgB2jCyX0VQWEo=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "Jfkyukr4SuQ7pSkeYEz4yl/SCP0Wt4w46rxXKGKY1Vc=", "JUddfWSfi/8mMNl4RL3A/o3277ibrsdeWrm9uid31DE=", "CJ8WVbadKEUNBcnfxhAwXUanfc1Q6vKAQuvIeMrzDVw=", "EjmAx8+FOLlpQhNZWaSvFwirqGbLoQXh9aOC6btqreQ=", "B4zCGa5z4uy0Al0ODZDPCfgvlIpjJD3cBihysQcLazA=", "DNogo2hNeaLhgHj+oyYWUKLMohP3BbVu66KUnKIDuBY=", "IbnGbRGQ/y3bMNsyLKJQjSMfeq+Pf19blbwXEaZy6ms=", "AiAWdBr8LR7pVJzkt0MYvvKTuystZJXUJM33AAYNyBM=", "DXIpArdVzRbHl3JHyygGimFq3qoTwAseL/YoyJK9xtQ=", "IXeTpT0KwodR4/2oyv8/gAOwhMR04kWM2jAzDjOOIsM=", "LTHgxuMR8yew54DykageJa69lmBkiw/1H+iFHSlnHP0=", "IW0UIR3prtdyAGAu14yqZloxDuA/r7W5k927WuIjD4M=", "JoHCSlZ1m3fV4Kev030oauNCJ0VWT9wV0l4N0VjJ9OQ=", "Hjtu2tP8vZ2ZHDT15Ng4+3bCVVQtJ/gtWJiZErW8fdI=", "Lu+3tesmWqYQxDVvIoLdkqA3RKG4SE3tsRUyHfdRjC8=", "BahIs1qOJwIkJC9SaGz3hdnxHsO60nUpwC9kSKQy7EE=", "Cf94IEjJ2aqGkO1wfoIWStMg4dr2RqOzBCHwPc93JCM=", "KylN5EZ1JvSRSvj5iVkDEk8qkSScI+jQEqBOO2/v1QQ=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "J9RPE9Zqd6ZF+JX/gh3c+MztjIr5hNu4z4K4RlOl2xA=", "DlDHLaNsGpaBAu3zDGuBB5XUHOQcSXgwKM0IMKzDfJg=", "AjQa6sgx+YmshKANEnwICfvABASVrXfh0fWJzr4SCQQ=", "IHH69ulvtc1EALbFjrT/XlJ799lJIYC8L0U0zQrgZ58=", "FNou1OF1zAlajWisbn+eLXAugrF5EgSSG8SAaxV74C8=", "DGIyx+hOo1QAvcD3uNDNIR+1GG3x/o6Se8Uc4CR9E80=", "H2XEVj6fYe1/fy6z/tzeWBrTtmDFB5wW592wU/rMU5Y=", "FEZ19MVLwz4b16q+hoXHQHOM8ceJHFxlmwfGKB/Geo0=", "FOziw8R+BDXLsBnbRwjvbJBLSvl11ymg/NdeZav3RKs=", "EY+THpBP/95rpOIusEKb6FeBn5/WTxJzJTs/FS+hiw4=", "C63k+WbVI+RlbESFSYLUVGq/4vXewgOkXMRj2hCTzgk=", "F4PJTzfW2QV6HC544ND3jv6xYaFNwhB6IWYYKfE10iY=", "Der//9D+sgnAB5Pl+AB2G1QZ2HJfTIgobqsiQWDsQ/E=", "CHRqcvtkws3B7xRhPLU1kROUopyALUpqlM/vhEYQxgk=", "BIgnEf2cVQj90KHsWioIELk6bPzkQaGSBHqCf1jdstM=", "8rc40+s7gDvKMlNHt6+VTMEEkoMkeRg4CLOupyQ1wg==", "K11eugDgniG9kgLXLlMwY2Fgjt3JUawfCKU9w7xulVw=", "FtlueKYHhDdAS1vyGqzVpD0j3dW8IXJBKtNjkLPORRI=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "L2/VKyWpSF3yh4WZvjSAhRfV7tbB2Dzkl+Gp6o0cOEQ=", "Lw3Axh8RpT1Bmz+4BfwtR2g3xTwcmQxm/RU57J0uTkQ=", "GwBKtR93OIxCdFMmPqYAeSpr5Zfm9zZQnC2+h9SimLE=", "CmkHie+RUFOi7RKqkKhiE0Aze8rlJROcnhq5c+G/iIE=", "DJJRccdDHazjYmt+UDbfpiK8CHR/6EnWpq5cgxFD0QQ=", "An4qNVvNrplAX805rCW5/+dzrlsO2ah6nkcHFf4rwnE=", "DUTNVvAhAigoHhFiYLyKq/ZPoHAWAemHgfvGsU+uqe0=", "HujZ8pUAgFcalgXHtFTDSA5kh2rSeJEkG49i1x1uv9w=", "E+3wmuit2/hR4A15/ouZAne0Mdcs4Nm0i1XjCVtIO/s=", "AdLH86RNy+0ED+X12r1JBkYiw0r2jFtK/s9jH9mY3pM=", "F+BPtfScEqapG+wRNwjZQ83HdOZMbsQxvb2jpsHA9Xo=", "Idnb1oxUzbLqi+r33jGvrRzUBMR4xi6PWWU4lZCaGLo=", "J2lQxfbES6yu5o/ZTxSkSgegAzUVsQp2IDqysSvWBEA=", "LKWxKo/27gFWZQ72czOgf/CLFWRUiXs3BzTEuYl3xtA=", "Ajef4/53tQX1+tWcyT9f7XYk6Z9TWcMNVu/NCRVGBmg=", "EOeQyz9r5RwLT9f24pUZv5vshCrG4Pb1WE1cwUMbXFY=", "IKlFZxWNxfeyHLA1jf1vz3Wr3YBrFQu071V1ZwHVaOw=", "GRpqgrd0FdmjBckLgYnpOtnZFaQRpUTQ/QkKFXET1Vc=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "LOKom0xR+XFmxq20NJGojCSjJ2EQBVoN6siPfnH5drE=", "6FJC7+a3gIfm92SVx774KLq3d2s7b1tK53uaPYVJMw==", "CSZU3Pnmn8LaOUE5uvsFkrTK4k0A40mBvdzUsIndlIo=", "FS01Fmo+kAyonVj72+mcrzvbH5hN6ujgLPcD3VXnim0=", "JQFZthxeVFvvrtYqNJzQDh/NPqWI8p6tXetnWgEB2TY=", "HmZEJ1PI2VGIu59ZutF6arkBjwUs6OHeWHkLWbxM18c=", "GpGWVYbbFWzA1P4III6nYgMOOQvEmENdOgTUG5XoVMw=", "IF0i/4D/0jBg7hrrUFDHCaY6TqughH/1hxcdt9nvJ/g=", "DpLh5UvFnmQqd7UzPduy4VWUoZVqPtDiYF2/5M0p3Z0=", "7LOdX7QtwtwvK3TBPiQweh875n81q3mwrJdOr0oMQQ==", "B3rrrhGGNdWg4BYN9JYfPFt5aIfYeN3NJoj+HWGBUOw=", "LQ224utDhtEKNxkUgDhSPrx7r2bcU4gYsLXYQwAuB7s=", "HcfjhJ3POaWap6h+8SKvsJAJru6jfb3vboUOV+o39gQ=", "CXVZgV07YsKAVgleOcixqONmu4qkKvhfZz5FJz0K4e4=", "B+CPzppRIcIYipblkbkrlY2lIHeKwLyme1naKzsG8Po=", "49WP20VDlJlX6jO9A+Orv7EJoWkd5mlkGdSxIH9ULA==", "DJkf5DgY6jBtO3doR9FPQBm8ogcNIA4Hc1xi2jGjE44=", "CuwWu431QZCPEd9qZMZ2GDx2v8r3dIxQPWCZrLs/Kpw=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "CFtyZTVOiDKYyuyhdhzRnixcIRmzbDfW9dZmuo7L8Z8=", "ENfV5nBCk5q51e7U1SDD/ggfnvl7Pqj3/+xdXhiJ4DE=", "HPrB8It7wWp0gt7eHWJKhjfv8sb1s45fvtpva8XOptg=", "BrECdDBcFemtt/f+fNu0BxweSWjkbkYcZkKoYdDuaP4=", "LPQBvhwyyVzeTr/GXLvqnAn5YyI5sxT1OsxjvzfYalY=", "L9DJ66zQMli/tomnpwDUOx/sQisiKZ1z5HiAHZUzo2o=", "BOwhtEwhxsNYeJ+StdEmWX4bYPBQUJdbkkzXBCCH5jA=", "LUITBYGhm+JIj5jERz6AURwnW+efUHfbQLdLQ4getNs=", "Dfc76LZOBF+ILt7k8X6dosXyWyhZ6QRZWEStzz349/M=", "AbBRAbMsor4oN2JL0B9DerzUPPbEtWEFLg5t89Xw7jk=", "CKT0Ls7G9iZCfOEWsg80BYmHWdBTEJGoeTZCepnVyRk=", "Bn60o1FNRdfmRo+Fp6YG64Y5W+97IwGPJeEz90Fs/mU=", "MDfCIRKWT289jkpgfx817lYtUF5KIv3yS0HmwD5QZ4U=", "I8R0XAleWXDawWYya4dd9S2U2wyUVrWvtVB32SmWqLY=", "EsqFsUL10tLYe0S08ZCBCwou8cu5b/tD/kCUrAu0UPQ=", "JiUB8+AualyVv88RdJkXsiEl/30C7N/a36N0pFFzxmI=", "LD7ADbnI5EqvlOqZ2uUvdojGY/C0LRhvwdAwgTpMobQ=", "EgqlA1bFRlPrU5mxAbrB7rjXKGJoAAA/iFihg8wTIPU=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "C2wd09La2seWcspp4nLk3t6bK8us5dEtsV/WyFW8x/M=", "HcXPtx+cn/CIhoZrknBQTDML/+2Afl9giDmv1JvviWE=", "K6nBb0lzTzu/mClmKfKhpObRsQBjGTIGUo6jmxGGnM4=", "IcN85hLhsNX8sCceIPJ8Bi3YHyyO+r6Sxz9U2Hrsopk=", "KcopxXpRb4AAYVC6VG0zKs6VhU09u7nOtXqA8iH0W3U=", "CWROhPcnYE1i8td8LVwYl/i5DzYnQKjG7vJe2JjhjtI=", "GEiKieeFBagH/8ooJVXxF7xxv7u5RD19BuMGDZeYcoo=", "AX+ZpJq94nx02P5Ru8CiI1kRIcucDv2zKm70u7yXYEk=", "EQaTb+TZHK2dwAr4uF+N/cqSmKxCB3iKR8l+vVrayao=", "CxkhPyTxPdQ9YgxtT+d1dOO6ZoB9YG+WBVrwY0SpU80=", "KE+3nUtb3rgjsKfpNWY4BznC3d5vLByxAvSROJr4hgE=", "K+6BIqrrUT9c1HVG8VCQzGcw450o3wip708HJtxpodQ=", "EJcStDhfnRlBvI7Uy+4G/s44N5+WJoH/H0nyx1d6rwE=", "HO6NvJ58IuqoFaq0VHBbLCthzPVrzFGB2OuazQiktwg=", "Ej+YaNfr09fFdqefS7Pw9vhGaqUMZCsrj7KTiyUzrLY=", "DA+7X5b3lfhw16Sv+pYasKgKlfmBTyIx3rvic1IIjFo=", "A7JozD46rSLU+OXtvXxReeIZIBumKYfjtKWqSEowxlE=", "Lj/1gjEPsUSTMMDf7RKRVNL4rsOHHS1ZO3OSanDY5fE=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GLDQaf0Zp6x3dus5/WB8db2GCjsvoX+Q8cAWiB66BC8=", "Evded3HV0nxmzivxDMPj1tVC89OfGEfi+nJjhqyDwo4=", "EHsEFVp9nBiB3vBb4Xl9vIAYvrj638mTXlaeLyoqpHQ=", "AXMYu8lqNZQ4JibHlcyYbdd6gamDvwvNyapZ5tcaWQ==", "Eyl0xPr99iHx+txF2u+b/lqSobWdMwVkSKElriZU0gs=", "JYU46oepYnaQaAN95i/dJy6reb/WhIn7vUeKfLcuBo0=", "LLEgHHan+hX3m5um6iYdF+C2LCZDcJ4PmEyTfEIRXiw=", "LmXP6RvdScZj2HSfM1F2q69jd/WC1ISE9nSOJMyBZkc=", "LNPXY/6Z8bZifmNSuVq1SJ0ZHQ5dQd8HgQ/XxSudsmw=", "J7xKXqKmYXJlAobL6k/wLuGGnoVO1PzCcMhnmjjMjvc=", "CI/1eWKO+tQZ1UBwwQ9Xt+aTSK6WrQ/Wi12q8wPulto=", "HLQ5KOWO+yTuIUzhfSl1L9zjFgX+UXYJpg+NLts6xso=", "Hcv3kQmnGTt1/Ya4LBWQsxq7iZ0PxdqR5D/pzvvkWko=", "J1je6NwwOUu/MKQSxt/9scezwViPSpPpYg24AmXhKMM=", "GNHPSmyEguxzMK8Or7Zv3S5Cid37YcNvdv6Hw2SKr+M=", "JIVZfP31YPNOEZiciBeZzrFBQ+DVxN4g7kpAeQTPHgU=", "BhUfKrAzeCq8e/06rsR92cQoaBrPMtdF430L5GQqp2Q=", "BtLl75UPZ5wBld/aOWbtjy20zN6lc5cxYnwBKkU6nZk=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "AtMTj9y642AEtx9Hr6DsCSsyjSIF1JUrR+nJDyhnh9k=", "HI4XjZP5P5zFaxPENxKNqzFFY2Db4kFe3DFt0KTO9Xk=", "AlvqIka/lRa2/WKZQH1ze0RcxuLxWM1ZRMGUhSzDKVY=", "D/3Us7crs0CJ87kRcPrgplYO+9I61cdr6l6M5Gt8nzs=", "B8YiQY3b+ZumXY/+YpbzkHwVidTqIIcDS82h98UiGPU=", "Fw29vJJ9IhPfUeko0SiPG7mJy8B0U3z2RIW1/wWrjwo=", "BhEf07N16y/lBJh67lgM/RrPx8Oct6kXGt7aq/omVqI=", "JbcGqFDuFywD2YqKGgTexW0mTQfXmVp707UJlvVS+eo=", "ATpbK7zP7ZxcX4Rklt+DLosxZhBKGDKZuHzy4N//iWQ=", "JWt7VjXyX1BgCRYvCeKurJokoi0ZTbCYfp4Blr+AXuI=", "Cg2R/yXLwu86ZnR1+RKZ7meb/85Ozo6t864OhnE+bEw=", "H3maXyqf4oRtj8vp/vQATyqrLPvYOASGmFeH+egvc5w=", "CPil04mCyMnroa+y1GPZuHy0EgZCcabXIYI7p2sTeGs=", "E/L5pXH2HHW0SF2fP3TYQiLx0yWPVEbpr7nYK7zNXFs=", "GtoFAge/Iyt3rwRFzTrSSsKFajLfE1RiwZa3GKTigY8=", "InDJe/7b47VLyr9d8bYP7iDPqLHdqLpMgytYDXGTDFk=", "F+Qph52lE5DhJTWSE032/A5hSWVhQrqs6JGlrAs9ytM=", "AsoaA+hrjo0s3DL5mKmirj1gQQTa2BzkTXtwt9LBR7E=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "F56cxc6Bw7lXRplooB2PQVXR+rQ1Zoku/rSqyOcwvR8=", "JFQ24iLxjwqVxe39vnC+s87gu+Q1fArSfsY3uCdr4Qs=", "EggpleUA3eKo9ePbA8+wj+8ucXxZU2tqSKdX/ol68Lc=", "Ae01Gna+flYL44cp9MIh1S4bLmscmpkGkl2df8ZZryk=", "Is6gUgvBaRBoKS0TIKuETE/2Qb0PP4s7zk5QtTAtQpE=", "ENjO+iC99k9oD59l4vfxGBSFdDhJEl7lAJu1NfvWc3s=", "B82G8vNzOQeyiT6BL1NnZrRcdZBRa44NqCCvVj3lBT0=", "GPfiuO1+ocfM8GdaWIdHQJ/9xeDZob2AtUv0eDO6Q94=", "Ea1lqqFDV9E3Iy7j4kYKZTEL/rpEdZBYDRZagLuHusU=", "FJ3e/5aN0+SHOoj4KqsiUuQkk01izs6/PAXgQQEjLG0=", "IW5IedvrE2rc0uL5x50aiZEj7IkhUx/Rno89t2npuac=", "CzL/3JO6ieeYA1SWqg8OXzUXNCDZYF31wpF2ucj+qcs=", "EAWXh+S3uRSRytiela9kgZeqtle+8DRyJKr+ob1w8Pg=", "Ef6vu20wq6mQX8RrLPqL1aHNZoXDQRkk9lIAP5jOYfA=", "GHN/G47WRPzSAxgvn3HsYG3+VyKEgxnrBq3boIYhksI=", "DblkUbJbwiEcMVyUtzlggP69Ey5IiDulvnxjUkVLJTE=", "FKEsiGjGmYx3l1+4BYjcUBIcs/6QcBefSP8IbdtEy+w=", "Bk92masBXRRmzlug/YqSUxxZLrkQEeAk46kN2g0408Q=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JzcNSOCE4TK/8uOvD5H3h6lkjr1P5828HO3sJsEc/ws=", "Fvk4X57fo9zHwGuU7SwNhglFFjTbWk5uGZfMFE4UFf0=", "FIuyy5FFUusc51W+2lnnhFQdMbC5dDwQ59bXmK/P99U=", "LpGBOIteuTAke7O/A2razjBJaIfD/l5RoIUBpXg013g=", "BF456nJ+T/JUuiWT9pj3no5LT1ONGyY5ErqfDVcqju0=", "EXTxE1liiCDvqjzKH18Zl09HX9mJaSkRp91ZdU34alk=", "LtLOZbKumrPlwzNm5Q5/miYish30Czjm8GBuu9Y5kUM=", "FKkC5IO3c71Z0pjDFrp5xKu2v25iUxJnL8UprS4TNK8=", "Hmj3vVEwzrEdBrgHWy2l/QnF4kAf2BbM9eaxTzzne04=", "Apgny3pw/wCVBQZ40Z8u7GmUwtuarCDCMoAps3zB2U4=", "GLZ64gbJGwkH3VyxRDDS0At8oQOCz8RkyUUazLZLPaE=", "G6ucU4tw+7JHEsnJ/LJQsnJROBMfyIh90xwO4Q14Uw==", "G7iIcj/gQwT/VqfBqqKhPtu4xtm4TJXDTPqjLETLGOc=", "Fbk4xYiNRnMPDvuS84Ke5Tr8m0ubPipYcpwx8hwHgIU=", "DlZmjV4YtZ7Yr7nztm8Duw2NC+SbL/DuTPBYAqaECi4=", "KG2JDJ4LANxaMYWzEtYfhhk19M8jAmfdFHhD0IXLmBQ=", "AWmzZ7G1tDLT5fEzdLtG/uh+vdrlJ0WWm02As3GlKYQ=", "JhYGGYGhJ/H5BRfQDGfM9TfmoeYPduLBjOyltP3Tmsk=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JQXTxOsBqtPjdZFWQQln/LEwn5AoEz8yth/o3KBecDk=", "BlgtpHzYXADU4ximFmmv6OGWnSxIbnbr4BlovCEwJBg=", "BBuJedJp9uworBhMWy8Cr1jCY1HGzZQ87GrfI2nNseU=", "FEPVOr6BqyWcu+BJTpjd29goTBFFMhwv4ksP5nLPkRU=", "B4N3vbJXAACWXCUFmXYUuZ5q/7Y9D4rB2JCf/IwreCY=", "ITQ2IsuHR1Pw0sNWM+eHfG8vNSR/CAobDvcBJyFXknE=", "JyboZMI7q0ZqTi6cHmyQvMzmEUox9Cg7ioe+Pu+9rAI=", "CMPLeXnlGiUJK442Z7WraWMnzt8dsldTcHGnGNeko0c=", "Dq3H8HNYY65j9tOi2YDMoUPdvJQgMHWxqTQftStU57Y=", "MCczaY7f5HbOE2DZ3YiF4vrEjxD9m2qklMzIRmMBYHE=", "A5DRNew/sMxr67T/11VAYWnUtxq1We38PQPaJzn5nDU=", "KYFLhVrnWYX4xaZHU4O9cB5SedQwrKUdh2cWFKLuw38=", "HIJxvNQCyETVl0b7uMgJJlJHF3sXX8kpEB3nP3QXCdU=", "LqevWv9MgzWkVWseYhw/t25QcTKXGkRSY112MQwkGZA=", "A3WMNyLLdksO7ycPtFxsdrnQOBaw/q6HmjQ2/cm6Krw=", "ISLpqHophBIWocHl3MAjY+sRhe3Gj27v2zj8Q0VLWI8=", "LlEyoK7WSTFMZmXVGSanoVvdahpcb1E0+vltUsqt0UA=", "qspbeqJ4Ed6jN2r5/vDNgnXo+Y4jXbg6sTYbTEmoNA==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "IDiYuSuz+DRPIg6fB5Crd6zWabODER4wD92U1WDrZho=", "HVXtz62kzeggk+MGqKhecD5w1i93+DqkFYx64GVY4sM=", "HFfsIRUu8b7KrEgros0orc6bzmhDSykac9r606Kkqxo=", "LHf3X/aFfTncXg7ebum2V0dk5M6z0iNar6+djClr0fo=", "JkAkxXGuJC9TClk63kd3jgTeT6/BmY0EGWs/jcRmtnI=", "EjoXSWvcHS7OfuCrFjK0PCeDKAVrhgnuv8dt53eA6LM=", "FdgGyox6fHJ+Au066xIQRT1NOcw/LRiPQhtYt/ubX+c=", "ApOP7yJQNHL/3no2sExLNrY5BkrrnXf96/91boLtjm8=", "HVvRmywFdl48S4N4G00AN/7Je9opLjFnACWHBR79BEU=", "BaXqdhLYLbvs0DEgLFUDq3PPWsDs7v6oHKRWl61d+64=", "Hf8bsgLppxKH2ZmkQ2q4EpjkTa3tkZhNZCJHcmbaT6Q=", "GmXwGoNcxt8I/hFo743HLgTzyEvEEp2LHFfHBV/VKNw=", "DGv+vvVCzXi0R4b4ZTF9OEpk/6veUvalvCn0BdPkXEk=", "CgalXtj1IkaUS6nhs1Gw8E6V6OPIAzf3v0xMs2gsy+E=", "I3rwtQbwGF/IFFEUS988zfe2bL4a134s5CEvYtYnEAY=", "HWtCHzFDpWDlBm7KaeaTnBPLL7Irzb+5bo1Vr3bQp/s=", "HqTNxI7rh73HDgNKDuHOaZ6UtbESZ3bzv6Q8L6y8rxI=", "DP4bgt3oxetQBAP13e32FlEGsoxwzZQfG2XklyUzW2g=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "EM1STYL+BbowfdOquWqDj2sfuY4Q4oTMyPiyuVhaZHo=", "KQafihAtX9XbI+HoG0KGdiD2r35ks290RBdqn+uvmho=", "MCHdQQBOwxVwSo13qxLJPYmjurozBmbPi5bMgELu8bY=", "Fz2+jyXH+n67KFeOD9MQP9qDVQfYtT2QUYl1fWY461A=", "Hsfctf1CEP8DYfRLSPSBjfzig9y6ujXJbXfsmIj0Nxg=", "DlLesNpZtfkkl+C6aio1g0Ko1zHOL4wZyN+dWOzYGNc=", "B3J2oqs8D61pczrR/VPKFINQundoG2vJigzFK+0+5nE=", "DmKYbIYNdaRQLO6NfYkyt8d6kzDEsIhM1xUjg88hMB0=", "GXfkq073LQYxdJaQXWzeRnpCT4L3SRreiLcCdkXAVgA=", "Dl/IblpKpYl6ZlN2Ck5yVV8P953nfU3p9aog21r7xlw=", "EzwIDFdCbFCuJPvkFF7K0gG5ZPoSq99+0WukW7dsDVY=", "CYCfDZQEaE6RdUVl5O1xS0hTst/inkSu1N899jL5Zkw=", "C56irZ63Tfie+PMTIkWu4PDQs8kZdaynZgBxqAZrn8w=", "K7a7tLj5AR5hZ879ZLtIdPZSen6s2qEO9ANHTjMoJOs=", "DnUF9ddKFok0I06Kg7L9JnvM/U5sed1k+wJCaNugPqE=", "CpbpqrbTfp0aTT4Ow3XtFs8gH3vwfS22bEPUj33QbS4=", "GRCan2y6o3hHXBrnCtedL4MQCzNlO5oWvYTM4+ZRYW8=", "JFXRTfxONPiy8MQRcixm7GJsFyf8aVq9HISXgL10ag0=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JyD6NbdlAPKs7//X6/MxwX2WpAC0CEt4JT4yhPlC+FU=", "CvivBZBPQ4lbXpI28Xgv9DOM35C5YqOsDQhoEq5ijL4=", "JfV8g+TRgxgpB40X6YU31W48PKFjGPJ5K3GgcFWxH40=", "EiJ1kD580EGebIFZCf1rZV7w81FvnJdn73x+s9jyJGU=", "INoqP7Gty6KSRrsZ4W7DqfUau9WarfMHN/+SuO/GHuA=", "GULvUGwUXZsV7kMSEuG+e8KGG0nn5oxqydzuQDRHSaI=", "KchigIfPgZfIU4My1vAlO/pGSAJEujHjDSNwQCL1WhM=", "I+wIcMxEYPqmh1OBebu585WhcVGV6GprtSQNVHfvMZM=", "Ig6WSCEsYlABcGXYYYi5YS9z+QOYA70ym6cECp5T8U4=", "HkJDCd+xoAJA9N2g5N286PT/SlcBf+iI54eQ57zm6Sw=", "Itwgs5mXuhtAKIyqvZ39Pp+dxP17zZ/REHm9YCov5TU=", "IidRhiJZAcEaZaU+ConxmVQfwSErTpaqe9PFv4datS8=", "F62GjxzlFiedjVD9gJocQOeAEEGMeqTuagn5tSOipho=", "J9/yg5a+8oc8RJZLM7MORLJ6j8HQigkXXxzJZBWENZo=", "CQIuEnLpfpqjJjS8O/wQIkou7RYbm2DxAVlfjfIHz/g=", "EOHxYCz8MNxKs5IL5B7H2vW749ltq1aK6vvDUMXuk0o=", "GxqmsnnCpfyN2aYiiRv0h4qu1xIv3e7AogvPL52oaLg=", "KDuG2Mv9vJE//ThJpecPkrafX3kXoEAduS9vHqEe8tc=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "DSGJesPZueO+nl0YLRygRByzuSd234eYNipLtANapCQ=", "ILPU2xjdbePvs1nI5gyG8dIcIOep8dvmfEUF7no73Wc=", "J9ufSUqnjBGe+DWKixIvSu2HFS+SORrJ0Yf5zssHI30=", "IDpCvGhTFvY/5hyRRqdCZSX/91j8YlVA2a16VgLGzag=", "AnhghssHpehKe7VRaBigE5+7sziBzSiaNtVd2jNPDdU=", "FxlxhPiT0ZR1c3vXICRH5e84XStfCl51Uzy76mHn15E=", "BQXQ6DxrW9C6faUFlon49EiycyHCOrTaJz23fJVNVeA=", "AWc5PKdIzFPrwa4Hso7Go6Lw1BE7S9MCzsfAs5ikhxU=", "DUeTOKtY/IN8kZfAwcWj7FFcxSoamy1Ct6MTTy+hOFk=", "IcJCPdTJ/R0YPeVhlEL5H/2ogBQ+Q/Frv9QoBvpsdBc=", "LPSAYS21LcPLzQ+2MKB6kuLqWUMEdjUJRQvy0ZmizFU=", "Bx+CGkJuIrmiDPyZfyZsWnqbtSH2pzU+JdwWOjXAdSI=", "FGH4/jj0p2C09NCbUeahJtTF6epSnrGMfJTPrdHtRfo=", "E1fQJxxHm12/7ko8sU3c7djPUDZaMRZsVGKsrgtys4w=", "KzKMDYC46Bod5YBEIrRU8BmUf0zBZ0dq5awUhiGBq9o=", "LjtUCs4kl43t3lBbQsm/q4iK4I1EI2JEkBLggGiRuTs=", "HOTDGW6kTWoqrO+HVgzB311lJSfwCSTFmKvOs/qfrgE=", "KFHWiMksGEx5wY0G49gO9DkHRoY5el6/CAAATtELcV0=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GWY39zc0E/w3s6wxi5aVkP8L4xztBRPcomomPV3ZZdk=", "F02TqUe0tz1oel67Wk/ax6/OHZw0r0/rf/xBviqiEK0=", "GoRJR2VOhox+5oarGKIiRjlzneet5QNTDxnidD82QPo=", "LKKQaum1KMD/Tj4yV8jTGfjBNo63OoCrJs3xzhXNSX0=", "CpStkuQzZsuns9uFywC3uVDx0iHwVkLLpNlRmmr8mhs=", "IrvAo9LBzyyFVhFneeq3EQ6okvMt+wuh217TjG/eF6k=", "HgSraw3RG2w/WcKbtv1iczFh10qZUnlOriPfk1RUNX0=", "Ip8+j2r9uiGNlIrrU5eHFw9Og2ruh0EjaYxH/PN8F1o=", "CZXLZBcvgiDWQgMKIfHVJcOXJHONWAVNjLashKFq7AM=", "ErhmO446a82eLX0zTIjA/TFRF9sgUnk6fCQ0d277g1g=", "DjBuR7yRf6fjjbUathAikCKMQCUHcIhAKUaYF7ESRp4=", "KQ2MvlIR1GxB9WHomYjeeEQipfdQiNDL8meddTr3yi0=", "Hgrvr5zY70JJZeisUadWLhFQbaKYhuwXAGsok3Dsd9I=", "BN8Y/M5gqH9QRVydVj2492MKDdY8Vd9KP1Sc6YZjZJ0=", "CVlz3Fj2UFsAwDOXO8yV8dBowxZxC2MmDHXjAOjyD5g=", "HRisq0GN4DHQJYej3wXZ3FAyHiBoeJWYccfCaB2en/4=", "IT1zhD29PE6Q/j/0r7VPETqUoelK58k+Biq3z9fKQqc=", "E4ByYeGXeI9gaRW3NtBPMSfjpTKHD2oohaCeR8epuwM=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JQtgnOiPCYPxd6pLEpOCWs9Jy+HMwdDSIY63tU2HIOY=", "Kj1ziFh853rRQuF2Lv3xfYkE7daaapAWGxmoBsouU2E=", "GQXwD8Oxzz+t3kfLfhslv9D8UD+pCzTBOzsdZg+oR44=", "KNMDmbCwnXfVETh1r3J5EBYoJb33PupNw3VynIsbRBU=", "D2BWx8i7KfR6IzcijVvzQvvt/9UjfSM7PxUF4JsGO5Q=", "JebsspIRGfeDpBC30kyDpdnJF0Ye3GLQz5XSG+QkpWE=", "KNpIZYb6em7nolBdUb5J44EARwtO3jse56XDZMpQDPM=", "Hnp8ROcs1aY1u9QaVDyfRpRbeFHui0gocbMXZVeEatU=", "+FKWZdIVSSCLEjiNu9VRhPI/1xMljFGCSdTufzrNpg==", "AWMthKDTFQLOUJsBSdoaUpPfH4wRsuLxDSFKL1LkyiI=", "Dldui6jOvnu4Grcte/GgjJgwrUkBbpvbg3ZbxqBd088=", "EW+fhVbqyd3daJEA/E4n3JpCxFNDIvThg3m+4ytTrfM=", "JhfLP2lLnTWFLVNBwV+lGkcHZDDcQHuI3HCKV6Ta2fc=", "Lh2r/NwiQqqtfFYBxFqjdvi/EolUsExHeUbpGJO8wZ0=", "IFYdtX/aSl0YvkhGHEIJ05s/12D8vO6Th0JJ1KVt1KA=", "Jf8zbxtfoWV22nZSc73m0ZZtliZMxOcHZtFwz/oSNHU=", "Lrz+rRGgqfiCU5shKUIMjJUjYaRimHE8PtTV1q+OxgI=", "F/QTOuqhnpBXZRKLQ9Yz80W9NLUS8u7xah3M68HMVts=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GzpJaHz7aSePzsnJAkwsymGj70NyjCG90R83i8IZqvM=", "IcL5+9jnISpXBR+OOcbmjzhJeX42aScj9E4IYSZKVnY=", "EV098A/TvW5UDdA5AWXu3Ig+5u/Ae0CfNnXetZjq3kI=", "Dlcpu16brT7lkgaOyqPp/oPeVuOGA5Jb25hipGDvRhU=", "KFRAVFUGrc/bJ3bHTTqqJfensN47fFXw5bh/t7bg20Y=", "Iz+A6TD0MkpqCxRtB6zW/I89m7SM/h8HLXX1jahOHro=", "IfnM0wW4vIGmshFuiDxprSfIRVBj5m4x1tqBitHnTec=", "KP4kc/DPwJFMk7mkmvV7gJ2bIF8mMdrhXIye/GfFqz0=", "LsA/Rf/nBTHWyqMLVSic/2zn+FIWB5eiuckHaMXEaSo=", "G20N5tsD8LrS8NSHm93EMXCKgh30ysXuicycnvcN2fY=", "ChHoh28I9pTtST3Tk0Dndet6akGu65SydPJL6X45o7Y=", "F+3pmuaOA5rPPLjTU7DbkWwvLnIfGZZaR09H8TQc3BY=", "GP/08+xSxDcp2ClFdfI/i8Qdhbm+qHffj9EnJtzMSQk=", "Id9x8samLzlF/dzm1S0qp9MmspJi70spgCfCZHO56xA=", "EbidoEddnwQaU4DJmScutPeHCQ0dVbmGDt6AujmDQA4=", "CNwWAoCLBKLzw6FVRdNkME9PfNudvdvdb2MpkdClvDQ=", "B/rx6kY6JKooRUYNOEWIVeu/zJ4dTndaNQoOiCddb+g=", "7jj0Dzwe8RAlUs/QOCTWi+pAv96VeF16TDrfrutOoQ==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "F/vBhGeM+4i9MMexw9eyiGQgTXQTPvQt5GkYf1/97aQ=", "HPnVl1VWBalAzeEEUnhOhn9Goq50/gRl9JOMRqVGw+o=", "HAkrtJ8rQ2azPi3C9u4XFGj5VXAYjksplbkltVOejWM=", "EvYgUxJ+IITa4dsoptlP9i72oaRzKrBSsgOV0M1K1Hg=", "HutEdq0py+oSrXy0RzIRPljA/1mKtGSN+XnEdOs4NQ==", "LDglBkf60+7crmh7GrVPbapYK9KWMcc/6h0vXEA9230=", "LuyGqwJy9X3yXYRT+zjp/PDbytIo7RW55/8w3JH+uQI=", "JU8PRZfvysi/nueLu/zdxXgfcVZSF+968L7sbl1fBvo=", "EqR/zbGxnXIKQ5i2WbLHTCetvSwk/64BAcTRKb7OEwo=", "G8iQwBmdp+3y85NlxBGPPB0a4k1mavn/uDq0iz4AogQ=", "ElJyB1xIrVxB3HPC0n3gAmeW1rR5Mrvu+JvM35L7dZg=", "rrjnHMJLBdi0oar7Ghb4QAzduR5tQvyFiM5QoZG4xA==", "Bg7OFMKDs0ZUGMa5qfVs+cliGLaFdggQFBIroFZUsw==", "FHKL5BTNHceeQ25Ncv2TkuROx9YJOvhGpJ3rIPKCMmk=", "IdX2bnRe8owPcXhyLNwUvr4CQSkRQz+0YL5yQoHsg2E=", "BrxjEzWWGntgCuwsQzqFDvWMgRzsu3S9EkTgME7Jtu8=", "ASW3wnfxYqCgd81vGYHl8i29oqCwvsRlo4Q4dSfOPtM=", "Kiof9e3iAwDAFb52MNjxBg6orvzH7A+WBuiqjK6Zv0s=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "JHxf+XbirScTsO0MIopWGWIVXzRV/nZudHs8xhNinL8=", "Aoywg3mA4J2qPmlykYmLrxYp7qxORjQrwHHaZWx79f4=", "D6V8+GBl4CxxQC5tvcJRsbdsEgXrFNiD2VuVezdsa/M=", "EzPXisgJZIPOGVnZVDI4AshTpKA2n+584SYYKFAc7SA=", "FNXqfxRyOIdRIBpmSxX0ApdKok9s2pqRqE1Wsbbqp3Y=", "B3ppfZKtLAcNBYsyVkqe/H4aA3odA5YttfJxneXMbH8=", "J8Z5MwPz51Nhxn/la47enDsT68jRDm/3h+aarVZZUGQ=", "DWk0D3H74rl3JGSy8f2yXF2TzTZeJLaSZwWneokOCNU=", "Hi1wmokb59VBH8suq8PK/Pz9q6t5lkGJdY0a+vcKaXA=", "LNsSSUP8fDKHczoKPAeOuYrcOTgSDKArFKWKRqRPT6c=", "J68RSXy0qNIHRxBk6FW7SNh4bwsUNm+DPHEHZmEpCL0=", "A5LJMA0EnKMQJRcIgKR61huAsdwD8+bbMmTtEhnbWwQ=", "KqWMjJWpG9Mh2DziaCpLfS9uhpoKTOxjeicrCzDVhDQ=", "Fve16dgzOcChUbEUJCP82NLBdY1neg/30d+u3VJXYrs=", "JAtQ1Q/2pZMKVe2ACvVfxiHotfAzPgIqSeE4LvgCMaQ=", "FuQ9V/w+zuF2Efr+Xo57BTgI94DcsREtGEH0zlLBXzo=", "GLmJ2SDbtw1RWY+yproisYJcLz8F9/1Il1Fv10nozuQ=", "Dk22x3DOXWYrIeW0Y9mTcb7AG2Igr1M3W40kv3ZoXZo=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "FFVjro5uFHKt5z/3PciOwwbPVAviiUvnWMmZU4JmZPY=", "GJLJl5MiHR8R6cVjd1fbEsAB7O+ZZcAMaXz0m6m4gdE=", "H5ZfjaoBjuMFlnBvF3c9M+aDXma4qtROcZVTA/zm7aA=", "KTVRGsg8mQhbJHpoEZWT1EMHuVOUOS2LweQ2a1QCFEI=", "CQeQdpfeweGjvRefqMqahyZZl7zBvtN2u7JkdDCvzrc=", "AzlsJnsLqRSpxLpF/gaoaos5YKodwS7XlDzIpF/NUOQ=", "BnnrsFHWTfmaCyyTdEhXraqIArvMbBfPDLKXdvoinoU=", "L5NIPQNUnDG2BrMyJBOd4ZmMC+b55LkA2f6XKFiMmNQ=", "FFj750j+5T2FLYOw5+Ay3qQvwXRzPuZy+DPYyRuBGmU=", "GpD4zcHGPyifIs1uTrO907esnwTMpJ19fYz7D3JYBa0=", "EypPqC1idgUfM2ISSfTGaSzd6Zdm5SshoIluL6oc5as=", "HXlESTMBXtmns3tT2l81392dodzv46RU7JjaaQ7xiAs=", "JoqR3HeuiP8FSG/tjt3r6mecAb3nPWNPXPspur2+/Qc=", "HgEajxS9adZDnN7UWxVwdeXUTOUfT5/mJ5+iaemZ4do=", "CdTMuZLi7Wp9HglkmEkITkx68cedt4TiOcOdqrvGmmY=", "BL0zPvdbbiCgqVZsfwckmIaNvjjgKL6tY3QIxqpD8jI=", "eiL/h1ZkxNuDNIcbQ0ugHpScYKQmTockq77E2YIplA==", "LOfAqqfTYdp9LRcCcKpI8Kli24i8AvZ3m+WlB55AyFs=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "BcFOBBYWudRXUhwnn2YuAiRSZqErUWS/4Fp1A0QO8Vs=", "AwITSDLwgyvLn8b71/A8SefV0IHUVesOMmem5IZ3pBc=", "H/H8ClBB6Dz4wUWyJrqeTzjkLljRVHnK9hAtXwpGwbk=", "B0Oi+ITnzBvxa9gzUqWzMkNmzQmDjaO3r4wJqouQf/4=", "FgI3b0Fz2Vl0nsXa7YOUtQ+s/z+4dlqJtZtv7wp9G0E=", "B9LLnJSwqBgY/OP5ToK9+9EHToxRWef7D/4SKR6dgzo=", "C7Lxo/qSCYG3b+yhUZ2zqjwmtwP6zegkI0ebJEv9Bbw=", "DvFatgGNtvUYUFZodWoVHFDOYJZXrDoTkN92dZ6e7/w=", "Dm6Ia1NxWH7JPq3KC1TLd8ctSnCb/ZQxxeTq/bHz870=", "BDho95agkBnO6SjN3Ud5723krRdXjB617Z6gF2H0ajA=", "JEppGxLgIC/XD7KDWAcA8uJXR8UEwqDr1YmTvsr4Tro=", "B9uDoW2Gc7vxYLOw1dluexQEBJCstnhwUneK6rG72aQ=", "CjjrKFEEbSZqqKptEk8xLgC9mVmSrbFuR6YKCG1beBk=", "Ca/RQQL1ZB+sQvWq1+HgT9V3ncptIPIYGe8+7cd5on8=", "F/EFX1Z6B57rw2y0ZIjjQGLlmP+I6eQoDwRyAhiR1QA=", "DnQrd7jaztBGdnmHP5hDMmCOXPX1cylatv8QHIa+wlk=", "AeATeGHOQk5v4fgWGEfhyARSWUXbAme/VuivZMFMwtI=", "Jq+ZOKhcVuYK2JrJ6nrIPgT1dNM9NA8UPKXwWOKuGP8=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "DKO7/6lKJEBmDuFIFmTihymnpYHrR/sefyuNGbM6djM=", "BW3fKIyFMxdIAetk5G4zK6B334hVnWF7v97/6sEsk14=", "GPaL1gJoLRJnzlerZfJ9zhhZu78p6lykwafEfuaSHzw=", "MFlbfm6DusrC4bl0T5fARfgboXq5QKCT8Hhq6/EH9Mc=", "BjaVDy7mIRUZXVcKbEPRjpKj7a+y6wOJSCIRtIb5eb0=", "CHTrhVX0REuVGz4xNPltda2IZqDaB3X8rqfYDMC+DJU=", "FlswiU5oN2AV+Fiaus1VUS62PScs5ozn1Hi+q3ZytVo=", "GeS53cV6VZZI2iGak8sN2w34S4nLAZKBR0O9pY5+Al4=", "JezNa5bxDioNqP5wAadFjhDD5mnMbp34TksQjCCngC8=", "Es7n/3AgeyYBpRmKccFDD+N1SVhyHLgQuN4vpsRkSI8=", "H5nJ77tBc46lE68bsUDxHoTOQU8IFo4WViCjYDLoRN4=", "ElKdgl6B48yVDCCNLkA3XzINr5OufkAd0h8x9p7DndE=", "BgVw+WInWkW95GDJKe3OHJ5W1b/ep/UWWprR8zjkMng=", "E9EfM/TocqHX/Kj76V+ke68+VwAng/VQPGUiwoNdjCA=", "I1nzxET3kIoOOoCGGkIlERX2UPpOZv6/gVyrF2dv3kw=", "E3w9hJT6/ouBVnEhFAqJM6lX4GqGr3nyGqB4buAyBxw=", "A1J81jHS5m0PgiGOwaKueNWKu8F1GXUPAo4BAVO1R2o=", "1n3lqAnDwX7IH4fqRwVlV82aIcEuYV9otaO4sr5c6Q==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "DgpJ0Xtf1T5Bxxbut8MXCqWWo9mUz3gLtPsJmj5ijO0=", "G3GAJHw1rwHVi/GM50bhk8X51stTDetwfMgfAWY8JAk=", "Agk8Wtbseeh7TJmvU8MrfBNVlzWsx07HRKRdoFDW1Ws=", "JsTQJrbaSkBf5tdCOHR/1XFWG3Jl7kmRDER0OOnA4cQ=", "H9O2YpWfBaXKNa5UPagJX3ikVEFZR1vh6dhFksUm93c=", "HYoRnaRsAezShZixhDAg8q/8/70NKrdFE5A7AnEXaRE=", "De+ey/xMJF0I+iABCiKIbAEjQkUEIYHMrRnsBu7MWqk=", "Lzieud0NszECYKCJu50IRu0CWsQ3we6lbcXHFZ6EdPs=", "GS0J9uH5fpWFiwndoxaQLeXguUbTBQopbob7kMCCRGA=", "Kr6EvceoHpIkjmKBZBlRbzG53zw2CI34sNrfokKvj5Y=", "DsgDatMyu7DY62MbzFX/DdHHGCO469a44GmUF7ItZNk=", "IS2QV0USlID2SWv/Yozbcopyk5T35d+qEwBKTdbXzgE=", "KLEOrhiHQVF+Jear37Y/XAuCNKRTul9z1VcxsSa4xEI=", "K1XnNiijFGOZycQyjnt8KwbD+cay0cLwbeOytUwsUM8=", "CiiPHCwue0/WZjI2BkK9GJcMpIlxRoHvo6eVlzaAAMs=", "KpjGryGsOObY9wqMu1mI1qqSnGzYp71B3gLWpGHgA5g=", "KBMXM7bw+dyrc6mX095MFLv75RcTXRqNBVnwl067ieM=", "GgQitEhlL4/yjECZpYV+NUdOiGTIKwcFqikQUvrbQt4=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "B1ngLdz5wC+uubFEHT4E4uJrHDwhwaad1FJ5ix7Ov/U=", "Hm5RABOn0mEI0WCzv88mn/D1GgdZ4eGycx98P9n2Vnk=", "CHsijJWa7CHRErgr6BZ3mRBPzy9qExGo+Mb/vJuRwNY=", "HbKo/fgEE8/LbHfpfFcK1HHavDjoyy/mgAFvDdbSxeE=", "LIZungAve6D/SpK/wF/VqcvSxEl62ZV6yUNKzyo9Oq0=", "ApAy7PkwwqQf+Twofpus/k7WQ19bs3dSf5Rd3ZDwImk=", "IalI1Zu7tLddfmLinyj9wa0h5nPD2JXSZPPLwLnA4PE=", "HcrOYjlqnF/vsxe/B3G6NeNFpOETqb6LmtO7T2piooc=", "KfiuXB7ni8yV2yHLqRE/McEEbEHYZqcDg84Aip5qp0g=", "J8XIcHtp0qsk/cFqBD0k86KqzOCZSq+8t5dU4m16PAo=", "LTS5a7wyWWlb3DXX3bKNiW9kuU8JI2Jxk9UNgpMKYfw=", "FQJU7TQeQ9Ol7fn9SCX4CUMX3+DxmPkINVyf/ASFtKM=", "LEypnBZ9Z+atY5QJ7PdmmwqZrOaIxsnDOjTXHdPvPJc=", "A5MM1W5TTFi+Ux9+niucs+/WLVQbtlgKEkbcmkBnp+A=", "JPaeiXNI8pLx/4htSZK2sQjxMSo7GUKW8HMUr5TCcBY=", "IzTDul/VU793T1PXfD9VbUBPSHrXWXq/UFYm5fw0oFQ=", "LXLXvVgPQZkOd2po6aElLRxdAD+8m+1kFiod2olSylo=", "KjEaAPbNgZam8SpyW5eRtJ9GoglVoMwFQ14TbD/68+I=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "Fe633GBpWYXMJKkBuB8sKsau4FBpWrHeeeMA1Uax8EM=", "EGX9QnN+xHPJajdB74EZv9lVq2BmlV1M3rr5dhrjPj0=", "F8PZISoJAm8SeU7uOwSEAoCxKrBr9caI8CzHcmCPrZI=", "Gz10JOqGZHEKAk1fV8nTs3LiwfVChoPaOCRk45FUv7A=", "ARIq7bmEeWFM/lknQ01ssRod3qU54zx3ccpEU1xRBCc=", "BV6b3tTLu6fa2YnZsSlcUjDVp5mmIRiVvEEu4kCG1ig=", "MCY9sCCb55E5GtCPIQhXSmqILwW2yAVbC6ngyocVIXw=", "BkO+w+cv5UBgx4phiLcJi7vO3VrlSfXQ+VWU0DUBwdI=", "Akc5rATCOa1lSWWMobfg9iBnu9U8Pwrpw6AWDciYLNQ=", "CDHPoBuEVU5vJrnWBMD5FEfGxawD7R0xi3lExXc4J7M=", "DAVwEh8pHY+3t6YsrhHqVoo5SRWpzXD2NIMKXjb5MCU=", "KZTQfa9xUrUCSVf3GI+rRFJxRgbFBVMIVM7BSlgrtuI=", "LlrRbvOPgC/HidxG7O0szKcf0lzq0dXR8UxIIGHMcDo=", "CfH9P9d9OZ02CJ1YnbzkPx9WPY1NknEivymBmgIkBT4=", "HN1dHvp3ACM0469QlzrYcAm20mgYv3g5a32JJMeqxnU=", "K/r5DFXWOgigrJSIdPmx+2DA+qClMJJqz4aClvhHjgo=", "EtPmxQCVYsFkcmnRtQcSOi8LdymAS2ZkPwgbt4K6fP4=", "A26b4xOpUuO3f6Qs8TlC4pKYKnVolk/yADVqHG+C5HM=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "DDTkLJdIhEfDIdI9tks5jGwl1Nn9H8/TtWJmdKQtHLo=", "J9gu7lMZkxbtFEpVkf2uH24r52tGn2Buf/Z1mokg3ek=", "CJXywphjFgkqA2bW3QGP/WQ5xHeZa00utcOu0ssMECU=", "Iuom40BPofdMoL4rcyN9CkQBT2A2+alqGtG2oTk2IqU=", "JF+cNggeAinf8caT4zhYsFKZNJySHUFjwSuKYM3f/Z8=", "EgcY/q8hBgZ6Pdgk3BXDY5MSgRwdjleCWqeC3oiiw+k=", "HNozDfTwV0f5/fUY0Ub5FgVW0y0G+MIfnyJDKuKrvw0=", "F8i94WQb94RZmzij7ZVoyz4qg2a87dVWcR6Fvfpx/MM=", "A7A5/s5hfSe7dPZPt8DiStrasSFfoHeYj8tRO3mQyro=", "JYX2mzt8rrCLT9RAO3JFf/OVPnCPIKKg1Ahy1Vcdxwc=", "HPHdcBb8cohehBy/fpLJMdmaLN3OU19ysGVIWzn948I=", "EfMPG7KL+6Gbgb9gYRsPJsGip/ZiOqt3T5me1ivgNEk=", "F59sPKP8vXqtjh73WSFtWJq1FIKm9zlck9UQWtecXgA=", "BRkygsS86dWBVOt16m+iloPi0jdtHiudImUQOzI8AUo=", "E/FEhXrxe/8MEvD9F3ptqbGzsQhC9IBWifEk1S0QY8c=", "KQQA8CLwmxNZvLmBLcs1NHJEn0voUKKNlJ+RQpCqWY4=", "JqWQ4tKD6k5L3MOf5M38+bjpdLRgPueLoM7wfgQtqSM=", "sLxWH7S6NG248o1B6wvMa7HEAhdhDxZcXM9PKUDKGg==", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "D8Syj1D3Sci1W7U8/Tx27ROhHhbrOBZSDXMhdLaPlpQ=", "HC6oaEGvopmX5JWw4c6ogVYjGdntwqrv3nsw2gEYuvU=", "GB8d4eYnvAIpBVssCPEq07cNVAsk/sYSjjWcuPMqig==", "KksKD+d8ev0msIrA7sajCFTKxeuMBw2wego8W4BiZ0c=", "E/Yrufoc8gnjA+dib9c0cQZo0CtO+z7FB8H1pLWeqUo=", "K19Ly4sMDBqvkONw6TthG9NAFdT0CDtv7/UcYPx/kNo=", "D2G/us/h6rFBgcC5zNodoCcnQqDGSshzMhyFr3wPQlM=", "Dym5hwHUhPZb3mV/FyCbsE0c3FLR1FuDV9ZBU+4GOeE=", "BPUPrApiJo58wkpkzn94S7HXmCvmmp3RaLDxkdozpb8=", "AxtnQ6b+6b5iWGLAX/xNTGVuMOF6TR6aaM2Qa6nFx4Q=", "AbLXofCtPc4uS3/bQ9451gRLlxO0fIIJf7cnId6Etik=", "DyCQ2DBW8joKhRnvYzrT90VBlqHaBttqqTu3K6uRPaw=", "AfNuoV4e+EqGnSPz/Hw/wL9CUwHpgCJpTlNKVk72lhA=", "Hn/fS27f0+jhnnP8j5OLlrsnHwqLW+ruZ++w9f4diUU=", "BYcn0IdeChpZBjTFJ+i2mkxuRDJl0BMADP3V8AufqsA=", "BlxnKXGA1Wzv0xy952kc7NNE5VF9k9NqLKALhPKsZAY=", "Ju/ZY6gPQQQZKx5mECFDqhjGlWtO2xTqyDOZy7lX1CY=", "LTb0ZpDkgNLL/g9kesmcdTywFJCteTJ6EZLnxbqzAdA=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GuIDhkkN3xbcV52lgMRzbV4gBm5MqYDv7GxBLWxfvyA=", "E4VWVetT0HDWo7koMXbsh1zdBKIxCovH2jd4u6Oov2U=", "IWpQR/yaZCPg3OXC/H7SLheoiezX3DE+yX2lMLABLc8=", "DOCn/kx34NA3zjOKcnLtZ4ZPVmcF5UIrlU7/qQHBGQs=", "KVxLmpqX6xndm8XLxHBP1XwQAna3r1fge+OSwYqVO8I=", "KYnSOpRzEvqrVxxd2vnE0Jwi0YdufQB4R1EdbkLC9Ac=", "GF1z13oOiPmmfiwaWdZHNwbiTHm4Rc5fmVDw/ibWx5Q=", "GCsO1GcW9k/s6IJmF5Gim7KZhq+4PMnhlO/jlyiKrU4=", "Iv8hoAMKV1pMYqgrKGo3GItM3fbUKFxgtg0DDbIGscg=", "ExNDeqeUmkq2T+hTJ2RXSP0qWODj07hWJuiPcznXsmE=", "Bu/iKZSwJFG+ui9tDcv76bkggX10yyEq239zgXitL0A=", "AwEGMDbkaXu6jSE9NdGIaXI5u9Gzaee9KU/03/0QiF8=", "HJD7Okasmt500gu/6EA+8GD9qWA3cwZDadTDRL716Bc=", "LFLGAcwAQrRJMpwEX+qFbecPmOqNG1zjowzPD6PdilI=", "GQNLCwqHwlesSUTgUA6Xv+3n7S3LFIyVRuO1gaup2yE=", "J7CGhSZEocdz8O5sfLbljXv/oyY4t5spkL1/HdaD7tc=", "Fs7Bz+xdVIpwekTdw6/ufbFotemG6qqIV0ijaNH8dgc=", "I+DVwgWUEz3FUEO8yApCLcnVn/kvPhqek018dIa71BA=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "D8hxAUYS8PIVNYWHiQfwEcypV+sA6GvFDzGcy6IKAF4=", "AXnf7eqUHsKM4WrUpv8yBlZjKwdQ5mFoiehTcZv8bog=", "IgDu3G0ACjG6Ba9gUpKmrD24fl6FK37c2pujBhkoI+A=", "DgYnMItEhrmSKq/wB9LciKTLgNqdkL4b0T1j8+1+H8c=", "CUHs6Xdmyd03wHyuhyIBUblnLwK/9ABnADELle+/T00=", "AtiAZydQTnxCJFIofzeMCpuFmJclQ3LutOTKvSwDgGc=", "H0QTaVPDaoXYXaJ+V6bfr5Vdx+HUVnkOU1JmJfRwYk4=", "KtLbGjeIGx9z5a6Y1ARnLs6Uh6CMzO0Xl04cklsPAjQ=", "Af8nmJ9NdLUArUfvNyuPCDlkmeRGHKfMxZFGdTZcvcg=", "HZ5Lseu/ZUrI2BOAq0nEXGmPRVL8KzhdYfFyn5pDT+4=", "Jp0hJc6vSREwDatZfa4tTZdxSkirrwWfAGDCamtGJBE=", "CF/psXl/9IM8dvI7Da1ToBco7b/Si53VCXpydyW64/Y=", "Kh5beou94ZoOTj4YmlN1VDzmh5uKxslLNUGqex7l1z4=", "A4+bMow4+M66QdZzGaMYbs6b4bydFhQqvDCZ4qkQ4ag=", "A+vqe6KolpW2vgCXNzaiCUedDoNKN/XvKGMGNVLYQKc=", "KaHrhhqv2lyaNqxMCUzIdjtJGQKxi53Sm7G43CFr2W4=", "D+KKiAAcF7Kxzq7viJG/xavbk3x/xtUbLftW5TR8YpQ=", "Jq6D/3IPtlky6DG9sHBdeuYMAon3vP2JoCCl87MOr98=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "FJK9xhtc62/Ds9kQZfWF4NGwN77iA8qCdDRZwewAxlo=", "J18t0xxbebXxiK5mmSNJTm/+1DDox1vyAhMuULJcGjw=", "CzJ6Tr3EH1ZQIYamVsoGgZ0dKaMqbnBYj1SMT9svaJ4=", "LF49AQhSHIrw0DimF/Kgcl1QA6W53YJKlaWexr3iCxo=", "G2EcseX38qDE+8rU6dxl2lxqNBkPsnqBSDWdRlFl+fI=", "IjZcVcSMVzbLS32uj/9JXpxmHp4TCvYgz/X0D6EhDpY=", "Bz+5MiBVaiv64eB9LQdsqkTAheK6ZkS/QlYJSvSOvzo=", "IT+4vIwR7NlbszEesEY5jzd8PqQgjRS4Dq7IxK/yv/Y=", "GmF8W5mHYpCcVayTUTptGe0cHij/i3j7P1URWKnQ2Zw=", "LhKEpZoQIDlm1TzdUCQF3qaIlJD5vPxaM/+di2/uF8Y=", "J8c4l7iuocCDgNjKKNBAU1G5V7Bkq9F6/MZHtzqzSMw=", "K8UzWVeKJCKJp5gGwEhTq4n8oCpiMvFS0Fs9HfvraQg=", "qOwbop4RLPxCr/CBzNPn4BQQaWy1UQN3Byu8svlgDA==", "LgY08m9z8RLMXyheSiMvaUt5wFrFu5ydq4na39ARLOQ=", "CsmmiFQx0AXkrt7pPbzbY4zqWxfDYyia27qa6eP+dEw=", "IWhUvOMHeve4KUVl7CAMDEVbnV+zXMmMo2oyNiC16uE=", "FgPvKlgqCtu6xWVbPDICtg7Twi5Z+0QsKnliuQMaM64=", "LP0OtR5gwcCGn13RY2Zu6GMLsvO1J6+YYPjiOy/hqGk=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "GD802yS+txB/D1v5/UwlMgM4VcN7VGPMvWWLaNhw5rU=", "GlB5GQJF90beU0Xwd19eqRcS7ctPFl85HpyPCxJoKAs=", "JJ2kZBuPEyBtPLezlD1P9dCBNlSqXY707KOcxs3c2gk=", "Lpnw0a0onT14AUcoQVXzNfNCJPf409trAI2VKoShLy0=", "GpXIB7ZTt2KRD7C52NC0oysAD0kPvpJeDiB4QqLawMU=", "EnoVz72I4MEispBVcsSW316sIJh5ojWv4I6NLmMc9G0=", "HCLWGsNPBeq3Sq/wz8AWiRMnVNJt5iA4lktaissfs0A=", "LuRsD777/XXv+ILTlSlIidkVoaHoWOGKWxTEIAdU+ao=", "q17/NMnAvZ/JDbWwWL32j6tPJet2Auk2kGD8tt+ROQ==", "CpHUedy+B729pCSRiDYfeqfgDI7dget03BdvGb8F6Pc=", "J2pX4sIYQ74LELiHeEkwmzPRkImDh0T/wkVBmeaDP2M=", "Klbkd/tKKFtO21Ky8Z/RWZFOw7OE262YhQoZ3Z9Ewsw=", "L8M9S3Yab/5ppfTy709B9yfXExos4V909nuhcjbokmM=", "C57YW8PkPrDDlat9/c/12pT6gJvPXSDahmouBxLd3N4=", "KSGXG/sW30SsrwRHhY6uBHIL/4Ss7fV9EFkBaTLAqeM=", "HvT0fo2ektVUyL+TEuDID1hQ+18SRCGkoDIkNicXBCk=", "Cwmd09VJh4EUHOu674s8mgcdiMzKLv242XBx6Hhxj0Q=", "MEoIbmc173oAxtX7xqVdq6GB88qQH13jyaKfYWG6XzY=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "KGaGptU9CF1geToIFcwbd8YepF/ERR57menI5ryA3ag=", "Fgnh/O6myoivG8UHVYI2P/MF1fOWg+cHEPL4VQH074c=", "Ek8nAT4A2bjhH2VQzL1qK5Qm2l9IKuV0ZgHYL7q61lo=", "LEfHQ/8Qaa5xuBHuhwUOnhdqBGHY9uBHKvSn2DKAcb8=", "EaBYuXbcX7hCTGgZKuyrj1a2g/Xq8VWUIDSSgdhJ10Y=", "AiIuydbrYvX0Mesnpl95KxmBdYBWLYSCAnx+hNvuXXo=", "D4ZrFnrLhFsJBfwF3PmFhJzHsyp2xTL+J3Q1PqN/H/8=", "Bxl8AvwMXx4TvNgl4fDfRxEdFr4G5PkOHOJFLtJ1gIk=", "CZqqa+9i1rHzCYvTTsKRbKraGXVr+i3SIsrX/JspbGY=", "GiEKri3BO9C/drRRJPdxxIbNLE3tXxJWAOyWHj7/XRY=", "BK6T5OyW70qXEy7cYhnuQ9QdPTggMxFSqDN0s2PO/GE=", "IUDU9p6ELpJXlg+hSqUm821rMgSVLFdjVRYAoX6cXAY=", "Fvd99ylh/xVySyysD3kQbMm9srPSVTQmOIPi43lyIwM=", "AqZ5gTEG0tGojhlN1VZBFDpa68wiBPtOjyy7QPY35QY=", "ElgtK/4i+rgHm7/Ne//P36ajMiH+/jHnTtrdXg5Yo2E=", "A5DnH++0WyI6t30EyQcn65dUC309nKcHmL87P5fZHyE=", "JrRA9I0cVMgwCqpJuauK/mItb3V5hX/5hpZoMlhPgtU=", "HeoXUpb1uyONBL2zcbMb3+YpdLCiGfVb4sPmROgrW/0=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "Dg5u6rHa3oKffYCqUQ7UI8hr2sezncX+9t+baTLMgSo=", "LOu9Ww1itE0/BnKPXbg4xhfZM8CEkcI7cHIgotYGCvM=", "LcMet1KONqsW/k6EWxhYtEt/Trz/jF4pFrXbyTqtpCo=", "HrO+wCq2sqKXfImYQnOxegFWIC9iLt1633hyRszHXyw=", "Ig95NZvCZQnMu/xCmYDC5lsZWzyLBpXIdlBXotAlpn4=", "FZBJGx294AL4acZmofn+uYN3B0Dt5g5yaSbf/zHySAY=", "L+6hYaw3TfG9HpDD2E8LzMOe/PprNOEtrn3c0LPXJXs=", "GimGb8ejiMvGw8k/8+t/N+HF6DZZsFsFIrrB3LM1NNg=", "C4GZuj7b/X2giPF2h9p3/bzOf0cwkVzZ8YqobNA1dPY=", "J5G3xYoDHQONB299asQ3MJM6du9I8gP+kkANYLmNai0=", "L0VGJVVurMfzFDnI8rDvBv837WFvGVM/kmbyjKhGAZ8=", "JJNpr+PAshEdRIMDq8vBgRCu0aGkRW5LO9p+ji2+/H4=", "Eu3AeO4Vvrxa1FCfPUTXwlYH+9YenUZNhLoyI1gt5Uo=", "IlgNoTSmKdpnm+Vip6hBY6FWWvQlWKBMZFedmLuiYPw=", "Hdown0fkX5psw4x+wEWIxRplDI8PEBBErWwLFKWw5uk=", "KtSDV3Iy6zk8uUPc3mxhYoVGjUta82d52GvXicSZSCw=", "KOvvgbGzRmczi5go5IWPlWNJ00zJlYThYi5uZ2wiGEc=", "E1KjnU7Cfw5y+ZHESKFRHh5+zE9OdrcF/yVR8s0XIz8=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "Aml+yfzJMwLV9ms+HBrZsgNSHwW6mZA1lvzbj7cOTO8=", "CVdRkSe9GvoIJjhOzoRoEwZoMVceKqrMpElPuypijEg=", "Adij6zjppSB4f3s3xZ/TCePs8ZpF5OSFW1PcZw3o05U=", "E8okikSCWtH9UANRN4ochz/L9vpqo9pIwnTRInr8kOs=", "DearaumFFgFI4J1dWzWsx7D2HN0RnKZrpyoRyJ/7ma4=", "Bhd0NN/4SH8B1Of+XcH1ljAgQJOEJpuiS1dR2pRw/Vc=", "GV/2LLvWaqdUBikOp3Pw5v/swfuL6bYxO9MKTgYmtuU=", "AXypc3irW5X9VIvc9THaKOQzbt/9qNPFrb7UW38iSgQ=", "BbJY8ihP/weYxp/iS3D5YDjO86PnvuNnpRp+YpB2adw=", "IKONvAHVo4xpCAVvXEhiw1F1T64HUAlMk89Uvc/nWyU=", "J2SfS87r9tcfZYHUDgQHsCDcc+xWvxZ0jGGFTGr8bIQ=", "Euun32ueSlobe5K/1R0S51aDGvcTOnmmIjOMxT4Z/V8=", "CEh/hMzWNr/VCLVYTRzb8kzBYFx3nlMA1DKL/NTdbbE=", "DngNJu6Qn8dUh2cKTMBDdAr1fonQRbae5rq9gIl0a7M=", "ClgSii/b9QDonIuBqLiDu1AEtLKVBxWLeUcXi1hCHTA=", "C2gCRvius4t+Tu+AfstJPDqrrR1wVDX6K7N87dBOlpU=", "KQmiYW86JKtIrZ9Q5PGMdb7iwvQ0vLpc5gXB2rVyGHc=", "FD9Vuo7iV5Pe1DxvFMkgJRU8eclktEs1yIavWbz6wKM=", "Cx55fu4/FbiM46H6/siNodYymsPDRxLbVw3ohs9WkJg=", "IW9AW5OXHG2F1wC02ZGpg3NwBswQmfDMHGyYo2bV4oo=", "DvtE/x4y7dT423Suh2T2STuw92dE9B8vHzUgWXW0kCA=", "El5S5NWOhZgJrkOkhluCHGXmMKDeCi9M/VGIzjz6k/E=", "BMZS6GW2gsYMV/YL0zoXTpubIrUqHUeqxKoISxF0uSk=", "CcrYCl3i5uKA3Ztl1WhgdU3OCrK+z6B7MIU6Mq9bARs=", "CBVE48rON2GrNWO2ZmFgrselLXMx3Ps057A11G2apts=", "Kcn4mWYYLTx8S9scdR+r+d7Gym/Q89LEsmUfzTWRamc=", "Ja5lq2rXbxjTQj3SgpvAWeQyUcpUkcLhHATj4kHbDl4=", "GCHoi4zbFobDOtfB3NQcYfR6ZDW+sAvY1oZEuTDnwxc=", "GruVtuMyQ6BQ5WO1xP0FneVRPsKJlKb2DlfJjTvI9YY=", "EQ0hOoNkeKowG8H9Tt04hQfYd0Wzq/ulvygq/SH3JCo=", "GO2y0QW7U7dorgE3hQ3C0r9tEwOh+O5Krfdtj4GZBYg=", "HlPpLfbFPs7EwN5bB9xMmgxVRfKrzB+r9My4SgpuLCc=", "EPy4F+EPafcHTmTDk7gHzd3zPISotc/jP0S3P+GMDjY=", "Kx2MEfxlLFk1Q7b5gAu30Mk3He25bwi7vM/9xsxE25g=", "GfRz5AwFZ21fjVHhEzbpxlyzKCjDl8yBJfHcZntsrfc=", "D886TZxsM5LeG9/iXPuGgX7LgMUb4X1H95dQIB8fzQE=", "I7AtAP4mNIiWc6fQRzb+Fbn2JlKxwGJqGa+NYIXXCCI="], ["Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "I5u+4L0FNlhzFPVCkYaFbZK/CTy5AqdROxE3Pby/cTQ=", "CsC8qMGhXVPOd0deqjmPwxb3kcqjBUA0BwVvmxT0f2Q=", "Ea2CgUQvzrQKTFNrco7nlzC+ZAfWAzM7oY71t0ks3RM=", "KSeufbI5VfhCZCZOfcT0AVsHBiCEHZA19UxQHQ1JdbE=", "DZRV88WcnqkwLnIcAAA/60DsgjFGO4TC1mxAPLkRDdI=", "FNUPF1wZkAyuPqwfRX4uAiGJKfXGVIpuYB8wOCQN9Fg=", "I3uSAJcNhDI5AbnXoSYmo9gor/0TLZrEOuAdWsPPYYw=", "AZ1m0EynhR4Musy+cxVlJGBsumvRdNlLt50/2Z2gWi4=", "LKXR5M2AB8Km50XOnTWBwmYdKOvPe3I7+v3qSpcAQGE=", "DVTOU+2BYFRsNVW0jG3BqVv8EaUp2GPvPW1j83mf1Ac=", "LCHG356H0JQnQM/ta2ksXkhot4EIWikvUFqfU+KWm5Q=", "BjUa5OzP419vovDlD69RLr873AKpth/Cuq0uGMTH4Sg=", "HIbocfafVo7C5HzgFfezJMaDOrn7+iATFzhX78BA+Vs=", "IXWBOTbDFGJ64j1k8hfQclCXiR8bHO/q5Ae7zd7uCbg=", "LsRBE6aJ6pbHRiJSWOv5JGCwZcJel55b/78PhZAxXqo=", "L6yulWCGRlxGC2eN+NGhC8glboX+Wj26Jrpjfz1O65Q=", "GGXV+bm5IDF6V1FZGjJ10jOv9bf25sp8D2suPx6gGEo=", "BBIWnFvWGiAFZyGak7jfa0OR/h2glrInVWgFNqIXNBE=", "C++dT0loFwLWF2yU74Vj99HNFVbvWt+YbNndZAJFZRM=", "EMfmdKZvslkFdRqfNVMJwKa0piK3w7Kek8YfZNldiBs=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "GTQoiDDsTW7wUEbzbH5mT8B5D+duOQ2uJlUCYk8+Z2Q=", "If6PT49PoIYVutdjiriKks+PCm+ePmlfNFikWfq/mo0=", "BOCk9IPVHdANEGIiazJm2V2lhmloxqvbch2W+Pfiuxo=", "LTgG8eognCbHs/qV9A6NITgp4ogRIjrv/lI83bUkbqE=", "Bfep+PvIEEAIvMoxiFDHaxnGJGcXgsAQSgSxsDwW15I=", "HEKbTxfCXgxz/KRe6PaeWv/5u8IbRkjsSXJ2pzZlaMA=", "Kl9JKJKziuEKBhXux20vUUyfMlEAA4PR0eE6kKnf4Fk=", "Hri9kgRN5Z6EuP9+KDRyQ6DPCmZdw4vgqAkkXPJjKEY=", "Bl7ltedNNcnkEUQzk+JGKVmhH7n8lbwbYnzQ9IQpg3w=", "EIKaiAYzaA5weOH+UMu7Niog16MTZHKXqZ299leLvoQ=", "CoPMs03IQeucyNKXTwg8YanZ8WLWFp20WeBUS+mTXT8=", "D48SbLODOuVm1wIOi7pffuAlJdQ3jYHTZzD5fd0sNY8=", "J4NVfPPGoLWZJvWAR1K/194QHB6DGkrUIbEtLsn3vyQ=", "CR8gCstsBDa2TEQlkX8vpMY3MTOiXKQKGaKM/amyGfw=", "HkooFwx6UDT3CnAPrRCIZI6XoR+0hW4ipSOThQmcqvI=", "Ap1jrjE94H0dxZIFxLKfi5W6r37++s44OYIlLxFz39I=", "GIotYsXjUZZkQY/v0P0PIUsQFXdkPvVnTLXl5Nabt/8=", "IwMko1+33tdKBMf9TPfuD2jNiFHh6GteTC2cGFfS284=", "J+EgsH1EGqKGS+rOYgHErumgaqQ1f9Zu92XG8Qs9PIg=", "LWoPrHAMeO9UuXvWHUPoi1IV81LcaAYgHz4y7wah3+o=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "GSFP/cML15iUCY/TgEsJLFCwTtBy02FV4gAyBOFijv0=", "LxW84vvBnwBoL472br79H8CmfUPkJV9y/5ztpJLJh1I=", "IV/sfHx3X73TvSMX1zOZhz7El7bfz0NMYG3CJgO0GwU=", "AollUQxSRXsrDZ5JgS2lXwgCjyP/l2RiLyrxnO0uslA=", "J5jVlTDR1BpqMR6QycN/C9OJo5c3OUoRgpGB0fJsSYg=", "ARVC0gUBG0ACARQbQPDoGAUbCpg66Th3hpBr+nHNwfU=", "C6q+WeYUJqf168IXSsBtJ8p4VN3GflG4u5VzkROH6zE=", "Jok3oPoudfecBNnyqmzFbKUvPDQ1LO5VGv8rmeuVOnk=", "G8PjOgPmIAaekV54ESxLObs2+fPOXXXp1RYk8L6xUoo=", "G8QbBUiYN5GZI2RDpDMVCIAYwwPPqHYNf2eRSe1T078=", "LuN5YKtc2TCAE5vnXb8C0gWtvGiH6W0nitPkMKQ8Wdw=", "HN3idVf6nz4lQN/n3uwuqS14YjYaSnrabkto8vO06Gc=", "IhWyNFfHL7TfbLBeu25pWgLAx/7owepFU9Ew6at8OiU=", "AsCpS64MjYEWncPBs++7VE0W/LChGxi83GjEtnVsGBY=", "CcQzX+elAoiZcKdnDuhTeDdSZZTZS+4QCNUVBrC6q2o=", "HVTH+rZ8OTqRph4OLjjVt61OQ/ZGKG5k4xcEx0i6nbE=", "MAtY+xeBTqgW0Pe82cOu4MQR70KBkXgkGAo1R/j0G3M=", "J4Vawp+ksav3TaOKTOQt44KDTJDc61BusfElmCOInw8=", "IlnF2j2HsKBl/7Wp/TQPi8P/xBETt3u/ZqJhOgOwSHQ=", "D+Xkf5CezxK8+x6W0val+W6OlfcJGpIdIl+zO6zmI4g=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "LPYkvMG1eUFmlpOm7lF/5W3PeuX43BUkVtaM1Mg5ZD8=", "KE/E+PEWZhud0mkL6ZeWkbM6ave1IUcqNsFUxez5S1Q=", "FfM20jSN1kfRfP+oUHmQxi2TVdY/sV+3txgcCqyINzM=", "Kwl/+TyIg+YzJ/QAn50K1VGEhK7MnrvkKrn/OGvrLQk=", "ArDg2bto7cyA+WCpi5SMGhciNqRGHF8T0rfR+2SNHL8=", "IfuGLTqplJPjA/H77LZ+L/gpqJAzjr9kKxvOvN0+66Y=", "HXQuVZXWVIpOXN4/oaAk/AS6lQ3nau750JTvOmqoDgE=", "LwDmDdvE2MvyCKrOSvvojJAl4WGls9v0lfEVIPsxRxM=", "CTc2fXf0HtsHjX79cxkaOOxhsvfqYzqswXL8gI5uILk=", "IMwh6+y+tQo+e28P/Fj5XZvZmQyODLK1G+p8+BfgUBw=", "IVNyLG7qxw1gq9dqpAJ55gCnOaPCSy2ZUOfg0IRormA=", "FwQpzv/uZSd6VYQswcYIknDWWLyGVlpWGKThFWVGlX4=", "KIG4YBm8YkcEQxvD7TFa5N1MZYkRj2pg2SDxxJN2lqQ=", "D3WsUkm84JVJByEz2A8pn14ZS9NPggQz7r614CCBcJE=", "CaSH1g2Md+lBsD0aTPDpqSuDKLxDK0NzGMC/CWuMleg=", "DEx7i+mt6ZIgS+0vupq1Qa+YCkeziczPYav1NTZAvPA=", "E8bymhO4CKvFfNyYvVsyMmwNN2QLKxxYqYjFDdCmbpA=", "Dc9319csA8Q4QsQ9kGhiy/p4tg+JeAuThaLYHjFtlqI=", "GvTs75Ot1tF+WJyz6TpyQPIoXhjBiC2kmwmW+mSl99I=", "FlAPHi6xOu9AeHJKWMhpz3rzuwqOtQI2w+JGPOVFVOw=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Avsi98DcyPBxDfRKU4Vk+kg12Cl6Zb0DJ5PETR7Lxm4=", "GGw1l9LpVAmDmmV3ZlySR8YdHU457ZddfqsEB1caPP0=", "JoqAb/kb23hI5l/P/K6Kty53Hc2eRJGLu/lh0CTE54A=", "IqchNOazRCOM/eKRqcJ8jZGnzoynXvyTKjrA/Ocilhg=", "Lz2TJ1t+j4BIPZTctZ7LsC1XhWW281EKOzYts4uAaZA=", "AhiAdCJ3N/VvLtAA+wVX2g/OJHsp4/welMeCSX3+3KU=", "J5XLakxxa/sTP1ql5BPX7AZDkyEAvugAPjUSXpCOkuY=", "FoZp9YU2mg6eHhgApKZOWRmPZ9qQIiV6447S2uLz6JA=", "H/oyESqBvGjlzptFoIvs7JRjztdm+Z4/cMUpW7KHzwU=", "JDBd6S8LsPS/dD2ZByGVfGFH+XEq0SvQlw01RxND8fI=", "JVPWrKZQ2zgeWlz/Bk866B0Q3PYP3BuI0LShgsw7hqU=", "LzwbQh9tR4N2sTXJ0SAxe0KQEg3BEhgDPiSeb2YHOKA=", "JFtL7YEHQAQ2i78CBtaF6kqtnsLFwnQEVQsTTWAwGFg=", "BdGJuWCoO0zQpwOPilu5/E+GoRlQQcPVrKgCDL+SoBU=", "KEL9gXkLBFx0gD91abJe/2yZLC5XG7rxz5kX+d1F7qs=", "C7gGslP0sBTax+xLkVBjXl2rRQXpGUziBGr3TbBub7Q=", "ETCAK9vxzkrTG1KjszgK0nTq7DrYIXpFQp57i/n1cpE=", "I2sIOoF6+nEUFV3jZdcVfVxF0/8ppmWChonJjBGIh8E=", "KxEYyDMV7tEcqKUSjdufvfywlE438w9XrpHoE0T3brM=", "Jse/CgfUPBHdJGCz0zkBRmbyzMDW+SbcUyBpPOZTAhM=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Bi2GTFEbiHMzToNtEuty91UoEPKLS5Jw6oN+kRjdkvs=", "JVh+sJ0s22YoxSCnER7SKH+O99W/Fef/DZQVYWwUvrk=", "IDRMx1yBhgUCGQqIqXU3QeuC8TVe/2JypoevFbM3CYM=", "DO5mirfK/gyS8SWGtzVmpZ+n2eFGJDlLypnW/p4ILFc=", "BBCYsgIS8EzH/tO4qictN91xnkME95MB1Leubv7+qnI=", "GThwu+OeYhADWKZJ+qP/b4HRkV2pMlRa1a492VFSndI=", "HYbaqP8iHa8sWRDhua3H0aMgV1xD7GS2+KylPKtG8Ww=", "JZI8fEUqWcc2eV7C1pk6LSehiwEQewGBZNww/8bH420=", "Fm+TOiYu/sv+/V0SGCiegwYTC5s66QNWSBKq4MNXtz4=", "DnEEKMlTp2S0P/vdFmcH0QpqCO1IqutWLKY6GbcMHFA=", "FCEswXVYZRC7fgEHt+maGt175eynRF41sjqb9em8Jrc=", "B5IrgX4yZTXYmtB3+ReqP1yhgOmCqJYoUCKZUVvR20s=", "F7GwIJhGUo7SRFC1tpEMPawNeaNcEpfC4K1Ri+8Y7Cs=", "H8+PTTujnhTONGt454HMuG+oCiybkbU7K5F9MiAbsOg=", "EyjjdDJr2V6akJaDETRDswnHXdVZx45IWJ+R09Zn/Xs=", "GGsLZ5U5PP1KSWHw00zQ+G1JHsiFntHzlkn0p30j0L4=", "IoZrQeGGoaSZ04YvkO0hOLBSdT3BX7Q/cdBx+lToyiE=", "GiFxK1Z06SqPzbot9WdlinjxxkCZcpEvWaP8o/4QAQo=", "FpwVk+8w2A+PJtTCh6eQzsjkGuU8cYtaymK66l56f2M=", "EM/FYf0WZId3YntvKJ+VqW+7lezYTuWe1UHnuB7bTWk=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "L0TdmzkDu+QO1PChTwamkVEPJdaDlC4/7eMix/J9tWQ=", "Ab5pW67L9ojWYYBguFll435QrhdeRfCXBNM/JgWuPtY=", "FjpD2rzi9w6g01wQWtVNhe6psJU9Ao/k4RxgToteaaY=", "KVbdoUVUsKt9sylo0XK3M7+Soe/exjILDDyRFNqIu38=", "EPQd2BonklvYN5UtrlqcSU3Shf+ppA2cyxfXG5CY260=", "KArT/KfP87PL32eB8pW8DucCdcEKZAm3uMmRV3UwE80=", "DxKCbubi9GkMNgQQrOrydybmTQxtObteuLyq/bQmauo=", "Dp9I3G+8RwbGN1yH0/u84/54QnJQsPyukuB4kNP9lC4=", "HHqWeXcSCkO/v8k1HyzMhKLhorn0QIZ+nZJXoVc8Hz8=", "Gdb3rHM5UZwATBiTwVuQxrUPsJQQ6c5SO93YiqPdPXU=", "G5Lz551/4Y3VqKfHT+aXuACSHLGBvjiOZbOcyBFLMqo=", "AimYYBCBBRJCvk2ZVw5gyn/4Fqzd/DYF9GOhIhsR4Jc=", "F/gRVINsG4ngJgkKtQW+dvLaJnSne7ZRlvKRIxBvFeQ=", "J7Q5SHyohloD/HaZrPnHTnWJ7BKC+7Duqfb8QhX7jV8=", "Lr8EmgfZKv/kh3w+T6pbsXbVjHtRTOA7hf+O6msXARw=", "FLVd5IS/LtpYqHTJB67VR8NeiSWSqHBOMwRXppJ+ucY=", "LPMAryMlOuEllEysZWWtg34bSFesO5ADlRxBTRZ+RiI=", "EaDN9YQXhkoDmesI468M/Kav556DHrFMLH5q6QSsFPE=", "E/A44WAoFNI7B3ZcvLRAM1YvfIGS/S5FrhNyzT+RAKs=", "CjJKpKInOvUBWZG35H3BgOwsbN06+qfKH/ukbky1p44=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "IzWliypIk947t3aiGrzGvQF0bSHWDcmUB6WOyZylOU0=", "A3kukyditTUwU81HiJjnBn+lngqg+Xu10HW4Pn8QaLE=", "Fx8Jc7r/7Z0hvkfRId53F9kgBSBXnmdMNFdB7iwMmvA=", "H/VYRaWH3ui5C7EbJJDlq7e6zzlj93OUIbRx4fPLWJ0=", "BttY2y22/mP1TQWtuK6qnLifSNgkjkXWR7kUjR/SAr8=", "IHp4GYqK9hcSWF+eOqj7MVMgIyYS+DUp+xtYksMFJ6s=", "Dala9m5uCqLxoKxx+inHTXW7n5npRYB5+8Q/zd38G+M=", "JE3/FmPyk1vqmMB9BBIh/0uGYoWpmaBOe623kyqR5+4=", "DxZmwVeZ53qriaKzW+V7KSIroLy0xpCwXxRLYcYQmfk=", "Lpta7X/0geeeSclJYEsdfcJBcAy/XW53SOE/dPMOWsE=", "FoNPsrpGSHGxgV8Ulahy1j55UE1TJOgLNK30PKemiQg=", "FDpZ/S8eBAyR9yML4jAQHOTmMj7sc48pBjV0ZFFSBqE=", "BD29hTW7Iy2Zw1Ndw9ZVqWMyS/cNGjJ05A5kOTAwRxw=", "B7FmwlRFT0uNb7WqgAh4VqXzr/wkjIFHAzZGY/CPt2Y=", "IEfUStUrtAuo6fMfUhM53j5By8fvlCRee5yC49Ujnyo=", "HiPq3+jNVEPxWr/elCNw9IJUzzVSFP6tTk2FoHIuNFI=", "E3GxoMDvcakL98MhGK5BT4HVk/lfhkzqmhtgYHsey6Q=", "KcmwPz8C+qPWM7Zdvwg/JFZesp427R7uS8U3aIm1oPU=", "ARwNSIERt+17kem+UkgZ+ut01kYZhH2els2RalDRcxE=", "LTicmwSnqqDrqJQCM+NjDIuY8GGnVlp9XKryij+3cwc=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EuNR/qNIOdZSU8vBzzLTnjSxA3dn9cK5BifZDXPTuwo=", "LiekIYilgpnJ2ARMQQhEIp0XoRgSQF09NVN5dGUurWQ=", "FL3xOUbUjvWgiIPvq1Et3xBZZCHQMYIyhEJv5ylHU2c=", "CaBop1UFfuBu+3/WZnu2I1PsnNCPvIh89fT8ssy6CY8=", "BRm0QJ7I46eGDuXJCVaQP9J/ra6JhUNX+BzzP+4OjPw=", "LoEMzx3WB+w296tkfKONQnEOqzNBQqg5i12kAqWEAFQ=", "IzEIwARnLdSAvtUtbyUXTNidGgJaYP9oiKl4UD3f2Ws=", "Bb6KJSfRHGwZsOXFoOdaC1TF4h5owYUElOT+d4TPzcg=", "HE107FrUP6Pz9QcCOZGBrFGqadkmDxsy/nwcy8IyoOw=", "LJjIgamTsayl7p5/VZzN8wXmlhVr0K1FFa/PW9Fo3ig=", "rIuPNdlJiFEMg/671JJf7ttxFTgPbE4WeqqboRrnOQ==", "KLLSt0VkfBUq0CHZ4efoeqF5xJYmNI/NDClESu5i1x0=", "Iy3Shg9igkjxtVofG39CBdXYyGE54YKzFRjrT6HroHc=", "LUVnba+xtOTy5TJq2PLWo4LMzjlpCR1IzgY1vM2fH4Q=", "I8m6szyMplupV59W3b2JZ9senjUwiJdi50OjInf0pW4=", "Lj9RGoZQsEk5Ue/hAp6sgAa7XUTyFFCK4IcNr3lO7gQ=", "H63vmbh6mNBCEW3I1opuunVgncu6JP7O7cV2pfjFbsA=", "E7HBre5XdV0sPaFf5Q/mMy5dXFtZKcXvjqA4cEP8FWw=", "IqM4/hpELWr+iG+cvKwRpPf5vdd/s6i3jcg2ilYT2mM=", "HAaa4bEkG5NUbM+dAqAnlzfdEGXgddqMuIGQpx/S6Ic=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DNTOrH5/LNaPKq3Xf4qJo1s55v4geVgA2iCBOdOhI5A=", "HC7jWVr43lG71euFZ/GNPh2zg7+jeXP4fLNucqiMgcA=", "Cnwvx2PaG/N1N3WJuqtNaGhafT0j8I0QblMm7ql7AzM=", "G1DVqdbbB90/FOtZTFHBzRGaDnNKHyRZz5iaR+VXNZo=", "MBYb07i3jYJL0mxKyOrr8MO/KsKkKMJ0tFhAbLpHmeQ=", "BydHAnNFkL/S+kgEayshzSYaImUmwSbcmEGgDFt0dH0=", "IwZMNeUE5ne/PEOLEgocAr1ujtvHB3jka35fANFjNZc=", "B7S4/PjCyr9SclbISqzLNI0Zo9jkHK7KsRDz3NVj0L0=", "CpXgEeaGbIVQ5C777ddu3brioTOoLt1jCPTI1inUKWQ=", "GAUX0x8mVtHPQl9qquB1EFTHHdnfCiNsbASaOzPLTaA=", "CqfB2W2Zv5XXM7rrboj0qFNsH4RnMPRgcxsgdPU0/5k=", "DdDf7fah0OM2jY950VnVhfGBqtuTQp4ChzJBedHjfks=", "BXLfNZj4eR2D00Abh7PW5rOneKmkoz4bbCR0YHCjvxg=", "D5y05z07bBKPYp4S1Ans1wSHgeqCWsmMVk8R+r3/jRQ=", "HbPHJ5/1S6obV5otAKzOJ9H4DaxdoAWsWlAFLPTqYUM=", "KUKhh1cUoMANOy0g3CFvRmu8RIrzpj4FrvY1MHNQOww=", "JSLK/38qK/nN+DbsmauDLj95JhS1zvQM0+nwDJst+S4=", "HMDQhGVTjei8MAd6D8qXC2vDCf7fT0jHmsfsa6H0pqc=", "G+htxtyp2QsVvtW/YO3qUy4VEABwVYk8zWV0EDfIFLk=", "Lsxz+CBiuKbZG+0NIhAiMx1VQ2BCznInl8GrJfd6nys=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "HpVKBNvHM+SthD8jp/QCu6EmMkZ0RQ7tBH4VjENC91o=", "Ab9pNKVQIUS5lf16Jsi+T5UHFp99KWkeRgJ3zooGiGs=", "EKdwZH4VercfwI1uVgv8IZVNVWR8MglsJY4kT+xIYp0=", "I3n9CwRbG0PVm9fMJ2DIvFBV86RB+mKIyEo8fHSIpWY=", "JCVX3YQWngNLnJ7OLy3Ev09LNSCy7AxidUzdphqhN1k=", "JNDmWGfoPPf4ZeiaRMD6TzHfjq8gGUzJ53MYgyICD74=", "DwjjnArKWP1myWuyFpHAsG/FZMwwAED/2YWw/9q2uok=", "HDEZr5s+a1v/jGkV9oRysizz+eGHqyaYG4bD6Q3HZ+U=", "GINubNOEsDGxpGKtjQoRw0kQ81uqipL7Plb5YVzXAsA=", "ELK8skYlq6vajBxxhokDgrnOg4VNe8TyRg8w1waky0g=", "I3/fKAnqUR7wZKfANvKcHVVcCzLf0lczT/U1/kLNgfg=", "IbnMTsTAgyR598xeFbStRyJHelugE9nTWdVAr8Vzf2c=", "JY4ms1TX6+J5PNP7fDv20XDPnbVc2jj1cVjZuGUpjY4=", "HUjS1ED7J6jtH9+CEuezTMIxvS2JNAJBL5b5OBZb860=", "E4/hED1V/AJn34OAxQd1lHSTv4j3WnPXg7IcqpIZfzw=", "Ht+U+1tDC3hL54P4mAY0rZJEn3PjPCXp99Y/OmLzD/8=", "COrhODz3mi6mSCGF+0tyNFyoaJwW5nvQolPv8ixc/94=", "B2HRYP7EaowG4+BV00eRcD+AWne/MAQqQ7bwTjXd5B0=", "LiPGEnlKf4y852SxVuArwh8iiTluMKuEZTYjnciTjvs=", "FTmr5NJxcuSrU4CvxZXXI/nvP7foBjcF+aB8QKZ+Ny4=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "BNgAq2Ftcq7i8c+46qGU27K9ldm8nYMnlD2k9FvvwrU=", "IgeuB9zLwEfMzlQVvgxJQczSqhX/5PSo4HpgwKf62b0=", "Bk1xHOILcNUS8coQdFa9FYWG/B4yGdCfPej97OQwiKU=", "BWrbBcgzxdGYTH9r11sCz8HHsh3Xv22vG1JSLJaXgVg=", "LvwkGqcuFv8xq8eXfaz5pt9TsmIXVExTu4eAfV1hUG4=", "9B/tIssypEfc8z6YkZP/8hV/MHWEjtHkahgRKOu35Q==", "FpKR8rsTgc47FugSxUaJDvXOMsHXaNgSZM1xnk4VAtU=", "L5/B5PKSTYLRfH6n07CfZ76TVgujnylTfsDB8r79Ryk=", "E6yN4UVW6biG3jlE7a5MYBoB94+yY3MPRPfZmRuMfi0=", "Kaaa+OKAUvLFbcJL2jpeYc+z6cbt4P24V6GXH6kyrts=", "GA6aLhYdIQE0hvuFmBE/eigGl+iWQ0AMvv1YeJN4cXI=", "Kf7FVbkd+lekLLNoVg1LxHHHei4jap18nGqrG20RF/I=", "AjHvSFRz9zPUbw4qy/5+OWHQRfMCRCRKs7txZYY8GkY=", "DmwbOYZ+Ie8MYwqZdU0aZqZogZIlTUBJLOiNR+X6FcM=", "LgomDWG61ht4keYwbfiyMQ2LjbkjL9H3IZ5/uoZZcDE=", "F2qn2lJyeoUTSzEzCKTGKZTUFJvWxvxZ1ubA8J6shZ8=", "EpIr4bf9xY5YLrGtxGiQxI4QyFUOuLmxHYVBaU7zqfE=", "AyJotMKYJ6ZQZuZ9ceEMyXinPgRCuxyfZ7rMiDo/T98=", "EL6rZTjgFB/Pv6jaTPMHDmmytJ2hgY7IqeVHV6UbPBk=", "A2GSqCup7qk6L0sZlEQKEaVW0NFXrl2lcZLlbCHCglY=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "A0IHOAuvM3Ca7Uvyz104ehXzDdByAoMFzc5gwXN6xic=", "AesJuK0o/4GnshI2ZSlg/pvNyEyqayFUnak6ctksy8g=", "JUUxPqQmk8yMDWMV2L8kCuYk1m9g9vCjVqEFympyIL8=", "Emmxtub/2ZOPi018SuPH/rdoa53gamgx/ZV8/Dw797c=", "KB6ExsxZnYU/z4ygpgb3Cq3Ik630pKCZNkuMBS8Wmrg=", "Cu7j8nmD2OnuyNaHPLHL6zjD1ZEsdAZr0NvFWe2xLGk=", "D9xHq4ago9jpIX+q7hjZtbhunWTeulUBjzVdO5o2tqg=", "LDWmJ7VUBSW+rMMT61czz5fh/z3bP5tOi08GO2htLhI=", "AzLIdSbkCv7IuT+XNSBLys1MZDHGCws9qrT7fxILswE=", "DV0A/aXXyayib+xj8lZae2T8tYpn58KaZNDkUPsrlW4=", "G5y0tfMvG6OKaFhw16X39ENwubDkwS7TSf3yjeX0mGU=", "HGPh6BQaWkmOoQcT2L2OvF1hqtbgq0krr/Jb77uyaiY=", "Jqs4acQrTgE5RZ8TPJliQWB/KAZy4tskRGbT5CXFD8U=", "DoofMFA1K0Ojn95EPkZohNCZRcygnzHwQ++HKoVRG8g=", "BR1P4O1wskAVbk/df7M1HVWEHE/ZfRpP3+CRCTIFJTY=", "CwoQFdWwtqVyGHuXpEJ/fpOEhVFcvjLgAW0R3n1rx2A=", "D7+jJvRF45oGvbmZgy91+AEUw+rWIGM516Xt8nbuVLQ=", "CcoG3lE2cuS/NiXQzr+iKGpEc3uEZH30FU1SRSjoJ1A=", "KB26l+ckOx00N8Ym/aN+Q8lcvjmHvqO+nRmGBnLtRxk=", "Jt5Xyq+GNXUh9HComdBy9SpBBD/wvyQqhFtxuLoNxq4=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "L9suGDq1CWF/6qbgdcud5A5RZWIcKkJm+4lEcenBlG0=", "BhiEmGkaJ/r4yPSis0JdraGofQbFOGGCMjKs7bJdbe8=", "C/7coN1eUGsJG6roW+mbORNYdA+afGV4xYNJ9SIyOhg=", "B4sjcwK9xRPJllhyED1FiMixmgAreE6kIX+wRFXTEz4=", "JfFRgqlVWC31o/WNNmSLXN70u73d7Kk+rmyU+vsZgwU=", "Cgf9Hz6KfR8CZXjlmZ7Tx9Y9W//gf/DJbPiyPi4PeCA=", "C9ZL2UKle4wgnXYCvyIqC6XIQlHd5DvAmOk491oLZ4s=", "LL5iyXnmCDdxEv9wUIcBYqlNxoVWJw7npm5lMF0bFt0=", "CdocXb54jv/ZAOqHfI8JmvHAPhEjANngcObG+MB7ajY=", "B5gas8c76qTh53XU5KvOO8hut5Fo1vFX+crbvDDKl+U=", "A9ztZTT9B6EQfWxUUQoH8lwKELJgxzdr3rEMTnaNkaM=", "CYjbEYoZdP3YtDRUnhPshlRkQpjzOIusQBt1tNVQ7XY=", "He/xZi31Ea/hCNUyKrEE5wcD1ltynB39wrx0NF1BcLM=", "A6G7GpKWXCz85BJKir+CtU48o3R0co376WX34E+uDx0=", "KB8Mvz4Da0rhg3lRFrZQcNFuN2Idg7PYiuaemNjETYM=", "FcRXbYR1pCkajbYaItuHDFawE9CEmxBmOG6Fm5ltkDU=", "BnWwZ/9jqWFB6tqACwrRLejqytFcf1PmJB/rlMvofzs=", "IBqgAonAYUfEuGpSGBiIFGn9Dk+Rvnuyca/K6xA3/VY=", "AdWQraWpS0mRfr8gvcVeA9A2Kz9xmquGWVfHa4SkQTo=", "YBHyPBPV7D31lRbHI3Hy6ijpMPcxiTN3YuPU3z9xkw==", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "KJknp2mxY91n9xZUkKGk2fw7jsGJrU/O4HNoo+dadXM=", "BaDKh0guHyQhV7GAzQL6l1xyvsTCXYf4K3xT46aDCUc=", "KzKDCc/nIdePem6GNPVFJMTqzELvmYCT4Ld8JNX/noA=", "Hd/h0eXpRY/7HTQuG5mnOwCDYTQG+TLXq63IRCIEwGE=", "LalKm0Si4mgfde4ATH2cq2Yspmwc54+y69YXzkSe5D8=", "HvtcPm8i9JjO0vTmPDZrnasMsGrcTpL8P4aHCc2sMw4=", "BGTwy/asZwwZQg55YGvER+JZ+LIDpLoV9yrCIOhTyIQ=", "Bn48YaleKMJrVij2eceEPh4ELXhBpnAhkZTpncxhj4I=", "LR7EmTnXiMhT+F2ghVLdRYpIoZfPCwIxV60EpJpyoo0=", "Jcacw6sJTFboYUcCTt6d2r9x3bKUqzdlnpsr4i3Z4ok=", "C+wX9a+0Pm+v8qawmgLu2EVb2s8WylQsz8r/sRnqLAo=", "BUPKrm96/nHN6bgXyadGhw0sxi0ufhxv5/7P7VqYl40=", "FCAlw1hFTaHhyw3plQR2b6KX0fb8Yt6xSuC+xDDVgIc=", "ErVl/9BnCP2Yv4NTmRvSNr3FGMf7skP7BUl+x64Ik5o=", "EvKH8PNoY3W6hDHesBj+nCg4LQs/bULAyL/vaLmbBjk=", "G5ekxuOxNA1WNRPCnXBEKQmId69mGsPRSo5cry7GdiI=", "ARYOGSw1kthSYlE9V4UPpfirBalYd6/KzfYWz3Qpkfw=", "DenNwq9bR4Cs2T6ka+kFqFMOi/ial9QQQc05+pCXWIQ=", "KaLHmp3Hw56K5XzAABDMKuyGbZEGqPLA3vNfvCmzBMM=", "Gzn+V6Vki2sZ7UDd7toC2xpqBZC8tKx11SwBa7XwBKs=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Lqr9KpQBgRO/7Kn2+QnDgMy4yZeIZFzYFpWG5mlopuA=", "J/fobkecnrh6TAXoDdI3AKgcLnIL8OiJpqXV0vKjhcQ=", "Ff1NLU3mQfjYA+SULxmq2L9rAaG3A9/Q8LUazCY67ZI=", "FyqOcl3Sm8Tiisemen+GveFcWLH+L4e7IdBjSbv2qFg=", "EYIOytAoeMzdkBv4gBEgNTntfxTBft8VHyN7jz81e/M=", "AVe7DsYieBvQSF7XnOuUSiPs6xGdrE+I86pIePCC9go=", "GgyL6uTpjzw2MHulqOyzRcxf9NM5YwAuQrNiQsfubxE=", "GTmGkaFjKQiefdYIzW6hh0lZeQi5iFt6OBj+3auHN/k=", "LJIpfvpNaJ54TdXKIkgN5Zse6RIDMx9E3Cwzh3eJqIg=", "KwWtwbbK5ve2ojgsUnyeSG6CXS9robH5qjlf3Hk+m74=", "DqwNQg6qItNejx3PNEpb+MBVWRcfWz2EkOfMWCRLYZo=", "HxTExB0zc2B0jD83wuHHL4Mab4EYk9GIkCaItD/3uok=", "Lf9JCbQ5hqUymXu2iBl5zGi8ro4Bv5yqaTid0GSiEog=", "DFy12jafH0+HS6sfcGtlLvLFCyl7U0D39sD62Y9vQd4=", "E8LHjG4rOWkdXn2jPOFPss/4PONXfxkJ0qmxtzgQBn0=", "i8vsVE+zdxjaLTD711fKYxh/NCRAyAUr2VEDFPb6Ig==", "EthFcXwrLHnFV2mFGRMoStVvL+TKNZ7jnlacvVLES3Q=", "EMDEU4YE/nrZagjqUzqt9TB8iVNKUdxNlY92mg0iWWM=", "DSpZDj/IqiJgZW4To4NybWSQQlyoDqxkgUZ8F/EFAmU=", "MDDYw8rehDjWZNPrywsIifV//u+RTGVeUMtorhTC8oM=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "HslTcE9rsuNZo4uZ0jDKekyOs340eSOKKC2nafBCW+s=", "HrZiaxe5/hKZZtGufyclFIJqC7h31Uo6fW/qjkbJSRQ=", "LDGrobhzx9FNgu07Az51uHGnJk9P8b65YaUy2KO1Bpg=", "Dbbh1D50edRJ6o4PpC7xSkHMiA3hx2mcq0gO3Yp5rH8=", "IdipetMfEZLI2H8IdkxPmo9skJQKbURNkiFR3IEvQnU=", "Kb0UC6TJEKbSl9MWybsS86Z+8KyxT2ivev423KtjjKc=", "CmHS/WDFf1dOGSYaSl8VuYr1jhCDbzF11I+nw2Hpjsg=", "HVk6Vx1NB7a2d8fJhyY8T57NXSZAcaSeamWp++pG2oE=", "CnZKxCBsrjdDDH5lVPReJRvzpMg0jmhtMQPUSjpTtWU=", "D8TFag5X84GsxMPYzMj5vAIzI3X2pHNDiW4BnyZ5p/A=", "HDTfGKvivWXGix5ApjQxGu4UKbSd4Kx6CtiQ1DRmWp4=", "D6iQsPTkByQomeKBLc7vwujl2qjUGWRhLYYrGC+whLs=", "HfQmXkvLhvjfEEJ5drSWcIQE0+uDcP/gbS+16yFZerk=", "FLdMXVV+wXgPOgQJxtU7O5cZBzTW9Itg6kLF1UwZSrA=", "ES6CtwLpnSWmL3m4LV8GIGBTga4hwxHrO5tkB+9xKic=", "CyKmEezexUqeFamPuu+b6L/+jG9ltZT9hkfODQOxqBk=", "E1UhAnVOg8/2qQyt+an7nJxHBMZSAMuHFE57vvk4I/U=", "CQhyKC6pcfBZNYfcjg+Le73zahp2K50AA1NAcwb35zI=", "EB6GxkDDuxecCAWnaubzJu+1zgx7WEwK7sLdrdcnyX8=", "F6EjboBhj2YcawkysTMrQIAqrNX+p0yFdauHo4u33rs=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EjmEB5SOrs1X7Znc5StAUdmn+GIkH2guJvKTZrJuisw=", "AYRuvxfUU9Uu5rxfIXq+ag1apDCEr1ztF4oIGuPiBPo=", "AgVPKZPUhyN79uSphcOrrz6o8FeK1etzH5Sg3VM+hG8=", "GRG5fbbxyDaSqjpEFyqvMW2GOtrPchRj6bNOk8NJnV4=", "AefxGIcIIEKXHCz1RsP+cDHZVep+Nxz/TScOVq6woWI=", "EhcOGKl6LImwRe7FJjZVxH+wj9xGIsWTbQudKqpyHPw=", "Agmz0DQqa7vOprPsJW2u0WBbua+5rcsKyf8NQJdR8TY=", "BhROeB9Bl+dAJybtHgHRqd8BgH2PZ55b/yeDeQK/S4U=", "EpRE/A9ICK+KZLUdlNm+SHZK3hmHgazYc2DvydzHqKU=", "HxK2K0KzCPoLhne9Yum1+2ZEz/1q5D6srW0Sf4Q3M0s=", "Kh598M5Xt6fD/L1zxoeRxar1OHJwgvdzxB6U+iRDP7o=", "EaxUy88OYXXDTrfjZK3Jom7qc5wir/eSCK43G/yLHPY=", "JjIwwRdCHu2EQ37ZJoEKd6dWeJ/Is8rOLakX7mMRl0o=", "EN86WefsBq5ip0m8Z5HRubLnzwu89RnzwCPlQ1FOXFs=", "LuQ/fLwwXWTN3/Fc2Rt/bbwEJecGsQfmsUYxao7UxDM=", "Fem6I2w70bjv5DkQR9beiy2OvUXKWRKmGfdmdlWht1A=", "HXSr7CCqlprW8ZkVhcCc97LktomYp0j8hP4wRRHGtZk=", "Ba5yCR6Qbn+dlOi14A9N0LQwOdDumsFZjDYWyG16sGw=", "K1SMeQpEmt78U3Eqd3srkL6nBh3y9X0ze59RKUC/8+w=", "DHnjQTFJNGz2cs529Rgd52BBY80AyaUmP+xDR3ui+t0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "MBeglyUVTCZyvBSbS803B3GhSAeDPAadcSYY4gdTGzA=", "C5OrSQRQQW7Ep2EVV2jvrF0CKos3EstBC3jkOCbcB/0=", "D370pX6BWGVQisXni9b/N8EdvEvwdzhk6UOxTg95yHI=", "KNNZj8nef45kVYiIZzaiOZAgCPTAxUUl4ZJ89mvQoEc=", "F40t/t4C7Jc12Drm7LB9h1t4NgxF2XlnU7UhYgUPJHM=", "IFXojRxIc8P8dgJhtySoyMhSsFdz4D5HgeA9zUEMh4o=", "IBr30nlzL/JKcwDUpjoyeg0VLUgedXAb+xrmAAGAjeQ=", "ILnXcZURiFuOA9oI0SifoCkjJZhX+lxRpP0/a77L6OQ=", "DAwS2eslzzfNRy0OyfTig4MoI2B8qCPjrTDeacsQvZc=", "DEE1havBQv9YmB0hG+17jX+8bAU42//jYQW6ROGLOOw=", "GtlbzE6ydXwHDXMvfyfKRfRoWIbsGiHmIi3XuZSHrvg=", "DpzXUyOjfYMYJamQYfCSDmWUrj4+lNRaOjOq5iDWcKs=", "D+lDduGcQCY97WI0DVBC9k43CODFVqtne2SiUt5+cgE=", "I2vlDw/hsVRUE9Om0sYM0oy4C1zsrzAfsy1oerhjllY=", "AoAz7DXoVB6je4Q9fNFhPHyV3m1qPB52iMwmrFwEM90=", "GG7qnEM/j1ukMYCHKV+uYAOmOlJQzOJf8xJ8646mIiY=", "GZe+MNVRwxQk3VksLfiX3t8TYxMgv3EHXr0V3Q6yNOE=", "DIa25OwLdnPIHiozz6t/Xr3PdA+nI5UvVVOmDXhmwP0=", "AgeepYYG2H+o6y3jdgemV2gESZCgMp+HexYUHWNnXMM=", "F9cikBw3hHqqH3SjH5lI2RbIgNVHvsew8rmxlXrZeTQ=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DoGkxxBzz/+bwgU+cwwi9vBHEqRLb9+j5dAxrpN7pOw=", "G2Q935IXpl3PWafEpA8KirFtA0zBKByYGUDSrFKMEbQ=", "Js0vU2TG0JIR7QyZRGAul+WCtH6T+Id5I/A2fCXst2Y=", "FOTzjThbV9jO9nzmblGZ8v3aP/JhoTmppCHsHyvVQLI=", "Fo4CqCnHT4Ik1uwPKoe5NxTWCEiSAwatUTCbXyc2yZg=", "L7Yaa08U5H9uxk5KzclBgppIeCCQwvOZQ1OC/2e3dHw=", "K4NT4h6aaVrotY6KEUYOjddjCwc9si5Z74BPVw6KVeE=", "KdxeM682rjSUfCnWdHeHKeyZuKtP/9XD2VfOUyrn7BA=", "DzbW6jfGcFx+p7zDSVCog+xlBayJtrXUHMdDUW5odg==", "J5nK9qJflOgdn442IJPZxUQKqb6Z3uVcVPcSBJKkDPs=", "K80Bx+XEXKl2TAQ4WhY24kfkc4K0Q9c6kF7OBmeQ4Iw=", "Dw12IjaD39pTIM2vzHEaIDj370ZfmEeowcSQTWBmrfg=", "KXT4NmoznmZOm0JnIBK4/66QeXlng6F46gAJF5/WV3s=", "FW+XPQ2deFZ047fgXpbFsRpYLHVlUIJ5YBjp3BG8W2Q=", "GdqRDipL6dA5RAsY1wDd4vZUVXCOfK+rthgJ5BA8h9A=", "LPxYsKvg3vD7Fm0RTtw9DTzqEXrD3t3m5vT+euR2hQU=", "LAxAxhxlmN2KukmK2RmfOL7k45/Abqdhot6JCqu12aQ=", "HjBUOxzhLhNvcZpZIM3jvDXhuUFCqZO1IrluqXA9TLo=", "AS/D4B4nTBCfNB/S+YaRZShMPHVn4mBN1jjQ8iZ9Y9s=", "KpaAsu2lZSOcq3a3t6qAifcy/p8BZ8m+6snKixRjh/c=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FCHgLPgpgLaKnIGijus5fgzK+ABV1apWLZtfaLvr7kE=", "IXgEQx0c+81uKuZK8H736zHiG6o1K87kXHOvXwfbjTM=", "LRW9+zqVLfMcreIcmfKTPtr416o/afwaFqPmvvbH9b0=", "J/WIX53cPsfn8rQ9bLDArh4OJVXvRs27dT0TUo4jnw4=", "A6N6FRoKQhTHi1IhfftLwyPIM6JeDG+lssnE4cPetnQ=", "Eab9pGuGdFavTxlKXwVxowU63ecoj5+oR5OzUW3Brko=", "Ak8izeRZrMq+jrqOlgg0EIavTNTATaJECwZ89u1jsZY=", "BTK5yMnCYnuYIut8tOJrpzVsTIZ8QoieGdgJA75DOho=", "B/MJ0zpNM0yjF5BIeXGXt/ZymjUYc11ggFczA0JSCw8=", "CUfzarzQ+tgA+KvyPt1DVltrbCa34kSvZScDaXE0D2c=", "C7ScM6J1HPuISFVNJMIW3bfmuII0dpupMEygvVgMJJM=", "H3kdX5A3G0S5JeX+BMLplKWE/EJ+Qhn1UcNSFeAi+po=", "FhgpnGCI4dOpH2y8CVbGr7w8OP1pH+rcjWeHrVLZdrI=", "DNTIINgq504p0ZFdbu1TvnfgbDbydZjPeHc7BrNi4Ck=", "FYVFGB8r17ZL+kHCbj1PWRfvUoUcAEan8YwmoFRLLvU=", "GvkeqPwjGdtpJbmUSStl9jG0Fpkllcm/r5P/5YOdhg==", "JsA+rJInsL4qhV+V3gyX0zfXY6918boyep5AnNWnGMo=", "GJsXbNiXXTbg73jy85+HgHadTHQRpa0nJJJ5gcyxqwM=", "BB2cfMv4LHfgWAQAzx+bUwrvze5R3FoaS1oULUFwxvg=", "J0J49pmVtAYmp3luL3Cx1rUvn8/x3FCWcIDZ8DMux4I=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Acmimj+38rlcFTUDJ2Izy4seQzZDRmHZeiU4n7q/MDc=", "LLVTPR1zt7OFMoJhZZEkQZqaeWdIPw46PmPjpBctFxI=", "LpvxOYD3O8nQP01kTndX9KJUI15lk2SweGB7FYQf8iI=", "FGeiYTbcfCGuHS61Mf2a+ZPJwPeSOg8XaDur94R/9cc=", "GIIQzRZKMwzaOh7JHHtVyCEN33Bsuzjt5di2rZgSJTk=", "IXiRE+eq1RwC+LODHiEz4Zl+0xI5yiZ8ZoKwA9APRqI=", "DWrnL0ysOK+0+V9p6a81cd8OpNenJuw7rUycPOdDVD4=", "KfY7t8e438GkcNlfJGwc4v0xJrqmIKviMOGBwZHLfNE=", "Lw/mBx1gVGnhcADinKe2GO/Ln6f1spb3MSUVtwgLoeU=", "LJk7YqksjOuBLK0Y3psMqW4EG+axK+249keXprJv4Wc=", "L6nO1zhS8EypN0dTF/HKNa38jCuJvMTOrn/kCijwWJY=", "EwJk6O2G3K7sCv8W9gX3/UV3eDs0h1hlUiLUtsADhV4=", "BRN86I63Fi8sLun6VLVrlRpEefU//mVv1qX/TJoDhT4=", "J1xV4kfXLOAAaNskq7eG7tcZaLImMwRy9simCfLe42w=", "HNE8t38MhpxEX6j51tSRiffvfsAMtMANriLbM8djGXw=", "Btm2sf0eJqTKB+ceP51AZHyqDvEAqZD/nMS3Ps7oG8s=", "Fp3WKygueP9RVI/BJzHOoYs7uV6CYtE5sZdLKTOns3M=", "DAZTxKp/77E6tSEMwyEzqfqkVrvKX08KT0objRRwKv0=", "Ld6uRqQnhM4y33ufcRiu+fE1UqysIEYAWvF3SIFcI6U=", "ImNkbSjTm0sP9tIkPqDmcjlTNSP4P6D09tV1vr17z6I=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "D5HHohAWs22QEBZayLG3Fp2oQrwKJ0rbWr+ZqttiuTY=", "Gi4KgczHygEiDy5+z5GJpfK5tG5T/5LYzSOLXRledD4=", "vxjzgcqO5vn/S95Yl9Y1uyfexWQTLnRO+N1DbRzZew==", "Eylng9CANRZIMzjH3xtfz4H3EFIsYxodbbGh/rfv5n0=", "IcgvRpv2YFpe4VayUR4PZ+miQuPRFy+CaGSgYG71lK0=", "KNwQhlIhyY8lMH7Y6y4jXifVpdQas/ugm6oJCfyTmDg=", "I82xTcAUz8aQmM/+Ix5NQ6IMaz5NuMbRf8NGP+lAUfw=", "Ie3uoJNXCBWUTWKderRC1ZW25GjOuINoe/ShrUn7KWg=", "CuEHWTfYQTxkcbSB8EtfbaeMSGyew6OfFm3o7b9u9ck=", "L84/B5L1zQR/qLwE3kzfM+H7eBP74UMgz3lLBd8x6bU=", "AZ0SBNOL67RUfBaKi45fkmbFyI+dMMpgl6WTnsQTZrw=", "DeYS4OP/HsjBDy9mgydOmMCVQ5tXwXilvAwyLZTvBao=", "DvoPUOGJN3AceBq3nyY8+f0yXVjdTQk2xZKGf0lwdWE=", "IuHnd9prPSr+Ki9vdO0khxYwhec29YcIn7Eg5cFJ+NA=", "GFVhBaCIWaNU2wEZUen5xZZ6cc5ki/CroV8qVZ/Tl2s=", "Glkx+b+CbmQ9cvHoUQTlEIyjOa9JPPWxzDZFUqMJMms=", "GUc/0j3L2ghnwNdlX0ormd00Fg/ZCzoS26gCtmHa0Uw=", "KclqLYcNsd4eNboCs3RJqUfc7F43CPxZJBSstZgSxwg=", "FXCXpQ/nBOH0xUpVCI7bF0ch22nHt64bc5RAPOaUt4k=", "IekONDAt7M2bNYjMbFvPCr25CejHW/YYu1pTNK96Fks=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "HTGkJ0DkMeIQ/BVT8gMIzQXpP8Wba/Fmrzlfmmb97zg=", "B9XBIN9e/lrUTUPPeWb2JgtSOpsl2mOQF+fxTf2+Iqo=", "Hko5zXYZC9G2VuKYJnF1iok/x9ZZhZKfDJFFU/vnkw==", "J2IHJiN5D8hf6nLWxkopi/sW+QykKekaHbLcokURENw=", "FEVU7Nv+iNxvDBHF9rEf7iqGsexM+daXUAkaeDXtPSA=", "GYO5WiyLb8NzTHZF67SXuULaiHw/kcBU+xpI08ih/C0=", "ERPRoiHe8tpMt/rzaEzrn2vS87D1Jgm/CLJzIlLpKU0=", "C/ZMTvExDyhlBMJaY37DFobPuv8MEN3ycqkvb6ivhEE=", "Egl5biY+DZmZmW6fdC3cxNkqEv1Y6jhP4KY52pM03N0=", "Cx7rbEzS15O/Xnwnu1XBzPSo0BDG5v1JCWGZYKsSdlU=", "BLBdpQ92H26LLgZcbG7HTpJ3rRbRgpMRu+vnc7wjShg=", "AygIaq2evHqgGQ0Cmxuf+Mib2FuQIGeZ1/C5pngG6Zs=", "Hd+62ZhX5LhESeEHbD/3qAWFN40hlNlE7Zpv4iexa4U=", "CGzJPDDpvEv5DAnf/k43VcoicqIWQ07m3xRMJBSTAhc=", "Jh/ftARvnwSQI1alaC2UHZjedNOd4RN0vcJPxEHXlGo=", "IWcsopNl4lI4nECgWNmvPNI9hOmlxMQFtxl0iAN8/Ak=", "LgTDzma5z+y6h5id7RPrpfr7SPtjCI5IAQ2+j6Fjjb8=", "LIsl18dL5bFjwE4Ty8dHhzXJZiU2d8aJ6hgZ52CyCqw=", "DpzUVR+0rOjmJJG35qMtasXrV/tfgB3hsncVzxx3AhY=", "F83CjDi0j2Gki+fR5eXFfo08rvj1kVnLgBeyHWe+g08=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Hty/Hoya3Z85tE6ppGFvpRqQqo03biUeA0owndaTMLM=", "EjZz978RDvPkG4GkRQoS3SygOo4gSKp29GvnZhksaP4=", "DuYushlX3M2i4nbtAqzco8+D7y04HeQqCVK6Ti5xoIY=", "Bnwmjzt1CJjComtXpAGOO+RclFMAGmIFzLtKu5oHaWw=", "FadLyzb5O1WPLyFe6NQcZMR4DfIx/6G5keEW8MblRfM=", "D9FbcPqJcPiOaJvP50ahNXuZpbczVBKdPUlnOuQyIQw=", "IX6HKRDAIOnxHqVDex28D0W/+aLAULzc+itsNFrBFFE=", "HRKptJrMyfY4YgZLbz0KJRCqmfHYNYgMumrAiR4XJXg=", "LJurqSx37c2IPzLUw0/x3ShemWU+YCwz7Tpuu2XnCgs=", "JHbrQHzCVby2UJkS5nSM/3retMuTOZO0+MlkPAOYj+w=", "Bim5cXxBa+Uaa7mMNxYENFDTn8AgeOFJgSE5OglmMwI=", "G4qIyP6ANY0OFTL36iMvFxblYTJrUAD1OulI+j7/fng=", "I3OfqfHUd+lQ/01j+C1jI5BUaHkWWBm+gSGXcwBN/Ok=", "DnUi/NJn6PrFfIficfTL0T1Ij0wlrqZxnCoXz95KqPA=", "BYo2IhzzgYhHvWBCMyM+aacYzs8mK6pFfPHlzMuf9rU=", "CeGSqeRW1IOvyB6l/Jz5O7kaAzNOtNI5dTgCeFxsj90=", "dMvLc4sDPZ6b6DdWmtDf89j/wes+3kSJJWZWjLZraA==", "KD4Li5FVdkXBXe/S2PbiHydiGtrj/9Cn1+nzE1kRAmA=", "EOrecMSH7izV5D1RUlzNDzRaaa1zW2A8wQjBe0mBUuY=", "LwG4K4NGxCV8Fu/5V7IgKMVQJmf6aHTOlW4D+2k58hw=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "BmTnja1rItQzOh+coLpwitarh176jomXoKhUCiWZsMQ=", "BOH1fqsUlUvQshYZrONyuNiurYYaxV8IKqO8HYJFB04=", "BB0ABzqA95C+uNS04qxk+Af4BtX+kFeqGW+IDmU+bHg=", "LS1x8vs9ckaDQj+SZhyPRBVl0uWoeLR69of7m3bhc38=", "LIDx9zL9GYNlFuyufVPxRQdu3+hXps0HSbhUBuz8FPI=", "LExZeMvpdvgRFgA+ggEKKRoAgtvZLarLCjm8sGCo1eI=", "E+PIdBGLmRPYHy2L30qHoB1uUh1lSMZtfAQh23FN/6w=", "HAq9uAHNc2/qo/5/mFFecveo1y71a1lS5qDoB+LGhaY=", "C9cFxXTmmPr8LQl56S6bvw/5LssKcTeL4Wi9qIwz0NA=", "BJBnxSLh8Dk6MgVXtBZ28lOdeBXvKyH88xDPYm0ToTM=", "GYk0TEqgJd1qM8DyyliyLqP0nuXSnwFQ7AXaRKa6vS4=", "IFmDmmuRkud8YYLm5WQAK5MK7Z8yjSQGFwHOeEQI47c=", "Lin0JeMi93gN/ICOZ5SA/KoHYfdSQgpJB112oIXoDig=", "KzEOIuvBu/plFPve4qSM6jbB6TimknSG/KrIIB/yU6Q=", "AkO28z5Dp9HtGefxuBYzFsBAjkVhgNVy1SMhtiKiKWw=", "MCjJTlY7xlRYSz8zWwvDMS7A/w35jTx/LQLXEOHHZCw=", "DOWkaZqWslH+PICSSIddCx1guQyrijDsb4guXOGCP6E=", "K58lp/t0rNUoMeOId/lSl5cLMIbXiIpcLhwRzh+rgfM=", "K/tYq/7UhE+Yb+xEGd2Ng+sNigl7crhMgccqnrTk99U=", "I5vB5NVfxu0sHkHRglLAEfxYjjWP6DnhB1+zRP82bYw=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "CpSMpcH5x9Z5xHbWzetkg9KLj/8fSzJYrKRTEtqWx9E=", "DFyD19YkaZw2VLMsqYpNpHI8RgHNdgnbQGvcxaljSp0=", "D6o5j2/GPMNrAK3c/WkjNImo+Wysj6yNkcw8O1AtLi4=", "HbWIsR4Q66nFGtbU2ZDbtYDGTAv0maO0EAbbysJ34ec=", "HLj93K8FD+tpd+9/uCYl1j9yhuSgv6Uqn2Ad5WO82W4=", "IhVHSNcrDgDw8z1tSeCLh07Sxjj+TDNkit+IYnSLL3E=", "GL1BU6EOvtt48CsU6iZjqFf0WPJwg5TGKCiM+8gCsEM=", "ER3uqkl9LTLpPW14Pa36wnJvhIcJNHLsT+jDa74rtdI=", "Eu3WR2d6vqoNmfLkWWvWThYE9pVStpccisO0TnzRCio=", "Kh1Yc+SOAKveSQKWmpIXgkML7HvgGkKE0EVSGWdd+bc=", "FHDRwPM9LV4rIJg3bRbLoHOMT+J4zPw7gkh5U1RIM40=", "FomUYzZrGT8N+zmzXfYXEY1VB0VhSC4KkSg730CAQFE=", "KvEmMe2epZ04fisqoUo64dKMxJbn/SjcnMFJEgEINp4=", "Bu77M1WG0euGLAnHnto3Er9k7l9RkTwU5keH9Z69T+o=", "JWdod54OB+Z3ypCqflFLtu7mnOtH50n7kKwgkj069So=", "BasVha4msQ+4ZFvnTT4a/pnyVUbgcI/RbuJJOERXTa4=", "CbXqmglpAqEE5bH+UYipjqeKNz5/m/J/Yhj9X3H25q4=", "LTS+1Hyv7MezfKJZAen148ZYlQAB1yhyLcVrceLUYZw=", "LQBx0gGCTUP7BXoKUjxwHSuKNyeLUXjBjtaRDL3O2hI=", "CncNmU+SvaWktj5l/4zDX1nvXbwgcy4VgPcD1BtbYoE=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "GUnfoh5rJ8cGCe0rzHqvT2JE4olQDEj9EkVWaDfMdOo=", "GOrPF1DAk+ELGPRXAqQnZvGAP00q15OZuGhW1W1R8l4=", "KcM3nkJ9TomGKYnWOnIyH7cxl7ApCSq4vyTBJxg83I4=", "KfpQ00SL14PMWa/ol1t9o400EPzOaAIQsylfivMJKeE=", "G9bTXxCaNUncHaf5aVPxw48GnppEFB6F5pkINmzWWCM=", "Klj2dFuQ3+l9P4lBXjdcQ/RkNRv749FAyr2KNDMT66Q=", "HjTomKCC1aG7RShw5BvWfMWTIDHqivv0YNb+TCU+xvg=", "HyiE4QtukKC7FcbsN9JpSJw1qf1fL4pUgALKuvGJvjI=", "EpdxfSZtD1XRqNg+hcIpSKiSJ/R0CLCmu6iMrU5AZPs=", "ArnZgBobCmFlgrZbhNW3baHW9CiAfwdBCMzoZ78eysc=", "BwH3cSlZhBmaEHVkwJGN08OXOAvUfgqfDOzA1X3sn+s=", "GilMgQ2D4/O5vPcJ3SK4EAVd0+ahHkVrKE3NQOCEomM=", "EBAyAXIb6N/cVVSIJsjyxsWsJJpmB5UJCRtxF57tHU8=", "ItZWAJzJrQ6ppgy9TrBYyCD7U4dxTYtP9SYJY485UvE=", "HUk6Qp+NufPfVxuesdJdQloJ115rrH6hyMDaFBRFul0=", "A9GnbA/su9Hrw7IDcIlChLvpe4z3sUu8ldyoOeycTIs=", "IwaIwfJs5l1oO1pAM8xbeB/zjUpOKKrq9XtJXPhDsKU=", "FZya3qAu6xJ2wuFgCTCSntvX5HsSg+0nPbXr3FlrxnI=", "GruKgbRilFa2OZZaD/7m7KrhRZkNl7KwVUb0f6QW5X8=", "Eq0bIanALaMBjxh6xqVON2+PcfzjIZM/XsilWtvNDuU=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "A8bFXMpHQFgpVs7kDOMFPontiC6iU6Nm0H38mlCMLng=", "H61T9Em1gdDtOd1Bl12TMHaDZMGpfZ/VEdDfFss/QI4=", "H+i8s/f7+cIf7bWgrk37fKJ11TXHhHsjy3TBglG3Juw=", "IYuTZn7eOUrhbvoHMV/3YW9oZMuCk7/TQY+dWxR1Y5Y=", "BBpojB+0Ids9hxamT8OdDgZ3pcQ96Q/QTdnzYiuus84=", "KYfct5Fx0hSBegBhJxcWlWWeoohYrhjG+o5QWk6gIDM=", "FPRawS0HGvMFBZ3g/AKHeNXByK+0dtW3s84upqXzJQ8=", "CVnx3sgcX4IlwfL/SuLGfHPk03l1b0Dun2kcgu4Ixuk=", "CsB4ATF3mtaRBp7LxPgIhsC9lRjZ4EuZFG0pvX2f/Jw=", "Kn4j5apWaLxxmwzCbc94HSyjWZh/G9b5CZuVN1HGH7s=", "CSwLiX02MjEjvtbJncs7UOOXxyLN+qqb9nQJB6S2U+o=", "KbFnTB5LcF5/2T0Qo4AUW+dZNHEM9rQ9JIF8o4aZ5wI=", "JdsZjhpd40tpdKo4/1NXLMxANkR6ZUqn8GhgIjPNwME=", "D/MXStWuGGYG/6y9VZNrZYOMK+amNb+MmUFlKkhbjG0=", "G6+wi9vDK/a4HSAmAF46xjkK0+NvkXi+IQNCYupnTpA=", "Drz2/Cl8NBOGYc6SNefAFT7aHwyZFzlwRCl2/4Se7xM=", "DXKSMOXWkTp3l0byl141GX7tg6phO3+dy/0vcTuHQLc=", "IIcOJrEU4eIMcK0tbDwpvXiRi+pbvX7IvApgmA5gHbw=", "CEoxBcy+uBN5MZAcwKSMp0JuXb5NAJXBHWPQ+Rxk3tw=", "Gx6bHVnV9FGEEqgoR1ylAET9qhw0kEkbtQjXKWQ21bw=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "H0vqDzxdvwtCYbnfNeXPalzDaXPQnws1+tPc0KTGms0=", "ASIoSTQqFE3isj6L2Ej/0JbNMzL1eiRd0+v8JgMqYYY=", "DKezPxEpqY1ATogu0KcHN1Q3BiSMc3TZqmRwWDskq3w=", "GPgKh1yilypNE9QdgaHOxWzzhHgLVzjlmYjZq6TLtm4=", "JCj97i75kS9Gk+6cKlnoLGJeI+mveemQ3XiEQQhG+Oc=", "FUeBorXEQB9q0oCfuawj8xNqjjlQ6m4/CEYApzDELZU=", "LFVNtkFTNgbBBTLq/iQ55I0pJcnW4YPdhfDCSYauOO8=", "A7iyiLHhof0vrvq5tOANnFA/hXTmcRK75gPuo3uX7Bg=", "CTqbA9pWG07WquOpj00qnR0oFG6w6RRkwloOjy9gEcA=", "EIhD+NTu58nfhr2aLc8APT7OjB+7LbgKDiJVl8zFQoY=", "HwQ6cstUMqTHjxRQXuYwu9I2foPxjbBH3vs/8aSVcV0=", "Faj7BuDBTBgSRLP0PUln4oujK64ehCIwN6uxUk/CZBM=", "HdvJUJZ7F2nNtPhoSzTZvCWwTesP5fsRetYJpbf0BJo=", "JGpY4yayQNGGGJCLE3hWNvBRyhw9Wszdz3z0rxNitck=", "HPmaQLgmV1i6aEQaRbSZOZPXMqizuItNmDpiBEwL99s=", "195WGfTFRgUEOeea9fLQuWTsQKySq58zxhdiPJ0EeQ==", "Dl4WUEvVQp8ZiZUOj0GtrMlbyUeJ308p61xiOpzkrYc=", "BB81p4lqYnu4hPj+p4LLSHyHLc+4Lc59DmlBdl0ewUk=", "FTfevBg+ULJWQqlDMnObnfqGEO+Cl9ljrU8lEUiXZ1s=", "LXAkQFZ7zZV5IKv+PKF5bcEFqdbWnfaPcEDUXhSCUVQ=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FISeMOQj0oGLAzgkvnnplNOylKd0XUe6egRBLJdqTYY=", "E2gD3JtEUnooMa/WALIk0742pPzx8bsS9vPZx4pJtVo=", "KM7qxPO4VhWGV978bsLZiugiKDhiWVGrpR3z2SMjr50=", "JOKp4qM3lfKe7E4+UXHNGk8QKzhwMnNiSNUdosoJfbo=", "F2t8kxyE/FGmlb/GNcmy1+OMD8njkRml0nC+OIp+y6w=", "DSMPvIujDqQ/6+TX1XzWRsFnmh4agGZjfhnXtfeDxGU=", "Cj0XeFL7FDLq5M6oAF3/6YTfIzcFo2Lqh/0xhlixsQs=", "DqTiYn8bDxSoT7cvFAJePy1Ah7XiPhl7S+GN6bxdB8s=", "K1pVhuGF5q/5ykLdqvSkj8vrNCozt9jDAzT2mRdpXBg=", "CTD/RZUOCzpVx7XVmxuxA/Q9rYfxDcAa9PAp8TNIYNQ=", "E78p2ITm8vdxjGK0my5EiPeKvzNx5g/2pV+P5hQJOvk=", "ATR+xvcvHmQkr13AfnLI7XBMHeJd+NApigbOh1M38W0=", "B/mO7DfqEcapU+1AdODeAxnHHF2Axtmn8aftFkLNs+8=", "H71UZ6woQm6C7pXU5nwb853bsNAMjtyZTQGwhegQJfA=", "FgrSXQpbSBcR39U3Fm6adY9GrphwXAmjG7XcnKZy4Gw=", "DRsFnXYuJseyN8JSnBosBCARKwSzQHHzZXaOMcTuRPQ=", "BXbq8i7WupJHp8HNXzbaKNPIL+43Ap1aVk6uShSfLKc=", "GJCXkA5u0gZ0A679jLLWj4vhOG2sLLBn80bQJ7ksE6w=", "HWEfGsCKL9a1CyNhLNmi37x30/HwHN8Ml3dohe5fU48=", "IZZqxR1zJEVgnK+x+kUqZ10W3398DJMqoTbHkU2oSBY=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DEM58OzwQOygmozmi4KeGBdOGDiXjRj/yFATvEVpvYA=", "IL+IKsj6K4p5jAvvk8j6r3kkjd91IL9mFbjUQ48+L0o=", "Hgl5hLR6uY4/GvMOjbCusW37clel1xe3SgMCwMZb5aw=", "AhJMRQr7RRyDRZevzerjTUlPQrg84WUl3dQmiXy4UlY=", "CuRvSqxku7c8vEhhudZ9rHpblGEYXxrzk9MODxTmyG4=", "KWCONeRhjy0x938SIthGHF2vg/j5ahw8IuzldLrRiSo=", "CN2lBJJbjnKXbXIluTSLYh1BHEJyUFT5K8WsfyDuEGM=", "LYPndu6Ee7YGFl1xxTlTgYg+7+PnLbII0FZxFmZyiS4=", "FYxttPoSBAJ28oxS/EF5xAwLmSzj/2FMyKM1uty1Ylw=", "K6gayH4bpKCr01701ecICY1bPqWd8CYwHSmwxjkAHRw=", "KXykhjbCLhtBrBDahNGJMPQpMpe+LeZyTUocknzmrJI=", "HsL6NmCIqj0k+qiwhXsO6UfnrEEqXDg9gKUiGeMDZxU=", "DvjpCrmg2SIJ68eufu9ZkTT66tg9TNxqNeEUhvJW+Ro=", "GhujfOazHEbwaxZgB7hLG1pyknd2naEqxFoFMpsasl4=", "HOWP1rtMcPIioAzhXgNKp/lR5VdF9+sOidmUXcZIyow=", "DJa0rrqvIR7lPCWSYRy9gVzYrXmrh+tCaslR1GUgDzE=", "L/VW6pHqQBCuMismzD393iG3eBSu7s0iTYN1S2+pW5E=", "BR1NLjgi1AdgenY2UkI/iKuKxB2DYDLjMNy964ndlNU=", "H0hNy9SuAyY8EEPixn3Nhxr59oK9Bj77mdbywfWNyJ8=", "A2Jca7vrpBzvRBnPx4haas0jbyPBC8IeuW+jMpsKqAg=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Eywr2cPfMhuDKfmX1R6kdW8G0gWZppsA2fXTJ/QxvZ0=", "IjJx2zbFpbc0iTZm0F+MI0ctpXUMnMIYUlHRzomM3DE=", "DkQtE6BInI/weSIZq5XNy2qsA9EmF7SY7tT0N+npD4s=", "BJvXcU0BP51K5daw2KGWbjtuwpkfgJOOmUltsSd4xio=", "FoY6zlJXmlGdwJg+c/ORmC802usxG0Vc11s8f3XEpAY=", "CwQ7u3qDXpNEA0Q6hx6LCXieglMUxVPdtZPBF+2feik=", "IjPkKxGzFRLNZmLm4tD2EjuEQoB5/SWCPjmse+CGwoY=", "HuwjRLVOu10tiSgs7yC1qCl+ylInWd9+6C+TBs9wE/I=", "B9PC9/+n0wexuAz+f8T9xXHuAICB0aN7g9g/korsvtU=", "IEC3LrThMU4sb+KLDhDNovREuql88VsRClVxrQBvNqI=", "CWjGmiciOdRlewLh4RV2NWVMJJPF3CHIDkWcNpQ8DH8=", "ET2uoJHxknmnXRSPNAeUBgUUf0Enc0cYGi60XaXh3rM=", "HbnKrYpzSXq+7tTOEhYtFsjqVqa6ZoDO4CU9cBDIsMY=", "AyOQa1MbA2pCJUT5p4m0gYlHvX4QEKnTFH37KY10fJc=", "KhewLmBcZvLpGR9gAf6NDAVOn91yqpEtYbFNs+nl/zY=", "ICFXAfBlvqh9oPUfMfsXAiov8S/4ajp9UL8Za5oXk7M=", "L/s6jVBQ7+ZseY6uLjf8sOdcjTCYRjco8SWNPRXpxY0=", "BCqvpQhJtQQSTqeIsLp9OYzne0LAnyVhixZhr3bELXw=", "HwdgxH514piMfF8nKXdv1lbKlQlZUAgHwzsV0qILjQs=", "G0EyRZLTf6+oF1rx2uHa8JO3vQdN6dvg9HvyRv0zgpU=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EyZ4K+BkuCLNVKgtUm4IYfac0FSSK3gJyy8caFslVEI=", "AUCUFGRDWk2kJcJGJ6AdXQYgQpyvK3TBzYIX9uwMWVI=", "AW0DgzPvgmW0Q3SV01JRQCOGtEi/LGUr11KHXNar3Xo=", "FLO97QKD2PgkUghgU0crqqlCFPxk4j7vqwT/OmZu95M=", "JlQj3QbhvDDXulA2Hfewg3EIC2HP+lz8tN5rhAzfzhE=", "KMTTEGqlUUJShaYmc4U9tu5p+CCjgBCx6YbsslpRfEM=", "DvQZbwar1L4sbHfN09n8cbcFb8+CuoeKPA9KZCGE8z0=", "Ca5yA44H4GMXK+7vCFsWAgTUH/8mEWSGnd07NaqoUro=", "HmU9MT3AhaGUc8vxc6ZadS0wCsEAGyzG+GjFrtHVqVc=", "D8jUeQEwCD99h2tDejaloHhhvT/eOUpyl6/7oAzAJms=", "CIieucAvKAXVmtfBzBHx+OrH0QyrsyTNKKTOtk+rkzU=", "BeIkX7NKC21PyMfZuY+qqqV4pLxlC5zPwI8vlFlled8=", "HzAxFgIPzxUa8hId4p0SN8A7idJ8zd/mKDwe3ZhajnU=", "Dw3ra8BvKVTx/25/Kw9YdKQKZ2IRR/SdkgiRPj2i7h0=", "E4vXC7Me5BZoZDHxG+Z2iZn4qIHNXe0/ukex5xW5inY=", "IyPMGBptlgBAd/yK+ngAC2evfrpKN2mWdTJnUco1h78=", "LMWpNSQIOdCRat8LoqE7NzzZoknz3/KdTmNuo5uy1Hw=", "LC9+IRU5dA8TV3GlYTvhudVib4S9m9PQhvbjPkl9QwE=", "I6OxKURyjZ2K7NW5rCwehoOm1vzebeCfnUmBV29gv3s=", "CYxghajegGLEiCqAqbU79gXNbTr96SW0vZfdDO1jotE=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "KxqkjtBhMwZBt2EKXKO6A5e6xa7RIgq/H/PAU3mdV5g=", "Anz9Bf36qxDXA8VhOsnDDy/eBIuFMV5MrTmnbCYlh48=", "LGdoGEz4RXOg6XBwSYfzYnz09GfnLYeKup/w5sMsdt0=", "FmDo22+yKZTNIIh4A5VJ+FRkJ4ptWT3Ycd4Dxf7YIz0=", "BYNTHv/YTKabUX/e05L2NlN8ysOVdTE8BFZEEes4Gzg=", "Gx82kwbZMS1mUwIxfS74uopWczZOu4S4LeFWrMvGhIU=", "JuGuHkYyXu9i4K0HArfCBBHlaHrIvIsMQvIpStUR42o=", "ImeiSEB72NwL6NbWCpAeam9jGY5Dzp3ti0jzURfMpgA=", "CvPa6CiGNg514mXyT5KEF/NAT83BiJYQTgfaxUQUbQU=", "EyInIGis6FOGcalh6Bgspzea6AZt+ogkA2hWRGzmgmI=", "KtbYevEh1LnTiNw70PshYN0NQ9611fzncLP2bSKoZaw=", "Attiitg724yHZCqzZ5bmRGSnHI3MB9tBCQAU1oJOnlU=", "C8x2+DAePar9VxInzY3Tlf5bHvKogmKqqjDq4b6Fpmo=", "DpU/PipuqRmjmEXjSo//BodPQPoMAhECVRUj8AUvKsM=", "BO1glrWSUs7ubavOSUUBKzr6kpYZ4ST8FnT5dC3mzps=", "DEX6vkX61FfV52O6b0AeA4qPBRh6UBVuLk9z6esMFSE=", "Cc2d30JvB818py5Ku8PKOAY3Bc/gSgAjltkRAfQajr0=", "A3EkwT6PU5PQLH3ab8ObmG4Q9+7n602Oi2eYrqi/gRY=", "EjJsI7ULTyrXrSpuL4HnZtqduq46hdUlbDb1T5lQTBA=", "Jwl/Xdhua9DAnsB+0dVlhGOC0RMQ1T4R5K2drdotKi0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "ITcZ7MFAG38UjZC7TOsM/syx+EoDZwplzyBxqXxVGIw=", "A86esuWnjgn9j5m/NnfPtp2NgfrC7VejeW/aTEp14Gc=", "IIX2su0xQi8u+MnoEyMgqep49in0AFD5rh+NIhKCJCM=", "GMQrEKAjmgeIyoD0C8qezrVMziitcCWtc8BEH0biXXs=", "AiltRohdftyeL0VSqPYeAyCrkRBAdroJNBX1Je4b/LQ=", "D0ZKR3dJU+FkfIgjwfDnll+vbo5Ro5LzQuJ/a34eP6w=", "Gvpacwo3f3WV/1mMEaJX4rJdyWpxpTZnHpjE/vj7sSY=", "J18E1f8cgh7ycp9oUaNyx9tivT1Fto/QU3V1OpyjitY=", "GrRemiqh2uxFhryGa6wbrnjYuKoRKWLzTFwZpFiPEbE=", "LCsrJ0ZbqPbBnBs+S1KtnnbfhnGsOBfYxGf7fOGg2bE=", "A8wsbNIt1YZBSh8Zu5uw+Lff3nc2nyAz8Da9GUEkEOc=", "F7ba9AG34IvZxBTQZ6bLSE7gXLLnwHkawr9BXoR3Baw=", "BDCEIk//9/suc5gbPS2mRYjnRuH/Co5BAhz4FOhGzvM=", "GdJRN740qnM3nxkQf++qt+1IW11JEkIyqRNBdHgYsSU=", "+8AKx6q5J/yrOMwfAz0Mea5Cy9ivi5xnYjU2GAX3lw==", "KkUuV9g137FTxdWrcWxhVYamkvIu6LtwzTLOeGZ1uFo=", "FO5Bxb609O67hErSfNcSuLe3072Wr7GEF7C9g2UOz1k=", "FR4bb2SipqxK/T7TrctZovJG5NAYqFpN7CmGeZi96x8=", "DbyVvpV37aJsJrlydngKLEQEbv8tIO8+IzvFE+7x0ok=", "IULADcPvVuWNT6U1KX0jSf5ahyBgmkWd59EO4qwgZzU=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FPnjT7jPkCA32gKH9/1ZRg7kLYZULqAn9QZfT9s2IDA=", "GvBy7zC5NJmiFocHHZWW+MByCVn1qt1HMBWjIPUl8+o=", "H3n49DaVHqtIOEUVjXmK9JQMQ7bHYGSWrHeH4j1RNWI=", "AyrBMn2R/aPli2SmKdBmt2GLDSuxS/AFT4qZ6pSn+dA=", "FpBSjruA665ibkx614CCARBsP2lYqPzMqvvxBbuYKWk=", "KNVya74hNvcXy6IhQkNCCQ+JIrYH5h/dsSeMkJCHlyQ=", "K4xs2w2kPhokNvjEOrN0Y1a70KQK4PS8KCyPJNIFsqo=", "EFfhop4c9PAWsK5LN3yylG9OzsFNip6QbovPmUlozMc=", "JhdSmexLziebXNhlEQyw9yU+A15N1TDceOmN0WegLEA=", "L+TROp6gaC98bHni+qZCgjxuxhZoZKO+zDqpagYCMHg=", "CPr2DydUxviK+DvlHU2PzZGlMMf+Gn4VwEZyvi4m/4A=", "ESWwuQeCaBBQYc1Ez9U+WbREHElOTmIVE8Dip4l/KsM=", "LKGGdCF8CBTCAJhKLm2W+mrXqTo1DMuFfykd+gprfIc=", "G2VOjKN3eEfX/r015xVVtf6nVbFnWBuRuOZudVehN1U=", "JcteVxrvPF6lQjMvPMZG+UDOHqmGKEB0ueyaJgKPw+Q=", "EBUqGROvvkQYCvIOxZ7DKjk1/StTHZaPcfA2UFT6rhU=", "J9GICUL+z0+eRtEaHj21PArpOFpnYQTeEiyFxnphs9A=", "C0re5roBcHwjL8Fz19s1b9bculZnCcyB3OE9tCVoXA==", "HkznsCE7OdsI0H+4YSePwy3tDeYjLH4FD56T5Kvs9/g=", "CeVULyuEgdY0KQELP4mqLAGwdoSwjEBtDIXL0P0B0ss=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DiR0T80oJqJRMZEfT6jtz4NZf1LHKQaTKljzBH+dFqM=", "F6J8/09vmi8qG//JmPDsAzOMD8PT7JeUsTr1Cz7Rd74=", "C/kNvmAivX32iOqvO5AwxbatDDYzs1Gr5ZBcKisuzLI=", "JnjjwfOQ1UWWltlQ2623smT4KE3c7669Eg6yfisZeDo=", "Jt+BBNTNs3fSKtNE6UK3YmG0V/UthJj6ad5OG47TdZk=", "KcDWreraaKhp6TTSNQp3yR7uxtosDX3REbjwPXOi9U0=", "FRcpXHolYcEYbvzm5UpgcDB1QLab/+Yjq//ImERRvxQ=", "DXmJS9cwDfb9BKk4NkODWMxNbmkh2jhSCgT7yPtOzpU=", "C9pzPve1P1hDgRApuaXEEiN6crloALzcbHEiPVcVeRc=", "J9kcXYIvVqeMhvJCLKR4a5SqovPgZvvrNbgcfhbAobE=", "Hm3Yx+c5+t2RiIhgrfA5LyYCcqaNMrkU+IYkk4R0MeA=", "EV2Gg1wgonyhbArvWv3XOhtrfKbxIRZyCyNSdMqJ+18=", "JN8PWTdrG1452ewqrXdiePqyiAR6LfXfYJkNz5NapQ8=", "RYhRZ+6OaVxqx56u6W4IeUbFhASQEqMJq47CCHSRvg==", "BEtw9eDfQxmCdoW+Jyoyo2yjxBSLl8E72rK9D+NluuY=", "LMjrZYvTr8j0IJocmVZnBcr8eTMlcfEzl5lAsU1zbxU=", "I4xEyE7jSbYwMLD7Avp2U+VHxKYym5kC3jYCw8T92g0=", "GaMstgKfzJPbKwHeuCZKnrFX6ZXKIaoOM1WJsG/3e+c=", "HIYS7JiqknjKqMtq/b0AwC7i9VHT1SH/Xp+SdIVXkz4=", "AqZQn153DMUNcY+FkPX53ndINy0tOfWahZySEe5L/VA=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "G6sSLFYBGL7o8+f74XEqsrKnMSr2H7mCC3fe6NRNbe0=", "JxcuPrUUg9rAyY4y8F+85odBTDo8wnqxwnexPOI3ghc=", "Cp49fz7zTROM2vNrkr/wa0tzvJzjYVZQV0EZW5jQSbE=", "HsqCZnuf9q3qCeqEDvy6+l4gbJcDfgH/uyhBL9K7RK8=", "HdjfysFXhDz1+U+bELqiHwDgKiy1GTlEw9PpcPkQzXc=", "I6HmiQUiqJubiNfbQHsA3GikBpKjZpNt4OuaV7vxwhk=", "IE8jazm5E23JL4E1GSyHyYx5hPHHfLYGTHHsBHl1/2c=", "LHSAuJOlKP4A0c4eTSKzML8oZEP6RDWQpj4nqpHuzVM=", "DFNwoYOm91tpjA/G3rREfLpd6e8gAs2OspBK36RkWEM=", "I3MA2xeajda214RzXN9GQNYdRLUY6ohI2DIc2it7R4k=", "DZxYMxvqAsyrS57wPrIC8ZVbJmxmZq2IYnL9znsonac=", "D8z0N1vaLF21E+LdBjjqHS7a9BwsdUSC+DPhfGLZIBk=", "DEFOlVuESTqabIJ/JMOfYqn5wsi92fdsOITRYhfTDIc=", "IFRNifzHlBrEly5VKDANDDXVplC4/1H3KXQAijEtQKo=", "GvWUEkIbUgwRcdi3QFfbsBZT9BCC+Fa6Wqart5pDw1Q=", "L8GkWUQGE9r3KNoc86JYwJO/QXBnJOYmCvzswT0yS1E=", "F3wek+4O1IPHPxSPx/mJHL/DajOAdbwBSYppsOH4xJo=", "CYwAWylZ7elCVFLu5JpLCAMjfPER8EZRH41Wvt76doI=", "FYZtgtJR+a/GksGhFc3FrCi0dxvqhi3CZkPm2x1hl40=", "Anl+gdxvweIx9QUdIoCBtG/lP8OUUk/0JJY9qakQcLs=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "D9Jdpf5izlChUl/p41Zun/DJWHMC93jXdWvQXYxqqvo=", "KhpqeJ6QiVLMjC5y75WpNxeckkiwkdAW8o442xIxIwg=", "K7O/j2HR7YXiF1U06aW6PRfcrc5F7ss9WHSaA+KwT70=", "GjCojOLkj+Bg7/GOHHvKYle445NRgjqBna8wP1/mQdk=", "BezTJbNX5HSC5OdJzIMFtFrB5lqn3dkVrDfzCY39LZg=", "D9M+7S5RBh7Vy75d4Ftu3pFS82sRRoOH9Ripl+T3IhQ=", "CV5MLK7bHeAqbGCwhrjYtnua/RhvZeFY0nSNJRTTew8=", "GELTh4bbrJQAkpZI25IF0llndkelAk41yqsIJgdE8BM=", "ID3vz6YhOlANWniNseD/4wh0QGNVUCZE3iBqcwPf82E=", "KUGp4+29Kq1hOMt1gshSLBrEiFtxnfqvSasKE4wkxlc=", "EP8qIBfLo8AkER2wfmd1h4lr934Gc6koxcLJ7cU88rc=", "Am9Faqq9rYHTOTDNSDQr40xIhNUsF8YEtF6b2AzzwZw=", "KONKQDHOPluS1dkvm0czZo6mV2K75fu/gssuyn4gjZ0=", "CUecA6vi/EvRH0ENf+lYqmSq0e2c5G3hLhbc4aqQB6E=", "GQGmJ1jDuVN4/9g29UOiwsGSLruGQAAYSxopFn7WCLM=", "JLvkKZ44jgHJbX3mG6nprUYlb42MGGsuOjh9VYz5Eq4=", "J8hBcNCkl5jfyatNapZzHQ6N53LKlRw+u3mTeNIgM+A=", "DxKpueDPTaCMCFdV9C8sg8+fmt2qvgb+2vvRzLdpbhs=", "LjT8Wnnz14Wf/3PuFZ+KljzBgM4jUfJwnby/bsCi1+U=", "BtKyzhVwVhjRV0EnyTJFYNLCIgZdoMZp/9IwShvTFmE=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "BbIuKfmRQQDgnx2fqm7Ei4SdBtu1Z7l4yOKHW47d8u4=", "Eh19gOyhTHHTqdVo0fs9F9hIMSrCFyJQcCnsPfYdZKA=", "JIZEKU1A/BLPU4kmFOwOketiYd203lpUWQdwtaY3keA=", "CPxQ7ilvn8blCKI7ONGAqpL+x0O7XmIBfuSj98mK6og=", "LyM9JIfxjiKDbfiTmCpZPHS3KU9s/juj7bgnK9JVkXk=", "EPbZQCL9LAePxtrLFTKCACH1DyiLpArkAWNm36cD6NE=", "A31d9+Fc+VrJxL0CulPm0Dvd1nekEr7k4GA/iOodbvI=", "EjVMixgB8Q3+bDlLCDF8fob0niEuyTP/9J2LJlU/PnI=", "B5Z53SdWvgJP6xuy7gqlBho5dSz3EO1snLWI8z7ejQ4=", "DTtCTulFXxNxYPod1TT2e/Boz84ZE6B1/fHK5+gyTKY=", "AiczgoHufaYztLOTj1u5gfg4xAreSgcQh1FH9Sb7rkk=", "I0rCI1i1GTdzQWUcqT2tQ0gHzORJCHvUOE9G/HMveZc=", "LgyV/75oD6diJZiTOtqypXxHKgBzv/4QwChHObJnALY=", "FeDInMbDan24QdQnCFXR2biEkZf5sIExtiXVptm6aT4=", "L4lSrYOx/7PBpPvRBk+qxPHJzDHQ/xVqF0eKHj0lURc=", "HHxIGD7CB9q2jXOq/rlgR8z2aDGMCERT5JXr1fkn0XM=", "Ds82Kiacu45WwrBTfxCKQSrJo8bjUdDSfTZaTbfNdeg=", "ARzVb53ty5kcDGzZyaDe+RHty5FdwZBDkHgqfukNDeg=", "HudOIXi6roQt2WWGlDgcyTsBWSxlUWCSPUD0rytT7t4=", "EqKDDiTIv06cfwGVJvccxXuteZXzjG7SAwa9ewDw1/c=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FOEu4sL4Klctl8C4EaJVhLvMyb4bZ+0aohQbLMeT+8I=", "BPMikedjYiG6eQWpo6HK6BKtVwJgyBs97ZrzNhn94z4=", "CKCBvxSX5SEPbgQTyLUQ8AD89KRr4KG4RCxbx+X7d1E=", "AoRXH/z/5wdRDQ/riVYGI9t+O/V8lnWwL+vOlft5aeg=", "IEspighXfBJp37jsm0s7UC7W/DMDVEBH1W1BNdPAGrg=", "BISz73vPXWOTS9z1PYqjcqCwNjsCQTILqjcB6KHQ2gM=", "Cdo0SR5SyGWlsIDLl5Gh+4AVLAQzWx2rw0/6atYihCw=", "H6PO9WN08Ah4NyxUBw2cQcWrmrHThZaNr5yirWfUlPU=", "ILVbObjfb4aiyjgeIDfWSYfRhExZn+soKWSJVa0W91g=", "D/HFNpd41P2W4pXCG+9N1GSPrZUx9mnnBK0uQXhnRWQ=", "BMTJIRLZmNVzaz9GEgQENpycDkKOR1d8hXUJ+lVqFaw=", "J6cvS26YlpRefVhOQfvTzV91hi/G7JRlH1AzyNo0zQU=", "Kh5Gcm7ZBoUE977PBsxwpfZFgRvWW+V5GUtUSGFYWZ4=", "Fdrctn4wt32LHl3Xntw2w9jQr7Kbbn8CB0VekqMB3JM=", "KcG8q677SVR0OnoEUCZHwRyfGN5n4hyBHI0rnz7YLa0=", "B9CJqFHRxDrwXmySQ7abd7EvDAsN0lNRxSLOjdmf5bY=", "EAPS4eU2jRMYmS8YG3zad4bsPnIb5LuJCJvXlMbp/Gs=", "F0fCh+zjEbVISt7O9CNDTXHKgHkkxUpT4xEJ5qUC6hU=", "E07/YBvejaMOYomLLgXBf2501KwxkZxBNjiEzn4w8Bc=", "Ci2S8ygIKj/PWAmVhnHjBNqr/bVwjtwswgcXVSa6Pic=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "BOvtLUO+WnTooAyqg5ifFsC56CGU22jQciJhSMCj1xA=", "KaskZjys5ZD2l1FQaQVmcHnbhNM/eCBKMck+e+ofqDk=", "FDUaB9OHlDz0a2VJbGa8bzvsjqIA1iIHSsJDDq9SHXg=", "HEI1dqB18dc3YWiyB6bXIDcSxSPGep04iC6GQsj87gI=", "LAVk8cUqwtn0YhF0O2Mv8HshCRbeJY+D0E32i6Dikig=", "B65+ROvhf8JKBsnKqveHwvAHxkD6qsa9F5B5NxKmlSU=", "DE4cVmhx80hK+6fTZKt1W4ObCcV3FBOwwx7WoP0vQpM=", "F8Tyhz4toATy7d6gijCpzy4F8Zb9MzG29/Eifd2Of6I=", "JvCoq3tbCsRZPJiome2S2DmDfVIMX28K/WXaaaEgXOw=", "CU3PQZFcbH/6Fo3HE3r6Z3gHbCtj7WPRqxt4doG9YKQ=", "FSQCNZEtnF6tj+7MKaTXfY2kfp0ZCXYylOoYwCfxus4=", "K/7G0SpUiw+5/RdscgDfhsO9eF2GtRsgdr2dPoJHMSo=", "FZVN/+TNAYrMQ2twsCngFGUpomzbORUUaHZ7iMgKyC8=", "H0ML4moR9yJWCzSLHFtSaJTLRY2KMLSYh3E9djaDAto=", "E2DeE1H/Z7Y8MSqMrMKkZbuC3909eSJEBoKSqsCDyPM=", "DK5Ej5inJZfmeGeiTrbvLBzl1FT88cnrTYTSHOgVkMQ=", "IOkzbdED9hpU8n+rZeX9GjF+dfu1siqB//J65MivvJU=", "LjbA7oUzQpBnMOeiBhw6otvf7721VLOjMMDvNLunQCA=", "Ib4Qguy7w6MWydc0lcwIxgCC4cIK09TutVVT7vGpbdA=", "LHzsDUfHedxbYU79o5BJZC8f9AmkC+icyT4pNm35bcI=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "KHyNM8C9i5/8w40aNQG0YnEaQYMzkKpikbVpEyHzTzw=", "BST0kCl7//FuJTqIoCsDn0175BxipHUl1hVVj7uRoxo=", "A6b3qW60KsqGz/fiQX0kXcGejHk06R897bQprE3nxh4=", "FV3RvxtTGcWZP/1DW6RfCgrI1H7wY0IwCLhYuiFIRNE=", "AZcKDbVEVdtQjzaeN2NFtH19+N1Y9taczoMw7UhyN3M=", "ChfY53kH4mpsI6Uu8rOQZNoBTwMLV4XzztmKjarso/U=", "GZtCoNs7gp7eJnNtx/75Ty8hFnnMpj5137aiIdSJeAc=", "HUktfH2qgOtk8zXpzfMGsL5LQY+37fMuq78Oid9bjmE=", "F8YK8Ckb95b//bxX21nQOJfGcf1ym71MSY5gadBnGtM=", "DGRuWONEK/Q7IlWqC0TEXIe/XJR8pRkuuQZDKvtHeRo=", "J7wjtkiOOOLqh9zr1jYN1CDX7JClhgHrHjEsaZipUrM=", "HFCnDavu18ecvi+Rsvmh08qcytaK+gpBl0UWCwPMB74=", "ASCuckq8x3LsewrJBxm+cunBcFmxkfblYmIEhOaR9uQ=", "Bp+EBYoFZflDxPXP9Mk5WBl1FlFE8dIcBSF9ZJeK2AM=", "FKCG000MtMBQz5lrCGqjoh5FGuZY7gsDfnsOwo9ZBbs=", "L+L45nrCc0uLH260CPX2L+iHgLN9TQ4zlshWEwnxOS4=", "GxJSaN99ngHXibomxZVgaZiapTKLvUa7OhyD4ptU87g=", "MAb+FO8UuHbC4eLHQVyYt4kYzskn2LcRxOEZh8LizFk=", "AZMy5syCIbI/15JsQxtox1WDA2okt+ZSRSfqz3dbW+c=", "J4B3XP4a4f6XiXwoYUKDP+KJAorE5RKFcZ3xTE7JZ/4=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FHTZEXJtmBMqOIKBlvcrqeoo3g5UCCK1MNU0McP3h8I=", "KXeMt6/Jn/YtoaOT1guHu4VzYGq3rXzQzmR7wZhMuxA=", "FIPRDDU3btegJxaBmNhxNYx5r7uniF0nwBt2Z3BkaBQ=", "Gowxwjn69H13O9ug9wgB6sCsABxt+ThGPM6BmnKhFZE=", "LFjge4abwUuw7rZJ9cfZwni292OYdOxATr919Y3sSDE=", "HWSYUHMoN+HAfJ8wPWJ4uxT1pUyhTIaiY3kCkCPDxtE=", "FDBthmgoBQIRkXDaFBKPajQPHe1+K6IJAExC+mKLOgw=", "DUF+z9y1kkQ3dCYFBzZWMH0DniPcnP/gXvhBbp26Ohs=", "G1iBR0pGec3nmktjJJ0fmNi0F/EWFZn2clRx9YIBkVY=", "LFceCzXMpM9MpxIcneDExar8f6b3VJjo7FeSj7HGfWQ=", "JjfZoDuiCmzX7ZmmnDim1wt50FkE43ydv0arLJBYN3A=", "HN5+tKaFpS7NJpFpRm6qiXyng0AYYOuitgJuUT1tOT4=", "BPgXy9/URTka5IL+ckhWegyLghNjWNI51O8YDd4vSJ0=", "Damc5iYmdhGPUfhjCdUojrZclf3a3kFwRkA7/bsIfX4=", "JQX743wxCaTR0yG3IHChUmJf87D7dsqSXlqiwFiHmto=", "J4MAcETy0S5dswc17ayEYUzbGxn2mQHg9gHvs9RM1bk=", "HhRert+GscXKvmIt9M/92BVebbiR/0mP8LiH9M6rEk0=", "i9aQrz7ni20hLPGEuWnzES1FzOtzhViWI4IiekNFQA==", "BaVGLnZKT0eAElJHy2vvqrfk3A0m4tdfRAh6+fYYe0o=", "EslyFAeD14iWY8PJ2lzEPNGpdARx3peQimLMIdQ+bn0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FhCb+fDu14xya8vefeQMrdEjQ0YLBLqTpS2WkgH5f3o=", "HoX0TAwnHvi5qaKePMc7O3gsYNTtfMdiTWrq/45JIDA=", "Cd647MO7LN7bqWq1vYCxXUq8xJtlKOhMHtaXH7Ouy4Y=", "B+vM/w6Xuf/LxqKyVr+IhznA2wW8XZjZ5ZG+pNdLXHw=", "ISTkpCn6mT0y9kH+vsCyW5clNCh592r99Onv92COuBw=", "H0IX6iX6/SpiqnCe9yNlxw1mpL1NdW6td2tAUhsp520=", "EP3dxflo8yu365VVwN1ERidx9XQkp2HNiEzQwVKjX+Q=", "IBwPVVEwXOn+JfJlJuQJwJaMgLngZVU4A6o4va/wGC8=", "Ac/qtQxWiz3VwlK3y74oZ4k5Ix0Sh1gP9iItMIIRkf8=", "K0xgu4nxqxvuIfRc843oM1ouhbUT/jqWJO6qG/YlV2U=", "KF3GBYuA0Ygp7kYyKs9R1ELsYawzGvQP+rbNMKB93Ys=", "E7m9fSzDNNL2DWJJ7ofQXjVv0YKDDTs+n0NcYkD0dgM=", "D+pwf0SInuR+jZhZxSP5nEMgg9hf3WqMdeG7V3HBCCU=", "CAmncDbc+57LZ3/+Tgnuf6sVesKDMKveYa+CRyXZ508=", "FSuxp3Oyf4JAbv2w4VV8A6k5em2H1GH6by4G6p3U4gg=", "Kdp5sa+Lsf0drN28rHGsKN5fvmqqnjD0cazFMvX+kpA=", "JSQZVCv8rsxXczsCdR9RQoNOk/RWDXuVuFrWQjBzvg==", "yd3YrtnpB8J/zDYQZ/G2wQTCsKVT5tYFPS+C/Yzxzw==", "IxG/d11CniuYLKeMAVz7CoY/5HU2JcS2PK+OTONuN+A=", "KnJUfo1btB8GIwctQZvPOdCOWup4G3NY6VdXoGZNSyM=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "E+5PFfO0JaoX2hf2sfXQDPCUVKlRWuXHGaLS3PtBES0=", "GQ2spudSddNt1lw3LTAtaYsaA3V8C0x2ieWbwaAWn2E=", "CZSsDhmfBERuGYh9aupQpOlBcv4pgYv2A1TpK6PsbTc=", "GdNevPNPbXLSzHOKlo/yrO5y9aVM/t5RBIIHb65VxFA=", "E7Oc6ZawZL2piA9abuFnfXMYUe2ciV8ZrdVZAlwN7Lk=", "1TAoA3AQhCwChV7Y0xQxZmIdhwGZ3NBry5cNMLittw==", "Jqv4TMy3nascFDwSzXQTIMmBEZkymsGxPCQPM8sKFHY=", "L5TQdaOIYrVhVeW9GP7wnikmfA/gMlmvISKr2TUFQgk=", "HQc+k5ihUouB0qFLr5fOMIE0CwPCLs4oQIzShMJ1KzI=", "Hb67+utC19cn9z+T7AZEJkzRigGA7EHbClWPO0Qwq9I=", "L6wznCT+h+N2OuKd1tNBrKE1lHkvbUjGb64xtGQjT74=", "CJ270E0xWinKTEq2nNBB6z+EhKH0pyYTneAQNATgc7A=", "B7m9V18qttLlemESuEwC/TjiWYd5S2VIf0l10JhXjuA=", "JlY9OtgjhLDDvarxdww81aBIc7I5/gbcIZAP/soDRsU=", "JNVSMqjkWORzjBY/gas2N3RZXHt5cihH49Y0HhZQyAs=", "FfamvkD3Q1LK9ejA0nyKltIz8413h1bdiwlUZBakKnU=", "AuGVqsH5i7b9iUtsjHjQM52K2LSPZ1MEbrQ4iXymfPo=", "JAxxTyNG3w4KhL/oW29iSxd+L76EslPMTdZ8hPsw5XQ=", "Ffjl6BxXHkLQujaP9ZrTdcLeZVWLYcY9CBF7yV3goTM=", "C8BHL4IDdV7qX0pUxCAik+cs7c4vnml87zKbSi5PNl8=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DI2aOnv8f1MoTT8thJMRCXnSxY+jULN1crqOy4fq8L8=", "KkMQRKi4D4R9CZr6jB5y1/IYlPOUawEmZVcg+KbHeFc=", "EYGheR/SQ56mcHiBllJHjWdnFUx6nQSRg3PMBy1Tri4=", "DwzPsAghdCb5LMXf7HZGMNCGHG/5viRZsicmZ0Gn3no=", "BB91W0r6b/Ez6ORvyCbJs+cLRdt+237irFAOR+mESp8=", "F1GjdDnpEkVU7LkuMAbYxWDWEJuYVwgAwu3FkAFrVwk=", "Kr9+c5DekptcfSn3Xlw0G+hGea6/XN8hzilcrliBhlo=", "Fz0aS9R60xDBIn6NJsjHrAAyWOyYy5nE9doQwv7Qvpk=", "II0060rHj5NO4CNICktV7bJuBE2aRgCIBBE7iz6m4jc=", "ElYW0AGhj4BVCXDQEOVxkbE1dMj3N+TIK0e+axmE+mI=", "BnFwPrWSIoJ0KxlPPC1JSEDocuYPpud8ZvwDhoxxq/o=", "DjNUVf2wyTtwohrn6mBjhIEHFknWu3Y0NlFmemIF7YM=", "6DuA1cd08sTiqMf33OphwLDwAMe83Ka66Hga7cJRPQ==", "BYxXz+xOt76B7qUa3a+xNbibLFoRG8pZf1IS7thUfaU=", "Cx8nq30IF+o/lJF5/BNbYJOMjCC7nMDOwgsbyMX618E=", "CuXenZuHPMQhGx/Z+y4HF85GBy2l99hhBWDJWCt/Bu4=", "BOUV9Ko5oKhmfPBqv/BNh+vvTYXcMs5kqAvpBzuOAWM=", "GfbGyGuiC+yHJf76XucM0LG7iLmyCEeSfpY+zG9G03Y=", "C5evgOZdWhKpF4NR/kfzxnQbGECO8QjNc6VqeF9lf+I=", "EQAe30tXhZF/tLo/HLB+RvjwOO3V66nGV9w5s/aiVME=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "H1fpH4GMtuwuqJpMUkjiHbStI4wR4oJEVSJMMWxt5Eg=", "C8vJKVKe6rL0ABI18Nx4bnkq8mQcDbl9uxeAqmEaxR4=", "L/7CpDy2FsIgr0vvEmWjaMRrDRwEnnnUib1i5GFmkGE=", "GM+jm6q9Oh81LR/yVxQR42/wxyonlqQOn8IjjYnZk4M=", "Jthu7aRmN4KF6T1GjDaGq19kmkDtRqUsKcK5rtQTkc8=", "ISC65IvE0LAZES5I89rvWzi5mRKFw9A+FQoh/AOCbek=", "KHKrHa0O6+gQJ5lkZ7l2ezjsbfvvtD2VN9DO/0sNgDI=", "DK3Qu7FbEKKjtZds7WIWhuGQaR3c8pEabXkRqs4O5zE=", "AS+DrDWy6XH2jzdeI5woy/yAEPLSCmCf+kvzyoB4hw0=", "JHtY6dQT47lkf3IEsUH7FZnuoV1QVSC0fWHBGuprHqo=", "AT5LUxD6+1YjWGMxaeF+NDGoIeMBoXjDMnn1SFKQ3mk=", "HaVOOPWQsYryRxOicFc+LBLitWmw6QmS64gxIRcmk3M=", "KLhaYGIettfUYz8YD1FbrAdXozd9/WgYG/amWpWZEh0=", "GhUkENeG3FCzKveUzqm3/Lf6SCMdU2s8GNvMdQlgYDY=", "CSaZ3u0pK/7rcYx2uZdTilnnrFSDQoMtr9ZGN+c48aA=", "B3S/NjcQMHP+cHyqLTItmpBE5L2S2BweC6VkZ8WRpIc=", "Gi8WRAsAjD9CFUEj7lwMDwbsqEeV2bEExDhXv1KM95s=", "FJodUMLCF6Bo3S684ZBxctWP0KMSPev4SdE9hzZIqLw=", "JGCGBS0c6GdeA7CXAprf7ZqXyPZ/YG1wk/bkEqe0u40=", "DiqExOmqGb59o+XU3XSkldMINp5LJqFl2rnEI46vpO0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "pi3JhjrX5F7393QxrNMy/DAoD2XvHO2kzN6mOzzu0w==", "GyRGu/9ntAk8BKbz6QQHWnlsXiilpuWG1kQHU7qXVRw=", "FluE9RCRAJw4nqvNf7vJkplv4y2fhDU1Q2jh5bHc1Zo=", "DBk6AMPn6ONT0Eda+tvjafml0XFpoWnsGXl3YZE27/M=", "IIhHPCtqauM8hX+U8vErkNf17gVp2W2AH6i4cZT8RZU=", "CHh9LOvKusCG6efh+vwhbj+P5TNb1GQt/RcIqCpTces=", "ERkXZ5R6Dk+cP3gtGr1VYktV/3CH80R4zgp6p7JxXMQ=", "LSih2Bjo6x7/9gqq/5SDZ5zV13pwFojdU996nfVn9eE=", "Av6BP6sQEdx0+KGOWwOd03PwBwqx3U/RJnGKCHyyuPk=", "Fw5uP80Qwn0BL4RMIa9oUChOaxn9XR/oJYhh2dskkTY=", "EH1oFsHj256ovcSF/bzH8T5hNOgH1+TWhsWHtLAhdA==", "GXWK8Ng8lQVJO1QZwX5sTdfy/zOOYOlgklnc8V8zy5Y=", "CURi8yTs6T7d2XZPd9NC4kgSG38d7ePxSVcanZiQun4=", "hghrNvzbOHxt+i/znEkQ/Qry+z7N7flXNQ4grTyEOg==", "Ljz678Ybi0gAFY/t5ICM7dnXy1sigMmxWQ4EKag7PbA=", "CCjN6oP5f79y29r61z8JVLiEnwmn8Sw7rmmJAS+Nn8A=", "BGLYf8LIGFmBptXvxuMWVLJpahxCrmC5ntpSP9jBPsc=", "6CJPJoQYEE3pp19r2RXShh6OdKdAVzGd7DEs+L5N/A==", "CJFjIzrZeflIdvd8lxenzDFxQlobSE0QUPdVDjHFtCo=", "E/T9bYq8r8LVd5fCUqv2MZ8tISLdcbFb7G3elUT2BEg=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "LNJo6BEA1yxETWJG+AA+u8CMG1tYUKUI8WJUHkOATDE=", "DezpLjRY59bj7QP0TFe2pZfyoIUWYuUfMMfjRas/xE4=", "J4LFb0h5TiJakf/slNQn+8d1cEpX4kyToQkrAD/7uhI=", "DeoGLisH98avulionk9GyVhrb/mryl1Z7YV/W2XmGPI=", "BT90leSxJ1sVs/nNdaog+fdpM2PUMRdkp3LylWr2+sU=", "LYIj3TJpTFTLynEjWXC49w8adCi9c4ZGymqGL0b2Te0=", "Iw03cN5JYHMu0RFEkyh7y6WoshkwjxW989ZqsDA4ReM=", "Cgi3hvPeuwI8WsfyhAKu7Uc9g89zRcxOP/MZ73EMjpI=", "Gr7Ddow/D7Cfs/d/EqcGg6AKo536m7HfjsZ4040vWao=", "KFdZ9alEJ93PFGJFSEKp0flTo9L37ASIRv140BoEk+I=", "K08NaShOKFG14582m8mLVNWJwIxIf4yJ0esMhzzEvl0=", "BEfb92Ap42+i6qYKYjXlRi3s7+ROVYJGkQyPbVewCHU=", "J1QV7CFiF3Oap2cVOxGugMa4tcVccPK5ccQevo4ravU=", "Gnr9PzMTfp/cs9woyttKLcY07GgDPEEh8uVeH61H0Z8=", "Daiwvw8Bl6MR7PinDBfWtziC+j02opZlgxYaP3Z6XNw=", "LcEap/w1KI9MUOrTvsfMDnW55S6KP922FJK6lJSNWto=", "GV90R73r+jG9i7Q92NHmh1xcE1sVw7TWCdUjRVWdcbU=", "D7Fy5nCd84McqGMphu99hXRROaUaRcFpyDDE5pG0Uao=", "CIBRrPL0x7pnM2EgH/Fjngb6N2sqZQWh5iA4kGoxzJU=", "GeVyKKgZjljLW8zKkMY9FeB6Dz5tXRMNlz2xqDGvC6s=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "IuVmanWHQ8Qv2zCW7Hp+QmatdIJLa+NhlDXRcvQ44tQ=", "E+pg51lHZsrffkqh+fAF+dngYXdFbLSkPZGbRThJKgY=", "D/Hu6yRu1QjZbblz4sULEm+lW8cJSFSsunZldMCImns=", "Cv/cU0KhLTH4eMBF52eWrQG9GaMTsIy+YHHJ+gbTcXg=", "ApGXOmDgPZ4Ij5HPLg1dS4FLLYS7l67HmTF15dbcUZ8=", "EXObjuMEDigvbVA5eE9rdJw6TWvv4OxidicNok+Hcr4=", "DnTneM47KKGs+CTebQibJ25TURfFXDYd6/CkBXPGfrM=", "GlJ8xy2xCYhw74RUP6YwwgemCU33PKymLEfr/hLE2r4=", "EvcBYU9TkcxyJRw44ROR6aotFwPEfoSgQatHHtd0UKQ=", "EZNjNtVFJ6kpmu2fUmNbilP5qVhZgzbJhIVkuGUWzrQ=", "JyMY2oc2Xp/WJJ7HYVlhsTiuDHo2tRde9UZYmMcRvgQ=", "I2sUTPQpmSg9WVAeRv5OodYAA1mbQEbXpgNz8GiAk64=", "GiOVaeWIi6n/fJCkrrUFZZQV2m7808EB55EigUmzW2E=", "Hp6RzH9VTcI26E8WfiuuzvWiZ2kpa3OpRkjUVAKMzzQ=", "FIr1tGhi6oJpSRBnqWqj5x9CT+G+6CDNmI/YsZUnu1s=", "JHcqYGQX2Xis8m1GdWZls8QU3ON+53nJHpikyvgDtuU=", "HtgUAHP7UkTLqENCsnJ+glgQjftj0dqoJPQzCTKn8pI=", "EJtFtXVyiCs95XxtBD6Ud6zDQSMSR6rfUSz++0YVkkQ=", "ElY4NtLC/m0HeoF4aADbvI6Q11iloyP1Sfm41SO2MLA=", "AboAqoC0nnC9KzdIlozm0Z6dP9rgvbwQzFDpDd4J3+A=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DyQpfCq+ZUcbB0bQhdOU3gkZk27Ed4dtMvRHB/4L95k=", "IOsLKYxIRQx/YTvxDgS90i7TEVdW+iFzGu3D/758uic=", "F2SC+dq4DLXE2R9wdXXyorVS/O08O5alvzf5uA/Mn2Q=", "H3mRVZHPpmSCAaKNiTVcvGh14w942Woyw/EIuzqNWnY=", "KWHM51ef+fnw6GegLPqLsudAHKzuJPVVbp0vzl0M7I8=", "KkEXjl1qBKehRjyheZ3Rump7XEeCCX5YV5P5h0hVWbQ=", "DsSuIhlZTsIvZIvB/UK4JnPEfZW/SOnv3Dng2pQG6uE=", "JheUqQKWBcKkqtVGMEfQy5b52iXzsY85EEfmhFGabgU=", "Liv2sYh4uDNeQDSef0deLIXMJ5+Z92wLtxfQ/3hm5eQ=", "AVPKMJ3yTJ5mQCXmntzDY8ozzBqaK+9ptE9geDAZUjU=", "LbEviFq+ZK9Eo+4/hHi5LMcf2RsJbWUJm+IO+HxkYow=", "HyxbTEm/i+fn1Nn4Phjm/wxwzpE/LiRuZQJM4y4LIx8=", "CRgIdoE3QqI7k3bQFXnvV8H7OaYOglMg+g6sqJUxUuM=", "Ld9jUViu9Zx9im3idLNOt6XQCIp/xLD39M5pmhjnOl8=", "B385ZeQtnxlRzJUoxKELCZv0n06wDlTTia8ZmopHQSU=", "I7VSNwY2GGBxFS2Ajc9VknuVQiUpu+mQDRoSRFMu+io=", "ELQJl+hsW+O2SVnoS2/5XcOv1316j3CLqB1kkHXHTr0=", "GefHbBseZ/hgcxh7T3MOF7q1m/H6WgA2W+LzVBmDYz0=", "HBs8oxtRebbcue46uIOtVqNVgQh3wFjWTjRYFes2X5E=", "B1r729LasgZEBpCf52YHL1MrzP+pWXCL1ThjtT8TI8E=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "LWvV9ECwUsNuGJauAJBLWEZhZmkS4UtadpF/KkAjqXU=", "CfrcqQJ2LhubLqgyVMFCLD/bmatHAUm5HYGPdMFmRIs=", "H8LvdVbmshfybEzosEm4V/ppt/Iq6WZdj+Bh5XzNhrg=", "J34KXV3zfyJykDhmoPEEcuPk1hUFtIJ53Xj55esY3G0=", "GSY5P4nRQrgxtalGOuOGC7CIlz7l7pAI8OHHllx5vic=", "ApF/XqAYM0wPBcB7r4yEbTVOOUX71n1aItBYp5MnWjU=", "DxgW/Pd2QxhcvNfwsUEAdnCgJ8wokSgABvTg+29wARM=", "5e3dJ0a3NFVjIDo6Aro/O+XJ3m+j1oGcHcjBDKYZYg==", "L8D/0fL7nlJel6+4jFwfFjabeGT4Raki9Wr2tWersSc=", "E6bVB8843Xq4TE/lX8N8zADlT/kRT7fdoTGq+vXj2LQ=", "IJ4x65lLEiSUnvckYJp1RiSxLj6WqqQmUZNp1ynX8NY=", "KblcTgmY4Bf5pu+jKemX11DDFacJGZVUMQi78u+S6l8=", "JzAX9l1UqKGekzooUP4zvNxWJF/GbdQL0W0ZYwZaghU=", "CaAKe7TTxB0xRz0MlxlNkKlKQ0iu2AiuLZto1mrG2jQ=", "BY8361Sg0XStiBAJoW4DOwQTNQBSRFFiUI8uPx+9E6g=", "KZHVarVb7UeU14++i6LYTgQCtwTGPou0d4FblMC25ys=", "LPmsl/IIy+I9XarffOjq8XuUnqBpQgLW07T2gCwgyPE=", "Ky/8itUsonQpl9P7E+E6vLfET/6hR3Y2K2vZ4cWq0Yw=", "A/eKmmWqP14wzhuid5rDxfJ1q3eWGBndAWOKQtFP6lc=", "KKnUDpxYWSdC3nmHyKzcf6XmIvXodQiTbFyQ5aKwER0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "Lalx7c5ZUeF1sgIx4srs3WcgVN8KgavOrIcYL5vyqzk=", "BIUrcqdvz8qDMs8vylNCbUSoECWwScb+VhhtprWSuO0=", "EmeM0N0QPb8AwIPD1WOqqm5uOelAyAwUV16lP32pNxQ=", "BjvoER3AYbex+Cfrp8xeEHA4Q7aHjPhRYLHYw3+M8go=", "EpLRSJ5AsrepakeImowIybtiupLC+2yikNMCaCi5Cjg=", "Exko+Mf2spKvIX5qN5i7PDdA/nRMl1T3HpZOc5+oTHw=", "Cd0JwILm72EkK66UED00E9jigMPYJPVmthkdhsPlLn8=", "E6m39lD767HDDGOIZgXP5l+xMES79Y9rbW1HVKiAPZo=", "J45kb2LNFbZx6rL+tLEIM2Bqc3AjxQNW28xoAsR+Iug=", "BjoEisqrpEuHY5o9JG979XIbLf7zvGOH65p6F1O8ntw=", "GRN9jHwFtDgMVCe6NYlQWimSetcBKTNBp5f438a2Tqo=", "BGBaqyy/HI2zHzUwUYsbBY6Kn91SOA1DZef6+Zq4ZDE=", "GmYnJcBVcNDLDODjy4P1qaDWQdf3tfA5Wzy68n7o56E=", "LwBwHkASE2V0CE/Nz9uKA9Q3Aye2d499vghGijoiHTw=", "DutDvuDOEXBVT1NlkBzGaq1hTH20TufZMxFOVq4TZF8=", "BRS9WN91LaOkPddRR4BJVvgz5hCRwz6LbrwFnRZow7A=", "LlAaHLZ3V1ZKJ6kwQVSXrWcfYYmaNyBuS9T3BSXawkg=", "FtR3RUq61Ks24Vo4Xf652Oy71kWkWb79VERWutbejm0=", "A8BSESljtBElWsn0k3ukFi3PTcVv37XxH1haL5c9HOs=", "Etv6ix8iyiszOLhbGhzXX/VXy7GL8iAxKxipGiTVXYE=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EIGFSKtz/QPSbuQOGkBvKU39jIBeIfhonxAB0dOAjhY=", "JKNeTrjfSTEtn+/IiH5S/pC4NsDP9/fAeoSKFLAfy+g=", "Lg8efSHS0E/OQMZ8N0YzAEO3FowWZQpPLJ28F+ru754=", "AjCvPMLHzp7bIXn4YVropi5FjrE8JG+bZzFw8UZt+hc=", "ETRpL18flB8oXMSTw/IycGXEUq0yz3FUhtzr/C024AA=", "Cp03ztDVJcnYV3uWmXUifL/vZeOJ2QLmxKrdATIuiuQ=", "HbLitc0CiLHXx/rwA753A7XF5F7VzXfA9Hu40/JwOv0=", "EtYpxf4KOUMIPJbj5TKJe7L2PbVRkSIVm2FyNBCtqA==", "BU2n3rqffy8uIYBygEKpNWdKhEaATDzEfJ0VF46NZmY=", "Kfx6stPVRPJTVKmJhIEm4j1g78Z9MMHX5t7E8ByL1So=", "FNycNWXE0kZgeSMUa2VKBsOm8z/y57KFzDOefgRbEPM=", "JX9ZTQR6cg8e965W7lzr6mKsIjlxWlWx/8s5SvCawLA=", "EgLtSjVjFuVxD58aVyewg8GrIXBQ6Lvn2V/1+CbHdmk=", "Aw/ivrSbiQAzu90Ie54mOt0SaWZXCIiRW0MQGIi4uWI=", "Bcoshsa4E8Wrfsx/pT+6/vNnjDKKzMSfpwtfcaHjaN0=", "IrOLUAybNg/CtKwWsPj+cejjCppf/7InX0ARLgHFn3E=", "AahaN2ozLk7UHFuehdvCgGuzw8bzjH8lH7ox60ktKBE=", "AwuN03KhVGs11DDHWSskp2LA50i4VxkKpHuilNpD+bw=", "BYgE0qovHp1RHLS/RFnYdHoArz+M76UsOvKB17caRo4=", "K+mHTBf0gRiXsILOR4CZkdV9CB3knU+SWbrAwru2nk0=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EBJ8UuofbSroyzp69wkWqyn9hfveXRVZYHbOMFJK3jc=", "LYh/OPT1wnixQrsJ+hchBxe8ON7cchMnw0ta8l+kl18=", "AYQT3ZnlR81hEsmziQpKknZgFTlnovo8x4KBqjdDt8o=", "LIN1v3BegRrqhYO5D2AEyhhvBrqQBdks885zF7T77qQ=", "JmchUu7hOfkz6jqIjjQ6IRd2qmmCBqa5cM3kcK1RDnI=", "F5Ryhx0m8uJ4Zz30V2n0nzlD+Ytbyedrx71jn1y5Sj8=", "HtD0qHAibIr65bJxnjqmDIpPP0kSkOy2pvqO2P7DLw8=", "Hoq3xRWJhP1Tah/LpS5KmpnSQGxoHQ1UwZShN4que/c=", "BuUECbDMdjiJ2u7HYkvnJ9zgljL+F5RTKfu7unM2tWw=", "Be+WBmoRBngr15Qq9u6IrmxkKJCGPe1ckIpw8OlxiPc=", "AnWjk8ecLpdeMgiPoo6Ajvezoo7VXXkIszBMYnC2hHQ=", "Iy9BrJ+1WCitifuRD9U6gEY60WrXh+KGnzFaWc53ZtY=", "AnW7jkkekCPamIhME7c4kvKx6y533R3ai1CVv1ya3Js=", "B2GzhoB2aO7ishtV/8d+rJHGCBxSMIxtuvxsBwKLTjo=", "BJPpo7gNF5Io0qgekDqf6NZa0t2ZpzPo/+BE7HGmaPQ=", "MEQT68WfCMgqniNW6gk0GRD/dJOHCfA1maTwUk7HGag=", "LR4fOPZwK4RwGd1pdDe5C7swL2Qv4Ncd9/rO0KPa0Uw=", "FqyEkHa8acUlKdS6ocINOZkdHRvcksjg/xxbytN08ls=", "GoXsZ2LWy+FG3IfNEcKy2qHqWZ9hGWWlm8/DNVpoQxg=", "GWUwlF09ezXJUBdNCwik5COo6ivLHUVfS14ELWbPLKA=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "BwUgkTYPWYXNcXwYjuSqexJULx/z2tChmWsA/ebjZSs=", "KRtYYM28Q7Dw49JYvfj4tYyDmlZ3m6tfkY4EIpO5ho4=", "DXTTtFf3EmegBnn1s0tXzRk2Juad/4JxU8sKByRfl6U=", "BgY9UsZXEvjqevezQFwzDzoOHkoWUswh09xeD2DNv3Y=", "BmsKMQPggfkSXEKWQNLbWZMDcYATHtIr3UE9M9aoMOk=", "AaHsOrjH5zvuUlfAZpy55ZWO7T1R1ri7GkPyaD4ggqQ=", "Jbzd+32KChkdMP0TJfceCBJK1LCZSF2A9BrGd+AJQVI=", "EENoVQeDk+NBhqJpNhgbOF4fS6vM7PiLGJpRsFLWkxs=", "E/0oksAvUeQtNtnWmGp3Pxz2RLy8ynQxjEhuGxiHqNA=", "LCj2uGRv4HGk1u6qvCL0OY0JrcBB2lA/peE9VfKAQko=", "CCg5acV7AVjNW/DdnuO/HWAI3MRcHvMojefRviQjgy8=", "ETCtF+MAC+pwiqLqkpP6obszyfpzTBOtNR8ECcZJymU=", "B0HFx9NvEc3ITsWNnm10KPjPLRURDsRdchj3mRvlggY=", "H0SabXr+yHwzkdXzBvyqW6dJj+rlRMYEjb3IR8fa084=", "E8IOPivBL8DT72uoaTEfvFtqOk13na/tNalgmOl/IWc=", "H9q8I/qG8bEuhAxJGn17wme9zPbrETcp5B8J60FsDZA=", "Cxir2sUZvpa6412JjUCibp2eBWH2k0vojamlwk5JhlI=", "KLaBD/+27VbLCrPfSbvu589Pl4RhGJ8gWux0HL6EMgI=", "C+yC2QNwSMgFopOnCEJ/v7ld6hF6bc0ebzTxP8ngiPg=", "L2OkGumhLaKG3pLo59ZRYu7z4nXu2gGy8d3kpraYJt4=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "JlxPxY2XYy/PGakjoGZ7npsot63WEtenEGG8k6jbDTQ=", "Eohb/0i2KY8QtyK2mepc/v0jQAXIP/eKFtpWOpV1jXA=", "FR1TzGu+2llMg58Ziv31QZ0ch8psReI7S135zmWQ+iQ=", "FNVa8EXx39j0nU8lbggaaz7Qk/Aacunn+pWWTSdLmQ4=", "DS6r2G8B+mS6BluO0m+Czi/Efp4BZEjj1yenxmp6vdY=", "AoswYMLctle/CtTgFVUvbAV9CNlOanqo9lzK9XauGck=", "KZmWheXJahuQX4XcW9WF0BhGjFLq93plpqf3JS0BUAY=", "LMNlZtU3L3alvdT61j5wmxyaH9jGONUI0ROGqWOUnRc=", "D0Xhpl1WMxOYHX+9hkbotsClE+kh+k2R0G0d7xrFNfs=", "C+Wkf99fXrsFdgM1wZZQk008n9W/apR9Iw7AewS2M2E=", "COBsV58ebgEwyAG5PjJcy6RIgifVInm2AM6gPAL1WEE=", "L1D3AAxFzZQa7b/nOwAiqV75SOFnLl5K5/gYxa96XaA=", "EOg/Ps3j1bq7eFMopwytfxJmraOBGBKWHN1WGFV5IQA=", "I5GxpC0a1idl5R69P8rsn+2ibrGo5Lw5e0p2kuUDY1Q=", "Bd0oH0U28OUSz2Mtj8O8OxmPzVAxciWazQpD9vOyyo0=", "GAXIcMnqokbpP+B7beYAswDrHSzHaKu4oyXRs1pzo4M=", "BzWzy1MJpjR3sXZi1w6HOliOguFbwIP8qS87EnLeWTA=", "Faewj/v61w2iBQ4sYJYhzCgX6fqz+OBvD303WZ83QDk=", "HHclqF5qfw66rIdAizjl5uz7TeY6sYGQCJJqfR7ZFis=", "I3G1dvZ6uALmRykNwMoHKL8R+igqEG5SVn5DCqXNbfk=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "LXYiLm8LoP/YZnyc+yqL8v/MyS50zeOq+dUV9ncL4ls=", "IanfAw/Cw4YjlJzMDifaXAIiXi5MuUJYdn5nBGscmtc=", "yZSuOHRh0McQQYbB9OFA8iSgyFkEkKXSi/hyWW6uLQ==", "J8Yf809yHZuGJQ/fekM1Bbj6cuvpoowPj5pahuJb1kI=", "EVqnqua5WW7Kl7ZyamMXItrgqPYwozaGBNvKqYEahR8=", "GM52DnAa7PdmQA08gwPiiqeTfDyJwxCaXwuPkglyn6o=", "Lo0nRlyWkCU4kZhohyYYJhsH4ncfCH6WhqB7AnRKAUk=", "EAZh6292ObPN3KBkabcXNpuEJI8YqaAlAZgijYWA3hQ=", "u6lHXdRJhoxn1Nc5TtRI6q/QOE9BerXsNYLbiWLkIw==", "LsTOouwjP4K1w6/GWM8PHVBW3+Q0wgnuPTrlEBxdOKk=", "Famd9+a17wMV2wRZMteiTeYDsLaJf1Z2Jv0d2fR8hVM=", "G+bYZnlLJfCtdyJgKBg7OLpPr/5aQ3XUslYDBqzePF8=", "JyV+lLLpXoYbcSDtl2LYxMlAgLdhLZtY0AaR++75c3Q=", "A69R8wDNb8tOpWfmyFE9gdrZSqHQwSWoQIzfHtnxA+I=", "GTsctevXjb4EKMmT3e/T3yQUxVgHj3V7P4A1sEcJCRM=", "DchsocPBCmNNuleRFXlAFzZtBjFbZ9hDgfTj1TCADlI=", "EjVAQjmhvTXYpdfkH795ebwRMuExYjb85HBJUZkEh+Q=", "F+ll+jhRRfLXlwRVeTiJMIndapQR4aQFRhS7oPFFO0U=", "F89u+GPfwn2eI3Z8gCGaYieafB35VTyMP7o02NgHBvc=", "VoyGRX1mv5YmE8z88pTivf3EREBrIKZWPrOCFk9rOA==", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "L1E5UmdGaYh5UV3FR/xKGKR7t7EGnPQtiMFpnze/cOI=", "Dp7GReY6M1gVjKa8mbNUVwxhtQrgtmqbLNvVt70lKPY=", "EQv1X5aea+uBSgi+38xCk2j4plMX2d+Yf99pBGToJ5I=", "BQovQPMzexRmOHelxcZruta9QIEDA/yQd5ljhPuUIiM=", "CfomHPUVDa6QJweZEh5WdFwuOv9sbt6w2fN61z8ukrc=", "GNsP2h9IpDwVwdcteo6OwgQs7txX8IzeeEhPigF1r+A=", "Es0VLmpIKyJnjhT+sdK0Y1YOs5sKJ72C3JzGeRxw4jQ=", "IIeFqOfQH1VriD0gGkMHHJIoY6u2tbnWKwbNvhyhmMs=", "Ci9vJ3czH/Yts5GHMd+w+JgePxWwcVpEo+B2q/HilxA=", "LkD2CpVdhxflW5f/FWqL2cby6AbQQtAhPO7yNW/Jf3Q=", "Fbgk7CgmndTY5qVjFp1BXK1o2cHHruGqJ5t2q+087m8=", "DLg8GRfkH2GjICTRG22PQ8ip6VR1aLgX6nKzrCU+2+Q=", "ExxsOuNTXxW7eRulwfUgUWNcRNjhPnwo1ggSp2PPYvo=", "J03laeICVnhKyjpd3KUiJHaywG5pduS1MyV463RLoFg=", "BM1tKTBh5FzfPzB5aiTmYAegrv8bnHz3zIad2liajRQ=", "IEXqspA47iwomlZPEPoLpjd2eVFKOJuDbdaZi0eZoH0=", "IPEON7rlqBk625WwaYGw92I7rzK2m2GhFpbnqHlUlLs=", "H1XjatrFubNS18vlVlG2gMSzQsM1vYVi+0Wq3T6D5hk=", "KWArpwaNC3VNilmme1y4PeWm2GCS+LpdoylgrEI35CQ=", "FnB/yu6VPlSLnwTCK3FFB61Fxj4kLR84b+gTcB5Z0Yw=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "JkQ72DVpyTODzIzXouBesrzq1GIecMwYj2QFyJ53ino=", "BaNdDiK+D5vSUo61VYPO2HDTYu5yR26XBmJeSbxVZJg=", "ECHlZViDn8i1+yIF0seZ47MedlfPoxBrBlHKn26d71M=", "CkqhZbd3HAgQ6crwT9yNa0+ofiuIzAiro8jskIc5vic=", "C3Ec1txZHc8H9AD6vlzIt47AFyS7K55i0RRWtt41GXQ=", "DbT4mpc92yXxE6bfjoCqeYzSEHQ5ykw6fLR4fyMUjHI=", "JFgFYPod96Okkhh1GH7wytbblPC/c0j7eutMnjG9jdQ=", "Ad6MPkgth9GaM0jHhpg7pLrjqwCHDSiuPcGL28DIVh4=", "A17JpJKWsYTyIls9aN5tHVpiMjZXbYOOVXsVCJO+pmw=", "H38uQ4wGleIFf2KmYaqOhXk+wWjiqsHOBu9929rR4RU=", "Dbprp5CYMxtNyTUVd4skl8OMPdsrIObcnfbtWthcMrU=", "IvpdzVBwqPRq1jfjy/acJWr8arWNwLDZj/FXQKvuflk=", "JqX9k9/39etJlCtRsDuY6c0qsmHVbbdRavuJesJwbvk=", "Ihahp4fQW7zM4Z7/XYUrkuMXYG1VxrWz+wKv1B5pch4=", "IigEDCzGRX7LCs8+9Gmeq4BNAlG8dQJeqSjRbRUGWVM=", "HCDgLaCVVBq8ZIGlwVlM6qaI7Jm0P/zjiwmLqBevBHc=", "EG8ZFCQZqGojT0yLlMmtbztvTaueR/88nWZpvtX/N5U=", "EEx7mX9fg9jaNfqyNPVsSXFt9LCnMYva6ReGsKAH+Fc=", "JytlnnijPxVB/PWPTLPmToBvPNDiQ43OIKmrfUFqMIA=", "EkkYbr7fSfrIX3bQ4Qreh4UY2qMG0rWG4pWGhXahPqk=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FJCtjp0zDivqrVjLy6vadXlqbgAWa9e53jXITcoft+Q=", "Kc7azRC4ObV2+BQI26j/HNaZubCxHhblJnwhfldKVZ8=", "DVX14NMe2MAy8bMevAf8sIj+uohYPdWBX4VDHzgpzb0=", "IsLeeLj4yu43eNSCVxCwgIB80Uv7YIBIj5njA96pxOM=", "JWvyYqC5Mdh6/9gjPGFTTZ9fM6P/5ZRgyor30NO6lG8=", "Alnk9s/MekttIkYzNHnfBS7gR3ue6Pqn9H2kXRSV2Qk=", "I15xayK2eJSu9bytSUZ8fJ6Ptom/wD8FgXbJsvLPpt4=", "CRJGvuHV9AY6KrRT5ljFDJlNrmeM+hW3OxSw9IQI4Y0=", "FZRUHdOW1ZSLawFysxMwMz8JmXPYo6Gp0pm7pvRdG94=", "JMyVu2LuhawX0ejDbBXMUMjGbHyxLgjyqLhlZTzKWGs=", "LbqJLE+byAzfpA7pqpscN/DU6ngcP75ex+vaOeInLbo=", "Lz8lVCi0R+4oGZdVld3e75+jy9cbYvNK7oWUdx01Cic=", "L0uBkUtSt1xGtuvLUmBdBz+0WPixy/aPudsiXkkZuLg=", "HjWmWMthAxRZNjRHzeYWUjOyu1EHxtu0wtUMRZlA8qU=", "IZOL0XDvC2h3UrhxS4A7gqQ1i/crdCZaRiPVWU3ncu8=", "DVS8AbGNzyVTg0x6IzCsgWMIMYbXOGN2UK57u2fmnAE=", "Fm70I+qM6VSt7DghTIQSvLUt/CrzrUB8yU7fGH5Nglo=", "AwSyenSQug5cINOyc6vDGrV9TJw58pKLgazkCyauNFQ=", "GHPvNH/4IxWFoV3WHLcUCZi0oH0f/iBF3TaFlO3A8XE=", "Z6Rw4MR5XiRedcl8tpdFydm6txwbiDau/wG+iV82NA==", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "FBifeD8BedanAOQ7bzQSrxiSA+R7X2v/rMuw+qbPhQ0=", "EhvCWxakXBiEMDXoTqDwPlULhcXV2GXDkWCHZNj52j4=", "LncFsSVFXIiTnr/5yU2UsyzRmYjekDNCGtJJcpnhwH4=", "BN6SoJfLzQ7ah3yV59fGIyBagukmTUgJMUTAKv/jX0Y=", "BWJngn390sjhPDH/7gnGZWBebQ927PzmOho+D/m6CDo=", "IU4DAPgF/8cVZm22mjK13tbBpeRs4hJ471bfTPddbXw=", "Cj45Ya7T6NqE2bL+Ad41/rr9dCuoPAz82CxIFCzxxCo=", "LsaavVrLNnnCV8OBRSD1otThWp4e2kgOJXRMwxB00Sw=", "HGinlJkLeGbdkhtBeWASOZn1LxmPJ5SJ8A1dtxIFpq0=", "EYOPsj1fMyK77NsJ3X+LWBRlyHoPbbAhbiPJIxqqVYQ=", "BQiCAKGLbyfS0JSkL+wiR/mxmhei+F+YJ783L/SV4Rg=", "IKVi74LleDHuhd+wsYtxbmPeNrzi0o/gZ6HOEONlqMc=", "Dad+EDoYtDishg1JAwqVdW3GnAEY4Ge7o3MrOinY+po=", "LnEYGXbChEnjLgfWZwbKT9G2yrjaYbGOcS9YFr9+lNQ=", "EyGm+qCBXrg3CcX0vM8965HZGO4VJnr8awKdkjv/K14=", "J8PqiIswBoZ3JHSBiTyvUK2ZznMt1FSeL2UcPiZhh/w=", "BHFyxUdZ83srTWSsL7aubGQo7bBl1bfxhTlFFRFN6oE=", "GfqHWl6CGy+mwv/orPpEbd1NbyUzODdvoomyDoPeGRU=", "LbB4eNgQ3jDKB8Is7lMoDRYBhubifEw6C/iV/iwzSeA=", "CowrS5gxXZwAagpUmSR0rInlk1oTRpdkAN5H0RXKQ4k=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "DAmOFOC46o1RnnPfjaDvOCdlGOThA9imEBmT8hreaCg=", "JqerIuPUcBpNVCFrc+kG2j1mhZvuONAr6PEg4ACltPY=", "IRqEagtnRnSqBLM1WKfYBQr4gNE+Z2KHLUVg4/f1W3M=", "E1ld0ZwVkiDpP8i/hkXFua8lLtrNNDyJuumKOjcxTH0=", "DYOTdcCHdjJcJWEM0uXs+KlpFUwJeax/FPHlig5+BEE=", "ATazGQvF2JLL4XYrzs62i1AIYaf2tZDv1iviWtHHOys=", "CHZdIPpHcPpJeWMqbltQCXWxc+ynmwMAhW5xMPZleTA=", "A7LTXqCtJrFTVBOjj2kJVPIkpveIlrqklrjoUCvzQzE=", "ApBImBjgC5wOpdL86ZTKkla82XdenKW/2sgZcrRqS4I=", "JLfBuE7GJvWceVLECYEj5pDyIVBMaABq4eWBXq4uIzo=", "LSVvhFGWvsWzXFKmY+TPhN1DM0gVejyHeprQjUHaXWU=", "DRFQ8B1dfjCw+zpjYsYx9GZPbH9ikea4iVRP93gTE3Y=", "B5cXAB7WdEyuB6LkkaIzinnLjJV1U5LJhFnBKExw67U=", "LNIFi0SPdbw2inzdIPDGf3QgY2a9iIIjXaQE1wLSvmU=", "G3p2a6/0P6ilLiYIVCehvu3dgLcO3ZklR4GMYr0jQu8=", "DRB1fqE+aIpNmcv+ZG9CaMskmNLy/IvDUmlKr0T3GFU=", "H+J9FQaPhfOE9jr5g9ENHMuUFH2FYNRWFxw9dB1CfyI=", "LsZXFE8ITkj07rQFVDYG4j/iwbWB+/lC/D2mXYpiKOo=", "C3H/glL54cHTdzhUEDxI+jhXVj6LLek7eKVNHJKUZN0=", "GCuZqsI767RF/rJM9fSSBJfRxzWYUkjzF8Nu41w0MRU=", "Am26WK3ozaGI9J5S/OcWe48hnb2STXeGsPmPt5n++i4=", "EzL08igRIDAElrliljcg5ooHVZCqgDxcHNjT1YK7des=", "JMRken2xyGm9oDCj+BbqJ+jck5CUFv8g6vObpUV2tFI=", "D131XCv6x5WIjTquh1Gvy8PyxbwrLewoFIolLelylCY=", "I6StSFj9PCabHfWFjuid1lne53aold1az/sXxjK2ZZI=", "BSbtMtVn4ZD/Vijmtk12JEfK7ihLhPoVrck4SiSsF44=", "FE2J3RtgayfVHXQtAt7aNBpflueuXuOAJj96IwIM/V8=", "CAhuY5pflsifqvDsgDUT6caGR7yXePx3nRRJkbqwKbQ=", "JKLZur2vo/Qvh6s54mnC7dRYzIfp48ZtvosMzoHbn7U=", "H9Aw5dUMo4iFmxj6VhdSfPAGTZG+xcgd2lrTthGij94=", "IeXNaM2zXDAnQz9SXML9T0YBMsvoNQWCO7yxKxHrrYg=", "mBPIA/+Eo2lO7a9LHCFyYVJ13BjKZUx5mnBECUbM8A==", "IClz9/ulvSHtWL/nFW17KQENQQkPY/G7KQwdXaGtYA==", "EjBerfZNrCSnkTpi2Vrv1F9INVV2xnHlb96cx8g0T/0=", "JceDrWbWofxshHcL1jf2IHCX3/sDeNfgOV+MC4a1Bfk=", "Ii3rYG8TzyjHOmchbYixb1lY1dKSuhDvO8LBD1oLYT8=", "FhTQJUcncf2HCp6dQis1ccVJTn1nmCTY/hISF31fouw=", "ATWL3Wt6UbH1tdCU29juCGzNz7nCf6rQgG6O9xjQ4rE=", "HCAH66TRYphGu2lASsyEVl3l0kYg91z82fEf7us/N0g=", "IvSdckQHfkH0CcCzU6/RaW46oV/9tKC9uIP/56Gochc=", "GVFSOkJwxUQD3+Mhj9PUzO+kMRTxsZ+ywoIaQ3Rxi50="], ["LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "LlfukImtzFHy7H1fxCgh5n/fCi89Gt2HCCMAKh6f9Kk=", "I0bCJkkd3iHzi56xvowWCEd06d2UGJXrNiwr92MFDL4=", "LClPokZqCp8fibGvW6se07hqDqcwdwhUaEx1R1Dv3Mk=", "JRngc8Or6gL3eEzYyEHdzBDWVQfLToXo3zv4Wo5Bpwo=", "IeoL3SfguLcbkatGeYuQfuCUz6ykxorYH5wMEH56g6Q=", "DaI+p0zDJdOSJmXLoXh2pkPE9u1G+YE60PQDlVdX3YA=", "Ege+sYFJFI+29Q8QkLBd4y7F1Dj7MGBPTGPCN6jMHVU=", "HDV/eDo98/CeV/+5caffxQwRRdqfP2fzI7R0LvOtf4I=", "I0dHstmINe6LkPGbXqA8E7rrQQ8hIROD3bICSGCMWGI=", "CzjhHaNHMLx0t/Ot1Yd58uC8VXNJYqBZMG5LlQJ2cl0=", "AUcy4bzEUvufpA5ykQV1ZAtnS7X5A1OlI1amEz8my7k=", "GX1hF0Fd6IVeEQme1snE12Qz05/H9MyADVvron3HtA4=", "KzoxF0H4uU2CVdh4EGSe9mdMemx3Eag/+I8q2ffiPFM=", "Cv84wfVQCk7klJ5e7zODcheXebspyVFCs60Y76nmc+w=", "DdDEj/KSvHZOn9hIQZOWlKdhF4eDupk4HfV5zTOF2N0=", "ByOgU3I7bKtz5ys2civ8UslX+Mf+AyLXc0iVVXXoQb0=", "JcpQgfy8W12LgIYnrzyUlODvdCRfmqRUGdPEAN3ok/c=", "LfVS/xQjJSnIIWmW8Wv6uNVVWSPS5KU3Btpm9LsBOWk=", "CHb1braETdqb8wq1SMjws8QSfr5/wx4csn485iu5QLA=", "Co8Q0bNcqSaL9EA2NfdvG5rC457xtcnm2BdPS88JXfE=", "EhK4iFkrFrJzxVwJ6IcnChXv3vER+z8LurbzTEzCTYE=", "BfV3G9MOC1FgRm8yLswj8o5WOkSoCj34XrMLKm2laB8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Jr9/ztC76TjNZ0efovA+Z8uKd1iS6XL/StSTZVI3vY0=", "EKSbkTbupvLD/HnZRvi4/WSFTdw6lkxXRizhcmKtfZM=", "Bbx3K+2lcJpv0zs2JWgpJ2eNXX23KW9XA8zX5A4NjcM=", "Fdc6+ojm+xt0zfPql8aUzmlf05aV/ztyZjcdGHD2EMQ=", "IGVvaeSDxbBaLF4mruufMNF7AQVL5dACtMMSoy3zXa8=", "JilSbJnhPdGGKrjRJaNMxo2w87wpfZdARGaNrsnlZ94=", "AeIEu0c9x1vvXxf1+CjlIfZX2MWNsfTglvUEZYknVgk=", "Kk/Dx7VO680CPdCQfql9c878KVWlqDR7+1xBzbEPsc0=", "A3SwZD2YA3OhLXmOjOD54Bajs9nHHlbguXlTSqvDQQo=", "LVT0qCHNOob76qkUSD0Pojp8wEpr4he0FEtmiucHcMk=", "KfzyNKk0TMaoVB9tp7LsOwzfJWQIw2K9cgSNgI5yiT8=", "BCVMrKmdrz6zQDDnNAheshcfc0bKLp9Dro9hpO5Dw1g=", "K0yNswZcKX0It/HMyzKoSku+ZXwWqw2d7kv+WUZQMP8=", "EkiukI/XX+/EKxO+aFyt5rwQZoSuSkUTrUFQKTdK4C0=", "HL0RGvYiAcJCo486G9eSUBz9xQNccZYcKRmaSnFn7b8=", "LuuisxhkkD0BejA28RmFqDYcr3PU/bIVxVUtnkd6elI=", "DTLq7ZzVq6KaH4zwKdAi939esgEfvXuLz0Qt9wJhxyQ=", "IJcf8+J/+p3GCag55ZHWiNB9xjbSzHnOVwwuW3n2O2s=", "KovdS5se+WuuAImcpzfS4dykkXZ5rxxk9iZ30tYm4xQ=", "Js+wF02RKAvQW06VU8BEiG6LjIsww29DFu/3JoCOxjg=", "KfUQvletjopzWMBpe48tdh5+YjfIqi7kUtZFxPtfNUg=", "HBy/rN4cqYGuX5G0SpX0JSqs8IZjfuQx3IGonU22tBo=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "K3hWE29UXWnrrDxFlFHyiipTqqFEumeQI7IWGIfvElA=", "JQwEcmDlAWDNZYa88OpRgIIfxxw3iFZ0gaeOfIuVFLE=", "D7+C+KUphLnUFT3W54wFFjyNRyCRXBl2fL/M0MOXNIg=", "BrvJVULthdYBLSMrFtPQHeymYqD2G8wWS2VUsy5h8xs=", "KBhnFDkseJrljvcTQkitM6XxJHDkFnGKM1TzQFb7Ev8=", "BTr7pljadt6SCE9Cbai0wDMOdyW+lHqiZrjC+cDFXEo=", "GESHK4I1+FFyjGbgsp1cvxzQoK1epIhbLJlnUIllybE=", "CwnsWm2baDMfU8pf7UZEPG+t1S6k2cRkDeP8KUDA3rc=", "BjhSnbfMIYJ1HqISQXY9ENNMvAmcV4smA8sNDA/Nic8=", "BdBm3KzKwawESNQ2cfIIM/rgDBBt5/4oyYA9dxX+7mc=", "Bl2i83RhilDm+joBZBYLHmr0KnbpsYcRWzMNYKVIs68=", "LiAjgLj22QcFoTXEIGbxz7kFB30556AiMadAoyYsHgg=", "FFcMQKTn7xwJbp2PzApGy94y27V5FmlSBqsDqsLoLzc=", "LYfCRQgDKYIdokixdFb558EGzoqAPT0BWov7+VKJfE8=", "2oxvyBDKGJGTi0F94paGTzrxXCjWyx1Z4t4o69AQ/A==", "IBiZKDXgBQem8tl8coygWet2p/ylI3o26arZmmEmXMA=", "LZCZyXXrMvMfEPgHuuol3b/yBcYkpmpJZqpZvIqq5xg=", "KY3ud9trKeRDlSZIh2A9KHxFhQoYWCqKyb0J0pKII0Q=", "D8zLh/BIcLymOCJEtDoPf5LTNuO8TX593vSBYOLemJ8=", "EpewOq6blJ6aUYaXVhP/Wb6joFjTS6rRs8FRePGef/0=", "iToiLykHdAiAKqdNw3yDPfSAs1DrGuMesbn5sgs/Ag==", "ASMbGw2RvHaHw4E7LaMufHH8kYlkHqDbrxVW6tjzYYI=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Agd6YVWrNKsFd3ZR0BUeAyAAVzHch1mGJW4QMglgb7E=", "EaTzNHqp8I5ZhWACSH/pekrBbcuaeWLROaO4DKlSgJo=", "AUYBb4zhAPbNw3r9IvAKpTWdUxznF5ovxpH9ErAMEtM=", "JQRYcPnaj0yX4RglxSz0zkC8oScd3sTtAbd0/auDiGw=", "FWCUSH1GJs2X7Ou9y41B1+cPKKZzTdP8M4J2XqER/WM=", "JK3m3t7rkAEQ30+SvXkOvhUU1LJLyIBi1iSe7IWAVHE=", "Eq0mX4DYVaetzCq3trufSbUCh8vTbn2eQYYPxllnNK0=", "LxYjcgPRPGk/qm2i0xYrJdDRvolcgCbK/e7azsfXyDU=", "GGjxdm0+L5uxUrFacY7Lqyh/bZzS6bxeZkI7W7x25D0=", "Eo4wutJvEcO+mmiaENCTgitdK5IKG3jdzX3xqL/KXWA=", "LnLDsfa9Onk7J82AJTLSdo3rlmjvAEkKBxbpVDGrvF8=", "Cj6MB6WmNOqBXh9Xr+lJRRXaYj42OkCOUF4BRxxaK8Q=", "Glx6VKgf2TdiznnbbcYE8Dv1GdaDyycCg5Zi5pJxvW0=", "EyImdMlgPbSl5aNjmNJNd1Q6x5pKMdsTtIyaGZgEYDU=", "AzO374115h6fRP8RGC23AxFkint4rd/k8hRCkatZh6U=", "Ix7zpVQGYTJ5jlRFBbEdUBBsRAapN8lwLHveREV9T0c=", "MBZILM0f8o21XWUyQg6VudPGbRuP3O5bRf2UpK13CI4=", "KErLzY07fG5+f7JG+ps5gRwEWCDu5V5X5o16bLt/Fl0=", "F3USRMviD4FrdJC3NGuN2urBY1WIt2X8DnzDN1RpmdU=", "DjsnqBED3SMVF6ytbGnkH79IgjfQ++6PDWUuxyvwmiE=", "Cq7/y9AWsniR7IyAOEpzViEbmZalzJreuyRwCpdtcbc=", "EY9FI2yHUoPN5HjfO9TM3+1T0Ifs+NhdJL39x4tAGMo=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "LLSlKOuuy1zlBE5gmp7F82BXGFqIAi6DQNdM9IV5WV0=", "C0rrIgUyTPnJFHSzkJ+qggWazn1T9Ozm6RlxwR0hKt8=", "Auh5/xfzGqNmZtzUIwPUqtn1W8jVXdzXuMVO9G+8jmY=", "G/X2VV7e95uwlCGLCYDyfbV/lwm2OpyUsYVSvghaYsU=", "IKNom3CEDXVfv4jI++Mj+nx8Wq0OiSOhZTcFEVhfB+w=", "EKULQyhkiDv5Kl+3fmADUU9D/kpaHAcKky3YNA6u4vM=", "BhYqWML8clps1HRsjyKamflhbc/FQBSixB6Xuewespw=", "ChLl+7vWbw3g1JgQ6UgiBZH6R4q/zfoasPxf6GGyFAw=", "C4mczcETGxEnJEk68RY21kIdtRalno/H9ugkC9dYG/o=", "ElBsPuLRWwgqLPMRHpvKPSVaKqpI4W6vUTBGH12IIOA=", "ITVIFWb42XbWx3bGWUmEnn3Fowl9inVwJAIjVpNQOXo=", "AidgjhWHJ2rtS5K4xgLYH8MryVeCbixMg9joKkbYq2g=", "H0/F2NJ16SO9gvjy+sBPY7uk/JVYMmrJ7olfz2grFY0=", "Ad5bIdlC7cg9jHm/6mT1TmgRQzmbvPWNSzHIydZxNV8=", "DI2a6DgbfeiKwolEB8gVj+Cf7H43KkVIzA26TZKDrro=", "KObyTvIpolAWz6p+MAcwSVHnXKFOjq97Gcfh31gDODM=", "Fsk+lNXsH6ox2+KhBShtg5WI/RUX3KLgPWsB04GtuaQ=", "EsUfJkCjwFcm0IGX4B+r99XakWcdM+QOAPkkAnqySuc=", "G6kyTXfob/YjTbZtYYORK/4jUn4sBWdEIx2ZmC0c3ts=", "BmFue4tPNFlaRZG/rHQpZjuFLmJtILzm7ngFNnmH1no=", "ArKRsAqtqIYxHb2OkvpnZzoukGH4e0Oj1FcFFdvpZW8=", "AkvByXj89ERB8lHAde7lLHsLcz7asFtNIIGktS6nmPo=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "JYqdKvUrT+/NQJ12O9jkBsQ1WpxIiHilosKCrer6KX8=", "L9gvcNBfS+vUZjTTKfMX52z/UUmoFCTR2hhYD1we78I=", "D0tQP3vkjAkxnFqbA0zi2/MECHPChKwJ8lT1zoboj2M=", "J20DgdQTujC4MdP9SikkQAkaH39P+Rn8pLsrLJAMERU=", "KOZh5M+UL5yflcUDrR0KLQeKxGRMXf82nVVDqnxI95g=", "IXPGeUaUY0zOJnvCGZFZjz3rrHCSDJ2HdZR7y+P1ESQ=", "Cj+6JBAZJw1c2Ly1QImXlfxZO13qIIzwFqivlwz3zCw=", "IPzZwI7qjenTjdEBgOliLV58dJPQ+MURpNL55dpF/vs=", "DrxSlgUkM/hkFqwXWD7wbbC2q9jUcRC2/EC+u+AqwpE=", "HXa+fdICVkCNrWZ0yNDlHVpaXLj6x5Bn03lkVhaNACw=", "CpTXe/iH2vAc5U8hxokfOp/hT67CoUAfo+4ioCRO0VU=", "EXT9KctGVNCTImdmsQXnzmPwAWoL95DYR1IukGw1eoY=", "D8crxdBRxKvWnZHBTOxM3If7EVBJ8bCKpIL3rH18Ti8=", "CEUVhVWxj6tqK+GEhJtlacFTDYNtnsN/nk4UwgZ0IM0=", "KCIMUG+yHR/z67xHwsjXZtQnowtTo5ZLpXWiECHYudY=", "D0WJeo8rXEIU20IzIfl2OqJWkuDAXUbppF5SU6ppaiA=", "D3HhVlALZ+NWyYmZxojIsqNU0FN2YOCFK/500DikeF0=", "G5M9QcrCXf0N5nnobK/H0ThV5Icdm2HhGbBNUZnAnws=", "GSh3dfyQkDklrDf2Diab9o3AVnUHnSEr/J+qb/akmCE=", "IHtq40g6jOK8Gy9CjB7iQKzz4coBD1ggsGVcnY64aK4=", "JdcdQSZL11/VBSgGK+2CI6JD8l0naBabNDM01wh0D/k=", "LqyCEvwq14j3Lr6HEPPGyYYl5SiUZF89cUrJUdryAxw=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Fy/RLU4DrxSK7ZMQNOcGCve46FRunk55NaMv53J64/w=", "FU3TbrRfUw/ZSbhSM+t0Wu23YpfDOrA2vKby7s+gMA==", "DW/ubhJ2HDgypIqJmJq9XGrHokW+MdwliwPBLMMIGMk=", "G+GBWxfceuykRA1YUPeHxk97JR3bE32lMZ2tjZAl+oo=", "K+LtuIZ6LEyz/iZT20tSbn7avERBg0H7cIpmIFCbi/w=", "BsD+V6RE2QORzrWpStHeFEO9Amzvh2ParOI6O3AaXNI=", "FUSkVr1+c27IiBaYLLru84Uw4chIDcWbt0zoRN5+xDg=", "E9zsfEEMgqfPA832YeTEd82mOzHTQnRlOYDPP28E/nA=", "KIMkgtGJG3mbN6nzTyanKoukz/lTABrQWBzUCA0DlJI=", "FFPNO8jRPPz9sMojVnPj/kf5F3KjhrEbMQj6qosERG0=", "KUjDWmBpDdo7Xfq7wsw5LFhWcdZLozj1ES1KxGcg4/4=", "FbrXpnI/6jHKLPuLeaZWoW5gIEBhk+ItUYl7+k9aLQw=", "Kj7s3RpPm6V6trnTGjWTUsSdwSnWjZxQmnSvDRonol0=", "DRpy2an3MbGYi6IPmdiz2BVy8nA12SiNi702hbKI+Us=", "IJmsY3dUU+EnYrVwdczPxv2VdKZfFbrJUJHdlHU1GmA=", "Bg1oHSEcAveQn6Mp9uBdvnRVrVh5rI09GRE4sF0ge4I=", "C3UbJnSHg0TROyUUQEda+bNxVCCd4HYEVrHa3Rv5Aog=", "EsEaZX9gJCV7HS555am3ah77w8P9/PA5LAYwhqxYoBo=", "F8kcrYNIN7mkjEZADT4l4amnFUyPy+ARVFLT0j0mWw==", "H8OCCvauZRX95FoxWWHidUmITis2f/iLTtk86wXeYVQ=", "F6FntbkBTKYzADZJYJWtcX9uN6Tcd2qrG4Lqf991He0=", "BGcC9itp2vlKEFl4YI3Sw6ja7b54I+j4J1yMvhapfcc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "HEQiOwHej72mZMqVhIuBMpXwE7jCCMiOmUfT+o0kTPU=", "JccXnEiSj+5+nKztYkC4UQUjIsWCC6K9wymGj/3MF9Y=", "GVimjwJAgQf6Hl3ndpAScBgbPuz0IcaurcEYZqZOK1U=", "F62a39VvgZX0zVXMh6gz6dahLgkbWVKdAM5gTpkwf0o=", "BWOOkKWINwVlJBLKXPn+MVu6p0dDmVtgAHLdS+X1zPA=", "JGfPFjR0r8cSh+xWzW2Mb1NHmus/oN/l9RKdtDheXvc=", "I0JxUOYLb8SLfI1RQMB9D5f4H0OXwJWfyFHIhpnI8C8=", "Fvkl9z4JGxdJulVgmTFX1yWf/xPCAQ5HNOt3562mCqQ=", "Lf19Z5biDdrF+hLx5TOVfGcfq/8MjHS8W46o6kpMh+w=", "BmTItN22ggnBJT5CSIOg/AWf1JvkakaP/te7ssiXjro=", "HzzkjD7ikiukbyvw7VFTXh1VnSI7SJvqKYkRbUjnvSU=", "CErhf/f2hIhaTyHSRhPXM/ot58aUciYR/B6GwURhhFU=", "CuK+XJdfycV+6xR5HFI0wvPnTIqxUdSUP7mPQ5GIjBE=", "KK4/s4lqgbvFg6JxXJ4hkyCceb4qTpqJTqJlAQ/f+H8=", "GmY0au3LYC85l0tpvePIP8cpRKxsLdMqMupbM4S0Fzw=", "IkpDR26JO9IMrjlQ67aYvFWU8PcOxb4gcI3EKLKqCwU=", "HXjvQ9knH1cY2gmaWtZYmTqmzE4mPwInQzwcBwC+mhM=", "HCreV9vgr8KenBFqi1LcZT47Z+iR3dNj4dvNUVx/B7o=", "DTQy6bc8gQ97GwE80skgRXTnXc4shdcnm6HuXPqRKs0=", "EMXtyfQgHcKwNm6mhZOqJ5Q4dF5OmAJLXaUwC79ZT5U=", "FCTVCVo+08mOjVnCF0Pi7hjmzS+4ek+PtWalHVUHR70=", "HsP9w6AoMwOfPvmfAcZBxi8PkK9OLZqWEEjpuHaY8Rc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DZq+8mCxy0RMwoFmp05ymigz4SRFqrzxUcHNA20ctd4=", "DtbLurL4cB2lS4tpIwTYpOjLLgj2VciJJOJ/TxWppSs=", "LGN+rLYCpldmi9UTp6EAfYJc79mEROOLAhssHZUKdvE=", "IPqBqb9XCHzzK9AfrLmGl0Jnksbrxz0C235a4ht1DRk=", "BPHSOf7nCd5bC15dXeNwQE19+C0isIww44p1UHOK74U=", "Ch3kAszRqq/svzEBfnFCkWKxxtgFeb/cWx7/fEi/uBA=", "HBTQMRjXEsjsXI/Nwl7J8Vv+iFd0mn1D35EjLdZfN7U=", "DF4MQnIuanTnydddEo30pWTaPg+4Cc93aGFaLPwOkYM=", "B4xLcxPUcBMO+rbYic58GIMuYQ9mmBhBgk5vHYEgcrs=", "A2aLMHyT7BT9BHcTwazbsLkkhXTuXW+jT+iD8cIvPLo=", "I9m+dpMOxoZmCu2osM+XU+EMhzAOvGQbqY4J3S9S/k4=", "Apo7I0XsBBM8dzFrQhMN4BMeuSJjxN3i6gcGPFwShoA=", "IJRxGhKBLih9JF08Pv73wX8YqpBzeK1QYNgHErGV1MQ=", "BcjWrtOeLZ+pouuhErTKCuoa+sLDpoYitQSEosNWpWc=", "FSNa0uxzGfxXIRlTRFPOr8NrwLwuRQeiqO8ff6nj6FY=", "KiUViw35Swqp2zX1a657mTVBjp1q4NcATiP8vTjeNeI=", "EtuI7UBWQAuPM26y1Q7vtHyMs0wxcICTzU99wwoT4tY=", "EPIRI0gkLOl/ZNMEoQhpQoOuiVnlyRcxtiWQBUC+0ek=", "DetIGrNFbMwjLfzVDrgqy4/spZU4vllln745QmGB88Q=", "K65F8cL/YuYEj7JOqLP3MvbKliAEAoW1+JvC1Nso4Ww=", "K5MIlEbXEwBzlwyiBZ+wwGEC/JGmKIM5todHBhP9v3c=", "DwEVr/XW/Fgrd8dE56MxD1aaDnhuErUmp0GtfpWOEFI=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "EWumSYE0QFPbtQAiz3l7fML90BWWXvMJRT0/JJ1YGwQ=", "FdgTqkIIFEow0bRQnbEAmn7qT0qLpDFF9yoNkjGkVVM=", "E0f8A3srJvsjCM9BdxWpz+Q8LGXyxxx7tsXEDr9zDos=", "FTy7Wua21IoTYIcM/V9eD0xOpZGs0U33oCsu3MLu40c=", "JJ/xZmYqtDZj5l7AeJxrpr8bhZRHGiYWLK/mwyEGoAM=", "ByvJ5nj7wlz5EB9Jy8/EjMClG4aqnX5mxSiXpdP13Ks=", "CmV3ripcq/TJ8A7qdvn8IZYojx+LPBbVTCH7yyih2iA=", "HGEKRqTspsEhWHDY012ScSVEGSslbeX4L/bTzW6zJ9E=", "K5oTy+s6zEphX0XcrxiCjIRKHWG+m1kgGo+9nbDLJkA=", "KrBWDf9q88D/Sd5rND6uBcZloMrxV5LTy9gyERnOK5s=", "Ft4I3KCtbenrJHhmsWz4naEYkL8ShTGLks8wLY/hRPw=", "DPdgMAspaVGGRcy7ydlP8xW5Ztgoznbp5mX6/kltyXk=", "Jg1WTfPcDbZ24i+kEOQXlP3edcTxlYS0NlC6kJtE71U=", "B4yRVy3RR3sHAG+xtYUu5Qq9eJoZDbgcDFHehn7R/BE=", "IoADnUetRm5a9kXwZODBDPEuksPUBnUAjUxOuehzgH4=", "V+IyDvtCNOYWkcm7V67aT9EasoKyzaH2npGHFwDIHQ==", "Ivdxun0tJ1z1QygyUK6gB0MqA5c8d6gnRLrJ/ZQhNr0=", "DwEiDd0HAjcJx7VaFIXwpUQwMENaoC2e5nf+TV6g5i0=", "Lh2pMOqlJ0nBW7a800sTHnwz6jramEN92bfuuyLbSOM=", "BtYhxVeJh1r2+mZFr42nMx5UBEpboBxUiRuhGvEKNsY=", "GsMCI0hXE2BCRIVxQdrNA2qwiPKTY+tRwxE+uo74CNE=", "JPBrsSHuzjvIxi4F+mwOviiSXipHptFuMmnFmEaC2k8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "FGsqzQlwM6Fl11JbLObMqrTVQdXqWOIVFm05PNVnfaw=", "AftYflkE1Y76AHMQudhmhPrGWO1AbHDQ4q+RPqQWADs=", "LKchcoDzy4dEw8OCTkbG3oW2VMQbGfS2YvglD3QgQeo=", "GubqIBL+Hoe8oZiM77Em1jCCyz+nSnF7MAikAmpusos=", "LYD+VQ16T39n0rFwpDAnBnnwPRGYOdnKcu+7mYLav8Q=", "E3VXWTlYtZvbzg3GWUyZy4XIDz5RjpkXnYAAszlJJXU=", "He8FCJtERK+/Ef+PtuECWe47g3/Q3T2b4XWV7LVIDJI=", "IBsjs8+xP9tA3rI5s+zhWP2MZ5UMJC7e2zlUD51xeIo=", "ItnSfM+12HTe/RVb214PklXnvpcvkSxEram3ooMRFr0=", "I5onnlXC/UfVhyWXzyzhCrQdukzeW/TNf9R4NCI0smQ=", "E3ck1qo2MUOQj1DZkL5fcHlOa5/he+6k3P6p3Atgc8Q=", "Hdbj/eG4SgtKn9EBbRxtIvqAq+3wADaNNNjAab4v7nI=", "LJRSKFcWLk5nv71JXoI67Rd8il2H0jf8V+U1Wxd+c8c=", "GDAi/tumx40AdrssLGu0ciRE/ndwPgpvRi2rVXnave0=", "IlLgerTQ/Pjc2i/RhRTwMUKCKXzJmBnfzwpanzVURDA=", "BxnmMs7hMbhTwIJPUnmAvwDxjYoWqn8mVIDNEO00KP0=", "MCRBso07HPOd2nvp7O1Z8xjBiCdMat7FhHN4Vklf2HU=", "EmksfXMB4YvP8QbCdc3S28ZwAVArIaqJDWvXDpWnaTQ=", "Hq2gFnlEObTUYLR5VjASJWAbqScyZqnpVf0+PDR6p98=", "Bcs7Dd/PLqhVLvV4E50ZgW1cPqcIT4DIz8xDlgrCyYA=", "E7ePAhXtf0j0A2PqVkD7mkG/5v9QRK06/1HXVdm8+xU=", "Gzpj0vXYQWP0j/JPmcy6XvBbKcqAAZkH4cOniSlrIt8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "KVf/yNGwo/LdAmrXuQ+37rVV03ctjyx/R+N+kTqSH9U=", "KhxsezReJgy+ERVKpqBi2Hclu5QN/peY55TVUTBvdfE=", "MAytQwRj594EPFQBGllLLlqp8Kr2VYpRlKaKMoW9qYY=", "CrY8126t0B6UShPnPy8Dr//BG0gjOAxtD2U88pZrHqo=", "JiJ655zexbgK/4Atu5v06GWa6SvYqDvm3LqNWRfE008=", "8w0XGf8xyKwhdeX9hjtbBFFoCePHrG7EGhpT2GanHg==", "EceGhxzCXqSN9a0HCy/TlppIQfBYhagAKNkQt7bm6rI=", "LHpxTae3XWuz6xa40VmfNykQW65nWhkk9DwyOfnBM1s=", "JLcCaylsJFtH3bweREkgNMS3qNNbKIfNU5UTxdBTJAM=", "LCR8cpD77sVbyFk7D4WbQ0UQAt8YkjiTSxa/GiDTYko=", "C5SJPyUC04/baRv9I7IR+sldk0z5E/TFLqyZmfwFnm0=", "B5trhSS4Jw5IBWK+rGlq/tiEBgFdRBmo/xIzKQUN07I=", "J+LhcI/IKnhos6D6vwWdFk7T3Djw5iIFNJKLHN9Z4mw=", "MECvvISCdZzt8Dq7QaHuhYzfVjGQ7s+yokQk1JZJEbU=", "F0F1J4TqH8cwSsoER7KHjeFoyHt44sPsMtaAW00qQeM=", "E0Rewyb0rvqiqEVHdntl2IhGea7ds5FZiyGa5//UGDA=", "KyPfEgkzp56x/uoyWlIbpdUzcuKdJ5qMMt7DOoPc6sU=", "LGrfaOQ/AvZyHZ/W0Z6JNM46Ri7FQ/80IQ6CgjkXd4k=", "Aun6rtXCb+zEZycjNwYj1vVjU3wG0emCkhNPSuJvHK4=", "AiwmHgx737kz6Ag4L9ddpoH0bZDnA0BzJmMHaEB+DCc=", "FWBc5wqikYlzxL/xNjA1gLUfsHHVIkoXMsEEJLH8eoI=", "IezQNBR0w7TOgRAdJnypXXzSZH+kv7yCOVap40jduHc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "ApMuiHbZheoJVJ3yxk6Al9hcNXiqRq316vrAOZmYNcU=", "LBv2YKHciyaZWw54h1sMKN6e97WR+ivAGhXOdym5rFs=", "HojzxO+jNPpb8xOpGcTeOWveguEk8AAvHAAin428tns=", "DHdNastPzEWxOdkjI9qCME/E4pqRnJRodG3SCm4D/O0=", "F8ERdMkQTi6ho3S3W+ppJexFodnlKTdBlE5TWdTTRAg=", "Ih9tNBIEgCCqgy12SltegK87AUE5so8GkgzTo9PHt7M=", "LAtAPRM4YUEIWbSBMQAayVb+TJ5aNo2cPwhVYOXTdpk=", "HamlzcyNXI6DkK/iS42AG7h7n7nu1Cmq5Sq6F1cMnQM=", "DD44JScoCsZSWzkiOIsxDcmGTZ/RGBWiyU9zePPVL1M=", "LnM8ZWq3MIpfd7F0fHx1YvC0jZvEK0wTkmMoQNxn64M=", "BVAMo+tL0IvZGZfU/GmPoFDV2A2IH2NPhP6qrFexWy0=", "ESqsMBrVztYZwpJcKX0zh70GkNCXKqIfiNdDf0K7XPk=", "JzycVSbaYTAWTiNgyc8RHiofsrXwKlpGPGxk1VpsR2A=", "BbMOXnsB2HMP1Unu8jK9OCSzpnBgTM+iQH8qY+q19fI=", "JukFw4ieRllwcOi2fUrJ7UT1qJ1Z7+x63QAklNo3bGw=", "A6S9CVALJlI47o/izBSeBY01VZ1K+AS+BxGYFbW5iWA=", "MB6Gv0eQAotnSySX3rQ3DzKyQQ3vxqTz725QCg8pgn0=", "CG1x2xQ0VURNmbmZOWS4J8rfT+r+vdzwGcJ48yyBFPU=", "F07xd8Ey16PpHwJjnX3YgkhDUBhSXwle8Yy4RrsGDmI=", "BXrxFNJBYYRzX8/wbYjnNPfY1d1BK3xAe7Og8JvC1Es=", "LNIQdtVfXJyMPDr79/DrL68F/4DSZ+tpLZO4QAybX9Y=", "GrLwXt4LPpeQUXcS73FFaNVw2joIM/joMXwWRCZM6X4=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "E0/wC2XpohTxkhK0dQeBuj3S4oUR9hzaemlVO6+0Tcc=", "FEd0pgW7in0Rsvj7wqDQUUaBKp8dA8S+YIpUTRitj20=", "Lx3jsINYBAWd3rHZO7uYIfbiBwNl/zTaLEPf9l0+340=", "CTCkGpAd353GbSeyI4AWUArsQ7BrrG5xE76v8532nHQ=", "BeqYiVg53utjfAaTxgmUr+SVCgiNEAWUayDCX0ix9Kk=", "KyrQ65b+XlygBiEJuMU10yuphOOFR/PRBQtyUmiE4Uw=", "DqOg/AtG2hiancohPAKI4zaVc/pms9M3muVt8qJSYvg=", "Jy6mT1SrNSbkZ5oNCYJWAjOve38uhRR6himP5ir7Bzo=", "KBqm5mUof5VA+y9tE6B31S4UXtYrOMZImbkqEjNXwIk=", "KkMvzG7S/OUL8hSjH5VGuqL+j7PR0AFFp/ynSCriw5A=", "CpgJE48SQ1rRFQ+Px01AHZksQkOaROvRIpkb7OOCTtM=", "EJrcHPhSjsj1N8/peOMg4qQCeruoOjeBruC4hESAUVQ=", "CXm3cWyL5rxAkaN2/9H8ExPhnzJmCVvHU9os1N+IPtI=", "FjyUZoXFhdRrbrij7a8Bg1NUmFb/bsCiOPRaHw1ZOvE=", "DT0YkCAcW7Gn5A3VV1tCZ/rWOukfQp78X1f1L0mPQgM=", "H0rfWKHKFYaBWsJqdtjWolwxPpsrCsf4MObh4M7i3Mg=", "KRbNbKDuVs55NFBGzhqRojGJX+JGKKhAhSR0skC1NFk=", "E5Cucw4Cl/HH7y4ns8BQ1nEwFaQDcNaigfHJhdv+hvk=", "K3R1YuSVbedPSxFeCCvZXACn4qF1JVx+vvfNxwWY3hE=", "JtV6W98rHantqI6FbEkJxCZeqG2Lf2MMrxI6rDKOAgc=", "JEECNeP6rMLaQhW5bMxSKPrwBwnaxlQvWJQJ7l2DOQE=", "K7DYX52q2YkabKdhF8WRKhniuVnwPlmsUsphxvyQvzI=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "HFPSXMMO5nucpd6S5XSujgBjeFaIg6NexnMHjFz//6M=", "FYCTcCVOJBNZR/pNTJu1NmqAkkTELkTVitUQQe4KwKE=", "HH/rlcdN+taaWYplabVUSzE4wpPHiVfCgeFheN1NL/w=", "BxYEgmifWc//hozkNrYTXOW40uFa7d+tI2y70XT86uY=", "HhcW2KSfDDJEhbw63A9qR8pNeSHgef7CcteapNT1A2s=", "IjTnzh5ABW3rYu3nuGx/ZIL3olPOSap4qlxjal8PlCo=", "ETTYnEzGTss1IC/Ca1FonHRbgSWH6mCuPiY2kItCig4=", "E8bAIaeQTd2Mvz0KfbYeBEQDgScm42m9uXyjHNBRQqQ=", "HHUPVoiB+ge9nQbPLDY1bFuCS3G/IGC3Y/solWZ7VK8=", "CBcBmaWyYLywVjgQBCje89+e/bUjNEHRT8IZwbz7Cno=", "HAv3r0NK4g5ZSSTpElFbviYOIa/QMPMut7C/XN2/seA=", "EhdBTafulmKdFtjXuQbfDBW7e9W/pVlZdHFK7Ys96Ws=", "Gbzr3RjdjNgnhQ82o/aEncAov/zBD9WGTA43xQFWlkw=", "BnqLf85TLqrxmO8P0RJrRffQqoZF41sDMdfu/cnHs2Q=", "KpLBeyupI0hEddS78WTKoajxZSO2ojstuiYNcXhTDq4=", "IbrSx3PHs0mykwvgl4ETigYcBvTwb8OOcTMrlC/yk58=", "KNB4ZonFqbyMfy62Ly/Qsh13bzzXRyXAvCruyAEEiAE=", "IizJ00aVsAiK0Wal3v3iE3dif90yt4lXUIU2PW1e+Qc=", "KlTUZWR8isXfhuwrrHgumqVgl39/tguHzPPN4B5ArGA=", "E4IvN6KI+Z2IHdHm9t+aj//0gvhBeb4JJOd2jWeKKpA=", "F5IXVAaqOp5wViM/SnAELoImyUO3q6mYBXJ/96lWUHE=", "CAvEaHkBT9a1Wj5NdpiSWypnELelR4pRKSlk9k3h12I=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "CK7r2o/fmWZ8qqG39XDleTde33+2Q4r5tom/wS4si6M=", "BLD/JymVoT/t5/RGWi8K0hNO/vVWJuGCTAjtZ62YG9c=", "Bjw/RR+2T9XpXSHI6rj7mFI6cWyPg+D3ZLQajnMdrq4=", "GSjejMZNbPIRBwRaf8xODLpHBuaM/neQRFg/Kq9uiF0=", "HvLshz3KfrEJKxg1t0zbQDcm2Pq2y+9QsjHfmrh85yU=", "CuAtsOpAG4ocdH9Q6IXQh+6pP7MDeHC9NrFEDYiZUDE=", "DLe6bLTgVq6yveYaOFIa6t2Hd3JwH6Vy/HeRUFDbdYs=", "GOiecxcCVkT4BDJlzgDWE4JGcmX6BVWYBmubGbR2U/Y=", "FnoAPt2qfRD5blR7Zswr2fLKmdJn4BH8aWafcdC3H7s=", "BXPLsnLapXDzUlb9OCbjTD4vNfMAreppejBvkU23pYQ=", "B/ybb99Y7hgaAUHP+J40UT57TWHgF4bBdtyoS5Zk6qE=", "Kzr3THocDzlkKffi1w5osBSzomjZKJczDLn9sWFWdMY=", "IlgOuDqFSoF+QnfozxoF9mPRmMCytkWPpMxFEgtIiDw=", "DAOmU+fiBh1i5jigkxt2elUHIrMY6/yL2SSyLIoAm0A=", "Hw8dNFRoFbRBD43fZ77BKeiuCP5hdJenDoW4CALgVXs=", "HcmYqCcyFTczOyLN97zwpf2acs+e2dngXKgt9BBcAvM=", "ITBfvtNqC2EczXE5pIt9NphQQWh8S3ZIPu+T2Y4o3r4=", "Gcr3VVCFXhtNDlgERKc9sdhtUHtyAx0Rkl8z+89+nxA=", "D96hCYqokpjXLd/cWkfI+RQZVf9aYStMUq0+oEYfPfc=", "FeFVQtgXYoTLGwB/RlUjax9nlfBFY07IFfu1+EK7PGQ=", "JLUfhPBzfzXAONOAHeMQL8MtviI0kcU2eve6yg6TNII=", "IiMaZyv7gvr3uGdHU4LC/BdJN7U852X0tvuXNxd6Dss=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "ICDOxc8SVWe5d1btcXQlnexTm0xAu6Ubtkd5IhtLyp0=", "Frf/saSvSx2ujYKCTFQugbc4Dv6/MYMgjdh/M2jyzXM=", "KUdOf7ot6Avt+p8vi8qjjmsVS6LaNFT9FDb9W6yvK/A=", "KfVaT9MXBkf61xzzjIDEz4rwsQOay9GTcy/xvcsEk2g=", "I4PRAVUI4X+p/ygsF16l7WVfdL1Xk7rkcARZtWAMzu0=", "CyE0fT8uHtDtAiYlRaautCCbGAmxMvfxA2r2f57MEUo=", "HDtNeQRqADC3Pk7QN0bvKJh3hWABLxS4wVH0Fm4MnP4=", "K73KubyV7BUJ8q7Cr4sRfDTY2AeRc8wJnmWMhjCIqtU=", "Ayw+OacpnynIFtdh+8Kr2ih0PpF1R+6h7qp1l1sit80=", "JALuPGz6wB4ftlUcNLFZHitBnU7GmgqfEzHLVGwx37E=", "/722O4YWGrlkinu35cJdFUGEcHDvpYxiQJN+q9BazQ==", "LdUBMhVyhZVMv8bsby5zsNEhjGmaB/sJmEaQ0PyHGbw=", "EW/P1IqzH8S2IvRCVmvhMtaI7fJ9Uzf9ivuAkydpFRw=", "LDx655ib8jyGJ54UZ5ij7N2AiYrLtsLsH3Fut6kbAXs=", "K35g/L7vICCCPnmUSNocsLhm13bI90wDHeL1RSAQGGw=", "K0o+Si25wMumOiMQD+W5rSm2Ph4AS0Chb8AOIKg7fQs=", "DRUnslK/1QXzdc+GufyV3FX+HKZdzzdAnsSNqLEgdzU=", "AbCjlqFY+nF1ERFHZv+t6vxs2CtyOQqpCOHFtJbqou0=", "JbcYGuJkEcFwXTrbOJcWthX3wbswUaubmvTfdsymcqU=", "HObiYa1NY1NTiBSVfFGE/zQ1IfGO0eisJN04CXjxsf8=", "IRS3AxU8BdikWLhtqsuKEYCg4OBjE8afAxmIUhjVclQ=", "C7qT2o/UXwIyqsiOJC+DVTeZpd2JOidpcWnZ/z9ijb8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "I0YgNl2eUI2LegGiDIuEz+eHNL3XpICm88AnC+bJ4DE=", "GHc0ApODhL3PPtKTGjSvdg00AeEMygKFQIEgnKW/nHE=", "EvSJYJ6CfuPdalMDbx+PuAJDwLp6wnIO1pl1BPf1DT4=", "CYrwmSEokq9G40ztuyHoi5GEqy/MuLhmWlMkYB2MWQk=", "IpxZVcO28mNzlW1OPdvObEyX29E4LtHBQcbGuMvPqV8=", "IEw90cFXYAzrHLVQcu4ngpKjADp3d/67CAozFo9P2fY=", "D+LLOsOKNfnZQ+IKTNNwWY5cGxKO37nLh38tQky6Vqc=", "KuCvhJJhC8F482z4iHtryG8C2hWx3/tnRwbfDZti6e4=", "HtFSCZfcA2RoNUCjL+PkNoOF0UC2GwlnL/DgvCs5gRU=", "JaDC9SK38nZnqTxDXCvcZ9V12oqAi/3ypDVYsesS2f0=", "JNm/RnNL6iUjKYea37ZXgvpcaAmhUgo2Vtf2czE0jT4=", "K1J3gXZpzI3wxrgv6xWH7VkhDxQUrmCfQN70wxTZbgU=", "ByTzOswsIIIv5/jT0fCsObL6ECXcGNzKpLJYomVOcFs=", "Fz9gnOSDdH3H6tJlmN0iJxB68FIfyqxe/CvcP0jAfJk=", "DPCys/CrQNcYFzqteZPmIT7kiATj5WPw5THiyTer354=", "F8409Fqv1jgjisWEaZdja1iqBNdrSwu0aqDNB4rhT40=", "CvUcnpP6WZEQRQS7qQFJIo1k7s5WDkyLwszxuUPPp2E=", "BnoyO6tPPQPfMlgYo5O6Xfq9ZkBc905l6d1S7i2PsZc=", "DD00RaJ9egQvorTF4rXQPBMy04vyangUSTJYlt9X668=", "G1s8cQs38ZWCSmI3ErIQTYIeyNhZlAvw0no8UPqi6IY=", "FvvLHEFAMbp3GEXm9nFR+pg6TjKXIDHvgT5fQ/86jLc=", "Lbsek9PNz/PsO7Ad69khGVH6tFTpoBn6RlipjxSMyP8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "H1gHhqhuYi2eob/YfC16Ol8Z8lEF8CR/CLDh7Ym9nbs=", "Di3rxkF8vOk1b3X7VbfvA0cgXfuEtbDeLAL04TBFPBY=", "KGs5niyhiWEqjX276TimGicwJXeQR/cqxfyQKEffwP0=", "ExRLVGkuV33kWYygeD3eevKjqBzF8AMLbDvZLTv3be4=", "Cvckflk4nQ+VCbFohF9GpytEdNnvZt1+NfWEUP2v6as=", "GLPBouIEds71iutLjsGCDYDCilMJ2F+XT6YqGdJi9bk=", "ItbKXZWPr0lAt04/UP5u74iHmTAsfJk5kzGp2wqd3jI=", "KOvNtBYhDH6gqcRM3MF2O/7tCCZ8x6F6k18Odd1r62s=", "JkUiqFaYvxzSTCHpN/l1+qTL+zU0zbr/VaiaF/lHrt0=", "Fwyjjf8E8XkiPcv5bhVgkiVDbkf2qtEMIQWbVJuKzoc=", "GYDoBSxH2qKn7OsWC6PLkykaz3uEw6G4OXd2bXjnyoM=", "LvVed/MjCHOfCDHQqY96aWHkgi5TAn2GpGqpya05tko=", "KErFJjebYUoUx+oFZ6unpFnCacMv1a8ZIkDBEQOjCME=", "HVqXiuLeI4CkWNI/LCwfe8F5HU++s4tsejVrbwM+bck=", "H92HUjVe7k7LHokktlQZQtoMP1bi9sEuKrde6/zRvZg=", "J0tHUH34Q8X9L0yCPEwiBXt2M2r/xmMQNfKOV/am04c=", "LUax6oep8u1thmX0OqG09v45m+0I2cd72Y6CNQvj83k=", "IeUKNu4ubtVi/XMBO7LTRyS07zRSXFGTFhAHa4HUnso=", "Lwp/2iHBmuVSM9uRPx3Yhr9x6aD+EvQl1Hn0YvHPSwY=", "LcfnFsG00YLNsHjzjucUjw/0WmX39jYKZtain+eBcqQ=", "CiTY3hNi/p+PI2Cd7lm7tCMPOSNuZyn/3ZW+3Pj0BN0=", "KxwIfOAVI8ng+X2Bxnp3AU5veRplb47cozEz/pIGu78=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "JDq20p01bRR7eRWnoR9u9IWg8++NADrCOcCpJt+CAnE=", "EPDqKZz9Ftp8VM9DFaS/mT9sjtIeHxtiklhlW7Vp87Q=", "EFfpesmD/t+lCN5ekFXCRim3+qJ58eSDopJ+YhpFoW8=", "E+y5aSWphRc+eSvK3Xbb9iZX6K7m5zLh/vnOsdhmiL4=", "Dm+bLGTZ2X4dzVlpGilExOYQ8sk2GpMoSFPDNe9Ei5M=", "D1Ew36rHaYyDJHq303OExvT96kxCNpHbwEZsyEfSIkA=", "BxnGbVENiNUagPIsnuBsq1Bu05WEdTLwsK73npT/XDc=", "Gf5946U949DL+74ibG2XmcrHPDQ7t/ZSJG0zFN4s10g=", "H7UROGD5w3F3QtqKyNwC09dQRHrgAjZ4msQAq3sKSlo=", "KGN8lxi4wQU6wn5sy2ihTaztXCTDkyRg0jqkD+BmYR8=", "EEn1+IXFWf4m99gRxmDMnG/9tRA90yFxEbmYCKKKEMo=", "EewrAtF2wiK8R59vuk5Cdzi5asobfDqhHbibJ64Q8OM=", "GUr1Z4GVP2nhsAyAQOrhvVm0hh37s5adgWHXdVIjPBY=", "DnUu2gPJ3GhQYNfQYl1Igu6czydIkpKG2wPwpFPYwhw=", "FEDDGc5H2vYTVCtghQU6wirOckaGP0nfZIgpLnvHKiw=", "EM151hORVeQgjdxxrJZGrrSsYaPq368zf/l+2RCeCXE=", "Au8jWQYEt/BXqqBYMzP1dm0lpDNm2Zq4f54pBgCz90k=", "LvLEX8R7F1y4xuI8LNfSYzLuZUcHWYk9Fndy8Yt5n5c=", "HnaZU8dJAeHNOeCp1+oS2xBfoqDD/kDL42ll4RFSSCw=", "JxOnBgyZAbkE7k79McvhuwrG7+43VtWTkui1lNtXphc=", "FbO8Y49FVqx2XlxgZ4sY7MWnqsW8q+8kfanPEWz0JJo=", "HfROa0P1Hjpwi3tvegXGfngX2P5vNuNX4mYmXjGDU10=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DaPuKD7bDkJWiRrJ9BZroUwXQ2wf+LaHD23qeWLzbDw=", "Lu1ft2Sh+mzTh9GTInkMh6a2oLE/gy8k8PpU82qtwNU=", "DLn84Cw/L4JwRHdAekaZHKsxHbbhLxTjiMKktgk951o=", "LuunNlPtzkHO9icimX5d+dL3bXmc8RLSm7Vwam6trQg=", "BDGMQUdVBNzgxrvR52/tgp98inHxsC9F7t9cOnHmOQk=", "KglGVxU+zBcQwFg8HDt+eWbmcFfI+u3UCOUFEnp4YF4=", "D0Cu4lMqCIzabRsTxIVpAi3qYCP4UjGlVEqebMTtzOI=", "DZeucjIUJ3V2kRI1vCXtgQY/zSG1nmJ5J18R9XwFRFk=", "CC8eXo5Qh8Gu/Q9PxiFnvKS3O4AJ46Z+B8767x5HXO4=", "KE8k1D0JvzHBtZ2EqPL/2LG5A6K4iCf7qLAkaP9XqXE=", "K2U46zaZH8JCn4w4SD99Sucot+EFtKxrtEkljridOqg=", "CC55kQk+krU8V1ufUfi7jR0qQFu5Q1lUSjEG4DOz8qQ=", "KIWTs83SAbP27n2f8hfgutyd3iu2yipjNZzspZ7RLYE=", "J2KwwF9mp9OixLRvbaniBxlMMqkaFdDIx6hgGHRkm9A=", "AghRzLIz74FENVcPlDXq980iuvKolyC0sJ0DXdQtAwU=", "HhfkrHr7WYCQPZ+qo1XS1LwA9mHOpDXNVjoMCNifUtc=", "EcZHYvbkBSjvX2DEkFzUQuE3NIc3/xHvn+GG6F2IzIE=", "E1p4k/DfMb2wk+Lxk279479sgM3tU7vyOELVz6c5wQ0=", "BnDJQrGe/g4krmZ/iM8lSCmI1P0omFK1nHQAuykf0io=", "L+uJkZYBaCfvA9/6rim9n332bzEvcorAOY0r6QoQxG0=", "I7uKz7gJvbXtKyMG5YcEZc2IHoUXz41gturLI5k+wZ0=", "Ci9m09VhZag1etTt44bovT0sGmpR7EqSjQKqnPLJQCU=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "JiHVPZD1GpeoJFXUSDWfH4drCO53kX5VKYtKT38sgMM=", "LhcTqhOh7Sp7V+znLVWZtuI51fpThm5AdEQpAlTxBRU=", "Cw4xNbmpuzkAoxK86Mv6pr9xdr8Jl06SJNY/ge65zd4=", "GzfsJhvlUtf5ysvcDQ8i6+/XwSPNzVSgtJPbMKZTWf0=", "EABRVlwuTZ/tEYtV++9vBgYI3+RVXkhqROaXFpYELdE=", "KYgZusYXeLIYFC5PsmUz8Ksfj0DI2AcP4vHUFw2TxYs=", "LLuQ5QiVLEte0mB5+F8R871ygUDjuMuRwdqRUsioJWA=", "GOneUDzvCuP4kB19kAQXDkZh43krRk6Nfhp8f4uxcJE=", "JApsWapyQ4JhyyYHDKk+812yF3cKIH582a86TfYHaK8=", "HFwCdBcr767KIB34du45tYL6hIoLyUVPaDSwc8Ttf3M=", "HdL8sieHZSPF0HWuqtLfVWynaTm+mEYnaPlJQMpzAo0=", "Hg6//ZVn5CIrMivRYnWvheOgnG248FOnAngnvPuooM4=", "BUnj/S2LTI9eH25a2krcMSXs5q8QQeTyl9FMyAvXqGU=", "CkOn47qDBhtTefYVgPF/21Bo9XoYzz2PRDHvFKf9i70=", "KoxxP6C/XgAtveVEr/mI7Ys0ev4rNkGgjquXm93U0sk=", "Awe0I60Fp8bFp/6sBB3hwjbPPbjg2kY2irClET3P1NA=", "EgLcpVE9hgmz6RH/w8H42kE49WKH8oN7wfiCBGm9WDk=", "ChCdLnF2eWQG9/wlyvg39cjSMGliuspiRX/UlnOw5I0=", "IVj+cqFnL8GwrrVr3s7/QQ3ipATJ9Nei45xM8IACZNM=", "Beg6Tz7TD4Y6FI5mwXcaRjTtUuc9wfnDXkeXRNrLfC4=", "FRRvAWnQ3LLmeKYkQ8AEQsw0IJGm0YopOheIKtr28UY=", "DifzeQSCUpaVKToN79H0RJXwra6BXN7g086fkVEsG+U=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "IWv20NJAzooLQw+FJZt0CEz5+ZiCPb8TCRBCoytOpWo=", "F3InZi3MfvNU70H9s/I0rZPntwplUOCb4slH6kYll7A=", "GGS7lMyV5OM7dnOAmQnuOhVsiSzqZI8Efyhk2xInjko=", "Lrqci6Vta4AGVKHoBdQDu68ir3/xqtkqt89CDBKaJhY=", "JBMzBvKGwE0sLhdMDM40xkwh+B4N9nwlk95bQi3B6yA=", "ChrrpxrnPyhGy9V/ndo8PiS4IpHSIQimoFqcBuACuNU=", "DS0K87Fr1zil4Bu3r1SfhCoqn4RwY4RdNtdCTh0r/qw=", "COSk1PuXRzz9iAyShQKMKIPW0IFkrn2ybmkAtTLoSNU=", "KyrgK51tUyIJmKy7dJwp9EdsnyzTS3TGbk8sSrqrZSA=", "H9DKCynmNgnC9qMVDvYmFqX+IWAmY4IDDkiymAYph1Y=", "Eefx+Rgm2BWQLi2deeAnxE54GX9EUMvxQSjXBMLdRtc=", "Ja4UHTH/IjcKmWk62zUIWKMH4fz7YP4XWjJ52Zh54tw=", "EwR8JII68L3xfMrto3FVLog0mQq+t+56mmRqp7ufR1M=", "JmNY4R5QgdwpRJkAB2RHM0RekN2rIM1QkSwGzxOI6So=", "EkeiB31Xeh728K7+inot8hgo9pxEu4m2rnD+nD7hr5E=", "LDOFJPM/Mh5vLl5CDt1H8Uyspb/bfT4GUHO3sg0oFPw=", "LO18nPxsuXJxeb/q8P/AKKdZqkTpclf3LDRn+aCXTCY=", "DmM5gqNZMzsBfcW05oO/onTnQVP0+Z1jnkjeAv4jnJw=", "LqC/HtcPFfwZajlayDbmpXnUkj/RO+MrFBbTUaBa+vY=", "I48447eh1RfgDGZsZnDAmc0r19hBjFX6zW5RHqN8ZOA=", "LadlaSu/76vK6w2rPuGHl+wAMsH+sleYPOdTqPKGp1o=", "LKubwdklyj9kc9VqTFfsE29S/PAsnuDiWtB/4k3CgdE=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "ASEDA6dwUhLoH5JkgmmcbWtqoTujQvRXbIc86XZDXv4=", "Lh/lKtSdWyz0xDx/1VH9BbsMrRMiJskrR+S9JL3ihSs=", "FuYZjjDQbBLVU1cJEA1H0KsXRwTklTtpa9y4MYx42A8=", "EQh/xNr1wBD56otm4vAekDJZeWXIEa+5ypxwBOAafrg=", "JozDyQn7sZstc3sP60qq/WosDw2k9rOR6tiGc8GH6L0=", "EgAVK6z7teIVZbGdDmtHricUzyvZrnA4/pEyh51LRog=", "KNslLnVvD/qD/YRfp9BuuqMB037fR0o7cfYFOaYw9Zs=", "GE6VkG+F5ONrC3fp2GL8J6Vuw4wxePiQSFFwDHA8nbU=", "FNZuZ97Len90km8tXsZJe5ZbTelBvdvXc3Gj2kcOXZY=", "EqWzRpBP1jtsUvYD6KDDUdIoTsNF5QUYSSupNbB7p7k=", "JpCU4pHXkka7c108Sj3y7J+2CmsvI0DmPJHMbV37CDs=", "E5KbQIeoGM1fYC7kCv7LwwrY7LK3Z3UwCU0JMJgI7OA=", "FPh4xS9tCcwbMvPOtvJFml/WZohguUW3RFfYGabRh1c=", "LZH8ODeeUNit3DX9+4jSfhAIN+UT8ymvxPycvG+gFAo=", "J7TdJinwKcHsEbtfI1JSNxlHMTmToBEeT1zRTUe1Bbg=", "D89xtPWPHoRTlIAPMgFd4J5BB86Ke8eGgQ48q7Z9XV4=", "DbTyEqjZ+ANhdNmVk3YY3IB0yjL1yhu1N/uraJjcZ5w=", "D6bNDJp0wZc2VtRK4hMjtdKe4mBlkG8HR7wzZNn6j/k=", "AvXWEqieP/AVe4wF64HNsDCzqoByjuXytITgJ+nXtYc=", "ErwvjqMJ0Krnzx/RV2fb6Xwoiy1y4epImjgxadflzwc=", "IOWniYSm5Dfhaq/S5D8RkjO0uzXPtiiuvMoKs7ECtMU=", "FV7JVwzT5QP8HHP6vTjEriTTHlo4vFbJkrWBfJpYwY0=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "BqSFmZG4IQgoO2CRGVuSRHFKGZepeDPFXE4VwAdH9fo=", "GhfJELkx0vp/v41Boc6Go0lhSPCmLLtUGpQxDDu5MdY=", "E8JxI6sVrG+WQCL5Su+qUfBzka/BCV10gKz/7H6c1uE=", "Fxx0K7DKKgKC9f12KBkebMrz4yw4MFoA9lk7T9dSf50=", "Fs9LBsvdIcWv0ex4eEf2lW/EXOw06Vc5r1ymfCfadyk=", "EeUdRQOxrtv+mTvvycgHi3DU23VVbaSUKEbSLyF9xpQ=", "CK/WIHbH+Ua03WGWezKm0J55SIjCcCrPrOrYEaT7SEY=", "BBWMX48bEO+hKqtjVG/8jwZa3gu0lKMaWDkcQfYvqEE=", "L4eDe29fKAdlnsdWUXOJP5GkrCa2wuJuItCaQXMJ3TI=", "B8co0ujZW8iELd+NtMdkEq765CXCd069ukMX6ngzRfU=", "FFXYlj126ZCDyJa/D2j2PbmSuGqRPzsSOpiIn9YaOw0=", "CLS/IqoOA7X4V6UcDgS2RWX1nIfvtoWfjHFp3sCeKEE=", "DtgjuLnQ8uCwxqqvPlYhMIQU1L6UyjzLxsiqDOjhtLk=", "FkK2S2VHwTfqnRaSDR1Cc+xJFINppFfNKPc82QmO5qI=", "DJ2Rkk4AevSbog8WNWNzrpzdQIvaklVYPkHBB5xcBro=", "LxUYuLz0YzYuHpJ/cz3tvogX3o3/EhpqVSezPnB3jOU=", "AhFOCJ2WxaS2Sypq0VT8aIC8rZ6z6M0dPvmA79pEUoE=", "Grwl7VwPrpOzgTvY/aDPdz30HM7Qeoq3Yvs2tlZJIvc=", "Kl7d0hbw6txMUKJhj0Sk3/1o7Gr498C84aRYlObLwBA=", "B14NNLkgeQ+70hQY7LYmY0ZLz6Bts1gdvsY1yM+GTsk=", "J7e+tDCjHQln3Sh96p/p0KFt70bvtVGKumX6Al2CV5s=", "JwvLAIsQ0y2LknUyGUIgAklOMDJ+5xsjebCdWo5Rm5o=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "JsSjsP+bfynJfAG0/cZdjtGgdxfamyl9PSqFX9pUvuA=", "LG37UtlkjRj1/5204hPGyU8vuBUa7d2Aoc+V3xq0hi4=", "L3t+eV/U85L5gQh31EUjpv2cpZv59vFVAvREm2/ajIU=", "BXIqqiCA5wzpHGeTITD+rCx86T7/Z+RTxKEMeSPYKCs=", "MFJHdp3C/Bi48yz/ixoI6+YLDOUXm8D++eQYkwBwUNs=", "AlwAB1R5YeDzaMW9e80jNcfTXB3NTgSxaepmdqJxPr8=", "CvdbAZyIoH+yTQHLuy6obnXOkEVg8G6qvWF8xierDOw=", "BHB+CCMtVdnFo3tzeNlM/XSTOx9IOm24mn98yD0Xoig=", "HLK8K0lLSm+eUCmScw3Ma5Sq2m0KBKNQCHs8mGbESMw=", "KSKVv2JXvehzrwNt1pMrYj/qErsxkovfyADRpr233F8=", "I1thLmcBPr87dPpBFXaCpBaaFzFWlfVMc/KQr8RXSjo=", "H0EtwNpC22pkjBnp6RGbFXSDvbx605Nu+53LPnLhIRQ=", "FAK94hnZFbvF8pWO3SihBwcs5sv2I0ZGJ1TCHW1cnRY=", "Jl7vgjguBVItjBE6tCqwsJ2kwWbhB7L9DPpHqu5fR1Y=", "KzKe/q9mP/MH7ppoL4g9pZ6mMkKqy2ILYe+FwBEP3iY=", "BgBGF61mOkbkHXkQPR3m6DZNL6WCJx2j6LOcAa3IruI=", "GhDBw73NQ/+m6k1Y9AjNfQ50peo4ZWobb6iOIBMCXVU=", "CccFyh7pZ4PgUwtpEX2ZM3+hqvBMX9JuUwnAEY9L2zI=", "CXiqVDXbHuaJbHN7o215EgaBdYeT4aHVZxj2zeUz3Fo=", "GTT8VGyyFaI770LXEkzv9w4dRpCBwsyjQ6nrvO8f+mA=", "HqRSBDRm8cXY8m+kgmcBSDMhSEKy0gT7JTuXybPe7Wo=", "CHa8xl7wX4nZDzqWBwpX1I1qKgneKquhYf1rnoDNbMs=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "HJ+XQtS7u2yd7AdrS5x+vsEgxXQOBOPGLQx4avAGowM=", "GNn5ruDOPqCNkWSlRzrBFK51XCW0+VZq7hyQ0KBucCk=", "IkdrwCYHzHRTIlldY7mOtw2yeCdi5UjgI4N8n7BgIaw=", "Itgzgdj4gAq9ssztNuHB0cL1UllL/ZmQq+BtB1fqyuI=", "FjgsHfQefQo6SVhlakLj8fMUsh/0Y8X5WbUdGmxAEYw=", "CedoFdCdqjOjJPXR0kBLPuQZuOm4gz21kRDI048Tc88=", "Gw1a5M3m/tP975MSVX0i99pYnnHocSun0phrS92mIG0=", "KUD5clhuE7avCNSbg4+83yT7KooD8Gm6YSsFNe+Uv24=", "Ge3Ksq8/GDIerPX8TzqTM4PSaqN7HjBJ08NsEcJfYOU=", "LeynWHshddUN5GRftWAbJZn16xX/3Kdj8KJN0d1Oc10=", "H4Fr7iBAA1ewFVUiLLq4vbK1pv+KrcGfkRBCCS6Womo=", "LpUGQLnLjRTnD4Gwap29T14BuBxEjO3ywuoLdT1VDp4=", "Bnl6WfuAXUzMBBFm1x0Hd2O1Cx+saFEmyEQC8C9WUXk=", "CtIN6CDAHbXkyACr0V4yObU6OQ1KSmA0jvwt7CRPgdg=", "F0prh86o99w6euoIMXvN4YLrKqOckn1Gu5sNzXCVTaM=", "LNtUc5Q1bJJgXHtDq6mu7T7DOmrVFeVdjfTmeEhxht8=", "LQAfhhacf+7ChDieOXRcGmQ0X5eL3vqGLoxz9/5hDZg=", "LkC9HZ6Ma0g/ke7qDn9PIQqnhlA9Il4fz0EWZzVze0Q=", "FJql0QFenyxQnjblR94xLUH6PV1KgGKwWqzacOo5I84=", "KEKV6RAZY5iUXryQkEAN6OXFCd0Yqz9HQ6XrUhvafWY=", "Gh8hvfFilhAdvLqUhU98SwXSBqHQi4eW5oMAd935kHA=", "JX+NXmmu7S/34ZTzmNr4TQU5Qb/HX+pFD7ykmDibIhg=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "IVxgieCppiVskB4z4wasnEFavBh1pJrdTebQQp/egjQ=", "LLu0gPpo8zMW8NMB88vKp+rqceJ4Sg+r3M/yrrqfcYo=", "FDYZqyIS0ZEaWGvg9qy2uDgeR7Wj40uR7tg/9Uk3o00=", "I4Xjya6VoEWel00pzw418oMUTLK6E6qRS04XrlyYhVc=", "K75+kJ/eQ5CnzZRODzCRA0R+kfP61At1JzMGP86gcFQ=", "AkMDdY5OpCpFoEGdiOQmyVxoylgRl0xbDDq63Zwp0rU=", "Jgu0DF8bIvuH3t2hcGxgj3j94OW5c1rR/eY0WSRNRnQ=", "IfJzAttPWyj+iEWAbzj/HwoE4oQ0o+AEO8tX5l9vdfw=", "Fslb7RXfyVShpLolMn7hTFsNz3b9jcxSkCcjDpxKDZc=", "IJljknc+MMjmTXkrAQkH2ISPKPaR6LLeE+qCJrrqNNg=", "DiAnXBQzPfRFt5S1Fb0HuL+QvYA1z0PP2EWXavY1GaA=", "FkIoGa9hXEqUevo+JyJ1tdW8111JQEK9yB2EzsMPfxo=", "FjKe7RiHiGMHxalHBu/jF5UTbt6OlRG8Qsd/+98iJ28=", "Hp9ZqjU11ZjjLemko3DG9OX45gkKnvshgVYP6ihRkmk=", "AwPffa4gu4YuhSIy11+09kaKuFodNkcsPc9WfLsjPb4=", "EDxClKZ1RGSNrtouwKK/gexA5MAdddNb4KBP7DKQewM=", "DZ+4EP6SCnla4sPcG5usDsJap98uNigkGs5oi794+no=", "I18u3tLAAkoD4fBQwaMoILPDPwNEWoML0GvtxGVL0yA=", "J/5KEO5I0s7UMqR6Km3UCD5P252c9EzkiJucfVgbpSk=", "Bcl9T+x38kJjbr8JM/N47rdEZ/qrNHfWuCMJZtsenlY=", "F7C31XDcdr2/PPXT3vN+CgBcm04LOYA0kMAStFPtYLc=", "BAE7c8o16wKDdGXAFq6L0TmUwzX6Bd5Cg1ADrFPORsE=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "BO1JHSrxg4jaU3Ed9NKTGBJb2uxo+RNMGz9eO9e4Mbk=", "FuH0PYeNLPxA5YtedzhtNgzTk3go2GMKwuc23omw0Rg=", "BF99l81Nlfjk5lwYOGnUwV01TbleUzTqGl86DDStO7s=", "JCr4DeCulgf1qtQlBmfhzUUJla+qUpPOsfGEzJfvJeI=", "LRSeYxn43+oeLBiT9a/YMlAT65/lfnmzZV1ibnSNkx0=", "B4pgb7D6430eGm/pmXcAFHLLJypnCQHw2o5RJrPvCJk=", "FUilN8OBCJevT5GfXki1EutyfzxHxTzT/81eOlWWQN8=", "Hj6dKRlFmCkTZbe33v9V8FoTezQ823TAADcFG5bNwgI=", "KuRv1bKhCmkIdhpQwvceX5RKvxG1aOCgcPtKTN4OnXQ=", "HV27/YLC83BAWaXjvz23t/Tc/ie94nhuomBjzQkhzQo=", "IhCJky5f+w1yuNiWu4JDzj1q3rz3uuTuVpZ+KzSmOUY=", "Klup4MYtN3dR0Ttfz12Oe6EIfnTPJ3ISQFRAs6j6Vas=", "HtltB6lIdpBtCChSRWP5h0FLKkW0iRCSSBZZ4FPHKUw=", "FhnKkizTZU+Xy6XxAjJ9fWoGlbs68i6U4zYH9UXCRkE=", "CT+IFQGpARL1MP2RhRdv2FR180J+wTPLW8zG8nehats=", "JBeCSwCKxafoGepCrC4b8r7LWGYVKL3CDvY86i41Wn0=", "HvsJESOUhXPQwOa5WmKKYXVnlxxYB8XT4Iv1ZqPch0o=", "Hy/CXwMJNLYRVgCxRTggxMcPi0VNpGG8A893PQM8D+Q=", "Jjp3wKou3TFpRwBvu/Szzr9mCAnaiRZscEHFIWl2S2E=", "FdN/WKlYntrbmSOQf5R4Qu9vtLYSUfg3O5c91CKhuUA=", "B21thH/LmXVIwrEr6qajmHZWn1Pogc6GHYXZxBzkCCA=", "AeIgFiaWy+FXXML03S/tURfBFtUqmWW0NN3XkTJyxcY=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Eu7cKQRTzXfAHlQ+V9TXrg9uena1duiA6FLqi46YvcY=", "C9w9eKXQ86kv1pCyJ9lIrmypTUNC7OQVk1FO+tcIZDk=", "IgcpZkmFbwQ+LXFY9o9bdYs1TNAiz8BOgR4bu000aNA=", "IUMK3kwBRPgZp5srb4Salo+3WPdqMPPiC195mREPNfk=", "GnC9ym8RcBU22+TZkmtr6oegj28O+nVLETLdThI/fAs=", "AoXY6Qq8FJaRXf254qTE2MQhJqPxX0vMHY3HIf2BP64=", "DldnYGjUtOOoVvLLeyJTH15RvxxvCeNaZFqolTvEXt4=", "EFOr2/+/zaq+W3lO5r7136Nn0ZjnZElir8kPN1kMAl4=", "EWYNfUTbcxASsC9VxaGeSxoQBB4Aha/yb/CIeX9UoFc=", "K77p2wpBK6cxl5WUzqRc3qKh6kDJC+ofOs4p1N92eSA=", "EZxZpn4xLalw7co4P04cwXUuf+xr3oPkN6zWE25N1jw=", "KoYRmKC9s1SrxtJztPE4VM0x10XmJ8IeoQdiAkKo0jM=", "GorIL1eJQjCrx/PQEAA9WRQXDYIAlfO70B6XcUI1HxI=", "A1SLXgLU8fmIFEQhujfPdfoJY7FMKslhrElIKMHmVdA=", "As/juvzorqK8s8FFrine3rnscSO08ylb+l0FaBw2Zwk=", "J084+8A0tRuUmC3zCDLGmWHWVjf4CFQcUKOVyODc0y8=", "EVTC4ELOZZ3+RH71jgnkUUcmlFzFq95CdQD8VBGoo2U=", "ArYgPjBeGbdzDtJzH5lDA3d/wcKlJCLZKbpkiMLBZMM=", "BRkXuUSvo5nqHmIe4q1i6mKaNdKTh74GwHe3m5Vp4qo=", "B887T08nT3EaS7plLq5fz2yVD82vkud8EY3d+3ONm6c=", "EYRWjQPCg2gwC/VyTWlYNVRw5ikiH1IhZ29p4itxc1I=", "GFeDnC2LDW0IwhJ5y4os/mE43x6vZkmIjPVAllqzwWg=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "JlGO51xZCXavjiE7QuWYinGFQ45ZPJY1oo7onGC6w1c=", "I2RUVd25Ke4rWWyrvV9A31niGbTv2MH81Py2euQrtbk=", "FtASbC33KtafQZx0dBFlv26fbCq76VoCLvyQO2LSXr0=", "GVBQIArcvbXnK9Y+0+HU09VOTP/lpf7Nky6cVoQCHd4=", "I8Jrjwd0lpe/aYLy5xXJH1QbFz+go+jfy2vKAUmRNM4=", "D/rL187CIzzlpLkR28xh+H11m6bkZ4AXnnX5GuWnIOk=", "Ixor6sNg9JF/Qz1+qerxheJwd4kC5uCQ7l4gf70FdaM=", "IIzuGNqFCiYl0VAPg1ohbszgIsiwgjXDh7jLGGXtilk=", "Lfk48xDO3y34UwzD6l7xJU7ZZmdLwIqz8eoUgFe2yQ==", "Bcxx9E9JbP6NaYUAIqFBhS99rAAf3szmfeYmW2nd4+8=", "HgTPN1eW9HFOa1FVIQcDbRb3H9C3fjV7YaIBREnvhFs=", "F3Bg5e6n47gAruCZc1sHTTvukqwYkYob4EKtAA+GHBc=", "J/cYOsBO87UwfkUIc/Wky9H/cJZ33ho96JR2p1YhJ/o=", "JyxBQ/P0i3EdnniWTSf94GFMKESGGyPBul72Mh/mSHc=", "F8Kd9Esgjk1bcKo7V8ktDGXgxNeAeTAAq1s8556QrEg=", "hCZYXvBiskucTeQ54NugOOnVOaVK6MT6ZVSSTA9rAw==", "Cvrdxx01a7AeNEwDM29sl/z2wO2YIs/1EU6Ft/sY88M=", "J949kROmJfV450Vmol5Uux0xE2SIfUVWmdieZTeeEeU=", "DorloOyhRlZF3Gsx9m2DVtb89DTa8c+6WasIqRQX6B0=", "HkEBFAHpnl5Uj4E+tsCR8e19A8EAWv/RmE4BSaLlmDY=", "L93gra+0fORr1OXTG7joQOiy7d7YhMbAUioKMjsHhAM=", "BtBHoUck2hRq4TFNOKVZMD5TgI9v+pCvTy2zxS0pRrI=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "J+mHObDkQxPOMvfFtVKggUq+sy2pbNgt52m00PXJTCU=", "CWwOFrDb8UHmvP28Di9J0BPzXKw+QjXbOcXLNflqXoM=", "paStvXSXfSTHzuLWQh7nz14FNDiOX54JuBGgVE0e4w==", "AXk59KL+mN4cTzewebNeKPn9kYSSMX/lkxHuhE/D53M=", "L60UifFPU+U4DbhrEZ4fxKsC+oTsSw8oO8KM3mtziqE=", "J2V2lTcTcDmokvHDiusIPcB94bcopYD/9j+byq9FW8E=", "HjG8D+Ixuuic3R7ow989iwbaL4iCXmNd+bx61cEo8to=", "HlFsO5rjb4NquYJPHBC4amIrL0nwgc16UK5RktKW6r0=", "BHzJCkvnF4g+AYnomPp9nx3JmPkdJVVTo5S2t5gyYEM=", "HFbXCmRy2XLjVpjqzXuo1Ayf6fybBJJ9BkBK4QujX1M=", "IFwFCIVB906Voj9cfuHZkTl46Y+nWbYh0NLjsNV8WAc=", "FodPFXhzVzWt0FQEQMsEKpZrjd8+UbTYEsZzd2u8R8k=", "JA9gKv0tl4iL9LZLI9bkTOxzSidGz0WAxDD3Lkb+tFM=", "Gr6LEeC/oKWClWi2aTTl2oO3eOz6RS7iprcUDhkee5g=", "DCdnYMkMZcnyKBQBheQvOngGhAyIJbzlYtB2agbazdw=", "CrfdGNCATTlEJPK543Q560vzMkGYxE56zHjS5ZXX3d8=", "B0q+RrNNHauhLx5448++aaMNzCsJCJfAQFZPAj73ueg=", "LyQP+v3Sdhai6sNhgd2OnZ/4L2K1RTfEjUl2CYWCgL0=", "EAnJGPhOcYDkhkwOIJEgJsYmmb1WLuW7JKAP1powMy4=", "CeKUlhWbcLNPlweo3p7CytgjabLRaIXpi62jGdaeRRI=", "Ia/fo30bkhja7wt6u7JuTWI/juQSk0/o68qdn8wsZnI=", "G6e66bolRqsvqQSHcVEGapxc3UQQfYqoKbqOoGELGLM=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "IEglb1fJyMJDN7v70JfCYn3MDCrgD/Vgw+gtMqVaTUo=", "CIJ1jFWamjjtYNERPaImAKw95iqMyI6QQ0LfvYH1gFg=", "BU9sEYWlgCXKOC0AZXzqYMlmdoLAYPtfL61089Bw1ag=", "GNozBx8OvEspYtSwYRRACWCKronoKFoybAuo6ww3AVM=", "JxAqWHUclqCvwYRoAZN+ziX1n/dmdXWNU4jM5AOrSvM=", "I0AozIW4NF7aOYvp8/771tWZc97SnG7lL8qGagex96g=", "DDdiZ1Yx3XtSklZzJoG1tIul+tNAGaZbHvGRuSEbvMU=", "DbkH5pmE+h+AP58Z1gM5HsWAuz3INX0XDj1NvZwQfm4=", "HFoRJrlMYtBqKy7FgOXkoWXeqnzRv7CHJEDelgaQDf4=", "LjqjAerU/ctgbprucrp6LLkN39chYq2UeOlGmfd29sY=", "AnnSC3hvtqesXU/F14+vnEejCQvVYbL6QwxdtkpVI5Y=", "CpUcy+XX0TQEzOP+YHUUd84QiBAt+jcy4yPQVc84NA0=", "JqjUsYcEpaqOQeplLOL2Dnl1wLfrR4q8VboMy6+BSek=", "B4ckczV2BGiRglfn27OPl9+ttgJW9gPVEQT2Lk5mKVM=", "Cwp7Uky3x1GUNhZ660tbGF0WwRDCs28WKr/Khys/SJs=", "Ae/O7IN/J6WSgk8VZE84iRZbsbxW1VZhealRMzslU5g=", "L/p0oH72qiV5ofaPHeZLWO7FE4DH3Om4lmx4m0d3/gE=", "MEWC4D6kjb8wQ7uvIW6llw1J4jrq5Vt3T/xhWugNG+M=", "H+3m8CpFlVZM12j9QAy16qKLK6GRJAAw4ddX1qAZU30=", "HjMYc3N1Cn8oRCcZSHbI/wXueqlNWzUU9gg5kNStBWE=", "HFoiNh6RTfriMdY0rSxQKyDoT+2k1Qaht5VRKOmyS7c=", "ExAnPAJzTmDjsfTHYHpIlhw6uX7ZaQwrJsOONs9WNhs=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "LqzlA2u/iSsQbWrSW/Os3DyUg05gzTgKGBXMRiDnncw=", "LPOZsDYk8v492/SML6Mm54jztuS0Rp7w0+bAzCQbe6k=", "ItQQVIMPSynOaIK0mDnplCrnoa6EttNmqY9C97r54Yg=", "Fa59gwdbBH/TZ2WftYiAbyO2vjtGkM/DypLGHnH1x2U=", "KCX9XzPTYnA9L8kCV42rdcpwduy798yRbU7T3EOzoOY=", "EtElBLpUHKKygSmmc6z5bU8kbjQFdP/N8k262ZvVcs0=", "KWU0kKBTaAMNNpDUSX6TD9Q3CwyJ1ZlrdbQg7IAxidY=", "IRiOz8m4qWttz5m2e984ZjFARiKewHyHZ8wmrG0rwWk=", "BMpSH+0W5MgnH0EBUUKACT0YnYS7QSnS5Uu7FQi3KQg=", "J9hnoEavuww80u69oIjkdnUrCMRi+hqR7/oW0iQD5Kg=", "HnVOd0RIL21D5pkPYxo12VZPBIWhFquXHXwboPxq1ik=", "Hf8SxnmiNYh+bIljBLRuODPyFjmNoTOL513fui13vOw=", "ECn/08qIEALk8Ahy568ymdmul5oNngI22LxKbcNtrAk=", "IJmp1mtS8P+IoRC/MkcUbcKjl3e8Abrgyifzs7o/H1s=", "IS7T5CTukK9I8t/Bgop45MUPqzZvUc4/pxYWTIl4foU=", "A/5IrcteViRubMiWi8CmLrqUmEoUcrAfWkR1YoqjjMo=", "LXJueQ9ozlP+4IQeGouP42uKdWs6BETqCK82mrb/gJ4=", "Fo3lfy9aejG3uclsy4+3sz/FRcwZRSzHpTQrcM/3S6g=", "G88lZobeNfZy1OUs7oH3TFUuCAmbPsuMjoNIzT828uU=", "BvfR85+LyPoxSYTYj+AoPmS0UuJg1HRflRSgEsMcyUY=", "AmcVisCifdLpT0Iihe6XlWWHdRbEFGMMpZEe/uGo4xE=", "DE0W69TLBGv44Of+Mhij8jVRx56DiOZbHHpVfiA0+Vc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "IufykXchQHI8M6jr/hU3PwRo4pXRtyT26U1SKr/V9TU=", "LFz7mXTLIpkGn44hMp1U5exPa4N/Fyfa9mohr4WLVqg=", "J6G13HFvj3Dxjm7vNsoVul3ylfm2Aj0Mi4YP8JSK6c0=", "FRCBS16eph9H6SS/myFJazkeLv2XVUsFe9nWkF6vKPk=", "Ic4KfaQppUUVkn/MF5HyXGWHZs5Ik0zBk33qIE9kmW4=", "LiYXRoreg941Olp88/+0qtrRKwW8tlzVcMcgAFmVa4c=", "KEBS/p6CIpjqia+reEYX/UE0SAErinE9i423250RHw==", "AvEpnstmQjPBRdU+msYncsn5F+9f01T1lf0VGnOWEPI=", "KonYHja05xaY3Slo/obIv0rL6uw4GYXzpeZ6XqExjR8=", "G9kIQm9E+A8CUUdCtIYKcsAK6Q3teqRyCQ5cEGLD52Q=", "GkPp2sEdwRrCDzzx7cXriiXatDidZ12TIiN6Bc/GuVw=", "JpJpnDDSz86yPVid8qWu1aghm6bENtDZIAM7IlTKaig=", "KIV/fahrEXzvzBBfTlBO/18R3HHh43GNerAn72ODq6k=", "DbT+ut5Qc4sauHQFv9RtIMvUoiKh8fhid1LPG5p2xuM=", "GHJDYKQMxQ1wRuqx88zW3tLtr8XLTL/9ub9zTB3/M6E=", "IYfUEYtfdSY24gXrSYIke5XasDcxA0nd3kcceC5g+y0=", "Bwm6fs03RoATTvWOlANYIznjpVFm9/OUPygcV6J15Yg=", "AgL9PwXSvY4tvPbkTT7g22z3LtU7ALfweFYF2J0TnOA=", "Cadgtq9LTu06tp7LBJinX8cbgVtr3kpWnTm2CGCWiY0=", "Ihjmq9TjHE4sTiHfyKJm6UbFmf5EuYE/KC7zrG0k7OE=", "A/znSvIRwXiJiiu73oRWi8CbjCIoSB962H57Hc3mv4s=", "IgHWrpOC3ALFNFsUHbJJwSCyiIYOyPmdUE6r6OfyNXM=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "AXtUmpgwVhlwC3ItE5Lj8i81FclHype94s15p2Hdmnw=", "EyGRG3h7bCn1i1ClPWbF9DaEgQPzM6rrpVieQ9sSCOA=", "CbpXZScpeWAvTFnH184VFvSBN+YZOOMEYNJisi7+H+I=", "FwW38H9aq+xRcDcTcUeF3m+GyJnZfz2Jq1NFmAGtd+Y=", "GKxFF82cPZsT3TmOXOYUAiBCs8zIL8i7q+rpOK8eiWo=", "LS3PSnVcIbtJtAKPs92L+2QaCPANBFKFwMpkGAI0om8=", "JCDnZLx7pjtwa2s5oQwJKt57GHP8GuG87Lg3STQ4MRY=", "EOqvs2+I8Z/ap4rjmvAd2d1cMSbrh99BqlWsNE5ECyw=", "GttYLGaSOFqM79M+btPH8joyUtv0zg6oCyy12VeESlM=", "F7PxvwcXdkwvAVcHFrZl4qswjsYbUR3T5l1r/KkDChs=", "J5U8bEjeENQF6CJbvMc+qfv9/MyvCj7agM5Nfl7CchQ=", "FeeU/sdffE9+Y97FcM/64kfYu7HQEUJw1EvX3bWrPIA=", "BAYytEVMWbKCVg+BSvsB6fYMTyQBPLGo1FDy4jvOnV8=", "HpwOBCR9jh9DtxNQ2ZFBPu+2fCc6OtpybhXYFzdxemo=", "Avjccxo2bd0rdsC9FBi8A7IH1wZVVvR5bLMluN0dsw4=", "JEY+U5+mEu8wKAOL2t/NrePIR14GN/pLHdPOELCqy7w=", "AoditB/rNeZQmtM+p3vYiYPm+oXKL2c4oaFlPTv1TVI=", "JHxEvjJtZ6+QICJETYDqkHdpNqgVkrqmcCACsn1rBzc=", "Co/7ZST6yKOCA3juDJrbI0X+qXESwr25pX3TsEvn9j8=", "Jk0zTxSAH+RBd8z5JNIukfPZjhzfXGOItzXWD6MscAA=", "Gpa9m/xUMuopokrjxGsSZ2nS2PBcynDbqxFxERfy7W8=", "FlQnNKDEmD+LggOo5n8cIpD33megKy5Chb9dHDBJ6xQ=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "BGIIZWRk1K4KQg9K6/Y7d10pdO4IU17xEBTUQAzKgiw=", "Ffap7zg3QeFogicrvrmrE18pUnKtfkWibgY6r2VglKs=", "BAqJhagyPdOyrTwoUVny8VjbSLn973LIyFmkYtfxF/k=", "C5tMfe2X8af7sdvMuPrQmtqBg8/tt5Di8Rx3B0Y0qA4=", "EHAERrxhcByd0XvENUrXJyR6mX7J5UHuQtnQ0qzDduQ=", "CYpAT9scN6OIQnUqMbsdK7URL7QiurQKG1Rrl8cZ2SM=", "GEO4UNXO+Icb/R4xUlmWQWqFULdIzJ/RP+QqofcZO/Y=", "AnnCj4FJmh2Bn7ZxMshCINEktmjMIG29zO/pR4NYqX4=", "HW+hCfnTPZ4UTFsl/VsvGJJzVF/a34ivPEp+8fcYnjU=", "HonCOD2SDIqAg3vKq8KukGC7pKUg/H6qf6XdPfwY1ew=", "AYBnDtsMwHDKBeqnJMr7TtAgVhFQujQ6xYd/2Fhe3Ns=", "BEoU0fcx3lA+zypkOO0X/4pVKgHZ+2ajb70Iruiiems=", "ATkWRLg6ujx8hqgfJA77FH/kwcU+CK49OwqgL8EDOwI=", "GpNz+pKGczTsF67fgz7xn+b2emjQMfegiAkXMLLVvJE=", "AcXEamhS7vr+45uPMZNcMyX0UAAMrduzVTj436ArP+s=", "GFs6p6Q0pyJQV8a8yOaBgN1ATljj8KhzP+ZKDB1TQQI=", "C1YuyplBJ+yUuQ52JVlVVRzB1uhBKRj5qu0TjhnLkD0=", "GrLbCuR5MB3uI00jGYgpj9Rr3PPRrYzBE4nueAwK8fQ=", "AuyMP+tOA6+xFALVkp+8MytbtxCf4yalr4YT2r6aapQ=", "BNw/sSMpsXpwt2CuddYgEziJKDy/iANVBf/JfORkG8k=", "EpfS7JLfmPGsGjGNwQBVcjfdnEqWaF8dWND7Yf/EwJQ=", "CoTF0vSRpAZU30mS35j2gfFXvJ+0oKasGq2eDplM3fk=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Ab5rA/+1XqoPz6TsAHrWVcd23c1i5xhN3gOxyQsa8AE=", "KRDTGkq54Kynnt3SIMVpBbyqLb0ptte/OJpMUGZiGaM=", "KDmr49Z7Aeac7SryyiDbmyvzWSMNe/PGu7eSMmJKV/Q=", "LQxQYJ/UgyrEKLxu1GBtxeXMSOmWXGAMgTJajU74euc=", "CpGAQGiEsgO7Nbr7zy9KvQ/+kKqePhqCzq/1VtLiLcs=", "DV43YUdbo6PVUTPrRalFBC7ia3R+PrQqB3dJ9PNnbk0=", "CBGRnlvwPuAEl54hZOJE8exRDq9f5uUQfl5vS9Ej93s=", "I9krNf7UrMvcB0aV9tE5PFwr9vIWf+I5sgKdVleUBbA=", "EAV2xWOtAMzSsHr9gX3S+NuiU1tcON57r9CGkbBJM+c=", "JM0YTRQxljF74/WU+OoJHzRCq882R8UL5UXlEJlN2Qo=", "EodImTpYzv1luvyE9IZIiJa8yAiABqP3r6zCiv1vo4A=", "ASaYA5PZ9pfP7KPIz1qkZs92mceyTtH+K83LPZjgHto=", "A9U7GwZZyVzvNaUVaW4T1nZDeQVkqA7j++PFsv99u2k=", "Cxy8EhigHMryJxH8r/gFsFv/xF0hRY5BUn8G2/Qj+xA=", "LSuUTU+d/YBHK6tPDOUg/KY190yLnx4coP1S7Ir0nuA=", "KG6nBgB3j67jODk5+urWmiSCH7QAkgd4x1KaGxyQ9U4=", "Ejjgg3gERVCoNrz7cSnw8NYlPrplTpYDXeBlE/buc40=", "INOLKD8fCru9ma+B0ibMZQOthuoaLqjpQZ7xWnT4rVc=", "JfXRyUpEI8mU+B0fVybIEzxdJBn6WPImqUwJthgVws8=", "G6SUjHLzNoXfD56y9mePpr3eDuJh+qsKY5F/3DDwlzw=", "KjBgh6lFPpbQAHrHBgDD8eCLT7XO8EIytk/owFmGdM8=", "CeUovK3p2bHpntU6bKh92NxGFA1X0GmajxIODHevZb0=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "KneXJ9erBtvVU6hAKUWJKW86q7ajFK+1sIP2UOOduWc=", "EapxJ9zpfG9L7uXb3eHVx96BLic3biSfQaUhccEIMkw=", "Lm31ZcrHOkoEwssf5UHZ498AIFRiLHkKbIx3jkhNoGs=", "IkxN7AB0Muzqc+VIyr9ghG0Oa3LtL0yQfdngPcs4HpI=", "IJUZTi7KtODnMexuHLsK77O/ZG9ubIBL5ZcRZ+vFj3Y=", "LvBXBjvlcjPVkTfbdsclLx0sv188TGyMyyIgPJjW4sc=", "FRhbobm4Bgdoxa8PcGNtxi/CnKUQDXb9T5xHZ+j4f7Q=", "G6J00hhL/vLQvphvwtQWF/Q9KaMLMots4/5BpAZmlTI=", "J1KPc0xmVDkByxr610FIkq4Uzbde1fxZ/tz6o5n+dMA=", "EYUinOnBg9fc6KZJmWI6RpOSym0uT3K8K2xHcqawSJY=", "CzayDDP4PSDBxJwAxluoXe7oNF+FY99EiZOpm+u+9tY=", "HuhDOGs6oMOEcf58YLY4IY75JmtUKpsVJt643JqjxVk=", "AQeXL3fgOC5dPP9baFjoX+bKKc/pW2AVmp26aM9V6iE=", "L8RgIbmEHbndPN485YeF619blgDI1cD0CGEwy/smH1w=", "IrjHBbe2dbaRNDx/GfaOI3ReVa7fXrkxw3vYlWPxSo8=", "HbCq4d6KWBdwyJDeXmbHYzAcxtUirgQts2bzMOhwE88=", "ArF8GbL/ZKPZpb1c0NSiHK57fXyJkigFD1k7LaRmUtM=", "HjpMLJaGknSV1sw8bpC1Gd7/C1XuMSTWnOUWHJERm6o=", "A4RgPcyOd0hzmk+FRizuX7wlNF4C2yMfQOUKhRdYRS0=", "DoQoZu4VmYCZEOzePXyp8dhn+WRZmFuhGbUQZoZiJKo=", "GcCdhWfpCmIlFv0Zc84nrV/LZquoskjQbenqMGpvssA=", "E0F206QPG8rZ9Ta7kriuuaTD1CSxTN7Jvu13v/vnVM0=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "GRjAZpOibEHwAlyZ6Tq0YhPdrCJyFfvl0ZctzbYmWvo=", "LC060A/M512mpfUQ1ZUpGPRGAWqPtLHcQa+TIYA0aPI=", "GP9HMWMXM92fBIUDtIG5t6vSrX3eWgAtjg/8Ql9XTAk=", "DRSjFZy0WLTF1ldlsVxWZTvizeIC2LKF9cLKx+AdV+s=", "CvfUDb9qnS4TgJXxSZ5lBcMmQiKC8b0w/pjRlZApjpY=", "H3KLYiAPhNVv2RbxAzhoBmxf+er4Fyasj0PwjzEb2AY=", "AvFQmoBKHmEoR1ePSe89TPAGet88NXXbqzYy9ubj3Vw=", "BBxn4BWzdwchzkuWrmIZ5oE8z/sVLb+hP9N9JbqBLwY=", "DDNng/xBZ59n6Aji7tG+nNo/zuKwQ5SBLflfn+vUZ6I=", "HjS63rPZKoiqhN7Me3DqNEyIUsmhfT4Nz8/Un50QNUg=", "JTn+1kyl+LvUAWQEkhopLHZS7jp/ujFNZ14C7ynwEJU=", "CoOULWDRT0bDyc2qkDkPrMxPzS6cPsjMBmBM1RrIINY=", "JyT439cOAJTWE/Zfa0jULiKpYdBvWJyhpkt04Lqa+KU=", "Im4QH81/NlrDPGCIF+5qTBQ1BJJ6/6uV9Nf5XaVZg8U=", "KV2BrecXFfDJBxmGs3cfqGIb9jQAZGPfO1Pe6b83sYk=", "FKrw54yliE+91igtwqIAihthZa3/pukWCp42GQ64Gvs=", "JlLmtm4yOHfqzcTg8y3J9y1pKudQHX/tbJYVRSn0Wjk=", "D6oiv27n7VHrsIfDW9M+00vUR0BzNJqA6cllSIMJGpU=", "Er0djZIssg4dDgLQZrEg8moZefQ3S/D65DzcwOWjZvM=", "FYwaUwftDRi1iYbCdJaLI+QECEp4q6Vofi4sTwCWBuY=", "KLW6mVQJJch0xrgVvXMD3793TF4QEu8rMFykdVn1l7M=", "K4RdleRC/MS7ikm+dzYJlXtXjhnuKLqogCJuP5EdJu8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "G2bnnGY77Ga/I7XLvL6brDCMR4F8PyQtP2a21WW+O5s=", "B593X0EcnJAUnlnmo01vb0eUfbQzfZ08GLxLUdTK0nA=", "MAnWy7UNxoi3QEz4LVifutQ9B0IzOSe8BJ5I2mkT5gY=", "H8cGYQVP2yER5JkHIiOHrTEQWNc8C+/WMUR4F141aUI=", "HuBOi6AmX84zBYVRiJQCm2LZvVDJ0Kb4fxKA6ChZ6f4=", "ZE9Sa0MtpYQhRW/QDg4pKR6NDfLtJ2JsQtUDxi5PyQ==", "J+md0Pj+LKaIPqiXgVszPeYWxWxIPAyeRSgwZ9/zxLg=", "BYGsl2yt0rHfwU2LPMYE8ejnnc/vJLj2cDLBi5DBfpw=", "BnUPZIVw0e6lNrw4QuipZzzFZMl4Tld5NHW82zmUV/0=", "FYIrdYzp3YZPohIig55+6kEy0bgAgZ6glaZGXZzmBE8=", "DZ7ikO64zK2Px70FTX4Q/z6w42FfdwFR/monbVPadzg=", "Kv95qibRldYAHAgFs1qMBaCLWaDoGcdonxdqsp3rM/4=", "I3+k2fovqEtY6mjXWSev7neKXkdgc6mzDWMorWLy2Ac=", "BdIJNuMItuuDc6iZ5gKDGuDLCRq+oizwRN5vDL/mcjw=", "IEcKny0qPK1dL5LDM0RLQpMzYl0OB+Bk/ehFT77nZK8=", "Ll7gYjk7g285EXG1xzjl1zHeSegzAxzpcFVIbe8tahs=", "FQZqdF5W3usRO536npLsH8QAP42s67Ty8KWR6Ukalvw=", "Fa8/N0fufWNzi0sTe+CMRPDJBEgwfR0tl3iP3K8wI4o=", "Cp2y69Z7z9DFwuK6+T+iBlN6C+XildqTNMGVFQGNTew=", "CdgZZj7u35zluX1xq8qhlfasD/yi5KmdiVEL0p2jfMg=", "BD5Fp6tV6O13DIuxQMXPmKB58KKGx2q9EUhq3sK5ppo=", "JnOQ8zm+kXwYWI7H+bU+3dpCu60ORDUdHNRkITibBtc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DdKt+yqjtBKLCHtSUNXnVGcu8CyoSVpbj5wuUdEv4n8=", "DkS7dqJWdA/keoGFlrbc9AuduFx0TTcBv7gIoA98y+E=", "Bool0uJ9pDBcrqe0ftNdlxJyD2VNctCU5NmzeWzoiic=", "CmYksuLTVRhDcjl2yRaLGs0/8ZaASmz+YVVe0ASMNVQ=", "KDDDk32phJO9piiEmCPmVq6pbzCfQX7mpJBwCaSVf+M=", "Hb+rVCrRqNGwZMGPLagrblMg6ChdM9UkIprtRNoPz88=", "EvBJlnRTv0PazxmKqsF9GE9EhQv0mCCzfzbflT5XsIs=", "L/C095QXn2zU0EMdeuyg4yAnCqOw4/Y9gy8YMM7XcPM=", "KHBFlpBzsbqAB7ZfNR7hUtm7sOaMdfz4o6Pg3Jy5k10=", "CIdQo5D2elsZpj7mnmBVlJAV55bUGiFQ+Lg/WMEIa04=", "KhtoS5NXw7m2dcmlbTaQ07EB/0xQ1bf5fWjWoketbj8=", "CSSpU76xD9q/YIgGi8QtGMR6KS0z+xKx3RHAlCBRpfY=", "BfuB7i4axeGYxi6nZycNO1KvHiTU1oV/gsLvS5Tzl0A=", "Gv4aeDotaM6PecrLK8V1AsbF7JrAu+NfVbNL1NlE4Vo=", "Eo5mudF31Yivn5oQ69GV8DAwyygGVgzOwcBGns6Kubk=", "Kom7/M/7ZHMS8xorC2jXMfZSeSc0RwIbcW+NfRue3b8=", "LSwcyDRgCO/76BshnY2+w3u/Km9t/urDuXm3YWY0BO0=", "KhDfSUjrtWptHt9rLXvH17w7OmCFVlqQvMr1NzkJPrY=", "KfCpFXmwQYzd61/kA9E8kpF4EkcTZVgzKEzkOGZzYl0=", "LWADLHBassjkV+4NIlrLIGpcq711sIjZdlbebfg9sWU=", "Gtxh44iVRkCPIdHhzZUzQVp8wXdZhGR5nahuMXeOqFQ=", "FdJOwoE1Xiighd2ZbqDJCqx++12H+b1woqa522tQt7o=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "G+QGacQwWvCN2c/rBbx/z6QLmYvHT/4RMCxPWwVTo4s=", "DeDjM2IfzQ+xHjaAX5cit9W1O8Oc7CxjoC/4U/MMBPo=", "IPCTDOKpgvY3LoSrUxC+O+rhsLf5C45WLCbC51dwLUc=", "KZpCXax9OkyHeAinRZWX/aWYTEIraplNgeGV8wOF+Nw=", "LztsCF7PmaWLdQfd6JcaIlxRG9b4Au46bKzAUw6KM9I=", "Adv9G+YoGlx3tPssfck3ol3s4wHdNx/2d2nskH/3bHI=", "IFdxiCinF4IJEr96q+hddNDnWdM1fbIjz6ERuC70jzI=", "AmNOcQ0yjbgqs9XAAKbhbkyrTPC1wQl1v2hEiN9dd2c=", "FQjXPjHv0qArYBpxUcoXb8efNyH6aG9zfWa0pDwVl9M=", "CrHHV6KTD+cErUL9VLGRBDlwd9XlKUepL4ELDvXYeHE=", "CdpJfdZMXjJzkAY10JGT3wbB0kJqD9c9fd3JnBja3fI=", "I4FXLjW76dP72zux8ZY73MxTWBex08B35R1/qc2abKs=", "FDWkn5KElKSeKmfkAogQ4jt/JoQ9HiLi1ze0DwHaEaw=", "CkHNtUWJFWqrWRgAI901N0ED5aS750btjy/D3bJvjiU=", "FMSE/b42SRk0oe2gm2O4bYA+cFnNjjMU6Nd0t5EKfPw=", "KnekAC2itOKrQyMqyG6PqxWGuE72BwXU9a7yaqVCF0k=", "D2O47r88RTW9oLCUwAe+w78Ou4iM7rlXhYv9QeOzOkk=", "EnfT/lYZCJUIZpsaUzcvLxDqCs/QfmhCGbdSa+NWbWk=", "JCvtkHREE6QTvi+TVmSHrs9+018vaIbnm5X87ZNkjS8=", "L0IfdTbW/gIGm0or4a3viFmD73/4evW9u3OQT5bMcEQ=", "DcuNN9U6XfD5/zfZ+OER4AXXDJO8I1V/YEFxGhZ+YqQ=", "K41SAY3kKuJ6iWphALAsu0KLzvf8lcIeBjGg7dJz7Pg=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "IP/ARhI8nnwWHsL8ADNnGTixvbu1FQS7SKa7dpH4Z8Q=", "A3//QUn0Q55DjOFi0nraSFjQKS/dXLpq2Ity5z5VKy0=", "HejI5hX6YI/on1lgU/fyqjshFYzxEW62vxLpi9xc0zk=", "C+MlHNrGgl/nL19wHBkhWGnCHbPhRvrsG32D4pHe6m4=", "Jcxo4BVvtAb+ah0Bv5JiFHBZN7uy3Vr30v63DNoEsnM=", "Hm1BpJ+HVFWiDjlcL1RmrETZBsW3fiHKsXaTTW7JL8U=", "LmfJH6rw1hMDhYvc4HSi9hIg1il3pNaWNkCAhBMnPzE=", "DRL7QvqkXO5XdNOBRWOdwTk+xDzuxdVLjYH4zj10y0k=", "I+cKQUYTPwp3pOHXQ3IGkhJVMeS4Ptr2ysFWr8hw35w=", "Lfb3EOwnwtZSGYYTr8I09MbWXOHPa1SIs5hOCXb3XLY=", "GVzlnmntkUG1FHm6B667UO2g1AwWM1wdwzcVgbAGudg=", "IQ+P2X8XB8T/lhDa9b7Ob9Kn4LTGGAFmK6OqF33sySw=", "JfG3aA4R9E/3RlfS071DqrBEeY3vKLQ151aGYG0Sqmc=", "Cyx1rFpfttK0/VElbTqoTa+XzUYR5Usc6a7CbimLv4g=", "B4OYzaRzFzESEXQCYsCHELhtYcVK5VY2pNFSINpbheQ=", "Fmr1q8asIhD8LkjhejQmtZe9yvhJz7U106SoOhb6vYQ=", "JxlMp5rEdz7JZKzLNeCb+vYPZf7Gn2xTpFq2p3IEENY=", "EMRtPCVNV/SamFx0cy8npAIjLaRBnu6NWcOf4NJWdP8=", "FiGIGWeYWuO5ae9VTe1+lQJ8gKP9JKyCM7cgTEa2exU=", "KOiTmUNDWXvi9Jk9ppOraKG2Uw+hh+Bwjm3d1l4Z9l0=", "BbJAV0hQNXuTz5nCpPo5Up80zVaL5bUf1rusGdZqE84=", "Kj6RwPVYMkWkUZ5tX9N1MOqX6r3Nng0mVaxHCaiOa1g=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "C8kVbqeBuy9KSKaXGhRjw0FEevdkDA3KIv7meKqvpn8=", "IWUy1npiBgW8I2qj2ZZ7uhMsGO1NyfscfQtuQUtp7Wg=", "It25HapKRUWQHRJ3KxRC9bpOhe7mp3Y3/DG/UT+xFu0=", "JoPNs6Gid675wrnMQtmDWshzH0LujB2XyRhD4zDMeX4=", "K+STdxQPVd4n3ZYF564EOL6ofhAnvhzL0nVHuxiCpx4=", "A6yl04kuTiOoLjKXCuBs95RJeXRBCM1AFElYIPPzyvs=", "Z8V+5CySWk/X8LcIBehxsd6lwMZO7PKG8Bp/gkltDg==", "CufO4yko6LtLLlQo9u1WczqVXbtBWWHli9pFN2AzcOs=", "Jwxr5yaoiJAMMl/Og2H+4HZrQXgojimJLkOsS8WnpTs=", "LcjvMbW0id46AhjMpSFbzSOGCJHUvo6uAb1rap/Yng4=", "GWQ+3SDXGYKkmgnLHg232YHZKEE/Wu10ogszmkXLOho=", "DKyGz9cMe9D5ZOIYbvqDA1aGba1UAmVTkbFk2gcjBgc=", "Hiipg2bcK1od1lHIzCOffWpleEJg5PmdXyLTrL8InfM=", "Bl5XlGfuPK+av2Qn7nDj8ENQ79TyQKch7NYUv1EKbRU=", "BiWg7VZipR3Qnxs2Hul5o9kJmd5lRN0BLgo9DKf1QpA=", "FMoWDso9zxb2PmV0XB/H2na9IorxbPdNKjIqAsLmPpo=", "F05agLVlQidglkTCmyrh9zRkdQdblbzwl4GyncptqLU=", "FZ83OQOgqfobMPHneIe39KE8A07ugn8L3OnvwkTVAwA=", "HmpFHwllQ14YuMaO1SOl9XAHMf7pRrRGpKVtaXpl4TY=", "KSAC2Jh4zLWRTF15UbRZUuuKSMDUuMp4r52xXA//0rA=", "DMbIstxSZnPAOLJYqFCnVK09oRsBaQ7TWbEHPjes4ro=", "Kr/WMoXprID7hl/y/aXaIw8nj5AgAB+BcnJ71vJXBZo=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "KFS1mEvWueczgJ384df+W6Y/qNWNV+TNn1QMI2jbDdM=", "LoiGVBTytFV1SOODx/Ul9HHJ/g2NZPC4AB5jDqiK5B4=", "I3kO7D9aJA+DmOyjcZ3ZScThtMSDoWrrJor6692nmg4=", "L8yGad/PBPoGx1sCK3e4TQkN87gi27qtH7jj7pSOhu4=", "Bn/vZQpFcRA3ofIE6sKQRYA/qSLM+K1RgzTAOikXiDg=", "JI+MRrs/C9Oq+D8MQQwOVtnexiCCCukdQcA8KIwNmY0=", "DTtqAASoW2OoUGGxcdh0gMsmKx/kzNtxviEU9KixP6A=", "B7Blqcyra5cGabwyg420xIFH8GYfU5KfVhp6g1+51Wc=", "DgK20S1INiZ33wcFavwb9e7lXN7qZQRN4GSKDHwKeJQ=", "L6uQydJncgEP6RTkuIpx4y9VY/TUoTiFX3q0JHJSuE4=", "GYnC5UdBzcts2UQH3G7YTngXOEr4B7pu+LhdS80xPF0=", "KN6IkICGa94/GdhLJTR3YHBxw05ZVp8vsKoYC0TfFBg=", "KAS3n0V8u4CNA0A277oAEb06sEGcObCUpzQe7SajIuQ=", "JOubgCAS4ROGtO1axS2nCVfO+sXTkR7B8EKRfkeb+oA=", "FmbKIQESwyuxmyVqy6zJb1jMD7fdk4dNUAIfvGMbgMk=", "IHmd41gTfb+8YjxuSsrcJYRb0hTUBz9SuAJMpD2ZzTQ=", "G8EMRFJfgvmPRP6JUdZpyL0Qh+yPsl0IxdoR7xEX4FI=", "HY3QN9c1RNeNSBHODWtIJkRJFyIXz89nGG7uQl4Yy9g=", "L7svzWu8oTbBg9X5RYLGHxlKqwaPkVv+DYXMXUuCvAg=", "HuqqX34YNKGWVdgL8tqh0s9Q1z0Y4Zc+anTEhwMEdOI=", "H36wbZYf7eBmv8J3POjzbdeqNacnpgeAcZ8LmmJ/Vv4=", "KYH6XmZy2Xe7Fp1w4HDnOrnXw/IJULMkLpKVtFOQ9G8=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "KHdsdfVK4A8xkNHnERlLwD/znSSNlgJ1I7Fm+UKSCoY=", "Ckq3Mza4M5VwEvDnvMNomYSbLbePj9cHtpJXjhS4Ayg=", "Ieuumb6rOv9UGDPWjHX+UG2FfYkZqX4H45ArkZ0+FDs=", "MCmqm8VbjRrhKPRbo2jPsgiW/uq/Oblm0MEnQrvSi9c=", "AjkSiXN1en6cjSnVM20aU7J3OHtIr6lGYo9F0D66Sd4=", "EKBDX44y/NbNXYzrOjwHgie1y7aZZqdtfx11HllEedY=", "L11JwqucldCcsWCm3fR6B2P+Efw1BEeORdHQfmQaspo=", "EYGvnbGUtL3WX2HlGk99ViMH9XRVIuJlGYsyCuZJVWw=", "G50sSg3yvG2dVsdjFxgNiblmCw46xU4ufug4aKw5piE=", "H1wlAUh5ErHvZfByoQjx5s1kCx7rDcfcDVeQMgALhXA=", "Byw/bcla6/6r17eb/40Ac2cMX8pDtbBnyqSCjme/7gI=", "IyjMIXQq4V79u7owZ+ldATT0nKJTA66YcjFeKeqvPR4=", "Gi1nq6be3I9oOK9PIxjvdXWg3iUc2L1LmUTAqW1wOyA=", "Lq9soGi7z/3zbb1HWuko0QogVdwQ2in3fM/1IExQaHY=", "IzGIWY2V356pyGs42wAnBR5qS79L8ncR7RZIl4MYfVo=", "B7Ri3a2HF15R/outfLdWlzzndj6nMrP2Tfo4oKDL3lE=", "FLvQjKBSVicWpGDNMNDD0goh2wdC2h5AIf6qw6jac4w=", "F7qxLTJmVA9F1O6L605PASZ+KW/Cke1U0PQYGofgpTo=", "KhaKJjFwAw+IdDQ2twbf6C2jkZFPSS58SKL2LVbMnUA=", "Izkn7+FwoEfT0wk4C83S0se7p1QdrCd8bPzz0bsWVx0=", "ELnl8k8fTviYhtitP1cfjz6GM+tqPOegBVHRI6HeBUg=", "J2e397hydw2pDJufpXu812a4ePe/bbChJJ702rCMVtg=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "De2Fp6pXZ4VY2gSarbP4S4g1dRDmQkcCcxtvOemCTrU=", "Bmv/u6VANlWn7/Aobqgnl/sbeK1EhhLV5f/dUTl5/o0=", "K+RIUSE0YXNq0cYnRqRGubnqFX9ZLB1U8728oOgbHSg=", "E8ev8iPDUaATbNgl8Q5B2pN4lsPrFT5xLKu9wNr9Aak=", "HhKV/t4BSLsy14TGWZON4Z1jzY8HC3k/SvaYfUsKLKE=", "EI5zG9Zy/9WPO/s9ZsMoHamnkhT/ZndWwxkzMfFewso=", "KO4gh8qkBKe5yI2HHqlpBzwFqi1/jIr6o3L7vSn+yQg=", "GSnnDD35Z3oW5rw8psj0VDXxeBvH0/q1wtnyGDa8pJI=", "CzKPFcFNqHYhvyt7FIJVew4eS2Ltdx7wtcDcKDk5Gps=", "JGOSToVPwnj3jUGsO6TILprjOTPB9nPY+5iPUlfqSMs=", "IGssUPvZPkqxbyC14d1OMbQLQQu7oCFG0afnEgoL3ng=", "IqgWn03IP2a3JcnbCur2lExJ9/WeCEdBt03HXxei1YI=", "Exvq9sONKhSMkbASheco2DxbQDCfifLuHWnMrJFs+c0=", "Hy92vCOkbJ7VRBuODpEFji6xYWWulD66i2H3Yp84cI4=", "A1CWPSwKqElBAFt/yHR/xhNlrgOmAK+Th1PGI4QiPWQ=", "H0OnGayxc+3zzvT/V7PjtUQ0mX4DvKKsMWTW0gYpjOM=", "L/LIvhlkNzVj2WgE3LpttPIAQQnk1zq+QxJxmBycgAQ=", "DIqnRd339BkljZ+CnOerveH1vhND/4nZCll7gQHPMxc=", "COwCnWDN3/x7gdyJWGpq/CM4JsFkHMrX3Ofaeg1VIAI=", "CvbyfSIRsSruEKQFuhlZ+6MuTacBLJTfqCK2g4V2heE=", "I8yfTKmdMP4Nd4A5fXKBd15zWcO+cEcbxkghk8o7MYw=", "Bd5+iPYxSI0jzd67qyXhKPjN+1JKy7/qp9LQv0fC5/M=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "Lvl+gh3PypC8zCZs07fP6GA3yWFBS5cFEahFJRIEzfk=", "HnTA4BXu3r51pNVpVhznRBB9j09UBuZWhaYPl8AMDHc=", "C55+V6YofxPL+HYPy9G/uYjh3qL3C7Q1L+ms/FYNOko=", "Hazuw+JOcD9UonqIBNlg2EGvWgoQtO2PLVrKRrYevbQ=", "FK3UVZUHp/8p5OkVowvLx5eHQIpswxwHEZnoHwPtGxI=", "IUr4RkBeM7l0eiWxdu3NfBk0wQHTaiq7gclYqL58Btc=", "CPYsHkwen7YvH/pbJi3zFuMrdpQURFRExONFtuao49E=", "KBz7z9n+P7ozKbHj1tpqxy49QBSD76mUbKsKtTA0LFk=", "DEkwsgTRC/MKx5PyHdXPhM8ISv8o++pAR080BWxLgbg=", "B1cXkXoNTiEO03+B32Uq+Ix4Ik2Z0T1G2tWj0ECQfGU=", "ECNuY5R21WXh3mVbD4FuhZtbOziJf/6pzNydlVgN0Po=", "FlNVaNeS1DCDosihVeCWRcshTAiOQLcFiaYQZ18rm98=", "IJuC0svlYX989LfKBfC7HdgNwqZStQoj5o3oVjNO3Xg=", "ENCEPDfp/8wGkv5gGNSA30X5birUG/lTkZfrsSrl3LU=", "F195NeHW0om5Y7A5yFyxo//LovaByyemNkVmrPX/LRs=", "EvljH32culs0czFCojp2pOm9dvyDi7uGWnKuwXo7oJ4=", "Cieq9q0ZU/ScUkBCW1CRRMmZhzWlnieQbphRj3vLzfY=", "AznBCNPd0Hyu7cz0W6OhcpzsM4czjUX7C3uJb69hgRg=", "HH63ZLG2NyyKfxhUntst7J5xPsYYNl8WnwYzGB7SHaE=", "LQa1zERqyHFc0hsciIlyiqtNO15/Tu1/rvNTD+N2ZEA=", "GDRF+QU1sHsIsgBzugaVD1AO/z0JYu9gmiIfwN9QSws=", "DgX8BlZGi4XqtxjuGbzQTQFU7cYzhDVwrcbn0QWSRFs=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "BpQQgtlDmO67VKcBlmqcxFswOgmJclOBZF+9D/l9nWY=", "IuqdImBlMBElAvjkD5J34aM06O6zB6A+OSSrjGcB8YY=", "Fs5n6IS/0XgocvzWWxiz8nr4we38jd782lPzZpZR3zM=", "Efw1hT9IXwrgkCxlC5dJtIHjNsVT/dkPl2fYv9UsY6k=", "DwTA81JcVvUzsjpN1N7rezGTjfsVMYY+8cIGbodY3eA=", "LhVmj/O+ymUjXnkS/ti3zK0JKBNtsGCQ+2k4rOIH82M=", "L6++kW069v0JJM0pc+HiR0sQvh2yUs8Dj8MucySEv38=", "CXSbK7XmZog5yL5W+kaFmPcpJ4DilOR7FVwSMi40oL4=", "DIFkNFjFrzaLgdy0BarrMAC0wLopw3aFVHDPvyw1490=", "L3dF1vgV3Ty+LFKcY/B9SmRgFYQsZnhFZAaiSCUtD3g=", "JUAmGuWyo77P4MzeZgz3Vs/fvo/OBxPAYdp+rm5b/80=", "GvUzyRCQh/FOr0E/eY9PDo2UU+fLoTbZ9bLmgOgKyRE=", "JxFfpSaJ+LhvKWavQlBNJdyyPVQd1qH10yize5+YI1I=", "H5VbyygsLA50tBaaYaUQ1PpQbsipBQUc1PvcnvETBlQ=", "DxP8IKaNmDrdKZLvkhqn2SlOV0uKDGl8XVZiKlhe9rY=", "DkgMH9jmGl7YAANtkRDKqaVTCbxGpPsdd1a36W69J2g=", "IIqLDKvHiQ144YAodooKNxIP8eDYHLlUG714HT+1pnk=", "CkvUDBdXJrZEw9rQ4p0Vj6GxdTpKWaFgZzjFcCbqw5E=", "CFm9h/uVUE+uLFiBZyR3fxyToXLeCyMdqCwIk1qVDfs=", "FXL08PL0Tnq1Tz0O4gjRO9n0oWor5xYA0QZRs1SDzMQ=", "JZWAK4h7pYGmRj3D3U4pvhsJd8h6ckB42E+hbam4ra0=", "KCkAhPXzXedFkeBqYeeh1panmy+425DVo97r3M1IOYc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DdYaVInUu3vgUiPnXoAEDP+kRpu8HS7O4C0NXZlBLoU=", "BsUvT5DXE3RKzmahfTFxxtg/Wr6lg2ejrsfVOHNq4X4=", "KEzozXfJyutSImGLx31MPSmbQcx0gSSJWRux8jpeihQ=", "HpFMJEZGYFH5YfabqpsAxW8BgjKhyujGkzoaVO/c8ao=", "Afnx1dYcIoMaqWR6W4G8kmZogmQJaNY8A6M4FzwPw5I=", "E4FilGJCjMId6naQIaCPuD9olgMDrBNoy6iLhxhl8Go=", "CycrlVL5IBsD1+vhoYh8f4Jx66sI6B7RJacMj3dk4ek=", "B7TRLH6UnU7m4uDqk9wQWvv6J3uTc68tEqb/ZORTVqY=", "GzhSC6HEWJ/UIBTW6ASay+ldryxMLZEMRKsUGobiGsg=", "H5rREL8bvLo+25FzeQWZplN5MAnsirKFy5VnqGjkGVI=", "LltZnqjSX8l+Yh6uCNEwkJF41FCAPt9uhTWEME87sO0=", "GxX0mHRN1FxkQiTLwHjpIffBs+GvdkqEZyV9bAafoY8=", "HUzsfWmXGWIEN8CkjyBcqoVsv+6UFG+w0djcZsRl9KQ=", "FzVDug4tGyUhkci5OSq9loEBA/owV5A6oWl0Kam7kYU=", "G53zUU0LMXfqIrbWG7umHm7MXvh2ZAQzP89vkdoBJ8s=", "K++pimpcg4iKuPIvlQTJ25+u5WMniolM4lOzSYCHPsg=", "KV2x1IOmYZEXHetqC5XQi4Q4J7AvXmkartsIRbqmTXc=", "Fvzn4NoK8gtzDYflD/O4FT43cwTZ0mK8PB4rRDjQ4Yk=", "AWYEAcIH67R3c6CZ5RKxF5h7yNECosoKfP+ZR+Lyy9Q=", "G94QXp6/J5VgfeIW5UTpY4+yPvH1mMzGBmpbGsu9wds=", "Bf8pZswq7rtC9sq8Kv9LpniBo2UxaLHaiRnqZBiNSkw=", "HeGFlRgM3s52vHo4nHJTA/gRRiV4Xk+OfLmHNmt9i1A=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "C3UwbFLp+qJTIVdFfKdRSE5d4svqQaNXSB5r5kHE/rE=", "BMeFXEs6bm2wWVwpStWMTDpBq3pnFgjgTq3ziad9Xc8=", "JZb/ejPQJgZ/Qn523ueMsMyTgZq1mcO9+TGRu5eXo8g=", "CKoAY9xZA9Su4DImjInoZbMmnXVF3bEISvJHn1UiWt4=", "FUiou2dFnSYliYOIJWP0SaVsAePfemCNCG6qsi+TcI4=", "DVzkf7gn4T2er6m+/v0y6wiczxwCdchZRuLf4fQ+jMk=", "G19EI7FqDLSvH3vL3K/99RsCGSTfqxvn/TOlZkelGZk=", "GNU1txYOiZaMljPMcfstl98xOYFMEv2tweWm92IqfAA=", "FqDWzWO7a1/0woCHByAWAtp9aw9EtwHoOT+Y20PCT8c=", "IywS1s5qwKuOrzHPAfn40s9Q0ksY7SFsYpJnLI1bSQ4=", "J/uWxcWMQKrxSpzvSc71pcC2BHH8qOkHxNVsCS2Lo4U=", "Ia0b3etiliFejiBxTzwwF2nLsENhOevg21X7lhz5dzg=", "AZsWhwurree4rDDJ5igXBkrpiodsk2dbI5hTN4M0PmM=", "Fv3O9XumV34Mlj0BMnHnAhXIo7+eSg1vk75qTp+vLQA=", "CDDOcBqToNf5JneqZdU/8or1fIIwmMJW/BRwswBfVG4=", "IpXXyLFPKtTLsPdipUxYOD+2qP6vnU6b3jW5X+WMoF8=", "CbHkO84+UtESsjjo9y2TST9BqGIN5uTcm1LLWiofPb8=", "CHwvH+OC9wUCTRvcuP6K2zO4I2HYy5Md3uP5+vyi5KI=", "CxfXUjNKUdAsCRpoA0SJ0ws7TH52WUIuULMtB6F6EKY=", "GNRSAmm6K7dCh1jhx0vbzt+PBY9pbaO9j6/dw/JUPog=", "BtDhXx8cKwN7/cr2secksm7yjXZkDmgRDVDkJsr+Vog=", "Kbe8AzrNkq6Kbfk971jUmLedHeUZ9q7Y3phPopbY2fM=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "GG1gO8bZNiZzKx+F6kzKwUHMj0V5ndSK9BI6Ty56E+0=", "Hp+0TVHsSRXtmlgJxQ3Qv+EbTtxp6Zvv2ewwYERFq8U=", "C0j2K/YMESS9e+Tgue5sZqZCkYpGX6GlDhq1ANZ3z4U=", "JHMYFUWBv/bcYzPLwUrnQgKx1BkkGwR9yJHA9g5oq+M=", "CybL5c7KiZNLzlVD+E5CvHOfJfKY5VYiV0LZh7Dmwmk=", "DGCtnGK3Sr+Spp8/DCVZYwrFG8j4TEJhMEAbeJAnijA=", "GwRwqeNIXmyuJ2n2qbeqXjtW8QHXvmu3yRF41ZRWDkQ=", "Jk1o+ekzt/gmOkZSYKqDkBGqoRfrAjWJRfzOcuDJPi8=", "DZPehCnHBBXfcin6Iz5hBonjFF1TRlEer1uN4lQ1F9Y=", "JKmQEsHtehJF9QetSpyFNGWKTRrketZTkD38z2a0QD4=", "B9qZtXwr/FZpPagJaRc36DIZGnZaUaJ2lx8WfDqCzLY=", "HOobE68ArLbB8VloMa+9S+FvwxPZVLqiISBOsQNaih4=", "Ejv7BjDoqvVs03RGYZGbKojA3/E7sKVxqrUlP5i7R2I=", "GvEyIxJSv8YC652YLUb3mBRwwfgdM7wtUHZNqk0MM9Q=", "LboLw3I21bYSNj7+7F21xLjavjZa8d5+q8QwfV0ToOA=", "IhymXJodO0W2kXCyblpkkhSF80LJ0XlgQqnWkd+itiY=", "BJf5Oca0XMwp1X4SkQIdf+QYa+y3ZZZ3ZrfvUOXyr28=", "ILgRfQvFsyX1pphd6w6mwRmt10jUQyqvUvHxgQDExM8=", "H6c+EpwU1ypOPUXhBEtOAjezjNX3pEKEvA41/c4I5mY=", "GfJKHGhuILBgOeYKHVIvjVIUkaQGmOpIpDIZ1AFhXBE=", "IfRzjNmJYXw+KN+4By80m0T63VvekPFpQgvsSgqJZV4=", "FNHOpCJ/bTabxgFTKL7Dbw3Tzx2dLQiLX+QT6n+u86I=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "CYXMumUVcPRXWg7ZL8gVxNJixr97iApKLppvBi4FObc=", "ITcAgVFMo0lvA1MZ+oF+QsGChVyTiwn1c3vV4LBA04c=", "KNUd4WCxkd/lITAF8Bmjhzu2DyuWeaPfZWF1AtIVONQ=", "HM3HXkNbje6qSwyLcV8IMdwiXHU4Jm6QYJ9qYoWivUg=", "Fe2KYDUW4fVheHWmFG3JyNURzRAPnuQaH739WBBAjGs=", "HMXnpNfsv0vNFeLA1UUy8sbzZ5gNWv5OFIt72BNzc6Q=", "Iolnntdb9WS9kk/0LxSk9jZj6Vgi66dLNfbFjW/1Ts8=", "KKhE3OCO4Lj7VeffljDjV5KNvvku6b4MAWO1HNVVUDo=", "JSFzVCRFlwE1mkwnws0NVbqlOA5PSgbviXssqJvexW0=", "Ilq9YY4RaJZwQJzbGmarcNB3zcD178KzhyWPKAokw2w=", "BNeiPj63pGZ5rF/B2KE9FnDbtfADQ8uyCJP8VXYSC2U=", "Fm9+KxTJsXdu905N6jFHsBQjT1itXKWkH1zEB3UYUVc=", "EmgZh8lE0VwTKpPW3+y+UCtbeuTaztIw6v24nT6NTuY=", "CqdVgFK4POoN26MAYLS0Q7Ok8A7ziNmKpggWQeerWOM=", "LIF7L9Ll7DLGvITxGzxjGXqkrowvNylSvQFhYsXXHLA=", "EZYhWaAX4lM0BJ3xPyvQE9d88Ys97Mf2b/gQQdzzVKU=", "HWPJ5cSxM6BRHIYkeV9UR0subkZa/ZAzD1CkTu6eV7k=", "LYLinARNEJa4wWc0pvnHJqxcW0ehmdvXsaoHkqFhQeI=", "GyjSMqGWk1QxEJF7Csgpg7eLSPrVPyX6AHdI9jDVJK8=", "FHug98ONh10e7uU+6RErdfsK6RAQMy3o+TJa64Xi4io=", "HM8mm/R2/svBJJGhC3oDGkPG3xgKdP12NAVGq+IFp6E=", "D+QHpWupGsF0/Unvu2HocwpDl+jfJKvvBmbEbhaW8no=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "BTq3iDprs3l3qfbAS3Qw4fIyWccbtj2+K/D8KWeTsrI=", "55GnCXtuLuXcMU1XQyl1QA+S1p1P+mDXyaAE6KgybA==", "BAdNX0e4UpydjHn4hp3X5TlEBGvgZdTPHZ5ADNMOAFo=", "EFtHiZiYzkC3t0zpSMQrGn8cBkwXpViMqwK59ZO1V0Q=", "JRQWjcE0yVUNfUxd0D3TtvoPTBD8NjE38XoctxuNxFE=", "CvHWG+JcxqGRGE53I0VC9JRt5ofLsIqozqkaYa2gVI8=", "HdW+pV00s4Hr3IQiAOyqT/soue3JYCWnAl2k0orwwFM=", "HDnp+KJTAPiK/B1a7KZIUXcZ9cL4l3hl3t3D2kUfc58=", "Ot9HRwlkPkW1c//ilsDPZLC86XBbkfg/wQkhIUdJQg==", "LivTDFpBThlglePi56zfB2LGpU6nTdgt7WD45jQ8RO8=", "K1OhPMJ1Ra2+1IFBjL8rxNt6xq7NpWSSc16i6cgo6HY=", "DZD3WVlj1MRwpVnyIvorbpWIZgyatCR0+9NQKxTP/JY=", "Jjtz40iL8sIIh2sivujiiu+snTpLdnaOnsC4OV0vzts=", "Kg2+9e2tHVsBRqBjDejoWIxun440POrrHpDxFj6T5Hc=", "GMBhNqHixULdTKuvu5IyqYMByRvbKUByzvYupJRLH3g=", "FlLHGIT6szuBbYlMYsbHc8xjF57jXLfnOlaFM1R9Mj4=", "JMiV/iGQDkm2wekIJeystHSp6Rmp00UeFw7yIYn1qxc=", "34D9T5Y+j+xH/US8UdlNGgSJR3spY+pGc5qZo+vjQw==", "HwP92G7inkgwnHnpDgwSJaH/tHugyiXk4mHhfoJWcmY=", "J847NoFSokkS2Uk71/ddVGZtFjOn+VrZTvnLY7crc60=", "B12VUAqTuoa7Uv3lgcu7164dKIuF6YYv22qEYM2aTQQ=", "KYeJHteSFb/bBRM0SnNqX672NuTcGq+5U6J+YHY7/08=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "L89oajIT3fKrhjCynScfHAOAQMAdbUCRfnZl9ZwPQRo=", "Jh6ojqIRnI7mYGAMHCaWRVmwNF8zYL5xaFYgghY4vno=", "D+BKJ6pjZ4XFg8JHBn0P4DKLhzKxc7IBcVc0l5Z9igI=", "LPCRKsIjelCR7CfbCn1ShPE71GMPtrWPIhpo9fT+MjI=", "MEFWndlyxzuI5z7MxxXXBD82znlBLbDfV+2QKVf6z5w=", "Kk+bXFmwmDTAc2X1j2PtZAODZr2dF8cBbwRQWruHizw=", "H8F/zMKx9NBRWVwOQVFAbCnS6wJTdpauv7e4Xpg3Fxg=", "AW/AAurq28YQ1TgY+xpyxH8H54NLlDPgJ27t9ODMd5w=", "L+D2vDJCzclA1K1npAMopR2iIQDOqGKIkqINNoDm2dw=", "BDQjQGOFxNteqIXaV2YkYJYGT8d92kYP6NjeuX00ukQ=", "CQ7m/SMfK3+nP/m69tsKR6AFfmJmTd/ZNVkkJC0FDgI=", "MAXC9zq1ioyt+txN2h40ItfA9q0P56dSBFrHIAHG1EU=", "DvIo12Z8ZvrtjX48e75ZJaVddFHff1Gmr6O74HR8G6k=", "AhYfdhgRO6fXhC25StLvJPIfijG0wRJGiKLk36yBDwE=", "Ag8IVmm/Io17oR2Thmyzwmiy4DHduWl9gM9iYoaGk44=", "KUNygE1uI1kAPJzdFndWVCPt8CWpkz0LJfquOUcXG8c=", "FdN4kPCvW7pLOrs3v6XV4RXvWk6AVQXizQIcSAeskBs=", "KH7x2ICzF1hul41fyOoneqpFHua+G7uN5ctEe32yUc0=", "BdD/4NAcdSr7+8PixJ8NNNNe5RmGAzANcnoRuOfu1ZM=", "BC5fuBlVL7Ztp2Z9Zkg4tL9lpQxCKrHpqFsf9uktMNg=", "H86bNEp3MRfSGXTZw6BwNoBlN3hFFx5Gk2y5Wj04BRw=", "AhfiN305otU07ygflzriL+jsT4dQCJlDHOzjx1xBAkg=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "MAc8U71TdcZCFIokfkJgoFtWYT3NzkoJPoXhDSlpmec=", "I3wLrBOcpllcPb5/gTDTmZBuwHEIGP9EwFd0tHnVT9g=", "Hy4j/NIln6p8szokO9IS6Juq6tFDp+2+bGscKVaQ25w=", "LsdDkimihPLEjtvhVZnUYrHQc7OmA36PfIAgd38m7k8=", "I8JouE6MEYczwq22s7CTX/Yx87R4Q7ES6AzZ7FtazF4=", "ATazmrBK9Wz9oW8/mUEbHDy9PvGYtfBW5lcY9S+rx8k=", "KTWKAjFan1GA8jV3szNr5Y1AOebOT6JRxM+GGKlV2aQ=", "KROWdPHtWWdHbI3Xd2JOSbyQiQpcmXUJIqRyXIEQV3U=", "L841yr6sFL60m6ua3n44Ebup8yuZp4461lW3fEc6oy4=", "LQ+8+ctft4+iC9h47n5r3Mwuqw630jJ0GTLA54UwHww=", "LKOPb4jWo3uOEm9yqCI3hQ2fJu3FtXdVjaWMLlWwdns=", "GeONCc25OeGHv7iCLlwil6iX2h8WVVoZEVe7ilrxFaA=", "9hpYuXey/XMjtIlBzAEBQOm32jEnHb8+RpG3Z97n+Q==", "IrUpl4cFCuBL+fuGz96ViSU4cL7RoCE7FDsz66EVPfQ=", "K+z8UQ7O1TqHPapTfCHXmh1QcapzT2BVPugJUgqeIqY=", "FNW+XGkIg+pbQGwQsBIHJb8eTF3iF3Jn2eOOnHkruos=", "Dc3Giq/1SNzHhC8ZSxswtgTk3wS8qJgwwLw2fncD3fg=", "Gwqgf58/Wu3Dfh9yZr2xreeaYts3FM24M9GvhsuJ2dU=", "Hnucityb7iL4WZcqE+AhMxTUPhgp9PmfvwGd6O9586I=", "A9CQ/cSOvACbTMftNUbWnsh97bxnlw3OpgUmQuUX/jk=", "L+24EZiFw4OYhgpubF2xhDHk8NmBovonSjbVwx+c76o=", "D6X6Apnqeu/401e9My8Tq9aTVGBYjhWtzQ7HbI3WdQ4=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "EjQqE5GmtZ/yWlyE81KgGiRCIEZiJiXXlYikPED06o8=", "DiGEm2tJaXFKEhVYMxwYoqiWkATNdQw/7GvdpjhPWjA=", "FD+oTpXHiT4RwXMGvLfHpk45Xj/Z8fTwhs41lHKJMdI=", "IWt/mc+9irnhJP1/9LFyyFPPI6KslctBs6QhkPA1sUQ=", "GLrQWUpGLwM9K+fSFRzdq8bPIe1ZUQweVtCAhy+5VJA=", "LFtJ/OIGxhKUf/X0oSzx5HY6Oh97lAfDKOMLNJfWnzo=", "E/u7ZjCZJP6hFTpkl4ajP82N+z5CIqPVk5O0DMs5uaU=", "A7RPkF48iis+dIfg/w4Sd9Wr5eEwHBZe0ckliCliL3w=", "BWwv4ywZROfJQA0KbsIapUzAVlYgBsSEWDhsjZL1Zeo=", "KcR+UxQ0Rve/xDr7PuhFSLXKol9Jh3lkFdaOMYiJqxk=", "AuQ8UtJ0SCghdxYyABaFdN5AxYT+YdT65dyuSViQIX0=", "L8zhJQfNBjDwaimSpRX0XCtGnydC4yjgdVXSLHXlHkA=", "HS5tnF6MIg+UArgrpOv2QbIXPpSudur37lVZ1D3sdhE=", "Cx0aRZHyM+cQqPJFz/XPdZ/gtOVfRjB7u79dRXOoYPk=", "Fjrq35aX/RWJg0QjOlowI2SZtyjG/lSyU0x8n8ZIu5k=", "LjNFYX3ohSO10JsnyWaf3LJHLGzIMq4wT/lgwNSlo0g=", "GFmpv9ULS/jUCIXJkmVHdc417EGne4liBt8O8ige/Ag=", "EjKnd7UUHuQpZ5jLN//spwjQ6rMUI1fk6Re2XkJOxHg=", "EMTOlnzvAV+kZrz2kHn48juygmz+oUx4o7RQmrKuvYw=", "C5gOipI706Kp1ekZIzfwcPGMEaFsgJRA9CYSasOQt8Y=", "Kx2R9CItKYTbdU5BM/1AYNEsHb5hWOs0/Bwf0PYye5k=", "GcobTgGhZxx3GJe3QbA8ppHC35hsM5xvLGskZj+uMSk=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "FeT8SMlaMKmzTjnH4uWyPPluctynjSXL8dB/a9HzUmk=", "LSP9xMDIHFzRJEAGZ1hUHX5LnGvCnKuqe7Mhf+VYDGU=", "Hh2wkCwLl0PT5g9xxTvbzLuZVGbzmp4EQHSjIIb1GaE=", "JLfJjDDM+9OzyHR5vM1xEi86QeDqwMWoKRatnhx3roA=", "Iqx1/KTTu1vw+fJb7gKTxQkBwtRfTC4dGddDOydxz5E=", "LQd3sMV1/CvpsTEYtLrAO9yFbAPJtyNvYWcNrF2pWxs=", "IlL6NegRWT5ifI1v/tqkUDcottbZZ28uMnBUXNGQvls=", "ILN7TtdEWpastYkb/oTZpblujFpn3REcxNyqgmn08Kg=", "I0eYZlIpXbefgEugbZVR0+KmtaGuNY2UodccNPNv4MU=", "GThOviRdzpTV5oBw4xFLHFvpEj4qNyisOvnTQAWKNec=", "H8dKACMjEM5q+eIzpJNFULDz7wY/Iho9q2TC2QcTijU=", "EEchqaZWjZ5n21bsxh7hhiPoniake56eRPiXfainwWw=", "Ftn9Tl3PdYY/OreXHdct5j4Jz3d4eTGwhopcFb5HwWM=", "A5K+ggM0elHJFXohmqpnh/VElLYeYsVOHJG9mVrd1HQ=", "FyijkFqRMLD1cK8BZb0tAN6mHWH30QP/fBMXKxeQmcc=", "AUXwPLOr4S618MrHPBHborvPlMcvLjDiIZOjOQZQeTQ=", "CHrio2jbXz1mZzACn6CulxtvUEMogcnA2G9fOqcWuEI=", "DjhlQ77zMNbDzBQpSthuJAiJTaJl/MBBIlGWq4Bkxzc=", "H6rzq3naKzBAbxEc1Cqm/PGHsZRIsY9GF3EruVrqarI=", "HGhBC8b3XZ13PFzFevKasTjphIDhoN4VGV5kr97IxSU=", "BbUp0J2oPYld3xqqmEn5iVXYEoDrn0txy3aUsqIezAs=", "BbjvWBOOfDKE2a/EVB5/KR2HsuJrULf+63XNhZ493Mc=", "LLExedbopK0bn+w3N2JTz2Q4atkF4kBXX8qGU5snLcY=", "DSq+a7DAl97us/IWK0H56WkDWtbKMecequuqWQ7a5Ac=", "AZCa5vhtbUMzL9Msr4MVLeOarD8nAUQTAgEtO0NJxFg=", "Lw7jqGdrcufl70eUrtyIBR8JEa5D0DZEnXwH/PL13+E=", "HjeKH7T7Cw4WgSH4a+jeNCJl8NlEPeN/9uJKjzHGMAM=", "JYOxsJEs3xYqBG2uxIVrqA7G3x8foIAQHM/SJRdqDos=", "Ednjiqu+I5Hct90XcG7ciU3qIk9svM7xgu2uKYgA50Y=", "HUhuW5Dj88eJgwvulo5tVEtUAxR3/cjJ0ALW+c79WY8=", "I0Q0ll8FAopPUzClkKsGYZkUR2NIrrh6HruvoeVo6xg=", "A+tVlE+h42/RYjn3s93xCP9fJ5VeLzhhOUk+oFwb9Qk=", "Ai1oPsyRJT0I5uU1pLYmJ3OMLLh30rElqpsZCz7S7Zo=", "D/FChksOFNJzTC7QZCpHT8HwEW1+HF3sGL3OrLJyGVg=", "H5MFV6KEmYIl9fTk37z1rCEfGxLZGwVi7T1jKF16cUo=", "AY6CIvaQfaV0Xuuc1KnmLyi4txCqhf5yn56nOj7wCZ0=", "GA6STXV9C+QGb+sUbtViEuOKz530lXQyZT83D5Bbiwc=", "L30HFdE5EZDnsUoSQrZ5nqwxQuIfCMoCwhdV6ud6Vbw=", "Aig+2NXm+UcLP09Jp3EGHkpPx9rGg978wDSKiGLGznE=", "IfYO+xMrYpCZkLn5lPOBqcAqvDzLVMXI6MnFZkxpE9Y=", "HN6CrO5guEQk6bzuSaVGTuBdHPC3BGkgimdWNaxxVJU=", "EYokUQohU/gY8KmWyH3pE1h4BfFs2xk52UBpQflY6OE=", "FkVnsN4Wt6VVD8oim6x8sHeVJDJeTKXnioYHiIFmAmQ=", "GI/zAxlBEqcDRSfMndC03rCWDJwQbOEVF43XCH5OjAI=", "CD2DKt+btKJfaGq+2p8W6/UyY9z570MReB0Jkg0JTq0="], ["DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "I1zpQNvGrirxGQFhUVgbOSi79dxmPcX0tsvwIwWkQKU=", "H0H0niPzcd5u4FOehzUGKD73MD3PHWFxpHMR6fq8Jf4=", "J2Heh5b34LWRX1b9/xgN3U8iAB378Vv8g/uLdsLtlaI=", "IDD6EZ5+pycRf6GNYb6/3FlFucz+tBc7d7NzqINiVE0=", "FvreElB17A7ov7WsxnYHbRS3bnmy2qWs12/mcZR2wBc=", "FUBUx1Lm6CdUPbjY1rqvsCcm/XzctxSJUQ6J3S+vXV0=", "G0ksaqUvQqV6ptnpaAwUh1yiihKf3bL+2+68y1yDy0o=", "I9HRvN9sLBQ3bmYZ74VacYrr99mRj1eLWQJemAiTYxE=", "HlCehUaYuDeuYtturncwAGSA9k7KvGGJpukjcI1KpcE=", "EEoWrswtrelTkAfXpjHLEufqGrn6GOTI0ViUHhMyK/o=", "Fn40FpjB5HiAoIshN0F4t+MYcU7rQLVFBK6pNEMkn50=", "Fv90XFcoC4MhJlNPZaNuBR/PFhSD0amsTSqILVXEs9c=", "AWVW2jFFsSaZhSITtT7d0YWb8MBkZKaYh6bvExnP49w=", "H1LnKuwCwQhYYb7EbTyVKnsX47hZ4eEZ4p+dVbAKnSA=", "FDkjXBNlM5UemUpCKFf8+P0TeWPIIxE+d3zKktV3IzA=", "pw7FyHwoc9GSflJZct/vI2/5H3mWLqx9uY/sE8PKaw==", "CFxNHsEJ1P4NqoVIx7ZB1ivcrXsB8CV+pU+eY3HQBVA=", "L0slgM5WorWUGr7ot/mK5LieZSoAW203jtynUYI5krg=", "E0UgEWlEyzCgXGlOkMz+JjdqI6zfRHGdXpSkDAy066M=", "LG9GI2s95jG7I93tN/5DSemGucJqmTgqKBJbISPpYSo=", "C6VPpzZyXEXJqi7bEOLRYO5Jlwf8XT+tCSxvbmCDA2M=", "Cf7FUHXaOw2UmvISJ9/2QUNekgA0uPOgVPbO7gP4u9Y=", "ISPeLE2WV0ZuLAmU/HUWG2WPzOvK2yXQPhAFSA/2Xb8=", "FRkL/1EEgB77rCb+CYgvpdWqK/pwLvzRueiuSsqfLuE=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Dr63jiR4nRPjFa7QPW+adQP4AnrIwHuzHKt9n3yGcnM=", "GnQI01a1RrBv+eEecG/hAxHt3rVk0V935AbEoX7aD64=", "B7kJ6bPXZsBWK/Xq5jDrHqo/SGtnOF6fFYQNzHWkaVw=", "L7+uZNlt8GNiJzZml3Gzdj/k1+MqJTsumkMv1ASlodc=", "LouuVTOLnnogIngCLR9PFkHo3+3LEBc/j/pHo5SnktM=", "lc9Vv3XxO2mGodjcbiPvJ8biAEm+adJ1zKCKlcT6/Q==", "BZDIB2G6yxmWFSvchD7pvI2eEQbWtEFDysYaWCyTxwc=", "LiyeGyMlNr5k6C4/44yfg8weLsd+uY1pDtiJcsVdTcE=", "KgvdB1A475JRBNpfgNQ2gZqIlrRhlLeV+e3mRRiC9mg=", "JeP1ToeIzHZavL7N3SMmx66HIN/8PfLnzvsGv1crAZw=", "LE44zine1XFIlk3wgW+lcyQGHFFe0C2fXKTLQjHnLZ8=", "F4FqMRVHH0r2PjU6iR5cY6HeIbB5Mkxzdsf7d4Fi1Zc=", "FrHmEqeRC9u1W0QXSyK3K2PM9FL0harbg0qIg/ehEp8=", "HNvObsVjG33zbX+7FzTAZjKVWZBs9MnMcCO3VEXyzb8=", "CFJ7sEVav5IFMZtBeKyRyJ0n1zrznKPrXiZ7QH3BIrs=", "KVpb4H0/rT2WIvkqUnQnhnQdGfofhUJOa7A4OysxhN8=", "HRDhXoku9cZ7BgYekjChOu8I46JCLlnOan3jvfztSUs=", "ChzXkT9zGiY7R4gLSDeS0er+dmvTl9ajf5sDv/ZJrZc=", "rvGNsFQQkfTQqMbA4EuxkcOz7Kmr/pGzNvN2iPgjgQ==", "LCQMH1c4TA6xHaL+/vZovhMAeWFvvpUzeMpM7jWK6As=", "HvBOVdu3dot+0mQiOlYLdGLRMaw4ew4G4JEHWwNsKQM=", "Gd9s+lNEiFe0B2Sskn5FxZpK5pCIt7/sIxIX+0m96XY=", "G3lNYe0qM1obbKT7Lfk7Xekk9Rx0LJfrH0UmL0zuPd8=", "BikGSCgkwB2vAB0LAeFVjXoukhvBJAmfpwShZzBbBDI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "HuXpG6RNORmgKkwFpwTRXb1mZdOgyqdTTwYstwLhLqM=", "Ek5WcDAWib0dIRJSYKyYCqd/mSer+vZiXPxK6gVCw4s=", "F/OcUbT5q6C1DPNs22PWSFs/eeD0xW/N6xZo6rItLuQ=", "HkeHaIMiH2H1qFy8+RbkJVwUYggQC9113yVQt/I9mrQ=", "D2z7w0jQxG8rRRT6SuxjaFt7SnfMGH85+QNSru0tQZY=", "HskW8PirNTSkX7i2/VKg22EjRflKfRBHucsVvENU0lk=", "Ipnoz6J4yP+Ky1cSg/jViwcoX9PbCT9SgWKG+AWddF4=", "DmOuCE1BZe8jRjY308bJYmQqy6Ha1i9d8yLACqumeIs=", "LGUtvBI5G6tuaxZCJ4k1rcV/Ao11rllOI+hp3NgHoEs=", "AjzKOpbIfAmnWPl38ejjgomL3Mgt6/rk3wW8fBbnSqs=", "L1wZrisGqgn/YXotrWmFiuVFuKY/XHMNUDEsp0DVOPY=", "GFwBMIPw3Hse7M4wRVVfWToVFvfASGkAApohU3rPjgM=", "Lk3tkM4sQMrTkfU2cYpvEHg4cZ5s8ALy6RTuHbP9qGE=", "C6NiZwb65NoipZv8fQt8PP/yIe2KaYRVOmtgX7fOTK4=", "IoaHzcgfS9cniR9BkR37/iQQfWDdpOp5tbCUiG6JxM8=", "DBpDdLwplj8sTmjFFRjgmNvpBtnDpmTiSTikAwCe4o4=", "C0ntF17Ay2XZ+3a53aWFmvb36xLgpIlcPeUSKOM2YqQ=", "Jr6BJCXeW+Pm9P5mlNi4g60VbmfrsarLbLZP1B1ksZ4=", "F81LTHW5eKw2nAJuDjSIW6tMdF7wXEcdeXUwDv8APb8=", "KOyztGjghn5NvinwVJC5D2IQEIowYkcVY0481hRAhfY=", "KtKmiNXh/HqFPRf/jilIfmqf6OI0tkI0Ja/Bkv1pJqo=", "F3syJdkOfEP0bqhVefQIuyOUmD+qM9Pup7eEfhC3Ggk=", "GMcz0/xtXE7XMGUMUSsLKSL6Tt4OQoEnnfJctX+vF0k=", "JcKHGQ/dPw/lUscsdHxSG45H8ELe4w+QyIzEnEJeImk=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "FyI+iMWv3Ob5jD0wlv2ut0+pmgv2I3uzKEZrhDtbSB0=", "F+33u2CeJKtjQ0nQO7rF2SqZ8fVFcc2sjhVaN2eUZVY=", "FjhDaejoZtR7dMhJSWeW/khSkAgKy20Fp4s5mQZlTsg=", "A4QUBUyrnapkhIhkh/mxSRoEJMddz9bmnAD4g5GWMmA=", "Kt0qn1ivslPZ6XKbhRDG3tjKwmR4cbSy2vksHtgCZnA=", "L1n4Me0WZjrh5ysn33T4h4WDsIhybi934qm3G9XrTo0=", "LIVjOXYU5Ml3ditzRn90gS1h62ySHfCxi/hNrgpEjNo=", "EIRLbXAbJk0zPqbVSW7mK3+ZsPPoHkd08nGs1ObfxFI=", "DZDhIhsiZiG6sPhBZMa9ZXzt9FfBaRxkklSMtQOWLyw=", "BnXVJo6FnXNPrf5qpqWPW9R+nZvL9zEdkoVi93KkQxI=", "IxU5q6px0Y88EARJ0tu1p4yMbsph3rz0lWcKtogc3ac=", "DF5nTFXlfpgbjef4nQCqCI9HxbAcObzoXt4XBRm864E=", "LmseZc9wafyn9f+/B2Dl0sas7I2oX/NPLDzVX3RMhEY=", "A0hHStOcCez6aGqHEKdzes0ZkX+2bpCj34TRELWyYEg=", "AiOAmF9skr3degLQGHyEX7g0ybfjZk4bBk7FgFNtEZI=", "IVKTBErCBE6X0tBucU6Te7FoRLLE6DS8NVVjOjHOHTM=", "EHbbCzj0Yqapgp7UI1cvBdFljDkPyhCdxqW66ts57IU=", "Dgs7OeM7Xw92iZdgZtWsqJ8HD7B4FSN4u+TL9ggzDgw=", "HezXE1SNDwTKD8OvMe9T6wT6+nc8xpa9XXlZ1bh4Hzo=", "CO6hri4dur9OOWm/upFKelvgWmctFq7pApw0d611wLc=", "CjyBP2af0FUABb4u0CX9Jj9JbPwMiHCMVyP7bUeDCQ0=", "FIKzmjHkh0nzfmzWP5/XSYtwYjY3+uMYPxgF3rSI30o=", "CSwJoHQnLFb3YRriMVRCUyQvuZjx+vWgQDLIl3BcwYA=", "IYyulyJ9JOVQGoxo0PmymNECtbtIcKzsjOsGiyGcXec=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Gf040Kn8/kTquBqIv4PpZvYl3M+4yOZjySeD0vNvQ1o=", "EFtp4MFrZ/tEjORn77ksA8CgPQ7mUqodP1cna82hW0g=", "Al0fsZWIuWuDXPRReItkNW2udKxLHdBBBfT/ce5Tjmk=", "AaPT8FhNmTdihwiuW8Gmd8oNlzS6E/n5uv1NQO0J79I=", "DaKcsoTwsZ5F3dNoigl80voUdybamOfXVlSAdTw9af8=", "C7JFpP4Xkz8aMj3pRunHnsrv4ny3J0bwLdf4oS+5dGU=", "EpaKvB5J6Rbb/Y0yyZrdDyUiYT/fpgM4SsrVCts8k9Q=", "C3IJAFXbjq7RXFMiO+DVnxNLbivBkP+KoUXeK8gf2QU=", "LskuMy1kvwptU6qzIC8W6PkxsLOhnQg5eYHk1n9+YUk=", "EIdeRXUbn35tIpvLYDWg9k0vwmYIe7FbRu2NusIlqHU=", "IKKNfnvyOT2/Ho/RtZV9Zpalht+A6nVWebySKzIhTwY=", "Lby1oGYTH+cOEDWs7LltYKPEg5TvAl+UaTGK4UG1lHQ=", "BdOCsRYhzoHfo7KlufzlN/GPPho8EbdExEt9ruD1OaQ=", "KqHL2jtyJL4mtVO2CWfR5Jp5zB/OoeKNzOrpUlcZX6U=", "EZ0Jj/T80VYGJk3KIJ+jG4+Q00PXNAiv2Zy8YL8xs4w=", "LWpewd7P2GD2BrtxfC1v4E1doKUSZ3v7O4jG64KMyqQ=", "HUTN1+D5/zD6JiuZG71LJbl5jFK1R1KI3ak3c4c7cPE=", "GlK/5CxpnbBYTpkIlHZUAH+JUkTAGwgnY3//c+5YY1E=", "JrwOci+I2vCuMQDdNgNAkQh1bIHC0lJtQyE1hnJI8Gw=", "IVHWVEtUHL6YtXsXvMMhdGkbfe3m2gGoWWT/TQPGPtA=", "HcQBEBwfHfGTFWnvqp2wNft+sflK6c6GzW3AVAsaH/8=", "IZ2OC1ddCed0rPQBj7YwKsmQ4TlZyL71WBSr5wPQpP4=", "BxB6rAxa/33xCzlQE1Ss3Rq13ACR0BZsVc0GPDoxAOc=", "FUGEaDaxgVnBCvUVZ/jL0iVW308g3XTtHO5YsxRPtGQ=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "GiGycz5XzlzDbZdwx+/xrgnFmvKpfetknzXgNBc5Y/g=", "CqdABaGrqfNd6I8lYwDQ9VyaVooKP5YlR//wov/PP6o=", "MCzDbbzzmyu49P+doGqVyKkEJ16073WluC+3y4ATMUM=", "G6j631T/GT+QznDYHQaO8cr/gWz0KYqenDWbeMezx3w=", "F34llhptLSU4Yj1wvUO4ZlHsY7CrKbHnBjCCJKC39oo=", "Ka3iKhTLFulZOayF5sUPCJ0YcGnfhllgljQpAknvxQA=", "DDy8Ng08yHEm1txzPowCduG1dsoxjSVmaaJ3f3DYkwg=", "E4pcdUIOGYvoYBDBR8EPsLbIguwQaD36sO8bjMAjY5w=", "CjUAUhk6SdMlUDAhTRWzahDnslYYkKTIURKGA7al8JI=", "EAJYAJQHkBHmwX6oZ7ORz+BbXnPG3oeGnPJUXBAIRZQ=", "CMBlIWgPp98F58j7ijov/cBSYFGllBGgzdKeX5k+j0c=", "AqOlQBIjAPMHBlHpGY+dW7D7UlRsNa6QpN6v2br05lo=", "FBaogkI4kQREdnki4yDTi1Q8yiAOpsVZHbkJLiJL5hU=", "BQfe+WJC+7mhq4f+8doaA/TDNJcj7Erm3olOFxobSvU=", "AtAxSAEtcwcpOQp0/sLT57qf0j9F6AFlf8XipJtDdE0=", "GURnkUcabwPD4OVX6g1LJLvSkwZp7SPdKG6Bt/4Xq+U=", "I8GYrpk9/DSlXSywIibbSa/aobjPuTSgXKWU5hb0PzU=", "BJ69LBslB6E5miFpDQ5qkAGE0VKAvaJ/W1MJmTOq/lo=", "KOs1pEkD84fwsXppL8mcyAgm+fNusblXbixcTEjM7FY=", "LiF7Kbwi9dF3K1vB+twRr1r76HsiP9UBsbY+wop3Q14=", "BdYX9BSMta2BjKg+PiXRqsMxGfSGJZJDBJi2wESuCH0=", "GW3feJCNo+Yp34hyZUHo89xr97NDSpOyVDSydztUbv8=", "GfQ4E8exNhxTZQneNzx069l4sPNhPQRX5ZKVzLNEeUA=", "HayYoAMX4a11tE39cQ3kOnDhqZr9FR3sR4qNC069Z90=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "JIOJtsEhWugEEjYeAx+dGeg+MF+t4ltRUXh7rCQVHzA=", "HWJFhJWVw/LmWN/x+CUgL3RCiMc9W2/j5HvgHIUjGmM=", "KCgZf8XsPQth4801s5/3ygWChE6piT5HV1rGmP4Pq0Q=", "BfmLqpRAPL7imafDi8ojF3OVGptexHgJRFaHwfv8riE=", "IcIXJdmCv4gFFr3QCenIIolCn9hHDuTwCSgbbWEPhtc=", "JRYWKLuWxDT83+0zq/sD1EkgYPnBLl1uEaMNpAH2ViQ=", "CY38QayNtoWsEun8snerizj6C0uUO19YYxieV6TsFyY=", "IOUWDbwyu3DdK2Z/8SKqycmiCYMNF30GXu2qN8I4ttM=", "IoK5KjMCgIzccDLodEGa1blEWl5pSMZ+Na97WWR+YHI=", "GRg1YP8UPl2FVmXgMTa9YNbmJxF4V+Rc47Fw0zXRmAU=", "AcsQgO4E2pjppUax6vv6xo17vTGs1mAoGHQuHb0DU0U=", "Lgjm639ymd2/ToOtsvVEyOK/FzMUDq4qJMoJ6OGQupM=", "FzE+tz0wGDmrzYW8skOpbGYqkiXXDpI/SWYCT/P+o3Y=", "EVqPoLAhHc9aBiXne/ANTuyTsxOBHGFEHQTi6Sf5mh0=", "EGceJgFnu0pzZQJ15RezDLBA1i5di8ZaI+K6tvwJJ78=", "BpexCJZIfvsKgdFJqVmyLI7dGxMOGKtF3V5PKH/FZ88=", "DiNWG+CmtuVhb/WCy6MOcH37LYWv9C2u7rqwpB/dKpw=", "DmwXVAoYMuSqhoLgwcpEceKtExxwpqvWMzJo85Vo3DI=", "B36KKp0NpUHZNX6xtgPulBDUntoxQLqau+G2z7+NTjY=", "HvWkf5SRMQ4E6FyFO8QqEiJ3IbyO+ZrPhmJWxvCsKwU=", "LXVr2FCGZP25YjvuKfYts2jn6fuML4z4BqICijSlTtg=", "C2RAAn4y31vRLkB1RhlS8MChafR+SYgzoDOHdvPP7k4=", "EDsxQbGNSUlc441eCrKmkeeBk5eNpYiONmBMUet1fpY=", "BFArwyRlfBjFmmvK3MBzXnBmd6VW8KszRoq/ZL1DRkk=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "ImiAWEpXp8VS2jJepTK/OCxnSCEIhwZ1usXT2banGrw=", "F40LewRMgGwYC5XfvhiPmefa1xRVT64TZSZPM7UgTTg=", "EQy9Bb7tIIBDqxy6imBKvlliWMUW6gxouATS4mKYnig=", "K0+bpuLS4xB47XD2oUfjKdHEuDx2EZlR3HvMbSqUTNA=", "FxLtzRZi9Nq3i9sIxdIgjgltJq6m2LWi8eoaV13Cnbs=", "IOesGYWAUhSEL4EUI2AbPxjIY06HsUMzgr3zl7KLfiE=", "Beaw4mfqiEx6dnJmthTZ8jiD8pepxAsr6dr2r4XzH9Y=", "Fa2ydVQ/uw4IOhDh7ESLjuv4IYXwqZoGvKgFc38NfbE=", "I/LogWkG9fw0npnIJBIwFntQ2NsixedS1kD8MZxzVOE=", "CKig60EkIuD/O+9Oj56Y0JNyk9i9lsntgj3hTHpg/kQ=", "FHOS0YjFL+SH1eFGUv8XWzclO9X7BOyeMW3kz1EAUAs=", "Ghpp1b2kxVlwLYe4/7qzR9YdXV/7oBYFW1QECekNBQw=", "AmJluH+PrEwWOD2XY0YCQnRqD7/H/DdaJRo55csSyK4=", "BWKvJzx9Z5itF3LTg0F/i6q3/v+j+P4bUGHmlaY+o2I=", "InfXQ/mdrMuCI+7p7SZH5rwixfAKDcm0XCaJgidTDAI=", "KrdVHmtHMaCywAwaHFetndZrIjmidU9kMo1AIySfMxw=", "Bn5rtWAEkGiKZ8owqUGmjxXcl+tBj4zszusdH0mvHNk=", "KZsEiCegzGe0TlP7WJfyfFfESO0l1L6IsbgbIhhsABc=", "BM5s32iTOPffPDuoTn7zXvWa3ORgNA6g0WGkUSPEBR8=", "F2MejFYzVjZ+FgcJYHT80iDQJWpg4ebRRb0kPFR1z5o=", "Jb6Euq6oa7Frw95OVXjHluGIisiY038fg16ofxqrzAQ=", "B/2BxZSTowbeyfBcASqWwROpUKRM6n3lcq9AHbiATy0=", "LXGr+rRaoLPUaJslGK4W+Hy2Cw/Z1Aw1Z+XeoSKBWuQ=", "C/HazJ7kkmNCC2tAsGHh3neIRVa+RimgEbtzw8+P0oI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "IH44MJ2Xpr8C0skHH7jAJDqPZXDBXB3qIR3MLL9F6kk=", "CWQB78O0KTlepcGHzO9cVR7ZkEPOOr4Q4LL2wPoNKfE=", "JeL7E/QF+M3GDagK8t+Peq6iGqjF6huA7cIiYcQkgQ8=", "AU+UJDjQtjCOiDZq9kDlmzXnuQ2vuZSc05X7nts25Xo=", "GnMjkYlYaCEtk6M8DE3liTM2McgmDJkfeIW5FtADcnI=", "HikIjtLrq+B62pYXyH1q4+6jhMyiIupZg1UMnSW7Bkg=", "Be4oWszmGBBBVD0B1lDoMUaQ8zc3I0Eza0+xsn3BvbI=", "JSuLXf9eZ4iyOJsuVck55phxkSu83gm+VaC6+fjHpn8=", "BRmOSsMVjC8fMOnHMzuPGFNy20NGfohPmWE5a3X31go=", "JFpf0x7tggT4m87t77RnuJ489/6R0kozoyB7tvCD4Zo=", "BXvIEshfBEgP6UQQoQaygdjz4tVLOeT7ReCl6tCRDfw=", "Gv7s18WYzj9ygTeMLlFMW+chCd9u/jEUl9vhKoGeQGo=", "L7jG0QALK/EerJSVZGT837ljOicfqLBw9LY+/XtQB7g=", "AyiZRYSHxytMSNwfcXoLKqPOU7aks4VYt3N+0hyv544=", "BmLwaRMli6+1vfGqkpMyx8l9TESQxvvI55gzX/duEms=", "AVhEeNMTmG6wriT100LT7HOBONdJtQceg5wWk69G86M=", "LboCXvyro9HEzweIXo+8HxHAErzcAJCH8wajmadkURE=", "CYgxgL6J1A8pJAWi1E9bm7ocN2E934S/KMT+WT/PBu4=", "G6K8qG8POnPzkmSfZcHuq7V+NSdYgom0ggo5GkZHXc0=", "AUi5Xas6eE5vVwQjZaRqAeWIDxfgnzFBv5nFPuih/wY=", "IJuQ6SAVoY8TvRNDo02QX8o+1VuIvx7qvT5UKYeghig=", "C1DLuYxMFik3lXNebK2aRY4tN/HAKvlbFScq6t7lMHs=", "KPCDKCwdw0e7gEn1lYD8gr6/quL9TVwxmOq0I1dlbAE=", "Hjz6Bjs81GemnIpiimJ/ryYYd0Soee15aVa8HjsboAw=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "IgY+UaJbWgRZFGUbOz+7QaQyos1J+voabaHxs6usazk=", "DtHuZdKyy1Llxy3BgITNr/3I7tLb9FMJqbMa+jI54MU=", "nx8UB6OVOWvo79SQkH5xsqHhp2H1WZBgsd35ur4+ww==", "JOIsPNQN0B3qjKALSsHcjPL+jsdATwnezbXy4n5PalE=", "KX0ZDGVDnekS2bGaUaNPOvMGI4i8kNzwLJWsVfgn85M=", "y8avKnKGc2//jEQtIKzOoj+SfELeaMWWW+a3P3h4cQ==", "C/RzHGKFAzZ/Ogl5006/xOGzpu6MuQ+OFF6nEQj3exk=", "B072Mt9XCQIkeFEaafDDXxZ3GN05Q6hx26vPz6/MuZs=", "C/MR1q6XZHrqFSTVxAE5KipiQkIJGGB8hZUHPwAWPys=", "L7F6J+XZPI+hmAkdKI6yXMmnWjzCuynHO3xJYrprArY=", "F+65dKS7M+w0mtxOPF6RQcP+W1K4qetfVYl/zT8T3/U=", "Fsddr6lLE/S69ahJqpPe2kSGcR+SGI7kEIP47w4qGaw=", "Ei2oGJrXDjwoEJreAVZvRwOc4qNdhe7i8iEhOdfmqDs=", "Jgly9NEWbwpTJyqvID1UkJ83L571F1+o0V+GMpm7rC4=", "rdyDyPI560YXyxpqmbnqMUt3UlI3nUooCSlGg07BjQ==", "DN/k/3YBhKSx4cffg1gkgww12a5xmZPhyLYZaDQcdP8=", "Bst7HX7otxXCsyWFPYN08vHt0cR978QtVg+x7C7ECTs=", "CNSKyReXD2MYqLmZ/PpkvQAmkVz7uvI1bA5oQVtCz2Q=", "IPXsqTSpIvIyTsT1zRQj+zQgBOJNtkLd4y1PSbAg8Z0=", "KSbBEHt0dSpbCwMm+XddPAKQB5uB8e57NUDIV6Lm5/M=", "Kte0DaVYPL/+Qee6ip3PoKoEUm4Xo1njgBUqsFZZqj4=", "FXF2BCyMNnjmpX23fEIM0qrGZY85Lu/sa9luw9ddFuE=", "DW5lcHuUC7QM6Gi+aZ9Y2PMoxjWQDbT3ONmuBbM35OM=", "DXlLD3ljYpJdPD+Pel/A+omV/xa3zRmKek8peAM9PmE=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "IKUlyki/UCvKDcmqsCDhQeJrOOxHpE4VgMDRthY1E5g=", "HuMgljMydikAtHRL0g9vBtkGY8mkXM+HbfpG/3tqZIs=", "ImNfghDLPNWl89bzwF2zX0j03ZnOlomkpJwTlv0CVLQ=", "I2hnBpU33HYEX7zDQ4fA1lnydAOPYL1GCSx8XG0qk6w=", "KUm/q7CdUaQ4ugyEWlacPP1BWkdnurukPUm0p9I+/lc=", "GDTS0Jgsw+CmeDoYF9CnCTUpah4c9s7S+zbkk5n/Ep8=", "BCaI+B6Q8CHGRatp6thd9WN+jDXl90faK5NT+6NhR1k=", "LL8+rzmtBCfON3cBsK7QgasRpNhCWl2F627VReAqPmc=", "KO55M5xXliSRUkM3mB8Dl4MEKmG6RrxLbSeELOJT4pU=", "Lcaw120zLFgrwiXg44UqhOZwRBo0o1JxGD3QcbOoufE=", "B8+GIPtlsnY8SU3aAtRUwy2GkYvNlyyBr4iW2qLiUiA=", "GdMwUDf+bV29scLPB9vM+7N3HddFoad2An52uCnDjhU=", "Lm8ZV1sOkXwyW1RVv8l+ZbCA1co7DYZqEzFe/B9a+0M=", "HnJsCs1uFp3i7urO/xKOdpG31PqKBG7UGoKFY1R6MnA=", "JSekKFBNj7rRqVRR9paN13UOm4jrc3CU0NIoBupGG/o=", "HuDhUb/8r3Kqlic0gYtTCGr5pe7q+CH6haFs7t9QBt4=", "EzLY6lFCJWQ+4mzxTtE8KTZ4DTsN+NE6DYDHWTM53Bo=", "BnRA0bXFweN5IVg6xggdfAthRDBGGrvONEX9yhwl5Ss=", "AhfhW2i70NcDKLqS65hIUzp2+hdwFbvhZ9lkjiFtcvs=", "HV9VUXFn6PTgeuHY+wJbqvtoBy8Oz8OcKraRfiiD8AE=", "HOQxiUchKTFzYEtUI8874qoqTGAiRMozz8R0NkJh4hk=", "GHDN0lsAJs62you3pKvkyDXMVPtdSivcq4N3duSkHzY=", "E7bEyKl5ZVlxjXL/MtBazShdTjaySg3aCRgdzAuCEiU=", "Dlk5jLUMmV3flGmJDBT36zW20f8htU+ojXUQUYDMnIQ=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "JHHN8SjGVwAi+heGo1s3lifN9KHPDIiM3fgBlvrXeGQ=", "Ht3IwYa1lSI10XmAHk0fVSaybnLWN9SC00qvis37xng=", "BBKHWW67ZU7CcDyyiDIMeLA+JSqY0wS1xnDWqfO3XxE=", "LSfN3WDyfpMXIK0gYzouCqnp+zTlOhySRJxCU5g2zIQ=", "A4ZGTiae3SDNSr7bkuoIPVJRYz7C7UC5ySmKawPQxH8=", "B7KNbzgef7BUFlUz5sIr5yNeAdwhEcJYbIjLaxORXao=", "JaUYNuMtMRHB7zpbIipFqGR/SRslGg59VIqlefBN1TI=", "BBM8FLs29PAnNRRHA882sObq7DWiOyOls9e7zM5ynjs=", "GhB8REF6hf5j+l8yvq4RiPfvnH6Yh4QOBsQUQgZftZA=", "EZY6f49iq+h/0OnwWb2iPlbqBE//MWcsFmUwlgNdbmA=", "BjlCKB2nGHzxFVITMqVIDqYpd2RUDa816ET5qdsU3x0=", "KDIxhPfQP1/bjFVBYpGg8ok/P49wQ0X9GXM1urYOYxM=", "HV7jwxS8zQUH4OHz0izeBfi+70AGvdGW0c2XKgDzKLU=", "Dj5+G/d1USh8s0NqBry6E1au6UlQfFDacHX7pwJZBV8=", "C9sbp1KIrUXGU+ZzG3P8+MLloGRSp+mxBVNJyhuVSo0=", "Fj77xTE6Gd/SmbT30krDb8CdrjFr2q0i8uc1SJBIezw=", "BlWi7pgRvkE4uHyurENpMYe6cjpKJS4f5apIHN813PA=", "Ihq3ApykHLNwP9Jv2/2Z+D2mLj1q7ZxxX9pJPnA97RQ=", "F+BqEeR2arla5pPvd74v1agWq+uK9I53gSrzGpvJdVY=", "JP15/4aagAB1U/5S2uh4QdJxsF00ZeIWMul4CNtlink=", "KTeWTLX+/1YVbAotNufXF/UTPFIxHoqSUOPlOMbWouQ=", "EVtUyllyPdzwuLcuAUo1Mr+5Rh2wDIe4Bebrb5UOsvs=", "C4O6WVRJlcEJ/mfFnhxmgt9PCpRCBEklXy5CEl0VIuQ=", "CFbOC5xHJkJWOlj2f76EkNIT8eYMhBU51lk85yyMqnU=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "EjTN5V8c4H6K3YkZ3CeGwqLouqBpn5MJokppd89N4xI=", "JyhRhAZFPCH4DN+8WuWn5bxmCFPDnAfwj0yki4Zv5wg=", "JjxuhwaBpWiHmvcFnp7ubCEHVFd1pwfl05fgkLtAZoE=", "JkuRDF2cdnfKJrAclbLqvaAhVdI5p1JarMnnw6GzEQg=", "A2JtVCXxluDsxiXJXK+ZwXiKsIgm25nPyZTfwHz3zeI=", "KFt/yGQMVkTvWs1266Y1eISQQISI1MHH/l4VSIKIWyA=", "CAbf7TSp6DfWJpRCoax/Brkym8kbhBZR+GbQAUV6fkc=", "F9UB0YpEPEWLwph6xwChZ5NfyVwLQ7K8MdPR5m9PQYU=", "HCZRRNhQrpRfiW0puNJVWP5XJDfPuyPA0pdO11qERsE=", "LTSfyrMX4vEEhnKLhbc/1V755ykT21epbeN5nXkzGls=", "DjsWCJyGx1GOzL8+e11sk6f1fdZj4xO9knhZm67b6NY=", "FoQhhbChk3kjmsb8lXb5ZiMj6cyxnHPKVR2uWiBDY7o=", "Cv3fag/1Ys+M+DubSqf3fKWUTcID5nFu4TaUe3d00YU=", "Gnub8CETVS0iZ7Zqahg8WL2bCnG2B0JANMokn0gFau4=", "GyktuOst+VXRhgROuGW1PDRYVfsE4OeqNHKPOjPcj2E=", "EWa8JUjk3RpZeCfh/2uHO4wCkFZzPCsVUkWV9mRvuaw=", "J+95Gx+0X3OVDKMpetLv9mgWQkDKD87E1QU3k0eksy8=", "CU42cS0+A4e+I/To0uiTIzPCtbMp/wGwve1kKHWqjYw=", "DDy4yUUdxl4rrKQCEBK0EHsSd+wejPhWhFI6hvRFLKo=", "DBYGbWNkE9ulNA8txYZX2j0E/U9kkoC+0q1sQ9uiJVc=", "JvU9s6Gfu66DPm3FBzMyZRJTG6ysBeEUK1Fp4KbzexY=", "F7+2ZUGP7A3dZJJDw7d1Fekuulg1VDfszjmiGz2lZd4=", "Ie1mlxpeDhRRqWV5GOK6zCyyRNLxAeSocLfEBADY4AQ=", "L8ctNyNF6aIDRAVLEw+RzDAdQJvS7eCDgLHSzJKWoKA=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "JCtOrf8RxtPVT1NydV02yYKas/GtNs3n+tG0knvP338=", "CF5tUgW8UXY0FH7DAO3PTY5A0xmyd02oWaZ37oI7NHQ=", "14V/jC7x0/bMC50mkICoNS9xbO2ahUG1gEdXCTHJqA==", "C4p59NY17DjBFyD9trypo35O+Lv9PDp1OBXsyXXGsdo=", "LVgfTdT3pIcPaSTYzMOurSd47x5t2Tt2b6qJczxXU00=", "AmqCqJrDRgI4RAb6q6wSBGZAiAQrASxiwxLRBZfURz4=", "EZyc4BaN7+6o6uEIW1eDbbKImAGWYehPmIuwxd08uxo=", "H9xJ6sEookBXEo2S7iuK46KNKuMx5T6JipzEuqpn4UQ=", "DmN5HtwIXn5o/oRKHiiBdSFPU2l8RHoGr2aOuvliTXw=", "COipXXLIsPVXLkNM0ejymiLHoFG+7+OLzByMZwIbbNA=", "FQv75lHLEpRSWBwKwFggaJFNa2Il7uVPPQQeigTulZ4=", "H2exiMvdyd/nMihVf0HijVYutxIzOZxRoRILb2qoT+Q=", "A6lO7Ds7ANoSmhMFmIPVa4nQKHaGHMr9Z38baS503ts=", "CKA6mSw5G+1HOTCOkOIDnK8mQisPwxSEEinZ5l4pMFo=", "D122i3UatinquIdgBVNDduecTPKjwM4sdoGppneHr9U=", "FMHPnuMfwRxGEfbe8JTmko/xRpz62Stxwn6wKTiZncc=", "HIQwFw4NJ/yFI8psWHjbcXt1E2ZptYsFgieOS2pDIH4=", "AuqrvpW35tQeI5rxIsOS8sikIjCcqP3z9z/RjE4ma1A=", "KLhfdGvAOxpkl/moX6B+M3tmSo4Bv5aglhlc3Y3P140=", "LuoJDd36ttnUX4/cAeBpfbJX1kgezuRO63NjEKVxlKQ=", "KUYcz0Sbn+OkizUnobeS8xdhzoihKhvRhdApiQSMZyM=", "LR66WKcZau7H/2DJIqajfSOL2injV451SUD+Vfa0T2o=", "HYSIUjSAA1RU3UWrETblW0jOcp/Df7O98HzUAePfmGQ=", "FpkEv09zSMzTQ1E88DjMVGzRN8dAt3099YrabN1JspI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "D6pVXBrfdx7fobT2enMQjHMlvgNMvCwubSRVTmLv1zc=", "GkzqrlfenbsZuzcBrgIbeyRvt1UKpQXfj5W+dCKTt+I=", "ItjraKkG3K112ozmL2djy+2oAEc5hRBXllMCaW4YWug=", "DPyCqgiyv3+vfeF76a23WTicOYRBvdKU7Q3CXT98T4w=", "IWpGJXfSMRkGBu8pIMY0VQRbjVH7xpgaEDpRNTNfg9w=", "DmNxWsDIlhQoFJPhawv+bREZSzbBJH4ig4dx6x7HZu0=", "DQJBBureVLn4tYdLx8NJlIc1Svott9874alxyNJAUmU=", "AR2uvdkZtWIuKUMSpeNBIa4zEE+z4fnona0GaPBRcVg=", "J0oBmJYeDJjqD3X+HjjuXlliIlc41sjtzdViPnsk628=", "E21Jg0hk5CkXvOfbsOQ50owgB/vwm+rceEl9HaJZO1g=", "GNr/Ar6TMYYxmuG6uR5CJWxbVuo9LQaYGJKUgo4qkHY=", "E/ut+CVdsJrWso0KE4dOhYb6VlFV2iFF+A/OQPDBdfg=", "B1p2FSy3fzp067ZKi5SdAyouHvfvDzX93P2JRztcHnE=", "HRqdPv+AefL9c5qMHsGh0sORvvoVxEl+544symoydJU=", "KRMqfW3Agcxtelw1JPKAXJrjxmp94XFMTnWp7QYga7M=", "DBRXtNxu/W9QbxTSy4Oa22mV4lZSI63TB5gBgYorO5o=", "BmQGlWqK+VwvjoT5dxYQBSh4MutIYNDjM7wqZzi+QE4=", "Ar6M5pZScsPqX+8wXYAFaXKwzBDMibpW3yNHNqgWiJU=", "DGJMW4T4aXTlmS4r+ZqnQG2wv8d9t5nmgM7tBRV4u2U=", "HJ/HsHYlWx3USj93vhK4wMcTaIDvOfAqoAIlP/gIqrU=", "HtV1KSAFLWbsieZxlluk71vqybmCt0BRdMjCz2K6nCw=", "EaednnGBbS+QoWgTWD28soasGfgQFrAf+kMYvgdJl9E=", "IzLy8CMeGl9K2uJmGkmIx3P1j4Bq1zzsf6hBAyfCnvk=", "CSBBzTwfJNyHAAU7bQtNEw+XCbrnHsOX0eu80IKB4eA=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "I0AqBKEqs3drFBGbv4XNpOiGbdHIwu0gnFz1qUgy2a8=", "IfbXxswHUIaOAxC7in/gK3CvrQIp/a1cXPOPcjHYBSg=", "CqEckaX1R94AYa1axka08XWA6YXZJtxIMD2pZd2ZRnI=", "AlQtUfJp3lQfcEDX1wf9TYoEXwLH8KZi4EWKvRx4fPo=", "DpNntG5riTY9yc/VI/SrtNEjoK+e3dXjVuY+PUkJJUI=", "E9Kq5B9rHBtb3ZxXbHRYcJx17revIv4Lf12Y6iBgkAc=", "GaKy3FmIqf/dRYOE3V4M7nlwr7OMGCP+iX5IX82p2tI=", "CN3c8ySQvpTnvjgQXnFzgveWbe7828Z0MsMSuKqxWhs=", "GjCsOIngRnrSF4+9hbk8zEk1ZcN2ICmC3Rbsm8ztJh0=", "LdJHDXyl5p5XKOdq26BE6CFCWyRbtc39SBMrTfXzYuE=", "EEVj12JGS+E/UQUNPSEBYu4x5LFPDjcgKq2Z+HI/CsA=", "Eht+kQoMy05NXyIGKM1kwoRvxfRwp8K26jgXC50Fizg=", "L9Qj/l0Ymf4FT/G5aE/5NUC8OWWJKJOIaBuQ/LjnbBE=", "KY9zKhqRJwL6TECQ0Ahh2Zu9TrgAsgrN8cnUpsgiamI=", "JvVs5h6u0QKUcnAU64itqZ/lAVyRFwXPfte9jwQmnao=", "DDFut0eA3vTHwIQg0aiH0/O4Ao8tZe8+GIIrqXKlDJY=", "HbXGWi1mnJKOgsK6eoUhPQOXbnNVvTq6kERMjY7LsQg=", "Kfvj8LXWk29OQs9e0pThoY98WX+u/QCHZT8G8c185V4=", "Ez9TdzlN52ZQMkF32JXP8RtO25AnJBOGad9j0GQlQnQ=", "F2LmqZBlShjrFRcahAMOQ6k0gexSC4b/ZSYwVVUdGcs=", "K6xi5k43SklLm6NKycuHLM70KWbhyYydEmluG3ucrw4=", "HcL10ZKwZUYeQQo1O26e1I+N2aW1ng1FZ63Ryh7bv3Q=", "HniTD76kUHDcY+uC+jtE/riBGELIBA9YRILlUpucCPw=", "EWHdg0RbxKwF6I+CttSzldy3vAi+9rwDlOKGDhuRpF0=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "AthDArLxzjaQM6pd5buEmPcYECZCY26pihPZ8vngPXA=", "OqC20XIsLpJwePDQ0qnhZRo4ewpQqr5MPp+eKc5YCA==", "GFGiVSDEfEBDmr8h+luQB64VV6DXpzfr02ki4ewv5xM=", "DIgji3vFgr5lo9l4CxxQKosqa7/PY4Y+qYjkyvbnV2c=", "EjHf5OocYMJjt6f4ScjYy0LFUGFht/qH5SfpF8lCxeM=", "LqCEnyDW/yWMDxhMqAV7/iNiRd1LhkLGTkLvShqdj/0=", "G6YhSPV/QgEBxZnuygq/kwRk8sBESsuQ0vuW09ti97Y=", "IfSjBm+tCwW8abkuAM6hMnjRpaZ0NsHz8hOabueby9o=", "G+TG4D0oB4VNI0Ny8mdYEFixc6yLPHSDxujcM1J5i3k=", "Npz51FoVYzz3XSI08QFPYNGrMMyiGw/GCvPA+6bMBg==", "JRugDmE2vZkPTbdFeiffVObmqYZybLAF7iHhc9ycmCo=", "ApBGWqIZxfOfx9xbIQzoBdcNMTfEOrNUq62scY9TV+E=", "ByFT09kwS8sSHhasQ7o1LjSSqpJk45q9CtUAADssGg4=", "Ce9u839fcDIpx8UXGlSp59cBUatHtjEqO1kiCMGSzC0=", "EEG5Q2Jzvs42v9mAE3IlHC51O1BIWVOQjDW2OXnZ/YI=", "Jq/nTSu6p21WilW4/jXwLl6RMoXLVnitYxZUygPhHyI=", "CrE2oCmKS74NUyUNe+EXkSOqP3OQw5wI12+svPOH77I=", "IVTfYUOPpyiFOx40Bkvzu5iPNq9IrGCX0oRaTtkko2A=", "BZsS2DVjWM3zaQyiJZRHpxR+Dm0z3V4MYik8H648cFc=", "GgFkbtQFBd8+vQIPeu+y380rGU1pf3jrLGcGGT4lx4M=", "JwgOAPV16p387UVnR1B7VaBhJhjVN3ukdFsaLAB/xKE=", "A7Enge6nQ62XgDIkO1X/o8I7qYD48f5I9y7OH/4Jsfc=", "EKwsn3f81BTDvqms9zCHM4krGALQYfvj5ax9k6Q3yFs=", "DqdLJjkYW9qhdsKF9+Z05K3gULsIqh6q/goFFtWBRiM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "BCuR+YAHv638N/jHvgHh5tGloAH0Fj3sfm+o7Pfl6cE=", "BPAZa0zEov0ktgPKZfpOsjzkUjtpXDTpMjofVWk/CdU=", "IGh3SfnL5q74jCe2vMxAIEJGpnDt53Ley6LzSmG7gk8=", "L5A5pLi0qyJ40P3Es1Z5Z4sdgkOtS7gUuLe8PhuKS0M=", "BgEkB8zbT1rMwmiIoJTjV1CqXYh3XNygqYgegW/iQPU=", "DjUEbEnMVqfshGMFPhWZJb9VEJ6Pz/WMr/CHZUdtgj0=", "Ctg8Klh7mMskDz/ux4xleEc/mb9yJKzFRXkwlDM7cA8=", "C9okJUcz17zWQu9HxnMXYapn4boOxk4DYJ02UuSV/K8=", "HrBKzujDJfr1H2rFMgC9VrBS5IgGvBJRPBZekMDqdc8=", "JfAJJ6d7L8iuo+PfWgOO+CSb0p5/ZCJSncznaS79Y3Y=", "CG/0ipMLWAfaz+Q2/MZ3Zq1CU+NSkHwZVxJ9akG2OHo=", "ItMRA7IaoLeRI1zpDvBs+XLIFlvOPGizcU+JRGpC8mU=", "IfEL72jiuENzMOvadE4sPh8mqSwzNsfeO2Raj0Np3I8=", "Lj7Yc7D2/3+svuOhELq6ivAw+8yu6jhs46lguzGnGVE=", "AW2GdRzUXTe+2rrKatdSd+mGTT9tMOTAzC3SWprlja4=", "A9BZdk5arGhbWTh6pISWDtTvljmEP+MI+Mw97ofjMU8=", "Bj+WKmg5CoGOVFmV0rPVP4oKXwqiNFHm0UsIUauLtXM=", "LX30hFlUE/g4Ye0F8wFG+aTv1GsLkPfKlEDjDCfJuTE=", "Bdlm4lz5zul05AXIaqKht65j9aiSjhNuEiSdrjyxITI=", "Fr2m60QUX4cOCBi/b2CgaCiKXvI9obwmTgGhH8HgE8E=", "KH8byATvUTdc9yC2gFAff/HJfL6YB0zMIm0YvV4Ys4E=", "J7Ht8AHjoKhWK5kaJ5CltI479F8tY3rntfG6emrVgi0=", "B07hdy2GC2rQmxbYLkWOswUiiySijHDF9pCrvt9w1QY=", "IY7z2L4sTOvzssanXd+Y5315cpoPnWsRGsCJXr2rprU=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LhMPIao7yVLQC6JrELZcH1XJLzSlHg1tYiTS2rokF4g=", "Hm8W22qXo4THFkczQA7xQsQd6wQFc624sPxx78L3ZGg=", "DaZiQqai4ntRndIzXlWev4M0vLAGFN/Olj3Af912EvI=", "IB0qRw/bJAptQAjP3r1LV53zTCc/+2alLsiZYuGlm14=", "BNHHCTIiHjmDdW7V1co472A8r/LSFo9fk3wVEHdbDp4=", "AqQ9t2+0KggjdfXiHE2vOFPpxX2GJ8LK7i2DfuhX/G4=", "GI1x6Eaw5jxdZVNabRIalkjZmvcvcsPzi8M3UemZkYo=", "HLTXfCBRfM80a5JWfKFaS39weaFQo7f7yVtHTSwH0kE=", "Lear2jkleCVMbClJVZuFHKMS5cCY6he9v/iBWsQhaBA=", "CXusljB+js1ClA4w2b3ikEAlcV9d3I1iN2kcNoljWts=", "Ee9uAh1OG1HxVqHBhj1JfJX8HfAQ2QaFnVEKLC0B5Tc=", "BU7X8rLkz+oupiywE3nZQEFIHchelM3EveCNqbG6V/o=", "Ftg5CwujF0FBI2vyEoNYiIfOPrlmt9Rc3gZNXLKjVzg=", "LbhkAJn65LKbwv9zQk30hR4z64I7V35DVMy8sTku4K4=", "HeICX0vri1tYrL5hJqCS7ApvOmZDJaiOmii86Jjt+Yo=", "IaUUqNR32SowgJUJIiT1Vir0HPlk00vhgelTcFkLV4g=", "FAziyWBeMVduRk5sv8jJcS7I+i5G+XQi1SsLZAGqW1U=", "IDE7InPbzyJfdNoT8+DQkJ9H535T6DPkoS5Dnhhdzq4=", "C4JRkw5mI7jAYhY9lz7NsPFxYIwSbH20eREWYh8oaao=", "DQs4k8T3DRYXKISzfWJC8HujnkxxgEYtvtF1uw2wcUw=", "JpF7JBoSOQGCkyBpqZQgwxWA7PBkSan+eHHjGTzaC70=", "F5u6ntC8GtaUKZDkPeKrzS5wlNfZ+8AtwtgrUNmXDko=", "IYShua3qSXV9WdDBfDae/cBE8R/6FZjy879L8dx/rlg=", "BloIXOxw7VOp1Tgnx3ZpiSGcZHS8XUFb4XBulT3iAnM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "E+xj3ZAr5wF52aGQ8uXx3e0o0v7aXWrEyZFMO+3K6Qo=", "Jy1LbCHi99LIOyhYj1sPRikZVUz0+qtLzGaKuGyHfuo=", "EuKbIKUVfxFSxBxOgyKHuWO2x3TedD5NPXpVVMw5qsc=", "LHNSBGaQXJIwqmloxv89e+0xMM3OtovFok5R2oYcEVM=", "CzcPlQMytwyiwkfiNJ0uLiLi1KT1Ge/tYDlQT6KysoA=", "HFi9km+iDfoO07flP95OTXvE33jROWn6yZndhY8N9ng=", "CdUFlmKOAh8mSYOrYae607zezJ1s0+xG7L2DurVptmo=", "CtPdjHkNt33zWqeNyErTVx8KcP1wtewC+2L0pFm7fXQ=", "FU7BHeC6AiYiszqRg2SjdfRjK7vTpsDHuP13w4MVhNs=", "K+3ykIakqA0SXfb8ppPBmKQkImvw7qy/TDmQt6wIx88=", "IEupSw4aWSORyfs5dwHGLXJLVdKGZf85CNJ38nKMN+Y=", "EZF0H8D8vfWXazKVOt6jzwYqLaQqMX8KmQdCZWfXWc4=", "CEU6u6GoEs1wGJBJo2LyaWCrmGQOmCM6l5n/muvBW84=", "L6oWo0vHZbgD/DIOXJw9YMx6YrxDF/5ZlstTUu85Hwg=", "EHOkwTQU5PR+PdWPQRuG8SabRmKifRU7LqeX86+dhA4=", "IIJ88k2qkV3sygvgAY+V8z2hItvJ0xiQtFgxEyKW3/g=", "DBhL4UV80/MDcmcQObY4lOwYb3msEtQVXDY89g2pwrU=", "HRA3WFyMAC5PpkWEa4OqRtQYp+xHXzajELXpPvMLTxk=", "G/vmLjcUV0vtXIkVzJE+I85WVNIX+okzIIzubNKnpzM=", "CayKR5aOFH16v8v7gOR5paqD7DL8miH9gCd6BeNtaQA=", "Bmc+jAknSmsHS6w5qSgChctij0yQ8ynCfTuh15scwX0=", "KlEyKad6NoYt7/pKJPTh1WAtUuert3NMtqW/sAahTHA=", "B6qMLfSiCD5GFps+JPstCphn6hcQOhnBP8CPgyqhfcI=", "ISx4vwsDyI/haBSXzqGwMGTIfbCqJE8GHYE1o2UWgWM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "A6WN3kA2XXoCUPx1xnRUMp2gRoXgSlG/UYVJVKavkVo=", "Bw51r9yz2AAKtNRZ6L4cTA3KwhPjfDRD1dM95ZoxoOE=", "HcmbgULnzIHsIbx+Wzfb4rKeacKQxsZ6pPw6fU1vF9w=", "LxYKNiW8237sLrxqJ/bTquqijpq4XfHSwaNBJtLGSKo=", "GuQTL+gmHK/lYoI9Di8FnPeRcgO9PhrQ1xtYoPCASmc=", "JNX0vXRB3UzLgJVey2C3LmdkASOTcK1SaFG3sjWICf0=", "BJT0ZkjumW7S5/ZUrmwHIWwJC2xPNZnG6xiqTny3Yek=", "D19nr7nFk0otZiUyp+y66QrSYN9Biedvcb9RzmYAqx0=", "E1zSDEaqGkKfriK6xUAHHUuqWqH3zGYlScKhFeGgFSo=", "ELFLRe84tNO9Ekfi2jpl3+KQ/QL/GhXKWYsFVI0fk8g=", "Ir+xlToQIvIfFzjIBn0m4lDD2m2VDwwXompCD4mMFmw=", "It0aPvytqWNxxLkJ6MQtxCbg4EDRUpEL/6zKHsncS3I=", "LsnjVLX3QVBX5peCvXwNtHey68RZCSVdyQ3T5voVcXM=", "HRdtH0A7SkTlmMbcNP2vnAjlguVCdI2fGMnImIenygY=", "BX1lwZVaxA7SFdOcMLxh0BXlBeMhL7sjDMYcr23JyhY=", "DBbK2zGRdzEX4AOOj6SMnCALv+n2E1mXnJeN6NrbkiA=", "IoNUwkZntJTSzVPb2F7vV8CzYhIoz8de8I7hH7MxUh0=", "Edrgk/sEAIqdmU/HzyfQnsDhnsOtHVSLXh0gXpfemac=", "HiTYozcdKG1qhzWMas1nV/cyvYFrbHfiGT9FbCN/ldM=", "FPX6mUYDEkgb8rLGCC5frVrDZZ61oTl4sr8qJmJ9B20=", "J094hk6ssymj697zVL+6anpdIKqMpXkXwB1epXv15Ek=", "Gu8hl7KjkwpGbJ8vjtUSr0JO6Zze3w2Tm/UyPME93Io=", "JB5eE0B75ODhI/kQa6M0Kmh+bJZtKIs7f+2kr1MqQi4=", "B5FLEbPLk3KD7jEp294kNYJd8e1k12CmLDCuvw6m1SI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LvZP0ZRQZcoS9Ir//nUnreMomtNQ/+ncxRsssFiGtK4=", "HpA/2JdMoO+XwYfjCl2s11FRs94mFbsrgypsgYAegus=", "IOzxRAFIwrMfmjwz9Z2oEu+gdVUHKEZlodXUvP5H74U=", "FelWq1ocWjV+neQJoZOGq7rDe0U70d3RdAAAebEGNmw=", "DeIqYf1mB0QdCJQmR3fWYLz6DNq50dqIfIHnDHu4974=", "FKGrRN6FRhhZBewr+36bDIozAmamL7pTuMU1bLXyDnY=", "FCfBizS5sZYtteE5N6O71hoq+emzdg60KuFzlLnGT/s=", "J2sIdtY+MWxOsy27ZKT025mqsTv/bWZqqYWruk6cC3Q=", "GFZGjN1Inqdedd/vjTNTmvs8Po1X4HJVVIlzGcaSv0g=", "I9oi1/rfjOB5RNoNGrT0/J4tK7K6UJCa2ZyG9VbbBIE=", "HEH90PX/+z2Z3bOitn5ioT4Nu1IbtK/tvFTH/aNAa/c=", "Dwv7YonXbw7rqy1LX9hU4DDxFnLI82IzQpDgzR+foFE=", "GKwzEw5gXfAE1oLQj5sWuIj4jD4VYr8Iok99JUyicK0=", "K+/fsZLt9yUl6WzTruOh5U1AaBIaDrNNEGTot8jEQmc=", "B4Ofo43cNTSESNkqkSLYS6lRzO/MiOJhhxLU74lreio=", "K8NbK1e8myvnuKcoElQDxaeML01kXaM7QI5sx5Z01RU=", "Hzi/JcosZ++VjT6SpEw7S4C5ENPhDD0O52jyhijW18E=", "Ac0R8EWyVzffkYOEP1+gH3tasAcUEA8KBb/5Ny8GO1I=", "Cn+HeZMT3yxe3K8QmD2Kv5OEZ/pd90vP3w1R7+ykBsI=", "BxjUFrIBFFUczeJ0fLaxXoicwyM/rYozlGWrwyc9rCQ=", "C0U2iwz2p3rG5z7SP5TV+PuQp3Qhly2twNcMF845zWI=", "Ji2sQOd+/uWgc0XGPnfpRqpddkBAjfwN0PJ753+Xrps=", "DqSI/B96/skSJnwZMVQSwQdUoIDBGnhzyk0CeTX6i4k=", "KX2xtvcXSWls5I/ghi+mPV8oMGcVoZdi74upFbn8SaI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "FWyQ/0+VXg/JZyI1JMrWYI5NnMhxXCScNJI1NzDVALY=", "H0ZE2mTACQXDpuFa2ifPWTmYV09u50ToX6lyM0VjKIY=", "ENTljtbhcIlmHAvM0sRWTfEuvWxKiBFVSecUdJHGcc8=", "KteC/CXE8NtSAoD43ZKHH3vtbQ4jM3023yFB+93XBJ0=", "KSg3FiXW3U3jEQKux3JqFdiN8NoXPqigR+RuRWIWLl4=", "JmX/npUgTA66cQVW6R293sn1Bg3dpuiYoGuQeNFwq8M=", "EQ1eZIiDauS8NEy+JAb0lNzgZ62yHWnrlrQ7twg8Cxw=", "FvcEXBz9sCXZJrlmv5lHKO+Klkes0gskXqHEHsB71wQ=", "IVM9gTCrof2mox1L5F47byfhFlzHrPBi2RcKh09EVm4=", "KbbW4AZbiu3r0gSP/nS2roVzc9WDre9XG3702ME3bL8=", "K9DSntJ6SePPWAS8UVR1vSSCgwUwSF8lMnn+PfMTZR8=", "LlpbwXn3j1STF2BfJxZUu7cn9bNfo4kYowg3SiIbMPk=", "F6o/uNGHsvFncTGcCJDMmoFMT+88j9kCd+2nOn/Jweo=", "D+zvUG6aHFNj6qvS5ddf8GZX6kpwFXe8wNMc7Cgubpk=", "EE57xctSw5SdTO1TRkqiXL1BknPHFZcX1CQ7i6PmYok=", "Li2Hu9JknuPX/rSmZaZYQyuYZMmk06W1K7KBP0OvhFs=", "KnN9CFweytK68eun17efdvM4XsiM3w2II7xyHn99XvY=", "E0/+8ETW20Ln3gnrMVEYg5HUpS7U3xRXSfwgtNCv+Uo=", "H0a0PMLlf7nyKuts1snWcc/W+gQ3ArYT895s9dzUpkg=", "FCe5RsqTkVnh825qTojYUMhPAGmBc9je0t06ZJ67gR8=", "IO+uQi6qQnKiVdAvgMMEzrDrmdvnDnNJAc6DA7fnWZY=", "H7zT8rWmsIqfg10sVu1G+yubnwAI5x+tbwcswj7PTnM=", "GrHZFNhaePvn2wV60CUcsQPQ8f5PqfFWW7He/q3/tWA=", "GF08u705e0IC5tLSOlR175OqriXpxyCoSRibOEdfPrs=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CaMzOKgUyk+S4OsBRVEBNtJ9GpcOhZxGG5A1BQbA7HM=", "E0kZrLxocqiGUnrUYH3zKpP41PhsuxXMzTiePP8NVZU=", "KYjMIx9ZoUJT6XggLhkOYJBNNkGBlgDuxo47rVjmMh4=", "B6fn4CR9+zJ4V/bLmyz5EChHyMFiCb6BfMiYj0rucx4=", "AQJBXPwuhOO1S2NqESXFrMhqwkFKoqSjb8pRwJAumaI=", "EgVJHf2pbc100OpkydBbdKfrC5jMTc6XLjxlBy7HebY=", "Ct743RmY8H6/hXNM0tSAw4Czzu6cFmmCf5WQ8XZ9wUg=", "Il+Zu+lNXJPuCRI/RlXdLWvYCspiTk2PCgZAVOIyhI0=", "HowZJl5lZRUSWOoRIGtdipNWy2FHCcMeQWcEbVLboUs=", "BFLLz9TR3jWoaahawQEwgt1KwUcOQwRS1KjqFTD1o6k=", "KbsXmIai5JYxRC/K9oHnkKiQPJbR7/ZkeUXtYm3E1oo=", "HgbyRukmtRfz3gCAZ81ryfUujTgsRYCYvtjE0ssYPtg=", "CSqGJOCcwSf9fRoyqsg4PlEON9a+yj+hF8uxNV5uuK4=", "KeMcvST6neXUAUOEkvm5IP+lat73Ymh8YepWKJPOAuc=", "HUe7Zl0b+SVMPqWb51cYesvFBLU3gHb+ApxFcPg1ci0=", "Ik8cksDD6E42AiLECqD0MRVju/YryfJVo9dkE3iiy44=", "ECGgmUYNgB0XG7DbHHlyATFG0bCWJfAovbVSQtjFH4w=", "Ac1nyX52S4CX9ixkAvzNtFqb0Y4LtLQa4IwqJcJ2Qms=", "Dl29wKsaFBJdGdfu2cw2r2vdX+B/j/JphC8K66kCwqE=", "FkngSJywqjhE6X9hu3afA59guWOFJECONCWz8DC1sGg=", "LYYR9p8n9ZmsZyJ3wfB4cAW2/jwWLYNmN/wciQxscMg=", "Gago3pkvO7hmUKip84RP8n9wthLhWBcPgbfmtvTq5mA=", "FXpCeBF2F1e+wLLezRworLqI5w6OKzp7U9cypHFXKYE=", "H2b/RfF+DsVpDN/5nBrl0i7bsK4SqrGLpcGtrls25S8=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Ccn6AP3c9pTpiEUhKv4EBIs0kj1PtB0F+Z0klVxgnAE=", "GsFU/D9CFlhAxUo1DYJDo6KPVf0Djc3/YoxS4X9yqpQ=", "AohZyyPuVcJ7w2Pa4mSgSUrndhe6kvWV37sUVKomeO8=", "Af0Xmmb9s8sKBukNFATFDDjSusv6AwvNCybmrkVOP18=", "CH3HMZ9OiAxxNjc9E/1v2y5DPzHgme/d5W3l+Cl6abM=", "GpO8MBjsfTR1hj/f2qqwIz3zfD9tpalmU4sTgYwVxDo=", "EXSmYZRzmFBkTQWpArJdGIxnrHv6gW8aO5tzrJcxxAA=", "D96ey8xvuKnOSQ6Akne527cXNpZBuW+Es926r6OdFzE=", "IdSxDS5XenUaEoTQ0HnQZva7MA2zWpKJxfXrOeHkrfc=", "G0kSB1ge/t3fzfIzdjJLmWnjb2uoAY7C6wVaXdb0+OA=", "EkkOksOPwmkxG9wazSQQUCrI17MzTmWrZEdR0cbjuko=", "A8VpN1uUoCGielazTf3dFMAff+6+FOIx5T64EcDU/Ik=", "EvXr5qQ26FUXeIWLtT+XgEOesJ+irEVwltcVjnrzr7E=", "KBfcoxXn2MJc6FvKR+8kJHAckd9UdAfIkg1Kl07qyc4=", "I3+H+yZh06FoQNixFRFte2HZnvlAQ+ovwuMR9jv+6qg=", "E7ixrEXbaibIVNRH8nUMCd6hLCb21Ag+nos98kKKrG8=", "FCn//WgFAknhJ1EQoWrdz7EwDylNY8C1C31HZPR5cHc=", "JwA9K3+YBTABSh9eiMTMLEF4YT9lfCtAr8OBauFOTnM=", "HnySabaOj/LqXyHDdv/388Hewd9DoCB91BqtGschM3g=", "BzvM/uAnTuNwS6wHiFJ/hwiINpkITT7p+s7NGazALV8=", "AaI8LpniL2Dg7Mnb0mmm+LVqp0vzGJYaCF5CN12Sgj8=", "Cws4oe6BEUo17u61TUGUWbFylFB4nxQgL7hPAJ9yggY=", "Cwi/U83NSYqfypoHddGaP6t81vdwnwB7DS+wfY6nRSw=", "HTdVDuhyRXGsyf9AkibSB1VE++KzgnZyatHI7z0JYoM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CPzmFQtn9Un/iYlYWHw2ZVJ3RAxMi9lWWnulR1gPgfE=", "CaPZAwfKxiW86d1x5RPxRkIVPHxKQR1Z9dtZf96Ii0Q=", "BeLLoqMFwpzP4aSb8c+qPwDwl/8WP+tzCMQKxlTFlKI=", "AVHrT6CxzmCJJeJFlyav3dWreYLUdJ5hheXwM9GJOt4=", "LjKZvvQQl62eViA6wl61JhIUXItBE3WxW+TGD6+aDo0=", "K1pP8Ru6MHTw4MPdNOs+Ib0Ax1NxfxlQnEniygHuSM4=", "HsenbXZPyshsVc4HY0T3u8UYJsy6fpCscDIWhB/XiTE=", "Gf59MbeeexqFrkMLpHLPaZqBQifwMl2VfOE99lRDCzo=", "DBBm3H70eLLtD+EMnHoLy5p5dKT3gtA/JICH+sUOyFE=", "I7Nx9T3kNXCAXtTDgqTir+JiB/HigL2WM0f5c82OJrA=", "FbWPvic5REFe5otOI3+tcAXO2C/Wwviv0TyE6ylIixk=", "I9iSnOMP37B4k4opHdiOf3qALxcsf515KreqbtCGa3c=", "A0BpHzt5PO4MrawLlqomvHByxdGBURfjAq+pcOZEnvg=", "J03byCNhHtY+jLwpKUMNAlCINzrDvlZKRKc50R5LbvM=", "I6N+tyax/CmEFyjrZXGR0pD6aqrJJjaxd7xYJGXxr0M=", "GO4iSNlRJyW6kDCGlr6zEC5+qG3icZ0sUrTvwC/QIjo=", "BAoUz075501EODrmgcOrNdfGzQrV2UrY/MUFDiA+5rs=", "LLMpljE8bGz7zsVMT11bUFe+u8T7DBA7nRQ2cm8LcIM=", "K32vt1R4ndyx3sDOTsUP40DWo6N8jYG97aB1XcsUw0Q=", "E+RC2pcaTHFiC4D5ytSNcQVTVZbUuPH+VQw+4HMoxEA=", "GY6QIloO1rh72EegECphJn9s7k13qmMeNVzc35O0d9M=", "IAbMhu1Uv3pfw4n6W8qQ3NUmmrpN3sqV3hcZ7Yq2N3c=", "CInsdxLFmCUaWYOeOJ3uZvbZlG0nWmDC6iVmz1hu35g=", "BRGCYTVTbvr59fIa7jcRJbt4QSpgi7bCttl4grZyoIo=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LxAXDSqsF6IrIRJIYpUz2B2gDKVc2NcMb+GwaJqlUNw=", "KjXcCdRIj8r0NsiToT1EiWd5AaB/h1U3xTgEjvUd13E=", "IBsZeMvTkvbOKKXI2ClnMvUDrWPm+mFvpjnXAQ8kVbw=", "z97xZapr6jW9292XEz8k/lhhkTybYnT2G9uLpC5oyg==", "JKFFVcQYzkGyS1vxQwunZ5Gr2VUCK6MemtLMOivHKGg=", "BY0S4VydAj6hNIstxcncK0PFhU1y4/6YQeGisISFntQ=", "KeW9Gputa+u1qrVVWPw3XIioqEzF1/OlacdVP2tKvSk=", "HSA8JJCUcoYhJ59rjVOn0qylce3q4gL3JlauIcgl9jg=", "HP82Kw+SZRQdolkVs/+eT9izPTAaHPtPYGtHX7XSFTs=", "BsC1XhCgL2qeXoZTtvUgKeB2lj9R9afvTCSDeBMD22E=", "KbqnPKNyXfl9Jq+24qGngQWbgfgQkILD2y0tB2rJEKE=", "FrxxzwWbYnuvT96HAhQcXCrDGoYgol828PR5onSb56k=", "HLT0l5xLo3I129jeElvdC/7tp00dvI+HqRCEaGUc+Lc=", "HZCXtPSOUuIH3LWtoUoASRjcpioW8odg0FFsPMyQkPg=", "LPRE0aXG7VCAE9NP9A8nECfJqTlcrGTmRDz4itdIEgE=", "GvYGXoS8XZ9lPDagyGsPDZ+o/zlsDPciyXuHNqr2/w0=", "LixOz2IttvHlViNpfHCz2sCFDgNpou7sr9yje8Eg1xk=", "CugnADZN1sMB7ybYRAoeD7ceQQNVy/eYH+yw6Ov0OeA=", "KzvCAHs4PaQuTzQmmkf2KTkmQ8D9kDAp2l1gVArs6Ms=", "Cb8bEnwizRf0Yu1Jcq869hC1vrKBip9AXYUqFo3jTIc=", "ASMPI+ILYBHVw4cQF0gv04+Ckj2etPvPbEwS/XRMi38=", "G0fHIPVDJ3zbJ/1XtX5KiL5KF/k2f1zFilQezZlQBfQ=", "JVDscBjdihLkNXFiXVjL/8AuEMleDpKXuhcdYIfdeZ4=", "LTV7lrMlIGXoG18UBr6AJ6wg05GcZop0b+xOMgUmDas=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CFAOAdlN6QTXIjlmhZsWCvP3PuH2cgiTWnJu8fBKIbM=", "CuiKWM1tfdHTjUJ9qvEMuvO+J+WrwsLb+U5vR4LN/rc=", "I1bPFM1xZTGsV24wl4w+mvM/4PVGXGkopwqwZ2n7fCs=", "BMnMf/HmEkDxwMyCOar0Ui9WR4BBX8R7/7HCj83V7+0=", "KsEZU0AX+UwQP7YZndDEvPI31DUpTRYmnWncOb4XDrc=", "DwOJzirw9iBm4PCqq1Qcfx4BP6Dt0LrQxFSpvvz/m2A=", "HfmE1f7XK+2NKHy+O7/5rIEbVhVajY92i3IiYgurKrQ=", "JGS2uIN+3UfrYVYqjBM51ZRG3DCxK/4/62pnaldU/hw=", "EeZw+nOdwX3lk5dwgw06yop5GQ1BOoppKAJ1qohICWo=", "CCQTQduTg4jeLi8Cyfbat/IECioPstZ0vRYMj891E+E=", "IV/3qL/OMZOdhBO6Aw9yVECS6/4G+Z9hEApt7yIIlXY=", "LHzUllGJN+w3wafOniMfFQh8DyZqK22JS+4Ze5S5zVg=", "CbxbOikfjeJHVKZHmVanBHcrswXxq4hKeleknG68jZc=", "CxWg38IsbrpdZhdQRzLfaeMM/yxBfQ3S8ctJVFoCY2g=", "KZ4kpqLfTj3ueXqdmzCa9/OKoRxhvsh7PZ4BvBsoNHQ=", "FKFoPgztUAb7WL1fHo/hC1tNXbivbuEfNUJoPVz6Dm4=", "JVleWIhQXoehjdji8/2Zg4eQEZjMmCNVfjQWfStvQiA=", "GoyhYMsDscbgdMfqmCsbtAbkuZanD0MNqKeFVDXbzYs=", "SPpRHHjQRvp7P5YN26XrOedT5AwD4CahP98lCTYnFw==", "KGBrJcoDCJDgq51YzLCYdUZdNoyP/xqUAaGKBG2Sk0E=", "CZyYjuULWoZoZXCq3noH1/PefR675KchYSFP4fWVAaM=", "DUI7g5P4BruURaVfgqqjZjsle84HmBtVqdzGQPmzprs=", "IP0VzK/73gi5BKlvmhjOXkERKNpZwpnOahiGulVOiFg=", "K4tzH5O7/S3fEy8bnzf4IM4u/HZIXeIb7iIp0D2YblQ=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "C8tGVDUDSPIW2kf4qQhaJCEf6xUakGxYUqNut6WQ5eg=", "DgvdCWpIOzxxWa7L+/pSpLZudwSwWn3wXD/Hm+wKqQM=", "LOpmL3wk6KYRGZDKEPflOdykNcAi+lRHrRfxQHueLD4=", "JgSU//MHmjXq6IfFk89XkVCYFa4xU43NdDLsxsANwM4=", "FcAQpPxsweVMrX+JGI4jkt8n99b860lYt6xowjuN6w8=", "Lxme28pLtZZpsOTd7zOntFghhSaZrYsDyNPd3XXotY4=", "G2MBfDxNyU4y98F9Z6MZAYdbIN1nV8vIDu/Za79zaF4=", "IYGchhGe7iqTUzzAVXtwlRGabGNH5wKu1sQc3rVDZnc=", "LHrmquKYqZoNxT4qCq4s67Y26D6A+OwsDKXm0wwN4HU=", "JBVZywyJxBa+oe4IZsF666Kf3sp1q5jSiQ1+EGl9frU=", "Id6IXBYW9GCvm+I4XcuQqKRx+ctKS+jna0XQ0P4/jlA=", "F5ujIDdMPGwmjwIXbhPLDYg/GuJLFFdpA1ugzSiHnmc=", "HOIEV8FHHYNyBZH3mjOXmucO4eODABHZSUt2hvkENNU=", "CbwX7ekZz8rQIBe0yDzJ4cptRpXq/46YPIRRZDzX61w=", "EJk8IIXs5fHwk0PdUyVDITuj8EbFo5/KlBN0qeiXXBk=", "EeDesdooVzQaLE4uWdVzH9JA2i2tkKHoFbcG+Sao9lc=", "FTE9UA2HnW25RG5UZfnAgRIzDJ0dyiGxzSmBF0VtwXU=", "Gj2pf8uiZsKdLzt1WJLEQ4zKFwPTaF/NJjcoNy6xndo=", "GsO8F1kYAsz1QhDaLSv2J3JeEahgVQOWZzLRbYLHwLY=", "E/2f9Uv/GlYIV68qYgssstcl7Nq5lgPFjUs9gxH4a7s=", "EMuJDQnXkiuXDUeUc5ldedk1JWyf0o9iISEE1p88OPk=", "ATFknGw3xGez+Na9aExs0SHhQUzlomR/z40pyE+yJkY=", "J4QpboHL4bpSYhcLNdJPWp9ChXfHP1GIje7jv/sSRfM=", "AmK2RuZAbTkGfs9M0cTn1tvY8JKaH6d4kG9wm43ewKc=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "K3gCO1C8+7c7RJfdsLUZxwPe6FP7tTQ4+Qbo8DN5gis=", "GDTWSFQpGWYp38UHdeiBqlvGU9YYbr6rofv6cNVFmXc=", "HiI+ygZfB5EAFZhcgYWEa8YQSIk1XALv+ZZvGK7tc4M=", "Ic4sw5Xx6p7rioP3bV7yaJZDBPiR21G5B7V6OdQMdMA=", "MBDaQbe9kQF7vi9z8o1IR/GxX3yq5vGXxRqq2UlC1ac=", "D8eqII6J9hWytaxsHITbDIftA1TT2gEqUF03GCBfiJg=", "ExU5JMD+Z5AC3BkSqWab3mwL/FaJMVX98uluBaGGsKo=", "Hn7JynFRZ4ctBitqL5Kta0JaOutF5aROB5hFGl88avE=", "GDnrh3mK4LiebOQFc0t3D6LmCSsGcLL1n9k1ALoyvB0=", "K9klgAqPldCytsoa5K7KD+2sT7yIn0ZL4kOu9h411TE=", "Dx7GMd3G91P0KIuq7F2QiBlmBi2OAKlNHDXKpcH4fYE=", "CateFcHhz1jUbFXw30+jpWzzpB5SZksaElvzOIiHofk=", "IEj29otN0BJ9kVzW1wVqAQQUWu53YYB3UFYZEX9Yje0=", "Du0SRhTPKNl8mchaChRW0wPGzdLScDmCpC3WiLZVWaA=", "Do+8z7YrCEKqqq4B6EGNAFaH01EWBu5WyXjQ3P3r2CU=", "B4I7d4Taqf9YUxKedVXy+ts4mLXEy+9vTdXX6MeLtzs=", "Fh4qHbDuDnWyar8Dj/a6izltDAPSe3lKLrZDlGgNsO0=", "KBbXpRcI2ZSQvZf1RD35pSA2CP6xvK5CaNPaHlGY3Hk=", "CymL+vpXrr5Um48rD5hVSuAKF2FCcpgEC8gQStgYQ+g=", "BbV3m+DIyItu+YXfhR91QxAmcEjG5oE5uqpLQdAsumM=", "KVToDtSeuR1lXzJXHW7SRyTc1tATxi/Y2qBmG0wub3U=", "Efl73hqDDpeadkfg6vN5Z/L7wpUrtQykV1lho0tDrXA=", "Ltq9epm5jF+fhXDHeORg3BnErM0t4JOB2yriW4ev/lE=", "KFtZteQVPHGIx+kY3/wO95jRVpXJ+ikhrvAeh735v5g=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "COvoUEKLOy51NEIOhcxwSDoR8z0rX98E9hOC96EulZQ=", "C8hOIqKaDDm/iFTVEjXkXhhX6jV1/OIOiR6pLY9W3oE=", "DFRvhV6P5VKaMc7S1Tjc4Ey8wFN5q0+Nz1oFuOADD5g=", "BL7/Ksbbf8W6GmYRTvJZEAD4giSXtmHPFeBScZwFIJ0=", "F/4j9i0iHgivQoWCJEo6MdZKL7s39Y+OlLxxmyxCkeA=", "Epxqsz2rvmC1LJRE3tqgR3dd0B3oeGNsuAt9AU/JhgY=", "HsxtO4u/hqthTIXlzyxdyjHYbSq8jOka8j03tS7XhWI=", "L6ButIKIWNOnN/pRcPx35ybooM2kOKiSX9VeWT4gRBk=", "Ej1sTMin/XfFPeMviODga/3XiYaELIaRz3867cQ/zPo=", "KWOPdcTXrU1tqSzDaBOEvKpr2gqhRQPeQD8zD4dwCr4=", "LKWz8N23pcbvOI4z5QHg/EGosWhYv+sQiCvYOCOMzec=", "Hn4gYBIp3OBKV/IwBde4rQN11O+rs+J2o4oMsszit8I=", "G7l4GufXzBQee3Li//Of71e9+5Ivj/iL+/OVc4vtQEM=", "JhesqsfoVH69rgvyBjogVuW0LjkoP872V4slb7iuAe8=", "FSRCY3ZBitsuy76CkTvPBaCMDbax89gLW6F3HXK4Dxo=", "I7mggftJBSz0slIf9gDEcbIs7BybnDIJe8kRkgmfC0Q=", "HGzQ+HcxKH67Eog+Y5kc5aqMdoSZ9cl2KFAZtBrWonI=", "BWT5dlNh0BQaaa2prFIbozE5ob7IGxw5+fx51W+T2J8=", "GPuh9TfQvAaIhzC8/1cPYsjro1LSiQZmhG7FwQK77FU=", "Ls2U/dxWVElPtB1GxMkdJks+F9Xzd5HfJaQstoDhKlU=", "JRaLcAMQIW1OyfpcPjUU5xLWlKRvFp93kb9LAc8j+g0=", "Dd84o22skze0rdDZozosWJE0rurxQexaWwWdsKVGaQU=", "DudCFhCcSEUa8yzXkUtBc0vcw3xg5QWphF5WiTE8vfc=", "ILSqu7S7tIxPqBVVONdyCI/AzNFOye0nTH8zVvl5ngo=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "GN6FeDSI5otGWEZ1/3TSutRdaGp4mq+A8Mzz48Mx2XM=", "I6spiJ6K6uNygtrmruOhZiTwWCCMdK9QPe2mZkHVuC8=", "L7yNBt4Dkm/xwxFLN12HKDOIYlhyspZreB0m+yul1+Y=", "IZ4MTVZrywlgkRjfIjHmXp6V9rbhxhSWF6zqcIP9ntc=", "WyGywRlhfupu3NJOH+6xz3VWC2W4CvECe+Lh8UoV2Q==", "VFbUGvrjKW/UsT+KCWYp0LRxaRpKKdn74kk8PsN3/w==", "FAAdzwI0y+izz3mbzjd4gxdqSQQ2D4P7WQi1t9+SpEc=", "AqXp/bEnJEfX5QvQ72aL/5+8hg8ZHB4MrRVg509tIxw=", "IpSYecW4Pql0E9Zmrg6zc53s26rPGjN0K9wE+eRJ8sg=", "IesjyHQvjUmAKd59AXChKgMcSfmS8HqWrwSURU432Wo=", "BwVBBiFQovJSZ6hHb0G9rLKzV5x4VrpJBJmfktCzK/E=", "JmRRjKhwRDQL/YxafCuGNgG4Im3VZjaNo2uAhpG5RUw=", "FKqBySefNQW3RLyGw6yv1MWwPaGBKfaitn1zqdjntds=", "DsuUsWO1Ya02Hv2F24hhTGmom/dPXvOpOHVWyjNDowM=", "BabZoe+rzgoQ0zie0VcSg2mMkOdmNjhZrMkQlolotnY=", "FrTdCcSys5QsABnZ051CEmJsSSt8DnF4GWiZ9Jf4MII=", "BGB4Te2UnTaR1b331gKezi3sz1YvDhJILwAXFIlcvJo=", "LWNK1mkGzWvqL61ZnkWRLJkpAVCKqRXwwhnWY3PE974=", "FljrCGtUNR7DVzuK2CAfWk0fACa48ErKZsRMFudRbvk=", "E1oBHggcvlR1odMWt4xyThgRJu9EqaNSUVr86WZanZI=", "C0vJSDaQPJeHzSKylioFxCx70IGC2leeJ37Dl3QY/GQ=", "Cgo30HeFBp9H4Y8kXv/PzrGfJAXKAJlHydLNlWc9PKo=", "D47NI9oTXIgMdtIW+9oCZ9Mq7itKgDmqV4MDTWbdoRM=", "DojtozWsGiIEqsNWpYo8pQOuRUOIHd0oK/dJLyU+GTA=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Ck2jeVXbXSu4k6CRnk2Sg2GICq2J6HlzuTY42fRjI90=", "GCQg/Wsdi7lLNdlYdJmCXrUFXZXyTFoGH1avUW5xxbg=", "Eu0jbRo97EAGH5r3qtPNveleXUF2PYsjXGZdJbARUco=", "LSxQ428sLEAkk/2Y7buRTVkXAAEdOD4ok4TA/SbkYIg=", "Aui6DmX17lOrtY2gx5KGm8dCl0n9yIzPekKcHzVXXBE=", "CEkQMe9dpfalD+Pp/kq8z+rgkeoJks9yojnQ3McADAw=", "D0iUuO1YdBVmQD/7akaMvgNuNl07ORtyu6c7P5Fq7UA=", "InJ7zD4/Hna7upWqeqLrVYBjr5K19iRDOq27sP8zxwA=", "GxIPmZBCcwtNLp9OIsUoUQzCb2B2kF831aOmv6Gf2H8=", "Czf/NuUVPHq8LAvTbbM76E3HN4NAqMYlnerl0UItL3Y=", "FlVWSWawW0fRcdsk+BkXoilnd7Assw+JNXEhdmIAm5M=", "pk3tv02r4GhfuOS/tNtS5KPhvBeL9/SfEzW8PP+Ppg==", "IalT8NDKHUPukgxUqKGISi3Fg2bhlfSgMnBYe/OF/8I=", "Io3CydkT1PRYg3a+EqnPbVXXxZoUoV+bjr+PDLgBomQ=", "K0h+XJq7SBKDAUFXLYsZNrS4zDEZoAOPdz87zKg9SbA=", "KFcSST5n7UIgUlNnMaMqsZIEN82Afc1liDa+uRICK+o=", "JsG3FbZPS6nUfB+X2Z+R6kuD6hBSA7teS76LPm+rzJU=", "DBiKQtR1jsvD01pz5zXz2soSldDZPQHu1sOghc4dlek=", "J5YQM3SyZVRVfx778TfDyv/sAg4d6dLnX4pRtd1SUk0=", "DhUj2Lqye79f24XqTur1e6/q9QSBzbibgEg2mNS0dgQ=", "FyrHfDeqOHkFBoMPrNqwbQkampi6CkRQINh6VI5o/dU=", "HqgosFLMyMIcFBeyR5vyHbvriwfx0pRULmt3bBekbKI=", "DFMONvEE+TzSnp1fbMdrSYLI8G1SaE7Jtrbbxs8+Fhg=", "JXSX1DKl3bk0FXwc8yGKEEqj/ljsfeUAL4K+hf9KKZI=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CbC0SD35KYMX+1sGjs8ykdys3a0SLU+YyoSGjO4l/fY=", "FWn/0xhqRDJS3lVpZhw/jqx9/Zh1aKrLhuV20/aJQpA=", "IzWUJUTaaKJrsFw8RIRfDpYS+4prM6S9gbDaGBGxU4o=", "8/7DBeRvPewoCoJgh98XuqrKcEhAA49W+U81QG5lcQ==", "HE+zZrae6mwa1YCvcTDzPr4eyRsETqHFaXvN5XK/1OI=", "EQZqMANLD1oKwuLF0AcgxeEcH8tx+lfnyNrJOOf0+Mo=", "ATauzn0lq1gXD0Ut1Q2+abH5p38GD7mbDimem9u/0kQ=", "Blb+EIeFqX3/OG3x5OLtttaNz8nLlh59RKsNFIR/OBA=", "ITLJqUayys7MdbvQuQ4P1/HIZOyBihPPwmY3mkh0Cho=", "AmzhnzA1n4cbhg9+dA4TYajcPU+sqAiQBZ9odCtQwbs=", "B7NLtzxpqL78Fx0E/cUSwubSmZO+KqU3paknUD0yfxk=", "HSB271enUVEpdSH+GurVezYaDP2Q2cVuWk2UoDrqTVk=", "GLLXZF9ERl3p2HU1RxZybjbwkrQ+Eaov6090n1zDBVI=", "KdnpNqiCgzdsTMQQW3velOxkiisCxL4DJboO5OjllGY=", "CEMzGOOVBkvHIKGM2iTfV4yrUbE4NOA/gwPpiKjs7H8=", "KYHvux52E3T8sgcVUn3hl9Ms9Nh4cWGbUF0/X2fgz78=", "KKhOdgm8TZ3klLUwaHMMD/0VTedwEaxLqjoAvB9WXJQ=", "C5j7CkLKSXZi02VeDwshWsp3a5Sw6ELnzHvYD2qgFHA=", "CS37GAnM3ejs9hpmAqaf16ueoPiDeYQlucpGRjfKH+s=", "Iin+z0LKK3JexauGHtBRswrY3TYqhEXm5/bm2IjO9sk=", "Lvp0VwhGKlbZQWWeTWO78rFde1ywD1f32W3kmH4OtUU=", "HriPZRIybbItW7joqxzibvuLVR+NYBBDjQ8m+XLJyGg=", "A1f0ZAKDV4Je80aR/Ae6q8d2UxBaX4lXd7zJ/vbkyp8=", "JXS2turFlAJ0DNnvD1DiKeTbZBgl0v1/ABjc3vuuZ9E=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Is161IGlINIeRnsvokjSy1RGLD3sKd4pShZ4e++xge4=", "HqcWKSwhtKltyeJFc48X82S0qd1cx2LHqwokuM5jqVs=", "DuB9spUITod/GTu3NFSCScVmlFmAqYfoU88oPg3knEM=", "I3ox54f/q2vYA9RoPKmlusndwhIZ0RnVRwpFZ42RavU=", "ItWRSY/OfFkD1pXLef3KvrtZH8aP56irQ3YnnzyHmd4=", "JXMN699dquJGDLeKzqrBVA0bMsSsP+qElKgywKufSWk=", "L1SvzAq571mIFMCp+DoW1E7EjulqBvsd19hBTvQLy/8=", "EQhV5Z6/bJnGG7ezco2wFBsMfraHfj2GdDMne82xLvI=", "EAy7ODgwOKf3LcduDsuASHob0q+tuF7qpsSzim4kYNc=", "DPnvA6y37u4W0h/27ua2WMQmVR1aNG7D0iJqdLm78IU=", "DQR/efHECfVCvPysQHCH3Alo+eC4K8dg0e9yY5vw07M=", "DI01snNzhgrO4thR8/8ZWJelQpeXpAlIqwwY3Sec01s=", "CzTUzNQpsoMkY1iUqE4tCVwprVILxUNLvABOQ7eaP5A=", "FaqAlOiQw86YzmTNl/fCFEXOs8hjvfiniNSeIzzIkmo=", "EWN1U0J8zVLSjvBMVk7prwZHIV9/SnZNl+NLPaZeZks=", "DXdCS9KFLUhUldkpq8jqHlwqB6k4Rj2051s18RZG/wk=", "DEh3bQLXN+3JXaOUGh94qXbFBRvWMN6zixAkDNoduh8=", "I++vzJqP9Dou5QZ+mmMbC+IcHk8Cjk+nzvOJGeTxScI=", "JNyI1hRGafZejIsOC4QIHeQe8Aw/hy2rvrqkrj24BSI=", "J7RfZjU0Cnf4V8ciIKuGb3BzkZaDWiKVIYa8JCzWmHM=", "BwSyRjIjnvgW4XsS4LH5XBz3uPM2eiY66HzWKFglY80=", "F2y0mH+fPfc487yHcSpGNWVrSExSynYkvRJFwqq/Pnk=", "In64BjYDmwrmeqFpspsf+ZZv7e19I5xRxqy0J8+2H5o=", "DDFa7Recum6/VHD+6s4NsuFpPJ/BGTH1EmVUHFCMp4Q=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "G4t12D4+lV27QGP27yk7Su4YxKO+kifDEC0pwqhd8Is=", "Bio3IfxACZGOkIhGulY1Ayqi6qdInV10sTmUSG4bYh4=", "H1hgbLfmH7VRV3hDQuxSRVxm+4guM2C2kqRnc2ATSmg=", "BB6TJJ4xfbSVi4hJ3qKB6oHQ4gQQBmIMeGNjVOIMReE=", "FW1WGkv7xLVXqs9czEcBSD9MRMglbmGbb3p9rgnSPDw=", "Ee1fqbRq1LP1eoxQhHJEafNrpGzshHgl5iRcRTeg4hc=", "CIpdUYi+dBzQ4MzbEIddP6AYieT4Dlvm6n4SfVsolj8=", "JxpjK4Q4RkheKrD1x9HhT3J1/FO4zc2KdDt1ZkYSGdU=", "JsChxmMgFehonbk8UKPcLkCNPAUhd0qsCZuTHXKVxtg=", "KUBwsO9OalXohaErWHTeBN8jrfjwqE+HXLGMTOuNEB0=", "L3iTHZbF/Z0P9HCJ6YgJxk9a/1iy1wCAmYvA/l42QwM=", "IwviHY6p5MXSE5r9Gw62HRSyJ+qGTAkXWyOuSmR9Z9s=", "I4NZRa4FxnjLK5v5EA9R5//aypPnQympaMOSu6MhojI=", "GHw5+rPsxjQWbXiVn65lGrGbFpgXt+UIdi7jboqIAz0=", "AZTIlVx+YgE15iT/WrrVjli1Myw5DmD3cui03UdycN0=", "BlGXDj6LgWIn0wcHHYT92fQXovG4RLfsVqIaewJBpoQ=", "GI2cnQ+8NFn2qCUy8RCaBsWR0rN991DChyRJCPGT7vw=", "A7g2e+gL9PjjuQCKqfxkC2z6yARFHJGmxR1ghA+eFm0=", "CHYuEJr/MGuAOgyQ/xAxQDRYQpuC2tUGanxhxPzVLhA=", "B+h3SAcD90XGe4vN1qEYK/q+pU7sO2K4f1Pp622g1b8=", "CDodBRHVV2ZRp4q7ihSsktnWGkP5d8tdyb7+IVDgM1o=", "EI9WVyM0p2X1TbIUbq8bRPo5uRIDpY03ce6hnkbztYs=", "AlNxfxs6YFU7qMVgjS6bM9suWq4c3aZlAGYgWJGDFYo=", "D30lnWpphhk7uI8hufaHVIuXk7ESDhA4ZWHKW+gB52I=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "AsrsHako3j7yV+pp1RTHGPcNjTgg/hNdyBUj0uE0lMI=", "D/zEmwMn1NqyP+mTU5xx54zs5wxlBg/s93Ukik8wl9k=", "B9L4FKDVLxZ2mGZIBBxa5X7Jtfoyjf7loiIGwPVU/bg=", "BWPXp51fMt0jl6zaIGpvpJR1cu1AUKqwHccy/+yiNp0=", "J4P6NkZTgVuUdKmXL1c9Fx0ItNvJdxBU8Lw3anDtoHA=", "JtenaH5sIH9fpZfIRWW76dURJDwZF96GVrq904ug64E=", "FWeDLNcOd+wg7xBBNRV3UQYorCocfVwXnJgxX/eMQsM=", "HFnEwl217HYK1AMEfzGC4MLbe1V4g7In+L0eOEp7duY=", "L7mExcNqBtB2Af7My90UZsOPLuR7fdUmo0u7noWaH+U=", "GTxpF4n28XUQXpacq7u8eBEZ2qwJJ6JpTQBu28CEUIQ=", "KTTMqJGHlXTkTkuU9VVNzi5VBwsZ3kIbTSt0NBiyh+M=", "IiP33DwE+t3CLxwF54bdT7KDehQlxi1N79zsFf9v1qU=", "Jnoc1OzNrK5ydxadkAB2Fgawva3yTcl7a1CtGPQITlc=", "I2dMnf9p2bBtGkEQP1skH3iGJMlyID06SATiBD7q+X4=", "DIYAD1qUDcTCa3wtzsoQQWwN4IJC2AV1BqhnsYFpFFE=", "I3wSBAKrqJtwHX20GWjoHnyp5jtiQuVtnomx6Ut7VvU=", "Hyre/f4n6F1VCiaOOC5q+OUbk9AwNEQxEFCgvcOoaxM=", "IQJsqebBXn53VMJMFe8S02lpuyUF6o650k8hdiBjY5w=", "JX2/IH2DQevnGiXGfwvPxx7c9G9eZVwvlLsAJ2g+Tuc=", "KX/DVnJEvjfksa2IoMMAjh8TJhRrZYit0uErgSxTx+o=", "JBXusiIMUUtLUM7o3y9PYFR3tUDXUyUof6ffSVfDiO0=", "LR764uvVSJCgDoaDct3iSoqwJsc5e1SCe/Ub8lk3GSE=", "H4LblcZ7RrYwpAMQ2Agcdg4b//w56R8Xm5mZWo41VhU=", "LoF8JLCM+TRqIWWFcnlvkLgTK2JH5DodCZwXt4I1ksY=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "BYjFAhskzK7jt3/OZMASLzzyEoBhlASWeva+ghrJ438=", "GR5xtMZl/QlUYcfrIXlON3DDtAtLwOIqIQFm6cdKoL8=", "KcuMnrnEz1vG4cKngqwFAwFe/v4tZAoVTia0uTTclxM=", "DsHjiXkFxFHpi3dLY24dy4DtvK7JWbqQ0goChjZv90s=", "KreGt/+hcbuHZgODRnn0vooYSF+Tt7ifLa/v8zTVRp4=", "IEu8ZKwHYT/QL4cRIrjvAgbWcM/2CfwbL973uPHhVCs=", "EXLLj2v+IteFH3RmJjmbPAU2vcb4lpw7XKa2l6h6ul0=", "z8rCTm6ZrGpZ0pRt/sHIfUwUyVqc4ugeyMhAX3TqeQ==", "JXhxVqmllJtkk+CNpzGy4Vq7MOHUYNwjggfQQwKnN4w=", "JGrDBYUfTMUHntENdp0zevlknEbzdJUdxnSyc0hA/jg=", "LbnPaDaE654sx3JXHPjaG8pw4iKqtsp+YN8DneiyP/U=", "FmISoGUu9Gwi9tjY2MU9mf4znHqtxosjPIgvV5JUA+s=", "CYya/BUmtXKRmPf1i5BVY1lhQ8YR4bLI/5Df/Gd9HmY=", "I1jVJOwmD4OZVlY3hdGnJ/s2RUft7O9b9mTlcGMBpZk=", "GQG+B75FtPjTOAsKXlLB5qqU3E9vLkC6q7n5j968kfs=", "CS2ZpK3pFHnN+LzCLAUwm6B9hkAVMqr9/xe+5oHf0S4=", "E69JaVVafdaUgtHBMOtw4F8PmvOpN2n3+1Q3Fzxx4fM=", "KNOq4hiqCylkdtDcNzSB9K50beSqocgyg3DxdlVhSlE=", "FDERJb5pKQsJjFzLfnqVNHMohpWdJdZ35WTXGuGudkc=", "FFSDLi7URtasmpgfVnxXZjRQuzXtFH5N3fjn++MLC7I=", "EQVbXcZ16XwiNYCD2nSbsGb4qZzxGjcIPByZGvVnNrU=", "ILKraog3Nzj+wyWQZhFA/JEfMb4g2Km5OHF5VM5fFyA=", "IXGwE7ti/6USUAux660OEM05zHCUy/gGsQEzqfbOPWg=", "E9muUHBn6Y5nypesaR8oCCUbqEbJcJHJnkb4wD1oluU=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "KS5v5VkciGMZ05SjIYqvSo/ACyyY/Fejle0rUtcuXRo=", "LlVbv8eEJaT7LZ2JIiUqHtsU7kSFMoAKNlOOq208MTQ=", "BLeX/SU3mEnF+nA5y/rOXV8B0XECZxdnxR3MVHp8f0Q=", "K66MpocY1yk3Tpm7mZHvQ5n7mloU/3NhxS5HhXgVIcw=", "Bd2scj/9qAZ8IUf7rokIhL+Fcvt7MIEBAd5Dad77VhI=", "Hsjhfrziea3Ebd5VD9oXHtInNs5OECzI4284RKxn130=", "DcV/Vb9nwbaKo1EmSR1ua3j5iDte+hC49pXiqPoLg8k=", "LT9LztZLZLlYuNkb0LexaLpSvfx9XfGLvBoXb94Rsj4=", "LxCm1/h3yBS8dpM5XcNXB10cgWSVpPA7C6SdbY2XpmM=", "FEtA+6UpqNclz3jImBEvw+SCbIPBlhMy7Tuw4XBRvGc=", "CXCCJtwbzahdNtZa1tDKaTQFI+lw2uzrXMSMFtts86M=", "G8Nh5CCKAX4VI3et1VOFLa4bM0x5SOAI9wZPSZkWwVQ=", "AhjXB1AlwyvWyk4VzM6IbvQqVII5VdUNGr+Qa+aaGhA=", "LDZgkIPQitjfghGlHnW8m1JpHPXJmW3ubLOaE6sY3po=", "LuJffvj+2b+2kdil4hcXc2eVu/p234YUknFcS0EmERI=", "DgK+v/Vg5JsUgYwC4VNcXK4yYHHA10cDuOqfGVDnjlw=", "Co6TXAm+x4H2hYforqiX200+jWQ9Totlr5Qea1azXYI=", "JOTIo4gMB5UK8V5N13hf3/T0Zwn36KLf9G6nZwr55pw=", "LWgDFrt/3piBNvr9Qro22+2NCVIvSN2xmhTTniMF5Os=", "FR/AJC+Iy0uCD3lg5RmqMzxQJg8frHfuhBhzzkgwpfw=", "AqkwqXuEGiaAcX2DIsRj57Qlg0D4cljJDziPMiuGoXM=", "Gi0xUdJEFzpzYkYBtUeCgBvGwPj3pwo6/HCKI7Cvdbs=", "Aw/ykakTnKtrwLNWjCGtbkVCy7PG7Glw8B9Ks/TmWos=", "DGFCo47543CceGz0IFYpGqFYGqXLHhwqoBMmUBVSB18=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "BEeEZqnJQYPEMekeLZb612yuvDjPS2vWPUCog4h6oOQ=", "DSCJx4cqXg0SAznGg9EkPg9W36ML2O446ekCC+V8+dc=", "B4NfFPZG7xK/rmmTk8qHcQeeXlsQXFSab3QJibxxUi0=", "LrE4uOlqcv7Wb5iNdqVkJZMPeI0jKUuxbABsFbp6gw4=", "DWX8RqT1Va/k1hPRaWATnRsKuel0Cb5I0sfQrXCNV7g=", "Bcudb7DqXXw2rwOIkHcSThWbrz+V1o9cdLmNuJsfw/w=", "Eii26qUdZJfxL8+GS33J1oGzIXbKs9rniNXN/V//NzI=", "LHSpLI0zqwo1j/mI/OCqC6R1x4OYlzTJvO9qo9kuOao=", "GADlzpz4QOMru+YtgoyV55w+HEk+9w/4dDqIQxs03d0=", "BY/2cAFPRre6S9vUj+uQP9N/te7EvM9a8hvaQVR47MI=", "Icc/z5rRsBB/xSfWHm0aKJyh60YW2xv0Alecep8UHGE=", "LatbFCe6VdP6GpDYOwxWmXjj7PqSR1Cd0/njA7WN0MA=", "E7kFxq1ENNv/bngs9HDH83zBKd10WA7t2Kj4X5hEhuo=", "FlQtMNt3PFTa+fu+PMYymw8eMKXydlm1cY4HOmo/+ZM=", "L7nSwzJzTP1Gwm9lMo/MyhaPWHETaFYAKOKVPCpwllo=", "Aby8a1yxY6RGRV7Qh52hGWprxKvkXXuBr3RvR9tSkuc=", "Hdz3sOm8VKUHTgIa3XIxZMmB9r0E254VDi8OIaGmo9Y=", "DknKSsGmiTthcBoC4d0Co19J4yp++n8pesTSw+VFt74=", "JoMJ2+KZdJaC9wMCJ2d+UBOIATcBRDf3QzrZ4Uyo3qQ=", "G6wkL67ar9IF/8TgXOzsYDvq3+B2Zqf5cJNKKsb2Kco=", "KOIwWoCwFkeIaM9zL5ATuXb8kqNNGk3Kd65XLDxpzdI=", "FF3p8Y9Z42qTQVszrs60hVSoTrogxWBEiA4UZr7A0MY=", "GstJu18NPJOF+iAqIzUOlF9XJZpuzooVr7O/+U/pLhM=", "Jq3X2e006nNWayCBIGeHB7Han2QkPFWkEYlEVnL5dNA=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "AWBRdI7VTJ6NVuRaRaTrICxMkfukzPqKBe46mRAO8Cg=", "GlHhp1vVTcATqDZei+TZP8Nl7R+FpB5FGROgNcGpdfs=", "Jtv5nRcYmDlk1w5FvpmnhtxZDCsGcmYx5z5Czxm82tA=", "ETL4ZixYJZjBK4LbhoBg/QKrLa/XMNFJ8PHD27XHVA0=", "DSCr0bh7LcwJ9Ku2C2uTa/MZYWaEkwehRr3aeVMnD78=", "ExL5iddsbPk9A4ZSPCtEe+Xu4adncIWaM+CLr3nflPY=", "KMef53ir6oZbN8uftvy/+D6146ZTmiLBjLCnux7j/g==", "GbV3IorY5u5sm2adNrqOB5esdGFuPvzJ5qfoGWEABd4=", "FS3Zt3eNiUEwohWr4yBl163+lUKNApgjAdQ5CJasSkA=", "BH5ts9rZe2D0cgfqpNv3aeZIgKu6RHq0KmS06b9YDw==", "FvmtCykZdTxJUJulfpyRWqMjBmZM6SraQmoiyfY2DWY=", "KSHXQ31ysiNXYRg/7yKS1YHWCIP28FFjxxgeiTBZgUI=", "A2EoI4D9QZCCMhg4AZF2aowutu+PCEQm+asn7XUD0N8=", "JmFXS8V7bqowIkuhDL9Mlh7F076voX2EbmYJFbNLn/s=", "ArUNZMYiSp/QPxTFFCIxqCsxM5IGLXC7g1EW9x+GGTE=", "LkO+TKms05oLhp/zYb3CJnlhnb1/uTfuSZ75nBS5Kd0=", "B0WNy6gnuRfHMXmclRhevzSRZeuL2IN61MmnqUas28w=", "LlZawcASybcAFlTlxLOJ7vFgTRTaIeLL9Ggt294A/+4=", "K+F5e27k2rXHbzcIAmUFcfcv83r81TXoDAKphCV6SjE=", "E99zeVlGy6t59auVoa4Hvus2i2pnLu/5UzRnV0zVtjc=", "Jx8/Sql5AwFbZGJPTWWxXNL+Xxj8jdbMrODFINXa+as=", "BF5MUjGXnSDTD5jias3QW0TGEBryO6thsiufLtTCuss=", "Jl2Gj9nrRiCVzRjkDqKusHQVPPwG/gxi0mj8huP6Hpo=", "HCrL3BN+aorzmtNR+OiSVTh+acfZzEqgzAtKPJorLdM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "GLTnPb5NnINRBFhxJIS1qIFUpk5PAA79il0tlgtNeZ0=", "4v3eQ5pfiZzX+BMInCb2gBijsOy/st4VWJ5YnHfGkQ==", "BPKyVAKgOsOm/WG6LnO1rNHcwiFwSvwiq0G6OxWLelo=", "LOCazVenwz2nowg/1zNvWfGiG7dAPMMVIQEScIPfJww=", "HcUcCENza6HXtcpOys4HWmFIa5eB3uy3PsDJJwiApdw=", "JMlicL7c7MTsCChWZUdLpBfkPxJ3h44l9kx+1Z1RiZM=", "FWeyXqEKp2Oed1Tgf7JhQOaxlkZjASZqyyQs4PgLqp4=", "G4QF4TsGoRkL9g4/v8di7jZdbkKlUclEmsbnjCXDE70=", "Guf8qnkK8vSuwUWNXo+50vbpxOGzh366cRrQFqj3WIM=", "Iw/9o88Eg53aVz7NbPanZfQZCW4ZxBon4hn3Yk9j+Rg=", "HIIcjblt7Q6ijIPgF2nUfnz1MeXuFnFUxZQt0VUsmcY=", "BlTizl3lRIXNv2Nv81qlGdO7CtD2VVPAiQNbOZzYTsk=", "DPthutY3RA6nDCFhbAAhUxt5fcyRC5RYPH+ieP63EkQ=", "Dd5YotOhnKjaztFckvgxVxtxo77f/1bfZO49P+p8EeU=", "Eh6VKTK36V3n7ITIZXbOYbu4YqwvEycAVP4luVVANF4=", "B3F0tOd0HkExoq2yTGyfIjv3fiZ42a5bMnnYblX4f6A=", "BdPrRqDZovD0fwlipj1TTJp305JyNGINLJKL8Jzn5cI=", "JG9anzy0jPH0oTrqWlS6U9jTBGthhx38H7XZ81jLUb8=", "Ci5i+qke+z3H1MZILUHO2Trvro0TJ1E15Qm7OhF7Gfo=", "Ieq6QsRcy+2T/jRo3IuY/EKphV5gznhWIIAFN4TCAlY=", "Hiz8rB6SQAgnGwhhMduj3QBEoDoo37svAIYR/sIwmU0=", "LJfSdaNr/dJQ4uKr/ElT2OBNXpJ5WpFKqRoWjxqZMFk=", "Cx1nyxpp4HG7V7P06u2fuZicEuJJwJAJILv+D+esbJM=", "Hw9lX4fDBGHnwtajtV1QkuRULIBfKd7YxJn+RgPfl58=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "HJpIhM9unMGXgvv/d/9qLfCxNTwuG8yA+AaFtNqamWI=", "IDHbxGnvXSq4u/CA53nIHaCKE40YsbzghtllDQRM2lI=", "JtQRxmFEPtuf4pAgaoRhgSjR6F4aj7y5kIhZh224c3Y=", "IQg8L2WH1NlDUbXo1NN8oe07umBbsFrEUVHFuCisyOI=", "JSqlIgugif7F1553bPvMO+QhZ+KyS6YkXcYMfPD+gYo=", "FarlBWY8r9g3WN4eWGBYok5pKVhj1ZwSIWeNCpl68Sg=", "LY5+rFyjIFQ2qjj+CL5ToPt7V+TDWrucjftyLqvEtPc=", "HUsDOMqPl+f22oTVSvMOMNBlE4GQ0MNgmKadsI9EuX4=", "Gvg4JV1pc9WwsZWFxS9Nx6x+4CS1QeTBA5QrdIWl+C8=", "MBuTOdOGPgXarFqjmqeeuUj2vppWreU/8n/phTHxuhE=", "HgPfigbkFheBxDzV2oX5xSHdH1mHvO+FgEgCCUSFLHw=", "LK3dKwC1sV0Yo+yw0BPHGWbKR9V5QD1k0LQb1zbdt6w=", "C4ejaeRwq5nixDSc4QmYU5HYSKo7YCAvehfvag5K3xs=", "IYFKyUs+MvbylcZcSyNKq94gLZYHsXHsANgm+ZimyS8=", "KbEiizNGp5lTd0Vk+mMdiqbyMU8skhbUqo2JKZkJ81I=", "Gl5ArmdJPgA3H0eWGBucDtn5CbxabZNh+bdbTF9I0nA=", "GseerA5b1k7/XXT9AvGc8KBm1uWtjRaaKuQqk19FTjw=", "AcwVkt80Nic0miW9qf84/r75nalS6m0zAUueBi0LnGU=", "JGrireJB5EO94D2OKzI9tCCENNU0KGKL+SovrSBY7BA=", "GNANbp+cqOHzFaqX+hIUMBJesu2EG92B8e/mk3n3hvM=", "KhR7Rk73MkSynMTk/SSinw/LYnEahA7Qdcd2goAbVPk=", "MBiKfTmyYXOxDXdnE1uEFkDBVwgIniviv49dMYYa4UA=", "HPcO5yrrJchVVLbenAGHfI71FkoeEYJQqhS7D/jMXZQ=", "KifLJZmegvir7hNRyAg8g5PlA4ETYZ54NkllHChpZ6w=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "FvO0TnppVj+bnLBKQxQNLFGiomQbndmtXde5QrOJjm4=", "HvnbpLn9U2OnxYVaHDrgDBh072kzNrYGsfJcT9MsWzw=", "A74QjNfSEYW2NkvYaIP6ufxjyTVu3vxwjAWIIoC3VRU=", "IWMcUiyPRYOUvSNJRvMm8KDgyustq0AU6OCJ82sl12Y=", "K0aceHADzc83Izvbnz7tnavtp0IoTW9yhqQmvJAi+p4=", "BAnkdNOEHQTY9qUhyuYiJOTRXXKaSPevc1cojhryAK8=", "I52znKmzHCHsYbfzMGz9Gpwgs66/Ds9K998YwqSYrDI=", "MGKhTViDC9/lyX+REcp3myU+CfgzfkV6bE7MG6G92Po=", "IuiVjgjtVAIK7uWNi9a9gWw7mfU9Zk/mwbuqwrtcEqw=", "Jon2jyzKuKuofa1ar48kyJ8k2Uwzo1VEE+yUyTCcIgE=", "B93Ndk2/M3CAwWtMaOk+7eJaVnveH32sDjvPbt+0xHI=", "KTxwRFGhqmbhqg1MfdVsxTkv2M97jMmY9qVLjDCyThk=", "LL/6R9LCjl0OxKLcChaK4lg2j+6guhdmIWjUy6J5BrI=", "AgjF70ayONqiF/5GzCaudGDHDrJfq18RIvTtvUgxiUY=", "JP5sLl8hxMugL0wVuh0HxzIBescvJiYm7uKSpMNITI4=", "Hf3nRXQY6pZDEIzB0TNxeRuQ+zpDRvTqaDD8hgGvoZY=", "GeunhQfrf0My3eU0J3bP+4s/U5c+nRkbDzEvfwXB5zI=", "Ar4MTiEeCJL/XT87eqAoHhYCzSNoS4K6Esthvh66QR8=", "CcrlOgSd75+AiJCbG6WWcPDYohgLBAYussjLLDiTwRo=", "LirfesFX/63fW6X9CzsAmxPI4UVLVNKY5aUPFbokqVc=", "CWAgahtf1/jKojxvl5p3st925TykBxow6W4gP21hGUU=", "FwntiAHtZh9UFWs9opTrWRrs3tc9xLq46IRhiJnWGSk=", "ITppn7Y6mAx901IAitRtbEI+d/3Yc0iHkghTGx3PfeM=", "A3Jmalr8vm9UWOeEcenvb8+jQg3qSecTqM4cGcrVO0k=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "F/SkP7zxJQipM1J6iRLyhCMzeA/TDAxG0VryFtvJJRw=", "LFdEya5/bYw9W2bU1DuVr9eco4WUuQSdiGSIzxDO9GM=", "La+m88YDxMCwq33qK1WTFN/097KhpliUYT0hlFlfRHY=", "L3IYAE/LYtxas3x7OANiYpbdb4dupetINOt2JsHYIhc=", "Bt+kICDqFmZSp6OSps7IpjFxuUPWhTcw3zyEbjIXbP8=", "I/h6YX8ejwIbg/Qcz+XnUmhklTqe7/VtYthXMewJCCY=", "HNo/5G2o4/JZW9Iq6TJ8LSlo/8DGhnQaE0Vv5bIYWGE=", "D6hiW9nDrwmVbrdOL5g+tgeaBQwBhiIbGjLvUFCWkAc=", "ERUgsPVZ/iR25qb0gGADjvsBZv+fa9qBKgL3kyKK8js=", "DCPe4XIplgm9PbyfLM/R4/duWUxawsPl3fqmIontdlY=", "EF9Crsihtgwg5wQay5S/629rX4xbcSGP7gIEfVfAwhg=", "KZ+RV4XorcHCN4/t7zCD5IfbH28YB8x7xm5RtzvDkUc=", "Ae84NlkfgD/bigvYk3PdeRdvvC6S7ecAb6pdlek5fYE=", "GieF202aNAmt87fdyp7ECLL5MEQzisIxIliN5GjFlAg=", "Gm6tE7zBpa+8Y9hdsKQcSgMeSAWF/nrl/Om2S8hmohY=", "H1mWoDWjBglu/yL/OqgFN46fTj7Vb5g09iFE9X6y1BQ=", "I4SYvJm2I8n7Ta+MpOTIdgczhDOpvCVGyfN8hq9DGEA=", "JzkV1ifTft5FDbxels6UibeO4Ej1dWCCIn5i22uaVt8=", "IcEWGM26v/ZXogyNhIErmEoBeBDpf/wWnFhe4pb/+fw=", "ID4L9L6P4q0fHutJJmR8qk9uQpznlNsIL8B+5TMOfPM=", "KUukoo8HBBDExPjLXAmlYlKtBdvktbzNJKSttP33Hfc=", "DkA8vrkE0VgveHIDX4Huq0AQ3oRFQKmyv+VBnUP4u7M=", "J8huUWuAvt4HVqIdsabO06wSaZb2T59u37JBf804Kek=", "JsAs7ThNoBokfSJbCTHjMQ9/aJQmszhMZbz88aHg2PY=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "I8KLfZJyECcKZtAs4URUx2CFQMHEERmJxm+lyDuVNEE=", "F1xHFx5kufz9mg5f8sv4fQkRwB98/LQoeiGd+2WjyUY=", "Kw3GcF5y+zlnbAmShPh5h1gEGeOAAZzsZSkpd4Dp8UM=", "LNMOSwlrKsUBgsWW/EvY3iduHR8FiswBC/4Fa1BJg0c=", "ITcX4atP40DI7aoPKwA/+irfSJDumrC75lKKL05DYYQ=", "Fnzh64dEJGntwg9b6F9BF2or8afkStmpIGBcW+mb+XU=", "LAh0aZt/uuEwRtrknbl4WKaVAZn5o/O/gjiu63NQF5c=", "GlZaEK2vqwGugmthnLecnHQgoUDUE2VmnsNhs3y1yNE=", "LIxBbz1hkkRW7McxGcbuMn3HF7QRpOvbZztI6MzR1NU=", "Jn/Q7/w0lSNU8FMytx/pJbNUjwFZ7jYUZ3hO+PuYYxU=", "K9JR41vt2oS/r/Vd430oNSd3WKYNtKm8T9o1cd9a5SM=", "C3pENxKzP81hAoVCRXoNo6sfCHtYqsslQ5r24eVTdaI=", "JAQTNXBiNXCsxxjxn/Jsa0e6A4VzlPVdF+jdr9RstdE=", "DaSF2KjTqXloyLB4nd5lN5ZDBkHE385A21y66k85IHE=", "IUbXEVya3s39W6BhEDcpFnyoKi6eWN9xd9EGRaI3RPQ=", "LJV9cjq1XPpd6Jle+ZBMO+W3C1d0oS0X79cdf7ELKJU=", "CAvD6Y9uyQnFFhxJjgYTu3Noie7tjOe8yTvtAvS8W+Y=", "Gdz3PPrEtEwnYeAk1ssmeMwQSlKMAnmb86CRkIrngMw=", "GZQi/p+h9dLb9ALJvWNNS9yc2vcPyrnQ6/uv0SoC5J4=", "GkB3sc9J9B/DoiQKN65gMJ1pQbg56/UeHhGMFqI8au8=", "DlPl69ZDRqg8Hn8zh4rIdTsbRfDhdH9oAxHuzK3Ymhc=", "Ba7/dce2DTmvr7yuT5nnfiI8NeMB2x2+pb7LpzU1iF4=", "H5dk1LA27psYbV3DecKCaxdZWEmsgp4tUiMOJD//MJs=", "AcvWTlTpShSZ32/XhN93Cfk5QgcUY+qz22AqgEM3pDY=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "GQ8qaD1B0p+nn2UwV8CFHHa/cwHDVeRtUU5iohFtcYg=", "A1i964hSed5CHQtbztdeSwuQk0D4o0RaPdF9duSrzRo=", "v3VfaZt+QlKz/WJ5OCfmE8QLDBKFourNTvZeOr/SgQ==", "JnU96piIXKLEqhikm5FiJ3cihYq1HjpIInUnjFOEJJY=", "LDu0vuVfZl21may7snCvgqn4Mg98Ot8RPPqG2c+0dUw=", "FJuiVfcg7aEURPgE6YFCYACLGH8mzhfkFSwJLdR3sA4=", "ITRMaCsfMUU8r+2jCBt2CWNA2sVgYnYsqAp4hw2rO+w=", "EbbHlTrVq0rhb1ARAbm1d/C4odfGp5PWbk+hYbHgblI=", "DrG+6b+m6sDiK+6aE/ohVev8q9CQjnQUW7+UKK4LAgk=", "D4nm92fvd85uyBiAfTBwb8EU2eAqphDA8/d6Ogiq+cc=", "GKcq3p7pdl3ozP8pULCj6MirtKM2rUF+p1g36DAbjf4=", "I5Nnv1ZSwrKTv2Rb2I8Rabb4csz4QFwrTwn00TX2/tk=", "I5dH38lvXvEbhXO0cUsgOB6kypWHYbROEYcvMGcieSs=", "DufVHuiPBA6cIdU2K/oIWtuwFIWr4e1XF7VbhofkCzE=", "IWJ3o9kg4SZmOfYdDCLXaFjoXa9fqD1iMMaxYooHcFE=", "BDUnVWYmlzc11RHSUuKh3TtVAm49WzgySlDRzUTQ+fE=", "FuQ168/33HIkTnT+8Hzaat0FwIpSzwcwm9Lv8uqJazk=", "EoAgsx3OgOiaxeAbsTMpzqPGKtEVpdZc5oVV5ElKhnw=", "DIQMsXLc27FQJ0m7G+tG4EOaoWfKpDFygvx4BWJi60Y=", "BUKwhSVjwr+SjbF0NpyC2mDW1B6cYUJdQX8AnEb6xn0=", "IkUvLZBDvLq2jlJtIq9V+4NaPlVOUQGoLdu8wEdBGIQ=", "EbkZwLerxrKMWCqEwVjV1oyShHVQPDEvhq06LKl8DsY=", "LR5kRepn3KfsHbCwhlmtsXfJN59Fab0+/QYOBtC9AeU=", "JRugL2Qs1eD/NeAIoKMJxMZ4Da+p+sVbFjJW05pOQRk=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Lwnl9Y8mLF9MmsJFjljcHD9eCkCf8/CV2OzslXrFDys=", "ExW3QsXeRGCicinpcOVGdQ2prpH+jKXlFUjGDBKqg1k=", "YObsuHI+eT7aBOSQyBi9B8yKly3ZANDL3EwoyeOsEw==", "AWd6pYL+727DSPGxlPT5eNavRzEzID0NIqgbCL3PJqk=", "EG6OZ8chPRxkmwj4Fj+EnQ4Ms2ORZys9xeYymDRR9Fc=", "IYuqvPJ8kEa3zlIwmj1tOiyhs5JL0vtkwVc1OohWfI4=", "KycX02/fzm4TTyVa2vqrPRqfcZs6ZhzB/kkLHhkPKxA=", "CwssO6xyYEtMXVaOT0z1NZYFCvHnusNifpsszpNOtII=", "IXoVtR/OG9+1Z4hkrMRk6VIl5H6kC7x4FVwUpB8r4gs=", "G6UjGunHk5SGhvfde+nERDXdapgbPogPNE4pNeFLZLg=", "JT45IV3cB+YEaEoi6y57/5wTixfSCJup9FHO4gnxQXc=", "KR3+HaK5aNODeisrlPjuqWBlNXdqJgZk6CJ+ISNUymQ=", "HTp+HgTEIt6bfgsJAYBRg3JHOujs2NH7gfSYG7pjEi0=", "IX0lymphplUavkveV5Fl0XFROnwV/daeYrRiaaHO+wQ=", "HWXwuZA3qFBseseBHDuN3+xxn9lRpzN90B4ixuAPTTQ=", "IojiTaumhy5hxw2KS428Z8Y6SV1BZJdhGY79fkJ1iCw=", "KYEfsapUolkoFnl6hm64Em9LMz8VJutuJbtiYiRJM2A=", "Atj0tPQdmrvJ8DxQ5NpeZP3+h8XQdUXO/NMBMfIPANk=", "KNelUvoqhqjb5BBZQ5sONWFM/dhB4NbvHbGveNcQjk8=", "CWzdyiq4x64gGQi6GmcakRfiS6e7wWszG6veoSvK1cc=", "I+OHvn6NY82Ldp4Ttxi1YLykpgLImSvj115xdHoQ3Pw=", "Afd9x7HdhN1+wQacBlEh9RwDakEjdAgHDEX/FdJGKmA=", "d2Xx4rKLrDT/TBV0ZUVj6PZyoU+xBWdqV/JVT0nanA==", "DhNW6o6AaLHvgof+E2LO101+HsGKG7Nub9LyJZO1Hpw=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CdHyWIk08UVR+JnemXvb/JGS6nbRSQtr1eHWkdNAOvg=", "HUgoWgALZrOazKO9SK4412G1kNhG6+xIbbSJnR08TXI=", "C8VngbBIAlbTZhrG4ImKcIQAXWBxZSJNSUEDhm4lbEc=", "CIhnqL/vHriLLr002vNSTNwRjSMr0bkWRsEaKlRVawY=", "KZOOZ5v2vsTSk/7oYVGGuwkocpHWm9UJU3kPsJ23/zY=", "DzB44tupmLggKz65H1AOjN+H4qyfhu3M2LkHsdc/ENU=", "L+yg6kyrGAw1ex3O8eiBbKoRX1cvsto3Tiey99KhcQg=", "GaU+ThqKp6FQKf9F9Sj0LI3QNgyNrPwSXOfRkqCnB2U=", "GKyD9r3ivZBDLun8A/DmKHGWnouieqHe4scuL7Quk1E=", "LPNpo2pkqBsXxFIbF8jvZdCUQqwoWNA3hf/x+K5OOIE=", "Ftass7RFot0s5sa7efH2HxUBmgkChfyjj75U4EcExVw=", "G/pP3ScpjRaqBr3J3bPCn0iv9P70W1zoC0rN+kP6E1U=", "DG0w5LkDvbl0U6mWkx7Rm1VrOIf1TWMIQmPSeLwt5TE=", "FzyiEYqLhebjZn0tzBxIDhY6M4zC1HmSsObwny02PCQ=", "CqglCXV42R6stA2pPLc5+aQ1yKm/4u+PY9TTkmclBvE=", "KGnXJIGdCfsXIlirH93e0l2PCvsj8ah7Mx0inrYeAy0=", "D6PcCjj7uS5fcUGDU23SzscWNyamQReXP9HZJ6t7DEI=", "Hw9Q8Tjd0l6cd9+hXyIBvEP+gYWVGVeC/c6DNmT90kQ=", "GovYUqaoomsjBX5buF+sr3BqZIegZRx8Im0M3/CfRQc=", "INBFNTsivkEKrRKGtKNi95xz+WEDOSxcTtMYiXKYB9c=", "KDCiOlKLHB5+J3+XQky7FTs9MW/hsWfqATCb36ag9iM=", "Afjz2H70dnZ5y/dzr0ovJ2FBJNUnABXH1kwLE9Je5js=", "KEOEf97ckHEBqxuJFdcVHcvH4nQZ0swkSQ0gIPMZNoM=", "H9PcsZ6STSJum0KNKfcJeNdxW8vaHscOWYSmeuYVN/A=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Iq/CohXlifQVESgNzZpNL3cU4gXyxNC2Y8nS2geiMdg=", "JWEXoBtJA6UuJ6QfktemXeU4dugy1dABP7v97OzcsX4=", "G9UF/iAnrBelHbKLypcIekM2EDo3X11ybElXxjwTd7I=", "E3C+63xippNnttg/Y55esHRN+LcZfkRBCWXGl5OKnj4=", "GyPuixSCaYWML0TDTxBY9E5PBmsrl6NX+BoGlLvzuqI=", "DBGDf6FUhhJRo8bQnEWQz1tzirtEDJ8iG2/dhrYrlQ8=", "HkG22L4IODxieWKP+rPjMpvTkelU9TM8LCS+pBsbYQc=", "B5IaXOvkx+M5uE8OY1pIWRNnWE0MEqZLVjfZYPNbPRE=", "FJadWRmm2FxYujCRnA8OUs3pGX2zloEWDFvjuYqruS8=", "HW5Iqr6yCYYFEqiTXq8jsbr+qHl6aoEoT7/m6BwfejQ=", "LjzoiPhA007YxmC/1aSLT0oMBA9bORZeJhVCeDH4aAM=", "Azg9uU6desPjq/4NJ0gsm6g3JkoQ9IKugPIm5RBCzCY=", "Cvienl7ukXOZN4T7Vm5tU47+RjRv9c9hscmTtSpC5Go=", "HvA++//ZLNLak3Qe70OovtgKdvT2jOu2FJPpcbi35+g=", "J0BnsqBCIpUtZXfeMkXzghmuVPBYLZ4Ft9igEzA5U0U=", "Fro3u+wKQ8jzDQAbvsswvDzz23KNpTjO7k75/0ukhqk=", "DOIpucKJuOfLxOAgoDcqNwp/KCIBtHeByv89AWQrjCo=", "L4BynHM4vhwN1hPCLoNu4ump0LBqL7XlKvAkuoZ4teM=", "HNxtKuUMEymhF9E+u/wf6G1VJqn5xZpQ4DHze2cQ3E8=", "JTCkZ7ogS8pF2D+cpMWsmlaMBTJm7hEmYHrDPH6UZQ0=", "A3EwP/D8aKfGLhe3H/mL1XFcZxfXlLad9Dmm18AAEdI=", "A3gwXiC7+WqgxjOTD0ARvCB4m1wb4/KSnWk+cExVK/Q=", "AaNjZWfB7zAF59WDm8qQCIiqNBl/uuWCz2gm+FUCDSQ=", "KB4qBv7Rz1sOC24D+iZSzWCPpHQpm1x9DlnGqjXAsXw=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Kz2E5cYbK5eTlnS37xN4CYjwwtoQnnHRfQWY8IAjaic=", "KeK5vcjcujYX5WY97dif2sQLwXFPdn8yfGUD1/FG+io=", "IW965szXusl+K7BoFozxiyNQWZmtWRblLOlaI4lIBuM=", "Do0pjK6IFRWrD3Tsk1VnpbJJMUAjs4VtX57BpVmam1U=", "Dx4eRfhHywNZGZe8iBKw9CLdDbL8mcJBeoGYny5G", "BRMuVsqsY1HADecyR74M8J3jV8R4C/cF+x0SlUBHowI=", "LB99zrFQFInNR4LBPc4pff51r0tAZd/Q/VEZHg8DSJo=", "DdPySEMiC81KZlhmMeiIlWoO0m9xfFVtxeIPOLRV1OA=", "LzIkBDOSMGQj0i8OnlwViJ34SpwcbivUBqRpE50TKEQ=", "K1cvflIIxeUqdZ4EUAocfWQf8G31mEqSbcqy4XyihQM=", "CxmIhYk0yKNTRW1ExGGnY7bJjtPL9yoh4uRpAIM5mQc=", "CwznYWOiX3JJKfj/5Vkr9kMTZg6+GxYEckZrwJHFw94=", "FzsSjoc8LdU+lOQ4tM0Gbs+ijrQtE77e50Lv1Ovk3D0=", "Ai99YnQgeUy1FN82CXw92NLpLiiQrywa/UtfW8JqZik=", "HzQyAd8wYNA+MT66dpCIO6d/3sPWY/xohOvUAZOK8mE=", "JHLJaIg7Fpq5EtQyfO+W5tT7eywAlZveFQte2XCJKek=", "E0wkihT/E8QgL5l7uH7pMFjeYBRM8vUUEjbwFFVDhSY=", "IGtjYeYTklPmBw+QXWt9COrHTk7y9UzglkOSa/XI6BQ=", "LbLP9VKN56JuBkOxYeezGOVUqquT+nL59HXZqnxuyL8=", "JeBbijll/golCqfKAw46dDlEVHjlncyrFqYhko0BRXE=", "Koxad8YUILa06+l02nFAol6vnbyQkvBjERKD53Ot/R0=", "Ezibe/Y772pomDEluG+TtittnkeD+WtxDi6+0628vi0=", "JzHK3/BAYi/MtTP9YqDUMJBFWIEIComEiNVciQgzlds=", "GIb3Ue/tbkAcWFH4i8KF5o3juUBivIELCSw+QWCw4Sw=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Gh3nIXxkCBbKltad+jqerQoy9isthkxc89ZuKXdhamA=", "Ib+4jg1St9zlQy9VxEOWTkbnKHm6q6eqoEV3tZ+78QA=", "HhybpfFBMWZ4bJZAG2H2h7pQ3HNdgVpOgRVwvdiVShE=", "A3jdEKMWdfe824AYyWzI2m0DSkLNtitAbFvACQCjN3w=", "J01twF3VUNd/sx00myrbXzjrSyfsFej5z69W/i+LMYs=", "JP4bwyjMleCFfonpnSypfzJ8IapN5cERpywsNyNefRw=", "Kpj6N6FtL4Nps85yhzlgAG6mcHXAI/7Vsy3+QH5jYFc=", "EJf5R1VwQrr0Rb31uKkgIZdsFM0DVO6I5D6MjFyuxKs=", "B3NKIRHZJe3BNJbQ9ZIqs2rLqEZ5mfX7cn6/6zejgHc=", "L8qIHq3UPNS5s73pBG9qJQW8RhMrLCTaTifBAtY+7zQ=", "J8lSQRAXmH1ma+x1jWA2wX5ECUC3fbR7QNU57hFWwaI=", "GzKdYS93PndyG3oPkVSzWcJKb/LuD1uXM6eKeYyvDyg=", "LhZXk7By6qNXbNGLkCdYI2hYEzm6PcGsupzUogJwFoY=", "IYZlQEJm351bprofWn2aYorXx0oJKGDih74U8L9Yd04=", "D0IXbdwshNErs3mPsrOgbkSkwzrDnr4DbH1qxv/aroA=", "Id1HtA/B5FRhSrCZeH/mXW2OqesOQFW7UeNMUb68Hcs=", "B9OiaDD4sUNCpjwat/cT24GtlO5uXFGcu6C/bSuHsmU=", "E6EG+xtkjISQpx6cFohuAEknAkAYnUQnjGOkb3RO26o=", "HKpZgl+G2izgkTT0rYI98frsPVVvl1YxLN2JkcO1bWA=", "Fc2tfn9AUDQx56jCCn4bSKzm0ZTufXgpgFo40EAgQm8=", "A1wqT8LEJP93yhgLm1Iqv1GfH9i1u3738fj8fTHBF8Q=", "CuLsV1da7rOBRhPSOQ+OooEw7TRyXRYFtYW06Mu/tLk=", "He1Fb/5WL8bfmZ6lzIDeD/bKX/8bD7JgcnPvG6UmLts=", "KuMHpPRnDRH1rBx6OiO22sYT0/EE4QfQQ44sptDtVfU=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "F1cKFSJuPLENDgz2J/7hV6+QDPSyLYvr+g8Fq0XVYwY=", "DsLLp77Nn3s7B7Wb4fdHs/4/QP8xhz3TBhBf/fuhQQY=", "EVpzv87McA406+h6AjOOxMnhvQ2VwlVLEs1cr6H3X4c=", "JxiC4eiNOpDlNqyREJ2JQK5BH3XefL1DAA1jFsXvSKs=", "KNeXy4jjbM6H45CQ/t+hHfrN8q3xSGGNJi5G/abs2Jk=", "CQMWVHXN78BWvzzqfPJuOeh+fRyOFJcnHfJDMK0C2Ps=", "BSHcA6vPPBUnjpBVLoFistrJIiDZnmnvnkSbWgNwr7A=", "H4Dkuu4EO+shJZPfEVAaecB8iY32zFeBkMZ55kw0ou0=", "ARM6boxdAxXSd1IGuElYjqq7C2Oo+t3GeAasE/rxJ7c=", "Iq8isGS+ytrhE7JNET8Mw90NF4+cxW146EvzQTVJGKs=", "FvkfIEwr2E+5B6erdEJ0L/JKuDG6JSgGyntuacd86U0=", "HSwC+493gPqiTz2h8p6RAcHN5EYbfVZ7lJv/XOHHHuI=", "D4541smgVa8Ue3RDnezOE1aRVi3FuLrE5HH+y3NWI2M=", "E0zR0shvqjv/OnLLYiYQmIAJQXPuLMgIq+b5WGvUeEQ=", "G57c5Z828g96z/DNeL32FPao8bz5WunW3b9cjH/PYl8=", "Wmdx2vHyuD0KkqEY8w1CF4hG5eIJuCSRZW/r72Wr8w==", "FQjO+dmf0D0bZHm5A5nKnf43kvxjv73TVmHg1EutgJY=", "KRzFw/Za5b8XWY9DKu9d4IckqzACbyWttw+F+zuw1FU=", "LHcjqAezlEcFtx24wEzEaIINO/uZcGUo9mllu4yXNNQ=", "CbsXHXyZ6LWzXe82JJVwdNwvCmvrhhvfQXsq4pCDLcA=", "GUPKVwfudyuDkbV34pXa1PEMLbHHcOM9jDf8IoDXGug=", "HXhSWIzPDFFmOr1luHAErViAchAZIU4AGQzI6TnrItA=", "DuhxEY+IKkKorL5zOmS3MzotFEE8URtqedWKqWwI74w=", "GuGZMOCDdUFA3YU3jKhweP7qFwPDwEBOJ3a7+0zbqNQ=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CnyTSgNH8N5+nn3aixrpsJS9ajCbgyPgZ4CCHXiU+14=", "D8++co9cHwZXLlp1AmDv5CO7aZKnsb+PDnYecnfnHTA=", "Fw3Knw9ukFc3LjgM+pJOZcuGr62GajMOye0169rhlz0=", "CkqRfzRLzjtfklaEUKTxfmoX4lHHNX5wjsPW5Vm9ibs=", "En/0MlVffgi+r+D+26DqmQtJyl30LLuZnDvXuREZU2I=", "BltuQ3y8AmwWIwcXd7ELjf1gWjWY+9oGh8dOr1Jdwbg=", "L67o5u4ve90l/zbDGJrtw7BcS9r/3mQMDk2ShPfZqKU=", "EpT7tDKsOGSpwS6r7xPQf3MrZSg25mqVTEhXNYmSQdg=", "LdOrTwNXPzNiu33flki60bQ6xpOdbE+p7nPcf+Zt7uM=", "ICm3nYj/Fchglxru+y6+DVI/qv3WCWZCsBiFZ5PnS0w=", "LlxWqwk07sb/jIIk/+6mV/G5n4gKAC9q1TUtMPfAuFs=", "JIiK3uQ23We2dChYgJBzpcQ5PWEoOoJbZbiDEU1EIg4=", "H7gMZUKS1k8k0zH09vrBogp2N5hlpjMedSjeI29E6xE=", "A+j/BI8j5TpcbvAtx9N/MWzUUo2k4fbLxFgoieFHADk=", "I6TNqGhyb6wWZZheE9gA0QC1a6zkP2finaBXM8KjUfg=", "DiWhsTK6C/dvHjYb/2ubufotOqrRFPWJ4QBiUiWgS54=", "D1NMWtWcnRxKN72k5Srehm0wW5gjCaAE87LG+LEOmFQ=", "Emn9XRV/W7Yr/b9PP4jBsraE5Azgd0nPzmV6Nz4eS5E=", "H7cNHsR3b5G0JnfIjSmDRCt47wDgO4K13mBqRf/TtOY=", "Ke7MItjlcl4AyFoGUe2vXz6VMFBcri16Pv9u9JbXsdI=", "I1XJ6P2f4OtoHoqh461DdAp5zJ2TCgKf0WHD7jL3JX4=", "A5DxL2WMbZKRsRj14RZyfi9KBxQOjzVj7FsSoP9vano=", "FAJWpKnMM9k+tIa5a3N9vRdYCnfyCSTko9h8I7JbIzo=", "LSvpmD0UyB0suGZbDAj4nWFAU5xxLPTCrIzHWy2v/kY=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LNzgqUqowazC23k1jD5n2VSYPvCSfcayb5q62CDx1CA=", "9J62UxqxZ06ppv+IvYFIaQwErd+akWSxP/LEzwCEQw==", "JkAwFOPMSOHPES7Xm+6O4UZ6zTA9DaXIi4aD44vLcgU=", "DF9gK58/2o5kfvekKvNHQdEau+Cpn0ZMEB5TS1HN6k8=", "GKw4qlXpXv75jDRzNagMr3/Fw+/JWQEyHjsTsSz0ai0=", "KxlgxyexC2ZjKPDDf1y7OwahrVT2G5UD8jsC5cRnhRk=", "FvE7U7PGpH8Bxz9+JsL+arYbPh9eVTQT8soSflPOSHk=", "D8TvZpAh2G0p3AQTm4j1WlpX/gv6JTYxkY4NgIsSNsc=", "CINN35b2c6eG3FrxJeuDyf/hU3/Hc8IdEBdoqsetpXo=", "Iz8TwM6bSIZ97biKFbFGHNG+/euZqcCs2GPdReBnJQg=", "IJmmGQl/lWXKZayWr/GcvqFqkOBWozubSdy7clkD7es=", "JpiYqJCg6xHpuE22rgc1cUEj1PCqCjDbGDE00nnxqQ0=", "J/sDutf6RqYl+wakeZv3oHzjv43AGGDPYXT12c1JUi4=", "Hwpb2Z/ZedDt3dJD1pZhUnBr/8gyb7CIVFs42V/aED4=", "GwggZb+y4VFVLRrrPyQ1roxSLbecHD+4R/5ztyjeoFo=", "GWhAoVpl7kYqgxJSC4aAhO0CE8Goga35B+v/mSImgzo=", "G7fXvE6g97j7WjsFlHjOf1ziBp59YqMHwh0EAPOGBJw=", "LAs9aHImo25SPAZ34POUnqpF0NO5ycLRGwQx2OzHQQ0=", "KiIJasrh11rt2PyEPYEwzIabFCQF05Z3gez5/wBiz6k=", "EdPfQeHTF1HFsAt3XzOSW0/V+PZt0sWy4uBMsJD/uXs=", "KdD8CN7TMruko0zty44+yp2aaSml779Ypy6EmFapzGc=", "GgrmZMOJ28EQRrsXDA3bQixMbC8Qxo7piuesjADE7oM=", "BvPHdwaXNjfH8tW5vZLW4kJLkmw4osynvKXfoHlOWEU=", "BWllYWst9m4pGLqEDggJuFpWej59E6xfHlMgYa+Falc=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "LfzxHu9hoAjyf2Gl3parwuMp3O1wkvlB3va1I5YK/JM=", "BPc/WvuC0il9TlFJjwgo7rPt3AFq4OFaKp48//NA1QA=", "JikPxJIiDJndghxKTRrP4bf0CzehO706tRQFqflYrJM=", "B7U4CUZv9V4uT1rQ8CnMxaGsXSYXMqsrAQA36K0IAxc=", "CAylGI73N4uTkFd3Sy7NH5ir8n3NRz7evMwGrHqULiY=", "K2sBQ0pH7RiLQxV+GWTzclz0+BE/sKbLTAHsfcK9R+M=", "LCEGtctAG9aOFXRjSbViOPZw5YoCHuKsiRUojVNhR10=", "CI7hC7pIlHVUeYS4kNfnlKslU18fzI+uBKM9MApetsM=", "KRCORYhRKtCrKOQyx4n6PT4NwNYALhnMP7Z5WnXWlxs=", "JBxIF6kUgUztIcBuxTUehe16kPKEPSO9U2Ouu87d57k=", "IuzeaZ3I29fNPYHoDZqBrQI8V7867FqCOYcUcvq8VRo=", "INzL/j6EtA85CL9D8FEgSPrN2GhspfFxkvmDWZ2qxu0=", "LJY4kzPFRZ7GWWDYSLBrrU1rirxvJgK/2Bgkz0PHIYo=", "KMWd/qb8q2rnO+umEuYgg6WLuAMGo7wnRqzgnWUMg+Y=", "DdR4pixoccaZ7LTqEuRUAnIS/Y8eA6jvwAXfbSDs3UA=", "KHcue+ReNrkMLUOXSMDXfAtSNxHqOY59vYWw198TANU=", "Kjd0ADm+B0OJ524e8AldfREfd4By1KVzNOvKKQ1meko=", "LzeEXZSuwtY93PLL0/tW/q2S6o7NgZ1+rDwrA2xsLO8=", "Fe3Mxafmld/0252s9AVhLwC6gKFt/aG1XPS+7t+Q3b8=", "KBcTSEW17GrtpJYWRNUTJp+G4HohrDtzRNWC7Qe19Go=", "HvU5B5CioyFBQLEJYtlDW/sLTmziS3oeoMmvaJI0trw=", "GEJ9b3zZv3rOY0HRbdhFzRvRjtS5uOzcqzb6RYYIVdA=", "neM7x+LveG23TbfuzH/4cgRUY3vfUbKBpKFHjxmLrg==", "BdLGOqLeRTT6TfemxfbRBZlBL9JHpZ93g2a/9XBhEPo=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "Ajq6aVFU5oT/SCdRy3YdzBY37F6ZquoY0L8uL7JusUI=", "C6IIwErBHvRUMRLb2IISkX26q1qHJo2BWKSHrjJBWE4=", "HP7QtYAA0+9MrB5v5U5kr1Tzk6zKyk1bjLBfYa2c13Y=", "C6HfTqAn+DSfyxXR7bMop2+1Nqtl69U1eHlFY00Jxa4=", "HhNrRO8UHJGUXIdogFzgEAGVjs2smwZYdNIXF9qZtAg=", "IGQ+PzxoshRgXG3y2ALh5Tm0ZbmDB/zdD41b+hd422k=", "ISfQ59lAsxMvq2sc1xlXf1G/jbUx437a1RlIde50k2w=", "FySc2r6cnbShuIvVY20720jrC6ahc1dFLJf2lbCA1fk=", "CmuUgiiCuhyh2pVFZq0wMi40WKbg3bFD5PXzBvyeMzY=", "JIZBDfj5tIF9gq370kquQev3xLvYcI06fDsYqZnPebs=", "DAt2hOiuRoRed2a/diDSeRo9IYv9gS0Aj3OtNRuoaq4=", "CX0+4yHw24wEzt4T7PqHzKb/whVlPbzb9iglBZuFIeM=", "K/9x2vrkWL9IVNeVeGXiNiuZp4kc3Tjhf3bFgoqhZTE=", "D+FfixM1EFiAa8rxb9to88zfPDDxWoWljfLc+tcuKWo=", "K9WGSAqhjBVfaIx1uoEv+BmQkwwar6QFjrr2Z9QeU8o=", "K5HLcvxF9tyx2r8Ec+JFXyi+brG1nP+Rtf7zuB1ijuk=", "DNrLXtIPGGaKfD8hNm4EFQ0Oh3dW4u4c7hGSEYSjGnE=", "CSOdabYy68wfVZdSovqwhr1GzuEgUEqMlLRCei/s1bg=", "ErzbayDcd9PVdBs/xh4exvUxN7AaI/SMKiZ9b9WcoMI=", "Eepzs/BGkM4t3vwq87+PgFS6dNwxOwnsCclvop6GWw0=", "DdpkZ8ZLAknS8GXfkPvHpoUCKs5tnMbZyYPb19Keq1M=", "FdfGHoqDCOSkPZkpR8AmK2W60WOo8QFCPe5kwivDqwI=", "CoJaz58J1lPga+Xbp8pjZI69YGA3cQEIDa89572dU4A=", "LfvfXUJ+L+aJL9QNTpfteAjdgj6tJ2KdiUmCt6ugimY=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "HJ6miUPYyEY2QGBkbeDjNTTVKKI62CuLpocHVCgdtVk=", "ChUAiuz0P+S5o73Cb/A+OGfpdDUpJss60VNfdFlkipg=", "CrF6j/hPf6XQ2qyVw25gb8bhM+fLBPD3tTNOjmxE6og=", "FJXYiDePfhLAFsqwvuJTSQP+h41WUK7q+zgUs6ixzLw=", "KaBUqkR9Y7IST1DdvEwtlDY27VPyJlGq+Q/ZPc7fyUE=", "A5WxWoJ+N6at8xdaJpHCiKymjhYVTC2Y2Wuw2+5qP0c=", "L0cGa6uTSd+mKyXstDNUJGpH7KYhbB0Sw2YB/jQT6ms=", "GxrYHu3lL4qMCv9JoEHc4LVaHwbIJrRBlRttZUuAQBI=", "E38n8Lec+IR2EQs05+9jDQPqITOMIAMimQFX9QqPP+w=", "Ex/4XPIbGmgzYWB1fRNeHWBRRPgrOtrA/aEQCE0SA0k=", "X4SNWS6SGww8ejaoR2VIexNX0OwB+PMpqoxvJm9KhQ==", "L4mZQSro3LRHVBPnL2iBfsGglCcnRNMr5Lig/3S/3xs=", "C0LgMiN/O/Ia6VxAYoaHUd050PaMBt24SfaRKI8z4mE=", "GZyLRcrJa7DbDy3L+Sw2EZHO3/DZSWBqFA00IN+tMdw=", "D9o4tfW9EQDatxm8+ziJNx9auc6cQoaOe7sc4tWoX1g=", "G7/mOnVYsOmgArOYMFjDzzmdR59+IZPSSR1YXVQaCGo=", "DrAFdj47PVWEB0Hwy/yV/lVIOFToF7TXz7RUmsecs0o=", "Cud9Sad35aIqP8auwkKnqA9Srz4c05XLiGKwm/MjDs4=", "JcHbSNJWFgjjR4yCOLOHLept4d5ZfE8m7YuqlYSA5bk=", "FQv4gbvTIwaO0HzqhwUIZueymBjz024I/NNbMd4huF4=", "AunSVCPCctGYnW7F6YOBLnNXX2BAs/d1/JvRx4F8VQ==", "Ip7W8FKXa8+fEeSPT8y/tFCnuS78+qUywchaBZ2zPK4=", "A7oEznKngDjGR3Mjno+MHaYIuT+94hws6Ur5YVrhD0Q=", "LqbdZIOFbKKjYQIifcFH+7Kfy2Lvk5kVqdtmwQOpmrs=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "KedSN8Hua7h3tulbc1XKwDFw+/V0Ib6NvMUPCGk9tYc=", "E3t2qEow6QajiCfMS2Kxoi6ULYNRkqmMUU6v2QE6LcU=", "Hio9zaiGirQH8VthLEBQaaXBxUWvgnuw+PbjLcVeAnc=", "BbccXRYTzZtrPP6UAMtdhYOhbbwRQs92DKaqn4Funyg=", "CnYD7BIujgF4p8sp2xgeKppx+CXv/IQVuNCf63v27TE=", "AS5KYd0+mDRmK3jZqCDCVmCSYDkjfvV5/R6yYLzhMRI=", "F8idA0N3eked6jF0TyhIrAYEVpbY8AF7f6nTq/iMs3M=", "EEohvcuOSSRazW/CgbsSY5dvE4eX8ZY0x5Qj80nW3e0=", "HmrTq4A3vtLjbIcql1enlmlu4pUPl88x64O81PY4BQ==", "JIrWlmtAEIYGCpE68BDaTqKCwtFGHj3BAFabO9FoWhY=", "G00htCZEHK8lRZONQbyzs3wys/oV7Y/9EWLmUkLqTTk=", "KcRCLJlZm6sXRwq5OI7nlpUcJJZFqxZOkFMPyFHqH9c=", "HOUA5Ad5I4QizUegptfz3P3AxpAoaZZiEbC2qaz1Fx0=", "GRAuPHJ4RPuJjAg7wf9F0Qaik9jc5u1DiVeC2vaRp7k=", "EpR/SsL2/ksRJaKNF8xKPi25L6sOC5dyjIt7sgRwePM=", "KnY5vNZZHbr+9J+2HbcQ6coNcSy+gcuGNA0PFpgQNRU=", "CDrBUUHpSqcyd6tSHZ66RO4w9OAtbpwVaBcr0Yybfms=", "BIBjXP+DFNkX2KVbNJUp3GMxcKFD9IZXE/EAB/f0t9k=", "HAPKLm68zpovTOZrsDnQNrK3QkrpFr2mJAKA1eXtCh8=", "FefbfSUmb2BLj5Qu+04MMsHkViEzbSgPG5BMP0BSk2o=", "IhW0GUOwZM28IBecmMSmlIyM8knwTd0Y9RnpWVqjOw==", "C6PSTlWB1pWcK/nAxpVg8dy2SGc03uVoNImLl+jAS30=", "EN5su3EkGdhNvs03WWOuYXt0lr6MqJxc8+zp0w9PhUo=", "Kk9Fc4Y8v7GJ4X6AvEZRYaUI3Qae5PrDRsKwJMiLXLM=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "B5whjvovy+HKxYf6qJvPlwE0ORyO2t/J1UxmbAkaaCk=", "ESMWQW77f6Rb4sE0OVtEbwSJAlMVVP044L+7Nk0ZaSQ=", "DXfvRXmUw3+KO9AGhXIxFnPqJrD9RzqhupwlxqYnaS4=", "GJv7Zxv0IXMHZOdx/WjwHog/mLCurG5cm2I73xUF6nA=", "DXfzX0qzP9gGJb6ClZQZCt+s5OpiOrElIJIP+OcHpZE=", "JiiPerFrGBL/Nit9KDU5sY39CDYuKnxEZnRKi4FbD+k=", "JvG9ZEp7MRjlXWvu0AjXLe/73pKBW4hx/42GEVProDI=", "Drih1a5AgTUsfvPVCwYigW/qF6D7nLFjwOVE2op+iuA=", "DbVrYmSCnJnwlO7wuMW6829slRhVWpuM5YRbTTLrluI=", "IIg8WZoZWHN1j9kX9E0geXeMy0HcEouAA8wAe2/WZO4=", "AZ8p+vnFOTzQt8B6kCRXCW7mVD0d+vIqT4l9LqZZmGA=", "IKK7s+vB9G+TnmQ1bV0WCbXlC1s/3HRitPr3Nc/2buY=", "DfmJ+qgFXfc7wqzZ6NmEK/36gRQEiOz2fbiG1Y0qhNM=", "HCCPjomyx/1lqV4vzOQy9dqOcWQEZ9IfNRsWnQM5XJ8=", "E1b7zaQ/eZmLKDP+buqvY4hs95n1VQXYEWTIggCRUdQ=", "Lpn+zi3Cqjj8QFUXGWn+r7g4pfJzXsuoA7ufTRil2uY=", "DjnGS9KcYshTQKuOtfcIbhyb1zOUUXmxCIkflmsiCHQ=", "CEMtA1K85oYSF7+zvfCgTz7L7q7i02DNWijF0jBZEdE=", "EDQk1/iRgt81zy1Z28K0U1Qr6v142VmVpeOGqi5Vqss=", "EOT/jjbnaELKEeIiWS0xiYZon+1zKLlMwVEEyNhuLe8=", "CmsAIBd+dmuyNL7H3uczZ4JRsciJnFFu0oMq7CNiPFo=", "B1FFI9Qlt2s6eBIFdyXAczNXcCO8ONcNB56y1STZT4c=", "DmZkCNYBmwyW18ndWrngikfMmI2TKSU1Jl9xCHPaWwg=", "AjOTlbBhfNlN0QGk0DBR6UNjJwRKxHDtBCC26b2Ha7U=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "CCPpz1nZ4pWQ6l1cqmAmXx7vue9JeoplPiHmuIS/OAw=", "JQFbwSwihW7dr/UU21IHlSJUKLi2O4LVTm6tiJBOcW8=", "FH9INq+DTInhLFLaXXeHJsh4vCAF546cC7Ru1HdAvIs=", "aVw64/aqNi3zIg47SyMNOup85N+kYpoLPaLPaKsIsg==", "LedpW/G5b8yU3WufRhhKmEOpDM8YkQk2cM/yHm+ab+Q=", "ITJjRkUZBqgjRf9qkWvH/6E5s+3xzOoSscyqVU7uX68=", "ES76rcOGs8Gr0tFzvq4bWpQk/lf7qywoJcLmp+Zj+/M=", "GipcKymQ8Ay4veRbV1ic1/0cXg31h9ZxiZmhiT8LyMM=", "IIfpWubfJwmOPrzUbz5P7KSux98XLV7yk4SfZxMieJw=", "JUwtebxoESA7Vc4B8egpUJUgHw8DYTcINmp69fe5YAw=", "EPI904PS6pUk5RLix6O3W3asx3ZqlQZxFkk6DR2w79I=", "CAFUNHoCmA/1J0mWNpx9Q5lR77EbGcNgcBCwPegCuB4=", "FVlA/G4yNvgue3JX8IKLH0PK1oZ3Vx2BTuqypphrIj4=", "D7pyLBu2Vu0cFiA1BtFaeMeQiKncutAKGOcHtx8yasc=", "CjHIHbg6Z0b7l0eYlQkBDFR9YZ0YIymPH1Z0VRR5vAk=", "FqL/y+mVn3UiMYjuLXvtDEy53fVSyY/qhqbAHxx+DdA=", "Ln6bnHRSZYGAgJc1RBlnny2Hj+QxKTRhOwGCDWYID+c=", "LfXVz31I3iB9f/BrKSlhCER4pgI/TuGg2nYZAIl32BU=", "DhwRC63LqNDTGQs33mLe39wqJWdfVNTFvWlW+ltsHZE=", "ElevGmL7dveiq7Pd6yVr3izDFZbtmlqi2l3wXLVrnrs=", "EZd3TvQXXWdJUekdVq/uYiniNqYRKoAsIGIUI7Cmbz8=", "FXh7oKv4FEOKPDWOSLhMrDjE3PZkQeKbWom7F7bcUK8=", "EN8Es/KXz9WCYOGTNCCpbxJv5KP51TAA4UDU9VwiF/k=", "JlIq7bTvckWtLlCrq+0+Mg9OwwtD8r8ZBMlWyzufQw4=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "MAhDKNU37raOVdVZPTUIJPAbzJqdjPKFWJgt3kO7jdw=", "BZIdF9WWRjqY+r0ukOLtku7Ki3kfdRNMmqdTjs+Q5FA=", "E0nwWz4ykOoDC28mlu1t81wnIF5r2QS1acNj2YXIH9s=", "HZLEYKTNb/5FgqWqlf9qg2moBPVdA0HdlNSV1TjawJo=", "HifOlbatYaZ9prf/AdBpmKXma3CtcIaWL4tvZof74Ao=", "AmC3gFLzQrD2LEptdcKuxzIbccCE/TZZJVcT3mZ8x0I=", "Ex5jBpYmZwwCLd2gg7/tkygO09slLVGtan6olI68mmM=", "DYm2x/HgRuE5zUuTe18w4pO0eIRarB4eZM2Qc429L+k=", "E7ZiWFuVpiz0ej106XHdGiGVqZh7pcNTSbKsKZv22uo=", "KZzdyxr+EQKZssRYmIiv38izMpOktPfPgip0qSL01h0=", "JD+TMTelN3yjmmT3iKG90lAn5MFXmQiqIynBjxNlS0A=", "FSUX2kZ3O6OlcIoU2zI55ZtM2vhMpVumt8Yem/+2/uw=", "GBHAjykXPD/9KarrLZEjpeK1vDLl10oj8NwCYZn5yNs=", "K+uG9/w5QZYoCb2McglhPrL0A6HbkKysvUhwNLTnNOA=", "ItQPBNJWFzI79kgacRb1x3ki1KmNhncw6XF6GBwk69s=", "B5hMV5Lf9aJE5F6NnKE9eHz1cl9FUTWVu/8UBfihL2I=", "BU8W3PhCZ/29Ao/E6I1R+nYkQFkg1vhXcWBhMMc1RUw=", "HhS0KhTccnLRj0fCjdgFD7OZOwwFcaEvOz5KTEnveI0=", "El3ciaSu7OptNiDwJsKpNy+oVrU9itXYrUlaXux7ok0=", "FJ0JWDyzn0EkpxRZIyBbO/txIcYqOdYjjPs4DHgkdbI=", "DsrnaYu/mU1lah07PfVmg1ARL4CleHcwyNMkNqrm7jI=", "DUj7sc0iLwUpQoGOc7ElYvdJCJL0dEAidBUXY+pmg2k=", "If9uDp3Cxe6xl5P7Kz5kzBEjO4HfQYA7ZSSuUQzwop4=", "De527vdjQGgOTz1KDFG4ehYttSVOmBp2hHVuVdi1E6I=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "HHLGEO5yem3R6IWgYH01zKkSfwBuJs4fmGutibw787E=", "HYv/IPU6G3+9PtTwFcoY+khMxv5P2jghAW1Dpi24VoE=", "HBPFFJ5fq+3VJyn05FAqfQ1QWMUyco24N3qpLxw+cOg=", "CiBExcQcDodPAFUoMn5pWtojN9yBySV7ZmOtHjdBajE=", "J6FZhFyDR9znFbTefTBdUpt8m+oJ0/sWFbadXQ4umZE=", "Aoo3MWsRGCL0POKHxjLNzecL0KCU+7De1JRnrPGZzYY=", "BpsAe+T//WwWEbIqH3OrqNM06znjZIj23K+PYbB8yEI=", "FZz+AbBA0u0nKTNV493CcnkGAY6rTwviOg+/kk10vRI=", "C1OOjzRV/y1/lSA+x8fRImLX0lsiSpJQCSNybyD03/w=", "HxiDknQOy0dKSliaO4Pe7KsMHFg8OQrh42VLyQ0HBd0=", "CF6Kt3/GgNv93TpB0fdJpbJfIHoQ+7WRsrK3BwXYiRE=", "GAOOWrhZJ6Id8X6KXbbj5iJC97325mKi+XOnlNEy7Lc=", "JZdWdK/MljfSeiO5e72LgodL7kHnuEBXvhOVFTH6n8I=", "L/nU4pVpH5l5rPWJxZmR8viRfGNYt25hobU+EYTdNhE=", "/40FPYQYgpR/tNMwJsSJxTtBDbt6/QSjRh8sa0aGnw==", "HG1BlSxTRgsJS7HXJwWefvCP6wc/HYRIRdU7lkCgn2Q=", "KRwoYycxLFM9PiRNc3MuISIC5UaAfStddYLnu90osQ8=", "LCnMCN0ECizPPFzrNIgsaPDHc9BVdms4kFEnay3Nr9Y=", "C1HWUxrvcg1A2Hi9+1So3ENoYGbPhebrUYjAlLFzkwo=", "Lv9+l2aSgAfSnSVV9GauIRFm3cA00TUxcoJGsjhQ7bk=", "AchW8eiYzZJB334b2yCFcGGssdglziucBceFvjWlBmw=", "CojewnaY1fEcPiYZt1YBu1+L7WxZ3vpCcDQbgEjK26k=", "Fxyk26aafyHDFensHUMk+KNlgoUI1iwgWgyKtVMiRY4=", "IZImTbd92nTgWoxzib8xREfsz+oykFT2lPrSrBGomX8=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "L52xJyv42vdGH2igRiJr9etQ3lIiY0/wnwbNCMjZBkc=", "Lc8KkF9p3MAG7PUZVX9QtgzsV+QG++hc5xkkCsitTZY=", "HvHo47yr3ZxZ9ci76cjrL+6GD+tKyjDLAzk5TdmqhFw=", "HxEVeu1uA2eFWOGH5zH05scLmPw2tTN1YsVlaA5kvAQ=", "o4zohMENKNgqO2MW8wx/yDP04SBMmEt8IAmKE6DVog==", "HbeOOE/HIvEpCjNyMdPImGRIuGet3igO9etyxF+73gg=", "HoFaWy/0BUVL/7iLPYrkKGgjdf3YWNn8L+4/ds06bUw=", "A3CwKIXBkraHwsuzMIiMn0s/JqbAVPcLCSrPltk/fJA=", "CCA/n/jbdXbhSHb0W+cI9Y9I5flRvgi7206c+yPCRLk=", "Kdwa4ZofBsbWetEh8YXs5tB1HQrDNam3yHm6sz37DoQ=", "DTwa8PrqheVOfaV1z/gOXAJ884dtoUE3dBCigCatRhk=", "KWCarB2Ivk1a/13ICOATYTCaGmyMDe/eEm+1VMeZROI=", "LaUjG7hLBcRn9v4rmz472neFT23jLOs4D+AwnDyMXVA=", "JGWKvEXREJ+ctO8c/OoR3jq0QvE+cQ0QwLtr6+WwEu4=", "Hzjq0mNoZfFqcuOT3dwWIv/FQX5RlNbBWti/vQBzlG0=", "DeapWQLYjfAhkkcWkdqkrFVhe3P0SKRhHz2JFygxVCo=", "HLjK1JlMOvOirkWEgnZAzZ3VAS/ktVE2vfUzV7TBaL8=", "DEsWb15MPr0s6chOiLPULPrueq2SPZgHsEor3mEVGxs=", "ChJcVkvYGLEU469EqH5pQGEVXhnLyExQ4NKWVt4qA9k=", "GM0W+5Q+NpZkuJ24V/Z4ex2CoXs5QPFa3UBH+L303uE=", "IhALhm+3025laZCiyDK9CdfQA2/8fSaTsi/PXCawVzU=", "IigZFxbzrtkZFlnu2l/jRrgK9YC2ZhWf8lRWFyVixeU=", "LcpslsMChLuPfPNGcQPTn5Iq7dtDG/o7Yqe8H2H9m68=", "CiQqSIKVTejT0ejPCYQjbNRmWr27TZgMYlwdRwNJOA8=", "DQZN7oJJKNOfKovn0vpYMiPDOZV4TSKIOa3eJVlZJZI=", "EWyFolDUYd1b8iSVNuUN4jq44Ch/XLxiNjxUxpDG1xY=", "B1Dqr3agN2nJfGhNRIrHrirZOVCnXCTzSCNAvSn1Zvw=", "DeBXykAab6ihfTWmQ/cVFWeJRPM9YlN3jRFrVbdZnPs=", "DJRAk/EYPS/YIs9w3BJKB6yTl/OpQaUNDDXajfXjUYA=", "GTduW7TSJm+DPX+uYMjF8vSEsgPwCAAwOFFcZuJncjM=", "FpvMMJ17b4xzWU11YyYuzTMu04yzF9LEP2+N1wTTIXg=", "MEgRUn9ha8jvWcVVZTN/Y6QglAI7Or+JrpkZMDTLyck=", "JL+4ZhciXt3YL4YyAxXcaOin+tdV7ECAEpaESdvhzrM=", "JC9LOjU11TByYemnXFcObAYXTM3zmMk0lYyhKee946I=", "Ky8oMnFFUJXTwgEqH0/aVLqPNlzb4BQyjgdT2Ugk9kM=", "A1qFLnv1z2CwDxW+GE5wfTRfoifY5E4fTDcFDXmlOh0=", "FQ93faIiBxAVxsTgJfZ7w1b9/WeNmEDdLJO6GkP5jvY=", "LYxwA1cxrZ77qSghqIEZ9rgYOjYr5kFympPWoyfAOAk=", "B7YgyKeOCeSc5UeqeDqnjz5FlMSas91vYCvGwDUdgj8=", "IxmWtZJShXVWfTnQBkWoOxOSkJO7+gDWpmHkppA1HQ8=", "BOR6cuSbnFqj9p9q8i+gq2QMk/xSTdPFCEhtZvB5hSo=", "Coy0sr8/DF2mceSPg+XBswGPDTEgCm8Z/VGV2yLu9/Q=", "GLuwArRvLl/sKxIPr4eCLKjnes6U4DqrXBbEuTFzncg=", "Ar+uGwVO8ukk11qKASg9opEDxXutEp7IOWzidLpFJN8=", "BtEBsZR30WJ7lUJYG/DN+rOLBc3v3LgZZcW+ANeA8ZI=", "GK9h9hhP+F8QTCvvF5s+xaXSQt++vo4nopGPYg6KW+g=", "EeOnwtX3Q3G+sYjG49ehSzMSivjuModUbRLXd3zvcMs=", "LeXWp6JzQ90EIqxxuNQJtDzLC2cul4+P39IU9NeGZAQ=", "Iny0O5gYkk8qJYiWSgrX3fo99iKEtLOxAZmlAe2XBiI="], ["DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "AVeGI93+MDMRrDJ6QyrumshVLPN9e+m0MjyaeSxXdsQ=", "F1NkUVGMJlIJwtnYUSqA9avk3zcr2a617rwreZ+x2Xg=", "ECW3yLWzjM1v/32+oyFfahzIDGSXPYlywLx2dMczoVc=", "GnwUYXzvs5zeIX88JYO/NdU4dQypgY4vBCaDIsKCAS4=", "J5k+j9joA4W3imIUZ1QFNh3uy/LIZEFjTq+3yZ/N2o0=", "DrfCtaxwBQHaGByqptQoN/b1FxOSTrPl1lQ4Ae48l00=", "IjE7F5U05LavFKVvjuwy8CxBmICTzH9P77KBlWJQsXA=", "AneYjd9/ouzPslYLKxaeEqSN0LNwe6PPHApRTEhSymg=", "Kv+QUGFyxDAMlNIMN6h3vdmGMMiZqqALyD8bfZnmyUM=", "CtdTewgl7c1GDQGXAyO/XwwzbVe07ASxVeNhBoIW+Fk=", "Flc+Q2Hoftq7Z/BKEKhLhlWnlqra8KznHSgqA+9zNp4=", "B779YlNRoulwhgr+XvDqsH3H3VGOthRd53JSvEdppLQ=", "JQ0sY5EFycWjzktt8BlzzEGBn7hb6IYIQHb0EU+g5lQ=", "DNeCyFkz3QeuDz9rDjxECsv9kVwv19p5yrHPpX9jT0w=", "I7YZigyFdnhIwXy+hwjrI79Tk4pgqZV25MKnysol0Yo=", "AfflDmigibIoajq0yHZLLLjQ2osmuFwPOkaMeB98wRQ=", "JY6/QMCFFdiXb7bQXaX3pDRVRI2ZjoaCqkms8lowfSQ=", "DeZ7O0nLYM8PIHTjYyUGVwfFjC/tQKx6HihWqPzDIRw=", "F4x0YnOiZQy2CMer7TurWV6MFAOn0B+KjRy0GX4+ltU=", "KrPJoKaYj2/l43OeerMz3ncITmF3sHeJMfAECD+AfeY=", "AthnVdOjdeixTvWq5uLutRBefsFgfeTWEljeJhf3kOo=", "GWcl0zLcUNbZFqGmNH/XCXP0YdKh/CuUGriRqgSz9eY=", "Ey1iz4KDPHn/UTbrLjltVxn3bsDFVlZbWnhpI0r9qCk=", "rjfGGAU2Z4YLCPMc2X5OJmGR2nFXCLuEREdB2etZHg==", "YEmU9oKZBXam4ckHYzvK4rKdK5HvivGRG0H9P9Fo", "GCqkzmZtFwo6prsX5+wAvQDcv+vQLz+lAOigHWsJSkk=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EPjb+t55CF8tnMChUzQnKJjlCEhAfPDRtoZs3iYKBDo=", "AZU7/1Tr+sfQLVy44HnVbITu1R1vNB3qMcbuq/GmWWc=", "E0TA5mK6opmseTAK737xOHsZJrDDI+onm+BGd1qOrS0=", "LwJ9rnFHbrtrXzsWMPmpISa7MacuUM+76eGbqJQv7aQ=", "K1VwojEjxVaJIN6qjR+IguzAQEv3O+wB9nVitgBWiGI=", "JIXcWuhF6KzAw4x6wxNgdHnkzusl81687KsQ2Cn7okc=", "JbeQetCYuafsl3O97xeh0xW6zPUCoqMDrpKS/PJM+G4=", "JbtmOIoPhjDUmf0EdAwWrj9vhIGy+WN6Nw6SFIlViQI=", "KgAiHY7cWGVpma50BtWHWOeVqXQcAE07meBiTR7ZZR8=", "BB6ke74fV2ob8WXp62yCt0yswiARwC0SlapopzQQhHc=", "L6XsoipL/Ac58GcdrbdN4ZpJvNvGsjs+Ss1lmzq34q0=", "GhA6zrSjDBKJ+G7m01nugIoQdduqhqm1kNqCn4ng5Wo=", "DqbhshX9yXC3TPjzHj54Epz60OVFk5y26lW05y80iDg=", "EBfbeMLB0WlZftaaPc0CRn4wBx3UGOtunbIJgFMUgUo=", "IgAsJCLsxZk58wO249AtNar9KItPeTaDgxTiBHtmlnI=", "B8g7/j4M0u+mL/jN9pTM+LMmjCNWvpYDNbRcnVd1GUA=", "JWtddYR6PP1cSnnHiQ/wjFi3OjHxS9ByRyQbcOO4ktQ=", "CqjY/k9C1ewA9YL1bQ1kqtmXekOxhdZgAME5YU2eoww=", "Ih3ZuRSu6CHqI8NZszc0WiLaAe74FhPlXJf+J1tCxLc=", "B6cYQb337g3PUa5BlcyK33m+FWNhb6X2tdky6rPPTZ4=", "P3gTZJ1GvMdBn47zfPKem0huKF2jBF2WtePGtjZkPw==", "LkuKPFgcUn6KErR3j/adhAWy2+84nWvI7RQ/cs8uO4k=", "F8Gof0+WDZE/XuoUCVlSb0yO16f7wnRP437TMuJr+rs=", "LEZYWun2y3fDIXmI2mlCO3FyTP9/vYzYeaDER5rxSLs=", "LVQwDGR6dw/cQ0DnQi15tkNZbuasb34bO2M5AioXaPs=", "G/5GJB8iEcbtDncjdlhQqm2hi11saS0z7qdkenPQl/I=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Diy932XCrgRS4+sleKwhoeUnnEJIHkpBr/utKWlyFwU=", "FqwSeMOwRGGOYadnsT3uIv42RQnviYRbL60aR8K5ta0=", "IkFJR42waPtxQf3ydG00KD6p5CMT+L+j6dyll6I//ZU=", "Go8LLBvjTT0E6niyw4EY9uBex4Grlclk6f7ADp2nD0U=", "CaxtNrmmPUAlmpinjJoiPeYzKZt1zUmpRO82Hm+fudc=", "ASgQrw7iUfJPuGiUt1i8Tg2w20UiJgqb1UBrquU2sj4=", "E+IafLj0nfuZDfFEzpuVCs4nYqODMdkL/VEhp9jL6vY=", "C/RrvDXOm6tUpFw7mjCN9Atrdxs6DIJjTobw6DaaouY=", "LTkFuiL9VLtV5Mp4ci0MPG2SLr7jPAJOO1MEFLDieBk=", "IelKILApvWhnT74RecqBPf5hs6yaLL7Gj8Y/RiXd8g0=", "LtoRqoz4oTzDal7oZcRlvIp7keQQYavjO6KkiUW+A7I=", "HoaHjRqZ4CyRCMo2FWP4Eg3UZVLe6M2GRZm9llkFrP0=", "IT+fsNog0h1L1UnrLNYPLpUc3xG7rtLoNHY3wo6Q3M0=", "CewEZiZjwBIXXQR7O625zv3Var0OG7iCT4sa+EyBzqI=", "LPbiLr9racnc+5teZtA/LJ3q2LFoviZx+gyQDcA0nGI=", "HLOQnq4DD9CuKmIyMuja9aUnZCOG5qGlz4y/NuScn0E=", "KpVLsdZGO3tnI+p6ebMxtSAc/5jr33cxH46qt6S6yIA=", "HSMmhac9xVPQ4bgJms2JNr3fQqQIE9Uu2yug4qcqOFM=", "JS15VXQpgoAgE87atITI1GH5MV/WwwoToHbuH9hKxlI=", "IURzncZEDPTwiQjK3GFBOzDp/eo9YA/2TwXFr+J0KlI=", "JtLvWXwCKV9JCia+QL9WyVBeSpd/AXsO4bRTm6tA+Ss=", "Lv/GgHrXm4N+Uyv0qfZag/kg34keVjARw0xYW4tRGP8=", "LglafhxozPHOu/0dnmsQZh+zzvSF8uzI3t6xB74amdI=", "Im8LUlltCOEsXZefdM10Rhw3ucpLdMLT1ypGf2gvZ6E=", "J+TcYbf0xxl1QEDbgMLCEDGX80pUpd6S/eNGDsz5Kzg=", "KgEh4jihPQ37FQfwymwWhvg4qsM0zB7LL30f+3uJwTA=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "AzxtTXes3s6QmbOxwoIKZML3U1glYqzizCT7S/IJnRM=", "CBWKT0pFHGC5wZB4d1fcBk9FcSY2zwFx5Ud1qUvfGVQ=", "HRjgr3EavGYXwDhWF9IbTBiW8BmbqSfzNpKzwRcSlM8=", "DI/53rxrW5D4JmI8meJcyLpbg/gQscK+QimORFzR5RY=", "B0Vf90dL8lEdIAcW6RbLl+CEKGTLiaQv24ekeaY/UFU=", "K3lrxDUABv+4Uvgm1CYf9vx5KuvBzTfyc+ZSGA3N1l0=", "IjH0bWmuTQriQpumCAt/5R8/k0w9ZgeuoSE5RQ45TdE=", "LjeygGNgBlpOgPo+bzrPDMkPv+5ejin+IDZzRfiXncU=", "HlKx2tll99NZuN7AWSV12Ri0i69l3CF6RC23J+Rv+Lk=", "Jm8u3v3u22HIZqDqZNAZ8x0d3v+WB2Z6XolBI5N2WBA=", "BiK5mk8Q4+pMGp8KLAgjYCofN/zy1wtucp+KUHUd3gY=", "ILb6S7k7p0u5GpaA9NwV4kNrqqFsvYUXOIGonS05vwc=", "Ht+alZtVK/owRhYVlV2L1at6LYJvsrRA02MCm32KFsY=", "I1L6/7H01x3MeHC63m3zkcSdQEZFHeA1g3/u1TRI71A=", "C7HIR2cHgA7Leyz0DYbmp9Wu1CFLnVNbIaApJ5ApSyk=", "GgBIYdvGZqYyxu+fymIUo2JW57DKl87mPQLVdA9/cvo=", "EVzA+2nDBkYojjQne7nVn1z/02SzpI3F3xOTZ4DkUs8=", "ILnW6oFrJe7y6uF464Xt8W2SLiWXWGEfjKc6hWDl9hI=", "G3ZQuXIaFYkkTQu4kQrLowIOWoSXOMcpJh0iklLXVw0=", "IolpOISCpG2dLDPjzuPwfOLI0kOOACOiDH1efByEvfs=", "GhxZlvWA3ZOg1IZUwD2fvQU6bUpksh1Eh7fRbVhrlXU=", "Jcad8tbRoSA98h1oLSSQfwjDS5QfU1HKorPCbv/z0cw=", "EoSOzs5Mc4W3Cf98mJYsUohl6Gu7ZSqHTEleWTGYb3U=", "B2vTdWBGt5ieiqkRW1erw1L0cLPo6YEgDPN1SO3MAP0=", "KIQGmprJE5GBzvKXpYVyhEisanSiam/la/nvYtE+xqM=", "B/7/gR1embR0xfoVUAS+pqb83wOmgaz+8uJa0zT3Hlw=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "HSAzP/w890XVYfEsQl2OEUgAC30EKutfJsXcIj/jGGU=", "KKu+x8nKpCjFGUFQY6by1eGg00njBh8FxA7zWANobUI=", "A6jhD+f6vuhoaDC4I0J1o6vzz4iNmsUAv8ZDxH1HbDo=", "GMLi3D2Lgy0FBGi3px4mvA1uiHFlF27QbAf77NPRWlw=", "DVDxM0sry8DNsBF6F8VUIIB1FZCiafRTBEHuGkKM9T0=", "E4BviAdVGyj0oGP4U9UcYhzwiy9nJZsDx7GxBzSUVog=", "Kwj+bJTru8qjgLDda/UEMMW+rSkKXO/vPnWurq97Y/0=", "IBlhAbdTmFuNgcM/7S0Cv8BZTteyWuw1Wh797nRsVjM=", "A3RcFD6XlFNLqOCTk6hNU35FoNn0d353+8FNItqi8Gc=", "I+AEfzvNcYlb2yAw4mVu1bp08jQLLMh2JqZzm2W2kpk=", "K3Qy2zJPXWPubfijJ619A3Uv6upjuEg1I+GxrFCvU1Y=", "AyMOVGP6iSrjfzj/a//P2wmogbrrEXzUUZnF94SYM04=", "BtInmHEQu6Ljk8zuGl0B+wRviOnoLJddacJVBfvi9+A=", "AhN8IDe5NrmvYF3aNP5EJKLwlap4SVbH4ahBBgI4HS4=", "G4WBHzYXlL+tHTZfkni47MyuLinxboGk6B+KdpgLBt8=", "GM6eKcq8OoiuEDKqCaZkowfwfEHQ1JX9iPRyn6Rx2Ds=", "FhF+sI0IjDFGopdgBCDiFyO3XSR2fj6SekZc5UOkQuk=", "FDE3oHIkofPfOC9m7R6qAAAAas5WQSulGVTc7Ncl8D4=", "EE0W2A+T8pVaBn1bYVsxac/6TJXHvSjFffegmGCLUss=", "HUhtbMHOe28rOq3GgNZj6a/tV8bfOUipnt/Y0h8yg+g=", "JrlnbD9L4nYYA35rhoHGJMwrrclePcwoWPROQie5DsU=", "G51ueLFh9TC8g1oXpWzia7MCynOEahWXRDicumZNkwk=", "EzxkcLtaNFu7Hjo2ULml85KVvPuXzoiMt3WwcYi+Ew4=", "LrQELaqtlybHGjtr5Xne6d9ktqylnLzdTgFN2vhgzII=", "K35r+X7BoRSxfmvEtICN3/FWFKcOQzGPeEDtcVYDM48=", "ChElkX6XUP2yWOQRPy477/jNd7LkhA0qCj766EMk8f0=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KPJAbVsgBqgWP6RJyrd1M37ENQdeCPdtyzYFdfHQ+ag=", "KDPtdtgdmVc/QF4kGHYOy/rTM/cbNfKT+z+yVQ0y/TI=", "EyloC6FwD9OPQtb4ihZtcSjuaLrtSAJfG9gnPG0T1bk=", "LkBsRllI1VK4K00EQ9m0OT6dA0weuWd5slVUhQ+NWCw=", "FocIZMdIHDdzLBImYBwP0JEuyuycSYaJPaLs8efpvqU=", "FvAgaiVqHq9Xm3iTYtdKbfm06PTDvEOmnV2E+OK4bhs=", "DTdpghpGQX18Qd5/2KRM8OawOFGzPTX5EFuR/QRfQ2Q=", "IIBy2Bx7Hgx/uLzy43KjphQtNkMISni/rTIy28TQQhs=", "GwA2S/2CWLwJGmHK+FvbUSqDGc5HydznguYhA8LHpxo=", "A52UePJEJoxIA/ndDdXmMhe+PIEYR2w8NsRjrOzFc80=", "FwJ4clPHcDZxE8oCT4NduuFbXBa8shIc89ib9gmT13E=", "DUJMJKtw/kbcC3CsRPFWC5inwXm2/Vn4e1HLFYBATzs=", "DI7sZ3RxVbAkONGXydVUN0kuriNcBeOF9a/yOOy/9JM=", "GTGKhcrClnrcNMQ0ztEmGr9D4b8RhKQ6CJdDYSEZH/c=", "EA0OObCsQWLRPlI6gwiz0Rhf8avApE+AqrGY9NSvLnc=", "HcnttRW9YioJ1vFk6q8suYesoj56CnnI4A0Cq0THHN8=", "LLCk2ZGIVZr7pyJvOn3GaxKTptXdfr85asltO7Gw3Gk=", "BFfp3v4rLjrOQCFxgcXPijYcMwO66NG4Z+Yjhu4K7I0=", "J8tgPvNwBDFHLYXOrKU3vKowHSIOjNaMjbmy4fU+mdI=", "Kg9zdIG/29Zfj6TLRGPlajG+xud8lOJyFvTVqnNN+e0=", "CI4waFMmuS9gB9bvpC2K9ze99C7H4cTVZTGBgdgpXqA=", "GF3uf/wcCTMvwUNvHG1n6zxtzLNruYF33l8oAjAsaKg=", "Gjwsqdy6eABaKK87Yh5QFVKV8UrHRgV9zOmG9jaNPZg=", "LImfjUbBjupGubQx1p9USb9ciWsHNDpRmeWHx0hEP34=", "Ere4HHjHESx/ed4uujPxhZ537pv+VNXz7hW7ri1rkKo=", "CpxB/KzxiUFgT7EpaCdhgD8WLA58wRUvcLt2oomVrug=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "AYwsgMGTv4k/jiQyi7eRleHLjsXDD6TQrrIoyCDn7cg=", "CEAhLMjfac3sml1zsz935mMM0IoEYnCTkUB8iFewm+E=", "I6Kmm0wfKp1dqbvBhd38iPrMmVhCjgb7qD1nprt8yo4=", "KZCgAjfOKAunBd+FcVYAp9Ql1OvisT7TtCsbRK5I/gE=", "Jo1LOvN7X17BGDasVMHO2cVpOQ0EY8MWwsqvcf9FLFA=", "FRKGw00tGoj8n2lubHYugzMJpnEOA4MSEtMXKWscIRw=", "BaDze3cfy40mvqCXIlEK+b9RCuhMXwEG04JKonToD0w=", "AhhkSFc9q/2ADFls9kcDuwu0XvW4qR+iEAmGKuOq4MA=", "J6xe7UFTQNmQfGtBRwjN4rmd4aVQvhwm1u+Vxu1fuaw=", "EYuvYOt0N3PN5ikULDD4bUnWM8WHnxl3rrhJaXGzuVY=", "Igb0r53CGl6UoAd1Yp2etGoQTsrw0hiBIhh/vZxfZm4=", "GHT6XNb+3Y3OVqOFUrNVEru8bKVqS8ZBBAatFJvTBYk=", "DyLc2/6gD0vInb/qx7Pe5gsW7pp08TWI9YebpxTIJ6o=", "Dt+Uv0nAQN+XLidwHhYil2bYQZeynwI0BlZOMs/YNYs=", "LSTOuWUysG51HRCafvzSm6dB5h40cr7OMMcSjEcEKBM=", "JvuLjrLZDtSIa5mCvTJVud9GkPhAR8zUvfIYEHIL2kQ=", "GVJkH/9LV3gD6sEtKQrMOfRyjj/AhvP3YxP7K3jaWyA=", "IjO6UZI8EDlNHvhxim6C2E2QVN6MhJi9BdUnh/qiXjI=", "EFUPfQDYPx5/t+HJdy9UXjLgpgyjugrhaMdQFH3ynuw=", "B+XokMPmLFEJ43kNK9FAb4QliDq/3eGcu6O1qnt/K/4=", "DWEaz+L5H2RaB68O1m6oE9c5Wwm05LPLkq/CejHnz7Y=", "H8T5b9fHpp/ugJK20Rx7raeehRMk2kjmWKFm0A5mggw=", "ELI9LFvX6XYijhkGT/M5Ifqlny60yGUtOVRkedJuy3o=", "LyEWa+LtGy2kdCXWu/TqHyxarIK4MmWRP26nCjMhzfA=", "KrCVL7KbvrDVco8Hqk1nQxwdPDSKDx22Em5Hy+/d45Q=", "KhDHb4V+RyRdPBRc5wyHoZlUSFeWR2mMEi08f4CHY5s=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "DovtTYaTTMhDg0gOIwEzG+zyqHVukJjIpVQdObO+IIQ=", "C9touwXL0aMr6jK42u6X7eepmcMeZmIbTsxX6Abptos=", "HGghUQFBnYPRWgJgoNGUVtik1VLtzvErjrPI0PzgGLY=", "FMRfajLplVhayBVFVF0oA/3ZzQ+kYqifLMjS8oaSif4=", "A8YxR98FGIJi/lbRmR+HK4BppsB7c1jRZgA6tCKiv2c=", "J7CTmWcR7n5NHWVmAI60a1O8RZJaOFumTEsxTmj1+Tk=", "Gmf8h3bPQCyUWHNA9Q/2oAN1cMUPJNr3HTsU8Sw3UVo=", "A2g4S8mKUZ3XhDT2P5K+URqm6+SXoPICxA2tU8yaxB0=", "HLj6fOFrROOEMnQlidSFfCkOQd3s8cBNGUdTgViNvhU=", "I1l7hQ82S0Vp3mjxrHKFZdww+oyiX7x8sE3l18S5fGI=", "Ddj/GdXhMI/kJmpRkDD8viqdrUkr+HMg/uG1Y3hUi3Q=", "IP633hpelrg08z8M/SvnBGOcAkxNQLLhMCcu5Sq9Q7E=", "IIhWgrq4VK2bMIsp6TvNl0SzCjKoa0NlbrnrOYlYxWk=", "GdOiW8qlU5lLlFsZZvDoiHe0mg66fPt0NkJayYDR9LE=", "KsjP2EgCtnF0ww5ItrgFr1rlwOMIvrgs83NPqxzr2nk=", "DnMJ65hrcX9yaEhC7kQmYHiqk1gg6FTswm6GswSjqvg=", "K/fqt8yzgukCUzwmWyZP+mMnj6KY/ShGfNB1p+O8My4=", "CD3SlTxV1cK58oNcQY+r6fMdcSYBu2iWQQEUmgkQBAQ=", "BxTtMPtVkN5RiaJx4ajGQ+UqsOXxOGce/v4yjYXu4Us=", "IRSPn9OwcivTIaPz+1nfsY3sgoxxqCDlDi3At3ugbCg=", "IjLk2Xv7Svb6Aj7XO9+JngQMheCG7GH2TZ52vIrv2h4=", "LxMMgVktFNqkoQghniOBo8PUP5p/2UB+rHkVaKcpDZc=", "G8MAauyiV6oeCnkjimrsoXthxt2MXjj/JZzsxwxtlXs=", "HizXVNl2Xmv07mBMMCfdFVPmvEyW8KGGDeXsHtTneJ0=", "GwMAhIl2LxjTUOb1lJG+lLkRJfbVZIELImAg+/Emb+s=", "BBOVh8lACNKuKGLxf0Yj4Apg8JVlDw+VTTPis+AoyKM=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "LpLQ0ANHiq1Gm8tiqcpPxqS4t7VKogCCQhBHtJUmvBs=", "L6nxJ+GG2krcJ37S0P6Oz2XXaGFxs92bW6V6QdlL54I=", "FrUksifJHRSuIv7OeVq3tOBnL5O8C+EaS/3tumGOxjI=", "G64TLTy2cjPvt1Aah+99UwTUPYR5VCKlmA/vbeuNng8=", "DWToWCYAT1JPqWM/89vSrP4hR9+I30NecZNeUYTAtd8=", "eomR6SExgvBufycSblg/8QArcy1I/mmJjD3RhURoxA==", "B4px/wbzpwN+Os6h3y8E4yZ3Tdsg1nFwUgZdW0jk2cY=", "K9vMBlPf8Lhkunw1ogU2iLmhPM+D/Hi1hXqRGDxjS6A=", "E1xHcLmEynJAYQYQF/b6xjzj/V9C4yca90giHq+khtw=", "C+Sz134hagKE2khPoOwXETCYDWZIoQ6BSUJkKE31AK8=", "HTOh6sg6oujjP5C/msUb2qGG13FN587kNXtXaL2qA88=", "DIChmjGcAJXRDeFHO94GNuGZsTuNg4M2oBM/hun9KAw=", "H7AKXVRIIog5/KmxCN30y+7i5cany41ru7M9r3Ll3/A=", "A0KMXPUTmmChnT+quvbYVxwBJCAA4hbj5BfTdHbakc8=", "FTE8djbpPJAoG1lG0SI7sl2EnGsFqcbljjRZ1AWLQkw=", "C+lOXEToZXf785udsNOrCKjpChSIE2Cjvo53sUZdagg=", "IV9Pw7NujvQeoiYID6MxSJux9dWy6ZJLX0GaKQA5BhQ=", "FrAWLXdMUIgqnyc5vbJ5MXkY0PdeL6db8k6ew/GiEQI=", "ASww/rEvxEHW3VBZwmkHTxCmnezBSL0ig9++WU0qU4o=", "FknFLd93iOyyFQoaSKrQlrTc2p9Rerh3oRknzD63/ps=", "Bu30u6hesZJ/+qMHqpOFwOEe/0uiSajmBdYk81r2+ds=", "D2GtJfNkHqzxyk/O44MNUiLzV/BGxHTr23MuAhHknkA=", "KtzC+WyVpA15bgyL3fMD11utw3rJqmzTFzuGj20Xfeo=", "ClDt2L2Jmx0V2sIhNr06POAK0NWBGIqmwtuW/2lmE7o=", "Jqntm5ZoEQbKwOdwb0KT/nnQeNkY8l8HqSQ7kS9dUjg=", "GVlbpAGRYjU88hJQyvoapkp8BZfA0K9bHeChgTFSBDk=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "CWk2OtL8Vt7dkypmvxGToblidvFuQj94z9eQhQv5NHc=", "DzZLClobAPcZJpf1yglgaAshfj/uLM0yDNQI/coPp/s=", "EA/ii0boDxXhLvTVdZ/d1WD3a/dM7mBR8jqxDIgD9HQ=", "LdCq1z0nf4vBx20hM72Miouou9Vzvfwa3OE4A0W/Iz0=", "HKVgPDvYkZjUUJYMi+9DOuNo7+S+Vo0fj2NBi8Z7omk=", "HrQgOymTmHIv61D4biEx+HCrL+5vcmh2uaITppyLNMU=", "INPqw6ae2dmWPeCh1LVUzgteNQAzx6q4dC/SWK8xOSw=", "A4ugtcK3w9QSkwR/tC7Z3zRwVpZcTXOZT9OOCz0MPHQ=", "ImxotTrTFvIviqgDqQ/7AsSJNk/LgHqyptrghaLFSOQ=", "EVmtIvtGVtqxDaYG0pioVoMUVL+yN6Ii+jk6mX2tozI=", "ItiY8HTq2+Ezs4F052KaP6R/jJLo5n9iEwoA+nUCuVY=", "DhGDlfxFGnqkYS2hIJfENyyS97l49a8JKkdx4JoTNDw=", "BbkSN1YJiac4u8+AohdUImVt0n4PX5Z0HRQf0ZOS5GI=", "G7PxM8LV95MKnezQyvY/F8VSiETbJu/DNuUQHxhoVFw=", "CjnugIkkHFy9aZVJlKvuBAzPQ7lRDVSgUFYZSRKWO/4=", "EdGnLZZmvhD+X+905uBkMVMvUVfuJK2nBoO58KWGtYU=", "Kghy8jlJ8hO0a0Y62CiRnr4DSVBCn5H6O/+yddcitHw=", "HaJ0HXTP56FZZmIx65mBdJpAveXOpvGgad6lfPRg7UU=", "IlBG820WFwTCaow3ji+liFmigI+U1SQs3Dx0LFMPYL4=", "KsXnkNeKOxnkD7mLJH7ZyveLR9iE2ku9cDWUgsL0rIQ=", "Kp/r60EXh8Wca45REIrvbZ3GOql8sxSQdgLV9rcCF1s=", "EFGb9LXXf4OXpOUa097fWw3uKyXgjLW4Zu6yqJHgprI=", "Iemt0oQFTLFJ5n7D/EIIueD4qMIBGrF7+zxORBnucA8=", "CGFBmzPRqeKpRL2GoioDSQ/FYKbj85IkELH0zq2/L84=", "IEvuCI9xY0UYfBwl/PrTPu+IqL5gawRBE58Dvj053iE=", "IahQncB7aQ8Ums6VlUDu5A1IXbWiHjos6dvoCPYhyS8=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "K8yeeZBluJBAKA1r+pDZsPmKyR1QUdaDxNwZxtB4WS4=", "Kir5zMjNm4l27CA95oeDbmAl4Bl6nnVqCUFo2iNMYlU=", "Is2oogV6Uk8T7Av9jPREgmkVNs7MMhjJNMp/IRJpA9Q=", "GVq6+hUxUY0QHEJ0ljBcUuPSyeX3GSIH8jmFoVqFs4Q=", "ImySlz4r8G6IALzkhtO1xbCG6XF9k7eeQISpo8v0Hcg=", "LUsZvf/tR5DrpZV+RUXMxl/9wwDZRbEf6tUvg4Jcu9c=", "IMgykNXvYI7L0zCpmM3piTYGDh+1IGUsnW6xpXVY+Ro=", "K6rctXv0aiK/KZw5PRU3vy1hLP3HBBOvXl2CYfh91zs=", "DwmHXCVwUn64ZtMfluNXlGzwEwfYmWLbDG8WoCCX0I0=", "KikkZwNonA18UhNsK1SCRbNL1rbDQe2Zw0DhFLhW4Pw=", "LwXXIyYi66FYO/gx9qgQ6hFvD9kz4UJlDFjWrxvLZsM=", "Gv5dHhtk53QQOdbCagVLcwDst9BS2J6N+M6PH9tSiec=", "GSXySE5Xos8TE53e3f3CuSNWQMTkDnMy0dYyxySAH4g=", "B3UlVjQNzUhTG8sURYPsdCz3U5yawjRzY/ljbqBg854=", "BDwoqdbzjKUPBX+nG7bwfGIpX8ohl+BWFg6TpsgvwVo=", "BBeqoX9XX0IyjqpLoivnIH/+nSZWS0KiS0GWfz4xc70=", "Dm2odjA/vtfudW/Yeo8+FjYyVTKt8mv/iRAZjJLgyvU=", "J/pXJkOjVzLNohVx05BgD5GIc5dk/ruN2vnAG8qAf/U=", "GlEM7pXntvTv26VhLoxRIcHOnMoaN22DeaH9wgalX8g=", "FEJMSz5R/7oYaf9lJ8465T3BPMHqGcy1yHkspr4od1M=", "IaV9iFTWyuXQgY0pT82eGi3HFpGi4/myJ/x4ictyGC4=", "Ily1DbC3OyAFjvP2cf29LAh3oN77g5JjCgHO79oELRY=", "BYZBiS6kcM/IPjY8W4gOuCYyElM/i6ZyhSfEY28+ARM=", "H0UFdGzk9lAEtD+fABfSYC4b1E7laeCP34MtkVMcwqE=", "KgdtgYbbJSjZT6R9xBchYpvML+g+7t/EM8IOjPTD784=", "HewNb2Lhmh0qsC1sTWpteh3ROHpKH7Fe3IYi4aPe9Q==", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KkglNJGrrUVhssqc0IzBznrgM1JA+s+m77T8ZTpI76Q=", "DP1RTwngaZIXFm4gp+2psAUSthRq9R/Bd23WmAWICDo=", "GTehGSMADZUTG68xAHi/64S5mnfgJ+jQ2WIBuRgTLuk=", "MDz7kKIoUJ7PWPxulNz6CGDSBrNLKKg2ijVZpXrdHN8=", "KJMOS57BfFj/p5NMIWqxr1XfMJ0RXQeJIz+E8sRBpTU=", "GKq9zg2pHTtkS9XsrxVKtxSPPDMmywG1k/ivnvytByg=", "OR8t3Mm9b6xgDrDCbgsamidXFinpsA8IDYdu4vG2SA==", "HXZcIKWIq3IX/dpeAdzM3iPc+anMzsTY9CRzXzniXzs=", "DZFNgHsP2hzddtGVXxcKs2FqNc5TUWqB4xWCX5MWWQU=", "IkkmGbFhg9MYDBWZTCUIyDc3ripC2WjayFrzA5IpTn0=", "EbO684M81KYDnyvUKvFjOkfyQPuIp/CsCQL64qW+NRA=", "IHxAO3ckTIAY2IRXFOaFZiFvv8SazQEHxV67iODeOUk=", "LJ5DHgSHFSSlJishKG0EMz3ts5OgePL+2SJmrCL++mo=", "H9CTAyghp3ckIeYrTjwjoZXSfqR5j5o/Wmx9TS21g+Y=", "LqqCt/0cBhlAwqd73S+2U4Qr8bBGZpayks0wS0kHUus=", "D5j3EOQQ3BVS+2nMhQdribT96PJ0KKMLWCGfUuQi0TA=", "EiKbVnMLogpqUtIb+PcxJpboz2U38fbFC/3Kqk7Up+0=", "HC+5W2Sg9mtl2QYPHwZbuC74gq92BBmqvcbNNSlDHn0=", "Ly/OYylkIo7veQhHjJAQel3eRa9kfyMjrYphLkHEgVQ=", "BhhJq6RFFFj3GMO+P3ajg0flEs9CLR+QeoLadQ3CFHg=", "LNYMMtbuNsN0AWvU8cCyc/+HMV9r/h3JqB+g7LEmRZk=", "w+iXqLkcEIrRmxUumELPuHxK8K7I3JUOD6Ml7U1pqw==", "B6OPiIumeyFQsOZDHOAkCGgdLsgMjaykxR5ltZ0yn/8=", "GvUkqH/dr6rYK1IxoedegHbGbETTtSeiWaFUIocNthk=", "EVkpCkdDNl14HgGg1rxiaDImCwffLQ8ojRXJUnLrH5w=", "CeUc0VGC0g+HsJz2lm+SaFeMPZzFiz5/mB9nUC+UeOI=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "CwvO7kXjGwjAVIcR1ZxUj1G30agMzv5lmbXbrQ20tzg=", "JBxv7ZKuTjkbr+OvUQMDX5/B9yem3I7l9hupsePq258=", "Jq7//EBDsizt3ojyvOdvr2+zwhtO2p1oLBTboG+56Ho=", "JnMpbdYs1zZlkIDQMLmJFPb3mXUkA7pcKb+a9q/MyPE=", "IsqXxN52lmKwcffNdWV8FenLINdE7dCnkR14tqSqq+g=", "GI+nS37aeS3DZgiFkByC1XBQ50sJoStfNG004eX2dhQ=", "DqAWbMTFHCJS5PPckvzzOgOWSgMFD58SW4en/gdN/qY=", "ITTaf7TwiaITYwEbCPtyqqj+dnxhi98I17h4ENX9tZQ=", "K+YskjTcfT22ascsdYsVYo3xzbeByQ0PLyPeKikAUQU=", "KCrogS1yny7/hvLsR4plcHxLY9M0Q79tj4clacQORCs=", "GJ55hPpXCY3XNyk6Gdb2CXHqfHT+xgC05vogzDFPAVs=", "HiDNPb9KdWQ0IeT6cT9c6qNe0BlxUBgvZTrpZjqeRcM=", "I71mz9xU+S4NUy/0E6Li/zz29WGjREY+XgoKjFoBAwQ=", "BCZXGC7kty4+RAhSjBm3HM8dT184rLDlpe/WQc38a38=", "ChGrwdrx/47Wr7awpjcL1V+751B/HaVo85squdu240A=", "IA7eq4uU2vMTXrYEY4jM+McUDZGHPS/vBLnGD1Ccfec=", "BYVGuegLLcIiUP5cU9ZqoUvjHV2StcBKBeNSWBD8eKg=", "FnC54H4C6IgU60CkPYO9wBBznprWeZwQu6JOH0C4r9E=", "G/Ofl5wBWvSvEZwTfVyKM07QvQ1/iWJtT3nvR5O5EyQ=", "Dhnc31tKGuAfy2xleds/thW/F21T5q0EfM+QWGGs1YQ=", "Ao8iBT9y6lRXYa/JVXyEsFxvc26+e/0sjFwETQm71NQ=", "BW54VKlta/+ymUXXa1H7noH18ZrXZxccVot0LpJgVMk=", "Kuys8Wn0GNj0dHLbYlrDvbVANmfGFFdmbUI4u/OdZjg=", "FbBOYtQWehZvFDZL7RltHQ5JyMzeW9Vg4mFgDdpNPD8=", "FfiMSzFQhxivZ8bjwwzzz1lPv0gag36A6JFW2cLRvnQ=", "AU5mRcdifnRPnmFAZ5yGMyXR2V4eR4blc6SYsKeQtDE=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Gv2X+sH253xc/kvOhIuTBRomo7fT1rGN2gSIY6ATzOQ=", "DfaM+2VQMAfbgQRK8G04zmP9ofVppwV/GEjuRZfYfAE=", "AQhrMkd1KflHb6Mk1tlVK7q1iVbC4glVSN0bsg6b4Hg=", "FhEEaxJqz1dnVhwy0xo2xQcNZFvfCGhCQKcrmDLDvyo=", "G/PrX78eW73pklIYN6jToVoYeSGDKYm001ehss7Zs20=", "B5mjSbEM3eh65jGtOVnW+WZM4j7pHgEGed3MYBfvEg4=", "xV0Mo1qg1FOsvdiZPQW0eeE/zlVbY0/G0+RwA1sN6A==", "IERMG/Z9bOivsKIOeda2kbrFS8sxzkGCsVee4h6p/Io=", "Iuj1nLtPkmOc9Rf9EZ62UHBLAObrP1jpLrMecTwbkao=", "G0hBrrA1suiW1ktZtHhzy5x0zQW6EkNunRhlpKdOi+c=", "Ez1J1Wx4CblC24kbQksw1WykTuf3OqAopeV36C9QmWg=", "Bpj68p+DKB0/1CHHjr5pTPXrNx4poJNUdBxZ9KSrxq4=", "Cc9ouV4aRHImqMOUQFE/llpB//iaHhYYxwrkvgDpLGY=", "BXoBQae6IDiB5akObUIubZAB6sc3/ZhgNEGRAmxf5UU=", "G3GsoLNSxe5OsG3qf0IC+huQjwjivlXcCDShqHNgdZc=", "FCkVMEuwHOyZoiqW0a8xwxM4Kb6gAq6Y1wEfoVFhYNI=", "BKrVGxE2OzCiau94tK9DHdi9Zd7Oz80aZnPY+WoObBY=", "C2PBi3hQO2pHqI9NVMTaepwj/jRt45qIhCJKKoWpURo=", "D+ENHzybQGv7gy6FuKhExcTaxzmPLcPOJUHfpxJg0lk=", "KkJCCAl0aRdkWAbXBjFWT2EQMYb5zGRN9bew7k5qJ9U=", "BaZsb1DTk9p5Hldo3odHdNBm8IdBGPD0F7agNqZX3Lk=", "IaTXGGLcy3wKCpuAlFxb6SMH8UfymRdoQ3gRHNvp0v0=", "BG+FX4PhZCau08gfWi9/kr7HzrcePcfiRTUUwQgcogI=", "GF60xn1PR5gnmAqWgnzbeZiM340xwvjSUydl9BVcvvc=", "KkKU05GbXevOZJsntj9A5UBrLwROHUHVhBG8AHGdPnw=", "KoAtoOTVklm7qn3DIn6i1yX2zOUDMmYfCDfPuHr0r5Q=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "FU648E0XUFcgfWF5MbUboY7DyDDhr6dV6K3lv6ccHUQ=", "HF+7I4zQm0rXYVSi+tt+fXMr1TRgP/PLvugDHN3nuZQ=", "HDp/4Uw+9/A0JmQ8yg5vqtKAb53ulxukHAED1C9PEWo=", "CSipcwsl1kfEVjtKcnMwfJTDR1Ze7jbHgcO4rcU5c/M=", "Ku/jn0/qlIJhzb4KzMXHzP9nFP10H73NbimCSVYN2Xo=", "H+rfSuy/fH8fUm0Ksa4VE/G0/IcxGH+bZXEzd8kGIDc=", "DNLy1Ngm2YzjvwjaAq1YZvNMm0PyBo2k5bMzeNk8TCQ=", "LntWpkCRNBJtQRtWCWfEbd86RvpH3sRX+4KgcL1EiwU=", "I+430dHh+KOxBoC9yry4kmiklYBR6CMNFKBgWvhX0ZA=", "GpEMAkeaZ5WYEAH0AnPHAs+9zBwA/QPeH4BXvygJhzo=", "J4arzqJ8NM9P8nR2nlF4eTIAHAZAAzp8iZFPRLyjKX8=", "CyfUAvxp4vI++OYEIKOOQp2pafA4z87tsHPhLyilomA=", "Bcj0Yocup2iXdCur0QmbCsp3hkobFl6uuNy7P7+5UoY=", "DSkTDDzQqyNYqxaDWXJWovfuYRN2uTKbiu0w9pUFvaE=", "FnvrdGZcGgK5BFCRSHDUSARytrK9IlY3UK+v495f748=", "AldCdce8WIeQBNY90wdjiwV+ub+ZOIrUeIZZ+VfvViM=", "Abr+IjKcAPzroeSMX2G9xRmyDrNS4YOFmyQ066bL/E8=", "BA8l+wSPJi0LiOWlVyNMTzWriY0QTLLrlgkF4ei6WoA=", "L8fPJZoUdOgyQwOa/vh66H8aB71DNAUITj5CQcQTrs8=", "MBRJgK81tYLUNMq5ngiDW7CWRNrUf74Dau/ZsZtxOuE=", "FA8qtHuhoI5P+MOKgkW3n8IMKRb8NHDk6usLNlS0ptg=", "CXyxrNibWxLoLhRXHkpO9Rb1wmk/C/cNTAXNTvxy3Z8=", "MENa33krpaiiyftZnJGh3lMcf6gJ8/w2R2Ho5o88md4=", "F6y7/6zskZoRXNxMMD+TNf67sdrRLwoYJf1BNZ73NJE=", "BFrAeCyO3QDG18DrWUt5neWYv1OMgPRn+3pOsfawHYU=", "HhXRvo0igcbyXvxWsz1yv7WaYb2RUYo96TyvKjV9AlY=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EluWxnjS7xgffkv7t5UVDu21tGqRPWVx0bIEeQosew8=", "EwvmBcg7wBwfoOZMee51sn1LTv2JI2j2aVnOvY7x154=", "MFHGkYOWh475ixO3xITGaVoJOtYHv9zYfwG3nUIOcx0=", "JjVEWj9mOJtGOOu4Gjb0zrIQ1fxUZiCewhXAgCOsqV8=", "ELzg+9OoeWFSdZzCX3JgHc2Ztpmow0aG5D/SttGyfYk=", "F9roKZ7r3gBiBD6ekyZ/0bONbwvN5YJ8EIIrE35LvKQ=", "JmTpVkbsXtBTahri/8hBZbWjwpXCHlhgbJUDerdGqHg=", "K4tTyOkDgnhrYPpQmU8oGGas56MRpArwe2M/PDD8d3Y=", "Fq5T9dTGOoH0/Uh3k+r1zSywPjyCNr58yrjCA3L5Efg=", "En2tM2YorSvEA3GMSYPBNvNMv6/fPkXGFq98fhyoeT0=", "EKEIAd/SFCK09aJkwu/yEh4PcWUSqd3l5jceqxfm5/g=", "CsYYnuyO9M45KNd1b6xEaFtCXOZL7j1IUmmHCedp9F0=", "BvSeVccu/chPf/YwYVfXcDELHE5uUJujkZuUZr3t45M=", "CtEket8eS8hmU0NCW+5NPzVCnFTWv0qOw7Ft/dHdOkU=", "CfmJySmV+G2vKaks/urc5fEFoK4nKyJTuy3jdYp3HCY=", "H+85baojf2Rn9iRBpVt1y1oJ+pTLH9snCsMJSH+mgr4=", "Ew103riAmeNTYoATM79/roq/lhZfrkuBeVeXYa4d4dQ=", "Gx5jt9i1+NlhLcWeGqlCL5YnYamSB5qOi/yRaVyiBL8=", "LV1cj+rtXeyV+51mdAZsA9bL0NWECEgnIUsJVTrd29M=", "IniitZaj0K8Kk2X5VK290sihUUzJBjadOwQCgRyVKkg=", "ESkQBsxnGJQP/wN4y2zvoJ20t7fITUR6sTKnpHVzurs=", "HgvwTUjVToy+hxvNv+YZ7Tj+ab+dKmH7Xe8zCy1/QHg=", "KwkHzTXGIVLBDkfpMNyojUsSxa+n4oNsJjeuc1ALdl4=", "LlBRyRAgv2xzM59lOENDbOGCz9SHwCoWV4z8ltJ8Mc8=", "EifgyGqwKtyvAc/FbP/IFe/qsz7OjBZMMbulCyhHexM=", "EDsyj46f7wLzQOP2edkdlQi7Hu0h2Y1WmkFYOqtZVwc=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Hj1SZC4WJA3X4rDuIc9LO0zBDIBf5SAJ3HUgRXGAlFw=", "H95vO5jfYQTQe4SnA0lIktj9IczlPP6epBxKxuUSUmk=", "BpNKY+BHSXVKGYA3EwHKobwAzjhQWTOx7Q4IWldVhW4=", "KJfWY3kcacm/6bMTdZvhzqFimeZnw6yz6fGAedOSCbQ=", "LzC6Z1LQkApkvo1r6LcY7aZ8+Wr5Wh4NyR5yDd4+ykk=", "IZiY/jQ4peW9xaeWEQhOCXdFZRNYb94rI7Xo401+t9w=", "DZDwr8WbAR0pSfmY18XkwqU5U671j5caRYcE/Yj2on8=", "DyHzcQtPZB3f38u2fRP4RSFu0WoPHAtFCsuC6ByFqT0=", "LrA2uqidkmUVKBq6BxeY5zlxIvtR9FBOB7aszLqhevU=", "Aa2z8K08fiMAxxemZ04i/6JhGXjYwp49IQEvvnYGreY=", "EeHR/nrThlWBoaiTBpjmdiErBMZHc2AQNCI0dfkae2k=", "FGSHR7i7Wx6LQzIiqWS5XE4UP3DWsm5qpiDhxXyELtY=", "FFWL8tr3GLMHVsy4jjiQ7EfyW0teCHz51H8zQj6XqQI=", "AubQusMl3aYzHiEXxoIGahvpMei2v4ieWqj3FrwUNYs=", "G75pDBg+VPKBv7S9hDr7OWG9PkKMgdz9rrgiCjhYc20=", "I1KN6HQvMjgSjmXIgSKl508m+ywRYv26afZffZcdUsA=", "E+OVr+Mjkvb9XExcco6uMk2cJHZJpsNBJHXE0ExrDqc=", "H/OLRcTluGgqc1dyPSCUn3t5LsVd/KdMcty1P+aMkv4=", "JF3tPb1sPbCUvAQN75xOipbmdJj5kjIkOI/LtEEQnfs=", "H27Erq81RdvmXelgL/SiLEiRHKZke8xjLIV//JmkLZk=", "JDGyNymfGl6O8iVpz42wICR90OeimHFkYhBuVRnT/fs=", "Lkk5sBXyf9yTj18cpV5dfpEgRey9z/7e7883rHfdvlo=", "JsBhzeR3xwEcBFBbASbv8T+lVdJI3xloh4lWIJ024DE=", "HG8hMA0T9SvtabKus9updgqU7ZRWc+MoOEjPpcRVXEQ=", "Cuz9uGpkMVQpYF/UY+1mTyJNELLgoy0106Wsq5FGVbQ=", "JaEfIB/Ppkrt4Y4F+xm+k8+0wVWHdZ1eURBCCiZ6RLc=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Ez+72GhYuRQ7zCmKTXg+W4tP/EKQ0dYeh9HOX6T5hWo=", "LPO7DADiBPGLusH38JO5/r8sp1QvRAcr5wzZFdLEO1M=", "E8Gku9OpOOjQOZ/3kdhpYtfvFQRZdBnCwA9CHURZxV4=", "GwCNuY3PUzMrZ8KHhB7XODggOy2FmBh0E8FzCL2MvjA=", "HkK8KETI8yyji6mh0CnHJQ11ojfq3S1Alp7VZ0/4j6s=", "BemQnZsqhkWXTVT9POPnNPwLmSNqKlkOb8Vk+gDIBtI=", "HiYoK32/k/Oqsle6HhPqrDmrIvyBtyUsB5oZLBE+1/Q=", "ECprPTqQ0fZ+Y5on52AjYS4JbALfZb9kEQuiOTYeNek=", "H41CWzs521CW9Il9Q4OLssx3tO0PHZmnII/bRfqjs9c=", "A9Ei902GlDPhRXgGuC84zZEQOXLkVs7Vyp+8N1SXyjw=", "F5Q8DTM9pdGNCFa0QlU+iCx1r1aE8qgSep1SEjs1DEM=", "HPSEQSSE3wy0njkW2xTWvtUO7pPf390IFIDaIbU4jOE=", "A+QdRmJx5/xjLufgrNLExEaVcXXr6/VUY++eFvSLufU=", "Kr0sH18u4VgIBBkJK5HWSHa7c/mqlNIIJOBkSCePiMY=", "HpeQQ7NeHVeCbI9xkqGGbOGyh3cssmbt29F3s8YYbY4=", "C9rU6S3HllEsTa8np1W1xdxsZmCExkjEu/9l/2YsZnw=", "MF37YoPuu49b74oz4NrSgsqSuolehYU9IQx8yC9Wrts=", "JzI48L87Ap9QZK0b6wEpuVOe3xq4KKTRE/p2UvEv0nM=", "FLErkGiVD5jeFBuks4zdseOYsAk9fhGGUdUYp5gM9ug=", "MBXHjeF8bMuG5Hwe8IaAsSuUi1pW2oo3Hm4uAUfEL1E=", "GYn3v9w2ClcjecFCI/da698EJUpYnJqa6m2A4CDhOiE=", "KmXg6ozA6mnGMcFr0XSCjMeegBQ6UcNajc3cajbn5xc=", "Bxj2iUyNh4mNjbLJ4/5+kkueMSISNfVqEdkcZOTWX6w=", "Jvz4zOtAP0ukQhnCfW5ZW3lPT6mduIEz/hoDHP0ytJg=", "B41cX25fPnvEcESoK6t4qFJ510HF+dXI81ItNNo9i5k=", "CPC16jXmmevGRDKE2jIY5z8g6Mfu+lGWLtjwcG21S90=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "D7bFtotb8/wL+EnBjoE+YQ7uIocWzgH61vBeAFgC01w=", "xgKq5LOc0ahBlfx5W59GUNRbeRr+Q2hokzljD+/7xg==", "EQRVVA04/Jx65/7Oi8/tpWAspygjqBYsxO3yH/VIZ70=", "CzgOl5Xxrl7vJAKcF9PC8bd/Lf0d442E5MlaNEBw7Eg=", "LsrAh2cog2StOrAPEGydRf4QawLmJL2/K9o/knOf8D4=", "F0P4X4d6oSHxqOveZqPO0W4OLGHP6h+J+PBQ2HKSkzI=", "BNDL0dHdCodHTjXRXoYCMzKOZwV8E5jZkh+TDbHDK5c=", "LSK2k+xwrbEjrbMA1prjnM3+aHOvvmb7/tD9EXDw5Jw=", "D8jqjuwHgprUaOGPgEy2hUJaf1ZwLHi/PvnOQk0v9hE=", "D0qi86rTLnCaQHqAr/zpfHUdbRiLbJ7U3RO//m7N7nY=", "BTdIUtImHa3x4UBDaLZ7+DdzmasqQ3GscewMbsUlFQw=", "BJb1RJkuM6TwxSyEBoh2I2VqrT8l74/rD0hZA+lKImA=", "GKmhbm7QRLIEWYIAJb4ak4dHuX2xZlUlgaA3ISenXvk=", "Ci8cARqSHe8LruzaZi0M2WxdVO/MwgiX/2e8GOY1ljY=", "Iq7AB6cuUG+bBwjA3K3WqVphvd6QhJ2foPfWykkAJS0=", "EvFgfub0wRCqpVdf6ZL0fgJN8JVas6mF/1eXx0R9s2w=", "CKDiGuvVKYQAgCrWipbWRDeLWArtnEbLcLw5QIu12WE=", "B3IUvfvsv/7PW/gj7l3OQQSDya9JBtfl46aWbkRpJMA=", "DYpR1ph2jB9i/4efDkeOmPEVf/yIzMI0+DIkSWiax50=", "LKfVRz46emngSNsLfq8cvi0VvZfdYsCIzCIq85ba+Js=", "HbUEwzHTiVp4Z0svaF/KsggUgvsgsWhDq9TDT5HnVMI=", "ImdguCZZkZ1XlbsXGyH5L9+TEEU4HF80HXcqYBjXjyc=", "LG7krx5x8fRqVpQ80aQK523k21RHzmYD6uUlgfgbNc0=", "GPEaa3IYI3Bm3fD3MLEeUkBLZBgCj1kdKwPd6Uv0B9g=", "HHJrxto0gD/EUWi63M+9bQ6Qg4MDtSVr6fPin/X2sqc=", "Iw2pKMWaNpBxZTlswS9RVeM1jbuJGUHjpw0jkYMTJ4U=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "CmlYvkuXG2+3EjKbmR2cKP8VvgweronN1GEM4nosfBI=", "GPt5mD7RBburT//HxsUygIZ25wLV1N7rgqyb866RGMk=", "LPK0Wf2PvuqE/oiggbidsue1AtlNFJEm9qUygx4xdk4=", "Akh50x6w4TxpaNSGo7sB66+/5vtHpn82NNEpQzTYNOU=", "CyEDMC28DHxshu+g/EXM/1RM+J4HN3s3vYGy6EU9lTs=", "Li4fxMVEPi7oRIO7cddTrCxw4Jk8soDg1vbkIHY/t/4=", "Gp4QXVim+Pyn+1BeYkCy+j99hNG98dxdYLrtaDBJtIg=", "KhBCzojtwLc+9MLETBLW2cpBmy+BRMSvhu2N8DefAuQ=", "Dahwd5Gcr+lKuk8jS2+wePk3BLtBVemo1V9MfIuIdSk=", "EN+GrYO0iAC3tm/sCEOSbn2Vjx9p4MLOMwWlqtDWuLo=", "Bcpny9Rk+DDFYzuEzz0XL4isuFJpI1jkvtCltp+hlOc=", "BvH1S1rMGOsJ96xWnFEXegJI6ejp2kCM2n8GgmzxnK0=", "Dtz8tAWvnCEyo5kq7WbA2UXQHvcmiIxlomDzxW8giy0=", "MAlSXz9shkHaqfzhCANr7nvSZedYrSAoEM1SYQEgFSg=", "CUOof0t4bwculje1tY4oCw7xDPdHzxNyn9Tty1wJ124=", "L8/NRkf2JcQvTBKdydeCdxx2ETS+Y9MUAnmWDmteMiM=", "Eq+ksk7oZ7xYvFfS5VGVIVvfwfKdVBsJv48TEdjc23o=", "J3If3lbnDySJZOORhaNa98OORtj4ahYLUI/WO2I0ibA=", "K8dcmGVaNVyO99SLDbNlS7LFefD9zNzunPJ38q+DQHc=", "H0mw1q9LujqdiXZOs/xaY9qVtVlgeuDfIGA0RQ5AGV8=", "AcoSSAwKsYaJbAHswo4KQQFIFLmijeRfoLebkKfMjPk=", "EEC087vu29L/r7pAfCFM3Yq9ZVXLVNWQ8u3qcUXZpIs=", "Ex+bcKJHMDv4QRLazeGam5U/JucnQnncl0tkMxT1HWE=", "ECp4/pYhM3c9zcfjCgD4f886PvE1/k8B+alRe1cuA3k=", "E4mtzIk/tEeOOLPzR3uMI8QTgqoL/+1LilT4yHzMYoU=", "WesH7+6Ylw3TbihXoYPEPW7pVgs8kP5UUVpdvlViGw==", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "L/fMrktq7RbFLVzSsr5E1mlokUlB2Ro8nE041cdv+IE=", "J0BNgVTLQ5l6XWV2+kYQlsmsHYhaFxiLuddBeANpdmE=", "BB8WY549YAyzhZ9wHkbl44uIkn3CDkKQMIlNDSv6Xwc=", "KAy85wpfcZvfMJbOysIBsseWk8E/AdQK8Gt9rjU2hak=", "Cuui6rEfgNZScUTLjxOvry7Jy0xV70JL0A4qxvCcu88=", "EUc+OKUWjDVAQXjgxAs1p7LklYQkZRjFITda9w6Z4ZQ=", "DbmTXqsqVVQAw33PiEyyzPEibE2TGtMWdJP/CicvraQ=", "DZpIHPpu8MXEQceQy4ybMOK+Ct/Scj6lwc8Lli3HpAs=", "Lo/v5ruKORIitlNBvSWwGwLODYi2WklqnFmrryXKC10=", "GdrQxbB4rIY6yrAovt5U5sH12PS4yBchdsz7U3QLsQs=", "Hc3Z+67qcpVeZ1L5IgXojglPxapOm3X6Dhc+BCWpXig=", "ASXrNe1n8DUhkWnef2EsG7PreI43QLkFTsiTUqqy5QY=", "H2Tw9LKAKr2PbseLagYb0zRd3YmJmKuRYKErpV+Zd2A=", "H7kh0vMLE1BNMfQtDLw7PoNxSjc1MkbmQm8qjabSbD0=", "JBQ48J2kPZmReVLJ9gDUej8wt5teyAkk9EJzJtKEq64=", "AspQTs4Q5zFkXQnr5SYUw+D+mWebTiECl4h/RfmfBV0=", "DvkJRmsAwAxNOeE854j84owy63Ph5FdfOWEQzXjGkMo=", "KKoq0x8h8y8biY/QJfap00q9dcvPKWlMw1F4cX24DWk=", "Ln5hmwGnnvJIabuKV/DBZorOfXtyHiUxZ61mHyefZ74=", "EJJYeKIpUdIWxTBoueK40qLUwjXuSDljxo51skY5LZo=", "Jb9xy6oi6T9TPXIRiwThh9IOrzwHyWuGqFfkQ16HDC0=", "LBLJj+f2Y8wgf/t1O5wJndwN4td0dxp8hP2zefuttls=", "KHnUz8bv2E/rDQXRVGlo+Y4Rw4N02z9yt1NBLSzy4/k=", "ITwgXDYqoNQYBICe+l9TqTxMJqydHpHs0IGSL65jRu8=", "GmWy/NXZwNuNrYmKACqcEexAQSN4wQeoqg/3DXQW06o=", "DWrQsoajVbQCYFi5fMapUqbKGuOuI2Qegby3V4MUBfY=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "E7Wq26hbAWRPrp4uVCuOvVADaGvHUTmUIaeYof+sbYQ=", "IHpEyOIETy8uaVPCv0Vo6KvWmCTzAcyiaXImbg4YV3w=", "IDZsYeU9yHGBJdBPZP9wiB0i6Faj9NkiTPhjMUOpVV8=", "B91Ua1ersKXw/HU7ipdSbvNBewannzDlovKDPSBb0ps=", "C7YlG3u87u2ws2bj+xF2dtGjGALTc+EBF8sHyO9KusM=", "DBmw0vySNlBcfHtqSxvqP5H1a1bS1Naw3aK24PQod34=", "AyOFloA0kiUq8zM2Wt3otDuh6mcisL7y2J64shXnpWg=", "EZw5cMw4bW8OOdNR0NHzCMhXw1Rzcxc9ZztyxdVV/JY=", "ATV0wLOTgrJJKAyl6GWThSrUNUFxV/zEp9evI7FCW/M=", "LEHftUczDjzRqzbc0UsrZfbba/8M8/yFjXtFVeGtLIc=", "FRrDhtNZEaJlGZYT3fF9KMytdzM4hxIM1uwEsa5deEQ=", "IULxhNrVTPq1T0lzSm3I6FjN6iogOd/dJhMZ+9jtE5Y=", "IylgWR70rGR8bwK9OM0LTg8mKT6xu+cDYDcUZ23n5O8=", "LTPijzPBGOqoyaUDIuB5amV6zKGCK5yqg2gZlQGld9k=", "EtpTaAGFlzoQGPPI69pUtf29GWorGS8n3U4TvaJTCmw=", "LOoGsn9RrPBgf8NU9kwsNof4a89WFtvp5WOF7V9yRvE=", "Eq6WWOXjMlK7wXYYJOyBMc3dTwBtNU8dy9F8YTP9hOo=", "FQAmUxPq+hPk23K2ZKoGmY99DwhgPztZotQQkmPIZo0=", "Ehy4K5XJRhGJs4tPnRU13rvl5JlU7WhHZ9GR2P/V1hM=", "J5JnKDH1KCvNsTyxbpBJOG4JvBGnTBs0wq46UqPWnco=", "CcSeP94KILGqqODP6mnrlTd62Ge+nfBMEfoj6eVZyj0=", "Ky7ygH002XXbdPkS44X3bv7dVFrd7LdlIJ9TG4LJV98=", "B6dsQwStth6GEdk1Zwjia5iSCgo/xUv36DQenhieNls=", "EXWqseEhUQY4bn1qtujIqxGJhkhVbRNenXedkyvWVOY=", "CViB5yFXoEsOIWhlI+/MMYzYEKLTGvosIKSb+jzsp9o=", "G8JZX561dXIfLMBIGA1qHf05sslDLEKIuJb/JzOKDBU=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "LXJUKgLWCT8imST1d2kFTwyfI0EYfPy0VrJfZZzKYv8=", "KgDSpopBUTGQYED0FthaQpO/4JjvbGytAd60E+3izsg=", "HLAeXNJxBJuwMl62lX0uBP5GxPQ7iJSO3TsPrqW2lSg=", "LoO2d2cyFvMh+svZBpnJ8iwuJikZHHb375m1FEnI92M=", "JXXgSeM9LwnIztTT9mP3chAH3MrV71SvG/BQOlRdeMA=", "J4hdExxTUgZPKx39fszJwetWPYbz0RpJAaTO0IndJTc=", "C+CcoPUMJdpXrDSK88DFFIO6vaLmKyw7VdAPHqtAx8M=", "IOqYC0BgDL42UWh1ARep1A4Vbh52M/9RJXNUTue+NM8=", "A/AhjqZCAugoQJp8ASxHQZ7c9/8cKQJ5LBF/5CdW72Q=", "DmpCsonT339TVfMtzypQdzWgtOa0rS7B2+l2GH9i6t8=", "IkhTw8opxPoibZjE4kl+IQACJcag4JArPYAdhSJgay8=", "DFKVSAaR7nPYCY6VVwp5TP8WxwznQ7uKQt1idxVkhBY=", "FIZFpkIRf2xYcP4kMG+bBAH/odoEkI4aoPa5QjmGuts=", "C+RIo/foktgNGKTzThaRn4VHU2xRe0nKRX/E7JFiozQ=", "K8VzYw+UimaPZGBvkSj48BBcEbCKnc6Jr/OwKgDwpcg=", "JRllABCyuWQkFOMzOLR/HTPOSXbRnx+r+CmNtw3soe4=", "KCXduAPacYgAvu9pqGMPx/O1ggbwbACMmHZ3LVInc28=", "Lywk2mUdgfQD/bTc5Z5koqa/F+g/ViQmpSt5q150Acs=", "A7/e83dE3SP1rJ5H/eEgNXc+t6HGZokPPYEVoMDxdJo=", "LfnZ6dLFTMh9DKyswinVYVZrVrDNAKaLMdxwbj8GNRs=", "FMKbrIIvbZ1FTBHTVSDepyP9ebBhEMgTXheFNhIKC48=", "i2/kFXGRhRrO6YymMgjdoyyb9zyDPdHK8VjpkoR6Wg==", "JaPf5o11E8Gia82ibEEkEqL3roDP2nr7+Za8gc+8zFQ=", "LTwCma+FT8jmT94+DtBMO8VCkic62xA/dL9iPoiWkdI=", "CMwnJy4WaGOP4/heXsdvXuFZUygRKpSSY6/I0UBtPkg=", "Kusr0KjaP8tX9bQo+FD0F5D6aPW1S1BnlK9NsEowodI=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Ee8Eo4I9ctSn4HMRSy5nkeOLW2rtN2IorEogsu6iRNM=", "EBAiBVZT/NPSZZ1qQmlFeOvVGLVzjmzIhBkuEJH1iHg=", "GA8FkT/cD2f1B0yXazziE3r80cGylA65UbjecjOX0DY=", "Key4oAr/i7ZP4t9CIcxXuwzW62sALu8fc1sCMacsfpE=", "FhVgeAV1kdtYENrecNbCHeOngtX6MUMhHaMu2PIsDow=", "Ka+PCUQdwsDhNEq/Y/04un8ISQ9DX8p1omOQtOWbm6E=", "JNi+8kL16pXNI4hE6RNNlRnWaCt0SNQLyfHtiSDrSbs=", "K3a1An6v3XpqOQJmVBbLB+cTlSUhx0hXzsSoKTdfy6A=", "KT3NUkfhFDmAE0sV+e+9ytPncAtu/6qX4XM5dF4ASl8=", "KsahPnmDiKl6XZuFb4+lruUDb9BCL5REdJ87jEueiE0=", "H13GSVK5wbuJLdrnbeghKqFcSVCMt2Ck9XnWCMZl62g=", "DrVYfFxDjbF48nJe/BtznVPSYfUsxDQPZIioJCt0kT0=", "L1j3fEwD6Vkassw4Vn1BJywdzKRzzEvN0KR4PSsHvNo=", "HJCM+OQZdrfWPD9Zzd3Pg8qyJDOHA1HGDkvqIarzc88=", "I1gRhEQMLODzrL1u93jlBPYWLxkw4GaIQXyC2FqD6d0=", "L8pio3jGXm0qCzttiUiejqa/XZXPJ/QLFsWKFfBeDuk=", "I5BRGBLoshrVCkTR6q2WkPGHVB9/+4oP9E41zjsnM8c=", "JGYKBSRVwmLPt4vpCkM0Uzjb2AjEIuiA7taxmnakLZ4=", "DbARyKj235zAFj7sPrpRsjCDfbIBNllBX/sks5WM8Qc=", "G91Fj6LNQK1JuhJwnxvRF7pnY597UqdzLFa5jm31svg=", "Ah/T5msjh2l3SmUOEVnATEfqNkpIFX3wjZDU61OXTBU=", "B1Vu67Evvu2VTT6dxNXaH/rdV41MyvJzrNzAY17cmKo=", "IAofD6TnH7GqHJtFlJGFdp6X0p0RyvExhfqzP6s24Jw=", "F5UzYDLxjh9OOSsDtlvD3SaIE7L5vrvsAFSKGLo3kA8=", "Cz0tfdx1jTIMYe5uqBN/CNLzHz0Vm8kYsProlcQv7bw=", "K/GjlIY4LBF6KGoZq5bXO9qpybRQllGPaUkfFX34XA4=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "ItxcaS2brqD6JoXSwl/FEKQ7r94DFdocUsEIEkvUCw8=", "HJp2OVCkCek2OZfeTjvqoJRLDx/rPZFyOECVhOnI+2g=", "FXYfBZHZm8NUqgvEoRFTz7C1M1mT5OYA1NpO2I+zMZk=", "GTdHNvSw6/fdOuz058u2aaU7Tfuh3dS5UXae5ExR7cA=", "Fha8N+SJsVWaPoE1RPLT9sBaM92KOcZE4Bea7rwnTMg=", "L77VLqVNVqiq5AovFiYrXKsr7k6WTzKsuhYGeEHvXt8=", "HuhamZmTFQCIOURJO68kDrUd6OgBX6vcuepoeXuwNpY=", "K3jqebIzZWB+ghqUe7S6gDXyiCDx3d3xyrp+2uHrKRk=", "DoThHimkuaxBwulT9hzIbTMlQSD0JuIX0uVydCTN2B0=", "LyjJaYepruonXaX2vYahWYZ4TaeXlvMI/pbXsovDsvQ=", "LBTPjIyJXvrNlsUB1UYd9cL5SUkREApMG6pbQPh1Guc=", "DTEauhFo4jUrQ4AVvUmzHZ9coehGCAG75l6/AZd2zhc=", "LR/5r6yiM5xm5kD96W/b4OWG5x15520UWs3RJgZsEZ8=", "HF7CJn21Z+jV8YgImeOt0X5+4MYRYFMgvzL6LTsYQtE=", "AgKQjU8aTr6tesvQn87PEKj+VXQ17PUeMINL8TaCeoM=", "GI03xoJVI3FUdaEOIeQy0hqPkhsyZlzaptyR0xkT2YI=", "DZdrXdvIQJ+2S2XhxfRYvQWP+NeJOG/dWV7vOgZOq8g=", "GSaNFLNMzM2TlHtuxkVbbbru2hypy6gvM9bk5oIGbbY=", "Bo04rsaPkYIT7rFaPV5ls6Ok/5MLWbcz40sLKV9tsbA=", "JM8RchnYI5lNIhDSvCtgWFy/bWZ+r/vHJsK2ij/kZvA=", "EiV3kSExpUf4XHQf/8TVql9uRUUxGaY8MAT2RlHoIcc=", "GZb/am89r60CRad7ogDTneM3HKK+UmSVJlescDJB1Ps=", "HIT2zTw7HQkVNN/5DgTwZ15sbmCqZgw9xDZuqrPd/TM=", "EfIykEQq4EjCYi876D5SqzAmYLxt8xFx8mvUKl81b+c=", "IxG8s2xy0qP4sQPDlYO+MHq5GlsCAlL3yAFeHJrn5Ww=", "ElcHz3aWPWR1pdxcH4MhZgcNrUDqq3DNMbUeg8ytvPw=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "C0uKBVBqBVOH3ZXZXzyRv2odpone1D4fVI9wNklIaYg=", "HQxqyELszUcEXk3bNOBMGTj56Tqni1/iwPRLAMYTGuY=", "COriJAZ4efCDD5ZyQe0IIfQbDiD5zYphIfB6rBDjDMg=", "Bz95aUt1GEdmTNXaMPOAE/KlL8JTClbwGhCQHO+XXNw=", "EpQ4HvviV8Ec5hNt92yubKpMpewZNPGn9dSJXpc5Gl8=", "DIDmhqsJ2jGViPfBeyfbjcYJgcD+uLLdWL6Y/2s/VTw=", "KLRC77daqOaw0nesE2E9WbCZWbOh6QtFf32T+nuuZ2Y=", "MCkEGBzfoZ8zqig49rqDzwIC8iBUhWFV1cEKDVlwBCw=", "Kxfcv2lLbuARZjd2tCIQCYnyV214UEIn1UfbiJrcTck=", "C4n9C19fy5Sj/BVGZDkNfbx6jwKNsGC3pZTyBetVTeY=", "KWQ7CrbNFIv/62utVONL8TzKAOqYxTjZAOlJ+KIj0cA=", "JaxA4S/106tHd5BE2iCjX9HsdH5/mAT5UdPjmU8L5kM=", "IrGdrkdSVPSA1v9lFlT4CObJnPVBhglPWk/LPZyZJSQ=", "HFWRombFrBTxyDhIu+P5vJJsg7ShkDGvAzTaZOvMD1c=", "It/YlHcBiOZcQDkNfvGpB4AKuRYRhTCgwbc2yIWkJkM=", "A85zCH5s8V9MDJ6UwFsUkPWPLMStP8dGu6zj7mE09l8=", "LTkTgbwOxSoiSprdFK8BuHW5/9adwRXjSMHWw8dDzik=", "FWHzUqCWyzKJBsCRphK5q5KkQz9dZfT1XniwLE+EQUs=", "Jd4UbzzE8yts+GlP3YdqHJ8CaeidY9SKiunKBkqyrmQ=", "D0EClMjZGpvMYNJfTHOkeXkTonBn0fZkdx2o0ShKd+k=", "EaUitrJWh+JY3zBJVLuEzrGqqdl3uiku8bpJxlKwM9U=", "DQYTZhecAmCPBraYStU6WtyLHv/GAnWBfnnn6wMfXdE=", "FLRgTQlfN7WXQlTkjX28y2jaVTBuCNAPu7jwa+vxX4s=", "Lw1fVY/URUsGL6M/HlLFplWawTea5QeqsVIQT1EetTs=", "EbMH/9eIFw0ZaFNUeSC5Ftam+2OhXUyrVFLiFfYmdMI=", "LEsCHit1eGO0G87S4apb5+d8FS45YCb7qgnOpRUAHDU=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Ay+64f40UnFjJAPajCqWo1gFwqPofERXyKJRE3vN44M=", "GXNgxHNx6y+CZuBSdiy/Qig92MT/FEYhPBwRdSxsMNE=", "ITrpfqTBDsSmRyDbiBDfNwzj6dhJL2gG4GyHHw3MS6A=", "I+oCfnLnDl2074kxbvOhJ0VPoIK9hLJVdjh4OVzhivM=", "GlIvyZgS/GreKWOFqfZM77q9xZtmTTOwLLHIBUZeC6w=", "KCvdfamWodWMzZ5Hl+F9ajAiRTHz13O0jvI9qlB3KYs=", "J48FH/WjWtmg8eXOmpnJ4bZp9YsSexdLFXPna5qVy2Y=", "FNLUON3V/ZdW9K/pZJwv8sndry5tGtELjcRVCGL3Qkw=", "GNvKSvf0Za1paLx6GDfAPRDQmpTwPD5/0/J2foa+e58=", "Cy9MS7CtjCBH9i0uaxAk2hMViNFphrA+Y+jOnt5sf+A=", "ITFnl7OHB2I5CzGkjoszsxnaXats1KDCgXDu6lj3gg==", "BrP4buaOclgPiUnHzn54m2Ke/uy15xpk0Xyx6PS1chE=", "IaNkIzeP6N3U06xKbe2LZbi6AjWTqZdYq5F8oLZ6Mko=", "H/aNl7TucfIhELA+fp8UZB2OmFE6m3DJ4e/wAP1TcAY=", "Lg0arTuL8hMU/VBtQYzX94iHeJWFooqu10fNrPd2W38=", "FIvUqfbc8Zu9pm9FMetOh2RDxyns4GEvwAXdicgI76Q=", "DBHezXdm9WAejV3AmWA5nipEElS1eqJbs7uAckqFENU=", "ZTlQ+zHBOEIHy18i5q2+k5Lg/Ttvu8nrJfQGRlbltw==", "Bhx75Rjip+fZ/4r1jcrPyz8Emc98Ne0Tkpr/r1fJWBg=", "BjJUbd26V9qTy1WuT9jdAGXsIslGhqY8r7axUdlP76M=", "FFjWQo5su6TfhKRLpqrSqcsNHJBBKDwexSd7KZBBh1A=", "HFgpaz2p9hRgYQoh3/G6gStyapAR8BgOT0V4dPfYuPo=", "EbA53LCvjHlSmPNg3H9VrKIBw1SHsbgc8An+/CBL3MM=", "H828/SBlRz1Jmgdb9YV7rLqUVj8oFFd+VwWgICEd0OY=", "LZ8Cplh0JjO4j+QYXcKbxCl9eqndRzdAGDrkYELfsEA=", "EA6RWpvheafLJcIzKj1ISB3uwu2RliFKVddlMJy8ivU=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "GmGMaNugr+kN8t6eSqMJGuc1grU1VYIryQOTJ0flILc=", "LMFoPVMSAx0GuJcQ8Ds4iQZgBhd8V0zjytsJPn/1owE=", "FuYZf3wQrDWyQywMoQJJs7Oajj64PXAkgv/digiI/gk=", "Ih5L/xVsahUmC0xWUQZPvjs8+PEHIeh+6fcucCF1lJA=", "F86fRlkfuep+V5Sm+maxQ0/sElB95uj7weRHLScQmyg=", "IvzicMSwlhyJ2SMlxSyFFBRh4JlOBBMtYy7hnZxR5VY=", "Fc/t/jCEj6VUMrYud5EQlpikV+zVRp7K7dufCD9mWQ8=", "AzQ+kIjPw3S2G3WtYA3mI2qsxHaeXui5rsnwe9CWn1E=", "Iz1z7SEXmBDMrOEifccvL4yA3bRGhh1ugzopxAhNRLc=", "IMj9IMoe8gw55smUePK96cRtu8CvqMhA7ZPLFT+8C+M=", "Bpaxh9TfCKqoCq8nLRL3I1L2vi5nVo3EW5si34O0xnI=", "JiQurqldQ4MFdKU3jycpl1PHkHE1yTUMwK+jDBhzxCk=", "LbfnTFgoO1XPa+H+Qi+y8lIwIOBFSbfLiIFWlL3AeMo=", "HD22/J8/q42eYtBIyxqCC+p4xDpx8gL3ebiZahVZ2CE=", "FOqoBCraOip9JH1Gt8wBOLn9EkZ0gjlC0gfHxqMw05U=", "B94rYbXXeWxVxsnPSAhWnWHHhnH3SERT0gHSnL5BmqQ=", "HbOKDCYr9j4Kp5KXd6wJFO2oOqskqkfYTmCsT/GL/E0=", "LyxtwMvMJtCR2VA44Eoohvvo9LNopzi+65lSVf/wnfk=", "DMIk1itjVy3ld5k+SCBdCn9XTPMq3Vy+UY5VFjz1QMc=", "DzAcFDgLgi4fAxnNV11j5gPshmbzYbUA0dbChJTDCaY=", "Lly91MFZlVfVllIu+9B4yOL53sp1A/pTPqUjC2Iuepw=", "K3tWEcbotfBf6f0BC9pjs9a+wakN1OTZXaQLtyBQPVM=", "CsgoFVqmYn6/SG1UkbrBPDK2HOy00xeM1HATacJ0AVU=", "GUa+jBHK4h/dF26v0j/WNTUgMaXfJg7cSTyCD+BbAMM=", "GfLfz79t+2WoBR1gzMCHleY/pT46Ss+JuFJZ5vhfADA=", "D+dSqRad/05ALHaoCVY/DYPG4m2e06sqOw5AcO57qk4=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "J1gz1WwQNd4Tg7frZ1nmlxKGr5UPW1uYzrKiqfxS9Fs=", "LALnqH3r61ys1PnHdrWZm4IW8GIeh3IKj2cv/TBRGY8=", "A6b21tu9lXVh4zv/Hn+XzhuLy7l+XjY6WIEM737pGFE=", "EW+o001cZ9KQVV2xJjs00rsM6DqJqBxaC9QRCXbv2jQ=", "HoHS0tBPXMFtuZ/bNA3z6F116cMFtUHS2TP4uAi24HU=", "KEiY9W3N6bhZg6q7UacyRHKVW2JTjIxvvlVAgKhxSXw=", "H/OpCfUB0VQg6e+3+AccD0xVZJ1eD4Gk3g/jG8TmlKk=", "BHvhqfzzvHhFR0tX1E+xIYvekFz6HajAUqlhQoC9nNw=", "KjeHox5WEco4VsyED60rCge7+0FyhZ+m/lJ7fg1bNdk=", "LrO/SzqYx9plUlmZE5PPe4frn0kIxHXwD6z8VXLIhbI=", "JqpfhjzjSY2x9bcclkV8+XIyz/I1NloqEJG2qF/JTW0=", "Gaa8fxSNBWoQ7RYQ9fmyKoJ7qF5RFEwEFEAP9NLpHt8=", "GW9ceHJuKJ7PynotL28qXoL1HfVM1U1M7RYnuefzCnI=", "ERjASNPerQGaJigQlE75/l+gF/Ry1cvo0nt//SBB200=", "THuBD/Pw3tRvLUzzRuIuQCpSnUeTMUo7yF+WOmu0KA==", "LoQyldsETfSrIHpseq4maT83peV2VmPyLGgJ4i+g7SQ=", "F8v56ekBlmcvzw0FMMCgLd9IeZVLzNgvdb/vtIM4Qug=", "J+oIVhyNBZmLU/QoFmygolzszeQ6nKi9J1tPfFN+7hg=", "A0kZhFZBBa+bvnTn0U6W7qWNc8OXJ6iuYWvcy4okUfg=", "KHAREYuSIwB4DVugmHjImMZit9W8yDj92HUBcLZD7q8=", "Ga8bZqXSxuWkw0hWs3paKqGZJUZGHWy2UZD3TXMee4I=", "BDj40aaOBN7RJPNwJ0Mk6dtbNcARSz1eGfvqfYZ+G1w=", "G33yXgLC2IuvsZsvlyWj3awCR0bzC0sCMlGNPUuOnxw=", "L8pj+Vd7P4jOYU/fF0c/fQM70w8QSTH6wk+zh4y74rw=", "GngrHEcyhpAUse+JJiBjYEYO5um3VB9esL6hoO8YTbQ=", "Fry6EVeCkSVnT6Z/SaYqPadCwmOcYsq0PJI2LCnIwYY=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "D6pFak8zSm1k7HRDMwAnwPb9w9AjICnsXgtymeo3IpU=", "Ia4WgCXYcWAVZMuUcStv1w78V6db15T5bglVasn6SZ8=", "Jlmzh9Brh9KLl8WDJtYPio6eIJVpJct3T0+5nLD8e/I=", "BuzWU3OE0/lrz9eUpTscs9SsdXTSPHU+IBhawFZBpRA=", "LEezWXV7aq2vORaFgMoTUmjuQDD4V+gweUCdufYaeog=", "LjxFUbpOob0vO7RvS0EcqGrMw4xUd3hn5rbei2OB5g8=", "GqpC1nd8DMzfbdnEYoz7T5CRyMThmyGNE8XOjUGwJ0c=", "EB1xdezTmM9rXjOUAO0XhmlT/94f1JyvIyeuOeqAXi4=", "BHqsAq1Rxg57AT1+duAhmjM5XUEDxi12QmuX+4pyC9s=", "IVlzTfa6Dr/L20QS9emFhw+DbVXqxyeAV721+gAhOaY=", "EsgKf4C8V4nhfnalMjzG6Hniay7sf3CtwU6RpnnXFfw=", "Czf/g1whqgjPXoIGPvbewt/t3MmH5/4iKni8mCfHl60=", "E2ptAjwpwzsYEgc78M+fthYDrUDd6zyt+PICWYyz99s=", "C9v5ci0q7WPQBZMHYXxHrCaI2dAai7IPSmG5UlLdezI=", "HZDE9MUuTIFX7G7LP+GnCTesjDZRAJNcPsTDWRN9Ro0=", "JdjPupF32Be/4tsIfKf/dPOk75KYbG5c/epXA6/6wjc=", "AwViNIGX8jshI4x3fj1/NmzJ5p55bLIYKBshCsPxoUI=", "LmtbZ6X3RJtCbj/TLv49+Yrwv61QBtY3C1dLQMZFweA=", "Bgxyq4mDH7z9EITNPclKqPaXlFQGcb7mItaDfUGt1EI=", "CUkEfIQszp5CLXecgPoT7PWspYWQhq6cN1nNOwLXR2s=", "CMkDHj+fzI/vYPgugCbbGb27URPHekwG+krz3Xva60U=", "KFCQXODCdeQnR4/7W/RGhd2Vzx9XBWvBkQjWyFw+fNI=", "DHbxn/n1IWjSDLTwzA0QvOk9KLOs1tR56ji4qW+URFU=", "C2b6L50v7acQ3KEUwiyr6vYWxw7Su3k6fqoyjqHKPJk=", "BhmHVM+QvASLZKjpJcQckpiJDJRquiCVMJDgXlXnaMo=", "DGN8q4hkub/4aFkca9FEJIknAqHT5lQDfQYlslgSbGs=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "ITJaWyrpgu4jpMkRsZC2MAWRnRrOVaEBgYOXxzvnL3o=", "BI1ocrhOhg6TTkObBl56Fi1XBbV21PwUxHU12eCL7CM=", "Decl4viK+cI46IDXJecdih15xL5EIf2VKcval2Ri7YE=", "An60sG01KjQE4WJkoPsIU33crCrdB4JIHC53NdfvGAM=", "G0clTjzdRBLgGCnwPnT7/K+fiCt0U1gpQBJ2EQaglVo=", "G0My9LwPR9hyjaxdEv6ZBwpTqw7RRixq3ZukLCMj91U=", "IY0i1fE7Cazonjd81+AtO1K3ShKFBy1iVAhCaG9yiuU=", "BorWmXqc7ScNrKlYE+glJ/fmpNXMSRHH4P3eehoGLQM=", "BnoYe8Hg0XQOvH9zQzl7I1zgA0vW9v2+Q/xQOU7dZc0=", "JtJ9m01QT+sa3FD0C8cXHlbpzHsXCG1orAm9M3q5p1Y=", "BukBr8Xch511730yTHt8jLh3L3lIgp29IpOrAyqc6WI=", "FMjhmZfqe7QTH5dl7Vh0JaL+X5GqT0yRggHnQRC8dSY=", "Jzq+XNmFQTSWGMmTtxksl4+wL8I2vUDcOkpPYdvOlvw=", "BxXTRhNfOxP4SmK3lPLQC8GcqyTTXRaNH5VCnYhW4pY=", "K5vPpt6yUsz2olUOGY8htf4IAP069wMpUASBofRy8XQ=", "I599w4F9900OkxdLFWT7235AELabMq0GGKFpdI5JbJw=", "IZeNSOLZx7CX/U0MtywjiFXDO8eYNO97CEBbG2ols/Y=", "Jpxwwnt1ZMnSSmMf02BNQjhSjiCwEJEpFuLBkn31uVA=", "LFg9yWoKncn576rB3oUyfwB1l6XoEv1WTfnkkLXdj2g=", "Eh5Bh2BuOzOCEGBp4NVt4m3d1FPIHQCWR6nLX0hBgJQ=", "C+6rDGFcSs+xfrn43WR78DkX4RacnDjQ85fBDp2tgO4=", "HgcEmu/TT2Lrm3As3ZPoTk9bwr+IrFg+5Mj381hjjDs=", "BZxkIvDJ003IE5SL/b09UlpQUBIquqclJhsheUpLsD8=", "CtpggnzOMBuzq6PA28GjLRTPVyOrSoWr1IuqN7hbMYo=", "EDcLgvrZ+jiQb8mv09IQN2CyeaWnmAMDmsbXtH+/sIA=", "IrU9Rww3TukPNHfRuzalenzT45MF2/SJXRo432WCiWI=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EhusFE6/cxt+EGMIABUBtaujklZiLcFraDKVnvMtao0=", "LOU4Nmyc7nqRyTJSy5a3xCtOSyamvlfB5USFJOWs83Y=", "Dh6yFNREOoI2hgYtT0T77L48rAUT7DfcaWmiSlwvNOo=", "KxDzqlGQFcufLY4D78PlTYLNqogldg9AhWFY7qdVg94=", "E9zcl6r40j1mZCawCKAr54Vl6khfxbMXXyo208ZYmko=", "HhefWo2M92EYihr386q/0MZYajui2krC5glAZJTYsE0=", "JjUMEHZDWrdhXvkQPb2CJNN4DXIFXFvyZb2PW8RZxc0=", "JWmq0WY/vwxRK+XXVJuFb1BYuNklS6eIq0tn+VdwPdY=", "IdKWBxuxj/xgjUG5KEsl+Z6Jb5C3PEtuvGx+hF3SdWs=", "A0A60uTtutUxCLGds1gLvrV1mJv3Y5OazhC/OsEayUY=", "LoegaOfhDNCieAbk64f8SpCbdWAufvTZtJcy0w+PaLI=", "D+ywEyLM1Cnlr+7p7I84iMUoJSh04J7myCEQvGfhEz0=", "IbGi4hSAyGI/v5/sVc2nmaFS6UHpnQ1kJtJGZuzZp+0=", "AQeHr+UZUfVRxeo95u7MjAitri3rzywK3XpXjbXbZpo=", "Epp1hCzn84D0rc4GmXKgCqBVCEHkGtL0bRZlF3V28FI=", "AzhEoNWYehnmbAFOg9t8kDtqp7r/XK4+xvLn+YcKcQI=", "KvDQASfGgIHdKaXAhY9rsNINDoyMH6UNDVOUNqZrSVA=", "JFK8So3i2x8oLS2AY6tWjRHPAN3QzPsWVSOw5xmbQng=", "BwU1lcT5kgW3m/mFM25FZCJlD0lML3lnDA00JX7GifE=", "G60aUtKSQBsagzXfFUKUQ82NyMXoVuGFuMX50Mm9KiQ=", "JGNbfTrUGlvESjoX2Ap4GDVf+PGDeQBOU0SnsXE6Mbc=", "Lnh2Ep8DpfkHAsyqo149PCcJdWNgQhETmXz9+x7ZJ74=", "H2Ao1Q2KfuZEMgzvlhKAfH74/kAiN1Hb+PeRrFFvqJc=", "B3HJ1G9gLGE6aJqDNNRuDlzR0hSkgx67xTUlqy2A5bw=", "Jp8FL/bfWuYPdsiR35bY5KI+gDccgjSe+WAIjvZLFB4=", "KWFxAECistasUQHLA6KPO8L+ZJuqbvxRAFkgd/Fd42I=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EHQM5nZr1dRe9ToLefaIwMmgdZOJAsZ2zv7IqCw9pTs=", "J/Pby2Csecpe66JsOXHGRgBUOFew16YBmykt9dYITgI=", "IQkxYBQNsqJeShfMdgASPO4iuld5CSbARhC4yV8f0YY=", "CJG+jVYrtv62DHVx82fWBIw7CDsq2wl6J+YuM2yyekc=", "L/sX1nSVj8t6jaLThVS8VXHG7+vHfolRRoghLGjVCh8=", "lMaIKM12nJQLJ/ZF26GSLSaJjGT+9V1WOP1uHTV7dQ==", "DVXLzzXrSypByrmVvRuQVx5Kh2d6kOYnk/YHM0PnmPA=", "GOkbw+CV+baH/mbP27+MI0wnrzF/E/wncH0nHocecGE=", "7AYS8pvDLYn3P38JJv4LPzWH3X7tScdys67yxdQQGQ==", "DM9TEQma7MgaNLVnmZ60xmPZB6i/SyLC8qtjoySsNFE=", "GD/75iKQDt+baoAhq4DbAGdvYZ28FzLcyPrWcSh3LSY=", "CPQzGu/ij7bwCeF/9jLbNQWxj/qmHGsNNB/gtjh84r8=", "Cet/M0mHBNuN/xyHd/9TnR3tK9IH+uS7dGXDdbh0cWE=", "ClMRmYMNcSABizA5x6+poITVKdkw+GXDj63NxAuwCOU=", "GUs88o17YkE/m4N7aHu7SARzPI4XTna+2Eb5IGjAZvE=", "G4YE4UhqNevo5rkAEn0Nu1Tciqypek6wyJVncwNfPvY=", "CbjeNnZto0HH4LgQpTkDviKHmRK3B+Hz91Lm8Hmt51w=", "GkNeuSDSuE/jwLgDyiz4Wmch0x8hd4cG1Kh6kjrQrDU=", "JWbZ6JPCr9iS9HAqzLy7l5x8zrmA0jTeVJo8bDS9r1k=", "GN+CcrA0BVfKj6mNxudcbXiEhHAtOJ8T+4K7Cd1e2xk=", "ILGD9yk8aMwjJPAaJpPT7azwwoaRaFUgy2wf958luyk=", "Eox6JiShvJIJPrq36lPg1dU7BZ4hAEsZyw0rs9unTzE=", "QCh8EbWj+YDVnsBttGxvo7VOnU/g9HTKFaeq0a0OwQ==", "Idf6QrxWtS1VfjSwkVGNamlFlSB6CZxxi4e28hb/zX8=", "Fp3CeWURAXw+Tr775X1vkxlKd1E/2oTvdFevutqKXVg=", "HXStcyodyAS5WE5VepwYwLSXIA4NJzEr0kMmkUcFZsw=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KsqOJRlk0aMmH5jsg8sX1hHRf1dYrrizSoEhEh9+7Gc=", "EuKE9D3Xap8XUdETNdQ1FO+WP/3yA2Fxzf1PR8metbM=", "BQceGDkvrKvqsKOf6jbDk1cumAc+GDMNnEx+ZUVyBl4=", "Jg10VchHClyly3pjw5sNH8yj6xAp0plMXywZo5CG6uc=", "HPhYTjdnexn7egVEZEjVUP5ypPx5yS6T51dvEB3QUJk=", "LRnbordlit9g2IQOnHsRX8N1AxmDNckFBHDKPAmMr84=", "DZjqGtchFs6jLalsdFZb2ykrb2JnHFzJ3gkE4ayKORg=", "JKwCEyCqHxrd7mVdT+r1N+RwkVR0ooWrEbgP0WaiDPA=", "IW/rYwafaUe+spShxyQLIC0TKulF98uBNooseSI9ETE=", "Ag7MqD7lFW5gknY9eJc4Wdq1y/Q4tngvTUcn8H55Ubs=", "HmMqQvwyYDbB8zE/NygDz4kS12KzAmy0uGj/vsRk2jg=", "LmUtVJQa8U2QtDR1Kdboc04YT0jFgnNz416WoEQdVrE=", "JR/1Mb76qvxpM+GV5jJ6hT5w95VuoW+ZuudM5wPhPu4=", "EqxHrLm3EleCB+QpuYngF+AQ4vjlE+X9yg1dcM9pz6I=", "DMzxfg1huEE6xmcwPTGyflu9vi3k+3knL9JqlqYDPAA=", "IPIGCinqWK4RrtYeNx7q7fjEn30tMQog2qSwh0KpwZU=", "HLnw1o3TwUYQ/2kEAKwVaw+I3bNJaEKoKXa+yHjB/NA=", "HnX9VAYehmD7gqbyTKOFWA03wX/HMey2eq6G3cvSw2M=", "LSnrxPgHdBxpdXAKrDTdAoV7nKPziaNNKBruJp6VCdo=", "GHHPcXEfQDagEE8HUG4iEcQO1EMnx+Gay8JAA0Xre78=", "BjC36kCsagQJWecZMzlaQUp475k/A9IwYjOwqv/kqBQ=", "Hqh6wRLWDyKWHVstomwKBr1Nwec3iKOIyjvudyzHjn8=", "JqemwkXanPUw+HybIO2GrzaQh73gBLttw+7osyiCx88=", "Gt9aAoziuKB4fspD689Cfc57t7OsGf4KjAtwFq+yXmw=", "BeLjNIyfsJDmKKpAEB24tPRrat/H0x+oLh9sn+W1Wh0=", "CB2HvC4U8YW5wZ9M7Ej6UB2ZxworyIHM1uxPbmd3Iao=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Knq1B5Bq3LZSLAQ6Gyyy8iHlRwgi8EgiC6cxs5M/MhI=", "HgeR7AyDzR86AAf/An3VifsIZsYlfBgdKTz7cLYqvlk=", "Ga1i2nxdh2bvkn7dD3+9mX0ObGVVpsOP2+5/UpmybYw=", "HPUY0oLgCxiU+GxCzKopLdIIvQ01duzRyxxF1Cb2YMw=", "CG5cZo8sdUDmWjebuXOEFuH0PgtBYZzcBAwyGqidt8c=", "K81pSmg/tiFgHypfD5APa6sfQpHWW7jCZTcClISzhJY=", "K28KZbreCtsj786cbjYpoHzvyicYs5SQKTYsbaS666o=", "ErJfSfsc2S2n/h/f288KsdcV7pKufiwLKmC49BBqu/0=", "B5fHqGO6gaoqzGIOCJrAr+L3E+Rv5NUszGN5U6SsLwI=", "ETFmEHcnsszZ4r3mKFhgyRKjGP88vhzKAGlz9EQjjxc=", "Kdi+q4p5MSO9tH471W1uDW5MnZV7ONasfKfVOjD9yUw=", "Bo+ZvSaewrzKMKXAWv1RNv62OjMV4F2tsqytPKrRx7A=", "HYoulfUBK5dE0z49uEJTJheX+t2keuCO69NJdTUR00I=", "Jqbfy/zSqY+hR70LGPPk9m4fGjKaFo46YTNuTaO7j4A=", "HVvbFbvP0hXYyqZl6Wh8LYrdC1HPVMUibtm4mGb3Z8U=", "K+pFe1aPwprBoj/0Miyu1UY6nNZIdp6KGhGKroTfEwk=", "Hb50Ge5Z3VgKCrQwVEClf7ZRgw+Xn40hZW/yixWQzk0=", "F6sdVdqP8XORuodMS25Sx339MWoM2VZtHijF3JMI0wk=", "BKOg0PnhsJG90zas0RfE7enWRiHGsupPB3JuBl8X4ss=", "JjStTpHR9j2m4lNMEWGr7GYNkjce2F6PDjmqkVI7nmA=", "Gv7JaAYKEGl6OIm/NFaiOk6Yw3gdDuiOKTNLFM92FME=", "I6X9I+yJGdYhdv85VPmDV31eqCHO5pU4fwlsf7uTgI8=", "KDA5xH2rNgcSmVBZIuvCFIIpX5VjLRfEn7jwfjgmQf8=", "GgCEvBs+lRrrPcY4hwj467UiR1J6OTIJZk1DoYEuEw==", "Fv36VA8mm0DydpZhDKwG+qfrp9h1Qt+kLSjT9FOnBiI=", "Bji60o/IQnwjSdKTCwhjG+CVvwwDVyEx86gTLzj0wKg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "K5YLSqa9tZaP0nEG7ZJjmb9Aye96CrzjgVgZEVbZS0c=", "Ie4v/TIHNyFbo5nZH1KHtWKG5fKGRBsp5/SVDyoQjYI=", "GpEq+KOoKslEvDQ5CtevcD0eSo8ymW6g7KIDcJvVJsQ=", "Hi13/knRKpGdjuCwvcFUdfnT1d2oMbCYqSHvhUdUKrI=", "HkYbC/plg4wxtm6Jc/0VMwivRuZWPlI7TJe60wTOa84=", "EiKxu6WGwyRYHd3lUFQxXqN4dUQWt7dEBqRNkEaIOdM=", "Ixy5DTAabm4/bEegej8mLxQ3C9pamESkwSgHa1/d6Kw=", "Dj5m5UP7WSkKjVf1/aQ8S3SyNeAK3x4UQIWdjyUv3hk=", "G8rjrLUt5h8vkH9vwWwUIBbgU2QMitm047rs/5eywT0=", "Ki5+KG+Q41VKyW7Y+AJno72fdH14f7JTO7mPRlkx9yQ=", "FynnsGrCbGJNxcbMbXYflNk4dcoXDNV/h8/5CekiIj0=", "CVZbPsbmNAG80V0S8S2MgF7FyJNsIiPKTdUQpXr7EsE=", "Gt4Poo7hPfTTgqUFs4k7r1tFaLzOcSG11I0pVn2hOp4=", "IwHcahI2QgwFGq8WoJXneqiPI/Y8swtBCjI7p38h9/A=", "FYxqAfsB9UL33ZPd8roXcdcmz6p8ObpSYKX2u7zjud4=", "J1e57sTLJ9TkJ0zKbgAony0S6YdGXCZ7H6EEsCkyqEs=", "MEPYsM2sJbCErqt0dXZjJsz9FXWIcKS0eoeD9z9eTzY=", "Ghc5/v5kiMecbDKBj/YqZa/e+53GKiO8s9RkKMrlzYg=", "BW+Rz54kRNDUd8E8mUOI2IotjhuI1ggLWkFaUxF2Q8o=", "KMj0LKkwNsciZFHueuDBp7h7DFYN57ETUNx/dOSuUeY=", "GNy1QDFaQ4cvwkb+P2d5ojfGHvVSfoekALJLPtoFhGk=", "G6N09w3mBHP2D7dFLULFn0dI3r3TRa/c+U0JMFtgGj0=", "G0CvbC4Qb9R1a1SIN9ZLz22/udk4Dhpw4BB2nvwigbo=", "JXj0puPbvyzMXhg3tAODJ5Jc/9APlujS/axnfysPqj0=", "LqU+xPL4kA0532iFPyrp6WmBnTO75quWhuEYXDeTNmA=", "HLfNcHqFHXZLfD0tpUSvpZy4f2rhmXHu9/QDNCwgWuo=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Br2MOXseLY47DTLvJZSjEdSaJZVnrkxjVYLenNFWib8=", "KRrbaUSJLavPUhcUX/dzYYFeWGAOpiSLDABpgCVX3a0=", "CWR3hz5W5WkRcWMeTrdMfS+bKAa08ORVCCIHOVh6iQ4=", "H/T27YvkPgea2EnQP/MUf9ax/A24wbhHfWXAltSyWkg=", "CeXkBW5VRk2dXm7N9xJ2Z95BGnFuiAFIYdVDbP/qvLc=", "CnOwSV0XT+FRheS8AQpUVAJzZ1JYUoggDqWSLF+NKaY=", "EI4CeVVuKPBMVXCmJ00RXUs7G//X+8wonOuucFP0BCc=", "INl0Udg67PtcD2ze1Cfd1RetpyneFg1OviQp26nSilM=", "LYp3Ak2h9jOuUqbPF4mMW5CPUK5J/b5ltGYoUzN8yRk=", "EFcf+SNS1Oad8Fw83GXA5SdH4D+GR2hQpH8JK8JysmM=", "GPfK2hxmHl+PIHTxbnK6qnBcLOQraOFv201pRaMwVOg=", "B4b/M3RQ02FPx1xNMUphOVtxRz5zUzLXinrrJwRDy5M=", "DO/oj2DLmjgtXu3tnnusrBXnyQberTXOwJ7m5tABaz0=", "DxY6IBKySE4d42tZkeWasP/UpTFXT2xyOC/pJXbOgug=", "Bj3E8H2fBp0Gow58WpaDDScxyoFlq9ntidGHdT8pxoI=", "Bxoyk0c8Hc0MzVoI3sajISZayI2sU+6lgSZGY+Hf8Nc=", "BBuNKgVvYNjTzl43gKNBuXWSkgsXBiXBpp8qI+EpAmg=", "Le3dZ3UwiqAns0STV/irtqbRDhHMOhTQ/v8j46hZf/Q=", "CsBQ9UU0AVyBCGOmO3NUo1/lInnOS3oUK0j1UCcCpPk=", "IVvKeuSDLFlG+a1Uq8Cz58VH+KWpYuTfhdC4Lc6RR5k=", "HvyyfTwJj1dOf9eZ4qWFzPVKWRR0AM4AyG2grgzpBoQ=", "JN3GrZpIhW2jYwB6GSPREGr/qInkT/p5Wb9B7bo4Lvs=", "LvjkHyiapMZCRFVEE+tRW5dZprXtniVi0aZ0JnFxZQw=", "LxwhnE0nI4DrQR2375P25pLsozn6UHtlbg1TKAHA4gU=", "BfGMg9NGRIipAYITnDEudTpgykSZ48LBP3wucvv0c5U=", "AXkWXsDRdXWPVxcvWp99HObkNaShNR13E5uSxuvshto=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EcIIoEleDnw+Rz+Y3R6MYbJ7RN6I2ueFASJCHNp8++E=", "KX+V8vvUVlNgcSpxvzyAt5ixffrGxU2ITZnzqn1nPcg=", "Ikzu/PMtdGAQ2AaeedNW1pZx46qUA/OYkuWIKhiR5xg=", "JzKyMAHEPGLEWc8KH0h5De7b3EiaY3IThZSlp05fhe8=", "DP/lnb7PIYA9eJxitn+UuwJ95XGpY74inFTISrEG+fE=", "Kbj+tKmjWF7DdgY8/44PWkKS8396S3sf8ijwP1+sBRA=", "JqDA5gov+hC+fWssh4MS3nTMQ/zH+eukngX8/Ko6i5A=", "LlcGVttB4viMPePAnWi6unJ+duNRHdTRKRRD2ymqX3A=", "ErtY5GciAO8oFqgjffzfcKn7B7LdyHibdI0LVZt8u3g=", "IW42nIr61Z4V6I4//fux4TfpsxR4VjKtLHyBurAad90=", "InnjnXkhuOBLbzZQMFmxvy7XmjuU8Vr5e5cgv/hawlo=", "BgVkgToM5i5KwhqFujb+NZtT6EJE+Qi4ZlaAhOMcSv0=", "ImikBWMdrmDo6sT0CPvVJotAscJUlw48IuqyL7jsxVQ=", "MAJj99iiVnSWo3q5TFfiAVRCJXwGLsrZ2EEvbG3cAIk=", "GWO8eqA6FS3x61GM2ViL0E8/0hoxgxT+DlTB82m+PA4=", "E2tnwreOKKnFJ2xv7dmvrShtNEcA+sho3lVIxASr7pU=", "KaMp9KlMbGyfyB6M2Q9/HJ5fbImHWigN2eoLS5C4rS8=", "DD2SrsS2R8sh5vDruY7zxlw0UGcs5GlPSfOZGc5tod8=", "AvUjXOtZEoaZNoEfhBw+4PZIuvye3ry6Sq0BaNA/m1I=", "Bjp2BgnySzaS0gXJs76/4IjCFYd96Ned6qhN/4Orsss=", "GWU2BzCqovtiHEcOkELPXbKMSCRXXJlLJVySsC0LZSQ=", "GDjktZbcdZ1ql7C3Y9lZvf/EuhD4SrSxxMcdUKkk0Xk=", "JYzwm92kMfrNVbYqplcSJIBW4+3ZQosBCoCex4xBrIY=", "Hlh+UjKfCim/PbczdEJpBCKpci4ijexoK+Od8os78Uo=", "Eg7/4wUCBbPtHAaqGGvKy+hgth53vQa5tx54pxCglQA=", "GCE9xhmrko9o1arCjfkj+QKCtuxk1aw3aIDTH6O8HVo=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "HwL34uB4Q6iLyqJ5fZHt+Iy9cK10PpOONTlmKP/4GMU=", "DcWoXZXxBdjksY7e1pfGKgMhNjdCluqbFPVMsOytue4=", "IZtg5tWiJXh3XoP0R0IGVZIEAlkTI4qY/gkpfmxHPI8=", "BDVTDgFNsR4r/NWDYpgtijPiIng6W9bbVrvTJ8xSN9c=", "KMH/xcEGAMDcncPRk7xYVSsjWSK99GFhtvjEy1ps6l8=", "G/ei9781jNEjAlgqOwJgCZT84VT//CGK5kQrtGAm+Yo=", "F51D+4cXDT2X9KAWbRZj2nhmTTKMrbVE2/XWxdYR3pk=", "CMq/X32KbUWLtldnVPulpxaunkhKZoIXrc7TKWt8zME=", "F3vh6s8i+RZBeihlHhjTeetE5cIADjKcHTyN9RbBGU4=", "Cl+uDwn4XVq2sigzlH2my6DaoqlnGt5JS3+dg2c5SYc=", "KN+HtD55WzcHYvHT+dwmhekbu3poVKzBUvcFyJ20k40=", "BY3iwP6ObwnxuFPayOqkc+T2+A/CDg9BkIddlMrabsw=", "G6ZXzSvbl+XSS9rf5cwRp1Q/VMGOZQOcDmFuE43l42g=", "DqWzpBFs5K1h4yz7+WYqYMVCqsFgFtVRFJx2cA7MRPc=", "LCGdOisOQzwf8kPbJ6I3/hXHM+3w8AhNelukASP7c2E=", "Ga2XSiKFy9FNBARcZBTxmaiRUkt5jPHj1pK3Qs1tifY=", "LH2clE15LOS3U1IHiROGtyJFjFT71ie6OVIaucvB68c=", "LnGjpFFWb4kZon7bg2R2UlILxbkgUx/NyyhZpex3v3M=", "BqSxtTDMXmToTnJWKZUL12RPZeciPf1JhhYd5TXO6Ds=", "D1UELApytbYtIQcVO2BIKYG9oRkLyLjOTjCtEB+sdGQ=", "IDeNx2htZLNbhEQEk8oQpYelUFFp04D8XF9KnugD/BE=", "JsUm+FkXCRU4K2VZKqGVfnPzFFyXDNfIkdyGt9PNQbM=", "GUxOWrchSHcxet/SFvNDEOW8B9oTtnE53sCMwlvyoFI=", "KeDWRgY+J8+vDk/8BUbxswkzOVjg7Ko2Mrufvc0DiKo=", "EhtEUQFLY4IgmhO7D9JyflnwcCoIH9NOBMjd64fTSf0=", "MBjqhD0/P1Jbn5a2xsB+XIbUoRPRg89mFBqoCWAEjvc=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "JqiJBlqRMe6FQVhyhvJ7irl40QbPIefLpWeDnrg89cc=", "EvIyKTjgL5YiflORUnGab6YhR8+Ck3oMmA6wEcYrAdY=", "KnBSoiCqJYKE2Lyx4GRsAmY0kETKPBe9C7Yo7FQip1s=", "HgHYJb1g12ogQLXeXkO5DRv7sIdtq/VQuqOl3UetYtc=", "MAL/ZWAABCDQ3pjofTNUMr5KWP8+6gU9LTMjVMvCLak=", "A9KHNqKVLjlvLeKPOlZ5AgJyFHBmV3c0MdVM0QwKBGQ=", "J3FtW9PhS2GvuNa6kbJ3OfkHX/JjCxnGwsJsXVSW4ZU=", "E83nr7ROD5ttsnk6USJuQK7p1ef8de18Zj/C0G6bhSY=", "BQOq6JgBu/xfcC9g/6VmR3pjTcF6/4+XR9H9H7s80zY=", "HqkQpdo7qNijmTCzi2T/znYW/JyLx/wf3PErZQ0ECJw=", "DrH/VpoyXhI+3nV+olDfX0H3XdK3XGUyq5bf5kz38+I=", "FswXUsV1zphHKSCOeXFMM2vDIk+VH9bNC4KirE1D+JI=", "JlM3h0PS7qOHwzCjdbuA5nh4qXQPwkJaNjFSBqFAF1o=", "F1sU4705PYJf+VYNxO5YNMab6s61+FgBVu8WLG02Nps=", "Fitl7/WbO8OaLdySPHfaehff55t1V7g4M2eSL92KpeY=", "KX2XlhAd+RUgQyl8eA3VE35rstmiWo+pIYe13iOZr/w=", "KS2xQ4zkvO01BI+hKwSb+jWXCbyn3DFMk38FFGefDSQ=", "GcJxXofDMq281TDOmB2HBPCiB+gi8ZC6q0IdTQPSS9k=", "E5vy4SG2aU93Olj3CVbLeCo35JSeSC2H3IILA0/9Dyg=", "KB4GoqPpx60pJlsu+MH0gUrcWeWztgWgXDzOilnjIdM=", "C6pBgdv/kvgzhulcbK4MjvoH8M1ugivTdp5K6MZOfZ8=", "IojNCGWchW5pfZNVgZfRbAP6xZAJbt5o6VljbQmVbZ8=", "KvhrOzyvs6zkKgy6XJncznsPw1MTsu3d8EAbwCk3PB0=", "FzgG/ksFErcVy348yGedOnpMK3F06M1xBXSzwUK4GX0=", "JbZtpjeo2S8IjY+uzwNKt34rLD+I/OXFYJIvZI7vlg0=", "EvWSK5WtNrx6gcL+j/xyk0K9OusVVZaVkL8iSNcKPpE=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "FwvPApSuQFnZXzZoSrtPws0DaaZ75LuRn+GFqjlGdWk=", "F9JHmD+67K/TnJ27H8JjPufM8CODl4q+i7oF579JgUQ=", "J1x0ulnWjr140C6nv8CHsXcIVEQ2u1Q4tBsFMHLfSDY=", "C5ehlhlUMO9pzyPf0JBmU+WAjDWTRJv1jDdCQu+CvcY=", "Jb9iG+f+BBBeilCwLtkCWECv/ea7O73Qbfl/L+ngLjg=", "KWkouqg8EBbq2G5ckBGxNNXSQXmxlw5o3Il5S3PQJNA=", "I+b8O4YXtrUfNdmDxHCplUYJmmNh7hYm5uROXj4vfbw=", "G5tX9Ff2hdVOf38zKvQjPSkxBvVqwJOgfCCSBSFxCLY=", "KQ8KxxKYfXlW6LTb3YtnBjma3OlQbjNz0inUVgVjcxE=", "Jio7azmGwlDTh/y3NM2RT16Lt1G1cfrR/zZqR54+ZTg=", "KVuIrFD+5JJFv9m9kRc0MkyNAKvqcYkXpNxsIbPlB94=", "LnpolDMM5tZHggZhmv+In7G73OyA5vCd5pOY80Sk9uE=", "DDvxuy7pRImv7TYzuOwS26pLaiAD6sgOfxZo/zQLvvw=", "LWFinSAzF+pESeIAiAvi7YQhqm8t5zqqVoEPwwTuquU=", "HZSuyNln6rzuo95Ky9LDsZ/uACEtLezljVrlO/5gN7Y=", "L3bXL9WXIsN34xVYP5GzJup5KWj75r9zWCqvevaX09w=", "DSQ9pznpBfiwAJElGTed46O61t48Oq+Rz9ePlzWwwb0=", "Cs/fX2nAlQbLhRmerNugubPFoPoaYM8oOHf/fvrzvPc=", "BE3kdocZYYlHOxJeqR7BzrFIH49J/NR77O8bAfTJ/gk=", "J+FV3qWhE0RmqOK6WOKwPK2MOMIHFqfT54xIOwGeebA=", "KGCsUfPnAUhWHVwQmr2wliJar5t7vBe9eqMa0m4kPnU=", "GjPgVK5FkWlR9zgmubrcAy7T0PPCGsx90Y1G8mjNKoY=", "Ajess2CNkVhzi2s3tvayh1MdloO74WtGPJRrdSwImrg=", "CTKJZgNtlezTRfd9yYQ5HQlzKs9WfQELhV4EIjZcYgk=", "BqQf/Zch7wGNfp4tZ7jZgg1qgL5AHhYX4Hsps8X45To=", "G6w7O5zUDsQbVCtH/w29oDmX+Io3qiPeadDVET5bRI4=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "F97bUmQdn55oimc5gL9HxGI0bR1nMdtrvwwnzLJWUXM=", "DZR5SfNedcKamG7WYs8eHYXC4/OpSJ2m16amVzvzvf8=", "K9sgqDJ+o/UJ7qH4GGWsNPfnxdxD1RYpSinCCM0LrH4=", "L+yxcIc3MdBwzOxtiHM74ydeW+IqR80pStckfNdSR/Y=", "EYPJgfgVw1EZ/kVYoK6p9TP515gBldltdagMsf7UDAI=", "BfoyCrXa42X4oRTRCSGl+hP3n0Txi1cCGkg+7cLFu6g=", "K5UVEq3SxwigENHKWb7RZvNybK5csVJd03kVbYEObCw=", "EfZGUUiBEnyfEGcjjAanyjm5waAjTrG4ZYwrxwQEV48=", "ByQT6UrKJ47uuspjx5QbVIFHOH0hV4+X5Y7CcZj9Tlg=", "Kqzozvwb5NQXUAGuvr6R/IekaigL4KkIhjg/8tVh17c=", "aeZCMDQ9msPGEwswDPokzsYIbIWhqhyO3Qc6fTOtsg==", "HOhIKeTmfNn9O8yNEWmhXHMeBrp2x3rWDoSwRdXXMao=", "I7UqETrE6pCoMwwYmmP+lSDy1z25RAar6nIVDqK36g4=", "FgIY8rfi0iZTs8oSGQ9VOFY66yetisjy9xlDu9sMWSg=", "CEwah+f+1qqcgPRV3RMuBviX9DtrwS8/X/VqQpfqoVM=", "DOy6ZT//N6tfsmauZUwjssq4Ow97qSxwageLTeMiGtw=", "LvgNXhWrprJlL+9+BBkWf4BPLPcTIA7s8waCzROHgdE=", "FL2TCnf+9M331HvLRu5vpZbEPp3UC6h6SIxhPVloy1g=", "HO0FBZTLAuQ6l89BJqXerSEhfptd7Cj/2AOjga2m28A=", "Lv2754HMIrOf3EivNCSjVMSM6xcRMTbseUqbMxn8lCk=", "IHDk4EZxYBzNCELLejdP8rk4OK+GrkZPgs6uLxU5wdg=", "EjdB5/Y+d/o+LYq9nyIrI9u6HBTor1M4XK1WWU8GXh4=", "G3UDXDWyAe/FWh1HqtqJdvX7DcHaIkgqa2HTPVVezrY=", "Jddtq8kZ70Dr5ZfUuuQ/29IZfpsPe33ag6E2ApXp/PY=", "Bma1nJrWZu0/ydHpr5f896uUujOHVz2NMfAwhPnlyXY=", "BlT5l5VUPu/G4bHmRhCIlupRYcnJpeF08uHLkJOAm0w=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KkmEUYz00DqbNZi9wlRIShgFFgYSuUP/e1CWN/EqcMw=", "A2cxor3Khv4BHde95AQ/icpJIIQWWu+mrZ90cX7VRTY=", "D1/E0eZ5kuZavN4ZTwfLB7coAKT0om5QIOlsXUrjqVI=", "INAslmmUKi/aDeeme4xc/KCLLpFPZWUqcQRKyaCRkL4=", "ILPHhcIHLBAW3DFqeTOtVB//p98tKJsyeZ4QbcT5wbQ=", "EAfffMyYlRqueCuHmFdWeEoURFMUkmFTFQgOLICjMTE=", "IjoQmXlXsSgWEQBJrHtW1VDNelwLR768H4s1FnGJsto=", "A1hjIYbaT/8XZdTWiMz0JcMzmVvXQ4JAvgzOFChxcnA=", "IWsfiL8Up4HJmtejlHgRgtQBYv3aqDkZF6ykZTgr4Dk=", "EIRBNooFijDFZawB1BRQVtWlYUiSh5hEwHocAomyySg=", "A98aQS6wLRe8yCCI9Gy1937GJ5/3FhhWxSSA0AVUo2Y=", "As8tnwgNEhni3T182hRCsXhGSlgyYObZYy4SgSsIw4s=", "D/j1+NI5ya/GydBB/wgF7iLD7zz1JI+iqxmKMDWX2C8=", "IrruapAl+WHZWvsSL+UM5z0KzZqRPy/I0HoFD03mXdI=", "ETHpQvw2KWJH6dkBPnHMiUmKcJCmg78IvdI+JnNA/h4=", "Csahw5T5KXJaywobXhGtniiqHHnaJWJFlkUbBGRdinY=", "A8yAumjYnNzJNbDYctd1s7jyoM1Q34ntvDpiaSkNaVA=", "HbUTwvKa5FSpm/ko/8LZP7w2PQu2zQvNkxBtG/5feJo=", "DQXa4qSx7DWF+Y2EvufRBxfaOxenEoFnLjRRkWJgowE=", "KtzUxvGRzNvNWpi9xgULqVAJ4gOd5/D9m77s8MTx7O8=", "BNDVcI4dh8pp601ENQMTcw2dhAOAFgbe828DUYOuA+M=", "ERhN+hracRjnn4iQA2+s3UcAG3tjt0w9KYP87s8+yuU=", "DTL4uXXpOffvoJfCo9TO6DQN6uMBJ1jjs6TuCi/Rk7Q=", "GiTpFiBJiVvbpJ9XzuA5bkc0vKtg2OxDBaW2hbPKZu0=", "GYc5mOv95KWF80pApuH6cCt/vSmwmqFBxah45Ejkjio=", "LQVbKErj4inL4NSQHOa2h+70DYFdo4zedD84Ucd0+8U=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "MB0r2UoqhaPIAtBGfBz7KOKu5UfS99UcKvEIpUlGKiM=", "Ge9v+UE/egWvY/Uop/gNrDK7P+YB4CyhX+uZ+RqETQw=", "Dxy13Y6li1I9Pp2d4DDqnbkyt3Dtl9J1XaIqFRJpbrs=", "FR7C7eytQdKkp06LCXSKw9Eaz/nIqCXg8MU5N2MT/I4=", "C/YFFUxubPynZFkAk7CezsLjigQm1Pjw9vnOdx1Mz80=", "ENHCtPNiIZXM2bxkq3MUWQfnNY2SvrhYJncNF0gQz1Y=", "B5wBkRSZFxqCBZYG8aDhaD6y8HakpyMU5RkkthJZ+3k=", "GIYJV4Knxqv5+vZUkIDCpy+Ozswiv1gHPfkL5pIEc9w=", "JhxAgfE+26eVSIyQbforWZF6/7RM7fFyfLJ9oLCywgo=", "LP3H/8Ngnp2Cs70fLx1C4V0eC36yRxkSPgtn0GCADco=", "A8nOccAOJDqVDf8NngpdPEL4I5g/bB09UODeGCKZPYQ=", "E3FKsQ+7xU4V+l/w1ryphG/JQKnGvdh7BEhoYA+Ju+4=", "E01IOLjHfnJwRgc5+0ROYFgOlR2RSlogSTorA9KUiQo=", "Hm9T7tf4b3KRQ2YkhH72RRRXdWohPBaMO9ellFpPKHM=", "CMTpgVZSchxSkyNd7B6ul/uPk6xI2Gw3rWrfp3BVZlw=", "GNAHESrJIF0W/yCbgM8LUmA4fOdw1OaXjt7p4AA/q+w=", "BRQOj10n1ySKPlDoTGv3APoxwaGnrBRDkPS8/1rWEkM=", "GfFT1m5ExmKvAm2+W+m+g0oQo9/q5ZcpVV1wnWHjj3w=", "EeApmsPz7T7nE3fc47hXaM0qa2Xp076iR0PRUOGflDw=", "GQq36e2MdB1U/FWK/JazXZMZ0xf/bWMyrkyneoo6eRE=", "Bb+PxK0BJtQsIu0sZZtm8FPKNgTwloUgzlx+8Gxah5M=", "KMBSANttUd8Q2KSYbLZcB4AB8pU0PeYI1o+uRcq9xfA=", "HWTQ1BQ/hpBW7LECajYbSN1RYvOL7vrRptE5hD09rJo=", "BWhpOJMwIkBksp+Vjzf+kPwrtNwkVEJbDTYriSvg+3M=", "IRJPp6zW2W7DCP/KRkZeXaacRIFMbkDnBbfGtNfqozM=", "IQ3k8icygkUj3U/QWH7r3XjMM56NxE+9wqMXJEEy9w==", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "DCMagXgKX5urwfQTcQbUVqXN8KNW4MO3mzMJgt3mxds=", "DSKG73fxW1YrqDFhUakkWMUqtpedNkgau27pQgvvwUQ=", "FM1q2yOURN+bUQxeHCo3jz3fvHW2E3G2iJMb88bsJWM=", "H5RXfMDLh6GAgRkjrfypqMx3uO9BwO/vNuGzGWefDxA=", "K/jsxTeWysextLjoy/6PksMfcm26Y4eD6wY7Z1+pYGQ=", "JEPf9Xk/EoJskZX8lcryFiy3Odg3xOFdQm5l6yDESIQ=", "KIB0RfBYV+XbGMa6bA89Z8/QjX7gobWj7CWcEeV/ZYE=", "LXGBoOtxf8PZVUuxmW7lJ8wp+p3T3eur80ZyXYQ4mkU=", "HUZ6Da1MpslXB+lfh4DKQPzJg6fhFxsRGoh0sSJXRIg=", "As1gSaCtBumpqe72MzVm/nVY2wAH5uktcSUM5YIYlFM=", "LsBvNzy3nBFD0OrW6pSlMVdLZCoqiO1sshu6++KTLFc=", "Da3eF4Wm6HBYVsRyB+5CBF3QNgw8szLoZt0DLvm62SU=", "Ju8IY7e060IjyItYZLkDUm2E/4HAmeqUL6mf+g43Zng=", "JvGiSQGGph3pVmfIZy3/vua8FFGsEf4unRWdMI+Hyvk=", "CROgpDF64ktsvvOch/EKP0e0+nS25/koammRAnr4HWw=", "EB1pExHmAvG/ReK60pmUiAN29XgEUXUl6xaSQNIe87k=", "HFXqsKlGRDBZld1bmk8nJDkNiP0+mCvkOwGmJ6zPWxY=", "H3iNyh7f9RcrTpSIaLwY58DvNgIDPXLvMif4d2vNQLg=", "DF3EHjb+UBqstNj40zsS2hZ6EvzcEGJqHN/JDMJc2Bk=", "GKblZ4ZdQo8tu7bpvymKuJWMXRc3YY5fHFZ5x2eHusc=", "DN+z5ZdfuQyu6YSXdo833UZVhuFmnWv8USsyo4lcYvY=", "MO3IQp+mIwtb+VU84Z8KeAVfLWjewQlX0NZOijvbPg==", "Bf9tv4wA6fMqYfkI5vp1GOSc4LyS2rUZUkiHrZvLOo8=", "GHwANaIPQrsEpNPxctjdcXYfvhZAWgxzZYoY4XcBKzI=", "Jn4ONxUagBiUm9dm5lFwrXlEtUsZHfSQS2fRgaOwNB0=", "DeLznEXca0e61H0p2M5YfmDEMr8D+ZJOPXAVK6sjLq0=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KEWRYykT5XIUvAIVm7Po6BwGvtL+bzAqPSOPFBUss+Q=", "L2EQMzSHV2u2YYi7OBcGAaGLFgpBxlX1WzZuE43cPIg=", "EOiiX9T/c3sf2Oqhyg/cEHodnkj/vL2G/is4jdEKyAw=", "CTSunTa5NeR3wdksnqG4C80tgfP+Djek34lCk/fuLgw=", "HUgJdpe9dv5bD+IdjBgqmgMnAMCqlPoUd2UUembHpzI=", "JqAHuOfFoPCVxHwn6aaMa+iwh2aGO6M4VLLfy2xwj3Q=", "HbnJedJtwiGDDP2Fuxa5v25u2QMskX7WQEbSSxn+yi0=", "Drar9Vq4kqvl7YrXIj0ERg63zGWRIWwmAlDsDqIoUvQ=", "CvUpY9LYyh2F/kM7PiDjYPSI3HrkCgdJJfYSlZSC/Xw=", "IaCK2cXaf7+glrF3OsspPv2ym3aisNVPEHEQ5/fnrow=", "Bsv2dRITl/Ble64ICYCysiVmYT4FAfdO/49xgmpa70s=", "Axoj0q1lP3MGuEnv8LQ3OnourpJ56PBIJ52QJBVhsZI=", "LwhnB9MXRwRnqOCuA7pyXvee0e8BQ5W2etTaeII3dpw=", "JDYBIu6MWpzrIWltadVFajFmQZN3sJg4ii8ZlmzmIAU=", "F8D30jPQ+8xcUg8c46XUsJW9Ef6POfCQq36dJOvKgZU=", "A/KTFAt9B+FY9j+UeS+UNjLO13LXHNvZPhcamKK9sak=", "KA1NaA3kT0o1qNC6pKH+s3Af7JehUul3tTUlY8eX9os=", "FjPdQZbPaVv7nlE4zLs4GwurYZrRtyiALA6bNXcFA+U=", "BUnLnGs6sUrek/aV3DHfgW4T5s/3kCP5HF6tkxH6N+A=", "EtzqTOOSfKjDCHUVUKd8XOTgleDppBcQjBgQLksKujE=", "B4MxrEwsZwJlXLq+ISEk1PGh9QBadfryxv7lB7mZZUE=", "BWdLMrA3yTerALt+9Bvv0cAAQBS2aswmsRe9C0YocLU=", "FlxUH/PDj0qa+HgDQxa8TAjsFfzMx3ZX566jLJguJtk=", "Fkd+L2lWsqIyvoOJWGsFaf7vq31jXxc+v8qqBgQEQds=", "FphCS8hisKlv5oQ91cdiauAYLVD4MjwziRe9noyKh0Q=", "HfvGdkSIhVkz/nXhDd1gsJ1n2YxiLzbLVlkx2X6SKYg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "L3Iv5TslL4JW88nWE/yxIgXcl95yasjyPG1O4KlXWt0=", "BM5/hQOURSU+y8vzkwYXWQYuUqVAYDMdsnlHuw4EsQE=", "KtHMtpGLTbtou+A4lSHUGPGTDfHP/JHejo7mSKak5i8=", "EZq5u9Qz/wHH5DB50ojQU+fgxKdvrN7N4ad9VEkGtO0=", "F9Jj9189Pw1HK85Q5kEBeikfhGbmwDp2jBON6xtQ8/Q=", "JIvmdGsw4YzBMlkHjshIQRUyrRHUUGrGzN4TFJXJ/EI=", "CwL+QpV5B2Dh+nKBHdY1Auo2vtjrhlLms19Pr5tVQxI=", "FItRncC12qUPAHMJTofbREnIoGjM0QmHJpaXP564BsA=", "G7Xn74LBoqAoJ6LxajTL5gIJ+EddO/wLZlLmH0ET5to=", "D7doBOYwubUi2a8I8bU4gPXNxpG7IsJxUfVB/I4b8vs=", "JfFf28wW5cGrEGbSlLx3TbkWbsRdTc2txFl+3h2lMsg=", "GM9ux6xt2UPFe5RytYrxiSmpTdkqNAs+Q8B09it8/7k=", "KJk/upaD9yqHJ3AWdOPmV/3MrEZJ+Ch530KV6FiFcxc=", "H91r9YXt5ldyik6X6t8ZXAj45hRLKL2S72y3BuT2sF4=", "GBCw/cJtEjusgZuhUP+2rJRVrafext6r8Xjw3/+rBdc=", "F5Nbw5ziQeeLvWT/xyFmuNgFS+YsSU87iav4iBCAj80=", "I7Zv64ept6EFkjiDsOoMc/eV5EXjy29oySF8wP/qQ+8=", "CfasyUcKPKGwbgI8svbWikbKbENMUhstCnmcw/eymp0=", "BwWduTOkmlnXfH3YIm6kUoaKsYPRSqCbo/YgEaCMoxo=", "EQKDwthO9JjVTYzInzzNSJkDgq5zuJk6NkSrmWG3EUE=", "LghhklzJt2xbAEbYF4yzahOyaqTOTl99O+RTN4koYn0=", "GG1/ACKa10WgEjrZX66dETbU3/n7aT+VStn8qXLOnYk=", "IsemZhVu0+eBPpj2DRXiOkYdLpzziaWB2/i+C/Wv0BE=", "HN61DGvMP5zS9ZWI/XL7kpA0aF+IUG6JH0HdVyxnw2A=", "KXiioVHJUVVBHorLPBLNvPkp1nX7l45jbJPaZjgAwzs=", "Fn5y99t+jiH32vTwL6gwiEhR1WLDtRYGtSrT6A1HV78=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "GVe+YhvWIHc2sDdMcHfvZs3PpL9XWhbSck7JTi12SHY=", "A7Jk6iwqFxzjvGZy+pVwauNxVf7RYhgIDzPkabybblQ=", "HKx0JGhZWgHVgjn6J7/XPl5MgR0xvyMH4619n3pEDII=", "EwjiUD4WI3kxAqPG73mwBBaWGR1M0aCJ1EDnF9FWdbY=", "E1mX0RqKs9QY4bNDdtMZPQuDVZAq7f2y8pqkMnjieQ0=", "BvilQfFvnz2LsXV6rsXtH9++eZDnsEb+beuMavIS/0o=", "CaQDdFCsfXRnWmq/AWmJCiFh2sVQy9uyV8oi9AJu5OE=", "G7IoE8Vz6CCbcQDnfvgc7feefOYWsimnVAUFhUwmEvo=", "DVI116zYutll2+6qrDnVmVQ7J2ba2B36c4mI+MT+ysw=", "JFIugmQtDADetkBqsooYZ9+lDNbQ7KoOGLblgkAFq68=", "BRgI9xjko4mNEma0c6Lg+kcLmrWS+eHv37F3qPGxqGM=", "Lr8Tm61Tp0CLRS/fr4hHFBNGaI4F2k4OW0eMF4vDbBc=", "GPF3v9q+XsyqbcD8KPdeINvZ5HCtUDN3JL555G9LQpg=", "I/Xj4JdEyj5z/yZg5ArGuBUuHAqT5QfzEQkOZXRFh3k=", "I/xYZ71bTVJoaujr48FFTiZrxXauwfaCvxj3g4U9hSc=", "DeLjqylr51/gKvMp1h2AxcTSmIZSgxW0aYIjaZ7HDeM=", "L0wdPPZ5Ow+KcH3kkJwd8/iIo39fjjggZbUAk2wz0gc=", "Jr+3Ax/RblnXDcFyDU0EMB2X4HoAI+WHZbK2tzWwJEM=", "CPC+pPkoyq6dGecfGd2Fx9cAsbBbMXBUh4Rne8xNznM=", "IG3YbtsDiKvVkVRrN2p65txDMEG30kjqddkIxLN0Cvw=", "C9iW32MuOarU5XVESwv0neDhAYOwkTe4959wTPL+6+Y=", "IYgRZIjkGSviVpZH6oHGyqRdCLiWrBTkl97XprgNmFI=", "DpVUD8wt8tH2MBkfnl9It+RpX91fTpp8kw8WWYs+nlM=", "KdJdpZ+bI4kp0OtMZpIWdwZzu6mkihFgeT7GbnUlkEA=", "CZjFbiLA/lfJNvGXdOxDaP8zrKBliYB9s6HoE4OVtPk=", "H0YKJLgHJMuIr5/StztRLm1f3prW0Lc4AdsMrh0MA1c=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "DcW000gmYQiThNGFAO0K/bGmNcAG7GezE375fLA9J9A=", "IsdJLy+nufKXwvA2WUXODiYnkzMdPNoctz0IP8ig4h0=", "Jmr5XBF07QpXgbrSGiOXV47E0WZC1ynE2sqPFPbIapE=", "FMRhadIPo+Smf9jaOBrCJNYc70jdJ8GXEnNRm2+bcD8=", "Emm84TJ+5RXH3iLO16qZpN8gLPZh6g8sUgzipyGmQPI=", "FyvPJiH+TlwpGUkHKO5dGfbRs9syit3LL3CnkkkOm8A=", "DybdBAo9Q+R4jCC+hbS/d0djcp/OcwN65TpfSQq5nEk=", "L+MEuyqtfDo/4wt3CHYA0dp8otkFP37SZMGGXMgjGQc=", "LjZdG09tmUb68rpx+t4Gu78vhHXuxaVvxIQ3ZftKSfw=", "JagvEjFifdT6MrgtJ0ZYobZOjrrQbukDqrZJ4y/6288=", "LLkyS5XAVqfayFEVYv24BJxPCOb70+4iK6uW7Ky4nJo=", "HjwD7EzMuW6T57j6lvaRWg6i85K09eusWy8lEBP806c=", "AhARcwYXorfHYPd1jf43clGJw5IkAj/w2Bnb67GoHAc=", "KLBcCi6Y2+jwkIY3MKJLWX2X7DrbSgDz8aF20C9JUTg=", "JzVXAcMOwDMoe8EDZShVw0Go6Artmwv3oWM7PwqxGkM=", "D613kwVFd1NsVmUblYWtHswq8oxAZcb65P9H30KJ1fA=", "IbsDjbulh7hc8Pv81ead6fMp9mRr3UDo4noQcWH2JLM=", "IbHwlPPnjL9gBns7eF47PyTEFhyRxFIxjumQ4H4iVSQ=", "BS2LJNc8hq28gxE5Clssm2MAZx+ScXIDrXxGO74Hid8=", "DXA5/3Z6PYuwf7Ytay6+jFQyd+PaFTHalMyGHUV09kg=", "G5FvCFGYbE7cK5J6qL+dkheOvnW3dVLOR6Y+9wQJvAM=", "M8q59NPDYJJOkiclT0+b1S+ncS+1GOU0+f5p0E2ZTg==", "DialMns6AjsNGkMtS+X38LCfjEFDq4gbmF8s9+RY/eQ=", "LKV70MYpdTYHpMnje3g2aKu+x+jjBvdbiLqXdy03FZU=", "C3Uzg2cxFyrJ27VuVFiKXrgA/YDWdUr3T98TRgw0DvM=", "KMNlPWR70iHSs8efPaOCqTfNG+mjMjJ0jwT44ciAva0=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "B/wjC2o2q7HH9LdQT6UasBqogPezwKYO7hY3/2iInb4=", "C7/jZCG6UqL8h/bXl2rsAWXkGu4Pccv8h/Qba5ZcpuY=", "D9JCSwKNTYrBqMZuYwavLD3yE6Onl542fClX62MfF68=", "G2dHJaH5nh3+6wff+k2WHsJKMdQz2D+FjPP/39L6uus=", "EsnMNeDqJIKTXduiFPIajAjfPcnWsp91YZ+f/g0FXxA=", "GtOxDz9YT0gRyATZWzcJ3tcMWn07u/b5EzmUPYW74hw=", "Kr/Npbn3mbLQrwhhwXwzJTeB31HrGGpl6slYs06MNaU=", "DZz1L9IMGJmCUE0CqoBQClxzJDTfyefKyvCN3A0Mdt0=", "DYdiDaFcWMUK9nvzUzs5nt+DwefbwL2Xc9QNXqKHq6Q=", "KJ5VBR7HQeJzidzg7KHPwPpXvjOBwSlD/fxqo5K2CvE=", "KF7BeZwZXmOOFuTMf+W7fOBrHIIQXMTWE4XcLS7LuXk=", "KEzm5xQZIK1BWfnJfukhokzRiHGPcADxzLCRBn1N3u0=", "JAOz8/mf0NqorXfLP41RUFXPgNHV6NMuTkYn6VSJ9X4=", "LvZbzGdQIWnFxdMk4JKXtyUzAsgqM38AAzyBSqM9nO4=", "Kxzthla5IynWI6he5h4xBJVWbOTv/P77bmYG7Pzb/04=", "LPYWapGD5mvZS+Wq5Ur/8PAsxuto10Vs392G4OfwcZ0=", "Bg05KjHeiNeLaW5yOK88o+ql5BJDfGblnXBJtp0lB8A=", "DCtivYnjVzWSb2R0JkyJnrK1lWc4pHi25215K/QgzRY=", "DgcK9k5gPSRgiEfOhnfQKR4I1cEOwx8j2JjXFvHDnRo=", "LeZF43YxVfSMoY0G3SE3DzFOJjgsbJ6IPYTjh72JKJM=", "F97rw1FHrGRVchQMoYGoF4XnTfzgY7N+Mmzm55xmpto=", "CwNdQ7/spLekZAVOqg+JLLA12wajFQrZzhzkX2rQuBE=", "EAx4Mo71pJlENUHB4n940Od/Zfk3OOOTvc9LCYaBvlI=", "GAzR5aEmIIemC/FW6O1SgHCTaSNgXV+wePT2+ValWu8=", "FAnJr7Jm9ScjCJvMO0lbsVyfEMtVsytz3q0DD4fm4ko=", "EA7mLTqdZtO2Ng9UD5VEk9evc+bNlaEN283XnWc5/Tg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "D4UztRvZ7VShcD+oOZI506f+d7ClUhCRc0Pgk0Kg/YE=", "CjioUVsTk6CDeCxA9yYekh2HFVwIG3A5249Am+styPQ=", "Advia4q1bG3hEZaw/+c1U0i5kIOpTS8pZtIn/eQ4Ifc=", "L65YuBEgT78yMrKY4nTfEgAgKJ0GujQ7yVMvrnzPp2o=", "LDPJcRKKvK/95EVnFjsHHByEXV4E5LPk8yVsaQzGHv0=", "HWh5KYYD186RmJXqr4VxV7+vILRuutSMNuhZJ+AEln0=", "FU4rSVsolOJMe2T7g8BHMYayVvg95Oe1+Cq8Ppe50XY=", "EQjmWQ7gl9YXf5sOj232MekcpqrRdE/fw2pafPc2icI=", "Aw5MwN7+B+DA/8cuw1z6X5AuVkNZ3Cfm9QDJIdtPIsI=", "HE+Bd5yGM0kPPj4nZgMWLEpeQv5ttYpTMW+AXFyCKSI=", "KVTFXlER6wM62AyGcxe0qrqddQufm+2/xIq+hDC6PCA=", "DVGdcjdRF5HEedF49lAOVFMmJf7xeu8geC0VvhVoMLQ=", "Cxj1YEvvN0jg6Oy0Dn9jbSRSpC7RkpmCCl1BJB4+J6w=", "JxnF3/s8XgmeLr5Y4WhV71Bd0Q2vfMLyExE/9kdhS0I=", "AW5jXbsAONBb2VCpK3ha+ss/0Oa4bM49JCEy1PHBwM4=", "A5IKZiA4VmrKBysmVTJ0W68jm7PmAyaJEiIEdgUBWyM=", "LE8Tc5HzteTmAkqX8cnL3tsSl9Ejrdet9NZGGuWodb8=", "ImSn1gPbld+fB1gvsD3Ok0Di3jJs6oRrugQ7CUb4Etk=", "Lx83nwAsSQlN2ThDOphrUZoSPE2dAYnWZTNmXQdFBnw=", "DSknalrFEc/Do/57kkTUtwEM8L36kNffDWxAALlYXUU=", "CsOraAL88ws7bSsaaeVLNpkXm08wtGTgtxtrS2sRJL8=", "LcDDQXXmEYNgG6Tc+f+0V979NqvC4kur7bsKlFAVX90=", "Bv0IinvKILVXDWhmWuFxcsE7s2mPNkDM4iq3Tq18VmM=", "HehwA2QMAkq11Vw3inThThreoHL40i7pMrSRUN/REmo=", "LgG0ddeOZpqGgSmx8XOnegso2CqJtOu/onSgpB7/PgY=", "G6nILuL5zhtwOQ+qHTxAWF11F3W8hZbjKs80vP1Y+BQ=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "KmH7lSlbO1wJScSGZz0c5u1zKPQsndHILif6PbsOO/g=", "FWvvtu6xP1K6ZetzkLfIErpqq8XRrPwYm5X3H7R9soM=", "E0IveDqXjtXONeFUDZnDy8Z4A94Ao6T9vTf3wSDXqsM=", "GZXQDOfJlBXCcn6JYY5wWof9RFYUn72JnED0MyDV7Is=", "JOuzGORApFlW+uGkajMD/6u8rVrLjPmLbuaAVnLqhLM=", "LGwbNeeXnC40sHGgMQHbjPdTtcJhk/IG4q0hTtRzh8w=", "L7VdF+WlC4CxaPzdDWGPLaAHUQvbxCnF7X/J6aHuXA0=", "EXw5AzrA4fX4tXhEIgtyYOMIW7mZJer5N9SkOga80r8=", "FUpP8wZAJ9DUqrovzLsF/EsHSte8REMTLtI8XwPTjvE=", "Fuoz5zJ9P6tOFc9mzMTpkQSqQKSuDu+9R4UXR1wnTWI=", "B68WL2pB1WI81HGBNnxvH17gvnueC1P7gJd4nqmgzfs=", "GnMuN2VAUiPNtusoq9LUJdx9HNvldeCFaOECjY3bw5g=", "EgjOGjoBfbXRAkkgpqD5T7pV9biGIKzi4YDD1RcWNkE=", "C/msbMyD9x37htQLGbdgm1VfvBrUZbCfm0eyHLIw4XQ=", "GujLxuXkuR6pJKqARZZ6v00i1odjnn9k30DhuuwUo9A=", "Khvh5ND93Ijq3KXoNfML9+45sKrdmVtIp7pgG4fRY4A=", "Hc9MKbq4XOlq6BcD/yYmKgnIiV+IanHAFBPUQKL3g/w=", "K95bxWe8WZ4glYfQGo5bg8nyf9SYjJeClO2baAsDBH0=", "DX9jQWqqRuGlqwdlPJhyGzhI9/QN2gy+JPW+lXJJv9Y=", "IBwNW6GHN8zgvPYGnYKscLfG2paAKZOf15Pn38EZl8E=", "D9Tf3nccIa31/5ceC9AwGw+cAHmlzL6/bMBaV4IYz58=", "BuJuv64Nf1WWvBcZ1XixZFvcy0c8gCgg6NHnO6lf2uU=", "FTqQxKTfUDreRnCgGcHFOfqaux172FxWJ+KiNoFunpQ=", "Jo3bDTYH1tiKshYj2zIvcIgchl0bqihO73tvUEZJ9co=", "EK2TjCyXyHhSMgEejplWyoerMbbplHo/Wpyy36UmwXg=", "EAqdQrdhfWDks66lFQ0Fm751FFbEJJ8NgHJHYp5h8MQ=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "E7yF4q1DHfimcF0ZkKySXMw98SgkBXRgJbilud6mYf0=", "DPLYnLOcLYhgXAo04H6zFDaneikJYExpF8HI71tJDY4=", "JhLquo1rgzQyZlsTNNYSzZvEMKO/4uuz40t6nYePQFQ=", "F/KRWALjdsWCfnGaaJDZD7BndiyWuzu4a7NPLxQhEBE=", "Hsft3fbiVD9eRXrQrf5m/1XsBzAqYFHZB5e2U4C48H4=", "HUQGqgefuXa/TYo7+sgTR7zqLMm4ynMtMGT5QT8gIII=", "KbcaINMROJxnLYqFezSwTltMlWJMpyBnh5zTEtixfLA=", "Bt8MTH07hVLCKY9RihlmXsNVze26KZsg6xk8Z8DnLUM=", "JneeEIAEN3YMe8ISzqpdY9U6I0NoKW1mfx0ZeE9Hzag=", "7Rxe23BTBosH7mCRDtPRweQWhLJ2oK3lDGVN4QpEzA==", "JLQEavKO5QE8sWYqga5rYMlDFySzsWICpdnV7NsN0yI=", "JxBgdnFnRFHp2iky9RYW8UeOdEABe8vl8d8QMbqlgv4=", "C6hFo4AJhkyiR44ENkW7bQNasK4gBTrmXJmukUgZh48=", "FcXFTz78JtKDaizoHARbyyDhN5RfimTsk7ULBfzqFiQ=", "L0FuQYmurpMSkKoI2Edk2hjc4hfscW7BrVMNIdA1waY=", "DJI4XGPWxFE4moPdekZ4T5iFK23tMQC2Wot8W5bYkwU=", "Ii6BBaoYgIOvI3heNuHrO0g/7DU7gy+X4tZted0OKSY=", "6Y1/XkWsZhD9Fk7WhwQfKVLm3Tyf0S68g5WmiTrp/Q==", "EVkfNa0VQ6eoOYzIDY1GmA+y1akYSJQpVgcqO1jD+3w=", "D9pDRxyxftLJ5K0bzaqWLaCfuZpb90Ak0yI3hN9OBD0=", "ChLoEEmoiEmtdLQPOBvjDCwunsjYxQus7F0YaPSYKFo=", "B8bRlKc/hI99cW1vMKy0ise67Fr/xXG2uLa4SZYWgzk=", "GU+Efzx9BIoZN0JqeOB4TN5gdd0+yq0hpNiwwp5tzFg=", "BHgiXA3xCuEEfqprt2bHy6VdGy9K0skrV5KH1K+r1iI=", "BwmNhSITlLfdnV4Bu42PoyT1LMUKAdBJWffPR6nUJro=", "FSI3cnh2U2+wSSt34spQg9OUIcSNw05QeaM/o9KoY3k=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "FCChTeLLr/8leWFvrxv6dPfGVCsFOkmatVGjQI8BcME=", "C50cIRoxNc8kjyzou9H+nGh3iNN9ylgedu95agarszM=", "LZCti5a5XgfzE9SFGVqQ6M3uTDD9EbdAYXyqhk0guk8=", "GEFDn0AdIL5B46qBVKH/tbBqfLpph/7H9B31+SpryR0=", "AjiGQGQsKRpqHrmNc+p4t9F2wrcMbZu2N6vbhCwPSng=", "JoRzk/xzZOl2UbK3hxEeKGOuYSGMCiG475MpLW0/WaM=", "CpeqhrfL9UbFciVA+8MlfjfnAcRAI+Y4J4WmuPXiqm0=", "HmbJ4dSX+u7kakeKsn+69fmvKfQ/3hb5pjheDQWxeTA=", "Fd2dF0TAg1JCDnVswl52U36Nz9cMXg3MRF93VgtzDug=", "kH29cmPPkLjLXfs79gYQ1P1Evu6jCZRdggXNrq3Sog==", "Iz3OfKIf0ekJ6Y3PK1hOmth57esPOVv5pEqn/ViP8j0=", "KNDyXMiPPTOvVNARBjwKKQD7UOGNFRfVLWPOcrQ1o6Y=", "INuIyTa/58boYSZYHL+L1+3d/yYjffZ8AndwcNASrHE=", "J1MesAN9xbk47xiPsWfzgDn4Lyz/u4+2URsFZ2r24jA=", "F0yENtdjIRcXjXd8MXSqohsZCM7e8gmXr9T53lnbr2E=", "BhCnJF+xEbhjLNQ/jTVqg5dRp+o4OHDhCPRYFeff5Sc=", "BR7D67VglOb9X7SEAdyXp668CMAyEmCgPOFaZEAdV/c=", "DnmhcRdmC3llEFiqoQK/UwqYwPwniQwOVy7MbWZpw24=", "CtZClaChZFFwQK8M7yb6njmx6mfbSrIttdYHxPyj3pk=", "KGHT1TwmZdmslioqePpP6MtugeerIp9mxDKoDd5xFsc=", "L/p6emLV4b0Dy+v7xcdYRErg0HNMSl1mehWPuhGprI4=", "L87KUwI8PMPomRlhZE3stggGxeJr0u5kWUJAM8vqBt8=", "GzFd2DyLFqKq65EZQ2B2NE0voyHzNZ1qnvbMFbRaqvo=", "J8eGhlsMQkvC4h9D9CFo1mjs4bdwe2K26ndoKmCkscg=", "L1WsX+nE3uuSzTGFBEI/MYlLgOajQP0hraIVhW/L9bU=", "CEhMc1dmRa8DHajQWffKzSjGaQanrhCtkcGWNzYBM1s=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Hx6Zok2k3pNWShEHRNSBviEPYCCtmABvC9RhCgVLs5c=", "ExPOlJem4HTBVfwCGNhYICMI7RwSQQE/2xsjln+iMWc=", "IN0retLE8fHRnxiymjrkNkBbaGa438T7vwh3+7Pn6x0=", "HZo7FAd6fE1YVjLenB4NSmjHEgNJLVkRyxbzr6aL0uE=", "FzG63VOXMl4iIfZzkAL6qdoDcv74BD6/k+Riej+tFWw=", "I+fj/owQtVgKefTDKYyOGGK39SN5QvI6VFXU6sknVoU=", "LAFBgKbsxHRSgI/qIzuC8547fK8BdWh3d6znVEop43w=", "KSpbdVcx+hkXOvNeRlNlUKtnqvX3MCoAPQ9t8gTol2s=", "DtjGmBykFgDbpFCoYLhXhGVbwFGTSB3b5HXeTzUdJDo=", "GhlZeQgDbCCsY8zv7+dKfUo0JH90cb+nQ/fRhYyPvxk=", "IdgoE4hoJ+jBmFuuHdO4N3v8rsbn++CSQjLwWVAesng=", "Gjuojgcd+wPir2TU77urOCUX+UVmxyaGUImetrsZcdk=", "HUjUCKhXZgxfo2KGx/3daNKkgxywzQVflQvjw8lgc0c=", "I6kS7ganFyCKxfjpSj7xwNzLfLFKL8Mr5x2NJeZYJ+A=", "JPFjGLgGTZfTVD3AnAwolXRb38ljcbzJm1xtb/avPhM=", "BzLAsEDmv/uuasjO5XSMxLHdeVWdK4TXM0fnho7kXjY=", "KNlhozaH8V2OQjmqou2qsdz9VDvTBDevwVHLodi2+T8=", "KVM41PUJoOasGGIimWNb05MLv6pN7DuIW4F7rYcIhdw=", "IL+pH9Bcf7wvqwYZY3v0/tMflXMdicL3BA9MiTz6uaM=", "BA3xiANaskBqkyYGo5HhRsUUY6USnCvFqzQW5kVdzAM=", "JIP/z2haakKroa+LHJr0G2Z5aUaVfmmUf5eQYVQixhs=", "KFqq/dMYCxVD/BmUhG/6wi/gaQjlpr3T+j0is2RLbqc=", "LcXzQ95c9ZppyUKeliidwcTIzwj+aRhLaGkPM+Iz/cU=", "BuPXtizkQ2/t0KJA16d3rc55cW9aIrXv7qrQq/HotfI=", "FILLqXQf8dxD6h/FGJoqWf1bK8LxlZwWQkFmJljyUH4=", "E0hJhCDl+el3yduWCBjJax+TzzcKI4ATi71W4MnQ1SY=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "FP5QO7Q5006o6qV8+hyq5x5ChFIbpiQLCvuodLk66Pc=", "H5yag6lSwecml9ipOwCle9sJLWbr3hrYsWk0P5PD+OA=", "JPuwwPKs4FpfrwYYZ9LO+zVJTtn7fltZDbViSGyIsKw=", "EPc4vXkFo9ufDW+3OyzzxId9zmDOpZJdW77OeMxVFv0=", "KmLiRbi2jUUpiYfs9AoKNBnqhlPk2g1qb1WyFS2Fymc=", "J1tyiH9KP9Mr6ku/RzlBBpY3Ye8+AH8vHkRgFAiWwWg=", "FVLjbRZDUVDkdvpmZcTwWDVYVM8iAtkVcwcro9/SgH8=", "C+nvkEqsSG+93RuNp9V/nOjRvF/Huiq8F5wfoghztZc=", "HoHd/092obLc4b0QqqFlMPhjag5WO/M6AsuYAdf3Yuo=", "HJ1v04wVGxaIj/Pufceo9lP+rVD0YqYEXMa9qnIjHeI=", "JJ9sruLT8iVJt1PMCFeomoXcACWEAllKXr+9cjXIWk8=", "CluubFU4C8bDxc70qtvuPXui4wrODex/osPoUr8DB5g=", "Glkb2LqPXG5kuYStknQlfTjKryW5nKsXfITI8KziLEc=", "LxTnpNBx7DlPQ/RtYLFVKqmYC7UOfJY9QvSD2jIRoO4=", "Cd/8JZxgr1/1giz4oXBHdpWsV3XcG5AQRQPKxkkU+G8=", "KVr5FS3EBaQ7NTd16Tgo3A3RrUZX8fMk914l/GfTVbw=", "BO05ZTvVLwGyXbUPdbD5p4aNrPPG8pmcI7+V9YzVMzw=", "EOgVUA8itXuoBW3v9CtR9KQTD25tNkvB3nEXuQI8Czc=", "IobXWnKDK6sp1YOVxFrUGdPRJzBiyJOnDFb+njh1CIY=", "ER31Q/FPKuetqEm4DQG+MOI/tJroBdCa+3ocyYBXon8=", "JcHR4TYZ8a0EgxsjOdFjrYPaOAmonvwQYQ1cYrwD2j0=", "L6T+eqLcDs4d1IJ2iDi5q5EwEFOf2alMAFKLA35PjsQ=", "GVDy1H84oJduiAGgPt1R+YL6p0OSpwoNOBGU3CWHcOo=", "DmlFeVqHiVRkT9TTbb36hWxrFRPIw439ceP29kjVaM8=", "DxXobmm/DXR8frnRAKJpMORLVY3kay6SRsTNJp9OBwc=", "EyzM7pxH6idITcnXWdk9VgmI2aQqxvkL5HN3YeDUOPc=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "HxnVtYx3GxAi1q6nMlljTRyeHbInvX+s4M89fsbwSok=", "CemamJLsXJL8sts08KgNAfk9tmdbg55UrAgeJhbv/0w=", "LjmYKFfXH1O9+ostL9hIFycmfAC/KEoBHnXeEJC16hE=", "CkwOviEYwqxWQnLrj4mW3I/8ZJSAoUS9pX58M/FK1VI=", "JUUTRbNSE5ZM5DH2+ezRWTREO0NafxdavYDZfZmf2mA=", "C7xDdsH4VSO8fIrp/NihcvSk+ZBdCfHeCm1I4nPumAk=", "K90QN0aaR9ddW4mUcx7eRDBuE39EYPKsfBeL3nvZ/G4=", "D2d7KlXnVt6CI9yoy+WZVJidJ8qH9XuLjlkHjuMLJ0g=", "L7Cxe2ee1vo+UosAnkRLs0sXP+GJJZcaO2d3hjqTZBE=", "COSYjoqxonQg3GAKpP0T6p1wEpHgBd79qjPg33LRgLQ=", "KqP2+4G1RPpdM4wqcpnSjUmb+G93EJ75zZHzFWWV8PI=", "AgLOZnps7+aaHRLsbwt2dMrn+w4C3eQuR/z+tq/AEb0=", "E/xFHBdc19CsiKi3ATzUYK+faJgnU+AesLnMzMLHtXo=", "G4ai8IZ/SpfW8u5HAfI9fgXHcArlPA1XKExp4XDpCFg=", "H7+BL20BTXwBNLVNnWr/UPDddteImSaq9Z6G5pxyCCE=", "Ea5fG8Cy8QlW41sqEl3tDqSzEqpScHvV6YRS9u0NnSs=", "Dr/ShEoo0I3yzL3cjVLlG/lxTpJ5riW39wFdN3acdqM=", "HJ4oMNU9L7OOw/ss1vRQYQWJSd0YMSshL95wgneOuXA=", "LImhnMZ1gjxhhD8hi9ywzMtbm08Aad2/fpAP1kPCljs=", "CNqF/4tiAOCQz/CiwvBQQuMMeeQlkHrZoFWpoqSW5z0=", "CWAYDl1f9UkTA2ADiqwmv30vWCjogyeh++IicZTuJww=", "AX6lMYjHeldg/T2jIT9UnlpFx0Pbayf08a+H5O8oYJo=", "HNMAFg5cvnuc160RgFmMBloI6llIl6iyxmdQjpOq0sY=", "G424bP0x+yf/0FMSE5rIWU5Lmlh5J/HV+7N4vnX9/5Q=", "Cc6S63U4B7TNic7+lOfzGw6uQ7TNa5fYJIcxzKeBffk=", "D5U+iwQ6W85cRZrgwXWO5ScH9vDfvdxeQHSDcJ3yKnA=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "DmH7fnXvkpXEGJ1ZJpQMZb7yn5Rg/WrKuW/tPRvj5iY=", "DaV0+qOFGw+J7glnkuci7wLA4JeTuClXnmLUPpdFB4s=", "Kei/tDlBdDINjDUh+aZltUfLBWD3JqDXD1L2E7DyRoY=", "E4hkpgwGaDXxJ8x/wYrQvJJ3Tu1VpXNbj05Y8cTeVLA=", "DEBhqFVsul65jWlm9wFLfwk+bBbKHEmLqyZpGO/SSYI=", "KaMfmqqN3qX/4N68TKaWiFSsGWIV32fAn8vQM1IYC48=", "HPOuCxubXZlEWn+UmYxeWUiMYEGmIFBFaDxC90F7ilc=", "KXyc9Ag/5QCQi9H0yIYwbfmwgOd1aaU0xVirVSvGGhQ=", "H+40QaNFhpu+90RG/uT1HpMD024KMxaQW5F9uLM+6EY=", "KfgacGFjtVxuVTJHd3A6kwPvi8VlAWDg9G5bgA1iq84=", "CC75hbFyHsx3DLc7Eof3RXafllLHqhd+Q3Bv+wFoP8w=", "DSkJR5q6Gc3wWd/SiRXLEBdW/Qvm/dZa8nFj09TbgKI=", "L5zZRv0cLcdL0PPOVzesg7EHG31Ocgu7LY8TjCTp8zY=", "JOyFV65iaykbUQ2ewb01QkfcNyf3KDLaennE/K+MvIw=", "DxGkH4Qbic5wUFVD1wKPjIUswN98jYQJFyOcNyQRTm4=", "EUu4J5W0NHHEin1PIeF8Jw+YxpB8N/L7H5mFYmbLgIk=", "K2L/XwG7tJHHRKgobbCt7WAvKHq67DsfsbQhLljmpME=", "BlYB+L3Uh+w5WyD6X8J214ulkYNfSBETs6XFmwBeSZw=", "H8cobNAWjoQwG0jvh9fKtn5FiD4WbOPVs5g4kjDZrks=", "B5XyO60jnC5GVgHhCf/LFuFT9eR6RzVBOJQNmQiMUGk=", "LpU+cV4MR/3NYYwsUpEhWnPTwaKby8t7m302LyEQcsc=", "BXezq+3bHLoDhc1HnVuAvnOsGOpVZNlyZoHYwphXtQk=", "F/aO+A/lO2ORlBlSddbdVnHSAW5nt3egYA1p/U5yOE8=", "IP9OWGWcsJMvm+NFXRPQ5lkbEtqPTGFIkBPPkGCxLt4=", "HiI4QYHBnYtsUVsnXbhAHpABkvCuVNFE+nxDwCld4tI=", "K3O9m6OqIu5Py4Gskc+K0D9m9kDfuxzHthqDxOeqLqg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "BuB31cLk5clwWCeoe/HQO6DRrQ0a1sodY00l5MZqChU=", "ASGiEtrLu8DM9MO0KS9oFSPafJ4aRuG6CFa5AJEeT4Q=", "FKVAWnHjvxLONHxU/eHSI5j8YW2zTW1uxX2NA5VYk0E=", "Dwn6fE7quiL/AAvaYb19TodzTz+BlbOL/OzG/yIdKGM=", "FsJYab1Re974g0UxVkE3TqhuZlQfEnJJOKx9/z/BQ1M=", "KTz5aXC5BNIB7xuqi9rKEyGtP/DWdUjXrQcofSkIUYs=", "DF8iMoE+jdQTQQZFoThUk7pxUmCz2WgUnzB7U+zHk/g=", "LmIKOaV4mOukmSt6GyvZsMKFc6H/Rw9UTGJaYO9iQXM=", "HGi2TIiH09uklca7NggGX3smuNOQUAmXcDMIkd4uhyI=", "D+AOc1xB/QCGr8JQIkwtSM0Odx7atz6151xY+VcIJHg=", "G2aOylIa8vkiKuhoGbWu9tMtgXknXnuY9rnDFLYmU6k=", "KFAlwYjpjU5uWLDrbdRv0fjSatUZnrm2R+mfcEctxLo=", "IN/b6ruJAAkHJbOPhPZhzS/1sRzrPGg172mPfY4C0qA=", "B9ka2t1aT2dLaZB8Uz0STunxWYjLcacy0cMYiJJNNyk=", "IsPbWxIVW5RcfMBMDNtTTbL4g2uIdCyzLbQP0ORsn34=", "AUtkCgPdkgd2TP/s2QUApfCQGUa/Vebze0+xdkuvg4I=", "HpuRJwnoWVe1j6Dg1CTHJiz888CEBmcBLKsNBlQsZZQ=", "H0p16WXWa52WZd21oVrQmp1ojrK3dPyKhq9G/XJ5a9A=", "A9XGN/aWd+CDMcGF1TupdZrgGKgy2gNuMfANzuFFE7w=", "HkJkG7KaSLG5yKGH3Wzfa6YCnLB2DfkHNLXTutjiErQ=", "LYC6iX1ibg07sVR5BEuwB8tVJiFJ4Q9T5j9CpTs+h/4=", "IHGr+jPxCaaT/QfE2mpcoRdf8EE1E9Nq3VvHIBLnOhs=", "KFdnWjwjZTKDPmwExsnMkdSqPhjrjzjOpuQhxJM/BY8=", "CdCXioYbnYUmUDmiIZGCTkl0srETYi3UU8cbCx+OxmM=", "Cx/7YByUboCJ1TG7uLw01KNuJX6FlsR6PHc9ccaGArM=", "G4z8ZRubKlGEnb+nLE85rgGwmJl7Im9YYWODUTx2rAo=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "J9Fn/nhwhEfhHdH54TQvZ6nSvh3My3wL8crGCw0flW8=", "LSEampsTvuA4L7cHoHRMpHs8wPWgr82rtcNOUtyPonc=", "BBIVpxORCblT4/dfA5wwGdmjJSZGHLHnSbteSunm3xQ=", "E5JVMYgg2fdphk5LkBG9ysJPVJGkCcjQCIwGh1VNDSg=", "Jt2kRgYsEbPuin2fg4PbHxiYWdkaA9NeksKuE5m5lOU=", "Kp0zWao6s1l5nSPAPz/2d+zjCA35eCFMm6CINoRuMec=", "AlVx3ilqEewmx/WzeNvFg3w+jPCWefxj2kY9WibpnyQ=", "Lp0ELC3rPKvW11ilTN6ygokeaV1GPK2qwBpEtkmB6WM=", "HM/hdHd4fDvXJ0EmXlrEGc8E9g66uV3aPNdO/r80r5U=", "GqvLv/QnaRdvBcM+1ulX9u+z9ARFHYPGwQcxPrCY1X0=", "HDp53HrHm0AUKbEoR4D4IFKwIXpprcbOQx+23nB12jE=", "JFG8Jl2sNUc1O0h8RD0ZIw8dTzBeyy1huupkPxg/0do=", "FG7p3FvI3dsix86KO+Y21pwMBglwm30YO7ilIw9JDBQ=", "FyLbExgNM7qZuBmafm4Uv7p93O7DvzUWGn6HXDNvvfM=", "D5CxkGHRHyoDK61pghlsPsITLq4H5zp9e3qhoTU3EvY=", "KdwbjHCnUFLUMSiJBdZCQMaXnwQpBHK5QflD3rf3iTo=", "HL1XDTtibL/3RLj6tFWjfFR2BDEUKqZ4Dns0apPzL6U=", "Ei4NWu9qnZRCEbMIcmak39xkwsHhKbFG5LRck+gSh4k=", "BqLof2wlHC+KVGYaxMF38urYxmvULNv88GQuSwJTdcE=", "EhsUtRLytnZ7xnaRkG5Z0Mbx9L5Ld+FeJ3UmpR2+GmI=", "JDN0Wd89NvFBMO8ciVD9JntYqGs3wwq4fVckVxnzhDw=", "LXUUB9csOL14A2MLEv3cegdtsy2QFtOwqTgjG19mdUA=", "H8+j6XOU4QV+te8ke0eg9hDtZ9ZyJfTIokb1S95XXPU=", "HORlaPwrMfxFjGXXmJO6z7DMlrDgi1HoXU1UMuJEfoQ=", "KiA1OJr3qsOC01FdmZ5qaHycLpORjFYlPGrpaV0W158=", "CnSFpXNJLDj+u3e3A7BnUpDsYVl0yfcF+mOxdWKLhUg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "PAuV0iUEASQ459p4saXb60+VVp1o+tX6UfEm5DQlGg==", "EkInSBk91UEN5nXFhYSktmEu48uP2SkyCp5wcgdWy6k=", "BWDRNgIniv0PlgltJVQ0LPO8hpcPJ/yAfc5pvMC4dMw=", "EzlBi3sDnY5oJgAV9VudkfrGm/gjJyL5QXOKq+ohzcM=", "HLtGawJ1XTLrXXkkFHgBElgz6QIK9vUr5ojl2MBxvHc=", "D1w4qimb6FvgO48GwpCPCq+vZ2YqcU7apAffk/0aMn8=", "BkRXR+2oV6gZG2jifWQM/ZHWgnPlTYiP8FcAHkdvAKM=", "FgRlmmVtntbl3sRhpZPD7ralvl3XImdUJc+IPevGls4=", "EfwUb5qkX3SKbM4QKFRyDL+2D1KX7S93sWyfjsmkrNU=", "IuvU+bzQfFmChjOAX8mTcMwXyKgY4EKB/IYvQlqD+uM=", "BRw6SSG9IG9locqxu4PaLsYSi5J+I3ZQjHSnu6NTcS0=", "GwTPLXpxKC5Xszs6ZyNciazFoD5uW4wvx4SJHqup4iE=", "JC3jTtUxa6l65PRvBaqefCwcFdrZ2/hpUojBMXG+qJA=", "IEbJGlnVDCccCScapA3tmAyRqI6l9+OysIhYRk4ILBI=", "Js1UWZlCjFFCBItkGvcHdZQjh3jRcZbaLlyOGyU7Ntw=", "JWsvSAAHGu6UrGuQMZdPJvptxSCTjJaVKHg2T2+XkP0=", "FkoPiXUI9Q6BpKUeGr5WQT07UzBsN2HdQI4XQ/sGCjM=", "H3VpNDB5gm8LEkBwLsUHkVFz8416Obx1rRyGz3m9RBQ=", "BScrs+hOnQzFhqfWr3EAJvgJ6gZSb/6do1D93MwJ0aM=", "Iqyb7SZrlMANL5009xotNsDQm7MNnvZYe+dS7Yt/vCY=", "B2dINlF3d+03eeilhHMqlQnknbnZSncWG3hwzvmBwec=", "D/56AXC7SPtsPguA5iROHW75nM8+ijBhqjE2sfeVbPE=", "Gv2dzpGxkRR8X3ZDANju02Lu6QdhbQvVbJMaqnaDGU0=", "GuNGiJNvzAloJJzyB3oamC31NY3Vq8jezrbzO4SLRVw=", "AzhtboKu229LwF006WgFz4dbvc2fWdo7O5X3BjRCsig=", "GhwG6gkmvQJGQJNvlzdzGfq2gzNJrDIyQBZ2UfOgEDc=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "MBkjNkCdFrt3OJYl0J1195+C4+JJubgKVtVBpGMYRJg=", "GciWf+vPRYIKL6x6j3R1tZHz3IfiYzknidJHs563Syk=", "CXVwuR7V1Z2Xfo5x7olaWQtSnbbuNk/YK9o0rBj9Icg=", "GkOT13j+pO/Qk8WkO08PsxjK7dke0w4q/+gAVLbNjk0=", "MfVA4cEDipitO4DY/JvfrqNdHRU9oAEQY7JHIAS2ew==", "Fl8AG8uKOg+dTgDurtBWFAY9ZXNd7Iw5c3qD2kopP2s=", "Ai5rIjs+Q1MJ7nT0kgWE5oHAPAOCrU1NRffx4EyPHik=", "FT1MdPZ05WZHAHVmz8V10IIg3Yn4jpGZF06BAG9LxYk=", "BG1GVOXqEu99eep7VA79jPyw+MgDvnqfMTMif4tnORk=", "CHLZbCWPZADAMQJMgeueSfGu+600Il+lYzNH9hWRAVI=", "FeiiONKV9Wa3AkZIiuf/0UZaDv0S0taIzrKtHM5Q+yg=", "CnwBmTPRwKJcuN5n2ikmWRJ0rHma56CADnnfsaZrCaw=", "AScccPiAUyEGjIleHgNw8XvUnXt1z44FW4f3YViSxsM=", "ETVskM9r1AvdKZhZ8kOc0Jj0O69xAZiqpFe+0pt43NM=", "HP7VX0+ATXbdvcIR8kinp7lEH/Ek4xuub596c091q8A=", "Avn8FfqKeqchffy2O8MebpouxnZo7xRJnrSmuTIjSqM=", "BoLKi4Z8eMkX8Ewqd0Wpp5GCgWZ3xlp3GwGeZO/5Ors=", "Idyopquj0/AbwOJ+pRjwSb1XiX8TVBQdRhtKDIaC5IQ=", "InYVq/OMhU7kq974tTsmh4MrROsFIQyjVQgq4G2bX2w=", "KSHYB8/u16hZJ5ZvHdW/JoNdOHfHInrY/OlvKNALZvY=", "HJBF0nEh6yAOmanfK46Vb1cOfLBqqkJIcuZNokZo/AQ=", "BAhQocLRt7eLWdzLeQd2BdxkfjlxsmZ5FCz6ZXs+d6Q=", "BIAN1dNIYKzHRfc+YcR03Ejl7YjMKmVW/X2LpH9/4Zs=", "DNYFzBByg1NBgM/ssmgGjM4OMk+O7RPcVI0jhVn+uA0=", "JlpFYKihzOz9SCZNnuFq8ZwSUkTBPuYmsj1yvWwbadw=", "LXK1j4eODZb+gZrGMOuuQSl6CfvHn/83KSjmv5KaCFA=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "B4PgPhwgaH3Poym/52KEfvhGm5oW8a/0bnIbz+tO2aI=", "B8VJh5dpthJ7H92eEZx/EIhFmyREymL5RvgCZcCNlrE=", "ECWIXCnEDbMcqPH0kMqkvGIZJOiHJUKPvGcFVeQiLbM=", "IfD+ylh/5UYipzHsiHaNmGWBwHRlxHRylpHjGotP23U=", "Bm354nEn1wA/OX4D2tJGAnElrmyZIA2tPNX68v5D3iI=", "J/OrDOEPVfIx19JJ6vOKpFN13PrmrdmyF4PR68OOSRM=", "Hi3uTZSjy+Z4r4sKi/J3RpFQNkSW78Cs5YVAhlpiiLY=", "CZctC8UScHUc9/38latyCIEtfp2TqbRThuC70/sjxwk=", "FH0zAqI9+khn/PIWi62v+OmH6Q9sFB6SvsJ4zoFqlWY=", "LpXAtxDMF5tOOfPUXJfQVVQ3GV0+iU5b8jirn7mSnFQ=", "Dt/4TQJgJrYh5t50GEkwB0gHjbFAyf4EI2wuBaNdfw0=", "JF0F7AtdyCK+qbiizWxW2ji/3aCk+ldE2kQrqDMJhXQ=", "E4h0NgtumObM2P73Qtyg2OxEgmqsziIbMRz0IabsApI=", "HMBb5kwvPNK2hpnFLxXWJl1JPnvVq0AwpTyL4v7Wfok=", "L17cUIuhToJx/H+8yz59h1D0MiYGsuXcqscjm6chQ9I=", "FVfU7uIHNTFD7tGwHDeAa08LbmiAaaE7KWIUQ5u+CUk=", "JYZQ6MpuEWLhn5IwLSpujkCwC7Fhx/LKW5I2TLVTtfw=", "EuwjgaAYtxhY32v2sMngLxTYykkoeAVdz85mDH2RVTI=", "Kuy1miZRCVPp04tWaUR99r9MLcGpuub0uE/9/f9qKik=", "EyAZB/+EIdx05Remty5PmXE1yPDo6lRGkHxv0m8WCc8=", "AdsTDlWDyBLqJeEH4niZyJUhSrsiW7OAfqgCMgFdIeI=", "J9uZvCiaxeGtexGSygwPOxYUx3p3eBzwDuLkEYNRhb0=", "IaMmcSxbEJJy1qrrtzzHTNOJVD/Rfm8SyzpsIBrnNeY=", "Jxb4ImF6NZtgup2FPXal0FHJvr6eqUJdUbmEdalIWAk=", "DpnyWArc83LxyZ0AmiKBbFPNUnLUef1kAWpF517uo4E=", "CjETpq/+VZjZ2K0t2/g/+U1Wyn8HikhxPQrxXEUpKRo=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "LPZ9XRqTg84UrfjXtjAF4FiYDKFI3rO/DxeFXLEVCX4=", "FBgtKPF9dk95D5GFoVpqAxRMnkHtIuiiJpYZd13TNls=", "LWNRDOD1GsjzJTJxka4ujayHdcBfh7h4l+c0FqU9EAc=", "EdICP+UPEUeZi9t9A7cPcPGlg6Z2RrBVviUuM5O7D94=", "DVvqvfyN7xwPr9K2Jb8fTqy2092IcNBVevVMnJi1t5k=", "Lo9Oa7b3ooQiY2p9Ow/hLKIKsUzQxcRcTvE/Mm6l/ug=", "GuXryq4FvttZGU6WySwohHnc4qtD/OskVByiZIJFdio=", "JMr7TCGvHNFiFt1Ct+XEJFfV+/S/h722VzBBjv1oKl4=", "LhOeDfk4ZFFqq9uG1qtl1lmKABc0b9cy5/iVr/NulIE=", "L/g7sohHEwVVZJcPHjnN7Qd6kgXL10ra1wQR4vljFZw=", "JVL4KVdC/ZTg8mTRgunjQCP0Fj/JKcaxQ8s128YaMsU=", "CwXA8d76L/TmpWp1gqVo1lCnoq6cy8R4vlK7T+NFIpk=", "AsBYgoPgu3E+p6IvsYn6NZ3Ks58TfJ1ZU8zQrhNncPg=", "GL/O27ofknnS29HQtLcopINrloKQXgP22auZku5wK9s=", "BLMU0Iba68TzOn6Psu5XjGaOka3/OsMWjdMYOWX1Hsg=", "Bs2EE1/9102cMVv+MZ0BsXBg/ulj6Dc9FFjhgQJ/8AU=", "Ke6pA5xZyTnLgqaafe9qYGI7mGjhpxN1kLkwFAuuTsI=", "GXL8lsJBIb3cx2xEB026asAsoaELuqe7Sc5tcWG0/+Q=", "G6z8LXLVf2v2lfPYKFmFmzKbh1OeDBgxOh0/J6ua++c=", "EGni7aR+n7a/3fu0jXQCVqzZvgfS6piDtj4yFNDe0Pg=", "HYfcjI5zw40g0u3T9rWr1Faogd7tqQ0HgBds13cEGcU=", "HQjIoJUrXk/ZFbOTgqDuRYk+PCB+M55sePKPF4e86Us=", "D9urYKkp1JIBegaRAy+AQiAaMiPHrWKKbhtjQNCJPA==", "E/JYJu3zAB49it5d0pZZia5sJXi36IYRaUlVO28M4kQ=", "BE+gLh2pm8SGbCIHhKS6Va4oz8R8S55bpIj0O2FBx8M=", "B0ktmPd09sj2dYOqpIWsYykGoZADp3VxGVNrGat4udg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "H7uJ1DisFBKKQENzUu1xgtEPIpZIM+/m+0brIbeA7AE=", "Bq6Bmo4MV9RO4asHpJvoLKVUTYmrhRj4RDhVdq7EMjQ=", "Kz06dgVUPTULCDi5s/qWVsuRqEKH1vBukzgVTzFsuts=", "FiAyPMJPuBhU1xbc2XLBCOpdOwYoQXUqNsmUxZQZl3Q=", "BTkkuvq9+JIyNT5chT3YuUb2F6KPCU+fkrrfHCM8klw=", "AZkkHIKlcBTjN1ApsmXqdoNhHq1RSKj4OiMQZceIeVE=", "HottsNRHwJmudDP64ioud50RC9O4/spYruBW9+wyWk8=", "CzkI0up68m1CqROXL+EMNWX2J8vzsFr3sDoDtFXSdFo=", "DDN/YXheUCKH4nTIF+XzgOXNMU0aPOQoh9/hm9IOg0g=", "CWWn0PJ5mqbz7LCrT99fAuD9U4a/E3zSvbw+aqt0tgg=", "AY2Nx512iQu3WGxl2DrM5hheEbo40oj0kz8z23QjTqo=", "IEhgLBHo53G7NUFdtFGXmMNrWT6guP1FYEEKcFfV1qA=", "KWaDNjPymqr51fjSBv0TU/FA2YmnIUzRO/7QZXsLVAc=", "HGuoWrX4XtS1PcQM7aumPl74AGxyREC5RI1krCs5Swg=", "BlrcYIqm3Ah49b/MK4mz28GMWUTFuGjb1tJjz9OGzL0=", "L1xpvTKWCvKc56sUFQugiQc9dLFMGLY9zpJC342mZuY=", "DU5Hwu76LZeZHVgZjhR8XcP4VmZfNZBcjcwMeYGXlmk=", "Idx5iWOAyZNtXaRxF+5zDBZWPUCCbP7ZoUFWNrttn2w=", "ETk9ELG4nfmi58aN8z8e5BZW7oUJVwzUrsbWiRdzIkU=", "JQGoMsS+M84aR1KqPDhAuJx+udeiomexbwdtnJCm6Yw=", "KUF6fsw/rtUfj05ZnhNpnTIHPF84ZdiskvZkAWBgyEo=", "Hm7kvntfif5et/UOpzk1++68bKh1ZYAJmzyaQaimbz8=", "JLEJTP+oFjHdn8eLM8vY16k9AmmsYFAa+P+C+mRuMN8=", "G61E8XTxKALE7B3K+2hStrmdw3I772KTYbW+pZSn4/Y=", "Ku0sJtyJDVKDtTrV8w+TVOIoBAFjNeQZC1Ub5eKOTkQ=", "JH1ZRIYArZgRVsLhnivpJNe4O+0brPFomdq316i/f1E=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "EFCXMUvOLCWIqlbxkbgT/uWEeei1QcE71sm8jmVBcq4=", "KNU1SgzrXbsznsiAs7b7wOfk8HrA7PU0hCnhr1cGm+8=", "CjHHZ4Czm0lPczSnos4AS4D1bYmKwVVxb2UXL8491FQ=", "EiWozk4nr2YlrRqSUwof2zIGE16wn2ebKzjBOGm5Nw4=", "CYoW/mxqKkM6BF/Q0CNG5cAk17S8vhLSWURppKeikls=", "IFrQ38enKYvMqSq6PsI/fc7iF4XJauoRa89x4H2bo2E=", "FI8erci+cx+V74G44fNjT0QYIQGy8T2P5Guzqv0jALk=", "BDckdKeTisyUffbSYfu6JoUKCaFlh9BpzYdxUeKH4dQ=", "LKaXmgecsvRV2k4juQ4ZHP8j4tdrfQptYT4MGkUHxKk=", "LKWd9VrUkjBwpGaWKarXVKiLUPvUZD1UQEXXYUhFHcQ=", "KnBV8eJESLUrv1ctDvwSdUWT1ZBiNF+Ri6fZCicTBYA=", "CmROL+l1o9Bi/0lqF+cROjlez2eCid5TshN99YEb4cQ=", "JZu32Ivz8cLwUh/4TAVCOiUPwyR3gjxE1T4RyuYCiuM=", "J9VR64gJ3y4cIApmGDj9lr6jCnoLf/sgeVdBpG7DWck=", "F+N+RDI2Dtmhbcuc8FhLR7oEnLpVtTrVtb/bVcvTasM=", "JjaT822ldOn2sa8uKBfoAwgANaGawcL/dU8Plw0gxvk=", "Gok8TeNxeELt4TX9sqY/PAXINMqyJXK+wh1X23w8sFI=", "Cbyoj8QX2FwWvJji/KUxIGM2ImujoCpRp/vcIxDib1E=", "D+aUTDMX1Y/6mPs6mRwiaY/yB2XTTCuLlYArg/u9nNA=", "G6PRRCdKBz4X7VI0jNgus+AMdDt9nT6USh4/WjYUdPc=", "LMQplVhiZenN+6qEVSUXcmmze6f80ylAdGE9LRKvQHA=", "CoOBG/8efyIAByDVmO0uNQjuFKnhL/YSXb23jPB6LWI=", "BCQpGKX8nKPDSGfWdNx9HRE2/7UZ3g6s4eb5EeoZc1A=", "DtuhoWGq54G6uSNj+g0S2Pz7XjuBjN3viET5Tp24kA==", "IwlC3nL+DbkZbXh7kpFEv0+s62m28SqstuDWtRzHkxo=", "GpVhwNAg+yjqLr84UYMgWK0c+XLpmEH0dyqMV4tu9I8=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "IsD8nAD1PUJHyQiXax7R5VxBOLlunDrB3B9NJo5k70k=", "InKdd7e4ga8vSEoahDj1LLe+O5PGBzEMUDih0HJToYQ=", "FIg6zslegkq1BXVqUzayxeG5hMahk9S9uwFMCXc0tGQ=", "Eg2W3FtChYn/ufN7UAHG9ZFbPORGCyUzHGLVnWWtwBw=", "EwMlqJyOdLX+69Y0Dd6ZL1aaqj+TUORdCQQCcIfomy4=", "Fubnk8gaEHGfYTqxgq1X6+x2342+93XPA+HjFmRtBfU=", "GLt4j0/1TcCYHjWnF4gJ0fJRjL0S5eeKd8LjZtBUPPc=", "DO3uUdW4fZulLW8SSQskzunmHBiJ70by+IJkQEZiZGE=", "G/4PAFmkURdTSPivhV4fOE0Sma39H42FLfbDJRML/cY=", "HKgusapNYIGkYJT0A5VDma92p9fa2I1anKkhowrh3Js=", "EeHThOsqZEcqJuQFlCU6zSVQJ7K/H3qaUYuVTQ3gQyE=", "DccBOUaekYJ2u2X/gzT2S6RCzdZLwYZe/j54j/DHQ0E=", "GJb188dU252IEumWZcichzYg2fDlmcCy2yX5sYbAW8o=", "Kx6ykvvwUgezqRZpIAOrwEaD23des+l73V84jfW55uk=", "DoIqi2vauc+t/JiYLT0n31MwCSLqeVsp4e1OYfLva54=", "AURHMjU4Eo0Hakp8Xn1IclamcdzhZ+Gjf2lgHGR4Puc=", "FzGsgkNgHJrRwtgfbKEY1Hm51x0DqzTCgr9o88qspaU=", "Hv7yTNQX2ut/vBeJ/COB/BlPUV1r8bemG8zXCg/RPCo=", "Jsbej1tYC30iK/7i8Z2+AlgNpOODIXtIcPHUyPe2ksw=", "DTgj77TEgIwnX3IMNApzP/qrKMNkeZeLSFs0bk67GrQ=", "JKKx1DjuhxzfdluJnS8GiBGm9G0CQiwTP/ZpWn8wRZM=", "Cf4p42vHTPbUd84FRhD2OkOFWgjCe4avH/WOmMn+aG0=", "Ej5M5qtYXnSKZCSBmySqL9YONxuYQjVd+V7xMxg0bBA=", "JX0NYz57jkD6OgwwVI/3nSaNkClti10+nn7k857IFPA=", "IfS3ksH8r1XnDhsYBM39lSp+pF3LmYLDFQJERuNrS1s=", "GM7A0zHLuT5ctMHU8QgN41b0ZeL/svpxL+uFi6zk9cg=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Hl8I6/yfmX7OdzBTbdTP+LUZ6/UZrRNC3jwuJkc6C1s=", "LXfTSiGKdS36S5QbY9ewKrYHgDfOIuwGCNO3tALk77s=", "GQBLj26jm6J55ez4IQRgwRLBpWPPEGc22aCka3uEJpU=", "EftJiJNpCNs9UJBa3aUGXuKXp+cYfDYhL/31+BIg8lY=", "EIHr4+5yLk9oe+3yWczctvpGQgxE0OqIOJkXz2cXwEo=", "GFqo2TPMlnkQl1ZXdYlLFeKFjsKYAxHlXZgnRxu7qBA=", "GrMGhousmlumUkW5Pyybk23kSakJG0XzRzv5fdQlrts=", "Lx/I9s1HNZPPOFJxVuSCiX34RB24TIdVh8JJZvZSOXM=", "F3cLpb0DySdeL+Dr8VjKhVA85llpzJ+G4/s74k4futo=", "HQ0nXElxl47atLenzdha1ywgShNBXxQNnSi4r1FL1pI=", "HKB/YCsgNyuNUMmGP7Xsn6Azxj7rKTAVpLyRA4vj9/w=", "BHgvMcj83UiYr3bv/VJP0HOcisKQSA/Q8y3foILbvsY=", "Bo3hLlh6osJuLlCfrqD633lgKq6kbkW2CL6Wnr9G7eY=", "D0fz+I7Cl8NswWWB/iI6lTiMfDuv/myrx/T2ab90bpY=", "F7yZWBx705uun1k64dcumddijblBNaZcLFEHJ/YUgCk=", "HYXcDbc1tId9nxY5Ag2oevplgJY+DC3JXDCnfsV+4rE=", "J8IabGQkhqoHXJp3V7luaEGcq47YGeQNF5mSZS6q8dg=", "HBUBPgcZZQMGSHsH5CHnGLqcNSVpZAcXYO+ZxriqrSg=", "JrsuTiv5pT4RR2CNeak79zCwn05lHWsI22pQnOROu/o=", "LMfg+h6WTEij4PyQ815OdMwBsvdMxN6ISi3943Mx+qI=", "C5yH3ZFKJcnXUHC3mXUHOZlw2a3UE7mo5Dl/RquLl98=", "B/nObFkDJrc/AMhgh18sfU5rtScl2OTWlYyqyPRqSuM=", "DCidZwx+LnQ/vWD9KipePKB3tL9E33i6vf+iMmJtOQA=", "GQzhSak6UoywH7J9qeqjneK7rqUFUqmShtT6gLjnsi0=", "AgYzrioFttaddlq2/C4zWuDF28rBMLIEwB+I+c0JGxI=", "JUOpMtbNjb11M/O/WpBcNm3RrHNykPZnHnrWrbVXd40=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "Ihh9wUJcv1BTkvl2qDnfAcFwZ92afmfQnpB48exDq6w=", "J0V5uYtIMbiaQjUaK+9n8zoHQa+HHjsZEe3OKNaxMg4=", "LFKSVWKysI0dGyaWrykxV2kvKgt/NAUsvo4m6ABx0lY=", "Li+CMdtPN4b+9I57ZfnIkPGqg0cp92n+umCjVUuShKg=", "BSGSKrqRgGseThOkvfkv3pc3CZdRYmocTWARyw0o1Ig=", "LuEUCNAuRgMJv9RjROVVe7ZxFQQDDITYHRJ6F6pyx4c=", "AXWYGs4OyhUVNgAjUmC4IbSwUBPz4OPK0zI70yWIs5g=", "HRcJPHOVZogHAoFvd21U7ueBZOVxYzVwj9Z7rmQHuGM=", "B6bis6JJWEXKlqdXonm4I77CPm4sLuQfPtZwWp3yJUg=", "He5poKqsdjYKZuBXqO71v32EXLCaPrJ7/RUiObyKaBg=", "Fd8WrlTo4+IR6yf5X32gvfONqVMABwha/CBVNGju4uA=", "LYXNeMgCRPCQARXG9fXMTPv4KVwqC2hfmHFEuRUWGNA=", "HolPBS2wASy4N2LT+yqCTbEGhNtkHG4+qp/kXJVhVB8=", "Gb3gbW5+tshKAumg8iTHfAssr84Pup+/wGOka2noFAY=", "KJfeXZwnStQwKuZSED8NjToEGuk8DUYawV0w02pg7b8=", "D7Csd/mmz+lruqZG/igNS1RJ7aUbXMGsNjJcOvD0+DA=", "LD8G9vc2y/yxtpJ7U1Q8MalcZI1IKOw0QBwkdMkypIo=", "I+VkODRl8dH3y2KoDUmV+iFFz2sG+i8eBUHv//wZ9fQ=", "GME5FGRG28lW/5UnACI3DJPuCZR8q+47A3fRUk7CCAc=", "K7OxoXcWeAkugDkPGB/cbfNF52Qci35JMnCKwfMy8Lk=", "CN8NBKDY0bK4DyGcM6kmZnW/wIBTLp5mQwu2fgU2D30=", "DTnvsQPgMvmGyHXba59qZ0jPrrMzyTrXy0XnVer+SMg=", "BfR8b9u9e05ZzHh37q9jy4wWxN138hRCjclLmywCFOA=", "DuEFGzMpLYp9w1CRa2JEB0Xy9HmBchuASW0qrgyf8og=", "Arv1jaCHIwRjqYshCCRFOCOu2DD2BDLOMVbFg+Bu3wg=", "FnTlvGcOmAKcoi1AD/wZpCADUvsVLHhNqIvgtn/6FKI=", "DjCndMNTosvyRNPQFNGg5f8LrF4kJnOuM/G7IDD+/2g=", "CKHlXePmN/+msFHuM6sgNIMClYTa8MV8RUu6MM9jY6g=", "DltEl8OXsnynglStwMZqRVFJKaPcDP4u08RHpdOSYIg=", "C8z62C0/vsMp5oTRlWmZPIVUg4FPslR+e5bPebqHVhY=", "GQjHmt/a1MSu2iKVqdtWCjPpGwEFBEhJFjJwWxia4dY=", "EplWXb8lR7MNtQ9d1JyoNcMhPuugEw6DWupK3WUDer4=", "K0kG52Xx6A9uhNWFLzTaiextmWxKQKBmxotqmBAKL5w=", "EkokewuGbAnuXTeDvHFd4yRFmQFvD744Vzj5XLXcCig=", "B30brA9bImYHsnZdjUgRixxVOAxgqqwuwJQK/QwFsks=", "KsQahCeT9pPc/768XAjta0rs7n25VuxZ3cIwp7NXnB0=", "E30yfUGpxuQuILtwX8PaWigskRyOennKtONmX7w7Ups=", "Lb0f6HIEq+L5wnqDQ8clepPngUUdjhWf607xLziyjlg=", "INnLg45FTphB3dR5Lk6nuPUc19fycdbjLz+pY6bSzfY=", "CzQnBmMDnjFfY6XJkuMdXQlFEiFQT4WzfhSABn/pIXQ=", "EoJuW5vhybhffJiqypziiocGh9NijWDe8KswcrV7Cbg=", "Iv6hKXpKXwiQTVVcLhXQFhAqTtKcMrS7EICe8Ur0LHc=", "JMxnUYlAh7gxWYtbx/nbPLtIzilNkgjhqkNstfougOE=", "LMPQUDoOHalSsIG6XcWxF+ZGvtVypkUmbG7DzgoUdLk=", "Ee7b5aWWnzNEZQNJS0aaK4P4jTqkd+XW15Y6gzOmExU=", "GJrp6bFiqxoZ1ZnO3O9Ci9EyXHh0CqrWcVtxC/rEweY=", "Gq0RRJ1uLG4a3PnokRTDNsAUVSjzVqwEn1L9jLCENwo=", "DX4eriz+xAZALTTCWeWWb24usmHU8I4pCIMlprtmmmM=", "B5aiOtbtKsmVEEoNPmx16XfOKauh0l5iqaiiA2TqG+A=", "KZuOhiHX2MjT1ihssSazTuU7LcmjaXuDgMbkf1cRNFw=", "IPEe6B0qyantHKxh2c/fEL8bSc37ttIyhyod8UJ8GDk=", "CkA+l5lDuNL5R/btptQRcIgTQbteT7uztP4919zN13c=", "BGRiUzgPS/ZClyroGXd3lFSqCDP9o2sYIsucCXGePdE="], ["BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "DU4RghjFU/T9F/Hbs5upQu/XbNGCmL1rcuH94nHHQ3I=", "HJgUo26lfie9g4N14cGlYtzSr2pmqtRgv8ivzz1jq4s=", "HFc+KQTknGq+0gmBRZ1BxWBUQwaXhTXWvs1xBu0+Qfs=", "CeObMC7+frxDB80AnmvW97USiiMpixHrjnMEfPLy6SA=", "H8QnaSYBvu6NX2v/qj+qia9hos56BI+aWWzyw4rCz9c=", "Hlt8v5I1Gr1qcaI12dK6VL68QOaTpm87iTF0zKwpdm0=", "LuadAYBj5HUsQCwiVbJnoF5Jc2gU8sm3JHJA1h6LaEs=", "AerqkZNo299XvkpV25mbr5QLqBBStOTVuOfhYlMnT1o=", "KX93CSPtcZ/zFn4XVkEmvG3aFsjP0nqtKd+npGYDhFM=", "E6lOHh/9EcSijIYpCnEWL4LAPqJjS2fZjBpcHQaRIYY=", "Gc6ihJSxIQpAmKwOedmftUbCw1iPPP5KBoNZu2CC5W4=", "E4QUSNA7g+6mGTX01JVQNkNDbpCo76WL5HyF5YGwULc=", "LfJyrybFqlQHGI3nG+t838+HDHeLIJPK6GgACi2/rM0=", "Kf5z8U4kIMmCVI7HE7heN0wdikPCvC3bYwK++fsrbiQ=", "CQcMRAb702DsqcMA7b0KZf6PWbh2wYrhO94U4zMOMXU=", "LILqZ1UWb9ibaIIAeIuoLSlzTKGwRJTQZDuGiasLfMI=", "JudrEMDdDd4KV/m3Mb4GGuV8HZZOLlJQgeH6YIRjK1c=", "J3KY81VJabxpN9G11f3Fghs8gJIGo5MOyJTK+aNyQL0=", "KH5TqJojv2JL9mE6gh7l1QKDhgUZjGmc22rl0nS7hFM=", "Lp+FtGQV2rU9LBggIm1OcRfmzJa33f+p9qlsxpclYlU=", "F/zE1knOJpa7DgBGAXK85F5d64xXkE5coNBWyd8+Upc=", "LJcbYw+aS8p6lQFZ/0QRV4uznu3ujZ8BcbYe9/67/0o=", "CbUmvuorMsk8kgXOM8bdeYJO4BI+DugwmBRDIpmpdWw=", "DIMRwv4azOhyISvHMWQTL4/IkDm0spcJDvB+GZdwQnk=", "LqTUgWHBOt1LHcg7NmbvOIraejU/PaTIBT76/dF0K8s=", "BEfPsoHdleW896GVvFLgjXiu2eZMydeXOHPQakK4lko=", "KCjZ0gtBS4AKAor6XmHsQ2KtoBy9ZvOk4Bj5Qantwic=", "Dzfe4qjcdujMy8/FJ82MM4MDLh8/UGXjnSqnC4/td1o=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "KrFm8oz9vPwy5R/B25JktSfkDGljV8vfpr+Qvwn7l/w=", "LhVnhc7xe32ULO2OLuFc5LviunPA5VvVDriYob7c88A=", "DUZBJR1xt4EggVbKNoDWpWdvdJt1iNXbBGTHarmFpDo=", "DOXPdD1yHwQN7EBgYUT1vMiwaNK7sRw2I+tCOxAw4Uc=", "FeNYUjgaUgIb+syv95neV9jchgbyRl6HXH+eIqMYO6Y=", "B+m04IITIK+7sj++OiAnGS8uyJH95gL69EbQazp3DAQ=", "C3Q9cNy1imrMcINaAFx842aHb+Pv5QSQmwy4euzhcPY=", "EGQ/fWGBqLXfHpIesahBR2qTf8akcxhdgyLJoYxIej4=", "KSjffJTef/ijdwmA8PvjzE5PWQhTfEC551JHvDHmWFw=", "Fo1E9j5YpccTw34Gdwm8Npwn9CivXrPqp51EW50HMxg=", "K4hFqWhC+WU0OpTnbvohe4O8Hr6ATHsl6LO1jdFl55w=", "H0T7AvOH0s4U3RSc0k+0EafHOBV3FdahvmbsAo/AG9s=", "IXtar5iTrkEDD2xk7mhwvJlUJ8geBKJl4XdEAaVBKlM=", "BFoeIc0eDlspbMbgLiSabNDu8/ZIcpLw8cdC3nEqSk0=", "GQHRYHB6jt+7fUUzkUubi7BvVlsaus539/dh6zPznlw=", "An3umbgDdPPGZaTcXImo42WlqT0H5Rxyfd1qiWx++Kc=", "CxxwWKvDyk8WM9ZMDdXwaNf9wQ+W48poLRsq5uKJqvY=", "HEldZgrabDL6LxB6gRcw2Z7AHZoX3KcAHmWfuEVLmhw=", "EAiF9XZd4XM6kYU89mhWO4jJw2AFy1TK5hqCtrtlFgw=", "IzVEY20C8WG/5brm5odVjOzuNIcCNdNsrORMbTcvBUU=", "IioYCoaKWJE32Ucnbjy6p0ylBS5oXgLBePZHZ6TmZEY=", "IrG4lRS2pZfBMx4k7D9OMjKCGnMwpSVinU1+BJUP3NA=", "Ip/RY+oa6ARGh314JyznxQuKusj8WRuiXCJmHLHh1aI=", "Be+0XmFGa7uJ0IHfvMi9OYu+zTJNWVDWUVG4DBAqBQM=", "DN8kZbkt0EuWjqhBm+dGaw6jeF+98adVDcW5nngYU6M=", "Ksvpnut8OhZzdsZM4o4QsWKMw/f0gOaNumi9Rw8p/8Y=", "IcFzZHJJ51x8jLHQl9otTM2hAxzLi+Wh0sPTkv3qW9I=", "QmwAVOGZ+JzN0mlA87bo4wu3RIhtWuZnfOdfCryxog==", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AmZKmVAdn8x6/r6CdztOqIJF1THVmnoHCFIsQ3osY8g=", "HcNaqK5MlfShfUSnkBV7fycEW/6pdO9YGKKtVXrk0as=", "D9rmhpRlJA16YoBhavyD6TfMWCHYze+K6aCFOVqnCMs=", "AXgrAZqt1FTVCRSeJluEdEZ8GsIZrwWlO49nGj0cerg=", "DlQ9AxvBdIhSozPy4DHLyznVcV6GN/+hjxjWIN47HKI=", "EEmTupytEVx5pYMg+wEjP7ASSnPgQFgcZiFCnPL9ji8=", "KuwqoQJUIn5eDO8Z3Ekf+uhWvVqbAp2Sa2DN7jii4wo=", "FDlWUwg0CO3OYO308yMqlhTHgc/X9v0YPuIuCOnUba8=", "LiAHBOSRQrtosg2fffBAob0yEYsh1E903KKzGBhpMBI=", "J5d3j47S6a8/x57BbySLYgnAMDan8NUGYje++6sW4Rw=", "JeDkA7+7sxvoxTYAB6qfLjak3EtbKwgj+MvUNJlwujU=", "LoQjverQs+4VFuxsXIFsfqMASkWgRDGSQnu8RBUlF3E=", "KjQBXSEURlL3IvFBOFugUQzTjaiGvA3zQ1LueudqB74=", "Kj/uZS3O3JWgtEoHKqpU9RVbA2siu69+rwucPN5C9Mw=", "E1aS1HxaDU3wN5SaVPxy8jAxT+ding3XmHtiDGZUNQU=", "FCCTxyjqNu3whE3l48S08eG0S3KkE7eyp1i1vkHI1hY=", "KgtFmrP2NlZ/4PEzDssVRT9ippk7dI7at5rYzdDVNbQ=", "AzCwpCgjVSLh1eRyi4gtVqgs/akEUquRhxJ85zZYqfI=", "LESyKuFboPInYwBOj88K9sYCoMutxn7/cKdAALZwF/k=", "AcaMBNyl9yqrYbe2AhninRGDyNHeXHyMCUYHOLa/l2A=", "HHSveMoESFMbdzonxHgAys5/huaOSWnSmooS8bnVkzA=", "FOLr/b+cdulpEaI6n5xwdrODFjk/4RoKdJLmBex6nEI=", "EZqF1ASLdsVvY2rPzn2ucXWYKNcR3Wso7Q6aI25Nj7M=", "Dem+eOLjw0Sgt2oXG4184aHQXyV5CiRREC4FqRRyvzU=", "HpHNJfEvLzz/wkkHc/ivcH/hpoQ6dmo8ROtbj8E0sAI=", "IJVsg7JLorsAhqkfWX0KkC8tdOUyFrvZWS01xDhkgGE=", "DHFtebG/qdAW/nVSLXcUAPzXWGITMEapsQEVQNIzHoc=", "LE8+YdWKq508EKvEZW/qST+z1jdHCM2y4ISmfi+26mo=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "FXYjk+6zNRZ1mcEwtLbSL8PwU9u692NfOXAWg/lkLf4=", "DXV5NhOJtd7AxYF+V91bd1xI+sursVHrD34tpa4Z0Vg=", "JlueuC75u2/i9wzPUWvua5vkARg/CTJ4SkCmEYb0ekI=", "CtfcjZ0LKK4wRrjyPDp8thQJDgWjyew/6OL6s2ffInI=", "Kj+Hg517PgUo57nCITeSAzVDBONjaE449fvraYvLGfc=", "KDTiENIRrrOVrgUZj3ocR1vhyw2JqMCHfY6IqdYvxeo=", "CM9q8PjHAX8N4c9uppRwCcEEEWnVtXxJk4pqTIY9678=", "D5sBFckJfzYND7YksUyLShzv+FciChgdpMMvYZsWS+0=", "EJAtF9uYIylM67hwb0TodS5aOr/YIYrCdxikwPyKRYw=", "L/wX7piEjYeO1DFePOAHZntPGL1DmT5Nlp6cs42NEY8=", "D4ePCk32clX4hCP/tScBRlZRXq6i6cw2vpw3E1BB/Zg=", "Bd0+ZmcBdM28dkzgcRxY9CfcUDx5jikUCCAFPadpTSY=", "LeSezbARBBUZQ6ziBe3MgauRqe8q9MM+4qotCLrWwCM=", "LLmjKExxilZtfbMJqgzm+OYdumSiJfdGt1fvLq8LkxE=", "HRyVk9DE6k7ZpJHcc4IZac7ThhRc/4CDZLw3M1zPWmk=", "I6KTca13YNXF3krlAkpGEnQ/p3sJ61Zsn0HSFslVKFQ=", "DuMMDKKSw9u83CRx91ADZTGwy4XrhGTT+SRmAIq5Qkc=", "Fyfw0YtCIBD5cFj/XorCP8hQlRd0tDGjj2Ch2bVWAXU=", "KsVFe8I2+JRTZbgoGD+CZuPRtbPcLZylL+us3N4Rtxs=", "Fm0p6tIlXjVsohcJabe5uUu9iLs0rX5WY/TTolozDuc=", "Ljhs2+5GGZtIKZvNDMjsSG9sbKrbCHtS6oblHU855zY=", "B5N7v1bvdHv8FUPmz1xlNDToWiJfCRmc4RdH2l1EpTA=", "CunZhSCYOQtKW5oHXTICCl1h0KKgX8YDdAiEDUO9BPo=", "EYG14An05Rqih+ET7TvlgSRWAeonzks1IZxzFwh1aPM=", "AkdaBgUtskli2Gv+gE2z9lIFmE5ZZsGoaVNR3sSHthE=", "HpUwqAiKPCQbLlztQVeUlWWqkEJeyLSU3vFVWB1uENQ=", "DJw73XLDRC0Sc0wPO88r0bxnnPj6yRJ6v7MW+8rlMgI=", "L8pg8QksTUgWSi4sgf4TTLS+pVX0Vp4JU4nhgaTOtew=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "ERVhThniELWbSw5wgTDdhFvlvuEaoc5DmEzLmb6zYkw=", "JmQ6LqddEDqHtQyhaQpVEXNAqz9P545j+BGH9Yo5I4I=", "BpnOPbnViCwEcWzXS8ScK81c+jQDmFbSesc1S2CrhBI=", "FH44I1TNG9MLszg+/wP4mXSwNaAIl/idlUXPUB7PskM=", "B25oNwzrVcypdXdlsMLv8eBUJv07Hurk3ivZ9JwSFwA=", "CAZEg7HuNzP2tuna5Hp97fe6qbZ/+Ecc7SU5X6OM2IQ=", "JiJdtNeGDoaaAPVPoQkjyAQc8xPrkSMYqvj0+JdAH0Q=", "FbpBzk5OCzxmM6qDGA2rUioosliH946Ky2G2z8b4N9s=", "Kb+WkqH4yQm/HQ+sSgTeOATonD/MKwgc0l1EsK//ewk=", "KYOLOAtD/aKeS4gkIpp2KRgIwqnEhkuo5Vd/2sdaheY=", "Fl6Bv50bW4ntc5uZyExT3D/KBw6DqBjVu/7tN2MKC0g=", "EKcBMSd0IFcgHkLsvIMJm0mmCvI2X4v3zEA6MJXtP6c=", "IjdZ/9EqOePjhMdoAlRMN3jxQUnQEjwSgPu5LtVW2f8=", "Bwcpa8Xcc7cJRM+gfyHHcEJ1OkeVQNuD2RFfn+nuPlk=", "IF9daa+fS7ZsUfu9mezXEIx2JA+X91ihfmD0a9zvhtA=", "EhDdL0xHmS9NXHFQ8b2TRoYARlNL7JvLs6l3gC/pA34=", "FEzPGuuLeN6UN6qC96gv/LlYUpzFHdWig2Nf/AsKbIo=", "D5lrkRx8ZQ68v0ut554QQR49SrDi7AH86HkoxMD3foA=", "G0ahsO0ECAywaP3/blMbAsAC/D1ms+0tZWE3ABt5Jq8=", "GfzlPtrfnUy16uhv2LHGjCOK70alyjNgM2e43gknsvE=", "JrCIVnL2SU37Ru1CpAEXbyovQnkHJfFK2u6Oljiphuo=", "LbYggSR3uNczKXk3xSrgEHb1ko7At0iOhV38W5OLgKI=", "INMP4P9PV6PMbmMwGC8j/dcsJKrwpbNyoyoZ6ApjgRI=", "Kl49e5gTqnoMvSuhxCXYDoHhLeQGC5C6fq+DLwDzTS4=", "Cri22avJz3feR/NtrsOdsPfjx6MdtjGsbr+lAaSz+U8=", "FshDjC/4nBni+c3OFNw4CooxwfZdBZ4jkx9puSHltNw=", "E9Nv+yWRS/8KnBtJDbGPyP16L/n6O2c6osyypkU5x+c=", "KLjub37h2NDT6+Jr9CRujrVFFIyobmDL0L/fTpsiZg0=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "EN0yG3oRoryWs/Rxm0tEPZTlqi3b9CjTLoY9e5VqoIU=", "Bfxri3QOVfXQaQt+IwnzEtCJxFVfBXFypiFINUYKNC8=", "KVHvLHc4C64pek+8BeqX3lYu09gKqKmGNZw/8AvK0Qs=", "K3x2e0QMoN24ituGr1MjGBmtbCHCIrCaj8j51hEIJ20=", "DkTRIvkcQNlHCvw+SE7I+P5q0P0kFG8dONcX2k23Zzw=", "G6R64wPC52hU1/OZx09I36qjKHwHubeb8f0I+dpwPEo=", "EbQl2AAIEOklhn96mFCqeZqiM4GFtvl+u+t7SBpS/uo=", "J6vFkf38QVLO4l9PttCh6TKjlrcsMRwFqZqfkjsfcBQ=", "KnKUpz2hegKCmWHwzVs0xnyQmsw4dKI4Y3+1cNTCMEY=", "CLMl40awmh7vi+f8PYGGcTXofumVjxbat1m/ujSwra0=", "HYv97SWOCF/SyHGp2wyjjOXl0jLShZyePah4KQV/8jI=", "EDIbfVRmvh6Sp7jxehaje6uimH7Vc5n6kDtThdgbGb0=", "E4UpmvFK187+kO29ZW1yEm4OkHgxcwaYTyAamOPof/Y=", "Gz+GNGC9dD2kLrM+R9LP/9mhhV6f5XFnR5jTsNKqqMM=", "FvZfJNQCE+hkUsskLiCiIti9onQlG0+9gtwRCtePEQE=", "AnGq5HgpidrRn4QRfOBGalLhZVE4a0KnRVLbDG4ARC8=", "KROx32LeFAUkGCnr1rvycZUQz94tN0wXHysKOVa+rLc=", "ECEIv0pz7Jq87WUuxRyhL7BuSLXfBJueNxAs4Kd7ZX0=", "IGYD0CLMhgj4B6znwOwx2d2YwgK+bRvEek1E31S7SPo=", "KMTo5O8QcQ0ely7mpKL4iqCKDW+713y9BXzoOra3W88=", "FDF2nxlVKwV5yaI+kenwF8zveE6vC1LzOBm/1yrpj0I=", "AgxCSQqMoH2fObEecguDPMwDPh7RajENUyIod7BjAzY=", "J+m2o2K/vlPun+BxQQyoBKm7/S0uV5uVpQ1joWyYjaA=", "LpN7dPsX1jyQ0ywSWMHLQQj14/giRv1wTUQjNlOquGA=", "CxtpdMUG14rMy14bbJpVg+nJIhUuwNETSV3EmxSmHI0=", "GFVMzpl97bldJ78TXIvd07DIqtBVGm83K7pRYTwDNaw=", "EyBp7KyfJEpeRHocwZqZgHOux4DoI2yCema/n8bM+KU=", "F9QBhalFj8a5iUitfad/A1/Xo2GCM6Q68NDlEeX6N7E=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "J10otSBDh0JBo/vynw/IclNGkpyzeKfk6ejHqKwcQSg=", "Fo65nIbXBcKJsAIn10goM56Izajqcm09msu1eudQQ7E=", "KnYpRVMiC1uiq632vEKpAmQTEvC8GVMoawi6Fq5l9DU=", "BPVSIu7AGplsnExwwR9jdXFMYB4VR81H8d7gs5mb5Mo=", "Jq/hRaXJ0Fj9JaZATkrLYssT0pnegfrB3rNf+fSkDDM=", "LNXINuF17XqQL+IzTyOdSZ9RtY23O78rEYDP5MTfeTY=", "KbekkRu2eim9c2jA9CB5rtofwNRS77KxKbCtk/7ALrE=", "JY0JpH3/oq+KHdczyLCPY5Ed/4eKL9tHlOMZ1Gpj338=", "IuJkP+RRkzif15gb8ZGCZyTV/x8KaGUcHJjvAtgfGwo=", "7LEhPI3ybeqkDY9sTwodTjxy2j38H0Nw3n2tfjJhjQ==", "FLoJwJVt3f50EBknEiOGWLTWVQbHjjGK52nScyxjrd4=", "Lc0oww9Ewu59gSGstjjeurRtD+7k3OYNSUrLZ3E0pg8=", "EXxpWXKdHXdM4aj+H6KCUVkvO9YvhiU5Ke5FypWeS3k=", "LCkMvX12/J+c3PxHtI/WarVdILfi9zNX5oMZNnx/rgg=", "H0DLXFOraIwln8OivbQBEVMw87KFCVWjl2Q3Tl8rUZU=", "KlihnOF0SiQR/eZAGm8z2Jn5+pxZ62N1Uw9FvYp1Ezk=", "DfbOfhu1xB02bW19VwfGPrOulHgEP+Fn9xJ1igW0kgY=", "AqMvCMAV49uh1xk7MTYuqIFWs3D8zxXEirtxM3R4M64=", "DlSbjxJ+fueo5n+dxTT8jjpicFm0BjecY9hqVKWT2G0=", "Kta1F8ujmhbKpvz9U9O4pDdY42DHA67YaR1yGlI6wXQ=", "4ADoLpO2nXK4OFiFRkyxUxx01iVfHBFWU5yJ38hAkQ==", "JLV9HkySC+K5XA/IqE9dVgPwwoboDXFmnWAEm5R3BBk=", "JMZfDirW5hTqmlOwWGUUWflmFSJ1r9PNaSSh6ZDn0gE=", "HQrowwM1d+pLHy3UtouDYgof/LTVQm6WA9TM/Lbx+2Y=", "EsgYU2GdcPc3VErd8zuNEErxPuMR7VIt8TG/JNg9rIU=", "BQ/vtCKdD7tYdWxJsowK0P7pM4ofsjn42O8S4WiqFi8=", "HcSogVObA8obVJOllL4U69y2C8srTRtYho06ZVhBAXM=", "Hn5fV010YzoGHKdz6Wnc6DrXWOTQjDfjkA9ixfm4BcU=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "LQMNSY3SLl+bN2GwGfgSwt8ALrvb5dqS84vh/xzZfmU=", "In9uGykq7v2u7+6qLnryH80BKnlMosGNKEZhyw+x3K8=", "CamRdYvo24RcpLSI39EeJ/DHc8iMJQetWE3XPrFwk1g=", "BbPAjLBtI87fLNTFzSSFFKibCf9w/1b5AiFJIIFIBwU=", "IH5g29u77x8xYZi3nk3z5ojDxxuPguBIB2PPcptrugM=", "HZSqPU6YxpGz76rnKuGNUNkK5WYp6wDnvDJOsjYtJ+Q=", "L5n0YC2KdhLFc8PtIjLro/kfAw+LXC3G3j2Kpgu6KGk=", "GFp/sCe0D478/LveAsvhVWfWSuasm/IGeBcDwH1icuo=", "Drhf+n7l6fqWrkaXylJ+57v7abXfYRoba3FaMPm2m0Q=", "DmUHzGE8CRw/bVY7JLi3jXgmLX5qRw/9mKHKbNDaXvE=", "D+sob6CV5N7NxJ6j9X2nmbKBh0aDf1kZQeZ6k/K9zb8=", "AVfeUcM5eF+r9OpYS1XhWEhbzn3VIcCiUWAkeoTRPms=", "EYs5oyOmq1Q/AF8myJxnNIAgShg6H2jgEA1r5NVd8lQ=", "IA8NkGXnm/KeNfqc4U8NhwOOQ+wcHC1Pq8ygA+Ly1yQ=", "JxttvXu7+dmKnFyIFMWJI67W5KMde8+NcjVh9RFt+Z8=", "IllNo17dwYUNx1dkm1PBJkA6kHxhE/OelA42O9KDBQk=", "Caaj4Tpq7Q+3CXhv/Ip9VgZCpZ8s7i3Gh4ETBAdFWoE=", "DV3puUkXrd2LjryO+s5P3ARDgKJ0RuXQFwxKqWW45Io=", "G6T3TX2/RPlnBgxhnkKUhSVMiqBqwIu4+xAaTIiBHK0=", "K9OTrAxmAvY+8Tg1o2AfbE+E8JzUfO3wKrCpLw9Z6BM=", "EyzYpiWRD3+nqZnQM4AQglw1Nlk4XqEKQZJV28CjRW0=", "K8nlrVl8j3c6esLf4hwWqdVJOh4xnclC5jUGesaSR1Q=", "Ia8q30i5XMZ38lXUSuo9ETIRV4LOoIu4KlJjZrev/Lw=", "G6qJmvOmD4gzYqobiOoXd44ljT3vpE/sGz9PnBO4kM0=", "EINnP4nPH/4YtB08twhCcDY8UZ72oWSEIg4wIJ+D2XY=", "BaW+cYJJfFwuyekbGkr4hwPLAep+fY3MU11ypgYR8nE=", "D/bwdqY+342H9wtgrA1k8xHrF3HZYbazOGemN4GBCIo=", "CrgQ8+Hc4I1eUonY0yo6sg6+VqHj9s/sgYRigEsKrTc=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "A2M59wlCW0S0tBWEedoLARwaZ/yO22grCkQ3YHuaq3Q=", "JfSTQNpTcAQEsg5ZJDtOUVi4otwkrLjwclBBSUgdyNo=", "FLB20s6PTLjYMj7I10OUenyPyW8UnA3Ep02IOTnWILI=", "BKb91cBhaCaN25iGtbnSPxRu4YKhVeF10XsH3c59+Pk=", "CIaMu4Z9uJ3HiV48LAZGbgzQk27KfjWrX7j2P3pHIqw=", "E2ObLiT5QYd5EblLuaAlb0gAIQl8L41xPAiMYo2P5h0=", "JIdpTa6jftn2YYW2ulcAq9kUTBje8vuHrzpPzFuKa14=", "Bi25sXnBZ3v2zRfpurTLvBehE8c8E33GZkv0k49yM1I=", "JdfYl9kqD6+so4JAKhA0sg/95bcJ1gkqrQ6J7kP0j94=", "C8iDt1JV4Oe2IJThyiqmXLKi3HxLMCM/bgVyV7Ja3Mg=", "HpArQus3/+EIZVJgmR1PKNKGWF1unBcrbYe+jgjszzE=", "BBo7JUoshEbY6ZopLiS8GFjrPY/IQbx+GrA91fHEDrs=", "IfS51gzF7BO46H0RayfYlia8dsDo/0yq1fgl8Vj+7/8=", "JGvkGAe9/ZC3ywZiAcszIDz9VX0hjMqcz+FFGob0slg=", "E3YPg07Q5SIRttmzYIDa/gecMMJ5d37Zkogu3p/czzw=", "JOdf6bH3VDbEZbIvsFIKwa/izSbgote2R2o8l0Dhrag=", "IQqaSyseA91f0nC4MD97+esmiER2H2dHM3LNZlsfMZs=", "EzxXK8hO2ad7ZlEWK9qQYg8AT2Gu9GdnH/gBnKbAm+0=", "G8NWQe0rhFqU6TuyuJiJ0LnTM41FUD8h8f6bDAk5Tqw=", "HuHLY/+Z8kDLHV8RwKv0GNaWoLc1YK/ZMCpRGXUNrr0=", "JeWEDCq61Lk37c/B71SJTZVWd0sekh0aQ3J4+MM4YiI=", "E3ysfqGPF4Woa3aXhc+m2RmvJ7d9fhzwfLQHAnXJE4Q=", "LjllLCUcsuaokWa+iA4QIZlv/FXd5LgjzKPDBaGDZ5Q=", "A+xYyv4nCqeCRVHBlIkRoEEqSYXXn+7wMkvWOWDGmVs=", "KTuUfh5oYL2BRCssKm+zrlk3XRL4V7W4Fh4PS/tDDvQ=", "Jye659UE8hgeGRC7fu40nq6wSA0hT6/QGWYu3AZ6EpA=", "G+LxpVkzeNb8FQXlnEwo/7bN9YWaXi4btbSaNgUfd7E=", "Cx49Sg1uO91BHB+N1PJVOuhFRLhKV7Hwn73SZnDUsAc=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AfEJkYFzegmmaxNjEDCYK/Q4v4TTcVoL7Ty+vsqsrEQ=", "JJp6CzoBWgT8CKLGy8d4erocyYPJSj1QdPWE7f6yQWs=", "I3us4sBpdsU2tW+1rN0qxR+yvowgSDSwERBvA+s6KX0=", "INg8UcueKh+woPp/MsacyojmrySHjyH61iLjZKa+bBo=", "DmXfVhindMiZ0Z5qbY8KrUoQw0exKsH8v+33qfF+0J0=", "FqtRBC0sBW2lO77ayjF/t1Q4Rv5vsUcnm1hy7ueCHlQ=", "Li2LVw2pMpvfAvX+sB8rbjL7eVYxxr4p4DocDOMcYpo=", "JNH9SZ57uAyy0Mof0JA5vEz1GP9DcleWvCtI0jfILng=", "BqlrfZmyt6blfLs1UhfsuGN7w9Te0eBGeDptX2Nok5I=", "GaFD8cX/UZHZmm8UTYY17k5IM7C4CoZDSklKapcnMjk=", "DU5gyshpTOGHhflMXC8Y3dXuo8uKcKtLw+Uzs7qgxnQ=", "MGLEza9D55Deo4fluxuxahZ/MOZE5UEfklIELVFrjww=", "GzeKJdDNhh+8lJGDaqnB/BaUVsICezSsG2Gm1wkPrtk=", "IcwbT4cysqcztCcYtqSEKd83lxEgjeqmWn7qSvHMfTA=", "IRXheG7JD6Nz7hqPUHaHArO4nkwKzv8TisSHND1wd5I=", "Fc6LnI6VCxKS7h+A1+Jx08C3FMHeNLdgY2JNAKaGo5o=", "HQ6RfgWOtsuO4y6dpCC9Y5n4sil4dthNmX7PirOw0VY=", "JNmx0xzW6xnAxjUTpsP7BKQwM5aGlulUQx0A8Si9Y0k=", "Hk2uVRvKYA2sxY/TfKxQvycTBS4qSTXWRHH1hVCPDZs=", "EbHMYpchztSMNJRZWGPe494VmMEaaBQSBiYQrIWXNd8=", "Ju9QMauWsCsA31EnUscWXjaPQGhXR48Y1yMLbkocgNw=", "DYN3X6/aeVcYyp1Hd9ebnENUpzu6aBPEFbO5cPusbmI=", "IL4s2bfW2r1NsN/4mRGYerBHndnBwIH6ZLl/uXyNMUM=", "JVvNXCFao7tb2eBfS65KaOFS4xGP0JNo+rn+aeIxSdI=", "GUfXWuRRCOeobQ4+A0u68nt/5xhFHjpcIG3VoSKpF/g=", "F69/FveMe1FxcUJPxPR7qIzxXEIku9E6+zv7Bd+W2J4=", "D3Nu1lMvC5DTC83OybBdHFkHDxBSVefWD40xeOdTxcQ=", "Ij7+YXE6jVDE2PAP9pxF6l8n3vzg8Iqbx056gghLx4g=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "E6DVL6mMzlzUO8tKriA43jWnh/htN1sBnXJ5oTXOcQ0=", "BX076zVIzHZQ8Q8pP8LTkyJ9+3JCLokHLdi5BGa7V8g=", "GmUzpl52StsWN4ChjfLn8CM77w7rYnaJXHakdJmK+3k=", "GROnHA5vjIf0M+1uwLvi5zl1RMDb7XGZxfS37c6wank=", "ImaJH6XlbQJA7phxrXEHwNdAOY+MyRZaGwnhCit0DBc=", "D1ZSVnr+MPTV6TTZhSvO5+oKj8FCtIItI0CFMCISj9A=", "Bbvw+J9a5vVxPBi1erKZer2LyMD84I4gR//uf/Tou2E=", "GnvM4NY7WAtneZV9Vvmr/lqo7B/mEOlSxCWQkQRtQg==", "K3dYJxcGmMNwx/wXBs2VuPbHdQ8zisD83pHr5Aytnbs=", "G5yX9XyEtfeANz7q/s16TsPgZSGXhScoIGctWemFUm4=", "HIm5cIBk2FWPE2HGrLptc+7NBsTkoVerzc4nMcvqPpU=", "CaIt0BzL8+btLefXThb1jt63SIQ7GdDN6HVr3zDn8iI=", "JngnTeycIYDU9bXgfPtCwkia+kZzxh8JGl3QCrDmAY4=", "FACvDHd/2ZNLn6XR+rNXYWTvmzGmyL5Z9yy/7kRqoUg=", "K7LTIMbxX8gNfHj9gRDnFUA98AFUsdJ1/mQiqujWjMg=", "CRK0i4xTCDi+NRLOyNTCEHJuF9ZgsqcmvbRPaGBSMAs=", "D85TftrAXKiwO2tHLb4YE7/KM8BfoazcaVxukdYFKcc=", "G+TkiIoJLtFpEWDkOBzPqJlyN+eMvX7N+MEgZqScGeg=", "KL0wOuu9rYoU7ihBAqwqxeI2gCh9jDWHpxzGHM1sW5A=", "EQt5wL+PUogcJPTnWYxfWzARJnWiZVqxg75Uxp+Khfc=", "LRexEDErW40jPc40cCaSA3drR7hdFD4fRdWcFoXM8nI=", "3/YJNzvE7tdJtAHfHnlIzoyAhPTIFoRMKep6B83zIA==", "IURVR7ZYRie2D/E2Qwi21tHQhhXeY6XC/x7H93ZDBOY=", "GtJgbjh3cJWTaZ8koCh+K+VKK6dPNVHdsTMsfO2tDTA=", "EMaVJ2+dZXinvVw1HByrmv/er5q+39uscv+sBXtn1/o=", "EA+CCo+qC8EWW4oW9kq5uqh/x+lO4j9aFhJaccsGuDg=", "B79/H682D2XN8U+p/ziyYZthbykTt0A6T+BDHsFaV+c=", "B7leeH40x2IV29PhxUjlZGvzoGHQh61kd8+WKjz3Pa0=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Lsev2pM4NzDJBDkTxrhmwgpRIggad0T21qMXsBF3r/s=", "Ds7tKmYC0pGqsQZCVMcP1BE6CbvzUn9gP2fwEzaRXTU=", "KEs3sv0sTduyvN0FelZoDUa31p+sY7gMmR8U2xq1s0U=", "EN27QXOwQBBPEv+1/Mh79nMOoMiu6I+eLADqoaQjGAQ=", "C4fSwNq5/x7JYBfoxDu1KBJm/JIjE3XnjwI1Q1XrDHQ=", "JVw1DLJtSdQWUvmif41sIjuHVvh5fAyWCq82/pG0yRA=", "Av+3jAvqJTTWfAsGH07LnP9c3Au7m6BWezW1Q0MpziQ=", "Fq7JcNDxcawvcYPWfJac5pzx9Nxzs446ctitutNnrJI=", "LnTJLEEuLWlD37eUbID1+proclX827mMQ3tl+X/sgbQ=", "C9sfvIuB9Xz2clyVu5Qou+0EbVVd3brrArP7m6p1D+Y=", "B78VCFk2iUwj3kInHKEC1VSkW1SugPoMfm16qccstlo=", "EuGLlW9ofhxD9Qplccru6L3o19qa1eXif/rTD4M+rjY=", "LEW2Wc05WIB4jlIVmXt3dhxGVV/whPJKDSjaz+7PXIQ=", "KAXWw78N6apcfDVJRwIO+pSJmV6LqsIz3fBOjqi6kCs=", "GBh8MwtC2/iezAQ18Nd6fOwo0lb2UEfUo+GsiqbLGZs=", "L++No4t5WerLfsYVVIiDZkFlXBG4uryPEucVr/8RXU8=", "CIARZzhkymd4u5fVHrHylitp0HpJa2t7NwzsIXxgGug=", "D26D88VdX7i2tsieF2paT4GjoKy6cRPr7mYbQRYTQ48=", "LVm+KuwO+8Z/WdoVbZNDE+i+IFwUYGmfDnDn/l7P68w=", "KqBUQmPhJagtnKG+6m2c8itAr8cVW8sPHIsawjok9sQ=", "B+OpLJ68FJp01BgP/cMOise9ZZjXi7jzUwQD/NmxIiE=", "GCe/nxHUBhxQaVQDkJPmbmAEGyyWuPfh5OVQWC0eoTo=", "LhR8juRqRfDsxk3oZH6DOx7HCCabN/TimxfJG5urgoA=", "AxF/THHcKY6nzcU9xV8KFVQaNpaRYik0QWAmuxpluP4=", "Ei/v76Zpv1G1RN5cCso4dTyPMkGbLs46l/AjLlI/TLM=", "GOjlhDHm3SKbiPFC+c3/EpiDu1TtughUspqK3RU1TZc=", "EuC0eH7cn507EngYOfPt+nFazLPlJ7tmuwjTVbh6+ik=", "JIkoK9sEbUkietvwxE/dOr8LsuyyGiiGM2VUOJ1FLC0=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Hi+newkKXC5fHTfiW6fQZZa/o7VGNiEDpP8Zu6z36bs=", "AWKhJ205fuqjzW7oBHh4ja0mULFDO1WweRnZZqG4fOg=", "Am6y+suDpamN1AWg5qlHNaTATBmthHxT+/BHcy6xFPw=", "K3SW70418R9znbm9af+/xBagxFUS4x+GFBZBu6BPNnU=", "JnkqN18cojFbdtF7PyvD1qPtw8VPiuaCFxFDqR5I8JE=", "C/8nZZF3apl6y1mleYRlJfj+djTWbJR39UBrBZhed2k=", "IOmvDCG1ytfIflVMmAUuulYUWPj2tlNMShoNBxNoGGY=", "H14nDXvjlsE6TynNtYx+TyZ0I84tJCyTBJ7epLn7TKc=", "Jv98HPJTEL1x5Z0XXDw6DwaKVMhJPEAaO2cDCSK1p1c=", "Enb96xlXAqaoVUZc3VuAf2hc43cTK2JbPxpek0Y25Z4=", "D7cqTZk/E5uqDvL7IpzaMtt83g8QyQMf8vnOPyuINJE=", "FaUpSLsu4YTL/Z0rQZg26Fny05KRZUwIImGooZhqrGw=", "Gp1BBvWjDEWagHadsTWepKP6DkLLMupP8DybgA3YvsI=", "HZJQ4+SfC1gpzgbYd3A+4MjppRtRbwnffaw0ENantdg=", "JST6tSbGkNJkiI3yBzl74QomJrcel9vGbRko41i9JD0=", "BQj4INOjy14NMLSpcSqZ7dy9OtrCsTAfEj4VVul10w4=", "LvZdV+cLB/0KIpOM8QZeOsOZbfd+DBANNU7rsiTcRJo=", "JrkU9SmvGn4xr6UzTmA3RHS5mK4Y6Z798Z5Ast7dSfs=", "AVWDdYTb28I5YuAPpaYRXBDu52aB8lxRKAobsoQthIg=", "Ii5yS3gKRjd7d/2Dr3C1PLOaHd3MsOrnDk1d1t3tjaY=", "DQUL0VV4/kEXWtHnWorQsn/olD2JTd10rtS0Y7fwJ5A=", "BcXwAyF4Kz0vpv3LZ/pj0aAKn2PTX07LCEgatTWQfUY=", "IHoMNwEp+VPhWDbo+R1/veNFU/lNa4mehkXJbxcx8Jg=", "D4dazHSbCr+4bzusnoqOVr6bm1XqiBXRm+4GkVDSf9I=", "A4pw3RaBlnMf3e80FjHhapdEdVP5JNbCBNRA393Asfo=", "FQK4o0Ecc5FBQVb8ZA6KUaEXGtB1hr1t4r4uOPxkhqg=", "eYSQj4kxuTjhbJbaw7WNFRxN0KktZxzamOFpU8K39g==", "BpTZalMf6eNpQns0V7vtJl3gOSTMsDMdS8RFxCYMVR4=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "F+/EeHMN34KoVAzIPEdwY2lZ8bDYz0OLI59g34FtdRk=", "BtbQZCPWZWLvnK7wdz8/29ztcPq0ew3nh2t7/BIW33w=", "x1CxTN/ez3OUxgOTOc1GWooBAnLBv/jJGQ/+PwAY1w==", "FQANSNhccZto24ye1+aM1IFDfGU85ke7fJZe+fwcB+o=", "GxivPVPaIBmJVyiNympWe3mGZrwUwT3sRkKRAOAflN8=", "FuEp3GfVwIx5xv2vON7xuQ9iV84AF0iLQu0tRr3sBNI=", "AclY6au6HsM1I+dW6L4eD6yQzx7TFLN9Iae008hOV0w=", "CkSHtMBG0Og223KdIUoraZUUa1J+pC2fGxAI0yGkx8A=", "AWmyyTrOsRguWMlCBOKFOArxNHbIa2xqs8OmXBX6IcQ=", "B5e8LAuOCKTt3q0FcoOMI30Ngl4ja3Je+IJpsO6k0os=", "IXmInciNUJbuaRTAPzR7nZ58XNjIuZMLX6/6xpR4tvg=", "EFfZn06UCdwqg7iUDXno4cjpwbVaKhD0JhV1ZTvMie4=", "FoxJ5zE3vQBrCwmWs9ptJWLbKpT5So52PqNvlQwPY0I=", "BYi33HLFZKcDR3IeMVRN+sgjRHAdKbErz8uZyVEWX/U=", "MAUsVkcRZ8g9WKlwdkobtR9gL0W4/kJJQYLUg4bRkAE=", "KESHvaCMj7MIvZ9QtwDhB+gqx+zCXOkTYjA6KiKGr5I=", "Lh552Hnbe+uSWb+ogv46GjQ0VFGyMNTifXzINY5D3LI=", "H9rmMCaaQMirGmTY+gmvOhYLx+whj3ql68ojRsVFkNo=", "HWyq3fqn1/mLKgk1JDYdvM9Imm0rzA6h4uE6vLAlyD0=", "BcfAsr6pDphbL9jH4emAEzXu5pgB3Nh57bUQFzkpRTQ=", "DuVN5r/+himo/vSNyd56UIhQVKKNyFxmScQqvs1gfcc=", "CTyCbCg38goVp9q4Jfhzynn+4WB7Kh7SedVhs0aqnmM=", "Icdf/Bmte5Ilasnsuodo/rS26s5nbi9nAMh7jqaGc0E=", "LewvCKsIhKwAFVfxObpzBaMNjDQtTuU+TU5qvmGHkCM=", "EmErGo185D4cugRfXA/5zWH/YKTflIhHpfNSmWwBUKQ=", "DQv8lypS/XYNpUpeeKTUcEL0O+jOBGu0UivivrZE3Io=", "G85RpOUBMJMW0I4k/aMDo/Oelizyd2WIwiOBAJwIKY4=", "GeaCLe/oYoVRW97jifCKTLnoBCyodDWkdEPL23bTCBQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "LpMedGFvQqEx1Ki1ZQb7/3eEXYvdZkIL6zMlCXw10q4=", "Estd/Cq7glLp/0ZydESslbPqc/BBBCRCRIjhRPhplnM=", "CrI4keB9mxSrZGjYtUCDR53bzDqjhYBK9FMQWLb1LyE=", "B2wpe3dhHnM9HoiapZYpRQ3JpH1rDxNMzaCD9DbYWl8=", "C+t1RcGnO1F6bInyKtMyt+NDvsWqtKpndZ0b1cUTzIw=", "TH0EHCmlDmlxIPJcqqvWvodNgUQtIxQpeNnjChj8wA==", "BWQQLJXol8ffIsKk69L0HfebJ3VNyD3a3B6PtQEb70Y=", "LAXONepJ2zaZNixLS2SlumjMN1rYqt4DZe9UIZAaWpQ=", "Flax3WMSTRNUsYMN42biw+GQddGV9v5t1bKKWZ833Nw=", "JQeza2uOJHgKtLe+PCatV8Fvudou2zPD8drfOtBfYRk=", "Em6R9QxKACkq71TNFQUsS8YRToVHhHm2Axjm3MpdbDI=", "L5q0KkbM2D56cAXUVTrTQU5SEcwnMEJBIhcMknaZBd4=", "Ja65ebi6TkZmUd1EFoMyXKBoZ6YNJ9C1G6tHpz7zswM=", "GFbglATlUkmm1xFKRVTtlLwJ2+Nz7plM/mSganCyy0Y=", "C27fTFfofcXrfNpWTrcvdnNjHtkaYS+0Ikh61zK+hds=", "Au63rGIB121ycrK4hhxE8YBF+zCDe68AQP5HLZcqAFE=", "JeffGeg070/AK2vCTx5FxC2TXcjjJEZ/IW+3RW40RYQ=", "IiVMO/xjvVdYEoZ8hb4Ei6bzzS0rYAWUcDRQoWuns1s=", "HwTZFBhEruVqCKPosFZxXjR8ZozMbx/abav5SyoHdTE=", "D/QSKMHIWx9tLfbjdCK/fti32+q6faY/b5a/mzpSX8g=", "KGzB/RDzteTTtI1pltheKEtqayFcC4YtWimXL27htoE=", "LLNFW0r8Zwko5l1aoUYe0fBIhl8xuH/2uubxsTMDppw=", "I92DLJ1SRNP30YWz6LPXWcEbhs6BAt04Efx0PmKkTas=", "Eooq8PDRll/LEzRDc8wbtvT9pKXCjLfrMf3siBNI65A=", "K5+EwpUwf9UhUbYLe2dtFX7K0XL8KozIn42sfdZpaSE=", "EKPagerW7TfLgzTPbH1ltphi7SL0hbCSuto8DlFsSLo=", "DTTT0aToQNjizrxdUnpyzpKf3H7yfkgqDwKae4xodfg=", "Baaue1QjwZqn7IB0iunB9dGJk1zqVyPP/ofufO7qjAQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "FXhhTZopZyNq7aX0pN//VGk+/jUXh/AGx0PrYAqTa/I=", "KFx5M0lFvtX1wwfdZUEM5tYJPZXcpVUBRpldeQKK6wk=", "ELX7vv5IIWSh6cMLtGMYYaEkdhhuu6YNpZqBcqJPvE4=", "Ac27Q7h9dtQg/24a3vGt41Xt+XoWRhB9RJk69Ha3i5g=", "GXM+q0yOR3nMkU8HWY3zuxwqygT73VoRb4ZKhfeoH+M=", "MAnu7+iTprBKLVGgJ7Y0BhcMMF1SXluVngV4JXV6j/Q=", "L+bJ3mp557sjQqDAmSqbhIi0v0PaDOVm5TvqS9JOYBg=", "LUDyUgpd86gN2rA9uO16+Z6gVOOhWcSj+2/nmnabaFw=", "IjQOBYMprFSPZ5Qh4XFS1hBt5zk82oep9zUc7dJkCM4=", "BWCdbLC8KgA+8Cs/YpAvUbSbvtcv33JGde3iOUMs2yk=", "CkSByIxB40ei71/WuRV3IonCyQuRs//zAYRNq8HFHNo=", "FK3oEOJnkyxAI+9v6mqw/FYGPFdAolbInnWhcmT6KJg=", "GZJSt5RJKy01vurowUEb0bUXfhevZcb4bd0yYcL4mZ8=", "HvAUKn016idnEsG1uG4ThiAcGOP3dDIc9ptqDS7j8iY=", "JM8Y/dcJgGfr5ocx/1gPfAHeclGBSkZm/1GCIhMKovM=", "AQh/N7GIrEri4FBRoFtg4Fed+PQiPYdHFqbCUati5bA=", "Hwrto35NHoEVAjm3GkzaBPDk2NdYjOaRch3yj+nxjGE=", "EYRWPqScKGk+yAC/U9YQAEj77VGOExetkiwJXUhnePc=", "KLsU3kyqjbgE6c/Z6SzekBHIKeXMiKcJ0XYWOMiKBZM=", "BeHykOHNWO/s0YvbFVdTVrhGd6WcEYtGW5Zx+BY5eD4=", "Jfeg0M6LQPiwLKY9+pWmjjkd+fbSQYDLPMl2tM4E/BE=", "BIDMsWr4SyGExvW1KaPY9ET4PcEXgaEGrhDaI/YVh7o=", "BTkpb1t7cAjeRdXIUW+pnbGPGoIlKdMmb2D7uZWdTu0=", "HkJBU/rAYAC7rcFozSjCRWq8ewvpXridjfx7m7p1dp8=", "CTLAPBD8kSoTQynzMPgZ6NYZqoqbb1JZngdhujLGDgE=", "EhH2xpPh0N6nKqCgxQXc8fn9VuFlRcrggY1VSTdHOQY=", "BCO8PNdiC5GZCNd77MoUNzoP1ePpukRw2WfafuZUeQ==", "IRjL7paWRDDkeRITLw1vHC5v7xwAHI9Vq1kQUhI9BPw=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Hx4jdPDxeEYTPduH+lRDDGw93JxTIRHeAe2jaE85epQ=", "IIt2tnMvLtaB2KufG1xRDIhnrJdqP65y1fnYhnanWn4=", "H8p/oa73guX0IZWnaR5zuQAz3zhJW5Hlw46CBCZEaCA=", "F/E24zRlhRC/dkMLGFhHlcyL73oRwzphtSWTOazKM1M=", "LANFbIGl4uMqr2/08dVyBnfJILzkrbmdHYmmBhjaIyA=", "Gl7VEOblGAP9cgEcLW3kxjjVHG2aV97gk2gNwzb1004=", "Aak2vGd3wtpxvOMfb71kaj1iqBVoAgPtxmrNEUgTICk=", "G0ph+ttGjfU79U3JTpoYkvaeaTomYjtsdoybbwjrJg0=", "IgcszBiaZp/Jwd7BeN7iLmgQ21H7B9LhxKuiI6ifJfk=", "GXDRI7Ttjov7UMgXKEQw6TSfBC5Fb+XVGPSZwHH4lDA=", "JZBkIhJnr4uqJeA0xyYWQXLorAiJ89YtKe8FrPli+bQ=", "IodTC6dgM05GsaSYYd1UL89BUSkwQXEshUSkZ6kHH/M=", "CEAGK7Ay+pCj6q0CX9R6Y1N5MTCqC4YmVltIA1eCqmY=", "HVVfO73WRlswt9oOy6mJFiTW0EG7eBJkqJqnsW00bAo=", "I9TznYtHjZ8/6cVoUOsJHm+xQyaqXLybKw19h8KD12M=", "KQG4pY0HrffDCAwaNs2dcGUq6psHcC0HrQkj11jNuUk=", "LV/RAnGtG3+18FMQfj52nNNQntTVAb4Tz6FCG1OUYF0=", "IHw7EG0zfjNi12DMQc21vgEfznOOX0hdK0a5PGTPm4M=", "FJLA7LHbz6HGY13j9rfZ7tZhOmAtRP7kcal1e8e0KJg=", "FkTTNTVoCMgW0EQZUU/17DKN+53feOYjy7trILTtO+o=", "Avpn//AsfTygAjidVMbvxGh9qUcI9uJ9G8WCXxZMv0o=", "IeHKCBdVZLJtaIICQzxApBm9ryULgyIp9KHzHorOVGQ=", "LO8t6FwpI0+HF6R5MfPn5dJt5UxACfDPvtV0Le+zvec=", "D5EBJ1xtgsWFuwNwiGliahsO34V6pTa6EFcz8AQ+/aM=", "AT0qyMz2DHVGIFDI9EHh75LRuahCw2v8gt3/ZWHv1Js=", "I6fLruhWYwq8K0I3Mu7rwew+BxOR0D+cm1E1HGeUPls=", "LT0e5dOv2hr0nqUm2PJQQw5hkhuTrfByrFICtf2NDzg=", "LECgeS4O7IqP+LkaNoNf8HdOEePxMSDHpqDvu9bvHw8=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "DOKsuOlXW61EDMksgvGWlPHvHl8Nwd/IPDntgJGXCds=", "JV6La/zXPyDmxL0/Ye07i9F2JsXlqEOFgJOn71XrHWE=", "BxdW46aEWZOa81d/d1Z79oi5lrR/AAPEUJ34M0WEbBY=", "C//jRGWJs+6mrBB7MRMH0g+szHu0XdXWhJz99+vOxB8=", "GHh71mbP/S12ubc0Tu2ONP64+W7bwThIb7uizWKMpLA=", "JN2Qz784hh4wfZ3P1VB7Ipi/ayYY+pfX42sHaQ+nwTw=", "FBDbPR/xdQDZCLApVSv7XETjythbRNi3Bwpgw1m+er4=", "EUxdgPak+smzlieI3AxUI3g1LrWTwM+INV2MgDLv3qE=", "H6rk6qJzEO37x4K0DGuglpd5yBOAfYFjCxktBT1NXHE=", "HGqSF6COPWtJYc/IOdboIY34StBCIZER+A0GhSRWZCI=", "J3mjFjO0HPEdmIs1YPqgPy/vBqwrWPiNifxfOG8otvo=", "H+8zoTPccW2Ed/bACFS5u7sIetOXBOKqwS7CJRjKQsY=", "BR0yF7k0q9AuZHyc8PlkKyw1r4hrKkXMe1D9MmgXWmU=", "Aj4pdrh+v3tkpaOsoZJr+2F0Tg9Pg2DfQFAPR54FLhc=", "Jm1PVc6eIYOsI3wcuCoTjP7JtBV2l0Ky/rV9J+unAn0=", "Ig7YIDjtsH4PdAksgJ23bOAa31M6QrUSAPZ81YutoNU=", "Fzm3cVuV24GslsIewf578LxnZrN9BXIGZ2bjTuRFAOc=", "Jw2l52Ub4ZfksgCuoSzIuIxjPUCGoDIPvXslumu2A88=", "BvbbQRoDlJ5rtcCiT0mWfx6znDXq4BKqhz6gs0R9b1o=", "EXopLNg86w00HAHmVZD0s4dBw7pRwNcX0nPdquXFnL4=", "Jj5ILfA/lYsWwhMLnOqbdLR+5dfwcO1aarhJB0OG+GM=", "KAP31+PL31vpMGoyqQtYy/xUkNHXRgnL9jhEdrKSZcs=", "FCx+LC6RMi3pBbhCDtMtb/FX1k55KjjuKcybMW/Oo8g=", "FH17+y2Ig5cUrMEIDZNfnCiUNNXQr0dyaZv0cywTMj0=", "JL3OM47jSK+CpgyWCAAJTVeU16JgfV88zdH9T+e5VYM=", "EKCnw4UG1BpS5u0MThTcEoOEi+t95z4OktSgZRIcJeI=", "L1FidAyvvF8h4QpOrtNqwzGwRvhGxGoxm1TZ4iBsiS0=", "AsdDab4Df4pdmFv3ix6Jg44PfBqoRZebbFFCdHoLxrA=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "KFgKPXbLisfU3tMu07cNNLp2HgsJgD8Q0Rlu7oEsjmk=", "Gc8VzITefIelmkTQLoP4gSC9P30asH/6yHihcyD0stw=", "If+3Fvn0aI9HfSsDv7TE9X/DfHW0b4X/PY2m4CgmNZQ=", "HF5WUu5cUfdGY7VhLQDgAuyurG37JtFD6PUqe2LIE0Y=", "Awm+dNfqeauYaOaRr81T/dZZGlyM7flloYlSKe/1Sno=", "CFM702W8/MpEpitKPX4bCWO6mQ1bxVd6ypDz7a6OMZw=", "DnuSf+dbPjMiZR+96h4B57W5owIuZAR205c4oBbhFyg=", "LAROd+GInJ8u+p0hf++xADl46uydjJmklMqca64emA0=", "FsooycaBXUfBPuuKa67nl6L5/o+vzNZbxxTIFlc30XI=", "EOKhyI/6T09Y72l0tvYSw3dVoarECACKt7O0cWCSVmY=", "KvCOQr/ja2p5XXjTSk1L+7onrcEKFEkg1XCf3veXcwE=", "ExK5rEDO3NxxVMOhEIAyIrQrKw2UTOcwipkgdMD9wlc=", "HcJLdaJBIl6RMia7TkPUPH1Hvk3vA/0bVp6s9yb07Sc=", "E9Ok/jUo++QuxCPjZ77QUUkOGwFO3mt3awfY4VUJ2II=", "Ay2PDPIcaX/714jz9j7o/cHc/Tq2SbOcteEaa9KiTQM=", "KMdYdpKXPUB6EzsvtVAu6aUaRnFWj8sFQ1zwtfvmn/A=", "KOQDeCVuPL2Kf4yv2+0gIapJ8Bp9cFaFi9PqrB3AU4s=", "JdlD4G0eFBzDm/YfeeevLXHuk7Nh/HI3otmoq8mGBWo=", "FwgURBia1SfVuEWvKpffjHpCk/SFtIP56O1wIRAvZEM=", "HHlyn73atUHS7Nr7k/qsHbGbTegNBrlkz0zcgeHm2nE=", "BFYZtusn7LVaX6hliV5LsncS9OlahK+b1xe1jlAN6Fc=", "Diqdtb3y6B0DaUPfUw2E4XQk7FTznIA5033YXvZePcg=", "LOUJefaUTrREmKEmXbTVGt5R4YyoG8acAyQQPNQRbWo=", "KnfeGp0E/+O5Vd2zykTVzeWrg6yjBXrSHSJ1Mm/gMqM=", "F8xkT7qeOqn/LLaxOGSUxnB515BNXQKCioTxAHmNTs8=", "IxsOXf/hcx7vA0LXKJJq58nRTPMrGHMRWj1HsjHf9wo=", "KXWspn0IGwTk4A2CTVAHoC9HiRxbDm10/kvcNqLD3DU=", "Et+6DLsXA90DqjxuQ0wU5QzglhUVI4ChS5e61K7BqNc=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "E444mUUTv0zaUmu7bZp60/pgu7W4ki8/qIm+f4Gsxog=", "Izpzf3RKb4vx/U0wmaAFtHg4k+ggNAMnGsFBFruWvtU=", "HIr2FwiLA+3RHiaX8/HWGupSfrMSRlp9HZcSBUfl7qw=", "KeAoq9NZooHP/Pjm3vc7JDyMC338eB/hbYXJY2ZHtok=", "Ec68MhgxfWo/yZ+iTAKXw8kX0seZU/5rGVBDwe8qKRE=", "DZ7/fWkMpt6W/Y0vdX+r/wHnz/X5ryGjMb61vzwrE4Q=", "LBCuF57ENhRNWRtYaT1IhnowgDAt+PIh9kbQBRkjOsc=", "GVNA+Z8xQtWKg3Q2i6ewqr51Ub30yEEUxUNzP9QWM6I=", "F1oxdXjyaGADIUFCtqyHUCfAIVcpBDdmlPhGnqLaXDE=", "Fv/okngXiMdWBp9gr0mh7azN3RJSsK3YT6OFDE+AAC0=", "CC6hh2yzgEiMcPfNycv2xJSj3G20SbJ7KtVVAKkTJnM=", "HKx9fXAnkyGXNDL/RSSKRJdUHQfJorJurCk41mHu7hM=", "CHVSSRQLM2dJ2kkwtqgvb3GQ6wXH2vKJSK7WAEnQD3E=", "IH3p1pcmUVr40GjQ0mU3eYJGV50pujK+LcIXXlPN0EQ=", "FAXqyGNKRKNRl6ZQOgBURrSOf0FSEFIxYsOaio3xWCk=", "Ivh8mXzRvROjy7AtPVNMiXUok52eZxT+DGEcZz1n2G8=", "FD1A2/jNeGrlsg/ckkL862IktkwYezanymZInIZIkpk=", "L94LdwZ0WH8b4/62GbQnYSX2Q1GO9xXmlCE+MTS3dz0=", "Fg6mEQsQ6ePw0UysxIbAuo+b7DSYAkJXypbFCy0t7Ew=", "FbhBjcHEbz9UbXDZg7wyEi5AaCGFaY9/Vn8TWQoazmo=", "INnRDL52elOOypviJydJRAlLnp/AG2G2V6+99rzf8A0=", "EElSsTiRySptfxxcupg67ko9+zGhdy2ZGSqzQ9ToUZo=", "AQcgng5BSg5A3/vce1Lirj3gTkOFqMgQ6S7SvC9nQR4=", "G7/xVmN7qERNhnmr93Zoe43CRi2Hbxcinw0LYrbq+cU=", "Bh8OMNiuyiMa9mJJbBpKX0xrKDp5rA4Bu2d8sU/ag+Q=", "MGK2HRPpxtYUcYM9jmtS+GaVeDFIF6wo1lCvdRLiOGo=", "FWock7sbsZxG8tYh7RAJGNnzGUIheISTvghkTag+SqA=", "E2ZYTMqtue+V7ED1PpzHkFIEQAtS/GucDSFnL6v2V1M=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "BycGDwBKEmgpSFlWNP+3THNRrrQB+MFsMaMzyGOMvO4=", "C0Pl1iDF8BvlpaMZO9RYpu4ZZTOqj+o+++1kqD7y/5M=", "BxGRHxWtcTTLn/lwUaD3PzRrS+P5dUUI/62CPBHmBBU=", "BiwRirC57k+B0S5w11Hb/31wR8iVrsXYew4dv7MR+b0=", "HtyQseJnnXthBAsnLS7PjUcUF+Pfib5xXVqFpnWew30=", "K9AmoXEj/4LvanReeGzjtpFxxz8ApRiInDIGdaSjGCQ=", "GLmmRrgnnzJC5AgAdSdCCT33Ba79wTDpAwJtfm83cRw=", "K20APLEGUwhfTKFBuGdKJXFA5K0CKm6FpWgc0/QV888=", "KcqWcEC7Tvb97AAIo6GCG5omgmKavGwvN5Eb6DxNe1E=", "KcX+WFA29W8kvygbvjiR1C2GetjfAxdZ80WGq9Q0HMI=", "AYJQRzw2xrL8Aj2fmA6RF9K32BU4ZhPPUYpdXhzZj+g=", "Ieyu0sCEn0Rc43Dbv/eg9OOrRURMphStgYhWsFfQtVk=", "BQ8Yuto7cmXSGU3PRSYgaYJySKH2j8zYAP8Mj0mPz30=", "EFbQv44cFYpAP8uoHRsl7RDOe790NqD4KvU0F9d1jac=", "EOwhZ3N8W/L+UP4cROVipPpilXbEPDHCoGfT9+GZrsc=", "B41pUGnFodN8cSmfP1ZnUWt2pFB6QyARftJrO2wF7+w=", "MCs0AAuKTF9BFFimwSozWh4PNFvQEsA+mvxiyPwH3HI=", "JREBB9lLoy5HM2+2SkNOAvcj56Qp6yO4QTugNQDFbn8=", "I5ya0jye/Zp750ieShJAhwpgXFuOhAIfO6zoYoH1/m0=", "CnHrce0c/CMWeAT1m/UTJMadGIYC5zLlzFpuP3NFUDM=", "IvEgKN0By7kBQc/fVJetc0A0FuQ38GPhujkcwYvAvF0=", "HSrU6nJAovcYQWNcUut6dITLl6vZTHC9sYdyTbMclT0=", "CvxoM2Jt5HPKCKVTimSgbPm2BCQvApxOxXa6ahN2z5c=", "GeAbP/09HDABfLs+2N/WCDj3DgAXc1WPxKHJgYvUwZc=", "JtsFuAqQSmTbICl8xj4tChkOyfz51Si524j34HnKTUk=", "LYKG3+uwk2WFnlJCkWdoEpGOvNK14lExiE5xA3pd73I=", "Dzx21xpCIQGHCspzZn6tCzVej5qACaoplBKT5cwQXQ==", "LHFCIl3Vo48yk0nUvtbgb1i6ocPcMqar0Fe6s6Re7co=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "DUgwciFBys56PViFZxF811berp0hXN7A0sVcfdKTzzE=", "CCa/YlcLWl9heChFs0mBC3pIEVPn7DO7NmfkosfOSRI=", "C3TaWZKNbCKADtwhIgB3AUe4/L1dQCF8uiwa54SsPGY=", "D12g0TkM9dT+rSrk5GP+1x0LHVCVQoVyAJAip1UIZPE=", "JwTZmY4eF9WmHqN3sbeO1tfslRr+r/UjpAZiSplEfAQ=", "MA+CKqS5VupDq0WwQ63JZ9QdL31nRF7M4b/TJZ5i34I=", "BD8ods9KmzOvAj1Ee7kLY0s3/WpDK5IOLa1P4bn3NOM=", "INmC/mVcN7fARqBxEOV/qGSZOeN2pP0btr/z8T+I2/A=", "IdbLqDF9rCZMo4NjC02pAhTYA8UD6lUgxbRN/+LBONw=", "CHMBiWO0CENHrYGwhWk8/KA0Wrlj9laJDJCILPxdyvI=", "HmF28sjA5qy1sC9OVNJF+Aa5+nvBJrNDW3nlgZ+oyc0=", "IdRAyl5QnhrgR2rlRt80QU16v5FSgGtMeZF3uHsVP5A=", "CFrDIaVAfX7pSLDK0wP5J1FTLLG1X/F+cmfAyYIbz4A=", "Il/GIIvBKqpd66NoiTGivIYX5rSudsHeDoXe/jji8Uo=", "CqaEfwi2HW/H6nEXibdiVdFLatfeiRJMli/lf1NL6Yw=", "C7O/bckiuvHXqfVVOW148xz8PLvFNMAWumh50Cz0AKY=", "AkEYtAajneaiIru5m+GCj51wwkzOauRSsgZE86ZzC5U=", "I/iAQ9z1AfBqm6OIsF8cFLopB4uXjn+aOrpVywvxp7c=", "Hp/00JAhX4jZr1O79XKC0xqDWooFLbsZtcCzZrRRzaE=", "Jv95ecOL5xiwkoQuAs8STRzsErQmpe2DUbgyOF3e5AQ=", "Bi7teulFiPFJkFp9FI92PIQi5+C2v1z1zq+A96B1T8M=", "Ldy5ORI2T3UBUEQXQ8Mt/Kh/ujvP0oWlzdhUzDEqbX8=", "GmHIEqqX5dxjuCfbO5h9dZc4gmSIq+zOBZKvbnKBM20=", "CvJgwBddwRiK0RIiNosSKh8MtfcdXfR1F/IZB0j4A84=", "BsVH+NNo8D7FqgBpOoXStMxWqtiABqyh5Gseq7hKXVQ=", "FaBA6nLvMlKBb0U9qNyXqbQXAR6aZbCoYGJIWR5ZcZk=", "Lgroa9A5ZU/L+HlUUKNpWBObPglBuYd4OVuOy/O0DoQ=", "Bxk2rl7H4Ox3dIXZQAqMQUziM+BzUqnOaDrkGUM0HJo=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AfyKznXIXm06dAT+ArAxObamfc/i0U968RzDCiqOzjM=", "JjgVsqgLceEiKAGsOb1E+vI9DiHS8x/SE9MAaJpyDY0=", "GpH+OK2JgYnp3X73dVkYWnnYBIGAj0BE2q/tA3QtP/c=", "C5mmGSxbv2GWJNHHzH2Qkw8f+3mm1M0UW9tYqF814yQ=", "Kd9bcil5uMnGN0PF2Ze3INH5OO3v1ac1llG9zmDDUvo=", "Du/6XCKJFMA9qaLrX8kvIyVLzegsRZyBJmIj5vzT2Jw=", "KzZHzjdM6vsO6cT17Udi23JA1FpbAfOHPypMi4ami+U=", "IeKHLbdxjpcobCI5tbchpY2JyjfUPd6B1c8ElHfdHHQ=", "FzkJrJnMw+zRqy+4kkamSK46u+JRzpwBYLylcSwGJq0=", "Li/SUK0xsPVD6VjhbBCzzJ5i5SwaQOxeurQGHTiA3TI=", "LcfNgm8vK5Y6GAtaD7G10g1KfLyGBnkmcUKnB8a6SNc=", "DN9ijeawvCs10/mgssrEytJ+fhlmw5r5g9Y+FGFZK/A=", "K/L2A+kdbu6xBKyRQXmKzNUl+j4kGxGCdT1P8/WbFjA=", "BJyWdrWVdVvi8yiGOTYxJELBwHUExb/s15Ph66fD9nU=", "DR/U1v9UKwYLO5Dsu4JfD4kIIBRL5L0DNKLq+DOcmvA=", "IgapP9BO+n55EwwKrFgvpQxcp9rWFDMSgcPUnuTBxn8=", "G4sfMquEB2XLYlD0ycAZ2ZT6WFjGe9WFpfSnZjFD7LA=", "BVy9XXG3h/uW+rRMjGoerzrqUFxnXDL2CK4LauLnExk=", "JKY5YvpjmSjpAxHOhG+Zs1ITVotlzB21+mVVWgFB6p0=", "LUGDXsnI3ISL9it4Sp0CnPdjI2nTtun2h3xnFJWDG8Y=", "HD6/HN5HQE2yxSPGgOo99gZorTe2f+UCmMYyt3vT9iU=", "BNkgMoVtHrKRQNmCWmz/zM8A9f6pG4Wq62jUc5Gmf0Y=", "E/1ZzcLah2Y0Pp3HjQYEx6RTxKRjnx4fZrFUYF3QDNQ=", "LVai05o9tiDXsXK9dFU9Cc+tqA/nsfK+8/xMwRX3YSM=", "Doz8ZjRF3IHNBrCE02yF2UbG60mHGt0mPOFPK0d60n8=", "IjPg0Avlt6d9oZKl/dkdtfGWcF6gdU5L0dtaNXszUJI=", "FT3MiH9dyomZ1Rrgb92hZdwD4BxnvYeQMWvEZexLlhs=", "Hj6jQGahcBFPDHZXNFIDM2CAkBK7muTCS2wftHbV1dU=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "BmYrztCLFtPTpQydvKB0PWbCsNUGDGiYPYRIun4Jc10=", "IHNX+nDkc1jk35Tg/ihguyreVlRgwvKsmWhxi1Ev12E=", "DYi3JD5LqUeYWrBnOL/bzXK+dcBTn8LGXgFmEs9IoKg=", "KQMvR4x7X7ER+NMnIKvB+gUGdsWPeDu2dAtYdiEVJ9k=", "H1iwClvluvnh2hINjbwSp2fjBOtjwMBVKO+tK5X20BA=", "VkXQJ+IDYmuKjBVwfK1/mVS5Fb32IKNDgSRwxj1v1Q==", "CrVyQg3+h5RRWo/0/nGwg41GpC5jtIi9vvLGchZodY0=", "GHbBP53l00HiVLPSxLyMJy4nC1jIY/+xYySheJht1wk=", "If9BbAD25HjkcPd66tTez/OrhH4Fjma7VrHHU3nWfVU=", "EEBW1dd1dAuhUPaAfSUWB8UHL8ttIEs6kmRrdvl9tOs=", "KFm8LygFRTZ7OEQTSyPS+2ygfFHELuwYgAz8eVRk/9A=", "Iy93fAbKcBcdCRKcAYFLV6aFIko6dS3u/eBEh/cx3FQ=", "LKsMQU2Qa0zdg/CPzWjTs1VP2o8XlnyJ0LKB+eboCFs=", "KR3AMEcqRjP+NyJUGeniarQGsSxseLQLsXqe06+FhBw=", "EbO+kjUuNNCJShCDAtCX6Urt4rkxtAsWK2eS8SfQ3VE=", "GCFFDPmVDrLwyhTuFzhXNcDA9rWOz7TDQXMsWA4VKJo=", "LHGFopZaPf6G0viKFOZv883l8aQHL9xekDpTZwEta8g=", "Gfi4hDG+YIFI7MioYrBDxmJ3xtJE1LybBjSI1HD5HFc=", "LgdZfOGZ408akH4TXvjH8dQ65GRZBl9e9W2/raexQIY=", "IN1QiD3pIvMUEaommjioCfhq6YXaDdVyoCsKEV5XMX0=", "HetY5NsOBZteQjOifz6/1cVvt8ii4JUocP+JvZhbf7g=", "B3K4MR5SuWC6uo+cy4101SD1ZTYIuoECQ4VMowbpxaw=", "JlCK2P9z1whi0ewE5AbxZcU8BKDD5GahGiRWZWogCKg=", "LgPcGN3aLupgXzV9gsCnqeBfdNB40NlAoOdQbdfbsrc=", "JlESLlcVt9XQ05a4sKazshnhtclaBTJiPZl2Mw3Ax6I=", "HS+hp/VdoF4ud+ssfOCbT0wPgyciJi5+VxCCI78uSnU=", "IJkdP463hcoI+/FpWqCcBmRGWFjeX2PmKM/W3/Tfp9U=", "KuTEmGYGk1h0yBsET0UKatkcHGq6RnAJHPg9002L3UU=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "ItXctYt1GzPmGUHgNOxqXaIBYrRKZ/LywqMvsrsZ78A=", "GKIZfPmI+oc3+eofj3z44bPaOhMBd7gMR++1/oqzuok=", "BWRysB+Hlq87t2/ISsvafxdPVMMSnwP2s22AN1vvYi0=", "KKkcL3T3LsvnWm/sQYuf9r8IxzHKEU1mCUeOKkmPlHw=", "7NBMY+0e5orpTVFjMVWGhALaw548g4Po8NRf/dHa7w==", "KGXGW4RdgGHc67yPLpF2KprwppxNdpLWDj3+mEAKQNk=", "AvUK6Zz5dT/JoTRKZUV03X1L7DLffR1LHLTQPdH3MZs=", "JrNOY1eS7rMVvy4D7PuLAPe2v8E351lDb9DlKF+l6Pw=", "JstZ5VXSERZGMn9+ycr7P7Q0S4lNd0YGl5TEkfcbX4I=", "FlxD7adxR8FAjaQS0krBMUoyejcdL2wOPcLH6VbpYEY=", "Fy7dB/pZ2q6wTMSkx4MCdAHti0f8b7384FVDE2gF4bI=", "K8NvA197zspAAVRdn9mLDy6uhY5cSw8OIZEhWRdis3g=", "ItlrLlWIhMoHfw+pxBo4FVh1rx6R9ead3tNkmcV4bNc=", "DxFG5ZH8cgVsL6QKNbIC5q4ppebZEYBxPM+Ova7tuRc=", "KVENEUNgDL2k8jXwxsSA9DbiDara+UYaAyIE3gCdb7Q=", "HbrRSIIxRJnBQxY3XpuIiL5DUb3zuW4mURJf0Dyomik=", "GdZRsMVntlB+tqcgIIH7YxHoOYqA1TGVpbMnt+WBBCc=", "GW2XIkjhgClsqg+UP0oDR0agACBTELFV/QBxv2ogNB0=", "LoI4B/OiwtuBGBv3dhRHJSMHyMfgiPmkcMJXrYOh+tQ=", "CuB6AOZeaPBvs0IZzy8LgZ6mvxRxaKtfmCyVE6Zh4Qw=", "Hz/6TktawC+okHL7+hDRaf9c84LtVKhraf5ew7Alw9Q=", "CUMj+bd6l51CpJyx/Q9KXqJT6Qiw6W9HowjkQIXwu1E=", "B1aMYmYMkZtCldrh52Gl6b0d29Bfd95Jd+mepG693Fk=", "HSjgXhrueOCpwQyX4BGT6xdxw9yErArwt+m3pd81k38=", "FHnWpqln56dnKgHCxUG7krZ3MIw+NltzNJMn859Fk+g=", "aHKRmZb3QKolWUGMDaBC0VzLuhzaBsldrvnw3d5Kaw==", "BYewl0WDujuEk0pQC9cmAYsIEl9fAH0BhW+ywSTgDkw=", "LuC7yvZ5j4zBB9xOwxV9/K7FSfNqh8k0qD8cCAA1re8=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "B2Nz0lbWjM2yAVkPh/ZhoT1hhAcUC27CG/z/smfg2tA=", "E6W+CWd/oK8/sj6VQot8+ee4J2uuuxo5uHob3EFrJw8=", "InpyWcOyE1YS0SY4tcpZc6udaqbWozV4HYGCH6i+Ask=", "Jdlkk6w3HCuo3Nyb8psbUS9DqvOPzIbxfp1E1Z2HDN8=", "HsESBBHe7edA5+NIG5bOFJK0cjKyCPFa+yEntBGJr+0=", "ASBnyfW+KMCXTlXhknTGX3Usgih2N//FEEs1eZNisPA=", "BGLqOVj5xC0LJAa+yOOFdsiNlkWXrmHx8H2BGHPEZNs=", "IEULq8em5jfTLYtX8hhBKkMP4IdwbYjqxEHWhx9dY58=", "Cyn4h1clF9gm+XfDcTQfKBmZXmWikpwHjPSpN9xoVYs=", "J9kzSeLKyDJeQAas7M+5qxZayjiVaX5C4jt4ux8XKlQ=", "GWnuBXJ5mQKpN1RTl7T+y7g0RoQc6FJbcU12X7JdkCg=", "Ht699YB3L2FhMUNbF8RuDjhbOrg0lCB++02aMvRme9s=", "BDDcF8PxlXdY5XypPJTFYjBz5VgMKMq6+kAMLl66X9o=", "Hf3JshUmFaTcyLJS8X2XuJmFQ+hLm4zt+NaD2RcYa2Q=", "BIqa+9bBH/SmgCBOiVtlXgBCEeSV8rxG3/7FmL9Azkk=", "JRG+ggCH2yGRonNlDech2/er084VvJ6V4qcVNEPKf+k=", "GyVcN5c/raVqElH+B9YXzoArTsL2CgAuH92QUgkNOIQ=", "BcNv4DV0B0oEzuy7zwLSMdnYaKrmmLIFgqpVbm7jS8I=", "FAcdr0n+QBpQgIUHGBLDeEkRePZnEu7o8c1/YR+GMrA=", "HopF9m2uO/d6ztM2UI0LVm7xqp1YLZpEuQKNLhpcKKI=", "A0cNVUGIQe+4d3uxaYTcnXHKVbYBxqmsvMBt2KOk5LE=", "GUzQp15e3zRuaU54uDHUIHDZO2lVW2ktpvuXmnivzgs=", "ItH9nVDvKN+rHDVVNgHOuy3/5yPjZulWotnyABUXuSs=", "BkqRaQayiooaLfgAGbZ9fkDcaG0AMz/KzWPM8SnR4oE=", "DK3x8SCnumpz+09ZgMWrouDkQoC1yUePXYAOYfw5yCQ=", "EXg8ypGuDNBrkcrNUX5R1PLn+1kgKZPa/eMO4YERWxc=", "FWPVK7ZsInNhl13N/P2Pa7l0n4YpelvTpr50uNW9K8E=", "AuPPLLsW1LanbxcdgKm5LEuDJHIebDopt34slyeGMxQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "EGzURYaHKh6Y0CmnajNHl8aVD7cvJB40QEDsXR52br8=", "JnyB7r1Pm+wtf7E65qs0V3QZKCXsOHeaiIMmXfS3Q7I=", "Bc3m+8AkxS0N2clAuUUFR4BKpqrivware7LDlG+wmqc=", "HbaW8pEyyaBl45LmBtO7QRAhO4i3ElygFXp3YhJBiDc=", "Jpt4tvtXfTpUY7C4i/qRrVbB93aLVaaQgSDrrff6q/s=", "HjKkuWOe29NprrMiEJyRlHaqheKMK3qKER+c2Qa9+zE=", "I4exmC4Ag6BiG0MFwvr0qqCr0z3CZQaemx1ZZz9bGBY=", "FvKhgeDXnQo5Fpock4nQtn5Q/F7NJZjS2HXMuvxlmt4=", "HEGO49r+LZfluE7NdiW4WYxzI+S+qoCdd816OrUvXFc=", "I10dq19y0bDAytguX0auGXIRfrp2Eq4FgauF1N2bd94=", "AR7qvLUFIG503fakQX9NbDAthD2tXlweU2AE4QD3KcQ=", "FLT2/9xZD4WaSRr4nNz/JuyWNVFnbk4QnzM8NKCz7KM=", "DqOovXIrAlVZrkOO+F8fqDZM68gxCEoxKbdJj8cGeso=", "JqY9rzwncAvE5aDBPBKiNOihPatm3rb/KouAWxB6RRg=", "DdKKwciPmVkxG8Uzh4QOExcmpqubf9uhL0A6MJUDSuc=", "EiHbb4aHYEvTX9WG4JRKNogP3R0dordx/Aa8gEgNibo=", "Bd+4qtTWuJYZ5B7QLlk/DeBd3ga2ruse6Libr7CHI0w=", "ELqLPUJ/6GdCIGXhsqjg0G1WfnNxfersNDj+NrG93VU=", "E8whf78bYJciNL4D7od7ltKH4w+4ab+BZmLSiH0txo0=", "EDHzrMQogjXlW2fzQ1+xkVy6nODQ0fEuDmAuLWBUl8U=", "GOvcbdZ/LVhTVBrxaveSdWruHdETLTprHQc023k6Rts=", "EKS96ovzoEQPRWxQcGlkWrNzgXH4ls/jtYkMmgq+vAw=", "IeW0byuFl3+OTGfzfDDd8DVW6xtW2DOfBGp9GqjZu8I=", "Coc14C4RyKHgpWsk6+ejkiPivsyuNSWXly+t2PT9Ors=", "J9XVZVw6lI2RJ4cUpA+rjaicpgDnSKI4AUyYuTJgn7I=", "GLS24HlM82TG1LX7RKKJnUqwONaxXtY0xsEqzOrX5z0=", "AbibjJpSUOnts7n/9uVL5bjBc7++y47vOEfYcY3g/ik=", "J6Xd+Z2cTNyWQyGanNPk9H9jpYGvmkmfjgZPTSxyagE=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "I3sIGmjjDKzEITuj0rFTZySD7RcxJbrUAURIdj0t/Oo=", "Ka9ObK4Q3Zm2ctdBxQNPkXYrmb6ESwqTjpZwCVeObMs=", "CRvWskl+qpAq4FSAaZ80c0x/dLBzr2xMVZv6OjPU5ug=", "L3+cDWHLNuMx8ngLDt2gNZgGfKrxhN/pVhOVD4cANg0=", "JE1uf6VYPjbUGrdcZ5GRSX8nWDp+p/XLTof+rPK03s4=", "HxdOX1TIg6+5rlt+lVOAGQdnBy5Z2zoeG5DXA1UhNZ8=", "CX8jJokkxMz0ZZSZJ07nKhqcg+QxeEVNSdZ19OWycVA=", "A9KrYv73j7abcEnEHjTm8YcGYrM2r70VGLp3YhhgD+w=", "JxhxHHPaHiVtG1whxrLl5D4rADnob3j+V5DgSzx5OKY=", "DTljg2VcJ8olYD2I49NcPcYzRQapPWkJdF5SqnhUvU4=", "HGb9dGKT4jFUqymMPkygyhSYDGoKPLrJedTtj9ufaS4=", "FXCKUsir3IYNBm4Ksqa1tcq98TAfZ2sH/q9TQqlxyus=", "K4Ic/ROeDaTFXPvYtnp9ek579ePOGTK5b2cB/TnpJtQ=", "Cq++5ZjspWJKMbf0C4NgI/Nk1BtrJNDXgy6xgKYIheI=", "AVyS60cw62iyKbtn2nP/88pyCBRFAWKoHRp6Vsg8P8c=", "L3IAxa/ic8x4ewrdhungOA25fLomn1nQ/SZLnvFE6Dk=", "LqxRgHkK2bsGm09+GEKun7CwaSFsm0EtpglOKmlXISY=", "G3oEIur4B8DIJMURp7Ur41PCo3iVkd66m8qameTZKGk=", "FmL6HHihYhtbve1enliAqGruSB+8RVs4SdFqN83tpRU=", "KJcvWWPArkqysDy4C0rh8dvZBf3DxldVBki/78THGc8=", "JCTRGaEpmTOyCbhdSvGqifhSOAHv7uu/z0nBtvlax0A=", "JioFy8hdwXfhdAR8lJBQg6J7TYh/gFDBuYoHYIrI43M=", "CJ0bCvWHRM2wbhwGNjBnUfa27eBlJ+uncOq7cZVGWpM=", "Jtiwh2S3JAeJ2SetZycNqFIf/SOZW2fzsl3n/GDwM8A=", "GcWU9FK2nZq6JK6h9IiHtbK9NR57xphOVsNGJk5cXyg=", "CamEmDrBJAUjm31x1+lKt0pdfiOz5lH2GYjiWBR/WmE=", "Lt/npcE+5vzyfKOpjSMMMVjcHquaEqc0545p17zF3cc=", "GQrG5m/AJEVEo3gK5sWg1uVolJZbNFobcxzZbIne/tE=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JIiNU1Khe+rE0Rlrm6VlYxkqIWULboz3NKu7Xcb+C4Y=", "J/GnfZEvxP/rBRtEhFzcoTYLPf8Q9kbPTi4xsLUnBuo=", "KB1KRai+uAwpdFYsyYeFs3VRykJYx7cpIAbjh7INX0k=", "HQai9rldIHQW6XsY4KM6pQQlG9VHMxPsS6Suvbysjew=", "EdwrWqxsa1iQS4Nw1iL0CNS4oipUpZ8GCpM2UJKFUA8=", "DwNFe4fGSRwENjO7j5Cp26ju9gZ/hpJtxN9KYUW5zIE=", "F5gpAc+Svht/R35hdHpUULl93+Qbtdd2C9HCXfF+sgQ=", "CEivYNKTmzmD322f5WNDkWqgRpM8RRemwMKQJaPaF4E=", "HasXBVjxeC3wFQHRqBDR9JHK86A6VWPIY462ZJ2FInI=", "F8MXmL9IzApjmGuRQja6IaBN0qK9oK/PFSE99WxGNwo=", "Lr1L+wrj4fVA8x/RWnDlneSrj/rNiZ1WBgujlOIkzPc=", "FsPqMkZrF56+V7y76X46f5SwpLPgkfFeOqqSIuixgvI=", "FXdA4wWIcsKMpzMQVfPa+Lmus26cLX0jHyIXHGMVcz4=", "Bql0p12UGlRBKBTWjmlVt/TaKygfKprEJq/oG5jsJ+s=", "+pUAN9IdcgkMW9y4u2vpEf9KNZ8+duxiXGTxICurNw==", "AZBlWFtVOqJkmkIGJccH5h9+DnDHU9rfR0vaj7oDVP0=", "GDuyudhcOpNoAXzR4c2ISWfAsEjcJD81toE69bJ5hyo=", "JxqdGbmRFd/yeoZ3kQSlSyUjc8GBBc9fhqtf/LKplC4=", "KE/STMPLRcpkTxUijXhvuCy789ZvGidszDoRgq9Pwbw=", "DmKzktwnsrgKhoqVAcnhxyQQv/oSt3cyzh3whO0KejA=", "JlMR4UIvw+XOy0FY66CySUBIQrFuiVS6s9gNaAX8T2U=", "EYbkRmFdg6lA2W0ihtm0EbYml4ZFMRcvXo09mral+ck=", "CiJRW5x/3q32T7iWJxvY2W8fU72zLd2b58siQA1pq3c=", "E0Py6pG0a+cluq93oJLWt5DBQpuoej1BBeAFuFyQFVE=", "KljaIHqwQQHYmgnGn42DCdjoqTje3f9w4u6jD0yIS/c=", "G93HQgFd9UcY1aibGB86ARBzKwqx4BT2MgL22eyi6r8=", "MBFE9YMFdGUOYJOkt1uaNLWQZnd+0h0sAI8mNhd+m2E=", "HvSvImaCSIkKp60FsHRi13ew8JqY2MF9We0qEn/SxVo=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JbIKu5iD9ZUWr9G4n4DEsYviJwxK1w9/n5uRiMmAntk=", "J8X2AORqhUom78ft4RCM74tgfc+gR8JZ7DKTRmnB0VU=", "H8sbVOefLwaq7nlVGG1xVkEBCI8Tg38Rvyzq+Tk2GeE=", "HSTaMbywjrZN+eabcpqxNc8bY8sjxMiswHOp1Q8zu3k=", "IcCiv4wOoF+PMZ5XQI7EykbwADMl7964yEsjAm2aiVI=", "GTGtXXqxJkZSNNj6GQXeD3frWFh1jmyDjXSPI1CKwd8=", "F69uFZKfK8qRjUBNVrTO4MzYlpGV8vPt/lbb0ZN7rt0=", "A2sswmRc+tzqgMR8q4zfbrp/uPsrutYxpc8k/OaWaFQ=", "DxC7r5jgsc4syhl3ui4nG4nPRpM9THp5dnHI+wdU4Q0=", "GuD5u3tyoyOd5ncEgVHm3EBjfmVZ1yYVjev+d5pypwg=", "GRL+B+54QLBV5oMX7e1hsCg0GBOLn6L+4ob7mZ2i5ug=", "JKihr0fvJfGLObXKo2wabfVx08gz/BxU++2tVgqlVx0=", "LT9mXqaRFtJmBX6k6e9SJYAKHLLsa31rqfPtu/4frO0=", "LFssq8JL3MDpXS5UxSwP0M7upDnY+oPAA2/u4OlzDj8=", "Gnk0jIgq+qlIDCissBVH2BYUi/uOcPIqCtOj9TS8BFI=", "A5QuIyow1KlBoyq0WVisSbCLCopBb/bex+308N0WuP8=", "JN6U/cf6hy7visRxuncZ1fP1NM2YgkjBVO4SLsIJDsE=", "E686alUwMnplnmvbDj8mQ9t13H6esGpcE52EooiK76c=", "D/8jDWOn6hgj5cXrSfrbtGUihT8Nbu5FlI0yb1RXHq0=", "H2ezwxGtXu50lbHprBI2+Kzdjbv1sgre08OUe6oNf8Q=", "Bb4G0qrs5c3rchyHzgU+hSPImSyRoYhO3N1yuW6ORIs=", "DzuG0g5dizfZxHwKHg5WVO3Vv5/EIClZhIzDlR9Ylx0=", "KAR7+1hfF61ufN5bwDPYBy87PpDWO4hN8upvOiTRBgM=", "ARhq6hLaUsJwvK9L0Ph5Q89c2d22O7uy1/NN0YS67u0=", "Hk1l4LrBTsP8eXCvDWT0ypuTIBLb7lmzqT7kK45S4Gw=", "Jl0Jg1oZrFwp9DJ7nfPzWYjKiJPByogTofkrVVVQqg0=", "JVuEPAU+ndmwDQbbF2EGtjK07w5uNF7ZZ3XkrjE9rm0=", "HNvy2cnh9AmWUjYdgwxtaR7F65Ua4xZKzXFfSarmEqI=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Js0FYXTcJHfeb95qlbeAXtNDh3qzX3vRavzqqXcfrSA=", "KGxj3Dd8rwykaXFkvd/SmnmuwHtS6+T/8aRgG/MXjvY=", "BEBKLZcmaIazoAJEoEnSIycnxw+GSvpE0RotN7pBebE=", "LXszztXCr/Gta0zNhIICTv+x39v6IM6x8tWa7UDaUjw=", "Glp4x1an7gzOMbEyz2dSofoOkE4tbdmrOBj76UJtJO8=", "JmNLfdh6jA6YeLE4NYK5o79ljdE8Rn5SgE69sWmARNE=", "IiLtAV2743vCV4gUeCdAq/oAxBGNytyOamVlh6olvsU=", "JDpGPRvv0MzhpGt3Lz0RNR1Hzdhv+OCm5rjQ+MdIbag=", "D0qd0Mz1LzE2DbX+3N4EBUBtTOIEKxhWx8FLrBh6030=", "JcblBzcauoiCSs2JdOw2PCHd1FChOxMPOOrNXbxejHQ=", "CGTX6nQO6T7H0v/ret9KAxdMiZBNnDOmg9iJfqujU6I=", "FGyubRvbAxgFj0JOiT4IkrChBw3jcKX0YERK0uU1qSA=", "HrzWTfetbw4WGeJu7N/m4v8eaSEFeM3GwFLhRR6cF8Q=", "Gn92qLmoaLer8LvymZLYJyitJ3qgxI0tsAq0XHp3v8I=", "AytwUP29US/cvJ6fUwwTnxIN8bU/JiQMAd+jl+In1io=", "EY5wH/IZYS/+lSS/ouUVu+EfL9WBpDcfGNf0X2THq6I=", "CuTdCqZxwKPdCPOU/A7aaKsr7utYxslOYCKRRfCGlGg=", "GHzZWvVh4WG8GilU4EqCSIchyA57lwtRoR4xi0Pjw0A=", "E8dOg6v/cxhyYw5FOEsSLtn9BxdvM20cPjuHg3rcHDk=", "MDkoCO3IjgwkqfD0o4Tjv9u2U4L7oStOeuAbcStQc+E=", "G7aHgbn4QdzKIQuTqZMgdg5/OsQ7TtnWIftQ68NEBGc=", "BRTuynzQAtBKRxZHi/YsEIs/MUooi+aH/Lp8bVED7V8=", "GkwcqiF7ZH0Jnjw94D2Wd9wjmCd4VhQIBPlYSCdcsFo=", "GVnR8UFMmlmHnpSJMVJkt2kdrNlq0W+JDrsuyMVfQKc=", "LA52EhdQPGwLIAFFWOt45jFOYHEwhEyX7mfb4ZQLPU0=", "JIyapwYi/+JCQL/xjRkSdkF+/3di2WWU5P251oA7lgk=", "Idup1G6J9Ydf1ekl7v/RDd/AmscWNOacYemAW9CgfR0=", "ISgIBnE9xSTn6yxpfuLhl9ib0uc/GBdgm+IcNd1b3Vo=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "A80XQ6PeROmhcoBMexWewXqD0q2Dj5pR9Ul7ta7+lmY=", "BkaC669m1xiBOk0G216L32ZdyGVN9K+WV4Um/X7/ZEw=", "J73KUKmJyqTcrS9F0r+n5tRVVJdT+z6MTD/yVTgDsCQ=", "JjohGfO/XVMwwR8wNtJSHkDzkdqe+xh5vxrzn19N/ww=", "LfLxP5VLGny1joTKTz4qt9D0JytVnljH3OfvIpITxb8=", "KsQNVn1IPo1nHI4ZQHX9st357FGhdCGejDUdzgLTLVI=", "FZuRVPu8rccgnJl4z1eDqopHy6GnKbspcYKqZ09/2CA=", "GiKV3k+NxAGqpKKxqD1i/bSCjO0lPazBMuydUYbh4sc=", "JAS730mVrSQcuhFpyk2F1a0nbKnQCQge4+K1GB1G0pw=", "Bv0iHjK5jC223BYC6tOVAB7c7Th2HPReu7w0DqNc1+E=", "CvMRiv19z1mbXGW1o+dKjtBPqieR9HzSzOOjHlQQMg==", "Ky3W0GU2XwuAi+4KL37GPqyxmQzARgiwhUnWUCQROtc=", "GAlBxv1uHcigqk/YYCDdxJKIhLaAdMjXjlJ2Srpsn5o=", "C4bLeFZxx2MA+ebU3SO1OuueLVttIJ+WaYasoJ7FmAE=", "CuhB8NJb+9AJ4AESAbR+IELqjZYSSNkO+dRKNgsxdhc=", "Gy9mvL22/FndpfNO4RxlTQ8t7CnjGSjVsRE5PI4PlD8=", "Lxa2bYBhRgSuhaE0QNRrup0J2Y1RYch4vmeg3tq+Ov8=", "GWMorcqBZ8ZJuYeumF6eVMCCIHcYi4rzSzxRjcIUFq8=", "EHZk8tPzvD7QEBP67ChEd3hfCOmTK0ImlF78p/z1a4U=", "L8VLxHzcf3FG+bgUYsZAkzdMcWR9TKJ0OUBq5ub3zKk=", "CHebM1lyCg8+CJiUL2Ea6uEC+HVifyyXPJc1ZVSRHMk=", "LjC+XFywcJDKMkk4aSYZRoTR89LT3cEUuuK8qdSgf5w=", "HqRaTwsStXi1hgC50IWqjZxopYPOpmWAW5OJ+FY9U6o=", "F1OjCLKGJg7m7Ck0y9WfDyEcEWR8vyL2v1+nwVTA9Xc=", "EC/+uKKpT83pAB4Iq2A6qJde3CRl1t4UtzwU30DWHbk=", "Guip6V7mnId0+NOo/0hHiKsnLT0XT1JqEHssisNOzZU=", "FmuEteaXW56Nf/y3vmQf2JxT0bcjh0joXzIITdqjqr8=", "Ky5HrNZEVCPZ5h6Wll2pjiBrYR9Srx0TvstM5JZuGjo=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AQ51VJg1YrYt5GYLMYvNUyQAPpXtxhfWscI6l7k4AuQ=", "GHSD3KmspHX4W5+MvXiqYEi9LISMrzlzyP6wdXOIOpk=", "AsEzCd7EG0312P3aKwY+gmTDVEK7Eg4o3nVVVp7ncfg=", "EXECccZ4MGCuzUEKYMxclmQcHLJlkbIWMpFKqf2U6qI=", "ErvXfXvk4Gt3tcQOH5iIBUBBvfT4ryxTeOY4Yzdxa2s=", "I+4smg0zJBZgKHKMgNYM8OIae9nukIFwWK07h8byjMk=", "BY3T9ACeisP6B+KFu9c5HC3qgZMMcyw6dpyckkkITXE=", "Eo0nxIBdI2XYTHVGIcotGoIpfqQ9vtqHwLrvUGyFEHk=", "IPVS5Mw6YswvPrdotp2FSe9MJNKIfX3gVQsXq097Q20=", "I1cwRy/turNYvH3PJbHQvvzHB0bemeeKbf7I9ibFqfg=", "KAwu2GiurLa+fJ53OwjFb0PqhxwBrP35/1zp1EQ9M3Y=", "G8dPuSr+nbjA2mg2UybNmUTbmItl9G0DKYkyb9kB6SM=", "LZyJxWV4+lAxr9GlPSEhLxw+8kz3B2Rg/1M+3l/DYA==", "HiQT87jyOiMEc1/rP96dLQ+I2KpywcYOrJIViL+vac8=", "BTpMv0tX2IIXS4iR2RiveLQKfK+DLC4q8CuLpb9cHN4=", "Bec2ueX4obk/467x7gppI09/5i6pmKnyVZ9lBmnXbb0=", "HojYs9FA7GWdbLM3NqAlThePxsDDfS+ls2rkqFsotaU=", "JXI3ye5pn115pi8mR6O1HINidZzZVfEIcjRqs7QBsEo=", "K20lhJ1rgeNs0ynSDulzwVzZtikh4nrP8EjnWJ3fdzk=", "Gscxfi5eMBFCBVj/pDD8q1Cy8/t3gxG7JbEBnIjO0UY=", "DzIj1+iJGKMyULYazf+s8ZZaW6mAeiPO98icg3r+W5M=", "H3M/qp76LbaDY3V7GlD0Q/6b1OO4Y58h8eEqwl7wC3k=", "COLmsTqno1K4wz0PUpOcFoGeapL3FZmGWIoJ4hlu+j8=", "IImVpyGrq/tNUn2wtp011Q4mO7HH2XskrFLCsxa1hyc=", "H5HQIqePcIYyBAQt3mKcGK+FdXvPSGOz65FqivEyuh4=", "BjovTI1Rj6ctmrh+QU63zK5O0+y20k+3NNaLQ6kujLA=", "KRXGSgvzUgDMpXecFAx/noiM5yucRYqa3g8BCOssz1o=", "F6ICilSjDk4O3tP32Ggdbd363ybvXEPL0ZUuWErVsK8=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AqoiX1jVfsn8sdamcR2u0TU3zG2128SFshqMSxPuTvU=", "KpqCRxX7jbHV0n/pdfARMgiH9ZPTbWyn4r58wwXqu9Q=", "m8S2LE4HHkPB4g2WgQ/5Etq4api0hw1mr3XRCrZXiw==", "LX0yb7LNZLVD70r8nSlpq91TBC5gOM9T8S02ugfCGAc=", "Hmbb0w/jEdrHU4LtOEPP115WC/JjT0IToNN76RwmnLw=", "CmEV6Hbgl8hlHCNw/AwKedT2cZnLygCzxpiRxW3IHMc=", "K0zRbAY+jRJaM0kJtfknG+9hpeb80RdAXiS3qNUFRTs=", "GXNO2mH/DcfGJkPXHa6ykc2PGOEIP4KnP/BeX4vjGQY=", "D0REHLF5W2C5pCTfkn+1S1WlPHWpjrkHCP6ktC2hju0=", "HgtvPnUm4xC3uHDMz2m51xaSnnsfB4ZSWIYX6gtx/rk=", "Gr+1bIiJ02oc6n2WWAFsn/VBh0W8QY2BNOtE43ANVrc=", "BFC5biYZXkKQoelNiW2qYBsL30RlG4V1YC/+pIf7U2w=", "B10/uhwfCwhpcUzFtOVKAZ4Txam3Rb84E58rDwnJMjE=", "IqHlZjcAt7evIqxWBLEgw6tzKUFHiJ9zs8mGoDb91cI=", "DvGd3vcRF69q/d/LW6RUYC0167dJfWXuHngF3WHYB8A=", "KTpS2FqIHjhF8CmT9Uxq9wD2NE3vLakKLcE6cUdg4iQ=", "EPR8cII2lK2zlSRsdQdF7af7V93fX25xzhpBwumDnPc=", "W3sPipWG4Oy531C4RQtXf6U3yUq3t3DM2IMYSuJxjQ==", "JpRjnY/UjkC6MB5WCXyycMoeSm0MtbCZMxQq79HETvo=", "K0BngkXmgiXEydj3jS5mDF5/y6xjHRKZsaeN87KDsZU=", "CIMiywKTcUX/pWay8CVtXI3aU7hf9hGmWPTeiqnKVnI=", "D19FyRUA04/hrMRiqGIimMGm9TxzWr8dSpcdPZ/RDNQ=", "F6+IBYMDHucGf+yA9bN2D54Z273gY0PllZHakIC42/s=", "EkjFstPr0PKHAwfZZe2lPvfYM5LPYB2V2g6xJLBcNfY=", "KGtQaoiD1vKev/G83nQpFWeS2gAUK7EpLzeND4lioVg=", "L8+eHmlw6LiD+PcrscSMU1Qfv3L3tD7p8yc/kQK1VIs=", "F/f5KeOKQ1d3D5BenMX/fih+BD0GBUx41ECXpEYXTns=", "CDJtDIoSjAc6csfXIqEp+kUP1CmFZzKIb72j72Fga/U=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JE/ZSsnStqAq7BC+a9/eBwfYqVRAsEo0/uxOrAqIGCM=", "GPC+LnXsGskSkg0EA8z84K4RpmBo7V5/DmAUbB63h1c=", "Bn1RPqh4COwc9/WIDxPE/wfLg7BqRCVzwudKZ5Nj7bg=", "L60+vuRjyAUCSpiE4iEiiNl9NDoZnrHtRJ1/DPIfuG0=", "KeLD4OBPdoXR4s15feB/PeeQzMvNr3fxaG8VnU6QsOo=", "EL3yi/ysuGNRCOqRU768536rBFOXAKzGTAhPi8P0ogs=", "ELaolZFKeCqpSUjGUPbARdmhXScGslms9f1NoxHh1CU=", "LNUGeSU529LyzDyWeV2Wgxwh/cp72JiLuqxg8lTaj/o=", "DKnadgZhXxVQaocVEgC0aMEd/A4o28MGvN3G1IKM4tE=", "INhU9QkQxSqx+SMQK9bKXYLaFbo/D1T4mhvst84flP8=", "EN5JAO6OwkPKU0BFVubcFcqiurjdf4MUjcpVpZjqiL8=", "G2qOsowSbIaCVCJ45OSyySLK84f58ImAyLRprvvGm3U=", "DCoxJAkVJ9IeG/1WzYj5+gYW8iCUVLXReTy8Hc6dJQo=", "HUdE9Zii6YFE0BesxfzwjFGHrt6hRt5ux0pWEq/4x/Y=", "C9eeoaIkmHzN2D+axEkLdry8VU+nwkGOD+OOnaJ96h4=", "JAVZLcgaZqF1Z+aswgzKcXmuPAlxZY+3ksCYaILlcQc=", "FPSXqegRDuwQdFDA+uZNA7yKhBbbOR1MR3Dd6b040/8=", "Kfi7NSnaP+YVLF75zQBGVorb3Z2q38qBlf8goN96W/w=", "KgMjAPySvxm5zeiMvp2j9y4/9QxitjQuV/cTsRil+4c=", "G1mncJpTGmUNXsKsAfsJztgyer1FiPYZ824IhsFsPfQ=", "H8CjQ28QCk1hzLwyF3Hvb4XkIdVmO8tMAciJ6lBJ+1w=", "DprNXZF9QWBDSo/nA3sEHCae3c7ruRKbahdsigCRDSI=", "GWzIoiXywphqurQmiz1jQt22RbvNaShj6TJ0txfQKEQ=", "EUWTVrIMLKiRPRwLRQh/WihVkZDUhvBAOMBSITgdSu0=", "JelsB6uH8/XAaIYIwJWob4Dd/1wlDw9jdaRTmANNZOM=", "FdWCUoFaxHGu46PQl9eZ6e/rlpzMsIwzrgt63vGPAlA=", "BlRrO3+FBC/eIfI8OUnDnCJ2+HcBU3Q08Uejz+7BA4c=", "HiqjcEsIDEzxF5igDMDIYZyNWZe8MSGhdVO+ey3WVng=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "GeJPXhIOU7/n/AEzghH0+qH5UITycW5Vh2YClezqjQM=", "L/JSphVyt7kpYIQb/sxL9ZQLwNaC8XcPwnL3DUFoKEQ=", "K5zofWPZQ6/ZQK6Hl51d31C3hP34zU0e8OfE8iDJhkc=", "GO72u6vU0qWB8R4rIqWRNk9aT7pZFGqXVR++67hl/C8=", "GwlK8nJZ2uXi8ZKfFvAP5T06zKGGfTWdRoGuinH57WU=", "Ly+y4A7MER9XPYACxTlZBn87x7UpWdAmnM/qlynYlDU=", "BIxPgYJcVYTnb6ZbGbm5//fbBwOdN1Dzpl+qCmCLcfY=", "IL4Z4CXqJfhfWZjHelJxDfpdxluyZl5Y+qpdt6DIqSo=", "IioFCD0kEFdU4/f+Rezmrdh2d+jmTfP0QEFhhZOq9fc=", "FPPYnDiwJJrLA90OETAQDd4Dmx5ELBySujb4No6haCU=", "E2Z7e7psB6p+GNts4G4TCM/06xwK7MwRh3mKoel5Z9U=", "K8I09IKN3PWHvGXSor1a0JdPWs0feQ1ZDWbo8uxznho=", "IUZGRPoPsiSU+Pan96kpNi7OOz65/Nd8+8I7LJBmqb0=", "CLZd84RHzEdFW0B7Msi8LHQMC3s368TGHYZ7dbhE+9s=", "I2nhwZljm8UFzg2kVgHgpR7/DyZYjXSFPQe0GkC1twE=", "GZBRdjOFZy9vgwOJb5WdKyS0z6TWL67r1UzUPhkMXmw=", "IBrCDWK5QFa22iiMtadf5i3HiKiw03Bj4iMY+Mi13aI=", "GBV/OYq33+dwlKtukaXvTg7EcfoaBOiZadHBGiy9zl0=", "DzP49lRnd8UH4qefCZpI10MyWGTp6QqSdHhUWiH9chs=", "I3A9tLWE0sSHPnZ0xvPfDhba/TRP+pQxzDNIQk4vuvk=", "BFAQYzZIBeel59CpuHl5U+fwilyq+HORffvD2jxb6JU=", "LqCyPVXVDZB7+xZJf1apeax/RgFyR32+2ntFDHYl0kM=", "Bo2t85AB+R9RoGEwBOlhSlRAK2/LsPS4vYqlRideMHU=", "JBx+7MaqOXGb9sasipgOIQDYw0FWXROO3is3QXczOus=", "u5V2sxUWDm2eWHi8VM3ZzqOMk111/fiznao0eaKbJw==", "ICWZsoS/Z+pQysyjFcZiGPTFmkmifhk+3sS5+TvwUyI=", "FwBwoHGoZIY1Zn+DFeVBLEjDGW0dVR7NEUhXy/+bnTo=", "MC6EGHb+ZZkDVjVJl5ueJ8ptNvAEpVm9JGHV3KpA0us=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JzHxrF3AMOwRf7rXtTxrAqbJ4EoX9kvA5WiF+6DC7zs=", "COREMHC3/LGij2IPmQgAvwojvTIUbX6qgk8rAvUKSK4=", "B/Hqc/Fdi+XuEyxosc6zVzkJdT+GWCxXFQ63GTKXLlo=", "BdaIArJvC1ILJIp9T8JGHfd1ZkETGhrRCfoliMRiMgw=", "LG259yytRMPdFag9XvnrchbbHnFr2L75YOUsq7/KgQE=", "JjZdlQCGZ6HhsmU+mPiZo3jghkPXu/cGx9Pu2qwLFvg=", "BS/5dLLQRTe4QTsbDIUGX3J61tpFT5Cd2gqlmU98wro=", "K3aWRdqhnisHRwquTNiGcucWDPPAfHsnG2Bmg4KBAyc=", "JfVqCuUNMz8pTvoIN2o3w4bcTPJDZxOcZAUUVH26444=", "Ly1JsqJX2KpYuDivY1fYZSNuy3bn2xNqCaWglKt8U9w=", "Kxc2NmdOVKoF0L8sYMXfCzGy6AHmr7FJ6qLG/XPWpiY=", "LrQb+2JwUuHnNzpzkiZOfWgKGc3gMNhocFN1UgfEQDc=", "GEGVJlC3IVsknPUPi2x4URwpgxRaxAXOvfoaj1S5htI=", "Flafv6peMw9M4TmxA5gOBWnbhU1wHXaiM+ycWo97ziw=", "BgxxKBxO06I9fOIN0wwiqhcuJFzlKSNO0YoTAiKp5hE=", "Ds1Tci0RZTZYC+e4pcQ67ceY4REMmf6dgGviFA9cd4Y=", "ITwGk+OKueDNAtJEdhPVAz/Of1REOHZS8D6VuaGNymQ=", "B3LQ+qbHIshh2pWClh4jnA9FVFgKWgZ/nZ6b1x+Xj4U=", "E5/qz2neHuPRT0+57NBmgbWNTqN9MJ9gYqK7NIBuSw0=", "D9zTXWi5oKnw05ugZUSaf/BMkwGSeu8RPF80BhKZ2pQ=", "ElvoSidqasulUYlPXcjhTzc0eX1InL6UVCvovKgsXiM=", "K+Zb2Nv+jUNQGN2nWAbuNIIGhsqt21PxM8zZh3kTNww=", "B47oehSsJiwtdLF6unHWIGhZh3J8ohSEutNwUtWdO/Q=", "Df8qpz+fxDh3fsi+dNSU7Iw2/AStPxIRNiSli6Uqurk=", "KC9uIxKsdS0pTRFrAwiYHn7UXiFiQDxf9wXRNvwFrmA=", "J5Ggo8ITWC6aJy1rZnx0DmPNkY1TukRNI9CV33Z7aNY=", "F0d8VmNVyA/HhDhHFTVvacjxBLAVRTOvPJLgqKExmsA=", "L+Z+eagHMVBgE1QxqbRCaYLpDzs47NXY4O16DPWNbB8=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "lXkD5AzyMZBZwgwPxwpfP4p5pk8zMNFl4sYLWy57/w==", "D8ma5qt5RFMnxtSH4ymX1bR2cXvSa0ewc0ccg2ejzA==", "KWK78Q79io7+zNCf+A6e4WIkk4kJQBmvIozazS5CVJ0=", "JakJaSrkQ6vYft3XT4cFyAWEIW1b6KQsecowef3atSA=", "HA6MG4vctIm7aNcjnfz9UnHErDnSfiIr6SXel3UK1fs=", "C6bulpYsZuwEwHDrPnEoXYyRzJZ9INct5ykfAg8sNas=", "DLoSOOnOdHx9SZMg470nDbFM15a6gpMoVW98mNZMDVo=", "DIdWNQg+1pdtBodR791svDzWXafJf2QrU2Hqc0+XApU=", "Fpfc1zXemxdsTRD8WrEih3V4jtS+sW3LBinvqZpqflc=", "JEz1lWsCiaeJqvAPLiytSAzwgkr+jq5B4lnfOVvr8tg=", "IGw3BfY9e4cQRcUkW9O89yDhLk8KgvqJofkTZG04ur8=", "ILWO1OgOhoMFUi9etnDORSypsdVBiX1RrXtCxOzRMgU=", "Cvculd5w9k1iHbhaN/afVxLOBudZaql6EYi804YdbCw=", "HB0Vyks+BQgoCGnD7zju4lw9DPrhiLXz1Z1cfFIR13M=", "BK8wbZTo42Yn3wn/wg7FY67AVFK2uMGhfpPIo/MKkgc=", "L2l8NLWcVZqiMuQAJLxto5BCatrhZQAt9RnX8scUYco=", "CKcplSis+2XRlt2aehNkAReKfQP2+/XfPGnmYpiV3NU=", "Ih9iggQkBzK+OOLQ/TrdsQgCSFkszz1lU2ThcTArR4A=", "K0oF8Ao3O4+3k4tPiBK+WCeWmGETuh2AdJvgQdrEkIg=", "FtlNp5knwkt7vSXe/VwPzWcHPXOPMbk/8IutkHiyoj0=", "C1Nq26IzC6qaBwpj+GxGXjRj1K/Out9ZojOgMZ0b0h0=", "HFelmUQaCxR0UhvQRwqc3M42FeJXXuS6qjiiWVjPF4Q=", "HxPbSp185f3q6/OlcfoUgH6XmiPY8dQm+ha6mUFCHGA=", "ErUnzYwf4I6dkJz64cQF8RMhU4z1mvOizuZ6BrEdmFk=", "HywPtfEebXTbDDASXki+NEwVUpxh1N67ATp7BvB//5U=", "E1L0pjIPtRM0jdXwLKU86xpH2GFokmCO/yKEzLf7HQE=", "FG3+qyYyGdyudhOptUA3WdUSLJqkkONrpbSjfUifjlw=", "Htr3NhXhh+/+DYdkeONoL+9dY+OhLtzMIW3DAtd2aA4=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "HChEJyL7SdRNQLK26G4iGPlW3j9LN2w5Y5VWZqj1cYk=", "IOnlwbXYyuR1zRbomdHJ2SPY0g7GByfZJm5mywWFpno=", "L436H1SvZ27qPQW8xki49RHqARta0j6WHhtpW0tSZ/I=", "GhpQN+V+SucjdT09IvllrYuRH2E9aw5dZMqQUK5DYz4=", "G6mD48KPY5jXPKj34pY1ZKm+RxzNXD6wxPjpZjUFlSk=", "DUrf5Kff6zz4ZwLlSIgwTjYFfInxDUYYbWR7+nAGiP8=", "FcAWbuogzXBd7EtEqsoAfmyeSq8TG0d4nPcOU8Bp5r4=", "DOr6vtodyoFEM8lplD5TQAgBK2VVsIyypKv0N5P+Dls=", "C9FdijHL+9t8NuVA9McKXu6tnUOpQUAjx2PS+2Q/vHY=", "F7ad/5+d/b9r/+x8fuFeqwLu8XJUpSYCLYePyv+u3HU=", "Jy/kIt1W8o5jdctyWtRpBp4eSKqUXf/cHplCtGMHt2M=", "J9LbVlHlKT/wUQAKNqLJSaej584ya4yZOEWtVy7RgW4=", "DoNGbCdBw2/m9fXm5gutW/4+oGp9tYaA3EpRj0K23bk=", "G5ewSJJ0pZEsU8GBN+kY2PfTmFA0xhfZ1drky3WZBIY=", "CLCbAnZHvvyIhL8jeljv02FkHkolqx6IMWFq2QlqoVc=", "IvRqAVe3AZZyDFenY2KFxLEIVHIeRTMpQoNlKxkRv8I=", "Lx+AOqSpailryNro0HM1rQGOd65td5eJvXGOcthwmlM=", "IkXmHftSvgH921+0F5FA5LW/jLHHr7u2l2OCzHEtmBw=", "FoP5vUt5FBDRqImVO3FtlcRAaS/ktIhhB9BSqNUDB8Q=", "JC6GT/7jD+CggOIeTSdduDVVYPB7d0Wk5a71jQm2U6E=", "HrSD79gxAgPJOkLgaxi+W0oMyWEsM1zcyCwQTDiz6Og=", "ClsbTImCmEtu8WLq4B8KUzN8CZHCf67tK2HOPPmfZQM=", "EMJaFOUf09+ONPcNs4zWASSk9IN9CwJNWgy8+o4xZyQ=", "F+nz7+pCdc5N1adg9CFWRM9f2jZZzILIzcHGa6UzbCk=", "JcG/xOZ5s7OmknVbMxOtoF9tdHNlMlJQ4NbAxWYHDKU=", "E1YncXHx0qLmd7yxYdnXYGSBUNHylyR+qEKr8mM9RxU=", "KKq2uH+fD4xwhpVZRhD8magg3ZlNY6slgpwO7pgNJG8=", "FI11IOoKPXqz7lUM8wzevkNMp8hO40aluLbV01rgbog=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JBcPrfvPBeXTxdDV0FH3HeIxdQAtHwIAKTnrJM5dbSk=", "KUkekXHVeMA7owImJTGm2P8DqyWvfbRnlH5UNVOyXlA=", "EKzQO5g6RX4+sQ8QZmp1QLRgZu/9+7UKHFmW6OQoeeA=", "H7iahmvtXOh8whcPmYEyUS6/3neiqvqE8ogCTr2ebHg=", "DZi4MNiA2tSgdV2nYmwMt9vEVL74ixaZLzJCyf3qPLY=", "HA2TAnabE40WHUcRlfBrsgpaWfU/CDcxu0uUB69wWIA=", "KZu9LJtkv/xgGlHOYBhedwdlq7lSN1BV4PjG7cPB5+c=", "Hj4BKjojzFa2m5LFqC3e9Tj6J0XWi/mebE9lZwuKJYE=", "EfXiBAfuSA+6WbNa9yPDwefmD8SBf5LWOUzXqcZex2Y=", "JtO+O9MPKRMXBaYPxPXVHGYXkZmTv/Kp6cv+CIGcpoY=", "Kyn/r+eYk6iYROZQzMAa2gP5H0hTFmAG4O/QWq8+Nkc=", "H74yxd4HttYlyG/wBiEC6hrh9j6A6gRz7HR62aZ+igg=", "JONoddnxGj/C3CPYrlJwFQdZuSp91CLSuxlmA4NXFcQ=", "GFngzdNombo+oaFbalNDmF4kKVdolNz8s5sXSF6WWjc=", "LoI8ND+oFbiFDdhYJfXqgMsy4X7QqOzdxHhgmwlJUsg=", "J65ma128PcDRnDKgAKffD99mnvJWkWJ8TXsXxvQ0jQ0=", "E9OYjJg/yzy3hLIisruNTpR6/dP7HQ5b8quHbqsev9I=", "JgVe0vfP6QvFTr7umuN+r2LxHUzn6+Nw53dhZ6UXeak=", "GHowMRcPDgzLjKZ/ws2rLCpSdGE6XOGRoXkLkcxsWIg=", "CXmlpPiWzsgEpjMoXJRXcotab7+srWJZOiOu3e//4FU=", "F6mq07+kzSXZKav3Fdy9p6spM6aGjTNyCl5sYPiOMcY=", "BRGSpiTmXA91kMNzhcsaC1K0YgXSrnEJ4HbAizB63QA=", "KqFP7uF6xnAOXliVLyjVQ1+6w3dpwydeqf01ymIv57E=", "A1RYG0opqa1nPzxXgBu7b4pXCYyc9cFYYLTdJA2DtTY=", "I78pwC2NgY2kJX+t6ghAeKT313J5Xdy6nlMDDgbP42w=", "IJkj6cwHkZfQAfMwBpsFt1VH5IaFr7gEkxr1o6JBOQw=", "BtYUJWqnoI9n6o0GvwOug7ggZp7318HH/ZkqyyKuZ3M=", "ETG0hJJnPkdMjiMndXG9n5uJK47NO2r3VO+DofMKQps=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "F/88IK8z3NFyvDBCynuouazHxdNWlKeVvMiuPDXZ50g=", "Jz7KW8dAc7L2dhtrBJTUhAfEoCEFb4i3nw3DxHWALDk=", "JO33m8NTAMcn05swHegujMIUNej/PzSQVDa+2/pvnZE=", "LLMjITGl2GFFEnxh7Miv1m/Opj4+2bH/HvMJmusgR6w=", "HqSfsORu3MOpBlH24aSzYXW9slUFzJmKEBcQpPzu8Tw=", "HkDTlP7/BwcRbh1DxSOjbqKT0RzjBZtVYu5nigCKWU4=", "D+R1JCZkgN8TKlRpiwnoRHRetUDLpJhiOpPzbkjGO+4=", "HxE7XXxKPh8RVtzGg1gxjOaZs1KBSuAlNnLWwYVCKYA=", "Gu00cndkCgoM67wvTOUjuaUbN1BnLquKnmicSIvEFvI=", "HvmOVzgMaoCEqNd7cB4j37tWM575y9y5ZERgpyofMuM=", "KXqwZ4eYsGpMxxR8wSW6oRoFjPCIk1TmMinxhTNs01Y=", "DuVOT5AVMdOBGqZXXGBAnH5q1LR14kn9MzSIO0OKIJc=", "G5sPUjdfNLQhDgeNSCTQ04Xm5BLPF3+GKqr8O28R3u8=", "Jh/pjEpogr9YbOnAO6kFVdQoVnvZh2HstXv4sexAhFg=", "KNikaryhhun+mzJsFmhw+YrPZlXsqAW4ge4C7U8+gTQ=", "BNpgNfp92JmASFrA/rJ3sercWPUiq/AQ3lv50zl08jI=", "Gpc40TicoXDCCrW8TTnrOZkqz0DQxNog7z4zlO82m4g=", "GD3Ukygw8/Kb8UIc8OA6kDIbl0yTonecxkAxxMAWYnQ=", "Ha76V8gYZeih4xY8o51ADPXORy8hoYiPMAdBymHWGj8=", "KuSdJ7+NrjtfhJn+n3b9LyR7OCWo9OieXFNZamrFsT8=", "CQYxB+KiitjexO4qQ3YABsco6gfcfv8m80wOiL7Nh7A=", "AyfbCfUYWImuNuUtskQhQFOye/GNPyQFUtrmK2C63/8=", "bmG3P3BKPNcM/oQ/N5VtDDXK/mvSjF38G+mDmcc0/Q==", "BISZRVWnmcvBdbzk863VRzAOo78Fl7UvCK26DQ10ePs=", "FQmvj3d2Mbtlu+WuaPtL/T5hBAzEwoJQcE4+UuOTp8k=", "JQIUi+Vj0tvtci6zSoeOMmhu3cYyNSkv8zZDDKa9XzQ=", "CpBYDmUScXR3FuTmXqjcA5NF4GCeRZb+Zf6VOdqhKfw=", "Emisk0Nd3D3ijHQB7WYSdR9LJE3M/hp1Jp2oA2oRc7w=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "EaqRMolmD33rfM/y9L5trXVe9Z7tS3FvyNh+JHpv20U=", "KecqFuRTTq/c3WE5vsXrleIrdWZQjht0hhTUULVMFf8=", "GpWOagsaM58dPc04zhMoVx818Jq7Fobi+0w0WfA2xYw=", "LtgzcgjkEHRNc7+qgEndmKZz60c0svHmxQ2/7tJTLqw=", "KTd/ZAp/b3a5IrGJVLPsEiFrqcE+ABAAK1nqNPqXS+8=", "I0VPJxNxNLmvjUPb6y8UbJqUO9Xsf8dkLaLsiH6bxM0=", "IJgWtNoZWX7alJtNtHVAYccqPJAvkTDtyYtZJHCw7lo=", "DB6uiwv5JbChVeQrLlFnjPXvwjoH5ioWzn3itfojpDs=", "CG+B0ZoxZx5BqHStqnHtrHXE7MxqIRXCrJa6tuTakbY=", "BMWZrAKArthPlNsOMog3OS6jM4FT/zfeYafii9JDks4=", "LEt8sR6YjVRR6lO9e8WcHZKjJQ5csbgcgBfv0AaTrgs=", "ILSfwmr31R8EO0hnC3mkCcT8NmMy5n3Ksoza7V/LjzI=", "Ky3pkUAz3j1hT/HMKkYjTdHzYFqfTlL98haZhrMadU4=", "Kgqa7a4t256rviLe3QQ8Zw/wmCSbyomy17eJwaIA6DI=", "B4u8xUQzACnFcDrYZ9N0qQfv7h84dk5Bf2tyS6IVZoU=", "J/KwWRWb5ZVcniJ+hl0Kit2CqpUevZsv5DVFcE8MS94=", "B6bEKeEQASXYchIMMHveF7ch3DHhZ2PMCWqYnJffeEM=", "EEJJZJBe9kaRP3COjUMh6a4iY4dbg+XGXQllFlgdQJA=", "LDOq59kh1LkKA3a5Ou+aApdfqDQ9wAJgZteR6QMOBKc=", "EjKYPlVcfUu0KI+9uj32gpE4E7vmFsnvlWiCDgJFm00=", "GrUCPl/76o1P6OAGvu67MWKibipFRvUbHYNtNGeBbAs=", "HL2hMfILM+vOrP+TOUUbhIVOZXdf3B9d2+jDX6shFtw=", "K6C7hAQAD3NhyrGOeGkqF9lTMjowk0q0OeI7ZgXAI6U=", "A1+gWArgb8luDkr0PmOwiVkb6+IzxSameXPyXMf7SCw=", "Bwurs4Zlo1RubiP487JvBYvxMavxnTwT1tBYijF8bYs=", "C2QogsEpU0Pp6ii4mmLO6+C3kZtspeGIEaqXi8GBhJ4=", "DGijb234wn3uofZviRyA/CFa78ZG9UXWPK3yKrRLWRQ=", "BmSJs8yYnoB74TY9lyBwFKKhQFLegO3NFcTi+I0sZdw=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "ECbmJXtD4K/uIqAYnyjhBxj0zF5Js9FUBd+F2BU+jhs=", "A5R1iOlD39vZVpTds6G6f1ECjIR7ikUWToe1UiQYrsg=", "GxyyxJaudkv94ojqUEBcpq5KxvmtGZi4O3VXeHEgyxo=", "JPpPnvcHp39PN0KqrGuPxbxZ+oxARvnQJOPV2ArAw4s=", "IdyijXFgaH+8jQ0UTAYnEeQgf2F4lfpG3YeSJ3f/EP0=", "CCzRRoW8OzIZ4adrprLNa4KGQFo4cFJzp/rtodpis6c=", "KIx3NM5s8AF0K46E/lAs9SBaYjo/D+HXnw/pFt8HPEo=", "DL6vV2Vx67htF1uATEZV2nYDCW+YZfmDoES9jrxBZxQ=", "JXrs5d2de+COg99ktQtf8eMeTLbvhhDG28nqtAmuc4M=", "F43zavZ334GrqKn6nTH5lTeNH2nXggWPfvdpVVrVNj0=", "CInIfziwJEaFAUMS03muWuk0UxuiC36J9uHpdeltW+0=", "KImOy2oS2ZlHT3zZjn0OPrnaQEy0XekoURW2R8rzECs=", "FUS2B+4lhzzDF/briLcrqTcf9SvLZHU7DpDc72EDJgQ=", "Awt0EmTHOVBjW6Ya474y62Q9mnj7am9pWtQEbxspqH0=", "JQUtM4HhGMGZXOIOvunxz2FQU8r00szBQ/sebEzhVPk=", "LzC+qJL48rM1uOi9kl8kQzXkMPDHeiMTAT3dbtQN4Ko=", "Cw1l+naOBqqOWxrqMqLQ6qddJUgpYmjXvcHEt6IjSYk=", "H6GhAUujZDbBp9jOoYWAxXeSgintjjDOlNq9mLhz/ic=", "MBxQZDOCjsz/+/iXV9UmksfsYz8y5yat6fuJ94ORUKU=", "AVSnEQVp3OLU37sMTVkGaYEXUVWKBiB6FgK+8Q00KO4=", "LyfA3Wc9Y1OEBhLRz97IlAfXoj4lZ40fxXqvIQNVqEs=", "BIaDvNQ4iIXdOVb7g+GJBxDH0cxdEDtIwut6TkjTxa0=", "FRw2SKAq2STumv6N+n8WMDPRaDqorZUIpslqspwIkIs=", "FLqnCt3566SoC72gPS/OkuVxSG7ag/DA/lmn5GBersU=", "C6bNlyy7OQXtl2ti7TTZckRNghHHH4KnnAif73oDDk0=", "Ja3JE42CPu6XsNz55xQsTXkbq5LBAhXVtPRO4WbEQBg=", "DwQWmXpBjSogzaxsU+Z2QNo6tLXK1ao8nEQu+4lbd0Q=", "HcPk5dny5Yf9lQKMY3KjBNmH7aBSWHnRt9p8d18KQX8=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "DNrNJICE++ee8xTLBqlvkpzpT1JTAeiFjmsKtBmnskc=", "KHZd9NC3WRWyAAU44Ap9zIIZxuQo6C9FLOiILmCe75k=", "DoGlWS7tq1F6BRy3I1yL8NwMMyJYplym4pqGJaM0/o4=", "CIwGS/fFU8fk0bOEJYg/VNV/GKf46YAOBqPCMQ8BsrQ=", "HSQzNGhyjAMPAaPJP+A16f6RPzIixxScwi4h1ET6SfI=", "CB5NATJsRZbRbV2d9AagY/DGsyPiqOQGsniDkaayrd8=", "A1KloPrHgaFqLYvXLJQCo7HTYZm9TqRhJeM8M3MqsxE=", "AmYYvA/YFGTyP24i/Bn611PfGzwHYnXJXg/8Q3dg+7w=", "Aii3ASRoDJkb6Uug+AFuOEYJ56f9sqtA1mFhTWWlIZM=", "HQugZ4NPpUtQNHKXo1JaYZi/x9R91HEGByx5AbkApKA=", "GWsWtKPyZBzGs0OlemaGf5a+RQBd+cn8nQdxABCh3wo=", "L0VpX/FIyse9NIsJPZTgdac/T2C1IifrjtYEj7xHrrA=", "6TKJx0FAKqG8FS3YK0iJtlfbKUTdbMXJy9jnLmkGPg==", "EjOA7MbAnaXp9a0tKY3GDdCp03pLZ9SDPS/kKK56jbI=", "CIPoBCGdXt/hsL+uaKdt8Y8cqTkge2sL//e+9DCccYc=", "AhWIWI3svC8z/yWjif7JX0Kfv0O1SrI6sg05FKuETqs=", "GCxaUv5sbSqsOKL8Bv+2VZWhykEQywmrb1Bw9ZYvxHg=", "BqWN7xHxwnzSNL19m+BGEPUraFddlWDT3M+K2bW3Qdw=", "Kcu7XKssnf/FsSySMK+qWcfQsYRv+bvQ4x3jIYr7d0I=", "CaHU9PADI2MNxPLTJqXKKCPneUTr8cIsuTQ5Y8Yn8Xs=", "JfUVf4oZDmv7serpzVWBlgkiChlv2JzUS1tGA+gOh6Y=", "LweU569odLdGO/nX9/bNK5FBsscXVOSo5Ifia3I9DY0=", "KoFsvDFetyWZW2q3Bsbah1e+xvWIhJ+F0QsxdnmYvUw=", "LF/ZLLaZBZDmIFYgV2jaJcgTLYvtnMeH5zuB3Z3cVEg=", "LoAnagS0hrGjaqr3wV0ba0vUgjgGXO9eqxwVMjXKaTc=", "FSV6d9RF3eklnGFRwK9qF3H1wjkkpMT3/tWGac5Jv6Q=", "EhnAB+lmTYpUvnOgMmLQO/4V6zovjnyRlCcSNetDWBQ=", "CVFExyG6OxgyTlXlMohc5nYTRE08s+lZVdcgHXeYEtg=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "EBpkYkGoMV8gTUGtt/rYOxpQLqCefN2BWyFiXMDr4Jw=", "GSgtaWe9IgkeNMR/5yJm4crcn1jU9GedySVcCcKFSWM=", "BCsuk2XpX2tq/sQWMtmpM/R0QQYxXj3y62Yz+4c1avI=", "CG7WtJUR1r1IFcdlE4Cad8J35QbDBSwr7e2WBmI6TJk=", "WKT2a6FYwaootlGRfx+8dEtShrP2ZyrTn+F3vlAzRQ==", "KN3hC8+Jaap6W2uh1I4tzD9p37siRWbLP8l3JEoZbNE=", "A4QrYd8YMrxrTg6nDXEx97JWGpT3jeM3Gql20F1jWJQ=", "LDvt3a+5S5QnmTwZv6GUcu2MwGYITHz6XF5/gDp1gr8=", "FjVBt5+B238nQu+jWE8H4efdJaGa2TRiPhS4f5lgF5A=", "GEby5blvirvyCipu0NmiYzNzEDcs9XCjGNw8kchJ8RI=", "BsejzuP0Fm5iEvk/fW7/YBA88W4lLfMNEQz6AQIzGxU=", "Jb4ZT2o9aeO/Xwt89YAwp2HmKLGk3gA9nooC/CCA73Q=", "Jpn7b3ExYkTBCyxnKy+/B38hfhyRDM7wZSSvgPnD/g8=", "Ag45E3iZ/A0sU5H+GFOUFzAD+vh83z5Dh5ixZmFGtWw=", "IrlhXp0bWCkhSMWqqMnu5dVAqmK6yTzL4WxbZXFh2lk=", "F6QDnPkPssjKeKKrhHTl/NG8x91JdDAhKIkPeSlgpyI=", "KWp5R+0IFiElIfgsyDbxt0dkDtkxHlqEMrJPExq/dNo=", "DmIi0fZYAhrhqMg/7xB4tU/ilxnTCjDjPpVTAUCyrF4=", "JKgy0LYtf+2yQbKJ6V/H9FB1VsQiGDzfG6/RpRYwGWA=", "AxSXj/vTaxv2tu//nO/9/SLDEo2rAwNbxNGBHtOiJGU=", "I0Vv7eu+9D8VQUC1bwEGx7Olt81g984qCFpZ0hk2QIA=", "K9/TqkvKiUMS6fOSGSWW7+eq2+eywiqumQwYzjLFbyw=", "F2fY6H/43ehEuGGvFy8BGoCU8sk/FKNn4/QAhBR3mZY=", "Ca/qO4A5ASCcYPvtdklHSOOvcEzT1o9tzYRrWzfv11I=", "Hu+afwgDMUcd0p19AQa5WxzzCFTCAdDHNUaZ8sD/GPo=", "GsDfh4j3trJkxLX7HRX59DzLaRT6YnpkVL17EHOY8yg=", "FTWH3YhW7xxbpYTLxcYgb/JzFhEbywiaNwAOAf4SFWw=", "HsNCLwHTZ962Vm6j83yq66bm8aubSH5q3Nmr5/otF6M=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "CSqzYgcb5k7h3v5MRksY6pVwA93U+yXvHOjJPrDaZ+I=", "IIfEgSvQ0D2XGXnzQSVuKEpoa2NWS5E8YgPjozFqC74=", "FenTevseCHfFXNUhy3nF8gZY+PI4uGeaUKv6te3UmK0=", "LTrvXxWMNMEv6ExNSNSd/Esn7zrZ9unCm5UWvoXfIz4=", "JEo9R2sKBpAVihvt/yjPq4v29bpEkWkTJuaxtxuyZQs=", "EOnQRs3sRRJPe9OqxEa38OulaN80YshsYHUc4+UcPuE=", "JZAolYntwxEuXYe09HSQT6ndTcTyYpjR6WZsKB3Vg1c=", "E3ZeDKk8twi5zx7LZCfxoN8LU6fRErwaFDnDr8jowTo=", "GW0xkmUbHotbHPVOd17qOk9NZ+YNsvC+OA7kiBn9SV4=", "GMgeTvGccnbZzanZveCz1DNPR0jHbbUr3Eyw3pHe86U=", "JfQibOLJkv22r/wshcjKZMnbSG6Ecfk+MNlwRetK7lg=", "KhUsg3acmpdTgpV+rMhiRZ5CJwgO9Jd3UnOZXD8ww+c=", "E73G8mlAJLHiHj/nsoHkSkjjLDGugVruooooMYe/znM=", "GL5Q3VZKe4YrufP9giqebPhScpDQ//0phrbvsOTsPsw=", "B2tonPb8JnRpFMERh2Qq1FuTS526hJnh4PZF0ec2CXY=", "JMuWIg0C59GDzSjN2JAkZH3yHeulXiC7ClKZCe1IPbU=", "EJJhSC2O7+3ZVV6qLURm4blYLNtQ2tlo9zrZbfg7avo=", "JPM4UP5NcBn/r71mlTJ4jQLGoNuzmUitoLB/REqoJO8=", "F1Npra76Jppmuuwy/9YNG+DuHznKhSXctzpjV4YKuy4=", "Jbn+x8x/ZR6DVNeq6G3Js5ZPvexEDGyDaf6oHuqq6LE=", "LQyLgt5c5MVQJfzShunKV1w7C5Cn2l9negUEwFpLDLc=", "InQ33QY86m67hfe1ZCMtIr4pzdd3JkCTbDaYt8n+z2Y=", "G7ulv8igEMsl9je6aGFX7qRvgghI/Cwvxjb5M9QBQQE=", "FEcRAqXsSQmt0sc9osYMpRiAnx4WC+ff0Upumzl2g+Y=", "GxP7SnFqhmG9mEV0tVJJeEV2uDRvwkX6f/EVTnSGI+U=", "AmNEw09FMnRGOq8XB0hVCj5c04+w3/8XOi/8oKfy3e0=", "JUG2LIpS/73Snqh64JGSJeEtyr4hBLX0cIcIos9Pw4w=", "D72SK3PxbWYUWMZ797SzJarzA8WhKQKmZ6eMhQcDaXY=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "I1XwO6BypiC1aOfTENn6Y50TT/2YVhzb0il76xPqDxA=", "Jf9LsFuW8KCwVWIFeo25n5fh4pURN8DED6ky3nPKGe0=", "La+VDIAVT258SXBNcF4UhxJzSZ8vYZuGxcXRV6YgPf0=", "BRzvzNuM9pKLkcMSd0fXAOhoRPEUjwo0xtd8W4Sf5pA=", "I4Ji7FRn1q80OzNUPNX9zfkJBiyE+BL+Aa7VzIf8R2s=", "C32spAb8NsaaqVj6YW9IONYand4uRayLx4j7LLIQGeQ=", "FbyDxeaASNNqud1XUJgsCG6/DRVSVNiYxg5kQjHFThM=", "HGOWHVAdCMQ1WKe7tq3wJIzn2FxG7Y0Yy1f9JV1w2oc=", "JQm7gWn9u9R9olpyKe6m3tHGGdPAR7eDiqrOJpNlZzI=", "BppQ1MHuwaDtUCdMb6SGfvZY3BN52Pv5h41LNen6mb8=", "FddMCHLpsRZJks4DlMq5/XIyIOBpbSjqARYgcWvhrxc=", "ELDIFRkIY0IrQti/vGiSHR7VYQVa5QV7RcXka+Wm604=", "DBHDBrUhHrNvy+UFp1QFIlLdxiLQL0Qgx3OQhR1sQtI=", "FQz8pEW5M2ziLfytEXX1l3lLL0v9GKl4DqoS7vLuXFU=", "GU3jHQzhhmCqdGqTVtlgcM4jeUTlMEYwiEh0ovunmNU=", "FMIHHZ19+Ai1CxnnfjFEBq7osznEokWydwuAKveQ67U=", "FYR8eaqOHJLBjDv/MCwx6zjwAYBMgpH9WQy5Alp9EqM=", "D7uh1UiXiC3mx9JiA6qWw9sp14iwvUNcHTVMJxsSaXM=", "AaO37mxPJOqS0iKLS3YCI/mjTY9ww4ckAJILwGZGWHc=", "LOYQFcweVSCoPAEk84qDWcrtpTBRGUcCSF4AzC7QK/Q=", "K4vgOimg6Ptiu8IH5YfetG7aW9vpnlIudzv2Pmz/YzQ=", "EF4a7fDPnxKtJBakT79FjWI37olZYLuMJSmaxyveEvI=", "EgxQTo6Z7rFlOSSWEusalofi+Z5P7IASPwwpN4VTu/g=", "DzWsOSW2bVK95doxZVsR35l1vgDvy8p9ok6FUJ3qL1A=", "D0lXFplY8guMsk3dLB+oZou1aU+4LCd5qT4tmTwqQ2k=", "B/YbPMXxIgU1zcYwuQMxcsAq+gp5iKV8NzqRwTJj2AU=", "DhZCmklaCHgomk4YevKzueA5XKNAGTi3DwfAZHJzrY0=", "GBkM71BYnmxz+vNItc2Ivo3LtE837N9w6Uo7QEX7JiA=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "In8jIWTE48dBr6Ew0gbNhNg15IF8S6uZzqvgv02ldd8=", "Gx0JyLeuqVHUXPE5DJWwPCn2ggSSziR4c53wm5vw/lo=", "G9BAzc/e2ebQjT1ru/VahqumqlwTzwn/TMbbKEIKGDA=", "LE0vFlNWMvBQJWCG3U4siEeaHTaE7LjCX88wlrPhpso=", "Dq15C/q8foH3zjttaBNChpd8YZoT7+9awRAkRyHAl6k=", "CJAHVDWKXZcWxuL8FxM9qQaXlPrdQkECE7XjDn26dWU=", "JMBjH1GJBNagA+Ils009AuLlZF98a8689PmUT61Bnyo=", "CexhBaBXYh+b0Y/hPp3t4evtzm1yRh3BxPqr+hqn8QU=", "B5sDQ8hl4HNGJ2eyAhP/qUQ9sDh8lQZQNYbuUzMC6AI=", "B99j0UK9bCnuA6yo0dVCiSCn/eZDe5SRSTJ8KWfRQkU=", "L/JsgWnOxiAy9yrCVlCmyUoYr8p9BNoOMpHTznGncRw=", "Fk7au/7toEaITk+FleQ4Enwy+EZ9nech+1CoFmiOM9s=", "C/gwavR1E2owWlp4uBjB8tSaufoYHBHeUW44qW6/n1U=", "FtpRvzK04TS9sFkm97l1Vip/L8tnG/BYT7Dk0z8zY4w=", "FCkwyqGCi9hC4oyHkN+dAz7vrnsWXdzlP81G+G074vA=", "Gufgpy6brTg9CdBVWh9aC/F1POGhfiVLSb7w/Imabpk=", "KAMT334GbfHLY5pLMOoqp4ukZyBZXXfuMbVd4qcT3FQ=", "AbpiBV1KazJX+ma0cfEb6XlCLAXTqDnuaq/+esHAskc=", "D93GyktFd4xJp9spPHhihDHtyDBRK3scjldU7S85/wQ=", "CSnTLfU/GW6FipexeLHUfkIkfV3PN7CLSFKtdPnMeKg=", "D5Z9FJD/oygAcacYATs65/lyd1XSYfodhcPvewVZKD8=", "D1SQqJtfyVwRXaF+GBp+lbPT0iKec1gca+qJoO31Qhs=", "BnS/4Xf9wTAfHUnCh5c0yuFiiY0RAABQc0QCx1OExzY=", "GOGt49ce72exSZVVUWZx7Jl4oTxdoys8yHo3OmUV62Y=", "H5F5r7f1l1vlN1aNqQP+CZROJXsnV5NMzy42FJAh8Ak=", "DBGiVsNcY4pl8C10XTVxL9MDvX0xNzEaEyIzlAJHnug=", "KrVXhD27y/8Uez8D3hX+eejUDpzWzFVrEpWL7nqQD2c=", "Fo3RJ7pFgoSOrDZNc36HvQICS4kktK3aMamjejQVzqQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "LE1CenvsjRlhcEU2DlJ5THoabeecTpGWmKh+xRY2bMo=", "A20BoW8wvYAlRN8WnHfqAsAAg0LNikFeZ+SfKrIFOLg=", "EE2tp7crJEBdwHpP6vo4X91uh9DrDQsNRhvOVsT1dNQ=", "HRic4VQBkxJ0JuaMfvv2EWvilPTjnCrH+0PuzipSMPI=", "IJacHFp1N9YTMTk/aloq0V6/Ue+s9rYfN8CMjqCCPNY=", "Fyf4sOuVlSKbrzBbP8mcUdU4Y34tLqiTEDfHNQ1flso=", "GJf2GcYVqS/AgqWJ2Jp8UiYlQyIT1qkvrZ4mJqoO55s=", "H2JZkUPx8yzU77Qz8U7RRURoGHjbVYePE+aWlKIms/Y=", "EYwskoSNaq7aXIth2O1pU7e2WaJe+uYC+ZYTU/fHgdU=", "GJlyielGg55sNVQZS4fmwNTL8w9HvHOxJtbuvkehzsY=", "Ew2m6zRN7mQDf7UTcDyqltiquoP3yAmTCLTmyCsUzYM=", "JFNXsLYSxK6xJUDbmuFSZRPniFzlDujKC1jFv1QmFWM=", "Fu+s1ILgfx/uGMlq0XJaqjPKxJTU5zAaoXPxwppiVYE=", "Gq8oKg20FyNLLwr814KHTsKmNYmfPr3zP0utEYrN+uw=", "C7Fumib25ESQFqOS9YzAq9wVg4zsCGOhXPJHN7epyAQ=", "GrCR4EOgMqGooXh1wJkw8vP48BSWaXfHZy4FI4eohyQ=", "F6GxteBzAq/hFWNyaRNWrTL3erlbbcF2bP3UwC0mDg4=", "GY+MICEoFQKpIqA7BLNBhXHUzk9TWcolEBXkd/2YPZY=", "HNcFvFDadkLo9Bl1q7KsY1k86VdaDr4OxBLjPClVExw=", "L2NLxuaI2utksRtxeAMH2ZiRbqfbTNesB2GgPdP7F0Q=", "Bw794GFXA0bKFIlV3uKEY04otPXvFNCQGOKJpba1xkM=", "Ep4foD5DdLaqfMLMvDXiCmEkuE899Ju8w/WqHCX4Vno=", "CHJ1Dn5OAIZ8opqrGbAiEZHomk5+F/vA4Kl6a5nXmBY=", "I+jEPFe53G/WuJmBikQgDiVEvwhl/crFtCVnd/x2WSg=", "Kmt5TNA8cO8GiFy1rQFpjyNAh3pahIyPSe3pO1yegws=", "CUV4QJ1kYufiWtnQgWpvbisZjEZHlsnI1P1WbfJmCZ0=", "GythH4U0WLs/krB9l/So0P4yO2NZWWZNcAOs5EZGucY=", "IFsPorby66rUGr0rH+tPevADtec/kdNC3Blq4YL76iE=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "GIE8F6GZFwnfw9Ic71GtK1pyhzHbNpwk9TycGPdTeSI=", "KOLxSR+qExKy/AdW/JPm+vJgzzyaeYxMdVZ+biRQ8Yk=", "JFbPlNf/bhJM+FnVxB5M84526WxmNW30lZr5DoTKprc=", "GdAfrj5r8qPXOOWtwUDMsFZnSKvXkyPbMIX9G9OpOKg=", "Fbm7jBZT5kTwzpvlC8WZvlQ9GBqWXEex5V51wSjfZFE=", "CvVKNIa0TWzTRNdnlIyLq4ajt3BzDVeNNclGB2ulVig=", "AsQDkz2f3OmyNW6lWZoXym+ixSdHJwLTOhu+HcZIFYU=", "H4YASAOZKRvNuPK9RBDKwW9MwDVZmm5/f8OJbclVleQ=", "IIU7c24e9n/I3RZdP+EaZzQofvy7ZST7bq4aZqex6N8=", "L0YwoPABiwTGu3foR3bgbjskUtR74tFiIOrR2mEQayA=", "K5A2xI+a8bMghePq6fVBxOp7ZQ8aUibqZhuRJSFeiZU=", "FuBlMLNwupzgMOzDDwY7wGTXFt54zXTCJi1INAbg5o0=", "FpZfwmLgyoeaky1yHpXRaVMinup7PpXL4yW0i79OhR8=", "KCNh5hNlvkR8lAvHuMrd7xCoLopRQj584X9MzIrGgm4=", "Dl8FvD0vJ+r0i6bvu5X9M9Kd2dNxr9tGBlCJ8Htaqtc=", "BF5J0F6C+cgZKj/TyTbnPtB/Dt1tsAByBWlaI8knK6Y=", "Guw2Adx+r2FPgSy8Al6gadKtHrKxyLtgJQDNyLTsl9c=", "KRguXxnY5I4Tt6mKGb5FUvCbRS0Ok/uHazZyy9vUjYI=", "DoL5/rUH/RePDiwMMk4H3O3NwMsq10PO604rYt0TVeM=", "CcC/Awg8en+E2tYos1KKiQAdQxAAOUkbs3KTGb118wQ=", "GsCMS8MiKCUX0+kgHGAYIxZYgqCfg+Q/rIRsFiCqAbg=", "JWYb+3bZdqpjKR3iYk5/MGpQ7EoyEoo5vLts/jSiJ9A=", "Lfv3Eon1f61nvjQ4zB8NvJaVKZQqYjqJmt3+t37xlF4=", "CAWqqfEqF78BKIzKaK7BDPCNtrz0mou1btv/uX9oht8=", "K/6n15oXcg318hXUKrVzYJjIPaB1+suWTrL+9zCyJWQ=", "KXMV7XrG+byStN1KQFJRmlApznyX7vhP8RpGGGTb+dg=", "FylgcEynQiLN2cjr8YIQMTErTCHLsoLB8Rze4+woKEw=", "FLMKjpDuah4i/eIVAwlLr6PWEASzimnPlLST4QGj3Sk=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "JcL7k3WKNjJ9vrff7JDjMcrQWgTlyE5rQOZZh9c+5Eg=", "Fb5vIsvV847HD5Ez6Dkuj9tB8o2DHCe8s25BX8+f6EM=", "HSGH6a+XDO/ulJ0IiMc9xB5+JX4yep8g5GSJKFUeBio=", "Bpndy5HoVr0lvsiyGYC7sWPTiiDUf6nYE6MjJOgKx5s=", "D87Qod5kCTlHYWreV3Pg97oi6sSGIyLdXseH/f/jMl8=", "J3aLKWNaQA02XJNCAuS97XGd+O/62F5u6r7cJKQVSIg=", "Gx9mQq2HEGzRbsVCGzjEA5JCP+DRLygu/IR07+uVfR4=", "Cj42XTFZCEzGc6RARL3UJg4b0lt090Z3Kjx37z5Iy5o=", "JBedXmSZHUWgY02kNRDM8KNAWWleFRaCudNWQR7bfPU=", "D7u7Z6qIZVVk3jiBTsY3b02pfuJ0WGxSh8Fj0bD5jdU=", "Ee3VQ42bQWjW4ruu0x8x6kZNurgO1ecCEm/YLtODUOs=", "G3bPXiGe1LwxGgDNsD4o/7+GVCy9AlLQcVu0hGnBXdY=", "FIQ3sywrxIli01b/yqTtwFvphBNPt185VtXZEET3k5M=", "EJQiB6X2a7glKYhzD7gvI6Rb4mOJSJ9m2m+hE6QKsMA=", "EkaB4oYj9CGW6K17sjdMd0h8N0hbuhqQdYWVgtEMBhs=", "L53FsV3ECOfpfq07nYz8ZU9pFJIuM9e79MBhzYWDuy4=", "EVl+j0VyHQ+KKQDseCMwIAMoKq+ru9//xk5fPKonR3c=", "FO53Gx6A8jsvxY0vmNQ6dd3ipcfTf7DsOpC2Ye5PGRs=", "IhQqy/hKA9+NFt0uptrYtBAPhk5dqy9q+qako2YSpME=", "F8yiXD1F0ipX/pBKsg+RbZsYkNW39w9W5XMjJaeQ5jc=", "AxIAQbHDpMh0RWcjMyg/4o0Y8F3rXH6f3ObNp/pNBpo=", "CWWxjpO96EodhCSnTmnraq56c/ySDlz16GQQpGUR/6w=", "A2AfKgBY+F76g1xe8CdnGfgHedhU6IE3Cj1BUKaKS2U=", "FPBFTLbdrwlXllGq6iBTIDbub1S9mJNhSy6tz8BB11Y=", "EYROPXNzGqdu3SSvuCpJ1gyGHqolV5xF/LI95qRWZ9M=", "DUmzyN5cigCe+5ERbQGfl8Ae5Sicpma2gH/In6BpfjI=", "FaxmII1T9zDZlavFzXLVCtkJCcjNzhfFqni8CydKhXE=", "HJxcsC+3i+UIqBigcN7raWPGh9zil1qkWTqJ/x6mdaA=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "IQtd2Le/4VGJ066o5Ttbt7RiIE6Orh+Vlr+/HKtye8w=", "HnLhHyGrwipPaLN03YcmoscvmJHetlNvOkvtmM7ECFg=", "HQ6kjRCeN7pNFEpCUQZtbXt5EL+S9Erv5wgQJ+HpT/s=", "GcbJ5U3YMUp3axsejUI8sv1bbUlR86vfcXaHWgg3s+g=", "FyK9IAUHE0B6tCi0oVmNvOhuagT5CT0NQVtUa8HSZek=", "G+6e4Fd/SkbpUA8gZt+//Lr3dSEUUPUh4TrOrNUZAQ0=", "BPHDJsiAcqBTMq0U0l7ekNQwOUvY6AMh3WhppWEoLjc=", "LbSd/msvb484EC4BkgapCFA+Jozb1f12iYVZMjlJUuU=", "GMrPX8vh44NwbCrm4pTGkeuGB05hFDkgDzm0nbJzlAk=", "AlHjnv3WBuXv7v5Dmh0B2s/WwpcpRy7YhBYNQBjR5RA=", "IMpKvTFOOG0BVCNKlLxbhVIqFzDABVKKdNfyFH5ElDc=", "D9jTCSvKe1W3zOz5QXKthu6wM2JXEIyloXhsuIvnJJ8=", "FKJi47+uFeA0Wh+DfxNDsrJF+j3HBpVr3WSnTEjobiM=", "IeVEkZKPOQSBQ3M0CqZaD5e+Utvq2bkQEfxFSy3I9uo=", "GkGRi4xo6o1nUzD2GEGTAs20TXxIIVYb8/dfEIJMwGw=", "IZMERftfUlFZoX2pSi3U0oSFeUgBsMmmlLA7hJ4IeNo=", "F1Na89lS8qNWVUrQGDaX7sHIbtnbESEDbeid+PdYx88=", "GoLzyUPID+TuN7I4FGFC3ss4nWmRig16vZemkeKrgPI=", "BTuULG8hDwc/qcWPbmB9pPysra415b6jTutqVMyi7rw=", "DTT5G3Q6a6UsMgUr0GI4BPyM8r04S8mAAkNKLJYUM3w=", "J0m3yFxxrfvrWQC2M0xNq8mSXpiFyaUl508e2x5jCo8=", "IoSg8e5qhv9EfVHmQpUcp2pQ/D9MDQCSKKpn+amx+VM=", "IsfyUFPRHoh5CbAq995+V/W1+dN/91rNjM27dLcX4jo=", "KcMOqRZnUEXLmW89LzZiyuEV5oIjKfk6TRWfGK/PxJs=", "DlVc37FXbpu1y3CpI0pukji5EsnWUQDy3V8xML9aAA8=", "LxbmqeC9b8C0HZG9Bl9g28NheWB1Rf1Y8LHm77yG4XI=", "JfJh6ZmB0/0rCUoT390U4azi0BAJc84DMQgYJrjGnKc=", "FNG0veB+qCUF68T0+bWZyiFKCZ4IGihqIjv4MJ6bE0g=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "DCFh0N/h+xsDDSW6nnLi0PnHvhHtw+4DEN/33sPtEOA=", "Heclx/bJlXIeGh0KkMsxVjEQ7q+BRWo/ipgJRAyenhQ=", "EjiZaJUBFvAXev4rdzJgi6+l6NUDk2aIRPnbUEVXKaY=", "F6qiBizd5X9KZ8cFLAmQugiz6HRjPdQSN8tglCRtZ4w=", "C5mEc37AplQfSEyf5IN6djm1jQF83M0r6zBak3oLebA=", "AyCYLXVhdvhS3NdM6L4Va11/ktuZ31zLxcyW6T2Ddz0=", "KkMZ0LwE5MGLmxBZg8h0TKTPxCjyDqR36aYEQcoVzVI=", "GCuUNOidtUe9SZpRIq13hUVilizwQ14h2WDRxEmO218=", "HSarwL7LDkItNvTFmzT2/ne6dxGSsvytyM0JZb8Mz7E=", "CVip3OG2oXYg37VMNkrz7kKNyTLYHR3EZpUDhA3LVB8=", "CopwqDedcRNvvneFFhfL+dUiV8MsnDykyAeMkM7XFg8=", "IIqahAAlvAw4uIMhP7u0LDEcTXo/HC1TkkmZiS+p+TE=", "HxrOwXZrJXddtDmSmxVQc0/YIEt3r6sJ5CUaLh4SNmQ=", "A4flGSDt8GtkxrvzqpHW3oCkw6alVJPEywOPVas3m5c=", "KDo7CZs3pgNpQmVpKV4ZGWNaX1V8JuLZvWICTtQvbLE=", "A6grB0hqYedp1PSpaREpsUl+rR6i3NTUT9tiazH6TCw=", "Fa6ntqROAb0qGZOoJLt1F3PW/yDTRZl08AYCmCsg+Dc=", "CRODqo7lgCSn0OqsumYfoK+gQtRJC7AgYaAFeZ2JJv0=", "HEc40y/thGKZZ6JJEh0lr9p1jsZrglcw9MAXHwWYGCY=", "BeEKKb6yAqUjgzijy2862B940ESnkcsDz9YzZ2eDc8c=", "DjQFWCphT07ChGXMyuOC7j5W/Gf0V0hG9aARwq5LsxY=", "E8LhhzaHElQ0bnlR2ldYo7/brqSjfGL1IE4tgzyf/sY=", "DokqCP1NF/J36xbYz26mCoqyY+0xfCCXDFTgJlW7vU0=", "A4wjAmVCQk/Klyn1lZ1rejANfIZj3C3n1jyY+3N8iF0=", "JCVgh1okzL3tkoww5MeOKPNpdbF2eTOIjzo+7cTlZ1k=", "DjLsbWyA07rAqtFjX7GVq2QN417Z4Z5gAzdRubF7eTg=", "En+B2RWnVGyy01ZZGB9woxzaaxwPARzz1NLZCORHVfs=", "L+6xw/MIE5rk8jztSivT33XH2+f/nYmrMUBf9OH4gDQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Gr/RV9ZbD6reZwxgD5ZKBYJTlpH5CaJ/E0Kufx0fFlk=", "KH7fmAkSL+f0JHSL6rYEwEJw3Eu1SZMqtJ2z5CzPZ14=", "BXRifNC48CAzYhtF7gKTN20pgR8U3HAbaqxFZcXiNG4=", "E740TO/jyyPYTeJsuNzvnsId5OJ1Z1y4HY4HG1LbvFQ=", "K9BMLevyRKecIsNj4GVtyonuSmQRN2AiaHluBI8iL/4=", "IWcXWc47f6O43SnvS+g20BHIAukKW9KFDbQj8LhLj5c=", "FeLsofTyTFNO6Z9JJhMYW27uNdqmAe9cc8zBshg7WSg=", "GsQoocQDrKzqWxnrWp20SLrbCC6vEqC9s54z3hsqz/U=", "GNBW/giGtTQucJh6p41nYOh+v4QPzlSrN5AVmiNZumM=", "EDR43oJpl1bImGkK0EMbGmLQd5sHJyiy6Pnxw9wP3EQ=", "A60zRdTgua8gpazrzSPwZ8zYqtMQmsfRgEMCQqCDvvM=", "CEoqChl6divWxjPteJrhySrz0YlCGAHiz/TKTLe7S5s=", "C5+sPxtbd2m/NpeA7ern1ACVhtju0333YT2FMiQKSys=", "K2xaWwsumZxS04XB7EG/b6i+5ixr4eSJbsbuvLZXfw==", "K4kVZqg0Mu9Da0w3n4AzxCl9c+QTq2093iikRnJ9bQE=", "IVCTy6xM1qVngQ+Cmrxl1VbHx9gZN3cFRsaP7psLxao=", "BZVCzwLZ7XruC3LaDsUJIEO+aMU+QgfkydBc3uJiDJU=", "LF24Syg7meIcLXOH/L09cbzCYs62Fjee1TfinT1PRRE=", "I6hLydXn9GcSCSf5Vw48Rkamqx1xd99KCXLEJYjqR9o=", "GvYsHdb54FJvjE63FvLLCHEitu+6sI/jKvMNdoJcflk=", "JA3xIJpNw8+i5X5OC4NpuBri1TDuHgIvRUdu89VUHxQ=", "HWY+cW3J5oHzJSF83TOU4Siv4m5yej503yQmN4HDcKk=", "KAk1y4zmlr5PqI51As8BYS2VXXg7hwMCSoXMd2upi7E=", "E9y++owUqYv3PnIuaqIzYQsAxGh6Kbrcp84jkHSwttg=", "EBhEKcA6an3LCTsGpBgM+MKx6+N4alpYFJOYqAv4UBU=", "K5uRyOKalNZVM4t2GDjBaY5LjLdRoQOwo1vKc4BBPmE=", "DoA290xR0R38dE9obuIPYt+0W/mbva9DpVErCHVmNp0=", "HiC4WmTkX+u6w/X7+7ix78ERzVfIzVboPdUb9ipLKQM=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "J9P+/D/HE/ndsuP7WklD5VwzbZiB9GNTLmO9MleCUJU=", "Bkxms7sf3NFp09Fc1R1fe1mGQuKQIHkRACtlJpP0ipo=", "DppTh/Of/24ltMRgzFDB2anXcuiJrXs9NX8Bbre7qv4=", "MDcuP9fKfPhfXF/OZN7/wusva8Hw+BuUR87XFOTdR+M=", "HGmMH7drk9YDbwGWFILo22cNqBeKpmxX6o1vAiGARsA=", "AWV0XDIYUoVF9nHNB/4qUh8s1qXMJoYBsSC5eUpYOy8=", "G9askuwG9qwfHzSM4fVgjmBnmnoTx9N/iBwUcjN0kHI=", "BkaiyO1Hdhn2Ebrxn18jFdAw2TSF18cqBX11IbBRJs0=", "DF1+zjfLlJxfz539crYglR7PpUEfisf5z2cGNGB3su4=", "Dg+VBiYRCJ0wzxZB759RQtXAlndCjd4qW3CZDOmIYsE=", "EWffze9oToAu4K0nRbRIvJSIZ3+0qfIfQwatQ46KcVQ=", "CLWNnIfqaV3e9FV6F8bGzos0sg7PHd41XU9WT1KdnlI=", "LAwMDKqAmQqos9sLCTdI9tQUi31W1qyESDY9WS1JW7Q=", "Is+PUQ4V27VN16qqmsu3nZPJHKpnkAaYIvF+rcWPO+4=", "HcvcyHxlGjmhy79KJClRLvXT1dLvjCwnK7EZQ/Fdxz8=", "Jo928dz19EXzGlw+L3f5Nw8MA52lGgvPSZ6JxQ3ecuo=", "EupL4jzvK8WIosXT8KRz2G/i5iqgXkmT/Y48OgT8gd4=", "CqihtCSApDOXIADmtxS9YgXNAg44ergM54i00kSJPZs=", "CcljXpPvER/JlbD0EYHWRFB6lq3FA2YmAl0UxnKANA4=", "LxlUInavrj+b8ti8H/JSd2NLXkRjHIij7e3TCaNfwjg=", "K/COStkxhGXQEbb602lT3VcuGgbmrgSsvdz95C6myXg=", "LkFe6BhZD/9KjroU3C24nqtFVHH8tIcjoj0ovQfyIYE=", "K6GxNIhXoN3bFF/TcMSlFFeUtVX+kKqrMOqru4MeV7I=", "LEWzjCLRg0+tlBRuzZ4ghPoIAdTSUA08mwLf2uLGhtU=", "BV/eT6USOK4VE2DQuz5T1ryIRUQ04KPn6BiGlx9E8b0=", "G1AMCR1RiHjWC7nB5GSHEg+vzAfZkHD2q+uUz3LQmcE=", "FQfICsmIodZqm31+DUiePfqQPczdOcvjDWbnCkRlz9o=", "LFOJxMPX21U07JaXXiSzQbuKOVCBfJX6aIb/oX43Ka0=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "Ig1mj0McoxMY3as6fWmeHazMJoHBnih4IkW/Bqo5Pu4=", "D4LHNQimgCdXQcVEmiEIsLTeq7etzgVpXGqaVkkbCck=", "CB0ty+VV6tf+o2UOx54gwBrqG9hpQgTPy1P0QO6fDEw=", "Etbe9P6zuWlfOjMwXBkNQbRDYP5Pft7Ja5rC7l0Z0jc=", "GIpwWVI2mRtUk5bdg9wRCreEgUMyD/vYv7uNBn2qDcI=", "HuXNn/yDRz0lLabV8iCjKw8UBU7YfkfRY/YRsKA8BQA=", "Azb0QwgeTk7y+A2qDUJzdttZpc1E0JxMpPztghPEl5I=", "LjH1mlStdbk1x5aN7MrkTHZRxpieehlNjrddtW88jm4=", "D8Zv5uifnGuPz7G4JaOUt5FAS0xTXbAhBaDPm4FHGMs=", "AZOSYUYCJT8Y//bGrdAQQfvxrFc8Qwuv0b6dC+1mH54=", "JrxpbJAigBtVWPE6JAwvJZXLo9kjdAuxX4VwEtZbTjA=", "A+QfglTuqSDhdtq2aklKrCapBQpggzIa7T6cYNpg8w8=", "J34Tz5Nlc8nqV/7FS8INy3a5uyLkPdfT8MiMzENQ1M0=", "EAeQ6ygVK+O77EnRlxnx6BlVnguDzT+l9Vs/EeK6fFs=", "CKW8xJqO9Lccy6V3QiuRv3sOuHPtT4GaA/hLeyKzdIs=", "D+F83MezQxXClMmv162mSeU11m4YvyB9Bievm5hfD8A=", "CEI+FsYQL7xOq3ati5bnWrhhByYci+k8T9MxKmWrW/M=", "JGWfTmkJ8ZjS2j0ppL4V/4ayeaASlyvvxattVebTiAc=", "AUX7X+vuu1tv6yQ0HVrWVsvjE0bUFGx3j0lfsZSCcMQ=", "E60eQApzdfJbef/7PgrR0QIr+27sdvnydikZ6r6NY8o=", "HQh3Ec7u8slCPRPNXSYvnG1Tb7hNHBcb7x/rRG7PiMs=", "KpFNICvneZGhNXu0U70JBitgc/GV8xTlUmCPr+pPs40=", "FmCyrSYbMe2aExR7we4GqfGG5wzWGREaIbUbM9LRFp4=", "G8x3kDKPoWMWKg6FRO7Tmxp6ls1h4KpJsReuGK8p518=", "KsArEJ7qzUsGy1N48IyzfWIqhW0GKf07wD2OLKvlTqg=", "MGFhgu4kDG4XkqUam/5UqmhRzBCzd8RoAh3Mu/pgo/o=", "A35/xDDzQThK5qp/lqcXOpH32JbnfUZOH4+oxHDhh6w=", "LCOOHfLcttfJS/98njpJUf5U206SbEMftjMuP2rSPaQ=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "IA/xeNBpMZBEcrAP4jqKET0XzrM9bQyRAGj9UWilQbc=", "LDr8dmruJ6rYsbqfsUs9VuIhfJx+mtM2PVb+WzFyFoA=", "ISjxoSXgxk7c8NA6OX28pWN18PuHzkFIDlJcJHA5Hn0=", "CcYv23dsT9UQ7qCJkQvSU3+O/aAoZ2jYiiyf/UuBUfI=", "IEJsVI1muQhmp+zXcnjGnjOz0asj8IATQuQGSzvoJhg=", "B63Lm3bfol3mHSkCzjcUDJz8fVH7L4744jFxY/BmQdk=", "CRSnnG0CrclIduuv6iuOatpawjjnMgFH/f2jcK/tTpQ=", "A6XT43EF4dCCgbsoQBdtxGKjhkCawefqyCvn26kx6ag=", "EqqDsCm/s7j3QuaJmV3fccCqKJhNwHPnOjiqjdinLeg=", "AbKTl42xiEvYgC64bZhHemkANvFI0KB7FluUN6h8jTA=", "KfXSyju+MCUeUijmPh7tnJBsTZhkdBDEo8dDFRAf1f8=", "B79HrBru4q5IRXrYAxzmssByplrKx0J+8p7CFmwtHx8=", "ExbJSVHsWqWjfpaSIzTcEW0i8+P7IZ+BleJdk+YtKC4=", "DlqJHnadpMGw0Q+9452BIl+mxIIWcX7fvZRDVBEwq9E=", "EKhEUbbS6UPvYCVbszMh9NPq5kmBaVonvXXXxyzYXQ==", "A0Tm+p5jje1NmakrLa5DgaskAa79UFWP2OqQdkyt6bM=", "KKUT7mIwvr7zTq2ZeLIk7D2PJS8sOVangYVNBKKT1aQ=", "HiHEiaR79WqBFAQwTgRxTs5E83bOmY40mbqR+8sP0gc=", "JWO634VbXdQaNVcAKL9dl+lDCmCWL7oEQdUoYHZaQSA=", "IJMz7egRLCoYvtAz7sRueJnFNifL5df/SekyRVq1FhI=", "G3QMTc4voM868QU+jakkVtsfLjHJnKppGMgpfjNQ/og=", "IxCgFz250TXyWUl7PydVHQH+tk1ODPIjP3gjyNThYhk=", "AjYsjfKQt0i2WoaAwc4sQ8X6goN8X4T4EHwSyoI3CfY=", "JL9Th5vGviWCfkdTckhwK6o6R3P7XBdHbhQucKsXy2k=", "GTtJhs7N2lS/NGhouyDx1i4+eVrkmndRkaAeqkvwla8=", "Fx3mDDsfBhCKDqTGIQFsBAD8m5avIRJQ+cJQYqo/lxw=", "FwIIwLuIQDZ/xJbt6a9I75iRPMaACnYxj9j+8giGDBk=", "GTBUOfXNDRfXXRmBsJe/YXCaQnzAnoPm6YO0G97k2Ks=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "AU1KOgdCNkqfZZspNJv6VFV1HkjaB3BRea+w0B6Jids=", "FFB8fRjb9xkmVn+vMY8luufRXRYn6TD7703HYGih65o=", "CrkuN9VM3ynaVt/hhwT2UX7oiUyduOQqydP4yAAJ5t4=", "DTpczlC3BtDi1attmcxe4Z1BSpmQGuVtjtK5DHAWFHM=", "H6rLxVEEiXf0T983qcaElgJ9+23ph2HOaAh8oIks8IQ=", "CC4tb7z+2yoyYi5Mn21M7WzwpXAGLfm4OMRoT0qPbCo=", "FTRd4KaZylNw4Da2tl7k1NNBLUaQG0ccpEeHz7pp0gM=", "ElQp1BhdnnHE5CjMLNa5jaIp5W6UHze4RtRsbfzLqU4=", "EPByt3108gug0DtBFTA7836piiClHwO1R1bncONQNgE=", "A6WgDd3M1uqguIzGqy72sEUqIGoEu1vyNhuqPyE2stw=", "MBBxxKbT5rPidN1uzW9YieZektyxkOaYDYdl+UbqX/c=", "BJeEJRG4xl043RDqecFXl2I5t3H17opykwtFwVsM5uQ=", "Gn84EVcb9bzQeGonphcC5BZaAvc0lltSmWpsvBq/Ykg=", "KbbBXqiqzcaUuU79mARXFtyBqmDGriJJcOvQOVpsIDk=", "Gsa7dJLR5PcVYEtXooEWSsklxW78DND+SV4YmRTxR4o=", "FnFAWnNR7yDksJMzcJGjCOGFjVBlaiSgiZO0Ft0HUNU=", "KXhOSnK672YGbGtKWA5e4NYBBUP/Dt+QrmF3vMvj80o=", "FbuHjQwxKdSuHjIDp+iM2Q8CXIumUkA+i+ckHCkIozQ=", "FF/2b4idDrpeJDwcR4D1zO/CV3WoL1Vapqz7seb0R5I=", "I5fcAF1SpJ/mS8x+cTmPRmjksdfSPizUH1okC3/SAVo=", "EE+ulHvIH167QBcenOjlHZHVWNaGy5LTmrJF2zt/mA0=", "Edkhld8GS2vC8nAq8l4dV6Sa3Ed092nTK2Mq1cspw4o=", "Hej7OYi4QP7dbx7I9BVv3K23eBuJWscmf/FmNaV8+oE=", "JwiWJOWZscUNzKgleneJZSOPVX1Qre7mlvUvVlav+98=", "Hlt+4jRiJ0BLFJJzK15vNnIti7fJnyrY9IxhI1GSGME=", "BEdE2vKYm96dPTaHi70hFvsObwPzbsjDYKxxgMaoepw=", "GLa4rlOJELljSlTMGQPSHw6aRiar4BL0JP8m56Tzids=", "HqWGko0QeNRKGkvb0uVmuSShQYfEKHF4lOwG9H0BJp4=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "KZ7nCYwgqNhIX7eLN7V5QjX7N2JSQxA9hu2qxl/mc1E=", "Fz1YzIS/3gMnqkjBMcqwGD+bRx8l7P/ybNlQv7TE90Q=", "FjU2uqc0zuez7Q0Bzy2+/fqOj1sm5v4erJQR+Hz7234=", "DDSCN/ZPn3a65R0UehkapQX6kTTd9ml1t/VMqZs3eJQ=", "I+/iT7ALFxaX16BoSdnqxeFOAyYxwXrA39Jz7suqopM=", "Hnh492DoZO8VtAOeJTBH3e4zsIK24+w4KONcGE1FWmY=", "K+960BNGcSb+DNWKux3JLVAxTIrpQQFj+/jIhvhv4Co=", "IgKAH8ebPBznadhaxrvouCJegbrWPCom/b2BPqsUoUc=", "EqnHEgyaxy5YpTvsZC4EiQogvSCAsGcX2XHFy8dOnTE=", "LcaNopp3XED+Wb+0DRvzMIcfRTmV983vcbZ+FDVghuE=", "EQr+J2T8eUXU+y+L7gTPe4yzhZv2LFS7N9DLvI+ig+U=", "Ie9UrRDDlivv7WITehfozKDvRHbWj1fLMSkMvQiekSM=", "HE+qDyfdF/TSD8kwopXckK/ksrMZtyx6s9XWf9ZZpxY=", "BJbawRQczngRqhbDzH7lv5JrGbV+TCo/70Qfak8+Xg8=", "ESTFhPkxFT+etRzHv2KpCMfZNe6skq2Jvgz3s7cL8KU=", "DWDnFg4VxJrAU1kZz+WLm7pia3pWDRh9k8AqIBPXols=", "H7hsKnXn6xZsYlrhUYmzOVu6ycon/HFAQgkpxX8lTf4=", "MC6a+SLTr4oFb0AhUONICSU6+uNAW3aVYZWOLs4OuTc=", "IIo+XK3b2GmEaJR0SZHy1bhVzxJvL70No8dlX2xE5qc=", "D9FnoO9Tit9pW4Owx+K2Xt8gT5lClvQVSty0XVr71cs=", "EjH88omHIKIqKpggSvi8Kwbgz3LarKrBrxsI0TEOKzA=", "CtUq+Udw4V7ei+F7cuTyvBv+c5AteLfzpSolSJgTG0M=", "Bj3t2QJ2wnOJNacbOs750vLdO5vUnlTqi2ImFCLT130=", "D1hBa0r4VRCm877OwR2NtsCXGU7WLUoE5aKilQEaO/8=", "FZM7ki8hJZKoBtruYgnJoC7LIc4r/bE1OGLXYp3x75c=", "EihlTK1wz6eh8fMLTLXZJ50vSb/CM0EUd8Mzy2MCVrY=", "Gwme+vagiTgrAjHa+aZVBbd7VLavRJE2W5MW+Yi83KY=", "B1dWyzHK/ORq/z2HMoDCGrklOgxYf1peEHNkF4CR5zs=", "BFI78ajyhMbZWzEN7CtU4OAOWbVx3Z1GtiAcGOG1bf4=", "LjaXbzWjS+Vr84gekzcPCCA9H4sL6WfK1Mz02dLIPFI=", "FlCzTg6LKtWrXeGf8lPq9tzT4g0ivGlTnINEN+CIhRM=", "IVTz9MG1sqQgeN9wvRxrTwQu0Brc7+W2A7SDAAhxWvg=", "KBKGy2PmV/eONpwPbbPJgM2rHlf9zzJQXMwyXnqejEA=", "MAiz8gLj0gZDb32sJBLVF0TMy8jhrEV8EeD69tYGDPI=", "LAJo/l0DK8+IooA+Td0vPh2/tYkVtH0PylGAQyctWyc=", "IuirT6e6w0jO28/TdqjsZRL994rfk29lSFlNZYSVMic=", "v3F8DwktBPpFmK+8yJjMvN6j6509H1BCsPMl69VwKA==", "H1AOYCg5BTBpC4JCHzWVY8dogD22+z0BNcU2bJyuEsE=", "G5iB2fuTRlIOHkEd4Glt8KTaw2hKFcAhVNwOf65ShIQ=", "JOyquFzjvuxMOAwgfFZPS6aZXDKQ8nZqibcwEOrPyhk=", "B1aorZ9WKr8mALjcgIq+aiv7DUNSgkJR4HviwOZNymc=", "Kh1Q0PPaM6hz6d1eXilmvUBEXB5uuVBN1LJ27PoLMYw=", "H60iQlQNQ2ZJWlrU+2mtJbgmHS4e5W1WZpvgdobpIX0=", "ETrYtGw+7CDJlltaey6KUVKYcdBAG03m9j3p5SEWI+I=", "H8UKFtvfocO5kDj0f4GhxdHvbnsiHUzMpughIgEw4AA=", "EhSp1tcoj+hWUajLgwSMdmnIO17YLKJkL/8B6FKkS0o=", "DUIafCWvVTh4j0lHWDZxKvXaFW+IxYZ1aM2VjjBQJsw=", "Lei6g9K2q2pxH7kjCt7hy6Rt6MkwyG0masuMHLloTiQ=", "Dqe+gvHLSTsbvYOrfKKFvwoVWeoFw/WYJ7OwE9CpH7I=", "Hjrn5XddNSZR1xPr386/nKjpBc+3kr94dCOUUPkUyMU=", "BZQ+NhijLPBQAYpOI3X00Ce4wUrIKg3lfLuQxRIqZLQ=", "BgN1UYD2bpghXWHlNGsRbMAM/QWCdNfZabOvleeLszU=", "GYF9tm/bghXs9wR2xARMP0HXisWlScaE41hFlH3KCxE=", "Bzll96m6jLM6lV1C2lX9fDej8CJrAp023LP76pXWQvM=", "CaVQQxQwhGtmlBJbVkKwBgfzahopSFNho89Cfad+zNA=", "Bo606dbgpYi2GmrVAfOA2g8AkGdmbAhT0VbjPVnENRU=", "Il4AoNpaf3SWtw0JI6fPf/Myv/BpWMwPP61DmHT2Ak0="], ["K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "L7KAofI98MRWbzEM8xvq/cPiOKfYc/3FBlX+gnho6Qk=", "A28XXJk/TkCaYnXnFVi54aD81+QYOJGnRx6m+YfW0PI=", "A74Xeg/hv3apTUQ2R+D2nAp0zF3HryF3YiELKFXoSfE=", "DtZJHE/Q8Smsq89aaPAevRDfYhHU0fz1Ttdb9sfLwUY=", "IVjbR7N02d0x1HwghE+ocABQUcATlBstcQ7mLlbA5M4=", "BjfXsVxCWd5IZtNgBfsXuGYidEfl3OTCd5RBOYDqoJ8=", "C3RdwVgOXj1jGQKAUMt5Ktj8tbGhVt+sZZXt/yh9S9A=", "Dci9zMjz3avKOb5BpglxSvZfUY7zRzj9p24nVec3hpk=", "H9t4VuJ9YIw5f6n39tL9xLMbF/RcijRxJMjIKs5+EDM=", "Cv/zNzKhQPZ1m/1bKUk1ajScJsZLW7AYZl5UrLMp0+w=", "Gx2XwWmV/smu4xoW+sreDizKZT7+vuPV6nDA97OcE4M=", "KeoY5uTHWhw2lL29s/0nTDf1HikX+eCwHYGHDvkjU4c=", "FdX1qvkbquvTTQe5Y0YQuFlmwAj+7HhD+rflCwYWQn8=", "C9jgw6Fn2euUO/GfGNdlIw/X0iTfBkWFHmaVkd8BI58=", "EpKTck4tdsusyshBMmNloLkr/ABDcUfeY5DZZMwOBVo=", "LXBXZUiUHC+2vtbFJdtdDDPKbIb4HbM4OFSNZyt7JkE=", "K+y7wS5JglBViIKS2RrHQ5o88zfV+Yc8c12S5SoFRDQ=", "DO/QuBv6vLmSAjDzpymuMwOUPY45bFwOXKAfRhHz9hc=", "BuR+lmsbWXxhQT3E+ZbxRWcZdCJXA5AVycHQqjPAsKw=", "C/kGR8hcvIKwbjqUGY5EM1cguK+9/wYRLirKUFpDxH0=", "I5vFfXsQnK79jGFHZ6WQpo9ljGnL7CH+8oOlAyQXkic=", "CjauTLNbT4ZdciUZE2b+aR3WWtXylmt08q3CjSbS0yI=", "ESRFhf7OiG5GhfxwPIB+yODVkbV1/NCJqWnWhL5M4rg=", "DKp3edwWvb+Zo/RZA6zlB5GF4xfv1XM/x/dmzlfilpQ=", "JplrnQhohfm9aQittKr23q6DBuRjJQgU3GbgBnQZODk=", "E15moO4TsoflH18ej3nU/nylXZE16JIScpIOxzK83BY=", "Iz6VBiCF4t7ICAKcWaDoIwB3Mx41hhNWN4hRijly5bE=", "I6sTsViJ+Ls4Hv6+cRcvkaCtZdnwWva1ngDQyZ+K4II=", "Ht5N4lqDED4t6nKfDGipCFif4OYEyG+NV+BY/hEAB0I=", "K1tb7niNyyO9SIUzzK4UMePzUE47iebu2krotbvrTHg=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "JXNj8B+7EIzmNgsRXrA4JwlG64xGtuzs1oWWdl7YlNM=", "DgZhG9Tu4WBVgvwvChlVJOV6VS/58sdoMhicOC12OUQ=", "CrcPtoI/UsJ3uN1P8mHZZalCfTSvSvvxnzskJgwV+OA=", "F5yUHWRNgEo6QGiIT9HG16gtQR1GmMkeGyQpZtO72rU=", "A3+RbpDUGQQtKXvclSx80CdGy8GIFJpRoJh8/v4NwT0=", "BD89w9kbCrtTGILcAV4dnQXdZG1C39n0wUk6CFzAClY=", "FDrRnBJJrL70iOoKB09Wr9P1uJZmI1y/i7Xm/kQJZkI=", "G3ZhD8jO8usPT6dt984pkjf+ezqdAkt9QF7AlXGcQnk=", "GlFI1okT33TIcqHqWqS1QrOrG5wN2i7CIM8rw21prVk=", "E/EQIu0CKElyA3AAZm4tPtvrmlNQw3/twpO+mY66Mtw=", "CAbyZuTDXG8GaSX/c9ar3l5G9bxVsBAV25UWIVkJKnA=", "LhTNqs4J0JtJ1DfKSHUhI6bv48dWYCGPQIh4hx0HP2Q=", "HE+o18bI6vMxFt968KvlaUVAPhEfDtNq8CmheogCeDk=", "AjQ2/T2NSMfeXqMomdCeYBh3iW4EQFHlnUgfJsb0RZQ=", "BDcZH9yywPzLndK3AVXh4+uRoQSxQjWoT5x/cV9maxA=", "L2im67Xao8HAsfjhzD67uyna5R8h3KsbjyTzDlL2obs=", "LYLe9nBZEbv6J4o404X+F8mBC8r9cSb0j/u90Zfh/sU=", "Ff6tD3zOufpalrkDEh0jRTnER/d2vxMpDw0P2c13amM=", "EjkO+V4pTt48Q1+fFK5PEhzaqmtd5PP3mWmo+R+zd5M=", "Cp9vF1eksavI4KWw/qg80rjlZRBfxtUuaS3s6JpsEeY=", "CZbbKiBgsEVOyKEy7m2BDfLfSQMc5CDk55DHI/V4vUk=", "JnCnTzfmoyWWk4yuo87D4FszfO1sI9K/LsWYffvMaQU=", "KK4H6npSmAXTqv6fWirmYvkIsX+GSrWbmEUu8o4/1E4=", "AkACxJdxovy2PARtFQe4siWbTv9jp76Vgyn2MZ/ox4c=", "JwPgN0XtiBDMk8ynjqYTzzn0khgNasRzAOS6vU81fc4=", "IpMCk8MzSZCF6uVaAcv4wysE0hGgcJvZt1j3M+Lte3s=", "KgrF1/Lao+2tveqqRAln2XuuxjfPSKZ6NoEEMAFKkCs=", "JfpIy3AAMXXbSyJB5ruwip0wEoyG9ov2556aPdTz9Ow=", "C64ED/Sx9juXR0qXFEa2gMI/9NVSEqmdA9Hicnh3ABY=", "L6XbcotgWMxCNIyQJnFY+OdquZxkbmZmTcK5OWMhjhY=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "EUQBpMzIPIauD6Ugo+vkR4+m18TGNLSmUD2jNNqEBN4=", "HKYnOvbS5RqLfCuoaaG/EN56W5eGrZR6AsKxtu6CEnQ=", "LHtK9nHsX6ElMbY7UReC8fRu5UKLkYTZYMrw3rDgjQM=", "EjAYLENLIXXpNisCPlVFa/l9UU5TMuR1P/7aYPXZews=", "IuBBwojvJvHQfIbWwk9I6wQdg6gmC2dyiSGB4hIMkeE=", "KKy8afv3ol7TiSe6Y83loYKE8mrWWBMXeCIZIhzGvY4=", "JIczf/+qf+pkQPtZ6OiIwXJLvR8RGNMq2mo2UeRu9UM=", "Bh9GMM2KcLXGoZUN7x9+7aHSz9dQ6si80h0JKNVFA9s=", "PPzdWEIOgb/tsE39TltXsD64r++1ljuBM52SRFRYtg==", "EhHwnGAcMRKFYfEP/e9zSHyScJHxAIb/qInuwTeHV+I=", "rWJHrjustxaJkAP4ga4stE5A/0hj3AekAL3hDKvJGw==", "FhvPSNfTeQbvKdUipmMeIuNE/5Ub4vVBjB9Y74EQaUk=", "FhXKr86c+ZZWBF8BuQUIctFnIZUzByZypiYb2vxAXic=", "Hx/RtkyAJMGdxMkG4SG8UCPHaxyWEP7MAuAJ44T94WQ=", "GjQ/BsdCtuoB3MoFHn+BIJclDoHvpQZWGBfCrM3hP7I=", "GqWtN69M8DN3TozttAw2zBvy/S5zwTWiFFiX4lVkSrg=", "Co50N14cqSADFTqE0qiLOHlpBeQvBaKuqiK2F0VFZ5s=", "Ddy1JPPR420mUjs356elZcp6r76LnX0hgF15s5E0WUQ=", "DGRmnZIzY1M2f/dGAwuUZpHu1jqHENFbRJB5E1WOqJI=", "GGY8rtUq8xJf9zTqgh8rHA/2PiU+uN9hwjmYs4Uu6ys=", "CKoqbcGsrOla6Zz66fSKXtuNkea+Yu+XqOSPe/nSLMM=", "HYENRb5C7ekVfjfdkpprdNCs4Ocrltbx4EhTICdhPp0=", "LMEYFsRuZMbnE11ywAp9zmWnYUy8Fk38or5iRmilF2c=", "Brysk12eYjPu6FVdkB1ssLWhjguusHdMQrssIhao09c=", "CB9CK7Fe9+m1e3nK1jIm/FPLCA5tQS55C1BRta2wEgg=", "FyM/JFjZPbNcITpyyWmpSq72L9anZDXGgxKal5UXe/4=", "IjxGR5OIhSXs9dPIc82zpr1nWHSZoAtEDZJML9xF9kA=", "Ev9RXvPhabA4u6z5U1N8Kyjb0bW6P8eiaQAYiu824uc=", "BV4FaHcPvEybPWmOYhsZgHNuxCWfCwnZ8egg99pBdLM=", "GFuQrdzDtnTsvQmH+UgLdGJf0HyRvcvwSKZH1WHHVsw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Ckqyn0KKG0BA9VEOi08QSU69vxKIWVXOk3oXNgtLKV4=", "KmR4jqliltclOjqeNXcVI0+TGMCDdsFd5pSH+/mwmW0=", "I4Unhni/Q+Bicbh8P5hPG0JbFmunhrLh5yNzmmdS9sk=", "D40gS88u+qCGaBjxw5hmJ/+ZiZUxepYLVtiqP1wQ+/0=", "LQe1vFUzRKSIfcjz21hY5d79oiyqmmzL4j4zMroYqt0=", "HhpnZYd8uTWAQz4CWYX4CqGckInBcThIBCa8rkmqHH0=", "FfGmBhc0TSm22mD1fO0zXaHa20Aq6aVuutPAqrO2nnM=", "Br4B2k3pr2sNKTe8tlaX/cI+i9v1NDk4MV702/BF2RQ=", "IER5ukT2xged8SO6GlTiSNttTQSAOTkTeQ/x8QuerX4=", "GWfKI2WEmlupq+NBl5eIWvlzbEJDnxSBhioAy0yDsks=", "A3t4q0xsHL6D8ZdjPEyD4i/Tghl4bZxXRO1CJOq7pUs=", "ISAtn+zjs1F8LV556KW0eCT+R2WHBDQbp7/aOjQU/Fo=", "GL1+RjA8PCox5oSSRyV4cIpo0dYDa5YWUAV7fRzlXrk=", "DF8y804SnejQG/kBCxYEe7LCEo7gIfzgriwDovCyDFU=", "HqHHe5zn0kpPMv/2YeQU8Hk9nER3/MWld7DlFFyAZx8=", "Krt+w34qUqCfpboUTSm4/qae+iBbRpAzABPS2if6tvs=", "GW1H/yYvWpAymWK+s8QDSQVHgI/+T+lsaZGV2e5aIyY=", "LaXcOJsHPlL5KXCq7w0GG+uiW76FILeBkRhYWYaC9X4=", "LM4RND+XQ2ndX963qKeW06g/7tz6Cnjbctu3ibvh2Ec=", "ExJi4oPPCwX+9giG8y8ISkd1X8tMt8zExonk5/BDe3U=", "CuEYjQFdNgT7OJMcAteQ/KJEuLKE1Ue2L7A/mKyIdxY=", "B1eTRa+xwYPrkqYwu30GGWnNxRVBS/k5l5fXQT+LkE0=", "JCmuvkpnSoDwqK6bOKPyU+RbiXrnGntdCv5P131dh2k=", "E4K5KmxXO7GVqVPcDGl7u/MNz2gG9qsqX3tQCoAFLek=", "HRgleIN7WLMt0xoxUlS7CkmwSz1epJ1YL2QmY3vodBM=", "LZiI/IiAqh5LJlz2AhhyfDVWrI0xt6Pcah3V1RuQIgc=", "KPq3K7uZ8abq8gQKdP9V6HxaSMLTkqd1LHb9L7M+M5A=", "Jnjxzqz6jjtItern8GACGk9YzvVrEtUrnwagnk7aVa8=", "H2HTWdFhnsT/Lx6v5XgnyTFuEHVHGLn1GzbHGXnMRI8=", "Gh2fZLUr43flCdWlfwBLy22w7cha7Sb1FYHZEtow6Vs=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "I4hM/Q8EWRUCWkTpvbFEkeYm7fdK//7odMPk0SWkoXc=", "KF0HR18iRGrxUVwTSxDviQvdkn0DKCMNY3TOriHl8Wk=", "A1PWZDRcNE+ibOkNpPSY/jOmLoxG5+BbR84Rtmm8zNQ=", "Cl8k33bzmwBMBz4c/KsIgHArnoSDfLyyG9AC4kSev/A=", "EtxP2LeSAZKI1mUpIFDPWLuyxVvnI9Znjdy89VzfXCk=", "GT8EU45EtpO18DwyhhAJLoslOJW+yjCGJbi7okIp5rs=", "DUD+k+2QoBltwX6ySwXb/Qii2bhRA91E2Ie3i78IJR4=", "Gh4fcxJoAlwQaY7/+aGJgoFzMpagLsLkKGwKqddmJQ0=", "J+U87gU2w+lr1LeNdrG5nWEUZraHxg3FJCMEzyx/BKo=", "HhMedig19jF2XWoFSPi5l4azN5pUI2afNI5jwaPNQFc=", "GDd7U6a2hCBjGlCXZ6t0evVP9S/GowD2dZ6J0PqB9i0=", "K1KFH5osEX0kt7Pvhh09mBReGL4KsXRhvvkXDdEk8qU=", "IDEx3+BfTzhZopYs4nNvX2ZWec1UNEDlu9+MnkaPjxo=", "EbpyFt04ZAa9HuneV3wwFbO1aPYSt50rkBlVQ5tfR7Q=", "Bs/2ja2CE5WAtu5ANGrLQaG4jjQ0Sx7hJM2EW6TY2xI=", "F2tgUBLzhZPfDQ4S/aukOgJDJ1VPBFh1o5SrbWZZZpM=", "K7QAiKGt2ElrKg0HdMBtmQANn39eeO3v2CZ73CYCgjw=", "Bqte3NGll6Ve+29fMCi11G3Rg4r34Kdhj6vSBq4C2xk=", "HvTU0l4/ZzFAHAbiMn4dzdJR5dhopJYV18nmcbdOUro=", "ETKReRiJGDNlmuWqXUYI6e5S+LuMahWvK7bFslOO4Qg=", "PqcnkIOD65wMX9TI9Ed8fXyziHxrdAgJfCoJnM20Ng==", "HGca9VojOFsWtB+TvFyd+SRKKykX+ib5iZNtnhD1iWU=", "KHewklPNAjPTWN1cA6FevTgqlPZbsy+BpAnDIJyD3RY=", "EgrHZfcVJ62q27npHHi/vRfzCxxYJLu7brgtJ0W9M1I=", "HCp/47uTuvtU46NfT8zSaF3FpZ/2uedlOPN7fHkRBjM=", "JFZ2tIfiF8Y77rNosgTY/o5eBRqpHv289oVNnV7orsQ=", "Gg9PJPP6dbBxhdWfOC/2Pyd90a8KkC9xB7Y/yfRQ2H4=", "F0u1lH76YvkEdZouhcySyEt5dojujC8FaZ0DBfamirw=", "CTBRJ2NTtjUHwFv5BN5vjZcffThsF0gFOEC3t3W+ugI=", "IBELlrUTllh07sm1cWar56cdusQwDe166p6xkO+bCCo=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "F6Udpo1GAAlRsG+z+ePVuDSU0o/q51oNdzgRKdG1zBE=", "GRJK6qvs9BNQEOGpZTQeSMpP23sM1QdxDOaFvs6FpR8=", "DU7/EZBTC9wuD61XUErS2Seg1dGclEJAE4GLvtrJPM0=", "DE6R47fO8wjZ1ClA2/mkluXiP5VLv5zZ9qFBvAQ8ifE=", "KpH/93C4ZsjKjFMNeGpSITHBUmxGlNi3t6062GeMYUA=", "IRuUj7XIqcxF+N/38Z1QksRBoXSQCe57DSbQLRUwLfc=", "HjCxAxokBpzJOWG8vnrkYGY9JKwls3b6jSqM6jlp5mo=", "GLguIDL1NFjeW1uPbGnQ9ZAz4OhD01I6DkM6rHUATsY=", "HcIrW/wnMsHzSBNRdS14lfVZRxaleyLeCVPYZ181eE0=", "C8aH7zsYp37YSVqIOPqC41or4Xriu6R6n1q6omAhr9g=", "I3HCbY90Jc7o9mrMn2R9iJt4ogwC/vm8jmUpVTbVVmY=", "FHdHOp5Jw2pgsEFdul6DLiO6JXVoLLcGxc7zjC7oubM=", "BT5IKVnc23n1LmSju+IHk/rTr09NBSwMudNt+jlr9PU=", "AfG1i5Xq71HkQtZu0koj4wCz3zAy9FBAV3QCJ52gFiA=", "FBQRr1DpV4S1Nl7D1IeeeNMRwG07AxpHt7GYn/jioFw=", "IlIyOz7AbMYnEHeDcJF9lGNerdCrlG2DxyEd8v0YsSs=", "AfnwnPy9zrrqKxBT20HzlAbEvXwI1pYy5fqI0R2Nsv8=", "Bp1doR5mUjddcPh+u+m33wrd2pY06uCZkLaFYKxO1xA=", "GXjl1kdFaos6Zu26NXU/qpPj868cifQYrqD2i7UToMg=", "Jdmk5gO4EvOaIObl65nA7ShF04O5UrQuI9Zf5oIJ9Fg=", "I0tD41F/hXPVtLbJBXIXR1AZKFV+xBZdlROUCIAFAiE=", "A+Zs8mNogcilG7s1MvDuOr8JnRbG4CnuvHrpA6m3TXQ=", "Hpj4+nsOmHYkU8I7rGc1sAtPrf5jwESL4M40RFa38Yk=", "CKpwm1So3wkcoEh2P0Vzz5kXrqwIPKG39+uEwGDQ6TI=", "BSx8p/3KmsLNNEopTTIvHXHROE1eCm9E0KyLNOaqxM0=", "AzGwK8kXv8ZpHY1/Uuugil/D9H0W8C5EBkQ5DDmrc2E=", "DYmJSZlKbyY6n4Ilyl1KEYt5VaSnlgYmI5TOaden4Sc=", "ELR7EwwWAHtTeddEp7wZ5F9tkuJxopl2ZCATnyCndm4=", "ETLwFPp1mddExtQNG+Td1E5is/pL3EOaSMpMCMr/Nu4=", "HF44q0VRqqKrKrW2n11keNZocZUjeH35aL7G5nw0mg8=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Ecmo0afPAy707rOXbLRasmOeIyjgGPJFDu02pCtRcko=", "DWiw70hZqZ2aPTWPSOwEkiK0rcQPUhFCD/l5LTOARRw=", "D34/voQtIig5pqKJJtK327IMx3b1zDXr5t4ZcqgGEHA=", "IO5S9MVyEh8njKjwnarS8cDvhUEJk3iwuuGRNSiwEQI=", "JBd0cIOekFSP5lKr+He254jfpOD0NkogSHCJNJ0rFPo=", "H6mLY8aaGY7jNd51F5sjCGFHCg9gRZ7VOTD1khBhVLA=", "GP7Xyh01L90le9iZnpVdRvSMP7L2fpyLKcoP1u1cxNw=", "Hkr7mxQA3vQnoaXJVudhvkO8PRXvBwmMsIv6mU5cabQ=", "K4uFH6/MBBzt+mRSH2+1Olh4i1sWbaRpGSodWquhqwY=", "CRz4rIK22Evp+BrBNR+qDeIiYmChAZ0d+yRDfKNDJd4=", "BvfWGJfjp2XU5FJt48wTtMZXzF7IHgg4jEHZSoCKmlw=", "AoYhQpFqLCNDLuNWOVHGRsTedVIAjJKPoTzj41Ae2K8=", "LMbMWn5l1ojSf/zxxHSXZOcpTCPQEIpXspr0Q7uT9aE=", "FA0qNIR8ufB3YXYBDYBwzsg5L2EvNXPWPljWmkyVZb8=", "GYAK/J0FpbA4boeoVazcx0OhyAsPcQY9VtD01ur+0Do=", "JpHfR2witW+dbQz+sbcG1moeQead5fbanwK539iVTTU=", "Dj0aNwosET9V6L5qWWZ/cuC8kBjGwrfcFU3irahDz5k=", "BCIEHNu5npEQljKF6QwjPxhDNh2NNoeLKyQl7MmtFGg=", "GLOXAVBYbGDjYkPZ94fpzSNK5UJJvUfVPYNQQxAnVB0=", "JgimIMk3CELMHn63XO2WUhJxeyIDLP86kPGRbV1uS0c=", "EC5jjTPXPNE3pLyXsW7W6o/yEU7wJeEjpH+uEgkhL6c=", "CBEnw3nQjIa2KD47ovehY/FW/x774tBYto/x2BmBFeo=", "EAMzDmybsIfE43QWPx2TtR6idHEmlCqJG5MkfcO53+A=", "Jiht9LkKbWqAr+uEW5tXTI4RTasrI6vU2SyQ0FYReS8=", "L8vONpOg82XHf12kHwRgZ0czTA4hzq9HGanGxVptsDQ=", "DuSfe/jZprRlfMqaVTsS7h4DdaIlFAK2Iz8Us65DxFg=", "GpygNaW7qeAagznAdxHZxeecrjRB8nKvPm/Q+laIngY=", "EgLyyn1PmORI48xHETgG7C+UiF1TaXbbhKxPBrffZWc=", "CJoUu7jwllqRTLv4MEnZVZjtg/t667x1pPaB784xMP0=", "E0iPOwRWUk1JgjBf725sgflZo32nu6+rV/h+ii4/Jk4=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "FVyR219Z/Y6lL/8gmT3cMoXs/5fOKtaX9KB46EQDYeI=", "BcYewG9VYchyVuwhxqqSqx09zgFJYHKvXFCBrtcKBz0=", "CYSdwT0uyoccTcHRF8sNXrWxqY5joYIfbgiV0BCRONo=", "EzxgrhWXvK4/Awzxo+9RXvd/jfwP7P/whEEf9AplBc4=", "Eg6ThQwT3j0Gvk6pM/NFHLPUg21V+LZbMOOBSh6sfL0=", "DSk3QhThpKvuuNNogOb0OiqJmzvMp//g/BSCQRQ5zyc=", "FlARhwMxWuPr8bT14zM3NCglEDahJFrOQTT0yb0/epE=", "GFModUHNaHvGZ3Ajf+PobbnJggjoOK0cn7s8Lp8NL1s=", "CEWguTRNeVuoHKbcQzq7W50eCD1GAlRWlXPo7j6dpa0=", "GQPQeyciwNyBjdqJPXSp7n/LiwHTskrJ12BMlw9o4AI=", "KxU5CLg9aj/EuUBviRw9Ue5CnI9pBsJDJt5Lqiwi1tU=", "EHStUgsbC+L0WQzpfZkn9LpYL9vakPc4EOCnVHX9DUc=", "HXpm/KNFFoxMu1SaziR40ejwoZBs38HJXTI/mdZgLy4=", "B9jnP81qNbLYOQ5W1nC57No1b8HaRlUbi04VOA+MrA8=", "AkOY/oEcz3K7FYMSEVKES+AUmVqcIT/zcdAwLUAqIqs=", "MDyOGwbsSH5xVplzbdBD3UpjCOpiZFJWNIQfT7Uwvhw=", "FRhsscUfer2Uheqbp3z4+nJYTbwz+Qnn4EsB7FUHhOE=", "GADiCScZjyTjYvdxnsvt7L/Yv5Cwqg+ATOvUg+qVDe4=", "F7B0EApN2me56JeJIBugidDcFVP0t1hY9onX+fJgglg=", "Eqhp1tg0hRnRHTLmeLrP1v4g17AkIqHmO5WCVueG9Nw=", "DUAJkrq+FqG1qrXpW8y5FmDyLkAQgu7siipWLLsJiDI=", "Bn+mpzXklAGtbQ1AQ1YzJvjgY74Tsoh19vSpdRvtKHk=", "CKpGqzmGGY1JO5cH7YSmEDTaKovRIkxa6KqjqDnNsRQ=", "B9BhZhGFGGomxAvD1lyEBktoGdwwXj6m3whxb0Fea+Y=", "FktagMwqOQMm9gYpV9fTJawkTIxJdEj0uW/mc02+MFg=", "0mcTL/UKDmHoWRiQZfa82vo0mqxIgc/rGwto7heZgQ==", "KbNND+vrYrhWqqVIpam3MIk2vRY6RvZ/ly1MsyY0tfg=", "Gx3+Rl5FeIaaehE0VwN9fTGAtvi+QDRvBhUk52+ceBI=", "IZ1tZchqOFDPNkjZgbUWgayOGsCl1NJka3gMnkaJXw0=", "Fwm+0UDJYiRZeRim1uBWwqb4DE0n27oCafNZZqqtmGw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HbATvkBeHtzoasuZfvjqaK1ULssl/7uK3su54yPp3Es=", "BGcstC+GYFb/9zPC2bI1MWCMG1Qa2gAm8pLQgjBSD0M=", "ITEWcIxiBCfbK7waQiuNvkPFBhTqHvgu4yqSxxunhxU=", "GBC/QcME2o+SBg2ivUYyKVt4QVBxbsi1mjpmOSX7tVY=", "DmD+H2rDTM7jeKd0OpbNx38n42An87pEOfWZVH7/+OE=", "FQ/j1fGYRWc3U8ENIWg8OdgGuotEAXhdi5k9XRSFNws=", "EG+R2HgZszxJY0W/wL268KSm2gN+LuYopglxaxIDeMw=", "J/BY0BoomxqxvqXdg5/A24h9aP38YjCFyKrvWmzCoto=", "Dg3IIL4bWhAblvFTbEZc4nqWQ2YWpP0VgMMePwvmnVc=", "EVD4OYj9cczpM1AXOR0kBRLqpzwV8Rlzwow260vlgLY=", "BgWxT+hYrKG0ege8r+y1cdYcKn0/NVnni+Me+hNjJiQ=", "GFeagpSeoxPweGP1ReX1Nlp3km+XI2HPcQTy/KyDIxg=", "IbKxyAYvdlAhfrLQkJIkYDYebwd3wifLaF6gTnA5MGI=", "D4MXhzijRC5+TOa73BdQsps/x1LY1SnYsovhefKAi48=", "JZqA3C6oqJQjL1WS/qpC22J5c6kPUEQ+CL90MnPqwjY=", "CqvBu7klGjBp5DIFuWoHLo9p+0Rt10EOSBnWKY5HzJU=", "GPRNtR8JG/JhYnq24L5zwWslf8NYs2UIYnd5ci9F7K4=", "LMSp/i9a/joM6QbIM5dI3SniOG5c5LWurCKu7hfD158=", "LCVN2S1/AC2jZhqDFHvLft5VAxMSTZnGKIz6U4202QQ=", "JUGFLNfE++oTYbEp6JAcoy2cSyC31R+hLIegdKf+/jE=", "CML4AaglIKmhIf/KMhiW7HrWDd2aULlFzz9DCgUmNBM=", "Jd/H8VKsdAhNk8LFF7kYV8UaM/jN4kjTk/ocMmkW6T4=", "KXYKLl1jQG/yVNpLvJcVKsimo4rQh3AuWUlVrdXFDUY=", "JptrsAcFwx6QkUf5GYF9/IHYtJG5p28iPlb4HmSpUn0=", "GgLO9KeeBkPt2L/N9hoAlgWEPCbr7bHpBgRzQY918LM=", "EsAmHR47JHtp5FgrOoD9lYdisLPTupFKUsngviSRjw8=", "Jj+azeuLPOOsg7zLGRil1fxxJoCnL9jPr14cZxJnQ3U=", "IHQ035ASieiRbs3/Vt7kaakTlwkgxkgEp+2KJvkn8Xc=", "A6HAPJ8fobg5HzL8uqHvxv9LHe5/N3yN+lE104qcOtk=", "EknmEp73UHyZqGbZAjEtOHaZitn2KsNEVAVdj/HTUto=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Bo1oB4Mbbnhed6ILlN++X8bCNIQxDTap+3QiBnGAStQ=", "hbl6vijgaO5e97tMzYH63s7dSBjFpsnPT1PdS0TsrQ==", "LSyqO4T5IFPMQGoRrSmFyGDFenWsNWuVqGqDylBLxO4=", "IwVhwiCMY6PRC5WmQ1jFvE1o0BrkRHtcaZPI9hMgMeg=", "FR9WcgUhE+bxTd0ywoxxQ22qrccdV9gwylUedwxQNac=", "JzPJ1x6x8c5F/7qO+z3iKu97hP6pAb6+eT/8w+4gzB0=", "EiwNCgfCM8aH6BVr4VZ0kq0A5sSP85XZhUHfkETSYFE=", "KERnRjeyI/V3nmiLuK30ncvNklbVwxSlEnB7JLf/zVM=", "E6kYhRclS8pxXUYPnG8YOti9tfyndwJ3EX6cR30NPeY=", "Hd2O7AlN+s/i+RXmISn8ujYB2vMy3I4ki01CNYbrzWk=", "FfLgw4rIS/UME25o94+RP3RWLq5IosIIIIQaRxII0FE=", "Hdcec8wLr0rKc00QasGkjPhfGCNz2BqFRXXmXO0Nxz4=", "02gsOaLcDAgISYzuIiB2z8APEdorkp+l4GPr/jB9rA==", "JZcIlFohTLzuz8TP/SkFsGKLPdP6ZS8+/hwq8S6HMvI=", "Bxuux6QpvQYFk3MMFQ/x/foFCu0NcINDJZBjeW6DEZU=", "JoZe/3Xi9v28ZiE+4DuUVaEJquLpfM4HuTGb2mTPxrY=", "KGTBKsYcItTzX9pJETcAcOi1iKjuSoKonhXA8aDi178=", "J1i4tgFnTKX1JtJG0iFRnsQKBJjbmXuKqFVUWzZZEno=", "CQAq+oiZESST3KbKb1xjI9uPNSAI99GKBI0mXoz+vvk=", "Fzx1iuo49qeBJoOm+kWJ4bSpVuiXSvJg3bBXUZ4g970=", "Dv5tYkmB/14LReV10LZIYAvRhJc+v52fZT1KWouhcyI=", "DRSmkRRbJcpJxJYFxkqbrYFnjqSk6LA/45MhyH8J4aA=", "JHNCrqGa+kmo27OW3tqiU5MK8istRP6Wzv1GSDlIKr8=", "Fh/r4jVUJsL+iD5Y2s/25s3FrVplsoM1J1/rpD33H4w=", "Lf9b8s6nbQiI3EDNxz8A4wV+br8zeTyFUeIRqrQRVbU=", "HmtuCfgZXDV2fdI8gu9diGLKd+mZ1lxp2NxoYNSU6Bo=", "A6j8EL9KOUnoRpcysBSFlMs3WRI86Qrj5pKWbjEEDGE=", "CxhfPUyiFLLoMzAf9OmbH57XF5tBGRyZYHl7OXdt8rs=", "GsawOQH9xAsTKb84c/+Sd8cPzpYQFRoO95Ie0IVnNgw=", "K+t3GHrXdpiZAqlNBqmN7vsTEtBVhRPD3qbfSL9jfqc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "FJ4Y8SM/UGhZJ1SFz1/JPOu5TKJs3l2YDm+iw0ovf9Y=", "CKVMolzFCwNPY9Lk0QtMc1qnWcQi68rHH29zyEGXYQU=", "HBIQ8s40wpWNZA0KCq8Ubu36qu8NN8CgyvZxqDMtNMc=", "F7/br+nlZJjLPXsV1c1Bq4bs1HiVcBzS1vJlJqr8mSo=", "DNJ5IMBEHZiomS1AjCGfhZia0QVvlpLj226eQZa9bRA=", "Ldf7k8IIBfkVZb1nh346TOQ+x53ENfjHqF6CxuXRY3U=", "BbHmiS/2FXQvco08DPgwqu7bk60i2HBpGpbZUdun/zw=", "CDHQoxPM/VexzcnzDhE8Kao15XSx9VMhrgmWG4e20x4=", "BgDgyEQkPq24ZhgEPSphjqH17XfxrKY/Xg7xn2rgmoA=", "BfDHnhY0nKtIESjQSgy8gLkMK96YhKlMQa0bDE+GgBg=", "KqfeVwXqAQ2qqzCzsgzvDnSHQ4SvMcBN4zpOHO2Okl8=", "BYVJO3UN3+cOPrbJvn5ysY5l3iKeNX1HgrF8dt6y9WY=", "KEj444NhvVUSNSYJ14Bq8fvGsfwoWxx2Gni6qmj/XvY=", "KEilKdT3zUvxFVKOteiChBUK9BRSPiXRwBLziELXoRc=", "AwrtT735jPAhLVa67Zv5UkZrU0dmcVPla65LBlDYxwg=", "I1Dtu1Vu9Gy4whvZhBr2Qv+LOjmVaappisY8sxeigN4=", "KuW0ftfb3vWL+mX1c2OYReBneHeSbmPJkp5HM45MuSY=", "JuCHpQ51NDGrTxrX3WXO8A2dpgWGAbhSWmxRflJZzkg=", "FZ0mBGfvaeiX9kZ4LwPCTXs+Hfs660jEaWA/Uc6irAE=", "HmBZ7g7OeY7brcDzwkS0vcrLUYHp5HDQWR/YzDyHmN0=", "IdDGwZvGvf4ScXxTMWm68aV+Yftlt8t2viwSZcLJDqs=", "CW/3oMGO81vpu7Pgr0EOHks7kC84y4OBUPjbjwNPluA=", "J9FpkdpOJG/TMxEtXVCSzTyIjY6onrSrkPMzXx4R+4A=", "CKHn2LxGttC2DUF+SJS9xewbDafUaM3w9bZyVEFFSA0=", "G7uZTXTXm2mL7/ssE2Ctel2hvJ7QZaOAclN735mNSsA=", "BuqnWyuPs3VxlDMkQrviRqgjAP49mutSVICVdHVn2iY=", "A1Bm9J/du0KKIxblbLdULl7mPiuEo4yqJ/XAfjfw1RQ=", "AajfLVBnmDTA0dnfcrajPh/00aKgJlm2NfOQi2BBHI8=", "GmnyNIVfIJnOAY4oe5Rpar3VBP/bhpV1Womqx2KOxNc=", "KCxmz2byeLPI8O0uGTaIez9KQZaK84uoQ1tNrP5PoaE=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "CFzUgHslM24f/vybTl1hjHq6TExC40sKtewh8eJk49o=", "Hfcr9tM7QXl50KvDpYecnBgFm8lUohsXU/RMmKhlMcU=", "DtKbF+5rx58NDalUB/+H8QuTfBty947DZJlgHFNuAn8=", "LY9ny2q64bHP4h+RtV/f5eYvov48fC1hJU2EDC4i0Og=", "DEqETTPXQQ6/qgvjwGKyh2wiuPTmpEWaKULsqZAvct8=", "FZf4pBf6HIRwGAUecO7fu1pgIFJeADsgeiQfIlHIgYg=", "Lcjl1vFOLUPPCyc1IrNeKsw5F3R5PwkBSydITntf0Tc=", "LSTUeUFGkIGF8jVP0nFgjTCY4Eq05caZFlOh4x70zsk=", "AzQ+DEBFegWaiTJQeVpsasUIX9ciLe4HaU9sVi2WYxI=", "CvfbPShQ/BA3QoqbaRPLV+0rF84Sd10QoupZkh6bo8E=", "Kvdv4zJq9hgU8FltHpx8mBIU76sip4rFLkwNLqXzpVk=", "KMX6zfKDLSL8jHyuvk1Jwoo+rDThwGqrA9pR9MZ1SYs=", "BnuRDmo1VWU7fWRoiLFiDasFuCr9tIwIuRQi4dCJ5hc=", "AagZimjbVVu3DL85bjrPkmtm3Rnkrl9Cpi4YcOF5Q9k=", "D/O8WlBSj0I5TNsQAANi6LZFzRq8pFgUyuMcDBc23pY=", "F4MuL2pqvPHc9QhN/izFrppanVHz1o50dD76tIJpUes=", "BwfZoRHiv0lx4cKPCZPQcAzBh0L3ohfEweICfFNtHX0=", "DUZ0u6hIKR4LwLLDbD42YvCYMfMq9zLSFj94c9vWEDE=", "C4H5XwboRnhciYro8VB2G90VbwY7dEJ5qwMM7l6ZZ4g=", "AaRyTnoVBF2c7Ea8BZpuBsCrrnQQaX6Gf5fgc+fAWeg=", "GVs7cYEHuy0ltlRvSeGkl+3AenijfB3hWzm2Xe0EKm8=", "EXxYd7oBlWNYmlenONVUyqfIxOM0LboPM+y7gc9G9/c=", "Kfc525nKe2cJefSo87hSurOzov4LmKRpPElISyhyq3E=", "CBJxGXKPYlo9Ndnd3X1Tk6kIbkGS0bID77/pYjvTgWI=", "FDYHsVRj3Ej9Et3rrpPBdDlrdpM8JdvwskM8eJshGjA=", "JxxHJfAc2XZ8eQjJIX8Dd/DaM+m8SS0YffCiFc/j6IY=", "EFP5509wDdMWGGIQL8vkYOQfCjCtxUa2L/4+z/XBQvA=", "GfaqZPPyKYcizTG7N4nGt09tEvDb045s4f8j1mepEiw=", "FHXYBoa0i6sY6xwy6ACRKya4KsDEudsDbFE+CzD6fiY=", "KfhZi2Ky5238k5rmHF59ChWVSfMJ6/4vPwl67hxBrC0=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "MBC47YDknlgPiE1emEFMsGGbU4HrC3K+oVGFwy5/Lqc=", "GOnQzWLEkKV0qrqbA7ChHcDBG05jIJTJHvcsFCZqJtI=", "JJXEHeHevQy1EoAZOgLTIOl4CZ9U7JapcDQavoDZaoU=", "CSUX13Mcl6h35VLuvsdu50AP1T2b4S1V/5xrFw1o7Hg=", "BkPOfK4xP8y6Q0IH6ZZJN27oiNPjCbyOXuRURmJ01iw=", "L6RIXx+XrUxU+pCLCyVCS9x4JVr5x32pm5UJVhlIlYM=", "GzJ3SadfjbcaTDPouZ4sAYCLkJDQSeGrPHq/31qpCMA=", "CgYhacRyNmliMlGlCkMY47E4H7XGhVbfn+E3R0tiQjQ=", "FsM/9TbycRRdrsjwPZe1bQ+M/u23zDKSkP3Bu/3Cx00=", "EoDQZ8TH7O192K+sTkyzEXvnkB1xIatT89Q8RjD3sHs=", "BHnHzfsiDk2NesqbX+c4CyzUR+vz2KIEMgv4H8op6xk=", "FOAk/XurLVAxJBaGxKrhbuMAQi34tBkZzLc/sV7wYHM=", "GoDSBnfNG9qMl3Yta5oAbK1z2V54r7Pq87fz8RLjm8A=", "FDTkloJLjqHvnqf54yTJN0kuM+sa8YRZ2JspujBUn4Q=", "AwSF4MxViKL0mTIRe03eTJM2Iasier4yb0KchogTSJM=", "EArLaRFLU8ECf/Vt+d48/VYdfMyB6IFVVpbg7d+5H4Y=", "AXqXRTmIitpbPuC8fqq0FIldIRHDqdXFF4SInsbUFUY=", "GU3eJ+P2NzyUTPkHmijWjHxzt7YPWh9a63y9o75LnoU=", "K1Y7J4YYBDn71vO8SrXzrVL58g16oxxAsPeQbysEGKA=", "Gr0cl+l9e15ukYPyEwXfvFhV7TNjaqelz8OeYymJHGE=", "KuvKQxrEx7HZbFRDJ1HW0gE0zIQppRu9vxDWpdpNvPc=", "HpOzcqZxIU8ACqIgryRTu4Qx94aU12MRq83v3mZLW7A=", "GVM45okC6HBUdnnQ9KVI0byR6z4US0A7bZwF6/h54nQ=", "K7eguLz591QGl+O9p3k9QuH/YIOPS1n4ahraA3O9sas=", "Eb49pZRe99FAv54GtGjsRKrDfrKT3dv4cfkpL2lpVn8=", "BIGuLHC7UidkukDH/pkpE+VvxkC6y5d5T+5ACGHNIMY=", "CRnK3COsqoteGaVKmWxktZqQMsPua2qs3gJpbKRiEWs=", "Ji3gsD/oyaawSs42YFcCcYBMZu1kCZjZM2KRnhPb6FE=", "KzyQrDpO374JszP/Vs7CkYpe+SQ1mtXiJeCLzxcknfk=", "G7vpgZoFpv27KCfRusLAyXNqp4KA+KgfxZabV2UiAUw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "FCrB6Db8MCeHBLR/pJqEza7JXOxApgq/5zowoQ8tcvM=", "EC8k7Zt8xKmJVyeJBfdy/kFJ+xG+/DSwXHVWoM4alEQ=", "BZpWxoTDQAfhdFd8gdZp0eC5dB1NK51gd9j46MGAPfI=", "HyL4yHA0QY06ean1+7LuSTxoUUme4qhIALDnEbp2qRg=", "JhTRg1nSHSVzEJCrtodzZfSdWOpOeKRKnnrbRAmjruM=", "DEFKDsrE+gY36aTJZ5CFp7s7E1izlrK85+ua9PDDN8M=", "EZMPsYrilEz8JchWzdz/cCu8yBosKoqBq2jiq9DWPZY=", "KudQMhSJrWqrFM9/MIm+4B9Q9vGzocBGBggE0gTW1A==", "FTL7L09qDcI/q1f7KYiuOmG9Ye/zVjTxFoeZFGWElSU=", "KbhcfZ1SyY6sz6sHr2wqqsHdVaCHyoLPY28oaN3fOYs=", "DVDSImUvYTs88KNkUMhIEIYAssmLXRbkt1uSofyiiL0=", "Fr0p7OZUJhHETZDnLKlufoG/BMrYWLiPZbPPBZNIvnU=", "EU6ViI8eJj6TBFMeZy+gUzxZqtMuGabI55oL49q6ncI=", "B+1MPKypNVDZOf7nLzIvXEXEXDJiSB3G0/who5ukqcA=", "LPHY6Vo7LPjUwaDdU63ubpdWQLyQLgXDV9Q85AcPaAM=", "A3MKgtERTwPqD5it0gzXOIlJHC02L8926q5U3yBruYQ=", "IgFifQJzXW3vhfPUQJtfZ15PW2cPyP4zTC2nLp67dOk=", "Head9l5Qv/BSIufRW7fCWTWkGVMgMe++oKiNQSZYAlw=", "GZ6XV7SkR6Rmkkru5fTjxsD3wPFUWAg3eowMQ2s3Tak=", "HMEXXp6Bim6iZGwZTza+w8N8YylLJbqpyfSOo8MS0I0=", "KdRVIIizBTwWyIVSLHlMo4i6OMa56yxV4BFTKl8Jn7w=", "I9Oy3Bx/89KYmX0GRgav90Pn3214NMd1rtv/CZ1Fj3g=", "I4itRue/+Ni0Pg7w/vCE+mDP4ymT6nGDUE7nOPZEXMA=", "ME4eJVk9u6B8GqiOu0qAaE2RR8Cy+SR7SbVBbxP8OJg=", "DWPyPd51csFVhhiKEqehwLK9EJ9jQylPyPi8GneEFNk=", "Gc9u15BXpfxDmK51acG4VRnJchirhCcj1iEs+poKLb4=", "CYYmdDWmm/brze03jSqkoC7jt6i+yu2coeZjYA/JDD8=", "LBV17oXozTz7Y0JNhOpQAHhuWSdDOqjAsCEeXYeSnIQ=", "MAADr3iMWnV2t2T4i+WzsayMsLlGYJD7MxVp1MZnLDs=", "Ce3UKN4F+ga2QQxXpXlvzRztTj0g1Cu9xAsA6iiqs4c=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "H8wCVySUj1PQRW6F+1bz+B4MjUwrztXv4/o6+P93rMU=", "DDfz4tOM0xOOqTMn1ZuIWHPUHvMrdkCWOK9kVbW/2TI=", "HP+Tc19ei72rcx1rGmDZRvJosILZEv7Qs8y1JdjLZIU=", "EVYy4RwXBPll6nJAckNwfsR3xxbMQp8afrRX9DN6WwE=", "ENG8CwGfi8bR1vW3TsTkcrhV+1lFheRFjkwml1CRJxc=", "G/pHRdo7dzeBRCbyud1q5+oDSgAmPdCRzdfhGKRNOMc=", "BC9Cxs9e0PKeplNbqFhAkUV3JJgXSIbbfdRL+axU1JI=", "J9po08mNkuTpN3fAusbHz1COFudI/M08C3uftU5gWqc=", "HA3SQ+QAkLMdCT01yAcZMDt8SbCIva6Cskj8HcN/o0A=", "HD4oFLbrDeg0f/LbnefTvOZ7WpdYX8mTO/RfQG7bb/U=", "RIe/brMFsT7qWoJlmFimQiZChxIjcxL+wfa9U218KQ==", "HU3Mf8bTGjfJW9txGiH6SQ9HhgZINMJdLhWqgty3Yso=", "Aa0lKyORnJM4Dr/X/lvMIho9vE+lnlVbjQC/rYcsDBQ=", "G5u0eIU8Rqvs9DQRXVcwxtxZ0McK5YABPSFvn/JZZWo=", "qihJ2mZgOYd9HGOANQDdy1kljZhUu9gXxpCzJkOmlg==", "GoDEAwLixQs6mpMD8Q/85J17tffl4Z3chYOPAd9hyyg=", "D6Ma8j8rehJ9zCnXp4lqxo484wmnCob35oD66IrhGvE=", "ELYZllTD4ooF3zbj7OGSLD70t2QbL6j8gKhOPkfRX9M=", "IwAqPnSAnb096UJg7M8MULFa2PHQs0KW0GrljkootvY=", "FJVo368/rJayY4w1BqjSVgnKGOhGrenRmv4MHgXALGg=", "J+Ay34f2wWQdy+1oFq79/aE3g8MBxuCpDDGpj0wLkgg=", "AY11FX/xbpWZDYPKW8k2YlGkXG95Na3NHu1slE3If14=", "MBm1YLfrZjU7zP4lMUZHVCWYcNgkbX81u/EMaGK8c7c=", "D0ZJu7MBNIj+L2GtDVkEM/XHh2qXz5yD6CHweINMRbk=", "Ktqz6DiJNNW6fPA7mMI979pcTBUzZJNrE2go0G2xLZk=", "FJ+q4BB7HKweBkzFTRlQYCcRqnMI29rYnsFz2gWV/2k=", "GGAd0VK4rDOO7bEnjVN8FvcOH8zQ3Z8bHsZztLht6w0=", "HWXMbnzLcHerUd6ZL0KCRWuBjaJA9G3odL3U9q8ymro=", "D9wPWjK2WoThNAJ8c1NQPH6e049JkH4opZaUGehDiqY=", "Bl0+dTvsE829LUywhfwlyHM/UrU3Kkrt5G66GSWMKm0=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "GAqRbpQDf57xPwWh6iK9QcotSw9e7a04akILphiNSII=", "Dm/ChOiMFAPwarhz7J2AMZFlXTXCkHQMxoLKyiL8E6A=", "J1O7CaDEp3s68qaTM+UbsncDYV0J1W+GQj+Fz8iCf68=", "Jy20ttcfgPUuSqEGH2ok6Y3AQaC60H3Eaq1Z5n2WsBA=", "I3jOLFIHSwJ5QIkVYnQwR7e1f/wfZlTC3MI77fHLdgg=", "JukPfP1Ak6J3YA0sVkts2PS6OJm2RtdCfOkHqW0ltOM=", "HK2zkI7gI1OjxF+7V9v2s5LVseWaE9WLV7fg3HHI074=", "BNMNWX+d1nIOheq7CngICY9y176uI+D1hFKDywQzTis=", "GT2minppm3zzPDrJQqlgwVT0R6AW2VfiQXhiUxAbHIg=", "JkhOeJfxbDC6u5pOuCG5TiBEEep443Wby1X1+eHw7AI=", "JqSWssK1yluj3Yr23HOqoti/0vZxWHb8VwOtaKrmoe0=", "A4W3wJ3SoaDCWVqUCRR4DWG0nwgeIBScN9kgoG3Irnw=", "IVrYuRtUWY4K1xKfJvbrTlKifac4+l7CqvO0ccLvY7g=", "JcApvFRoeH/ED4uWj5VCqM85Yy69tSBJbPmt5y8ollY=", "Kov0X9aExAjogyNBOX7AWJFnwNJs17tzInzIMnNjK7Y=", "FiGkUnpFeTaqEYIeDhg8gwCOIBrJIu8kkacgdn1awoI=", "IUZgRZeZc0G1tRLC0wU2+pYdCbUZX0/+IO/SL05OEIg=", "D0aUF9JXSOZUpg16QtohnCwasWTg7PSVCjwVquyde0s=", "CFRWmsFTEa23fdjyzugQrKKcCaR7YTC1HBa5UXjXbys=", "DhaWppgNfa+lv1ouEK5mTgwpFTJyh0FTzb8rMDxsh2I=", "A+7Cj3IJn0CBtY3rCpWrzvTKBq/lJQop9WWxj8jA8/I=", "DwNZ3Gd6IgimsMYnkS0WtzbpGrP6g+uCWnserXHQAPE=", "HrSeLQ8XhFs+VZ3BLMN9cGv54Ejmy1WnZt2tEQCge34=", "KDfZGxUBpdS5WRPw0sJJZv739cNHqqiXwhC6FZE97yk=", "K/OfbPHO9sz7v5ekJUrNR4yJfIzZYU0/j5u+9N5kbJQ=", "Z5EucUTWAps7xy1Ejc/bv+D36VkSk6sgWzidYe/3fQ==", "GRtHtp6K38kE/2erNtGfuxAhxwiYudZX+2oCC9a/5oQ=", "L7611UIp7lgqYnW5l3t3zKqN3JAmW3xdWfjRmvaeRs0=", "IjUErPhII2oPfNlGyEKJxLSroOEjsduOWI/efeBu8vM=", "Edjo73izE3Q5N+FjlcEZPD5G1LhMeBiQdteUH7/wRiI=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "INLjYSXmgVNXhdwpTHUddVfjHcmcAcxF+2fQ4PcDHl8=", "IQgIWuYkaufddvez8+DnMbfkBnYC9gJsnMYTIYBtS2w=", "GQRqn7J6pZ/Xy7B1kFxl4WXRYkjZSMH6uatHLFfYrRo=", "CTqSb69o7ZLpQ1B6iTFjtDOFeh3FZPPybC9JcWSFLIY=", "KXGoeccHk9VIVPfM3roJkianA0+l2ZEdyBrugM9J8nk=", "D19bqbdK7XYlmhWTIeJsvhzX5YSa6FYv9JfBr5YoXR8=", "IOd4YiFwDkZ99k2Nc+TDh1OkSZaqcy2jjmIb0nChbg4=", "H0/ACKQaJXOb1BEYuqvPJGX8sOBWBbshk6rKFnc35rU=", "DEo+o/cI78iDpLzkoGUdhRfHChMk3kk1qlCMPAriTco=", "LnYQ/hA1KvR7YWiRCQcUxoAvP8H7nvshJIaU72JGrAc=", "LritQMU187ewXC/ZY7hWnpViWSJ+8hokt6/lRu/+QYQ=", "FUmJ5wXPnmK5QW4og0pKe85rVzoSNSZM6J1LBGtuu+E=", "GEdJoOG+wPlMjzxb4Mdth5dpUkScK/5jBEE96mEuLh0=", "JK1L+DwvM0HcoMcqNXX7EoBVaOksrkRy/hn9/yfxHVA=", "DniKCWstQZIEbudCmB+jiRh3e2UDDvU5V1ccO1+1Sm0=", "HiK51MJ0+tUtTlZAtKy/8sSBASegh8Qvm+mrWICdDVw=", "DIo/LuMkZxRASr8FIedKY7g1dklqr/hcK+dKcQaEbxI=", "Ia3elDRhv8vX6xA0WpQDOyXUcBFXxpRRn7K0CTt1Zwk=", "Hqma/6ponW8Z+Ka4LUuB39HxdoKDHgwA1/L4/Uk4o34=", "FpSRmf5KOHUN5z+nN6KDpqmtQKJ7Deq2MfkpWt4kI8w=", "Aeg71YGs1hw7VK/LegqaATjZrEyHOc2uiXWdpRUBOPo=", "BCphqEyUTc91T1qXsdyMLue9+94jP3iSEPUG7aVpc7M=", "K5PCixV84yv6O40PWFBh51oDt5w2anWFbNtcoic+ML0=", "H1Qhil2upgRfpgsGqyUgxSVgKCscw63hS2ZL+kl1K/U=", "D7/dNpva9wNmn6XjagCq8LJRpQkSBIra3IOq8JLn8t4=", "A2M71acqUf3spirv6UNBBLUuFSZVzELwbnBFXMFfji8=", "LA61S1+M7ouomKJC3KZN7wndo0bQYyOJKVf6MLPBOvc=", "FlA1mD9WOx47y+bIc/v5EdGU++VCQ+A5s897byr72CI=", "L9mCCzy7Ex41dd5Ozs40cTUlh+EMlucq2Ge7xX9Md4s=", "EgS5GdhqEs6nDpd3Bqsr54JZxsYI3KYo7uzOxQuCk0I=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "AvPNA9gugOhSGiNmv3no1P9c/DtPRtuZpJR+HOSZOys=", "HKw/3JZ0xkwWFKX0jWUjnapgHiZ2b8/PKcw4XWs3Nd0=", "BlQV5N/gjjV8Zp0UW+X6bMdLASbwmfrx1+hf6b79MNc=", "KO8Zq0uyYmkGcw9TlJfd5kihqWfaXqMZaf62INEVyLY=", "PojpcyoaVy5w18tlKIVxQ/tRqUn+ng+g+igbhbZLfQ==", "JIarXFMR5L3GWrSfxgsXL4UZCNZ1P2qcxA+bFTWvBy4=", "DFBGnGxr1TLG+AXSajCn5dcD4FN2V1GM2g4cYEQwHss=", "KPi+UlJ3sDRrzWZM+wokoCj5C4nKQCJUtPlYM8t+6HA=", "CmiZDaEvMnptebNWwdJ2QjkrGyzZzAtdZ12YQ2Bm5WM=", "Ihba+0F3ahlBsfF6XdjMocvg9g+BzqrEZYYbPcLrvmE=", "IObJfDdIkdkygFI2HZMjcu/LbAyEYotvO/zUHEfRUhw=", "CiVlzOvRA90URTTBCfU8XeJ1rFbpFwrZ4+0LYAqlHqA=", "HnmkWAK551kuYNfklk6JIKRYhiz0AhLblkg1QKYqzzw=", "KfVPGpZRS5tC7J10tdcV5hwmWxKacGG6wSa/1Q9pb84=", "Jrth1h/yeSQvHlx7zK5ifhlC744QOpFbZFJ/0OsxqTw=", "HtTWBtgl2G3e4WaJ8k7l2YMqFA9EtDcliWn0HUxELHo=", "JRMf4SeY8chxL07rvHIT6PgLI+fRvev9JVwYeTc08lE=", "DZIe2AU8onDWA0nYW6ON/NBbyWwFpoZ3GFlWcHOF1iY=", "JcerF/PKcv72MEL8++Gj1fHvXW5S2m1tu1qtRrHhdCE=", "HuA4OcokgwCb6/RhtY0RyrhSISZC040dM+SNmVb8SOE=", "FaWi7s0QfzB9lWVJZEjP270U70IyMnXAq2WXqvGJVHU=", "A/4A9GV2et1ICOwSqraH4Wz9cCwUUyZ7eiV1xstVe6c=", "FXeCGwfkuiuok78VzgYsApCix1fKcUD3bC8DtT2E7a8=", "DADyivXN0BGQffiRZp0KQ4kvv9JK59Kru5UbZzNBWOA=", "EfL0zeZo/LKLJxU/DA2FyG/bTQUG04/Vt20zc0ho9Mw=", "DxW8+C0dWDhpYFMJtY04KkdQ+oIh6+gSbuUirmlqv6M=", "KofIPFj1UUYViDDfUtdEA+MlaRebQJ2Ol8qKJ8dEa80=", "G2VbLEPqq1uNEE9HLY2EqDYkb683M9669HC4tos8YHg=", "K0x4kVcjGSY2gBFqeinp7jw5Ug3Yu/MwFuMbiERDado=", "DVekujCaOA7Y+QfGit7g4uwzajPWer+m0zwLNBkdXD8=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Ak1wJrnfbe49/DZr+IMwHS9bDXaf/m9iVhRzHIFjil8=", "L/qSYNO8GpittdmkVmpnOkrIFdkh9mp4x7Z4H1pFv+0=", "AcSd2UOaE1iSRWwZTAuLcn9fjfuLRjMs/3mw6IrwiX4=", "INwNcwwYj1cflEzaZN8DhfMe5HeEZJs4vIswn6cxAC8=", "Klfk88HTQQMCIH1T/GU7CRuSFbmRT34hFDxew9YIAgY=", "GJJElqAR8dD3M0x178gqdWtfp7c5rCE3QudH8Lq4URA=", "C0iNqS25+0YN5Ze9/1kXvAc5PlYLdd90EqI/hnggCKw=", "GBcH7XOrxH7TAwAa5vw4jf0wvKpXt11GZ/ve3qOa3fI=", "Lz/ETBowvMNBm4jeZXByhD8+tzF4mJSE4BCmbHSkv0E=", "GfxHUUnzlF8/o8iKp7sWbgVss1OiuyjpjLLGR6pyYBs=", "Ak5Sx+zf5ZrDk6fjZZ/AOPWCop8JB9kTDhYVpg4NirA=", "B75vHPcZHYz4g0nOzT+D31ST7c4XCPZaMFw+dJ8G2mY=", "HyGk0UOjSWzWc29kYtUs4ktAYw2NyMyu4fT+g9LY+OU=", "LSbvpq31r1T0bGg19NbROHS18PMpshooCxk5n4VUAbo=", "GJ1V6cDqOQ8uIZ/kq95MDsb6+hto9aAp5NLV8mmMBXI=", "C4JUIPN3JSzQlNtA1vN4BqxQiW8BprVjYntvv0W6tZs=", "H7oMcAufMBEJuD+tYZZDhczeLN5pUQtmM0/rgNjcXhM=", "DUwDgcu7I/9BmZAP6emLBYginpXNq96Hc0t9pKlnKLE=", "B29dAOc+TfzxP1WM7Zb9hI00ul7Ei8wUEijCLRholDM=", "Ha5Cp+JFUyEOwdN6g+fjefEYrygzpjjPsvY3wnMbFno=", "CnzFvyTeK3plU82xA/e5OiylDnuLKUdWP7jq9Mlqwio=", "KwJ3ZcKYIoHz9VLJ/COblrBIW81rJGVnGJdgOH1UpTA=", "EAGXZmK2/x7D9lEDGOUY5tuj5prQY1pBFT4YQ1ZT4W4=", "Hwo3eBYYlSL3JOplQE7yKEe6wP6V4qbGZqqyfMTc5EY=", "HnqUrF6kP9hoeEwpQyBapFmUV1tJSgwMRp9r4yIHfHg=", "J5EgZ2b2KgazoKDXF1mURCXlDTkiGLmZqGu91ZAYQHU=", "Ea2HrKbCXgTLhesVV+Quz1hRqdJNIPntVUq53ppWGBQ=", "B9dv+D6ao/WSTtMTsNGDpXA/SesX25tRkrvB5ZNfQfs=", "GO7CEHLJGTflPZ/Q44AHodjs/vie4KhI5cQqczJMCJc=", "DX6h2KFBZw9VSUYcjmZJ58DdJpJ1bGwlzEUl1Ddyisk=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HZ5KDSqF2+IOZAlkgG+h5RIuKCH29G69L2FPUlhmEsU=", "GwUp0rqZ+Zx+SVih3ZQBYORRrWCnMfSC4O7E8mgG3bY=", "LXjekLLLmQHM91gh22QeJhm+ygJOM1b80gsHRHc77B8=", "rLWKXGi/pDtGl3qdoC92cnl04k8T8ebnZG/MFyNb1A==", "EzRJ0IK4i1WzJOwRDNtNq3koQ+KRWgObUvE5kJarsT0=", "HkCwxXWXye/Z4hqgO55g7c/MYxPysyWhu1UqIn9GbPM=", "HcTtfGCJm0EHRe1ynqWgBmVouX3AB7bn6AR2nc1NfTY=", "EUbPG+NFWOZD4oUMv5DR4l4+4SL4KSoSuL5Mu8OwLxU=", "JMyPxMh1qI7KSGSwOJRfgTgbgprmMVbjFKsleClTGg8=", "Kflmjd3WEDWUwJK0lVvqQqeLdisBT4U9EsyKQ13q9Qc=", "BCP4rPtkJYV/B+Rbq0R0snRsmH7rPMzslPg4/iXVJOs=", "Im0hogbxfWSTBuoYpC5Q05XWUTbQgtkbCfIm5j+2VAs=", "UNjgICSF9u2SbxA20c/NwyUrSb7iVyGKoFj4t6IjIw==", "LGmYo6HUmIiT6rp0bPB+xmUInuFJhzahWA8qez+ECl8=", "CPB974+SkflAsEREOnIPFRCaZgLlRnDk3exPm+13P0o=", "Fa2clYSMTu5CKLHaJC2mQOzbrCym8hYwYEXHlODNQes=", "C2yUrVnnGV5HBG9eLb2zlbxF7GVLYMSdjznZ+LiV0cw=", "FpFaxiYjsZziEBwF/nJ2w3OzKfIOH+K4b4Xjuxjy7ts=", "JBwXQTmvoIZ/EIWG4zffMXO8o260GmadoSHMIcxS4Vc=", "L7xIpJPaNjKHHS3lqMIvIhEq+oix5xOV7O0BahSZQdQ=", "H67e9SdMrZ2KVcf3Y/qGhBlgoHRnRcNZUL7dqAtvQiQ=", "DlypBJb2qy2yc+VL3ZmuDYvBxvCQTeFJMpWPbIN8JvM=", "F4P17f/ALVcvqneYIACDuGsrHOIyDcfIoLHr/9vJ1Wc=", "EQj4myKFrQIoW0zqju0i0Pq4QfId89Tr+zmGBqa6OGk=", "CvM95zfD4fQjxR2JOEJC6iO8Vkv0AiggAs0w47FjRos=", "DFFSzgZfyzC+RAXNM42FylDWoG6TRPzHY02C4Ol1mnQ=", "KbhZUxrdC3IpJHhyVSM55Kwq49S2yoxwV2PMgZMQOqA=", "CHYirPJ4ECd/48rm4nBIPQ1TFYkA/KGEllCwtezwFQw=", "IohEiU8OzFFkEbC4ZNupiowm71EGJ/LecOHRO8MKbh4=", "GW1pUWxwHrAMZwy1dzNoBkKWQr6LDjAf4LsSKT28JUg=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "H3DYioUs0WyC9wY32dlz1Z9+d7gmiqzUhOTlNQD3KyQ=", "FBzc1SzDBFKPf5PyOUTdFrPMoahbKoRnDFBLl5K+uhk=", "DbVnRe4N0TOvbze/8fbawGHsfkAGn5qBHn0DTXowq/8=", "JWngHgDHJbSNVdJv2MSXhfw2JIKZ7air07krILFQILo=", "A1PBWYEh2qzVMviw/9F1MYswm94ot/+toyu3O3hNlfI=", "I90boretoY+xM3U1uTj91TGKGtIozwB0fQfv0VnMI80=", "CkSdI5xRQA3o8nWwB4d5CqUI4eFgu2bofQ9OMqxaW7U=", "K8w1rEfq78XOrpO5cYfxmfTql3YJWpjvpTU9ohVAuck=", "IuSaQ3i2tpVmUp9VuHTSME4ky6pdeQ92kA7i+EeOPAc=", "BmrVuAEz/QpjkcBbfiCxNBbkDCmgZGkyZ2jyQnb+GEE=", "A/IlMinCgQquXIQR1RMKtBi74Hew8RImIwZVMqJZuFc=", "JmLmyKETSgBYZ+EDkBpfbGesNzemYgrM+ANMuDvb1Kc=", "IKhgZu7Otpebqt3mojWb795Jh1urFC5X4XGwhwspIIY=", "E6+8VXPoQxKkMWD/QEUZCtwqnbA5gOcSY4H0CJ58kfM=", "B9bbbN3zUMwdWaR02E+6rQT6Dyv/kV8HdwjfQdWyp0Y=", "Jo6T5G/X8T4aNZ3fbrthmiHBBo3m2JlZCqEEi4gp3bI=", "D4iZKLMFswT84o8QPy5BlPKynN/yMbBe/lYeHP9OcLk=", "DFR927+Hwyv+RU2OiwrUQCybl5yqzq69nVlITUPNN6k=", "INqDGC+qwFmp0As13DRe8BFRF/0koV9rkbUBcoSXrlI=", "H2tkO2DlNdDycxoyYnNXbqcjZx5sUee3QoECj/sEYu8=", "LRTUOrIZb8cOJqa57z8unRj2ACavWDM1nypPaU/2+c8=", "DpuFhTvs3AVCmwoop+I7qlk3fZA3YVunQIk+uXGq36I=", "CmZGWLqxFSXXCG4SBq48aruewx40YdawslR6XWwu1U8=", "LgSY6FOdhXbfGHJF0LEiL0PPTT+PAgmv3LL2h2djNAY=", "Fsh8dmLmckJjtE3sCICAMzeTuiAC+5Zp62PcOxGJtus=", "CcXrp1rvwE0ENjgMg02jbSCmf9ThFlNJi07CGzCQD1Q=", "EGa1Iw7scLvebJjtTkjjkv6xiWe+caEqwY5zKgS6mEE=", "LdKprcH9PtBOslndpjC1jAeR1+55uF/CD/izfKDcBGQ=", "LpSpbqHxip2Zv//D/kPw91G81UnR5ZkuNmlDqFzPSvQ=", "CNcunf8g1PXEVDtyXkPgHxy9K9DZ6ozmsMGpsLLoSZ4=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "IwBQ65kB4tsvFt9Zp/W4ocRB5f6c84aaTtBzuiX10Tw=", "HC9/QB2hrZiebLtcgeNVmnkwzrGRZpG5stcC7M+j+EQ=", "CbORyrDDS5GxVUg6QTNKmulyA5QtdoOFAQCs+jXFFgA=", "E0gWtzMSqs8vVzQYKD8nvKWNTSNiSJD3o7nKgcEulxg=", "EktH+eqHyUEw3c93+H9LxT7gh2mdDl9iZjpjiRwWddE=", "D+WiElGmUmHmz8NwlARxH3J6YQ+UBXwwThumey8AZSY=", "Aoqztk9vbwzicH++hUKVYW1nbfsNZhd69mebP/pRLo0=", "GHBJnaj1jwCs9rETMRnXVyILtU7L15P57ULWXDF2D7k=", "INtwNW3Y2FWrkrKKlkKazVynfNnlIRqsRIuZHBZQiT0=", "Gh/xxYGS90gXRpGpjYxecz7YDqXC/tEbCY/LgVtDhRY=", "GrI5nH584fXT72w88z85uoPwVL1z2MXXQlZm7zkOT2k=", "HktfjqL6IuVol4z9kHd5N+/AcjOOFz9Jzfd2GpyqK3o=", "IwWyJIMofpVoFg8N+6Y39QxjRy3YnlbaBhG3bP6GkQQ=", "Hvx0cQFH5OffZYDQyliLbzOL7+tMb46KCWfPXJ3Ac5k=", "BDxeS6POrsQZCs0Fombo0zloHq8SR68Ef9Dc5y+zfA8=", "KtX5/lnLgbs+s66ZhakFrb8v7oQm/gzjwbEIIJrqhE8=", "Hza6DSKDmzF25Vqe0H3L8CVeOGvOoKW+mCPbszAP/DE=", "ClZbPOXCqjhhgSdnjYrsI1leNl9eUdl0dLhbFqEzYvc=", "Jx38KRRHMM+ngPmszJnKqn0U4FxC30ASk9JHWcEtjtM=", "ARGaeN0Mv4gBS5fm5XWLZMjBM6WYm3WK9g3y7gVANIo=", "FXlwpJ2tr4s51GraGf0Gs0eEpvM7TYVUfCST8n84ngs=", "CGlzV7rEExmEsm6o41KjxeXDP/IvCQGWRvQ7UTfU3zE=", "Kf7LPXDhvSEIcyKp0PDbksZfFB8CtFk22aW4U18LlV4=", "FCl6na1u490K2H7pwtxjaFyq5zkQEuJn2iGt4qqkNLE=", "DI86fKG0JCGZ1qCZmzDPPmHf2la5jcpMm7GZoHD5x4I=", "IQW8Agub+hojsLLtvf1M573tytV5BtL1gFO4qzXxG0M=", "LesE9vkMJKB9LzbkDVve80Y5sJLTlbtKT7SD+ErsvL8=", "KWTFlAmFgipkrBRD79xBzzfofb+FhTW8fIcYF2gJHGA=", "ILaMG17emcz8fNEjGxPpDVySNcNvL5Vdxv9TUhM+qd4=", "MAluEYlu0Wcmh7609nJbdJVQZn6NpBhxO+p9tfg478o=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "BuISKO2JSXi5Cl4LaR2JFqpjcgpceVuaBzgUUuIjgrk=", "DJvPgNxf2J6+tgRDcmJ2iulfpyY5JFAVQFUuek8kFKo=", "Caa+cwTG2gQ95MA61cdhAai8IfGqyNwQppXHxfwvkHI=", "HXiSPQHIrC9Z3fXwRstb/Iv9CD7GGxrwgMecLdsnqDI=", "JyrmSWQKXaKRvnkVsBy6hyUbxichQP9CCzbyd3RZQgk=", "BLFEHvFmxSD5MJ8vmEARoA38cdYTlgPukEluWdcV93U=", "Do0Sgax2rkX2+BFr90mCunYQnEKi6hYzV/6+BCJljEI=", "HF1CUNp2L6+/MTgEJXEm/qFQhajunBA6mZKVCrSvkuQ=", "E9VcfAtems+sIZYgHo5KHKCRUFsStwBk3O9vnTseGLc=", "A+igPh4l/tkTGz3nFQ2lrQtT2k/b6pcp285AziU18Pg=", "EmI8aZPxwwEIx8eYaMiOOUOmRZXre/tYFHkaqtWgnuU=", "HTgwMzSysTKNdFMBnFcfwo8bxeTjyUULSR64cNLI/ok=", "GSIx6+NGndECoAO0HqeSN0Kc/Erk19e19JFUqnC5GOA=", "Jlh9jSoHSSN5j6lbeNVYpzV/SJifVTugO76ADk1O5YI=", "Db7GBoGnZyX8+bAJAG4SNfK6LT8J7GK1ABHRntWAGcY=", "DXkgbIow0mq8+zdfuMWhF/PKscn9qN3uF8CZGxHGPhM=", "C8V+BIZ5dkuVjsVLgvo7xGkOmVkfQiFkR+xquJ5XUu4=", "Gbc6JWcBYOwmMYY/6Lk2kaMKXmzs/06R5LVt6k6ddag=", "CwLf1Ot51Z1mV5Ttgp0wHOCOLlKFvPb3WoPyOBX4xcQ=", "Lo7aSOXf63HjMCJ09RanQTH9M2phcSahQ1y+2O9snZA=", "KCwfHVYvKSfmlHFbYxoXa6r3YhxEpVuQrS8a9RLytJk=", "DiRVLnKicXslSVb84h34EP4/H7Zu4CJL50qsrE+br+4=", "BhnWu5+tf+egY5mN7JiIvuwqHCIGvJf2hTwQ5i7eLs0=", "EIVVgL+mE8IaTv27DzAtTTCoenmnfK2Cs3rHar5Qcaw=", "EufS3zMsxdYYoikA5mVSnywivSsqo4fZyzDalIP3EVU=", "EI+gVIARhaav9hnn3dncgJWITdzzyFuMkiqq3n/ej2Y=", "L4zd2PLF0UqxS5MYIZe4BztOnEHBOLZ2SuNWl3HmF+k=", "H0YipsBR42lkFLICSjk5F0NHmWi0r43PBxhtXC/weXI=", "DDecUUrbvczkUCzOC4X9A/rpjbnY820/PFbLmUKreHc=", "KxOXCDmfDCP7UaTSTnGJ+x5hn1x+A7y4yMMpRdjhkw4=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Gmf6OJd4yUicSV3rJI51TDqqqmPFujxuXP2Wvk9RbAE=", "CoK37+7Bbmxa6l6ZWXsJhQSXPIJO29R6J8sz1l19Cd0=", "BYtdctD7mDbauQiQqanbGDlZYYt949a3sfwHYhZEvHo=", "JEEfyTMcRGXeOJwVcZnKJPMEQkwEgdEX57DqI2V68b0=", "IQNRpF+k7yayg3rQa0ZikFGkZGAuUrNu8k+udtHW004=", "HgXknbZsM0Dn2xSSHAJipzRsaHqMJhN0N7UQ4whA61k=", "Lmgz1MLUkqBaHCvkWNBqZfa+QocU0dRMLc6mYVcdpwM=", "J0fg+5PO7fkdC3A8zYjxeejxAzEJAyFmCYW8Y4lyQc0=", "ITc/5zQsKQdDCb6SVGyjMI4oIVFy1DiZ2LNOM24ML+s=", "B6ygfQBpoCPXjgqR9n3HSKtYmQrxL1SxTvv4P26j+Vk=", "DTGQjfkMHp3rwQR2sPF9q7OuFQ1zHCCjIfWtbSghO+Q=", "KLkK25Jt92kyd//SPKc3hSpEFReo7KKezNcyuQ3A21Y=", "EEFH0fYQFQx5x7z2HvHrHR1iCvh8SVFqGTeQ3FyxzXc=", "InBLDupUXpPYVnlH9XNhWbjHVZ2pNGhR7wNJQ6n2Tqg=", "ASzxOGfh9MZl2VKVVJcZevghGSl1DdcGpqZdxlS5now=", "JkDHl6tAnMOz7iGGlBjO1saqMsjZa5o9qFyZ2KK8lQE=", "Ej4BeY0JSHSf+O0kpzJwXkQWKCbCx9KAJdoTPsNYuCI=", "IvWYjEfDb0VPxcL5grhUtPT2SsadtYp4ILEO0FocG3s=", "DXGgsUjEZXJ67Im9xmAbO/NBFZ4OuSZy/SzSlnBQlVA=", "CcRFDA+rW3e3/t3I9MUAMaET35c9Pb/wEBVk9N2l62Q=", "IWkJuafskn/0voH0XzQAS4DeZI3Mtk6VbmiXVcHQjJw=", "GmdlNUIOFw/cx3hGaLQhUC1p5ZVZktExM/n1OCn7/HQ=", "L0XoA9tj2GumG47TrzjEigDQzmnBUH6FZHAi1vOe4gg=", "A8+JmTxGVO+0segE3Fq7Qj/1B/erxlzI0aZgZxJkoqQ=", "LrhAlhriLUfndr+feNjwl4ZlLrmXgglwEOEPzf3rnuM=", "E7P8w8FWBC3TDZyTWkZcUoJ9unjN4lzIekNoRaOMwdo=", "KsKUk1e83FPYojThlUqpSBOgglqTCO42WdXThrLxDlk=", "DhVGC/MU3jxn2GiXMohIO8YpJry9LnBC6oB4iPfZwZs=", "EcdnoxYxgtXusq6FelswEDlflkC0QPdam4WcMKsYAMw=", "DeS4MS0j/6R8zO3GXeVMzflZaiwmqBd7eIkPmgAA8as=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "IqMGdIu7cnagJbmY0FPHXa5fp44x1kVxiavJd2ZQZdc=", "EeibL1qfcIORvxFZkrKVxd9Q60eTN5E5dJzTcY3udsM=", "Fw0YAeFWunORGrSRxGv+0XfGy+xEvaZXMpjP1uklMk4=", "CZQlo0S9JIAf10hH7nUkBUssC+cqWMQpKACNcWM0BZM=", "DLEwdtYqHM6vxJW676LLA92/e6waiySvvwqEI2ofwe0=", "EFzRZ8vCmUE48kkqQuOckMcfoREhYMLDy4b0o9xvNvU=", "L+I1rQriUqCSMaut8YhHk+FHn4lTWH0I8P2EPHPO5g0=", "J7AodcKL/BIXSQ6upVLOOUQeY0imYKjf9GBWSzcAKr8=", "GkjuCe0WoDxP4sQzv4W99K5s6uyHBsl7/3ZJEr2h3N4=", "F1sUzEJFtGnb/6aXCZKhv9bGHeqxPF2rJrFIG55hb7s=", "DUawl0GVqtRpi/0XbuM/zYSnJb5MEwCcFdLQD9wXahY=", "Gq3O/LPyGt9LJdyQjh+qvLrUCMKyzCTKWjXlZJx4c2E=", "DugNIUuAhhLa+VnwnCMUMSz9CacFAkPmnNmTw1H4Zds=", "K5LtcvdQWD0QkTMqzDeowR/2FqyYztLiq0fiZQt4PsM=", "B7tsBHoKs3ND7SotGAk0X3LuCSGwZoX2NW3KhVBTaZ0=", "CyfFwfTwiBDExxsAMJIEpeoWAgZfGMfJVooHNjBVEnI=", "EOshY2rTzFuIL47vULFk9cDwXjpFJFsfRRezuhlpP+s=", "E5r6jXxwFti1A1HwUmCi8WYae+EWat0PKB/uOl+lfCI=", "EKgxZZdGiy8Zp+3oNP97pHReYU3c9Do3Olr+vEWEnXQ=", "DnvIjcpek0qQswwG/DPEbriDEdtf/RONLNsjdryvTOE=", "HtNSDx9+swhRDyD4rYcJnSjCYWWp3rMzjHb7x7FAtOc=", "ClsFf+CT7VHekO3sH0/FTCRhTDVA+NNq8WAir/3kLTQ=", "D+Gj3vKgEbp0j5ufJj6IqjIzX/sumFe7Oi4KHRTtvD8=", "H2q8A6DKupcysxOivD7jDTeQiLdyxu2ePZ08ykccJJw=", "AyzDX0lMe4Jt3BuxhdFEId7Nw1yJxDU+E4OOwN4Od3o=", "A1JrT7dZZeSb4Nc9Q+cG51bYT4Dbk6/eaGPMSbAX8Zk=", "GQM7w8QnGrW6++75mQd8MzhsBE8FQFYAsM8XT60SuOI=", "F3dRhIFzePY5/Mjb2X3w4Tusy9kMg/C0gHrppIa8DU0=", "Cp4clVIGULs/Yaj7FzMGn7XrdZWTyYnHyMkc+mEIw9w=", "BSYQBjQ9Dxfsh2hU7H1BMVVloHeW58FzWCXp3Svxbjk=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Av1zd/kAb4cNDAecixC2Jke3x2y0gbKjMBE8x1B+/9E=", "GqbWfeP4a9WPBEmPXnEnCljH7MINgYkex7zCnZLIREc=", "JntSoXSsjp0RjdLQIQQ5Yf6WhscVbDJL/vhChqcKIMg=", "BxMbS3OvBpeip0TjSDplM3n5pvZuBYIbnRKqK4/H9S8=", "BnhlLqw4BcFja7YjkDI4YN2vbx6+ELFno5uXXN2Ju1Q=", "FSCbEGdcq29Q0ElncRF+BQzlEgEm0kFnLpkcLcwM0aI=", "Ghl3v2EYStNcU+v9s69Bd26rA7LbgmZS41rToS90W9Y=", "IpZEyEL5kHqTvssWKxKvMUSnx/JdBk1FfbcOnJzZwJk=", "F+2av7wOQQPp5M59H8yV8qig+K3eiRtV5CT3apP3qRU=", "IQQEDQe8Knmrx/5g5tK9jOebk313cuyuTiHNOM7395I=", "KbF2lgSLfIsoBefyrbhswUpsVFd9TUt0HIRCA4EsyYw=", "FVt8l1Q9UwwXhOsSqMjpWU1CPcRaWpOm4qsqolIQ8bE=", "Atlcuhf/Gi88yxZecAkxTFTR9dLqUUxUOC7JGPDRiCI=", "Cp2NuUkl7ojFNXjQMSFZukVoxMNbIWB0j32vzJnJZv0=", "C28ZsCDL8Ot0zNzrIteuRzD3LbX/9EYr05lBywuyKYs=", "L3Capw+4JgTmYUsHEn/q0NbIiflid9qAhfiGpZLYIz8=", "DAXV5xyP+WpmkZCWWw167YjRxd9ztw3heDmGv4hRUHw=", "CPrPE/jccxsvIWWB1LNfEPPVS2xBRX/YM0dBfMmk29A=", "G7IZpFWfaaXjyjJBpWuibjbIaVX+rDRnbC0TpnH0cO4=", "MgVMy/14QOD+/sHMr+SyEJHCuSYsAzeyade97/vWFQ==", "CtDiFl/wQROIPS52vI1RlwJkTB6Ti4DGFO+FuWbH6pU=", "BdDNb3bOFMLMMHshFAkymyn+DoB0LDKbZGjUy2xPiTg=", "KsIcBjXT0klhC1fYMSRDqcMP5PNT5111A9TMZGx8wvk=", "LJj1OtEsbS8sH0rgki8QyTGc7jtV4XIHmcFvo2xlryw=", "H6/pzdABwCioyYlbkHWhj5P4rSVjIxIAAVThsH1suvw=", "HGblhc0cVlGjtlHOuk4zvXlUr4CLafToFxpYM5tnVK4=", "K4AE1wZmcunFG177CBDaib3EgWWBSdl0ZB5DqOYVBRI=", "Dxmo/obsnJFGCDUg2b2DutYTh5oOQiwn4Jy65lWDFcw=", "Ehma3uFLj+8gBwIHpuv6d/T5IC3zeXKjHhHKucYio8Y=", "DzS78lDl7qFo8Xctk6t/U+HcVwxwbcmBhjnwGBF02PU=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Cyh495VHJCOB+D9T1xtKW7UK55usOwlpDC7ATCeVKDE=", "AWNnliWdgZWWRB8kGODEJcz7/mf7e0l8Q2ESJ0giX/8=", "IwEB+yCGw+TbtOGbF9zIkduB0+7ztcAxsrFCnkb7lW0=", "IDPmYGMuCy6EEbQ7iw/J0juoEaZKqEawiCUW2VRzgxY=", "JEVk8MYlEKXm9poaj+d9a8IuyZibD5fcQROi/dzy/T4=", "DqIqq3OZNqeLO4XPUS3gjG6jA/U/tp4HPS2puU1g68o=", "BwGGjPwYgI7z+Blr23vyqK7pbNhdJp22CkzVof+bLog=", "CQTPEcC1jj/jqn1w2ONl9vIEJPfNoTSSw6EInD4gk3g=", "HVkw8IBF3hQYz+qzowwIAV93p6GauiCbmS/a4YN+Af4=", "E9B8y+kqyYSNpMVlG2ksOymL3QAsdsFnPjmwxWySzEw=", "Ap+rr+yFnQ6up7SagVFB4tXoJsG89P4uLE2A0NkCap4=", "GvWrMi4CahsoodwGy6hYVVDbG7/T7iNV2N0cfUExJg==", "DGD242ETzl07iCT2ijO853+Klj6wrEIIo1wP7GAagT8=", "F6xMHcBnjjr+7vOhH6vT1plFaDk0InfEtqVyVqlM0b8=", "GNFAon1KdtHarORuUgHCBXtOE1Pm5qkNJQeY5ZsFUgk=", "DxM2rFbGDEvJ4ndl9Du8SiWDDlFBJt7c9Rjx9QHKtmI=", "JA48On3s43qORnTKQRUTvFsu8gXWr+9Wl47NqjEKX8Y=", "DB8WyO4CRYTG5SQwONcyS9YxJj5ANunfVCL3jIsByco=", "I2tw97dubxa29NCPbGdVd2u78r7vOO2fGHKUYH+6Pk0=", "L66S2aQmDA62e4tcU1729DkT5QblRrOh8hfsrB6w7l4=", "AeaakmFI0EeF8IdgF226K+HuW06hm9CRNdW2jnVyzRw=", "KpbxFAjyFsWt5ANx+sK9RSpXjsI70iCJeqM3JRO8RTA=", "FSLnP6QcxMI+msam30bcM+aSG4Ar5yzK6wbeRzbP6Yg=", "BtLHh+ezNsBVYpOqimvPfTG+bYttSmRM53sxO+483QE=", "H4AFe+xQSUaj6NXo0xQS0vtkYbXxdJdAF/J5j/9XwwY=", "E55DMIaR2ieJROlekQ/zxJA+L6rHWmUz5/H88NyJhas=", "KVhxViOGi6mP2YKgkqnrGP0PLMnTrUTQOXC4wjYe040=", "A9A3wGiu/K9iv4S0/nWopGpdhdY7ZZJ4sElQj9MdZzw=", "JfhlTEEufWMPBGwTjfxMGDMlc9nyzd4maD+0cvyLLt8=", "AYdLnQeibPL7jGW41HxmRwCLQoBK8efOssfuRmorWAc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "IrdPirasw/PvDZNSqtR58ts/UXFoRzTsbRjGnP4LFM0=", "KN3T4KhO/MYwkDRtXFwLn3priiCr0AHorQEyisX/kLI=", "Iboe4pkOK6mB9ufpfxqoee2m4+Sn8ZK+BV0H0jMqrCY=", "CJI/d1FF9yQwA+tQiRYNLgtL5raOdyEdeW5WewJukts=", "IWjhFY2wdr0sdQPY14dZt0Hz0J6MKGPxu/d+uKUvK9U=", "LZGmBG7mOFhwh/NPjzpFVD5aEugNsUYhIdN/PS9XTKQ=", "GaNis2CScUtQuGI4yjWz6RBu/i8c9KjwkaaHy3E0ShY=", "CTqzoexK1b5iNfuAUxTX6fB61ar7IUzq5+vc+B23L9A=", "Hm8jnxzZo3PkuKKDyGx91xClrrAKNTONq82A4UB5go4=", "D4snLYk/Ioi+VBUafG4+PidLlqOVYWl20me6MdWcC6w=", "Igc8RcuXUxJTioqL7SjAooWHk+HiojTV/Ypuu/gJj60=", "BaLN9GuJkZuTv/GNpEpM9HCg3mub2g7ZfZ7zCFZ4yaI=", "C5G2r3go9eI7BtLshKWswPb2cOZBRr+C26LNCdi5sWA=", "JpGbPuM+RulWgMyMIW1WGZa2WRVBioTXs9e8DSnj5W0=", "FhXWUeRxZ7HunHBzfBN2lyzkdaHGb9d4/1WRsuTpIBc=", "Hba6bhgBKt8vQ0gvIkVB3Ftf/VUi+TNkSfz+1v3t4zk=", "FXrueLo5ITewa9gQSHLsE1WHU3iOBE04ZEJJ3eSbY/Q=", "G+w/lCZTTWHvXOi0Dj2RmdkpopXEsuV2gDP6e6UfYo8=", "HMJhSjvg7vU5BWh7bWZtlXxvR7TzQNWRBvxa3ViLEnI=", "F8xez6S8tNQTi60NtNJbi92SGWlGXOQMN4MZCFXA+bY=", "K3HyGc3F/KXBuoYfO8tRqgj9/sbIYA6ibqP0MwkNnsc=", "IJCYsCkFgyzGJ2f6YON6lixMt+UbI7ZRA4m1bFENOmE=", "IiArQiNaDeI+9DMBBVBm0m2H0KxOv7jUORsF/cqxkLw=", "JwZ6Gpz6Q98fqnkENZzr0Gq8Qe9pTImVStB24pa8d/M=", "Hdouxv0PkqUVtLnwuAqmgmD9ZXD+KMNazY2lIzxlXJ4=", "IPy+VR5ijSnjYlyUjZIFffsWpIa+n9iP/jCLiGp/P1o=", "ECtjtjtllNug2VAoQaqgvfDSqtCNJRNfEJDw7ZTK31w=", "JmXSs7H0cRs2KyjBWBwTmqz2gfGJ0pzM3mCMf0TaxPc=", "JTTgp3C7ABeeb3Yh2W2rNC/5YNNhyRrbD4+upIZpPfA=", "Ey3jlleXlZy/r2GiOcXwnhZy07Y4eh40pTIU6dFcggE=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "G2Rmq2QffzDrLcoD3tuJCAgzsrznuEtqex7v0wZ30tg=", "BpDexID5FMb3es6HpHsIV6x/3ec0Y+SyRF1GVsU2U+4=", "Bl4NZcKj4XhsK7+/RxAuQn6eMdIhgRKobYIUlqMW1os=", "K1sa+BLPt3swuCG9smFMXwmqc+76n2pIvz6xRhSLAQw=", "Jg96gSccv9wnqF8UYiGzD6Eun/uiHWVKNxvKRFWje7Q=", "KitmAqSBwER12s6kGzYK85Js/NRicRKo7UGS8hOoI80=", "EUOThq9eJiId8JBavaNBQs5p9mFRGS0BQ9v93zrqrtg=", "IwUI5jLHFukD4ipExgAsLTmxoO4HK/+c0JAbPEgB5p4=", "I85OGO9HLtTkrrDcpSjxT7cwHGaR1D6WMqZfHsTnvH8=", "I33Y5wqhc77UIdTUiMQyavRWMiYgSD/ho5MGYYenzAg=", "JLCrBU0YDheXF5V1TgJ6dWvB9o7PnNyLkrMLSvLAeNM=", "C6p770yyosvRsz+VAa0i42VSahACc7jvGjkVLXeb3s8=", "H7mzVpw76SXkgP0QKjQyzuzbWdNGSGuZ0iKEFl3wgmI=", "DtNBgXnnEbCi2btE/dD/DIJ0G1MQWBEQMc0SP1CPx6A=", "LpKqYAdXak+BXGRauy6e4Q/nW6peE6sqCwqnAOCE8HE=", "JVf+5xPj7TZdf8fGwH8RNQbUjcy5hRDYRFe21hyaRI8=", "Dq7jcyFJKwWVzEd1hcn+lXPaAK0WGcdAnudsYlwR1Ec=", "G5ydQjBDOhk/MV+rT4y4p/SwlG9iQduy6FjzzsbDP4U=", "A1sdMEU4HVBT0MMp7xFFgxXWkzXNI3H+z+/IohSahYM=", "Kgv2SHWSk+IFti74WGEvTlTPp43PH9qEcVzd4grPSXg=", "AtH3f3uzTHrcqsPoi/NMwy5667guHf7DSR7UOca3HEo=", "BjIY0HaCf7GOj9TBR1VEPcw8v6W+21eoqh7UsaabUmE=", "KAi5F8lBf0fhiTxKWwBTxkoFQxmYjnIbQnE9Srw1ECQ=", "BMGyZWSPEaXtQME1Z1Fw/0hvbbEgBW0rQ+R2vNpOCHY=", "HJYlp4HDUw7PTVMsDxh26CgaRUq9yRTzTexiTa2CdsY=", "DZwu92OWYpKkWFwNe0oSVse0aHuMGa7+Dyxa/bjLEJM=", "EbrLuMgLPK3ce+QVxJ0ZyCB0Z+yjUtLWWzyVDfiZz3g=", "LzjKZN5IfVmwMy8ULAzJ7kCPlH4XvfG6f+IXzVDjsIg=", "CltC99PvMIwAfpGtC4WfRlgsqWuKP8EsaWS0464jC8E=", "DKZXhRXlHCx9qeiY+hVBpuk76ojtUp5cH0ERQYhHQ80=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "CYaVfLGcwQw224hkj+7v/AF7x/NE7KfieDE4h8Uhtm4=", "LfRRw2sXicOypnGYGKYtHUBZfGwogSJdm8yV/W0JD1A=", "K64iOpOwjTEVqUklLZBoh/u7KYjBJ8HiZoxVoA7yJIM=", "Bb6+9SuwhDG7uektIZtKCy/hXi9DRtDoN2ZDaa78GAM=", "GIQr/z/4mI0po3N6/BE/a/uAwI1aLNBkc7rO1AbT4q0=", "AveKj6vS6XcAq0ovK1dz7jSMuy7kkb8zpWccEOYya+Y=", "CLPxvNuhQQOHa39X9g0I7jqvnqJfVJVoCgwRh2EX/rU=", "DlNiISQqAvHHjmxZEz7Rdou3xYBa0aPlkGatI9yK1CI=", "LZBu7rnX7Qn3/FBNtC36eb33TQlOq10p/ZHnC+eLRy4=", "Al/8UNMre63BBmoGJozf4KMplXwQssRIz8of9qtuBFE=", "DnfZmBjV2VsVNmeRcFDoAPd4oHslIODLKo2fOUalm/M=", "JDSwlDyAeXzBOQXtfuNacAphv2AcfD3+IL1/o6YtDdE=", "Ffd9EftPx8FuSmZwYU2FtuuDPwyWye+W3Mhhv74uHI0=", "Lh21+VjO+unoMfTVXWyIOEei658bjqQExhMenP/K6KQ=", "IFlHVEwtXJ0RV7wmaX2OPBlJeG5iEKud7KIJLcVdRJg=", "ubpiGV0p9UBT5frc5OdecyORX7LQR/YVk8DP41HEBg==", "Iz7un150S85NQIssD80FEoUZn16Hb6PG9smaKJ22RUI=", "GBij8NFVLzTKp9xA3vux7WIHK613/1qCIf4bvGVefdo=", "Cow27S9k/xIczszaTXI6/IDhfB7RUNTUr9lhipvlL70=", "K7r/s3VBqfUh7jcINq47bwVV9JsFaQMvhI4V5dBUBU8=", "Lc5ThlrsYWz9gUOq/wXHv7tyikjyuBvGju1in/1lN/Y=", "JqSmPfJtv/mRoP6kudAAlDVN4zrqLwTwQxIlDeryAt0=", "BH2uhntq2kVQ4Y8kQ8RCgVhKmwfpEEqzeQ1l0L/C4Vs=", "GGcpQ/gn4oM6jZ25iClqooHKyIgWsR6izm/F6/+FZu4=", "GXk1P7RtjN87UY/+FFr2pTO56/uZBYL7NvMQhVRlVqQ=", "GzlMC0/xG2ehWR99GQx08VvYOBKrBW17oYaZit+1+9I=", "IhP7/t60b7m6sw1bv4VM0pRaMNERWj4srWt3G/U6nEU=", "MEWmuY/nE0FCfolONRQCNC2lkGf8RLih4yHei3W1OEs=", "HlYLki9BDvvHKrMTevwrS7nW0R49eOvAwe+XC4UQsNs=", "B5Os4uBF1tzn6wxQvGVHhcae6pKl/xKf/iuCJKTmaYc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "UVyUAY7/svwkp7uJsaEFWidMznTNG7T6N1EzHFWoMA==", "IoiElH0tHKrK1ktFOFIUmOajd/H1McAypB6MWZnOf9U=", "Ate7gHw3pdujFJDImWCXVSqTDlUZigyPeHyrSY5K34w=", "FfXLEksKGL3gTbCB32Z+uQ1yL+OEIMemojQN1Xgj1O8=", "L9tvL4OhOMCar2elt/Ty0h+fty3vkkb4NQs9UP3P8JA=", "3Ph1vjw0zzjWK+Vv6Tbh920Q8Byay2V+Tf7AL5jITA==", "AvK/Kda3Y3mA0CZEuYAwKX5O6H1RR2v+AuQwcAmTtOM=", "Eh3WOxhaP7vx4mch4dySB7ps6DJGhWx4Dx/z9FeSXxs=", "IOebz7wUhV9gf/5+/cBAiyNmJB7oDTiPWPyD8RQLT8M=", "FT3DG+TNefvA8XV2EsYxb5lFYNiLoqCTaq2r5x06tP0=", "E4BLEr23fWPvX5gH5g4YlqUhLhzjFKUvHmXNYFFUWuQ=", "C2zs8LAVKEmY/yPCOnwANin47o+OUthe9q8TFH+4uyI=", "Jn+ZL7HF/Xoq3qZMR4lheiBWhsAfl0PinDo2kQkC+D0=", "B8c56BmyMBPGsrug2x+RRXPQvpjad4/N48RKgujbanY=", "AV2mUkFvxEBWIFKY5IN4YKluGsz0KvTdtLbuxC+9MDo=", "HDNzlHHRvU/GE6/h44tx/zVirN4p3Fi/bKv3OhkrNyo=", "Dt+MfbWYI/sfdsxn4OPr+N6N18vmnsRoUVpfVRHIwfU=", "CDNLcuotDTWrPfrE8mlrDZgLZdbg7GH+JyTIlr0/UXo=", "D0MprTfqIqFlF7mx5tOK/cdag5jfm5oyqi+PLDNG4ok=", "H40+Mc3hwrNWTsm4rLbT3Fa5Rv0eo8xgZ/BFFf6Aw1I=", "CUohwEiay1j8EYzeEBPwgQUFjZ6X1qeA7TBwXA5UqDg=", "EztjTRh/Yv0u9tY9runTQnrByeIVdJeGouF8ur2n2rQ=", "GOGwO/h1wA+XwtJL99rKlZNdixdrx2f1ZZN5k3ZY9Zk=", "GCQq0i2mdKJiBvNU2FvgZ2ATf6USzH8wpeOHN4VBWaA=", "KUJotf4r6qDJlojpqeT3zqtqh91Cu5UKJQIiR8eQu2s=", "HxODm2Xtp3h14w6uCCUn2LaKRQlODGMpWnEwt47o3fA=", "K6ofryWQLYmQISTto5hieSeMxgB7H3sPGTcy5VJ/xp4=", "JlzwMxQsbUM9cBoEDY+fNcFUdabH6lh110kn0346aWg=", "HE7d0UEvAjWChr8H3/SrLpDlrfBR/1rcNp6Tw/t4z+Y=", "L7kkIwyQ4mrG03NXpt8hTxPCTHNyWZWHPfN9pW96Pnc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "GeSUhTrzK66gj801jSXDe6p7QuFKdOYnc3Ewg2eUibE=", "JGY+JZN3ldcjq6L0Ezd+RwuEQYBhzL8uerBlRdT2mxU=", "KBlM09qiDKauA6jcEswwyrAD8qG3hMm2RDaphIYq1Bo=", "AwBNlGlBTwp3LJn4lufyfI0Iq/DcfjD+uRtRgg5Fkfw=", "SpATiuY69tgxESwE3Oh5+UMwLzekYvDIS09LVDc3og==", "FjKP6LydPIg6zN0Jzyhh/zPwcrxYz+WAEThkkTpYILQ=", "JVNCuzdgFI3ASGF4gnaKTRmCMNpTtN34flF4/0gy8wE=", "CklCQPKdyJqY7H/Q+KcMPoL8EtKJTZKzbF5HK1HOwME=", "Jtl2S2XLZ3WJkWTluxea6vyqfCYoYb9YLF1kGfhpRto=", "DcZKzFGELyJaQ5tlDl6zJm0quA56xwXMrWRncKM46nc=", "BC0SLDlBZnmLlG8D2ps+Bv1bof27pJ08/J7OgkRCYEQ=", "IHFbkTXhX9A5pyj+NH1oJefLrcoMeS4nVZIQA7fPnO4=", "C4Rlr0/8cl4NnVAHnBbxpafY3x/HBncoU1sQ4ZzHDjI=", "Gz/jL9r0pMm1GGYE+0dGaVVhcgwaeIZ1FjWypBa0438=", "GuL9rHt9CzxHOd2esnN3s7rRJII5QOEtC8sRd8luB4g=", "HmuPlV7VbRRNFlDyULsPio2itjHTjXXmvKNKaH65al4=", "Ji3FNPaCyPh02HffFKz47X3GWm5CGYVw0V9JUgdFxwg=", "D5pPAnHVxqoCxCBTqNKx/YF5o1yt1PFimcwAN7CxbWw=", "BvB4xxeIrM5/SPzXJx2FB3xQ/6eoL/Z9gaEN2vcNkwE=", "JBbXTja0LdVRm9OgOTW1cSCzPAUmWkDMFfoLNuaVGF0=", "Ge++lkrdlLYBCc+OZ5W4r7MezgIb0emeBqObhoul2hg=", "IXgl3LD7Si3r0IVmedXxOLwoCDsFg7zdL+3YIm1x6iA=", "Ke2eG4oefQxdxOUepfJ3YUlwaTtldYZzYlprgeDqYwU=", "COcTm89eNdjCgmI0oAxWaWQAz/KwEqlKbt3T0eqU5L8=", "AjtFy0VmBBdI7UCfMqrzt9WeyF+K11vfAIpzPVAKJPc=", "BZ4anMQgjo9K3BfpWo3QoOCCSqRnGiQHURbvHNKasoA=", "AQhLanvcwpR4Nbt/AXxfpKAY2uehTbI8H0ToIaZUNOM=", "Cuku0RVHWQJgbX8+aZ2VZZrLFSEIxYajCpEnUO0YsNI=", "EVQLqFjTaIUrdb1ePTHiiaGC8waO1sJlTtTJLp1KmhI=", "IZrZ4IdhjRXq43gMOy+7vLaGZ7vtudUUkKBOSimGtzQ=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "GvQFvUlhId6L9o2xgsUvjc2GPl6dDQfDMnAsZS8QMVU=", "D7WttPLd7ix4a71jDhC2ryFWbhOIcmTSYn6WW4p2V8A=", "BXNdCiCYHDRDwmMhzmqusihnCH+0gvP8UlZCMf4fv6E=", "DV8l6nzQbJWRXKvBH2GipkC1EJdxI4tTUmZzvzU9jvo=", "J22dGbUMwWCHCAahYirPfPHfelwK/uwt13oJYqzxTLE=", "LVLadkKevvQjSpSiz2pBr9RxGTiItv32aIhaDFeNPAM=", "JPhKtNGsx8wbT4QuUChlomWRRHuL8kQ5eC4X4DK29TU=", "IQafP+sYptICVQEnDAcLG65gNcqqULxotrQCqQncomI=", "AUMN1qxZjeq5Qy5SJ/9fqdpJlPCOoop4H5/a5jCu90Y=", "BvwPVuqYZ9zBA4Uhd3G658GQHetZ2J1pShT9rQfvdFY=", "KuleOfUceTWlLzHR6SwvoeKipD7P/zhJNooia98QZ8w=", "K1PZq+iUxH25ougd3B6gz+6lyiV+jArmHUydtdipGPI=", "GN0JJeQ/gh+3w8mnLl1AnBPlxC81sSaOmzZoWrbGCoQ=", "D/dLbZao0Au5dQgoDpjBCh7/g0tGsV9HS59P5QF0Izo=", "GL+jgpcPNZgGHzDFwYs+cRBaUUXKPm3SH3eTlYcuNhY=", "He6fAPK3VI/6nMWjntrOY8RhxSinu6ihf1m3324ke5k=", "EsWBDplGSX4bb5KBgthRGFFoPs8jTemcZJvLPbuPHnY=", "DllTiB5y/zmOTDS1DD1m/Qc/55Bz9+vVk/79zHvE/jI=", "DSUGHSUo3VNR5Og2fJb+V0RkKZVllLL3Ung/BiUeHds=", "DNAhJLYnQUMfS6pk/Yp1nbH+hkZbNvJufpGtoaNw4DE=", "LVJOLAoWfRY75oY/s0VTnaOo/Os9tJa3Zeov18T+368=", "CfbvP9m4603Vz2OT9oHbVE5zOfahKfm/jjgAQeCkPNI=", "KL8riNOSupgj4tsJ0SzaWhA7bi9YGpo6u4ziXF2TR2w=", "IJ4Iy99VYrBRMApk88un11wl5QMqLNUzHmzDhts4w3M=", "DhjoDt2GeS3dks7kMu4zsV/FECzeCs6fj3yfoGY9UcU=", "J72HlSkrxotqjg/0Uc7zn5L3ry1AfBz89gKXEAqcSEE=", "CH0kJ6Nton5SW7GVYBW7LggRwDegzCcvIwzE8Yp1ahM=", "BeAX+Muj1Br/cP1CHt3WP0ZCVNZcCG5/XweYF5D//9k=", "Lqy5Wa5UKdIZxmtyL+6gCQYKCT0z3wzfIlVToN/I58g=", "J6jAfqdAVZksZuAAPAOwfAkNMNRblA0wPlEhKpdPBbE=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "JbcuOJRtjBRu41Y2eYHnTQAYA0MNSuAj0IqcaM6P1Y8=", "KdPX/or0WPj0RPxJxMuz/elw1u3469e9PQZ9RZlAde0=", "DcJaxvUt/GE9rgGXMiqYx3AM8E3Z0WJ8kAdr8jhLMtE=", "CvccC9FUKXMAe/8Q36yU7hj12pIh09b74EB4lx47gMA=", "FAbYz5eCe30lznHmLRfv+AxJO7Dh8qa5UXI0Md3hfBg=", "Chd9dTMvKq0gnJ7vgASHmv1qzVzlbbEW+DQFOrUSls0=", "HkL+6mD31Jh5ON1YvJtT1LWuT47hSyrVjXI8fIbBMNI=", "LFkh+kzNdn/SUz8wjRwYxjz9w/fY4Qshf8y+7irKDsc=", "CsTj2AOmxgK6b8NzwxmIwpRklHgTTUYnctu5HkDFZZU=", "aPsfCUVxrOcjtZ0aBZXNvSYx2TgGpfXHWM6YYons0A==", "9aRyZhr/2HMM78aY1miPvKO6B7EmN7648HIvL16MjQ==", "LtWvmY5J89nJKlutrk60OlFrGthAzAHRHIpEF4YxbGA=", "CZKaYIpSVlddfCh9uCqs31OBgwueGLI+vfoq3PtG29k=", "JmOeUgcQ6ZjtQPsTacfLA5vb4OLld4BVByyKVGb/m68=", "KzIlw1qI91fUx3M2O4JRkd9RsOHNQIJUHTgq/197Pzs=", "AcGjaMwCP5rucOPlM0GgboCVAixUE/8d5ChjY7ThuZs=", "GzkEmm9wiClCAtpl1luxkNRHRfuT9Ac6ANRz04/Dc5I=", "K5ZryKiX12wE+UPFp671UfPGBA0Fhu6+H0mJoCSK158=", "BnoghRQ66aJFvGa9M3TuqUYTX1ZcwO/bY1ijzN5bbGo=", "J8Pq09dgObEPO/4T8y3ygj+4yhRtmqaxTYzqGCqna7w=", "ATro5mvaX0CtPODoMwUXbV5zsD8pUNXdeLEIdlFEb2A=", "Jn5VrTSoeISXmYt5GThGwoIqJm6PYHmZeOZv++JwGLI=", "GpZMXEVQwpUWFxqKh2b6pxWaE3aoNtKYCdXpAaWEpoY=", "IWzOnltgYs0GOuk+U+/a5kz1R5rgHXVJ+Mx+Z6YA0YQ=", "F1EJ3Qi03kQbpYlgdwZ2n8UG/e3c9WrVfQ7ACPw4FsQ=", "IC7UasDmiCf/urB2Fnzuy8epYUI0/WYhxu7rcoPkOdA=", "AtJl5J813Ii2OrrTLRQwLTVVwiGujv8dM5mmaVnuh+Y=", "BZP4SlXJ468YXm6OaJmBqfvhq2KC85O/SsK3e+IdkdY=", "L8RCcpXVdaj6kxAaG5FuEj8mUufp6Uw2TEq64KQkM08=", "D9JqWpfDy9vsND5hbA2T8l18XrgndIEU5NphwBfiVHg=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Fj4DlYeui+0kIQP5csWNezVwhG86ntO29lypk14FmeY=", "F7jJNHVAoM9GlV/kDCn+NmgJaaB0604bfEDODFQ99P8=", "KJOfI9Y9Ca29HdGW39c+tl/+L7oHp54gSahFPHyt7VU=", "IvQkahAWc6PVjOlTo3QL+AfyX+0Izr8cEkVlMQsQyqE=", "EzXG9QVJsiAj0qlzgHxRDYwbfiKOhinDW36jpwHtAnc=", "BcyIoqsD+fcg2EFYPMg4cxNQPoBL6V0zEaZNDMPM6cY=", "IADUcVdG+jbYq/IoYXGbI6rs/NrcvnHVZ7G+zndgGQQ=", "A8LAB2UgFyn+9Msa6M7zJqfeTz/VgDUh5xUlf4s5LoA=", "DFr/xh1RAB17DYqqb5nUTMaDr4BuoeodJBzlbzhrVGI=", "FTpDGYGtcSrhO3UweX5bKrd8ElvPUwiArIVmrTpaxBc=", "DSBHCB2aj/93c9gBG7wLYaYFf6b5oWJ6PPMh/dZm6No=", "Lq3vH9ARFiE437DgIAaDo7wn4a0S2/srlLMiAxhuWRo=", "IaBdBDQAD7BYhhEiQpWNdLrlTtK2837OALApMyLlMlM=", "GXMsj4NhcLpAOg03lWG8Wqbq7PIcT7n8Js1Eveukdeo=", "D/MFMun3MFyUwpiEjPDVTboBNBp52k2w8ql1wuQ4A3I=", "Aq/o0+oGQFyPzatQ1tblW2+qZ2zTbmrLh7ODZYGwa0Y=", "L9Io1uTBoayur8RZfWn6MOVigtjxHUy9CcNg3M9Ub4A=", "DCA6DqJbf5tAZtrMspKNz7TRzAzS0UZx+rWnkoYDyA==", "F+yyYFb2cIz6OutidMM1LWuuQC5NJBRSbkwqK8m44LA=", "K1dFsnpbpxx6/l0b+VXFeNHOPJFfTTCXTyJfb3utfI0=", "Gm62xItSnGoKFm5T+jmfto6LQUhpsT6nE8GgyrhIDCM=", "Csida3Qa7mwYBAjWAG8TDtlFGF7pohPf48i6pJMw7jY=", "CG7KOOZM3y4lITTXkWDUN9klNzJMqyXNhpjF6S6UYy8=", "K74rwEZ8ek2dG/IVfNXMPuUPEBZqDUQscG2Wke5guLA=", "IsTD0nUV8wDYeei7hbBEc0HLeoFtb9pRbNzzE4aZjXU=", "Aj4xJZ6P3GmiOmA7TltHqQOQlmqvux9OrwL3gyGazRs=", "IMDA+JnSRAG/cITW0L4xTbs+wmf4ei6NN2mh9ktGmoE=", "LaukcXVVilkwSQyt/x896vEAWJ9nZkmjovsdvZvP08A=", "HnWbdmqjENx6uiJFYI7Kr0+5D1Cc2raUFVtH52ivNBc=", "ATWq/rWyMOAwJz5CunBNpDCF0O+WQI6oMj576LVGZDw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "LKLnCj2BRfYBYJhEUrJiIPMD6va/U5yAVf4qsDemSIM=", "CyWIHt5gFRN835m1OoWRqm4MBCpajGqeb7zRGjcCPPM=", "JYsZ0brJ5Tw8XMTFnIdUOw6bM6XmMf3aVimJl6V4Gno=", "DW5xd8qHqjMmyUIDaYA1g9Gh2Nlq3GrMM6PljN01h9k=", "I8vs9tn9e9xMQmA1kIve75yceoAWZ/8rYujq0oK7yrE=", "KEHiypfrfeNzP4ptMpnGA46LF/nRM+0S77TcbZI9gE8=", "K/Ioq5t0kPSwzgHL8xvtLuSm3cbVoApgjvHH68taIDo=", "Iusf3nocF18MFS1ff4UEWWHSsBOX2yTZ3pX/BQdifw4=", "EAkyVywSoL0fLujGsK8xfcUZHDvCoXfu55HW5Tnlsjc=", "J+iBVXtOwPESjvAGnCKm5c5P5I97ydl4nEjWlIvCTIU=", "JYYoU/0bRMaqJqQUq08pWqrg/kRX4PoMS8Xcn8KXIkY=", "A5R8erfXFPH41FA4KeLtzQa6qLqH1bhjVL1yVLhB7WQ=", "Jna1BqdWQ2Ceaw3YmGuIZakwAPw47rH2zzsCbWGR7Uc=", "H0XKg5W0how7aLEZEfUkJSAvzSEIqroCIw3dyns2VG4=", "G1/onlT1CLUYjISHMCg00ICVsUweCTiqgvk2XKOytE4=", "JYJvmuOQToD33tF7lUyJiaBKBgMmykA3HfogTgKwXrQ=", "K1Mk5CvsRTKGMmIsgmRL3pQeAVlG0tkhndC4BdurXCY=", "JeARyrgJIIyUR8512/bJD3bG1QZAgpuGHCOSJxpR7pE=", "BY/+z/YICZAG/Vn/fXXwOlKGE7NjPR3eP8tdbyOaZIw=", "JvBS2uqrdvLKjhhYS4WGrpqPWRqLl6Zz2C1QvpQ6oA8=", "FdMFvG4xOMQJklyvOWg2eFDG7tA4TkYAnTi65d+B/Mk=", "FvDD3puKdv8YNwzEidpGqb2WJ0L8uwoKsK7p0Sw8X7I=", "E3pPxeY9pKNmtu3UHiVfxLqnO6lmKrfStp4LfUmGtWI=", "AlpZ07RvXIt6djUYeX+vVcxHc5Z8F3KwHHwj8YanUXg=", "E98dYYFP2i4NJsqGGtv+m2qSwFvDr8lTz+AI0Xa+LDA=", "FbY/5YQ8Zhy0DdQv62ZNutuyeGbhGaKPntjTW1N4cLA=", "IzUqOjuujC40NZ11vMml2HC2lVXd9XlIyq8HRTgESoA=", "LSI8Utb7yw6C6f72ub1zhKK3icTZwnPrs1tO/o5R518=", "HyCPFMUbSMd3b66gGHi85lBxguoHFQVYFlgXMhdJKGM=", "GUmEoaUQbdyxvOEpmxsEPtrya4XEr9gMtnhcxcg7NG8=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "KL3wZS1JZKbp6i+qbOLYIyUzZNMRdiV4ch+Hc2qq2AM=", "EYMiTqgqaNtf32ohBSR3yMj/UA6XuM7cCUJ8vALVfm8=", "DGHSLJEr74UHxrCMvTb3y3l587VrNlSWE3lFFetOAtk=", "LujH+GhN7bscF3+p8ldKIMxP88EFYod7z7DVPJBkm3c=", "D1YZOZmBag9LFeOJdCc7XFhjQiuT2p6U9HxfEDUdRwU=", "kLcOyvuledN9bSETWFI+2ZLibVp3UlmLu2i2N6WSlQ==", "LelyZq8EaNxaWHIx8bHjqizdTR1yCCBb6QgmSR8mN1I=", "GYVT//iqRq3Jrzs41sAcwA8aZZTtDhqLjzcJZfiolmk=", "GSszAO8ldLSnBTwk19veqBwE2m88gDJp7oXCLBEHgrA=", "H0x6dtow/Q5gTRSDPQzq4l6q38+TfUulpr11B7cPzvM=", "ERlLRuqRdB92FmLVa2TJ0SfyvzYUL2gbylea8uiFbMY=", "EyM8uggrsVeUKL1KGYR670xQMZVoBfbiUi4A3JqSoIc=", "BvxUyaJ8q8oL111Tzv4pkr9LdE7h8eDPfCVEkuWEiG4=", "AUhwZF816Fkh9XmkfQE8+IEiAaEzvRS29WBPd8ELqLo=", "JGNE8czuTasOBAm8lvu2GJN+a8Yp2bG7g6ZpBV7p4hA=", "Hhxyxz2URNa8RqeDTGZCbOS7kURugEkJFT5r+GUR5ig=", "BmLFFJI+QQOM/QeP7kvb5yyPbpDlo8+lEIKhpPdSN1Q=", "JcfgasJQM084vWZNsLunhtVOnUDnwQS5WYkjK6B3bbA=", "HGN3S7aqcsNmcSyGeS2FZo+DO3rzXrkfNhdt43X7JSI=", "Du83LpFfMmPzHiw8TSFLTJrqhv2oE92+HLFUQYga3gU=", "KdsSRIxutzQirM71oqN5TH83LCg/N7KxlMvPCbI7SA4=", "Fhty2DT90mlXEYazhHCE0lH0dlpbn/r3f+cgMZ4Nx8E=", "JDQzITjJOmn+sGUhrw7zLAi2gLtQ62E5jjd0R97UYcI=", "FAhn+mHKo9zqEL6bRrdocdmD6KeVLj0fcaqy9TGoVxQ=", "Hjh35Y1/JamI9zfyKWUM3TRcMIo3xmNmaDdx+eJJrNA=", "LgD4CqW6BUVgBwo/IcC9N+MRzoBgp8wcZGUFYMlxUIg=", "CWc+oj26U3pKD23WahPfhdiIfcNDFmaoZzC+zXLwT8Q=", "KgWxDR+vaKt+YHOI98mz3lS8FR8LLaAnAuRx61t4alA=", "Lo+4vQCvZ0H+GO5nnuN46GAs6LvEKcqZhtAW4Xsvsi4=", "I88/BCpWx9LalHclIaIa5ryz/QQz+HeMv2j+HDZcjAg=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "DU0pW9a8tnFt2CkH2JuICaivaYWXKHc2ieBzvaQccJs=", "FPjfOKqVktWVGQVNjwrCx5tqEwOQWpdwcxo6cIGyvNo=", "J8qVM+KlamRNNcU/qctmGHp8DvcyIWiTLDMHJO2/vQ8=", "Gs6lKC3jXTUzdQPIyKIh/iK8JNORZIUO+pp6zfE3fwc=", "Dd4TX2nV7nJT0c//34eLPqdcosVrFZBzKRR5afsSDUY=", "CFZctWUUDULTPVuQeg4j9699r5HqWv91n9jKkWV5ziU=", "GTQ6UoUFtrMD7Rk+M4EKAFq+c4BXywDzTJozKcqAiw==", "Cc1H/IrEaz5J1zfrRxTVIs4jXBsP7/raCFLYFz1LCAo=", "K4fQdef6sphJKRp3AOroMXywFnajbA0sE4JXuFJzKi8=", "EGaU4WDbNbLTWZjk670XacacRIr9HOaqqOG8HOU9v0w=", "Fj2RpXAipHNOoXqwH7hdlGIqz/ZYLc9+S0bdCl1y2CM=", "K4y75m7R4dnFoTYe8KgFmd51Vzxi1uOqcYuiM+JZRAg=", "MF5MSpPZMfkn8KITzr4aWjsljscm/JEspZWQ/r2bYCA=", "JtDDSSBjlZzYw9wOXHkTVrGbm8bjm02hOk0qYS5WNW4=", "IHbKICbQS5j4Ibm9UtZPqxKVJvwuYm+vzJLQ0uI6M70=", "DYnESD5AxBXSZtPH8v9tHWZBITJ3C+cbzxF4hJUC0jE=", "E2cd3y9J6XQQ9B6tDhqAVk2GJ3HHVDZkvSB2IyT6/bw=", "GWlOQB0r1rbKTYkpEpqFyeiDTkD9H2CJ2pvWn2b4QKE=", "GoAcV0J5FkyTfzeYdIvxFfCfVgREYXcc39Z8lgbxoXA=", "BzWedmFVD0rxv9diDO2rKwMPuWRbBpRajBZqYXQj5Yg=", "DcMc4XjmD43RcQAuLlhJdZ2crvx9x6H8VRtne0EMQnQ=", "A7fVGyuLM5CSOyjQ8eGByDeL/QkQ8Dg1oe3OPe1Y/6M=", "IP6sp0AD91DH1Resp/LBgXRafSakcFHacgn9Gzumeu0=", "B8canYTcjZstIjszAuGAT21s3mcC6+mRxcl2pKqwlxo=", "H/LnpwRektlV0LOmeesRaKr3NafP/sXpD9Dkf8lG7js=", "HMrUrROr/ljQpp6pZ+lHfyBjDZKNyTlwAzeWyoBJ7dI=", "HSJ3pMisPnrpRfBUYdenLK7ttFbzDB4SkRyOPcw6ZrI=", "LsLSjc1+deEAwT71cunicNJRp3T0S3xZ33Z8pQ/hBDQ=", "LqRHwC4FmXDrktH9FLHssYndkAsoHmfWiz50JSPGqAE=", "K0rexe4BSzBf20YM2xrjB5YgLsD+EdE8I9/WVwPwQ08=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "F4S9F8sJZYeFSfxLDhtAvqN2aPlNjaiQyqe9J9Issv0=", "FJ8dl4c2a4Sz/EDtQw6WtkbrFpAQk1kOe2i6NgHDZO8=", "DhFh8TuR6oQy4S3zq1hwZBDaXmoQrSCx9i0cNMCc36k=", "B+bZlkMeIXtgvE0+dKo8M3Jj8Rg8ksxzgH0Z5ZxOaAQ=", "IIaDSyoD2yLHHnHcvIloiqAsw2JJbkmSvphF9X6L7p8=", "Glk4ZNByeD/m4e+KyDZlqq3Vk7Y7PdPUkZI3v1sscQY=", "AVcOyDP+jyHsSFOcauJzw0yuO/7grMVXjJbN6StJNoA=", "E7Yqk9sztvDpEU0/LxnAg7OXoZP27w9bCH8gecJYGps=", "Kri9JN2WPuRm4uDDOAzIik+COXz599raLYCtXqIduHU=", "DO3qCCoXvLpyW8ljPS5eZ/zUNlDiKyLfmqwwN9ru+OQ=", "Bd8g2JW+sjdLXtbYHtVJSmrg6cO8GE14Yb/75yQ7YWo=", "GrUp2wAUPXA4puAeI9Dp1Wzom9NAAnJwYcjlaUTkAD8=", "JUjFYsqy3lQFIMBQOT+UnhC7jZ7Uw/w4fiHkVPGsg8w=", "KQQtNcyXlVqA6wnxWhW2bwxBk6WBk6CAZitqXnnmgFE=", "BoW5a8Ho1wsae3Aha1x0pOXbMV3Db6pZ6qOfLgSUrAg=", "Ldu8Zv5p3RiKLpwwbPb33p+qEGdWGGuC8/tEDdC5EqY=", "GMcCYOUqZ6tBeu6mC10/iOruolCIKa5+o8BjRDzAlFs=", "D9QjhF+fmXBWHjP7D5E4IeHjGA29RYFakjitUVVDpjQ=", "BnFeh/Hap3PKtpV8EWBbDG/y7pNwVzc9r9wvKE2Vsak=", "IK8ytjvS5qpK220PR0zNEFt4otuyad+/zWFdTM2gZmo=", "CkMziZ43xBHLYzJR6pjYhY3ZRPc8Q3i2b9+lkE742cI=", "CSsFcYXmL7EbIrXzWD0ZQ9Vh+CfFSTbPINcQa5QW890=", "HtpRINX99fLPyeMDpFpKyHEL3HqcKLXoAeskj2CuCPY=", "EoKot5zFA57ciFLsG71YNfO4AEzLyaZp+IozHpZts9E=", "IzXgvGCIO1mxOQ0rNlLtC+8jAyTn/atyWl1HQ9X/+MI=", "LiPk2TpLcq0FUbdAh5/7DaTuZb3Bq3H4IH0tnaDybQE=", "Gwb+5//KQZYY07tkaiAzFoOKaE58h4AkvAWGRfrQHlU=", "Bm3bO61KSxN0/tazqIsb3IEt35pr6hsChzXc+Qp3vbw=", "KAtxrtu9N2EST+b61xnGkwzg72aVk4zOd3q3fqNTZjc=", "IdEw+iWPbh/iAQcbPQ9kODL0qtB6Opg+oAwmiQtUbls=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "MF9zN9/CxlkeWz1TpHg1VeHqke/ERkhSlEj6PkYzM+s=", "HWnhflZ4rFOhwEbtAyZmbIS5CbheWqnjTlFtJqtlVXM=", "H10L9anEWKPJybvj/kghGhEnoXbU9UVHqvNFib+RKMI=", "I4W60zKuljtgrnOGLPhsX3I9/TflawWRg3ORLY+XVK0=", "DWjb6HTSBvRe/Yckrf2bEJmafaEibDlMTnlZJpoXp5w=", "J/i/+YIrp2tDtUk5aGyu83ysaF1g79O7h7RogItIDB4=", "Dyy/L+0im4G/kcCKZCcwyWMxNtzx5okHwZLjRGRWCyQ=", "J+Z4NFHNYeIp8GLjjjYNnQIswkQiL/ISjUkB3gxbPBs=", "Cwv4UslfJHarUoC5RmCx2dLPVDnDTXtqko1ZaxNVXzI=", "K1Q8fh0vhPrEcEiURt+HbH9klW2CyIl+JozE4q8TCiw=", "BDZ6KFHpuE7OcXLtEm98+2PV+0ReoZ71oxpnUXr9L84=", "Hciiq/zkNwIf7VLoOx5nCKIOB9hCBuTGA4u5/zazJaA=", "shcUHTXCqt67rY2aQmtS3yPX23w8cvCRSWMEbhINWw==", "EGgsNQXOx3umX0r2iWPzMQViUnsr8cgSwEou/5TTM3Y=", "Lz+mHPRpZiKrwCvWZL5ijaj/X5tJ2T22WvEqDsDSVZM=", "A3mMiNp8HHAyL3KIj2/Xg1ha0nn0zAYCnzuyPzwy/To=", "FUs/L4hePWH6XCeHX8mwNQm582oYmBsT4a/00pt9I68=", "BF48qs/wbuOR9GrkPPeKK6HiE03gQFEgIoy60GlNL90=", "IaRDJozx2woe3D98Nm3my8aQ4ZOWWCeN6WeYFKWtSjA=", "D6V0OCUgsBcKwh0ADZq10lI7X4Z1gibUm6uW/BrZxZs=", "G48HImRzwo/Dz3j/4vX7OWe2vu7UKGaBTGSPXUrfX7Y=", "DcSEg959DfgyMuWkHMKHYYt5V60vo9sDVWQpKG7Wotg=", "IyfT2syPgPoF0HW3+bhUQ1bAT05gD1PY1NLQ8UdZDu8=", "FqYma9btQpJyxpqsV5yQMtm+foaXO1ePJ9XLjS9gRdo=", "CetOZihap8u2IhdGV2gTjXOVO69+tovK0Vt0lBklXiU=", "FfOmsnyKLOJ+kxy1maC7r2BCzG+NQR0trxlpwCxn9eE=", "JyfJI21DtBo0x0xSQgZ02q36/HbrMTsX/K4Od8yue/o=", "FJvQDrHaOeIqsNjceNer/1S9nBO6OKalMfaWzJk6P5Y=", "E+vPBqXJSF4XZ6Ekw+A1Ij6sa+WBYEH6B31cxvzRAig=", "Iq7H+Ic8dXAuDFXBsVKbEpCDHLTfc8OuZEHaZ8IegWk=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HUX5+hEwf23ojiIOYzUZo/8Y2d2AcaObOO4p1ZEPrEc=", "IV/z6HXXCtS3qgiACuv0f4P90FokYYao7An2dO9aoWA=", "FVLeJqzxla9kP6JiXL0+FyMoTCz9Bb+8I0laDPiKo2k=", "H5g2oeq+5JstLmyx8fZmdTgT9SATI9MC+q4SjwjkUWg=", "H4z1ELzViy/iWPP4Etq/CKMBpx7XENRkfNYP31vrd5s=", "LERvZF62YRUt5Ehlo6wUm8IKdkR2FglIhMm2UV7UVnQ=", "BQo3GOSGQMtkS7eH/BhKph9ORARNwPPzAGzrqBuNyq4=", "CzcLcfmNwQcGcSx/NIR0/v5d13L2eG/pbM6UmZywn7c=", "KHRzk5tcR1aGErFQzbJbMICMBYtLWjYzwDr4P3p+JvI=", "H17HWY9tpXeCasWvzW7DchuWNWKZkSXZ01bqxR0NUTw=", "qYUAWPdPMZb1hYXm/IDOBAXcUQ6onjPrGpyH/5Hliw==", "AiIn1Z0f/DKK7i/5VvRcO2rb63glOICe27ah5w8mKiM=", "Cse4acr05xWF+fVn6Use5uDYAu1q9J0wsk1BsceE5Eg=", "BtZx6h/IvNDYJOEBw3MkJd5aRDX64bz9HIX1AcogXUM=", "Bs/0wpGNTOdPTr3obllRrRQ7CalR0TZhjKzJy0DdV5k=", "LZ8O5O1R6Xmg8aWCB36OX2Zp+J15Ilp9omh0RhhDR6o=", "Etxq0ODa8odo6FsCYXkwAxL+smWEsqS1D4MEmeFPXgY=", "L5TfayEdiopRT6z5MdcaPyPj2ailGhHSnAIh/Jhz11Y=", "Ap7nQSh/VFoZzQKvdg1WKGwnq11BIsAB/Cl9Q9sr0DA=", "fUO6UlxEqJTWS1AKyjto8uPCV3knOQ9gGB7TbA32jw==", "JShmYzR3s6qg+f2nMbTfoNeJBas5wXeuH0922l2eVUc=", "IwjsDbc0N/gyANuPkUczQx6+UUnmHPOv4+ZzBMj6jUQ=", "BRfk7iiJktmeWVFekcW+aVfoObi6jJx0MP0x6sRMVqI=", "KrFdiIdhXATiLx6Yi52EUM3cLPrytYK9sAYgSlDlls8=", "EW4zpxN0itkwBDka2wfVymSWLIryqINeUOt+G2ZipVc=", "BoFQ4SSOeuRO9WGRJ+jMKGFtcncJGvtMIJ3dUEkj9Q8=", "Hp49KWRZTdW8h6k+S7Z+atcbA3BJ+QSTFllU/NhqHk4=", "F1Hy6Zz4z2Q6Xsazy8gd71qoZ5l3y9J3nzT0dvlJaRE=", "JI7ykhvflox0263K4NtWywIsqYuYNijXEQxyTNrgSNY=", "L7bRvVfaHMNhCyAVNb1Cos1AXstSsowhUjdYElc1Q1I=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "DOQO9NN65YAIpNGwLniqT+xWPohAzCj9GvYRRJhoZv0=", "H5Sv7I+mL1PkuyD3VqCCNuQOmKNGr+qFx4KA8Ooz4zc=", "DyFkNSAhqqZBpxdsp2Z0pGWztyjYrxLHsqX5M51vXkc=", "G4bJp8uCh1ILOUOYc5fox6dC8wWf4SvqZkmJrgjQDls=", "EeTbUigXfzC7Ki+WCY6qfqlBIpGAvtGGmg0L4EzGCw4=", "BjeLzvLOkb8kNltRoJcAKN2inr19owVKhEAgfBXtqEQ=", "GS7wlJ67MiQkeoPHTro25HJS9N2MPyDu2qOUhOp4ymU=", "IcHK559fqCg9eowqyymk9Gp2uLP31R/ZOUG98y04/tg=", "D8Jg2uofRw/rzeuEzFjwOxEA/+I6tS6Ip4MsGLGxMhM=", "H297wHWJkW6+P+5QJWcq2a+aOreY/QHGwiKOzKIMOV4=", "GX4gWSPsEdr+62l7h62XO6SoXZ2dOBfDZMNgn/eMGNw=", "KTXDk6iEokSwiqMUstJhyZmVnUFdAIV82IMnfUOfwAo=", "LGOaxUSnUIjseu4BqFRHH3tlONg/wcdUHZAYwKh7GRY=", "JbLJwvQTdi6EPBDlRs7QVy4aMNGpssXHgdJN6GTvSXM=", "HShzXNbaCI/3L+jNTq24vCgmjhWp11Sl7t5T01E+Axc=", "IFwwm0HmyL8v6kZxpQKrzrvwqjPIBzaa25hpwNCxZhs=", "Lo6Nv4+as74k+06LlcIYgQOjhM28wrZfxbkxpzBBbg4=", "IOEpEXVVG+gPcPps5uERrVQD0XZcS/R/YRED/aZLCY4=", "C6kSDeDLKJ24qVG100iFOoOa80UpyXIpZwPbXCFwVN0=", "KJjDjyfGQxHZA0bfqvNVT/axBOVhJLNa98syJAImRiA=", "KG43YugVrf4c4Y5Zko4EvrQ9vcbU0etStXQTJto8aI4=", "LTFklcHJKoq1/EVt2Oex6pf1y3DpBiTRrz5LvBjLde8=", "DeuFbiuwyhG/GX3j2+jozF26rJmNzCdcq5Gs968/80c=", "JHuH4OppCvq7G+7M/8fBL7IPMUhNaEuXMC7mf1iNHu0=", "IAOv4P4pzudkG39BoxyKL8J73WGfhaj+U6RTaITWhPk=", "JdnC4tZgUsfVzz1WyIZdk5y6GOC/rHJdwE9GiDcRIlM=", "AacRuho+7OZZXE7k3uSrPoZd135rWHl8Nnfh9JTRMUQ=", "B8dPZv8ZmFbwd/KbBqzAMwW7A9ehvq4EXhmblZasmjE=", "Gk1RNQbGrmbQ4aB3uelgStQ1mmy6dzjZch2wuoJv5wQ=", "Fy+Ctcqn9l64BErj+u/oHYN+U7jmFcLUbtAuQDYULs8=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HIGmTF1YEZH0CnCXiKT9YHxx5GHeKtFmubzKdC4Knbg=", "BlKElgvwnqsnczJOrQSMO+xUr3zrpQgF41MqWhG5a5Q=", "I09jW5IfnXoFbA/mOvRq+4ubVDDYGQW/sW7wUTaf7ns=", "FIgZlXfFACFNjZxL9tZNsIEdXmm0TzuGpYXZQQ+HW+U=", "IjehOIvYlikhzGN9ikxdD6prX7E41YnbmKUIvfnCJfY=", "G4m9vp6atA8qwgeT9BgqfzOtk+kHME+wRA0efUAGPtQ=", "IL/mEJLy5csFCKc8od2JgxJ6OV9oAMy+xO1WqpWtjH8=", "BazQx2Ec+pFwiW12Bqj1xnKIPOtCwrgpwpyNrgjfLsQ=", "Ljoi/TRJHxUwlMk7zxeo5FlA5KEZH80tF0HvhBaB4Kg=", "JlBLLVsHnErub1iPgluLKMM3E36awflF9xW4W1za6Xk=", "IB+9T0ycrCSyPYu/hu/hXYar6PGIOLtUKXX6EOnyqJU=", "CxPcav2ahWapDLUMgvGHb62E/9CSJBwCi57kcM1ky70=", "nAhT+uIHDE6oFqVNrs70OllAxkcim+D9hp7zbyMVng==", "GpJsrAO05vQb8CFGDLEpy0sgJTs8FypvK1MdV9en1kU=", "IzTAtWAV9sWpCDGTsX0iXqLZd5MlIfXX4yjD8Lqvelo=", "LL9zkFtUie07DFdj7uBP7WWUQRoTgdC9YXogip440gg=", "HgbE0eLt1VMPImZJhx+PyDuee1cI11vfa5oxuWO+e/s=", "JgwuXlNkvZFMy/t4XQGriYoqlh2vcI9fPjS/+VOySwA=", "JmifclnhBhFWlHsTbA29XowsGXK0gj9NzwTfM+lVMs0=", "KR3w5itWPaZw1E21jQBg4gk1hS62mdrubjQrPFm21zw=", "FOBVkbm4ibiJkTTIB5iG2Hgpz8OVOLeLemN4swvhxoM=", "K+a9+CTSzM1WzsbRlT4PazEX9sugNVkkM7fayhLtQ9s=", "HbvXw8PKDqoBzTCdzFfQxjMYFK6WQAccxruUg6tvmoo=", "Iiey0JeVkXMbh875QjfnBopcXgPWCeYd8kC395ROkmQ=", "HTUe1LWeRlceVydSntkubOVarts249VMvGwqc/xKJ4Y=", "IxK7c2TmkPZCEKyvaV5djQOpBZsmG59bwv0t146/5Jk=", "FTLTx/79qafoH8lJ9ylWvV9tVbxL5CHSfWSEfYHNy9Q=", "CJFsHKPcLSGmcf9JifX3rlgcIQLBcgVEcstj4l/VgQE=", "GZo1VuTHo3Dwgy/ThZUmiNRpF3x4oOdxB+5Yau7QJco=", "BCl+h/aXR9rRORWCrCalQknQBPvRa/xQ7BLX5rlfqpI=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Bj2zpGw+HoIjV9tjfIkQcisi5TFFSh2ibydo9ZqEV78=", "CCeT5ezUS/5XKJBoyhvW3LGp2sCGv+ws6Zq6TQTEay8=", "C1IU5NHyInlHo6oT57V6TYXdlN9A4526zgLfDnwO7A8=", "Ff3on64L1Vk+jyvqBApvg3p7/VxeE7BFFMOesa4VYk0=", "J+fm7qh5GZEJ96FlWF/8tdpiak0MObJoH8e1VAJRDx0=", "CCtGB1s9oeF4zWNnlxyvh6NnYinbx0XgMbRRNmGCVds=", "F2ZoMwsU6X1Pd1R/O59DC3/c+xv8zUb6cIObrmPfSHI=", "EBBEUPWwOgY4vducHZ20GZgJTeLNioz30/BBQxIuWp4=", "GMhCh6ux2Br7fBa1OAqtLt8FSGdmHAfkSyUu0mzHto4=", "BNfx7e7XVq4FmP5LD/ftxIi3XwN2sZI/3EF/5987rns=", "FrO88uX+KFQwcvce+dg+MYh9xjLAyGtDie5zBEkgdlg=", "LynI83bUYpRlM8HzSTkYNPLsgmwI6rDu5qJj91mkN5c=", "INOUq7OyOWfiI/W58KVWzlghKMisUZP2b4yVmh78M0Q=", "CyB9ONdiUXupeP0YTM8VK6HEYzPb2XkZS5/wayenkqY=", "D63/4QClhhaVtwWfatjg1UJv/pLCv/DYGCW3L22lF7A=", "J5rr3eZHtBGCNNiGvRafBR7Rk7Dtz0b1SorKL00820w=", "EZ822v/osr519OZMMvwuzRGPMZQJSZ+gB4Gc6Vyi324=", "EkKmwYH+kPlf1r2wKRixTHvO9jTuPQLjC60MqhYbG7A=", "E7RUbD2nf9yHefarDXcLzTzXLZJ8csafwd0B3p6tjcM=", "CIj9Wak/EExCPswiccWSYwWrrfn0WPcOu74opvxAH3E=", "Jaj/NfhQcuT4rBSOU5kYgkCac74xVqhlzQDOT5/QXjk=", "Eevy+jswISGDNH8P5WMuOsMfk6aKO4/7R5YLUFYBp90=", "JOVHzwUvh5rtnUPncvvngJxQBgPq9O5p5B33XSzdITo=", "D8haIsBeXqISNf91zhEox72t/Z/N8Y8by2bl7rdhJeY=", "Kp8ldqhcgnOZZV7oVrlO51czVYLkdoRhBtvMxwKL8Z8=", "E6WwNyul7YsnGORrJdeXtWpssKLwPGIeiWmzcaXR8t0=", "LPMozVp/FjFpiQE7HbWfjowUjOoaCbvL78Rk7DV38lM=", "LG+K49CKUoBotP9NoFmhoNyI4xH4ehqcW6mXODaXYvI=", "IQj+N2+K6XaU429XXqoKoNrjBlBccNWgV19Wl9rd9TA=", "I6KZHnE7AQIsu40tO4HMW3ERfWY+O+D3FTdXIxrSLLk=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Hp0SX7fDXfwAZNQ1GgVzG5Wzfl6+534coFXqdUkCx1w=", "EZ1knTYsDwnvq0B2xHnJgzzLyAovDabDYtZT7Ks4FZk=", "C2glk9CSUNw143YSfTOjTTDqIfefPxEgZmGPlHhyw1o=", "FmcMZBcJAzxfG7QJ9TC3eZ0oDnyQJd79u6cG2eE3FzM=", "FgE9Q5P7MWhxMRoicoql3pibzQMPKlT/CPvHMXN16No=", "Kn1FGLQ5MHDSKo2CS3XYpHT++O4+rkDKzDjUDLUlk3o=", "Cir0q5VffcbQmpxyu/9V0wygEBNlGzh1I3gkh/1r/bQ=", "BPzCHSWLJwRY62YuyLFt6uLIA51ozKt04ZtFc65BOUA=", "C1VH0AKPqQOqmizy65ui0wO//5zrHUBw+Hyyghz2hMA=", "BOsEtKoixqueDNjDMaBK6xVGtYVA9GBiHyaW9FPA4OM=", "J3V7X60g65mjBjF7hyJ1UyoxrkrDTcvyDoCEPyURryM=", "I8XNRL3D52GCfM//zwnUcKVaumnnrQ/IP9Lre//0Hmc=", "IbsaN8xqHKHWX+vn0YaHVL+F0IIhU5e4mF3y+oxHwlw=", "IFBgKi9tpBF9MlcGHSJghSdQjljopXjQDyw2hfYBhGw=", "KolsWY1A2ZIgcECl8WKdxhVJ+7Dbpl4zqMrpitRq/BY=", "Cy8QuWjHa0ocM4BX4cZ5hcw/VxOA22axw4/59tYw40o=", "B6Hm6d1RKxDrCBe1aDnju4W3NkQrUPMuGPB6Xr3zwZE=", "DApypIQ0UEA2WXp0zjYnlvkCHQ3I0xjvCGIlpVyhqfE=", "KOPjTeXB3hyFGG59YE5eSiStYDtnarvjZ0oO0tgCvnI=", "Cm1VvHgmseKwOFDWd5KPUBv0xjmBBMAJ7MvCsvxcvxc=", "LAQqaNBrX3EQUTGC1cVO/Wqw273OV/HutasSysJjIqQ=", "GMv7tmB/KPko8fou8hzovp1HGajXwzp/0SebZyLxUaM=", "LX5uA5+Bxm8ymy3ECtOxFrub9NuIvT5EvjmstnarNuw=", "K6PPNqBYBGWSjbGPYw5Hqu84jQSup/EKw8YA310hCM0=", "JAMRYADXX7Govz0KGKsGj8zAwUnEapNdkWeMRfyUiys=", "BitcNYoYkhlURJ/RSzotzz8pdHEOlha5gF9xXXqfnlA=", "FDB0MfdJ1CjRX6P8VqUXxnfCLgqAv9D6K/o/NfMj4VY=", "AsBIVMlqrOrjebwPdHTNI1Q2GGpfnwH00Fng/IMDelc=", "G6YQf/NKjLHsO0U2Ml8oRaBbDEuNptxcDgMnQZiAtIQ=", "Hnufzcq7Sbeq2xchn7Sgv02njU3Nu20UN+f6VuE/9P4=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "JpaElcvZn1R9lMgtJLcU48/qOHrhESvkUO9IqTdSrF8=", "Hd1PLr8eHuW4tnFead8T1YxSTGsL1RIHd7eOJqBUuXg=", "F3E5bgcvNC4U+kDjek+eRaOFtbrauKELi65rwyU5LHU=", "EzSz4StR1OZYc1ID3+JZwCLdxd6scr/JQr2JcMfT8x4=", "Lnrvj8An8PTtQsSsZ0/4aiMUuaiAlKIUMlrl92EdP10=", "L2bY8uTGPO/zety5aBIBDeyTvoShiyYKZZkJ8YrQB4k=", "HMgKToEUwghrkNfH8PMwB9M7YTREpjgjtGWTmvQJcF4=", "BO7kOWAZdE72f9Q/o3OVEaI3DyP4DitevFxaHJZVE1w=", "KLom7yhLxTXyiHeZgN/A2oUwWIgjovg6PV7belolr7k=", "L9hNhSAUagE5ishPM8+1V6woUBlf7gxbKNLuHWKbTZs=", "DYMeV7GtyyDCJ6Gt8qarUqChz0EE5JPDJ8vqiJfL/98=", "GGsba4rJigOOzithlxsMg/KPMuCX4ozc37B6qOaFAww=", "B2MMWTK0hudL/MxtBtbKmeSZyJE6Ohoqzj9lRmltmXU=", "LqP8DBZfONmqAu7GpG4ZpYVKC7JYTC01NU4cgUuruJY=", "HGLzGW5T9R/NpmIDF7TQiNITJTGnNnyOV5O/3V3Ac5U=", "HzUuJ92A0xWic6PuGhWfGIdXRMUWm/36XtaikRPKqwI=", "GT2JheP5Em2qpOyytP7ARCXq/XHa/Ib/Uh2B/PYs3M4=", "InHJBrlgXE3UjpJfqDHxJnk5NC7CpvLWjd22KlJBu5Q=", "AygX01oNV/4P0QWEEW07XEjd/W6+mQ6R/0abHmebffY=", "FkVAIQwYI5/Q5DAeDnKQGKf0GfQ4/PgpKUF5uywHYiE=", "LedJ0tXFyds2UoExkOSezYrR07OuMIw8nvtumIIujeo=", "KlYt7NW3BBkq30EZUjT04b2NnVi0zEjPV6Lsne5+5BA=", "DdV2L/eo9lKDGqlunHQ3DnGy4Pod3R24VCe9Lnn4RyQ=", "Jg8kyDbcB+/a5l25B/2DkLOPU0H67Q/FU8x8Ctf6VJo=", "Gp1AUN54lhhR/RJonMD5P99SeOFDDXKVz2IHE7AfKQE=", "J9JVpA3jgEFYf5B8xNhKirGlygf2q/bVNCJIwN9txEE=", "IYdjRicBPTD/8aROzT1aAYwGNSvl1IC9MUaJjMAEOFo=", "AuDu1JoJSGxBACVXreR45XuOwXX5yjb9SBU2GJdmKR0=", "GrrPN4CmDTBONzvS9A/2ESsGjAxdWWajMnw4bkgMkYE=", "KDmlPNFI/BjbKHw6ycvvo6R55BQJX+Znt0FR0reMY0I=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "EhqytquOLF7Pid/CvagzfX9S12z3ouREhZ+htxS+jwE=", "I6QFx2RPaptxBtTryZsPLGxVQzUtOR0xopZUeCMPLBM=", "PeHMuOJujb+vBqCL9Ribs46OXPGB0VT7sMSv7QPVUQ==", "DVlMOhkDq7Z77eJPZkR/psyPhpbdvdVIMKMu8gVJXkM=", "AtE8/ZdLBiRzT+SlEnsj2uFvaQM8mxsNeo/8u1UVhzc=", "BK1BSFBs9ubZeV73hMbBh14yKrDMO2OAMRsZ+UQdj4I=", "BbuhxNNeqb21k+GYSMNRDyRQq80kvDkkVtl6bk8Y5J4=", "CSNsNm6X10FHnVZcRTEUeKPJGOYtUtEsX1S3Nmxb9X0=", "KlYw/jPA1WFsQdCVPDBeZ1AzBvKraULkcu6JzzTkQD8=", "JFjlHwFkgh8O0JKkK5T+2vDYAannuu862lhs5ejNPGQ=", "CjIYZg/0dnrKW3eqowYKTh/I9fzA/NaBPJiS3u/X6W4=", "EMYo+0GDDK0N8dQEVldBLggzRR2fb7NBmHr8u5jKwwA=", "A2W48vwwt/DpEEaWa2foBLiPLh637GwTJFZGfgXReaM=", "C9547Z+5W42r3nnVXJLhGfDKUCvg7Qig3Dgfia2FzeE=", "Hpij8cjo+aNe6sJ4JhXJbhKVDmJ7qJqawLhzeX0wEH8=", "DAMIyv86R8yS9RFj4FoAvqBRf2IaTWnLnmgMeVd1Qqc=", "C7IJY5zergKe3jn5EuMwBzNId8AASEL3UDWn7ial5NU=", "E//AZdmPi6mXoRyrAP6hnR7+YuIPG9cQPeSFjiELAR0=", "JM5YmpndcUm4oKJfledmpEsIHl1HXRe3zsVNqgKEGOA=", "Krlx+Koo1/sRt87cbYW/uUe9ZGkObWzA/Zzt5sz8HhA=", "Gy4V3Z4lrYslBv+PAobzTSYlTStHMsq127cT0iA6woM=", "Hxw1WfeI/tGfhscWKFR80dUJKw0wtL5OpjS3RJI86iE=", "HIOz/5+jJLyaUxbwqFqGVxI6STqbAiAAa6EQCjk5GaA=", "KJWKWDFyftgAEBFohdx8ZqHCRfb8q1Y2LJhqyHyu4DU=", "KCw4YndYsWSAeLJBu+NVc3Wu0ug/GCeMpsliljKXoUI=", "Dd7q2PzM7c7Y5NQ3aivFMEZr70UFRzHVJDRU/0rNBME=", "C9sDLuE6Z9nHXfTERXAkTk944ZoDmzD58SxTLpsK1gE=", "BlG6LwSAPV93I1yvUDBd5eVUMaar+sF49SSloB+08bM=", "ZUH9RhsxHfzcZHssM+Jy2aNzO1/zjH4KLPUaZeIsGQ==", "AyKTsrbpRUXTYGtyP3oxSf9dmX/x6AlzWeDg6yRE+rQ=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HkfZZVnz2etr0vr+IQwx9KgUC4U+q5htwS7iUnYTAW0=", "Gqo/uz8z+2PUUE+46oWfQVbuILWeGYtTFUbmiRokl9Q=", "BlyX8aItLGVh7Ws+i7aPvCmfpW5Au7VNSeAuwzrW2RM=", "LM9VauAd59vhW6UEQ3JxuKM2UdUkn8UoK4zTj9I+83g=", "CrS4I3xo2t7RjagcWmv7ZXtNh51BZNsrLm7kuFTzSTM=", "AsMymyZ9EQQbeIMX9Ww/uKaFtpwPeCqyIT05O+/IDws=", "IvYPH7wEa67vyuQNK3hDzZXI3/fUng4YhR9/2s86TrQ=", "HSLciHBigfgEBfZvtg++ZlY5lp3zLvxuR9M2NdpkSSI=", "Gq9Y290aFAGNM/SN4bmOb3qTfYGuRqpTE+mmrYhuf2A=", "BvE9Pdg7mfVrjYQOc9PGle+oyno4qJHJ31f7lFuFB94=", "LXw+xXPpzINQlkog0KLsA9LpSKP46qttUgQGgI2AV2s=", "KTouVauvFnzt0njcPTVZdbwfKdwzVDEPIfnOAVdLDSM=", "JoITLjc8GKF/eGAe3upPh3IkC/uImz25Oy6OoQsicOE=", "MBUI22wflxAoWx5uRNRqEzMQwpwoQm2QQX18IeTwsg0=", "GDTC1E5XdKfmO6MRo4lvpZXATJbfIW4/BO1AnC3psRI=", "B2xJ5jPxLrk7oD1ies8MldHWI7bLQvdz86IOAvIxIK8=", "D+orHfNRD2503Im+GgYex/glXP8O7Op3jhzKmb7KtYY=", "GcOo4juUbWRSZpZnAnD0kpjuTu5EAoiL8q087RH3rVM=", "CGy76uaeg6+NavUM1PFh80UBepJTGKzEa+XMqWlpcEI=", "GoqFHPQA6k6belHwvNW2NueJTQXz4Prt66Ziv4DpAc8=", "H7nx7Uz+VnuBg/sPn17dJuivVruuR8+2+2osUyMwN5c=", "D9W91CXgC0meV+NPGc+um/A5bkBfzZtN8jSnPRX5bwM=", "LdRZEwHc6JwlpraQzpjky2xWA1BQVfbITp+4mAzdMCU=", "ARy+AM82Skv6cccLaksYByR2WipMwPMQNeRM6kXBcZs=", "GRmrqerl1cvVfThR7kARr0e+COFRM50P6bMmAtH7uCc=", "BtwnhisMTzFIm9jAxuKp2OHI1SKE9POBuI9sqUSV95g=", "GRHDM1XO2cVR5ardUoveAS6ROyg6Z2Z/TyaWda2lkKA=", "L6zKgv3GMzCjYo7JQ10ZOkfK6o/S3mYX1gG7rYrbD6o=", "Fou30MezjfhWr5gx9LHaIA3ySO2rkqtB5jjmgAxXJS4=", "Azhkw8wKTMP8I8UboHvR95elU5T04MOcpN7B39ZHOuw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "DHMmN91TqeIDXLBI+1rDK2hhPgzRL2iouNB/q8c4y8I=", "K0ToKly67DfiCHYrdbN9StS7xNgxkiQaSssiOD8m3QY=", "DPfmqIFfYSL87rd4hR2FFVOEeWvpod9TY59dgWMaJVU=", "CXZAHIwS1BXzidS7ZGIbcfIlYZ3ZOJdSW+noE0q5EqQ=", "GiPyqloMqTlJbuzuo9ep44b2QaJI+2iWgqhhbqmCAtM=", "EpX1A3eHXuorh1e9k+NUO1mnJ9p4dOZGzD71I//Lef0=", "H0pl+Bs/6Fj+5f4pLajSWU78CKOF+J3GC+l8nHy9ADI=", "EubZJVcDfcL8hcF8QUjpAY/KSJ6Q6glup/QAx0KXovc=", "AvHjkG5KW4fHFFVqveRZNNrUZsEERgmyyGXlqDVmezg=", "ECxNCi61aUhufGx4k/ZJHANiYlk4j8fVW1GaVeN3qSE=", "LEJ8dYdv0gszSkVmPcKDWZNzaAl8Rve2hetuP72hprs=", "EvGWix538U8PLpD1+kR5nPLVy7O3dVjRSTZn2yrlUmc=", "C4cwWY/rnuIVhNVdVEfYu2VAuE5Ax9TxS2Bi7AKuAMY=", "LhOFelO53VemKnkLIh7NPYrCfdfd9PEOxI5oDxoXBBs=", "CG+XUrd39rYmD1N3DJQFbBL0RK9oxAx1v3OW3Byn69U=", "FE1ePRFlHhgKFhUrMQb5N5QtSO50byF6idsuQQ8G4I8=", "J5VnlAltMC/jzsI/PNcT4eTH6/epWZrBs3NMwDKBGgM=", "JGQYLySLw/MufVZQhwp5w3Hdj8jWcDTc/KYhofG8WWs=", "CnXxwuQxxGRH2ljEtTtacHAwAD3VJaZ0aWOxRMmlGAM=", "BEHrOWuoMpuIiA2317KbV+cWUmKwIQhUQXAnjkROEeQ=", "HCcfFpQ8SLtI9OLReLd+TDHyI1VGbWQZdJV6WATnh2U=", "IJxG26+oHNTGIHGrhA+h8TioKJ6HFQF3ziDG+ZQt/zg=", "MALcjEhiTPf24gftPcRlb2xv1W8mDJbJNicU1M1mdyY=", "D8sr1DG2+ZcCwPayIIheV/k/rfeo06Nlrq+gzrH7dEc=", "KnQVTD99wGPxLeztzulTt+fT1x3Ej4Z/csinW13H72I=", "Ep7wuIIHCBas8JOojGYCRaTlgmGzB0V+uZ/Wxpfw7X8=", "JPduvxfhpDBW4eR2fPSv+VSy+f3knwX9psGO59KQlHE=", "HQmfDWOO+lNL2cdY+YVqeUPv8YNQ/rLZDde//EjoDBY=", "LJ9EHzHZrqQgJsDnzYdlrtMhrTkfTIadhxGLehEH6Us=", "B68T4kHPquxFeLUrkxW1AX2tMk/Wm/Gmpqp5znWwRK0=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "JVNFy4g1TjHTgXQtDVtCByZiRF35uYokfWF8kvJ82fE=", "F+XHxCXK0vuJ5qyweizqS9WxywL8BP4429s0G+HPfYk=", "AUb6Trl0yPqp+CH2Oso3J0edVI2fZj9pNMH0WK85ma0=", "ByeUKHbG7aLJD5hFjvT01u0BDgViI28f6/qnK9EaX/8=", "AbyEpWVw7Ide/fmFJytd9myGz+WKW+BS2ReHqOP41Jo=", "EFPr4UE7M7wYjgb+BHI13TAoYV/tWNvWwdAUmA7Xd38=", "ILEqtvS/7MBO5cdfQQjy2ELwBOhEN+kJOxVULcJoA80=", "HsDO+eX/w0cuvq7Gca1szR/IXi+nxeAuYZBTl26uXVY=", "KkLp7Kn8rvyEyjILcqBBXuzhUSsK/te89JOJhXJ7Yz8=", "GhcrLoHiVZ/zq5sxoQPnfHGy5he/cGT3qRCAPvfMn5o=", "Lyyy3OyT6ddopedzArmP4MKRRnqL85IuJwEj5F8GvFY=", "Bz6UfjsHHZGszv1k2SQuzzUWGBtYPiciLQWsZOV+Yco=", "IB4R3WVsMpKwXCAuo5FseHUrmnlvuXv9sv5nqTW3Yew=", "ErobB0+LVdpCIG1GN0MRY6GqbAiRaB/WBO4Xp7Sk0FQ=", "HK93lnaWgJ3U5HAYPQDJNYYP4nWLhe5sa4IS6rC62IA=", "LiyOaA3eyAHqGJ3WedLhbDZL8opp17ecuBhC7iRpuKE=", "Ap+hkp5/aGSmxIVunLLb9E1Md8yhNc7p6uYRy0LR6VA=", "D6I+V7zbl38YXfQli8GsVZV5CeZhMIakSmWBzSdacWA=", "K9GlukmhndM+zDaq0jaw4LSgOUL0KmL+gldQiJ1KFSQ=", "FgrErV7slbxZEPrO60YAiKt9JfoVy2mOntF+FhL+K/w=", "BMeM8+SFd87bjLUkWpYHzcklTKiocE940Y21jyVSsuM=", "Hp7zFd/cmREtDkEP1l/MycescoYXU32j6XfXr95BTGE=", "K0QhYW3xHf6UzStVAIkfB+rykAvdjujrQrAXW+Ur508=", "CKE/jbyC7JQ8jsquBpC9CkvVGpdi1nDI0FkDjUJZdE0=", "FBZ+6lxkH7EihjaYu/aJfLzXeNKJwoaFQX0C6G2zbKA=", "Gy2E6SSYSSbHQrQmt8zFhBxL0ZPT4Fu9XF7VhomRdBs=", "oUxAQGNCIaaGM89PRiIlHKNOQsmuJU630Cp+rxq8PQ==", "Gq5rL1bTrMftL6XzEKKdTlS9tOX1MfaMWcpbQw4fP4E=", "HGvvGnqQPU/SFaF1StjzABHmduSYo4EtTxXQqEIrNdQ=", "Jg0061UDZKAY1QnoMaKBy1sYcDPstIFO9C8kClweoRk=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "KUVRlBg/6pQQnJRSBvLBZCnQHAo0kZ/89CrDFKlpuig=", "EfTztqGnR/waoixmkm5lEaTL9iafMMYvNvVLWA+JGoY=", "LfHL/h6f95xE6seQneAdvuReiZ41ALzOgmm/yjEMXTk=", "AePtKm3U7AUFm43REGOpPQtsSCJhFdCbfljW0PYgvks=", "I16t4BmhrIkhAigIQZYGJLF5uCuyH3pXHPu49MrlQ0s=", "EGPcaS5CrOzCdlSWfYX4w7SHYMOyaVZfNYHDDOyutvw=", "FEwIfQu6ayZRUIATMyugHKNs+pJu+zdjPMlCPpslcnU=", "CNxEkJ005Pvt7W5biAL8uKw8MeDCqWaVbs8M9MAn6rw=", "DbsW5biHEeuJWhK6v7gdvt+N4pzlMK/wkaOhb502NGg=", "K89cnIY95XTz/G3X41uE0zP6q+Q+HWzYJ61YBhR2+84=", "E8xlaGI3eDGQYNAcfneA2d3z5v3BHb1uDR2vYcDKWQQ=", "F6Ltz4v0CsJDZi/bQeQVbph/xm4A1Qd1I8r3S5cM7ME=", "GT3N/SlQqTTMO5LBuegmoR5oKc3Wu/aZ1wLJAsnIvfA=", "HwSct9FOvWh6xhFBS2GG6naTjB0jn4u/X4OXK3eN3ls=", "BNlZWrTRi+1V7zw/0M2Z6CnY5VuMEB3wnCrNo6zKmvU=", "EaEOFlbBbTxT+IkHPZ+RCUVQavLgKarP1yI81FtFfyM=", "HITBuIj/jWOW7mOGYhmz4ddHOt48FM7tPB/fpEtR7f8=", "D1Ux7zqFFxyZqZJ72dHL4E6E3JTHrGjAYATZmjke0Go=", "buCPxpHwtCKdyHGzZ284AEL2t6weU0QUnNfWTMmrRg==", "I3Yo5CKle1FXeQWEfuyUnMCTitzaLpf8lgSSiY0MjU8=", "BLTjaNDUhrLUdyqfuAjbJR/fqtqrtZpbzCDJe/o4zns=", "KgSE2Qud5N4V3sqaT4eVphqM6j1e7Q6Ti9XCID++RcI=", "LPowE5/P5Q4HZzv8gCnf0I9RERjdSkvwp3p7s+HolK4=", "Anj9aLtZcfnYtSuekkgU8+B6+JMXlvwrXQlgXu66lcM=", "JOpDFfLf4+Nh4OxyE+UN2bJf+L1lTYP20mylYuKn3ck=", "CGElma4uSoeOzYjZGU7Fzu3Ra0DFHm7a4sxD9elKJTQ=", "IAPt9pqBC4o+uCCLRV+zpuBL/fp/YZjyoEdTEtodo3w=", "HtltngdIqzfWmEt76FtsQ0LTQRE9JVy6ynSdpUXTSYE=", "JJR2hllOklyM5PkZMJ1d3XifYtJo58Y0ACL+DUWouBY=", "CkKyaM9kbmmoQVLWMj4esxg5KhSCeuMkGYH27zQXPg==", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "LBb4ApOh1kfeVqSiar9ctoQOZ1cJmegE1DS6kjJrB1g=", "EAA7fEcgJnG9puW9RsJWTGNNYA4Psj+JjXOiF+sffL0=", "CPmcZB9aQ22uueJpFGtQV3Ho0Y+EfK3TAoyVnjnkf3c=", "F07NiA0OiWF9saUtB2gBu93Mj2PHU0Z+fktyhPnAZcY=", "EkgjAZyW/rQAl5+8nos+oCi6RRmamRGOW+SIXqJcWU4=", "FHbyu4uyZezudpuAktlofOa4IuotT8jZqnWSe+JL0Dw=", "GdrEVkPPDsRhhO8SGrfpocA3B8euxGILzMgK6D1M6rg=", "FGdOS46rP8H4DPV+NE0PyiCBdDJBiYvK2ZndeTnLm30=", "Htcrji2nov0W2KzNjq+0y7UcWanQXSIcxgj3S3IwNYs=", "HaWrRA8s25vAeezezrZz7NhrkG/8M1CSJcY2Tr30+dY=", "x1HQ6nlRXBrAWEh2Qx3BzmIm3YQgB31S3MZEY46ziQ==", "BqndqDZpEp1T1Jm+nRhHHMw97Nqn3bFMTBmYH3k3Az0=", "KApiJucpzFpf72tmJmAD+3KpmpfhmF+cGy89bhxfRpY=", "J3zLfyJqGSC/WriD4yDwXG7bWAA3vgIvmmmQecnqFQE=", "IH5MKh+dS/2kE5bSRMvDE6WldVzpy4eA9qbPj/Z7CQ8=", "CrcunyJhvH2s33MLAsl3LWezS3HBVPBkgOJXaZWrf74=", "JtyaZQV/3mjL8rUY5H5SwwiQhcMAFdhz2oGSTugReXA=", "DuTsYLKLiuG96Kt1UhUxdIB485e5kU7R1gD5T2Xtsss=", "JveqypKhOcXiplPp67EyqqOFqhku2eFwKwTyyJ2bt2Y=", "LS8cLlMmv4s0OTEO1DqHIdhwXm0cAxr5+s+xX0/43oU=", "H9argORalNnuU58yR/Itj6sWAmxdASbMVXBRRZnJSyI=", "D5Sj0Dum6zy7hOy/RDR0l2tLYQssfgvnvRjsAm8mgz0=", "Cf2mIhz14lk9eW1xhYZ6tldr8veYE/VbahrpofyzQ3w=", "JoRjlt5qixE7eEp9+5xjsLlQppog5jY0lUk29SBHAGM=", "GeQAou2WBqCjkEG7oiy76qhUfInKDrAGxhS11tG54Ko=", "Dio6X0JYfWCuwKu784kC/VTTksTPJvg1ne7KFgBhoC4=", "Flg20uX5S9mGiuRx3hsZT7QHw8J6OzIslW8TeJ2V+iM=", "K7opZ0Tq18t/pOZLDZhUgU4wOopoVDMFOtoSYoWxLdI=", "HEK4Pgv4zW4gcrVgLYX1FhumzJqnUjZnkc7J7uEihRA=", "KoNF5SGtdfYXcwI9kFvIc66HVLKMAnMGPUlwAwz2r9E=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "DcdpiJ5OYDKM7WfiMfReJBKD2UNWAqck3Y0finCbpQs=", "EAL5YtWUqbOhzy39yUC4Cmtn0/wxSL58DRG+UOJ38fo=", "EWBLVvKF7prK11e2LgqGeeyGikaMZxVQDLhOcr5yx6Y=", "LL7nUyiPaKkKPEqDeD0whituieIew64RKvGwFu6URc4=", "Lfhp7YWq0c96F7WNIX33c4wp5+5bDSVMHUl2q3GRa2o=", "BSsrovx2p8QOTuvAYrHDU+LHr4QwoRIi5kuPHAnle2k=", "I0RvtlO6B9kxFdNBP/fJZ29X0eF6CDKcFT6w6J0+MD0=", "EfH62Lgu+MBH/rN5BCKXzr5vKm1WYOepk/Z/wQ5Yrf8=", "AXrw8sX1FNKWZc3iAj2GYvRTlUEBu2bhX/WCYEuGFHo=", "EdfOt6WDYMiUq6/K+7sLCOMC6pQNKfXEA5ceenoBT6s=", "B0rQjczjhL0t8yTlauDsZfA1qpBHm/JdlArpTyW83pU=", "Cp4OK423KGD9MwjXmC1MUXZticzIk54Ah8P8HhXVNVg=", "EAU91y0+JMgEBIIhfqbWHD5BnL3v6HCbxYlR/SoHEaY=", "C4/reUmoEWrR7Cz+R5EDGL1dyeVO4Mr/sIoj5PoOois=", "Gz948YsXjujfS62M8vreIdFpjvE/eNNZjESgY/792iU=", "Fa8ej9cfB5n4x97IkcEtibtoe48U0PErSlIIS9aK900=", "FH1BmxmZ14lvfyyatok39OHd91zjYVtR4nWjPl+o/pY=", "KLfNraLyyysa4XBkph8Ds2/mT6+dt1K3Rw2oOYoVeOc=", "IWPpMbbT5mQdNDabuAizdFwQA3cdup3sm/nV/iTENXc=", "H+O/A7oXUuDZNIY5fij/KpNQxWq7lJ9/agJXWxQ2Y24=", "LsJPabInVQKXvucrBWGByRNk9U+csx4LFNOPwqw38Uc=", "CY2cplXhfZr1/Hkzvrj2sQDXhkTusZwec0a71gd/708=", "LiluYar9bSGdrvwrmU1SMQdwgwtXZ6PIIgwvUlHk14Y=", "L2iEsmAsUOTL37Re1khj3LaJrzuRf7EN+vnPqDB9ESw=", "XoHtlxmafDL1hEuePEjGDfyuLnA7sZhVJgR51lVrYw==", "B7MoHsRF06WGVNcqSLhr6KEDgJEKV2AkYMkeTvzIEv8=", "FOVe4ocdo7HgUcsIV63q76XpEB2bXXYjWA+nDN0EE4U=", "BT9qHGu6WkzpKWKmojzfIQlrXBwGUkRKUhdO+qpih6w=", "D1XBrdJdyV+WAjVqatAG7FVzeKA4sJ2fRtrwCzWdiOE=", "MC7yFMTE54aIz+IsWFRNPLiIi6xVEgRHCeHFb7OmpRM=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Ael6vILdKdIoSmbt8dOBFajPnSMWx5siYq/FpDSHIXo=", "GMhEtUTsDaZwun/K2Gt+TMO3kMMmlQfODPYIMI5j1fI=", "J+iU5GPS2ZnFu2wp6fVXNgO04/VfpLHrMVsGZHlKiJc=", "HsPyaxr3YYXw3i2JQVfd9pboCqo2YelBY+kQap+93T4=", "IpeNmDolXq5oQNUNz1hiY9Wgr9W461UvcgzAr/yM9TM=", "FhjX17bXui2v0kaQraTPp+w+lh85W5x/v3120N2DcSU=", "HfLkupukTKbySHeRm+bYTJem9swxjHKX1gjxqk8FCEg=", "H6bHz677cf6IGR5i7B5pYRx2xQPKjGwrReCuKGWIys8=", "AvACZuULwXUU0nhz65Lu6AOGlq2m3ssBoROPCarvtiU=", "JLDvbI3djXSs00/Sl3onxuWE/rtcwe0RnkMzOTSl76E=", "LrpZD1FOtSdw0UC7sr/RkJ+7AFZVmluxj763L5vxx+U=", "HAFmT1ILElYvk7uT9Ah0MAcDyhGznrHouunyGUTwxKY=", "FYxuGkGEJheckhbPNQlXBTlRgMJkgCMCwrW92nW0pPY=", "Jgnbf+EMk54CiVlarZeAdELErFsoIFu2/W73v8tVrao=", "BovKFIzwDdtzvLMrWA25QjKSo9DKVHIHwoEiLFrGTwU=", "F7y9gakBAm35deGifKArfbK2x9ql3A/Jp9ceQhDBZxU=", "Lfq4S4s1gyDP1v4f2q3Y7gHUZY1wE3ZQaADOcAIMaAw=", "EggZquN7PZH8jAurrDiMU28/CRkjyhNYfI/JHSwnqcc=", "EjE7ab1gbKRscAj29PzPPd7wl0PzEa26EgBYEImYVQk=", "Eem5ksBKTuRYamIULzeGjWU1+Ujonr/FQVHGHh/EN4o=", "BfVX3qadq/j0kDKgegIbKSpM1z5R3IL5uOTZbYJWmlM=", "DOK8ZTBhsJonH2TVrFRvey86JwkQ8lBe0YbhGw1O6kQ=", "GVthvA0WwXYSgVjnRjs+PuDfR20xz2QeKXyMufXWNo8=", "HQ3319oz9GikOkE9/U5OGIOFxsh712dIbEpKa6vNosw=", "E5BFZIF6O/npixoh8fNg5YMHZNpKMA8FkmgRG1Gwt2E=", "DuAQ/KlfRSUKXOlKiakfvWTywRjidVEnpWLrsA/SfvU=", "J52GxIhxYQOn7CGq+dITn3LH9yoY6r/Vge9hngw7ILY=", "EbgD19aSdF8rp1TxbXlaLFG8VXZXbCRO22+AzXkN2NM=", "A9CT0lAMYUhSo4AuSYvdll27mT6NBzl7bM2cODKgkHs=", "FmUtX2mTL6BCcgaERgRhkPnIP4XpzLzTYhDFh3d48bg=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "KVm3wYx3SuXeF0mvAcZ4qI6zIhWvvZYqBWHW0ZhSXnk=", "DCar3F57CVpOIjfIcukLy+6KEGGFcuyaq+LXsaN31qg=", "FzA+ebsXKO7LiOGNi323hOoacOTu1n5/nm3rp2G4Y+w=", "CPE1G3ZVh3c/wlTU6cYhUXi4Fpim4TMr27FsViaHm5I=", "JFh8W+CHc6svwiUEIcSYizMr/EMs1OKD/IbeOIK3iYw=", "CXK8RvdSZi7HKsyYUft074+omgPyzuoBhJ6oOfmoDSo=", "GFOCUxVnGTv/wTfOChfx8IfaGRurNq9TlUWmkptEaXw=", "L4NfBopQCjPmtEs6SS2PCSKMLWYPhFWBI+YpLpP5BrI=", "FZq+5lj65t2vcym192qB5xPf/3HEOPfmeKW2Q2UoWUk=", "LOrM/gh05TTrOahrBmyptA4leT31E6LhqO3u6DmEiew=", "A+UlG3IdLNZ6RrTnvJABXDahE0qOxdJRlNXHwwnAsCk=", "EBjIsKPeHFKGgFA/+jke10+xuJ49wJsUD3YlJJ8GEkk=", "LAAV7K0YM/mwBNkCZE/uv94qJ+UK7p2jFOTnSAoeucA=", "JP63EE0WGjKM3y3HwSVCKHlXjM6JP8z4DluyZb++Lmw=", "KUTZhpf33ex45RZcuu4rvwzqY1mYGhPCe70XpgcJt8M=", "HrbpPL/QNbxPeb1tMuJcBb4oIWYWZVkI3TlPjkvrDBc=", "FSdMQhWzSYzs5QflqceMcoopJ64kty1YDKyiWIUVjAE=", "JEQ52HkU6nr2RHHAR9Gvs+8+TT60Gvxf9FUeNOCy4Ds=", "B8YNbZjIXv6nmcLTWa69HPhlAVcS+Z9vUHh3a0RFWJk=", "C0RI2FxYMhiG3lytAlCMsHnkda0GpWkWEISOUwz8q9w=", "LThfcedC/DaYxojfffKsDNBr8e2k23QkbVs+8jTWZgM=", "DDx6pyWBzwOTLqQNpkvwRUsmymwCsleY6qo+4Ik/FHk=", "L0CR2v15G7PPcInI5xSjS7wvX6sERBaHChEQvWjaMm4=", "CakgMVL3x6MiU188JEXcoL6GId+PDJvGOo42VBRbI4g=", "DJlEYS3Q+OGE0H7FpEyiV9Z1FKya4V5PW+SbbANWkVo=", "BGXIR8fRGb3v6Ja/RSx3944STuC7JFJw0h7SvXnhFyE=", "FyWFb1ETnekJftOEKkFPjo9j6mueZBTl6yIIQlg69bs=", "J2wbEJ+IzINO2MLmhnKlkiUMbL/qX5vd0INMVWP5qIY=", "K69UheGe28V3LgSibeookxdClm/fOQEbHBbygy/749c=", "IEKx4NSpYrlcXbzARPoOxToA6K1nem3Dnja0GgFusDY=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Hrh+2Dg5EDyHQ045yRA5lEfZxjE01EIzX7PiJvhLR7I=", "CAoia4xbeuaBBYGM5weyRBoNpwhg13G7TVhYXqGmKGY=", "GwOMjVn6NuHf1Myov/fTi2Fhv/Af+q2elePIWRF0Uls=", "KunJJHD49NXvm5bZwcI1xGtconXU4I3R0ZOr7lgddjs=", "IftX2vm0zfgo103ncjmFs6GwIm2Q9WPvHLwNkjL+NCk=", "Ir/rpaWjbNUV+jG52lHvJqFa1gULtChT9Z/9oCd6mcQ=", "IPPfiIgwrolGRtEWYgSvBdmBdhPHGc2nRcCaoUFZDAI=", "BjsjVaza0aADKi8sei6l8wfjwDIdJhydf1+hCTQRnyg=", "Ft5gQ39GCYgrnq+mrG3tlVuCJbCYX8TjmD6mQK3VAow=", "AquEmhDSRUBJi6TH7nr6xOzbgeAIP7gu9WuR0CXjN1Y=", "JdYKJ0iRFsEtP7ivUsh39WkdV61kWUb8TdpT2xhuLFA=", "GxRC3DUa7ceRexAIu9xKBdkuRjnn868bf4we/Ju8ecg=", "JQJTfQNSPWTqzcTaJAoD9pgaicPzNS7VG5UjHRKfbvo=", "G3hgRLFTEvBPBX/LMveZ8BdiN6nlxwvzCamGCrkPxyQ=", "E6oesN3gnjgW6D75AntbEvyymPRp2FI7WI1yj2+8yEE=", "AV1y6HI+B3v7zW/Jg6R9x7WAaB8MTEIlxYARuuhPjho=", "E2lHFRLEInMw+gwlKZVw2wDi22JVT9quMVmYhQRwPPQ=", "AbcUIImhZfxtBTCQ9OJ5f369j68ghhYEs8o5/6eNj7Y=", "BlAoxJEhq0u23UtwztqAZeVGUhqAGzaQ2DZgLfXAek4=", "CwyTpMpgvWeCRAo+1+1hDkrhHbttc8vUO6uA5VwO8GI=", "BTj+V4rIhxDW3SmlkWqnOcmp/88PaSsfA9DokKJqeuc=", "Kq8IU5ClaCQl3gLZ/sprFxPQFtFoIEKpKD9wt3Prg4g=", "EtOjuBTBu+91TdI3aYynY4Z7Rk6agdm7AxzMkVdIeLI=", "JPtpmy1Te9N1pTpM/KglaaD3vzQX4dBcLwqZbF6F7e0=", "Ed/56cM/N4bFzO7JGWAclalWmgFQKEP31OoKcHgRGrM=", "Jh5AewzQtD9bnlwinhNyUAcH20Wspl08KEIaNYM2fks=", "I1G/AyexQ7IJTjNjN8FW79bepGG4wtI7qssYq9q3RUs=", "HM/4katyN5i03mRrta1tPj2llwp5pPJd7iWu593FQ9k=", "BHbksA76AZyXvTz1Rf56ZwqsBOvEGMSTeCfKNo7Ty8I=", "DB5pe45p2ebNFaW34tRGA44RoGJQ9pPiGn702e4R5Tw=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "GgnSt+ZGUh3VNdBsuMTeChtCkQ6gZu3CZPWTgOJs/+k=", "AXzZmhA6StwXJbVF75izy0WyvHYcrw7KUQiRNWwPa2s=", "Brm97tksSVqEqCjdU5voMnUpoFETG+oaGYvYSQGKWos=", "CGgAEpk6B5FOaOHfWdFPE/Ewy4wQmYM/wNLS0R+zEdM=", "JHt5r90KmfqA6CBFv4FHTvBdGRdLFd37al6u59mKZqc=", "6s6YmipkODnoapbl+KHpnoaLob7OxBce05x70qrP/A==", "FTf6HrReC43KgUdcNQ62RwH9FLrLCilIYJyfobnVf6w=", "CevEJu/+ZvzVu/9R4KofYDhdvAx/6w2cb0/gY4RFbqA=", "GEZ75dCk5UqrBVzH28T4dtVgl8XuxbJ/mhUmQFmw7qc=", "Lc3ACZMH9qVMBf5PgklOBhHEkJ6+ZkNpf0Ssky9TOTQ=", "A/s9aZDY6NpAWhEvwR+cqlZyOi9gk+GHCoZsIdLzQzs=", "B5A9/xylt4zW6V4ShPeocALwCoHWEvgoQrsq+C+4UKs=", "HMsXKnsPETm8gRjbumvajvMhy98VOk24JrCK0kUMuKQ=", "Ixy6s1qKDp3JmdujaEUctB10VvLMBIGhSip9cvIBZj8=", "EYXfifikCsYJjYmDNNB0els9AoXUHiA444cSzSYIHbo=", "L6Bk0oG+FWz5fdqRQcasINDhnYVHRHXuNZ4Qm8JaVnA=", "CiEU7LS7iCk+uiQbwPxKOzddpqujDMp26EgQFUoJMEQ=", "K9ViHUbS3LQc2PiiJiDvYl1vzuXW1QclDRV7OeRpJAs=", "FYRRflRUEexshJuC4P6M/nDNcVxaZX14/k36ks9pDWQ=", "BhK9GlMpyR9sb2wxgJlR4UPEtez5fi/4xrAkY/4prm4=", "JtPTSO50y+J+WkdF5zgVGz9h+6rDyjNLHG8O4Yp2MpQ=", "DWnAl/8TutFvBIJvy8keuZIhQQ/av7BqBMadr10NRq4=", "Gd+Fq7YDS4aiN/PCoYSYU+6nDaUi9yURG9eIMacPKbI=", "C2eUCnJwGsJNgeBWx61z49+tRfbBFHaT6OVq6HWcdfE=", "LQZzNP9Mq4kqJMtAhGtZEXasR0Udu83pysHedmv9Il4=", "JQ6L9tk54ilPZyPIsuABgJkjtxV7opfP4Qe4Igy/wAY=", "EGJl9ZpxPx3mBfBxRhzHdlxuss4St0lMAh4HteCwoSE=", "JoWRkyco/6RFq1JtnLYPah3mwQ4kTP9jO6Wbm9uVfgQ=", "KKJkzz7ustgdTBUy5j40SWs1ANqeYvyegHC9WWfFufU=", "Liieydn7dHxXeJjyEENzpJrcAKUZdLj7HGN5PyJBTy0=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "KSzcT6yUGWbz8v3NC2TO1evxdmJG4crEWrxAQjV12cA=", "CPkWa4hqZOJL1cufUyeULNZq7+iQS6s+po8ck9py/zA=", "HZNGtVz9vOYkcWdKSMkxc/IiA5ylQJRt+MrY8a3Eq7w=", "KERFr1DJdTMKHUhle3ZM97Gci12M/XK9jNGu2BJFiAQ=", "Dlyu/YlduuSsbZpQup2h/M8umRgoAeUN7xP2VsxS6CM=", "LFSeikzTy5ySXc9K8K85zF1BmVfoWhc0++DNSVtOYjk=", "L2kcKJDteuICRN0S7p+slMvKzqQrvTI0hBRrg77vOWQ=", "AYnBiHTpOXq8KBZDv6dHc54qtPUcLOHGTY4Pbg9l8GU=", "LrZwWgLH2pgGG3ThDKWU2fqF8uinaZExPScgJo9lIj0=", "C4x7BzyRkioKJawk3nxXgfW5XB0pZ2sJdAk4DG5PDSo=", "KyVMHJiTgTFfGwkcaFhzN3wF0dQOPSDUH1ZQZ1bOXOM=", "H55owqRLmiBqXRxCjCdgQDHekVcJJqIxkDKXgd2hTew=", "EH6CMx0aHbOqgUwOOFTO7w2wJwyEKUXgmzUsxp6Vn9s=", "F/yxhnxS1Q7/BKE3oYPT8NrpS1ZWyIGLT+Akt6ND39o=", "Jj+AIRGq3MmcwSnQUfkKzecCeIAfTcsXgbdEwgi2qlI=", "An7PjsI42AiboTk+i6zIVsm0u1VN+jfImm1rywpZVMk=", "Kqw7+iDmSgwAElEmEbVGCQhhbscoIZerc0UXLa9w9CE=", "+CK/kKbWx+BGr1BfpjxYFS+IDbpVzvxjkxPRBKmUNQ==", "HUgvdPc1LMOx4H8MTgykaFQX/0aFdLdpT2/36bQ4Mjs=", "Ce+z/V8q+V4SacpuQL/eytjtECl7ImHnonz6B2vag0g=", "DXC4VURYXXUgvEgEjnFtS6zIo1fD79c14QN2w6aOWPc=", "KpbC0sV/9/+KH+6Q1PMKQnxO5fqtG8DHZA3SYo174zc=", "BGcBT9dch9pLwIVCFQI33JSNpWaVbAOnc0+Ko9TOKgs=", "CybS+TOwtSiGfolvMOcEWvH0ltc6E+WPoUVvSq4akRw=", "Al1o5b75Qg9kxCpNRK7nGyFq2QVNlo2rcLxe/3dVbJ8=", "AXfwJ7DKtXKRRjylbjvlaf1Vediev1/VKHQvEjcYp58=", "LFEypEvoPYiHnqEUAW5nCSvZZqm6A2S6UB/AW2OIdJM=", "FL+NLkP30TOL2TxDUABwd/qewC7I5k4DlQ0X76GHEag=", "AwlBSqc3A63cl1YbvOzuRdJfGbRZHcbXcvz+CAGoXzA=", "BA6kFYfUpAuTVXGIDcrfReci5Cc/Dysy3aU+U+cKeoc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "ELDTfKJukMbBOaAf8XhhxG6/tkbzSPpUOkT6kz3Gx+8=", "F12lGD+XTpYG631+Is0Sro4n2+y5vTxMErP27g91GPA=", "DtgnOizqg3kwosCaP3skGIz0S307L+QbE+A7zya5Jck=", "EhfIh1MuQlwVAvn6SW3Hkqy84Mx5xmGxbkw1AJ59hKY=", "GQN1Lxx5jAlcJO5xTRuBJKS0sU0u4v9J/3Fp3bzVtLE=", "KANUffiPq9ZpURc4/7F8/4kZwjPAU+KxDQG7OYYp3q8=", "BO5ezyuSUkajS/6q/JI5+aX3J3+x45ExkAtDK6rabf0=", "BMN7M1VcNiBQolAh2W8ADRodvBXJllslNrxO9ZtS/o8=", "GmhTBpnfR5o5/XHVaZiY+RxEC2HXE41MlaNT7Cpg8KQ=", "BiSS3pNizu8F5mOy4Uz8EGVBXE2r3KDUtJtgIiirmuo=", "D7XUtQDs0h5AJJas0MOaDOaqk3Qd2EZig4cyQASxXcc=", "F0e1W3BcmNvnw4kD/KUmCjE/sa53mEZx9sL9WUv92v0=", "LVqVPGXiHSd0WdasFzMAVVNryFxJIF5udc2jpY+vmyw=", "EiRrIvGd5CC3doWMF997V9PcudxIo0FnubkqQp/XpAM=", "ETPTIkZp+ZKFhjK1SpovPK6ahpeWhLymIdIfuKeoTe4=", "BCx/9BEscvluKpCjfQuXVak11DraMX3kkEfkW6zpIU8=", "IJSCVtKILXh72Xzrcaj5QTyihzgt6ta4DshRGg+CCpQ=", "GjYksL1DqIrHx95GDiRspI/3GlojCYzgpxPtTNO0K3s=", "HfDczFOd5UO7HML1oHR8Gh05OYt+XSVCrX3ziMuaLBs=", "Ah39XticJV4cWECT+Y2FT4HPxY+SZ0/g/o38qNfBxwo=", "IWGsNt1Q00rX/44q9Ju+EIjTMYZ446jY4OCz9DDVXSo=", "HtPMOQI2EDWVk78+SaWN++me4a+zOstVO/CAEq6sF0c=", "JMjYlE3hEnCN9Xso/QEtV2ho2ZjthydvcZL4/oIET7w=", "GD+3uro9EukFu3GE72kZgsHdSJhEwG6fegSHk8RqO54=", "BnwIPaFCjOUhlRukHM74NNmctB6LkqTEzHzo3eLeStw=", "GhipwcRelaVBrI37ls8ry1+Tzu3QE1vek0SBOztXYqo=", "Dd96wIeNtfTzhO0C1fyQrfchXkw7xX039MJ85DeduaQ=", "Ktq1YrT3mRlI2c675TqCH6CMlrkQCxepLSreQDL0kMU=", "HzbNbmaDJkaGHRpEN4+Bd3zuZu57Zv+kRm6fmCfT760=", "FsUUvGI1IKPGPXJP+fjiEo3jpOk+wmzWBZbSt0z5DfM=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "J2I15s1rStBzQzQUo5+HLEKuR9XK/2oP0rEdsiZifRM=", "KI/Db+Djm/f43rdNXtzF1qwLDhP3FakRppYhLIJEzzA=", "H253vK8uEBYNU+gapL0fuWIIQc183PVibNE0dxTxeQ8=", "LFDFE8zb5g3Z0UJi22AdCFvrUp+fmAnnNLEs7mOtYLI=", "EEipMrh89Dz2G5/n1eeCSpwL4tPYppJ4GaHbzk3nWUs=", "JYgC8BYgeT4riGupl4chiC5u3ilasFrUkt/LVgVWd9Q=", "H97+I/cfnE5LWie7jF756X+KJyNh+Oa6kzNNUpKrHE8=", "H0ZZL21Md0Z0ZqSDWMXBleEtskcHD2hLswyvMy4FCxU=", "GgYowGF+2UNARQ6LIS0Zu22A4MM2oMc+vUiXGNAkVRI=", "A2L+x+UKnr9cvBu9BjIKRIOfPhokxtzsLOqY3C7YlYo=", "FDTaQhZUi4EcJA8om2NMcL0CF8LHjTUVmBoI8LQiilY=", "KlopjuM4hmpRq3M81dkSrvymCau5JMO5EzT/MZaNsag=", "L+Nd5PgjnLcBlXmUy2ePp2tFrCymLRVavGvQBj2Ed/g=", "DoGHExO1kmS+FbTSRGXM36Ug8arl40di5IgUwVHq4g8=", "AdzPqEZjvRaP6tDWSKcCTMf0XeKZoVUsZcmu5pgAoh0=", "Ddy5XtTM1hVAUtA5m7s+7TVNE0iibn4+O3Z/iIt/wcE=", "C9te0E0TMFvHq9yaH3KjzTwyWo1dCzez9rwy9b8rww4=", "GjeRpdSA9YbiJfajQZ2SvHyT08LJQeIBq6LbDbnxXXM=", "CrJU2qXMqkfj6n3fiFoy6BktKA/4uWJUA28iVi4ygK8=", "ENCEsYBYXukADRU393tNbTvvujslhe2yhvnjgiV6y9I=", "DpnUSo17NjOkgQnoQ3qGYTm1Rt3DpDkRQT7fnAq+2VE=", "Grs2SE8wTijStAbt1dQjL1IkaiZCu4fl6ASWOaWn5I4=", "HyTIlurc0NX2sQZ4Rch8rjiXpFTmCT/AYrbp+p3DJ9s=", "H4xhMnLLLgCFw94Y0sAGNCK9Oj97NOvTlGKlT5ZpDdk=", "A/hgCBGReiHmiTsxR7damHp61EdDetJPpHKzAWEp+Go=", "ISaPWXuEdS21G+CKOmoqixsihNiwRCtUnuWq7jlcAgs=", "Ao0++D6zVafTBsq6M8cOboaQC6FTrWH2uLQc5J2q9Ss=", "Al0gDoO3KIUwCGtpAyKlMOyLUCUF8wgKekbm6CKskNI=", "Kn9rKuvjFCsmYtRzo1j8G7nYFkmLPC7f/4aGbirAAII=", "KZr6DQEh/CPG1C+xJ+qxTy3Y7LHuDAQ3a5xzLpelu3E=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "KS5d6010l05WAeBf3SoBpXzPzhli4/Ev/Efs9izM3dU=", "C3/gdieyuGueVgxcYFj2KiO5y0Fq9tdJMZpfCnMem5k=", "G+BGJcSq4gAOnhOnlZEz6Gt4iL4N6cS+2EMVeNh92/Y=", "DWshsQ2vP1idcfuJxycnjAzOktsNSwWN2zsj43n6XHs=", "II8U3oKnzfW48tLC13/pY3SIR1dNyPFoxTsdxoZ02u0=", "JhsyAqEKkvj4GPXJt2jYkbP+064DsYnlp0O2ovYxIQo=", "IdokuZ/BeQd6n47Njz7Ho6bU6MYsNyH1o/ShL+0HTZE=", "D4ITVwZYUalLb8nY1nlnmgXKnKgYOceGYDqY2SzTvnI=", "FGzy3e33BFECMGKFoDIqJrmzEtiuDVY44SL6QiIb0gM=", "H1WVFZ1L90xwRm9aXfJ/h4cn8DfGghvQtKFrmh+eIuE=", "LlVauB1K9QcRoil0WmXcl07LvxbYVXZ9Pulz8mHGlYs=", "CdiOuP7cbfytSraM6E4b8ylyXomtsJSqxaJeNvj6Ekg=", "Bb7K3baGZkdHryG/Wl5N3LAwogMUsSPFjcoFXMj0cgA=", "K1EzsytXg5P/NC5LoBabYK1y0Qgv2pfEtpZhDc8GvFA=", "IJ9LuYarsmccmsVVzigpSN0+wEnmeBLprdkPPYPWI0Y=", "KYbhkBvsNxvPPyv63MNAA6kBzzxsj85ahnFb+nDdBdE=", "NvIT9WDNoQKLyn2lNLi86/hM57Syddhz3hSwP7uOzA==", "Ig0bjNsRvnXRGyeTKrcCalQya1s0CrBl4eTjXSY5hnc=", "H81zcFdcytxgQpyWL8/Y9LPslhTAhdE4OpQ9fkh8Tjc=", "HEnqXlq0Y1vgzAfw1AqPa/aGIr7V2vXDquKiAB0ZzOQ=", "LDOjbFSZmqouVO/nAEhlT02PqL9wAajJLYbM4gd8jyY=", "DnDnKjo9LiZ6K2r1391VolQ1xvWBpG/1/UYfCNDp990=", "BswHKPSZMQfRrRzDwIPX8jhH3zA94g2SteyQ/4eF6NE=", "FK21Ap7s1OZbxYr4RAhpfIWR/F9vdLbLgzXndmqT7Rs=", "BV2ZQ+E40kz3LUABNKAg441P+rn1L4VhCw5eZ4tu9H8=", "JGWeX9W51CZCIhA5tATAlAx6Vg2sDngMWe8Z33+7ETQ=", "Dl2f+yl3XPHWP8VBEPHjhP9jo1MzHCk1vAYesLzve/Q=", "Ix8zlMWThbHov9Vwn9ldAOWAzfPjf4qUDEIT0D5vxjY=", "HXTYdqpRh/UYGIvs6NP0UQrXxzOAw2KtglLmxhxMvog=", "Ioc+qi/A8dJNg61OjAkPJ2zuSJGZZTBP/+I3pcVVoM4=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "HP3nsAVwrlbWELDs9GnG1UF9rpZWqbNqNcWnLdOPFKQ=", "GlERywqWGuIW9aHYOsjaONaRDC90R178HUmo5JTRYeU=", "DLGEbmZk2RndzZXHg1e/ICm3UN088C9HMbSXW0ysZPg=", "LPfWY/ktf7nCDb1JII/xe2agI8Rg7vWDehJL2J4+YHw=", "ID/y3kEIynVntSpFyjEAsYwwFa+6oBuVEBCkb+ezotY=", "AqvMQpFJopxAFZWVZ6Out37HgYR91izilaTMlIf1jS4=", "FyAysyLCYLZrVtEtnycye7FIWb5cwCON/LnR86inxCQ=", "Cg6HiVJ00Rk0NulD3kfY7gkJyZj6CKcUo3VlaHL8VwI=", "Ie7oEAS1Y5JMAInRYqKgtQR61gkQpZMbolEDNklnvUE=", "GSceT557in9UBBypP6UAXXbllgvG09wTLh3msuoHIyk=", "BC3BopvVgv0Ix4HvwOZ1Bq+s7Ptpl6yHGyA8v3HfcSA=", "BrjQiwehtYVYqd1VWWpnzXKWBRTbVVoMIca6Kfvh1WM=", "ARbIAPxnTC1pCcHlVWhlDKJDnOP8GsOoHvWtj+Lp7zA=", "IbnvgNGWea9XH7GF5sDqp4C7/zgui7fti700LECurwQ=", "Gu1b89O/aPLsMqr0PgtD44AkTyVmYlSyOgMhozpqWEA=", "J2rk6E80RqcHEDVQgFxSwFEMsMLiU+wy8vy6JV6Q7js=", "Bnfibs2yjyCn1WVRD3OyTANrtu4GNgEOa9JlShXOSao=", "FEtnnf5P32StzDPaeKN3WRQhxIbfGsEkf4lidi7sY1M=", "Kz5HQz4BiTuhQWupOqpOOd6O6T9nguGx+dcJcB0myus=", "IQB62nqM+FhnABfwK29FKrvuos/wW6Y1EaMkCL+MVd4=", "CZ6xHBCcp0/VidBkc5L/YFahAK4GWeYNDDS52j8nNl0=", "JW9Erg3K6+cWqpVpuTcwU7pvoCJpO9hlAXoJPgKSMeg=", "C0MELRdbEIoOnFU82ZpNKIuhvQq0ss/8BJvWPulJvCw=", "KCBlHQmSIoGkBQXXVcCVHbwVl32POsnJuuOSkEQDmhk=", "B8deela5TElC2JPBKw6Lo9fKSeJDX8r+Dsn99FILufg=", "JAcUDK1qbB1Ys+i7bwg7PR7EESKHY9xM7O+VxW75+AE=", "GfZxPfM5nMR2SLSX+AcH4RyWL2lNlIahiEIU1jseJCM=", "EmiAg2sxsq1NOUGmXusSAVKClZiIOCu6+2Yv/LFGzck=", "AQ9IuLXTWGAHqdo3QwHlJGq2aAlIUEUfYBMW+IkHO2Y=", "KzXaOF+drr/sYwETdIrc2+xTHoAyPgBifvqqVbm56Xc=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "BBPCqrveONlL8bugW2gPX761JhGOdd93QOA8ZJf8KpM=", "H1oanRESabj8nEvylfld8AaKF8ElRBYRMtPQbMbCjhc=", "IS0Hton3ermxHZxYuO7fvISg86XD0BHENVjQQJazxZU=", "B8aJrrhCa+zy046OUBqu6JfGqa7l5Hm0C/G4SlD+4yQ=", "AgrVB9LmvYyqi3uHnYoPIrA3/HeEmUV2ogU+FzuHmfY=", "Kae10d80AkYmvNTQFYbhrFrd/Aborn4g5IVnBdaSHn0=", "HLtfbCq0/h+16Btb8sWDt/D2o+I/UYmQceb+2jBhAIQ=", "Ad3+N5S/rM/xZt30/tdstc51YGsBauqBpN7NKV/Lc9Y=", "K0kpi9OkQVGYvS9ETeiaGtNZqpCxTK930a+yHOelCzA=", "LBCyswG+V1BMhokFSsMB8HHmqm2fYLnEKPzgmmCsrlo=", "JnLhwQPXo/i08lOJ1puITZv5l9xMq6Y8FfSuc/fblqM=", "BBStoMRXb1J5lS4RjkQkgKq8RhB8/u2p74NEEEg9dxY=", "HCBJIJX1wJWZ8Moy599pvnckNWKA95n74HSymHDmdwA=", "A6yW6OPqdAyOgIMJ6l3MNdYuvl1ytmwjnVvQe+lSPOk=", "GY9Fp/z0EOuBoS4bMJ8PlavGYI6EfFpo48NSq/crxGk=", "H0bWrON5g8wfLlMClv7xFCsbB0wOtQUh3oYxWe3DvX0=", "CV0O1nNbD+EB47fuBYbwYDVVE8RD3fSQca2Q3B0F5Nk=", "C5EqvRJhuCX55LP7oA+CUL76v87rAM610AYrceme/is=", "L7NMDsBIbxOcTWxnTaWT4qkt2ItFVqwFFRdUBQv3hw4=", "DT66Haog62GM4mW7HalmmX9MExs/8t2vwMcfwDWhL1E=", "I2QBgnN1XqrCnqrn4CHcDuHofcYDZWsy/TxnG3B2yEw=", "HwX51VCDQ65Fl9DwFQKhZgqOWXWkzPW4kVcSxOSngsQ=", "EpSYqPs1QPYQEj8xh/rsP70PSel42rN4Hl+wsRff9ng=", "IZ4IL2su688d53gILoR4gbkyf5Bvm44n0z6f8MENhII=", "FbZWjSpw/a4cyLCtAddG/y/suhRPUEJhmVuMLxFngOs=", "AW2jreaNd19kFGXfoUaJmZBvYZJuc9PgjadQm0p4iI0=", "AeCJny+20jhTFmVrXo9khnuD3SgAYzU4oZX2hgp1ACI=", "DVxJoM/Jrq+q1kFXh7jPp7/mLFabfWlVL0wTixLbJxA=", "BY6XjGwJKTkpTR5yOql8LmAApcoYdlOw3EhYzqyNHVY=", "GIpxpS+RTsS/8Et0KQe4TPbhxX6FWqAJdZX4bKp8sjs=", "K2/XvDo7WVwgbEParHUrdloSJVw3q1GuGDkzc3qLgJk=", "Lzp1ZqEM+NPqmnlMSt/y9VeAj8Q7B+dvpMYUMaIGNFM=", "CajjNJ7P0uhxtFTysukx1B3/mpb8yqftDLYDYe3UrEg=", "BqgbMO8iK6Cy+/FBZdRsF1mJ0yXK7a9YgBTRJudYWpY=", "J8hZrLUAReh+1LcKqaVhrPX7vI0KUhX78MXUkGPxIr4=", "DnhDgvTe/pf7GxBTZR/qpQArnRwstSKgzPlJ1Z7lluE=", "F56EvQa9YI0djOxyxNGCwTvH1lD/UQzysfTlhOskhy4=", "DyPRifV7dK4xqwS3bQzD9nBjrh/xepZI3lnMKB9U/Rw=", "AfDVUJieos6iYQi95HMpaCQ0D9JTGissIKwUMnsAnWI=", "FKNG1iLEZROl2jd/c+24A6cF7hj55Eff7YjVraXt5Co=", "CnHV536wgchXDSYBRmv76ifxQ/GyxyajQwNPAVyB7Oc=", "EfvRwDt6o6n1xgfaHEFk+SgFXPbioSclBt8kIjDplF4=", "C13L/yfWaFCbuordBjLWXuXdypusFGZIxsryvQnZ5G4=", "DKB+9uuqX/0eb3SMrHGS1kcLFwNVqFF+tpdyTMHDKJw=", "Dg3HEJAZgoi//6edIjfBYu2d+1NUxTLy1jae1z32N0s=", "GRCT8WTdQSDAarZtuuytilKEqWq2B6/hsK0QBIrIaSA=", "ER0EwIP1Gm/fh0EqU39mAQdtYfQ1CU6haUbvv6SJPpc=", "ATPFkT8l/16qhg0DGPaktDSf0i8tU1MOXHhbcJiKOog=", "CIdfR9b1GMjC31Gnhr8iB6reKEBnIo9EDn0DB1IKVs8=", "C6n0ShB6gcsj+6ZvK8NBUnKPX1ymhAZkmn7+R8lHPyE=", "BUKDKrI7bHpLVHoQZgNxUqJELpmMU4G6l2mEExU7pvE=", "C6H3ZDZzYJUpQsy27fBRyPk3kGqBZkHg0eni7SaQb6g=", "LgYR+kyjmF17+vUS8hpAgRQfTtDcSwIoNNPLbP2Lf/w=", "Dm8jwO9vFZ3saDQah4MPuGS2wIy5VKFKJQCHZpeJf7c=", "AaeipKCNh+dfcgMCvq18ohyPfC7S3rrO2bixstpGHLw=", "HYAF30jIVlmH27RCtILK5b/BDuSG7MW2cM6GE0WXnR0=", "KBIiVII/iSast+mPVX55YoLl4ScWGIWOdtSdCIbaFvM=", "JBTUrvx7SFffaBMo5opYLSOy3P/Veajmru1sYQUOBc0=", "L3EMctbaGcfYfL/9VWZbRysCZdE+IyapozuW6V03RrY=", "LihUQdC+2Qu0HWSAg2hQ5NdtqCEbBKI228fDwwMgwA4=", "KWSQGitC6a6hplk2Yq654SB3oodDS9pOwgEuNqGdyVw="], ["GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LL0mXOPlvsywm7MYnKCIMs1P4QLzn57iv+hRqAOM44M=", "HgIX8T5/ISBT4t6WanrX+95qfUczW7WLKxSKxK17jMA=", "D4hcQAjSpMKZKzM38cDrOyG8VWnn62rt4RZCDTP5geU=", "LpxZSyAj7mKMiPeozQAuBv3coToBSSLqT9SJ1/ANDMg=", "IXr9BcLlW4VnXLOfCqSGoRaRVXyp7ht+5C8GlSva4Fg=", "AfjwZ8FgL1S6V2eV4WvCacxPNEFvphmSASbrFtqYeMU=", "JfNjPJiJcUlMbDeg3ktzeojNW+nBTfxm/8xMUgDD1vw=", "GM3IsddUPvzN663Ua26QlhF3WKPixji9q3dn50+IdHw=", "HNi+BPGscqC32q74OjbmiARqQbfUuoOqXvOjpN6OWKU=", "GjH2m9dsZwoxgzNc+XdG9mdmmFFEZ98TGUAH6vjti4w=", "KrLD01aY7ANXRsQTHI1M2uO+d+rFbnCLb7apgyr7OGk=", "Ihe4ysPhSTQALiRoPLb7ltorKC0SRH+5d4lnDnFrO7k=", "Jtjswzz1JhCybVUUXymOWjh8G0WH1EvImv0sqBohy3A=", "GbX+9NlFbpP+B5nBtWji9t6vQwZ+EZ7onM57GwB06Kc=", "Lw7jF9Wh1sbWyLAfEA6vU4m//iaRMa+e/zb3Gzy39Lo=", "EAmkOmoA21Ky0OMlMSIgc4yZa3lBS3Cy0E9hv4R1dZs=", "KIHSQa0xbqWwS7BchkhJIsC2xvARc6HoSvg9i2m9I9I=", "CjqoHGEaV/UJsflxNS1oD3WgM2HnSlwSWUmHKHlyw5s=", "C/HrAaubRmOP6dChNRBe1lhIvdmSm5PTc2kkCm5awnY=", "Fmb60SS2TLGx+8wG7mGA4tPZi9/1NOoNT/+tJBOxWSU=", "EwBpR+He+8ulHs4YrdY30Iw4uXMjLsxotrL3/MDkD34=", "IM7y/c3L9YFSfV/dlELX2A6MEixgq6dKNJ4xgRmpsHc=", "KTCKvLuMPXGBJBlhHm4/MLZLizZwV55ffmCExX+BgNw=", "IKZRvY7/iYn3BiX34dsNoZtAjWM4XmP4sfBm0MORLg4=", "L+h3UAN1mvP0HC+SPwtoPCfPib+mCexvwmcUuP18Xqc=", "Im03/dkCNWOk1uKju80jE32Unzay2bG426+8ZE/yNx0=", "LxHq81MSW1txEKdf3jhMFDZcLiy7EUD4tSAgQRjOaJc=", "B8um0U8J+i7uwiQu5AH+D6CJwovHfwLwqpClZMELTik=", "B1fTm4YYl/TKhjcTRSq7nmwU+HNkF/zoNZxbTaxb4LI=", "BYmS9C/2KuCLPaynmlrIPSWCcoAtxlVqp1ezkKsi1sw=", "H6RwzGdkchPfUfxjb85rbmneOmZQRGlva9qTFvrbWh8=", "EQSSMNpijgGyoRrxshQyfFgJK94NlJ6MCKDJKbOaE8g=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "KeL6YrsRKCv/I83fvUSi2fypuwygmfNMYxU9MiV+j3Y=", "LsWERbE/ThsU1HqqjTwBSJ6Bg43Pao+y55rhxCDbrAo=", "KibYjaktszih3j1kqp94OJxFytJNrup0/KXFchzwsHk=", "JSQElagxsRKFaCV+8MQ4oidXYyg1HvUsw/ajYa0JdmY=", "EDVrhsa1tG/QkT/mMv73vLlQcAXfb+Rr6QiflgCPzrE=", "I5Z1OIM8m/LzojhyUQieaMgaRwUfjDFUtYY/54pv9vY=", "A9z5HSYI+UeDNDxsHJzSSEerLNZ3j1aEGFJ75ArCPok=", "EYUZWFeVm5ZRBNJChdL4M2VBLOMaarz8k210r5+4+hM=", "FO8eF9aOXLzDqQ6tQrjEOPtWtfu5UNiIPC0WYPstHe0=", "EXUQDG7S3faLpVK09AwnBH/gLN0rUzo7mXVFQ5kpQgU=", "IwFg9TjjWFz/S9PPe0/jM9Kyo1c4+xNa5trcB1+SraU=", "CIxOT8GyEnCpM6k39zm7x7bn6z4xbKGz6+VyfjgXQus=", "Dj40XevfXPvXu5pMtdNticIHE+QzI9Q0F5VEiqu9dqM=", "Gk7YfIA3rx0CVji95rl0yqJ2Zxq7rwIQzH6dsv3Jo0U=", "Ee1IRnZk3wBUjzz8cO7UA59qWegm5z3EuVmQwDoxOCk=", "GO0LzEGqNMVVan698nzPGlDzJWF5MFMhWgPZMcT3LrA=", "LnPl/znlggWhbgE8zQ3ZNb6/BlBc3NZQk1hABi6LH4o=", "D2a8c+ioewsChyDcQgU0Uo0v5WCbyz1gBQemwZ0gzVk=", "C8CVQFq8ASJHvEpyd89Z4l45g0vVg5VCyrlZrVNKI/E=", "H8OE/bieJ02tMw7vncUYVcEf2tsLmwUvoiDrPjjWElQ=", "KAWibSRkRTbaX36fUHFEMYml8QK5JhMJiowj2+iHzuA=", "Ki6rCCB5xg4ku12+NUm/Y5BwjozNA0oqlKcaqcQUz6E=", "BaqHvE/pDNSKWfz6giJs91nOj2D4wgjPljKij/e2gO0=", "IDiu/YGnPvCbfQ/UZtKzyK7ZmtnOVZ6yqoDX4GmWkJ8=", "D6+Xx7vemeiFPGevniGHuO43COSNo0RrPqw7MlKgV9Q=", "Bd1XC7Hg/rXm8Tudvq5in2860Go2XZ68vSwSDG923uo=", "EkVIeWuJBcrzhqYbyGjRRnJRyymUj/HzrkhHxySrl90=", "DfncJ4pl0G+MR33Li1YsJi3Lf5yk2HUHCzbpwuf88nc=", "ByXg6H22HmImn1bSWVX8/qZf04gjILoxh2Eee8pCwuU=", "LyBNRp2a57Nk/ETylZlWZU9hP2DPZpr+e2mpRLaQM5A=", "D0Fl/7jDzQyN8qHNzG2Z1IeyBM6ja6gCPmoXyQxQ08s=", "GrY2PMjoWUyvNkyTOFqrIbht5K6glZGzTfIVL2tmMHk=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "JzYmtwj+ybXR0TMLy7LYDZesHIS4mJXeBiig8V+nOsE=", "IywmCZW8KVceghBop/7ykPwfypdCFLRctutjwC9WEBw=", "IqkTF+TNDwSOdWt7QcEKmhD4VoPfkFGxqsQc+3PfqVk=", "F4nvMeVGnI+p4mW+yvP28LZpid/d38UkkZM/mQYkBis=", "J1AvgUI98PbyI7/LA4sDR76WiAtNmybWhbyH34ihL4A=", "FZRNaJSu173sHOvoHqFAZtxj5J2zi3m2O1cRzeoAR94=", "AtXXnHVjL/WJzqE0djumAsQzkOBfy2/46R/oN2wyfP4=", "H4PyI7OlWawJK1zhv+lfgb5k7Wm9KroGGB+ZYsCc5oA=", "HZEF3fITsBPP1Vid4HHpoZvsrCnL2fVpkxT3Fj8U9kI=", "LYh5ovAF1IKbVDmqFjD+A8tYHdMr437BEsvI+3ZxWHA=", "CJj0LTGmg49A3feHTdSvzjSBtuHtoExPIvguOnwzkHg=", "HlJz/M6R7BdKOS0rOE6u6yhWwb20NC4aOJdvl0l+Ubo=", "JKhjmIBh0kZLe8yNTtYw55pHH+B8gp2da17M3uF0B3k=", "DT8q8v3j3ABGH+Zfwl2O8y21Z0laeHdvD06sINTCMiI=", "ERMPgv4Fjb8E2Opr4xdfIuz++cSYNUWHCWfHMmfg3WQ=", "DzJ//BCimKtDdrNfKLfrkOeUtslhe5qcsf1g0eYgj8E=", "L8agjNwHIk257YXEhVXptnR9QB/DC0d6N2RwoZGJQo0=", "HDOtbQECakgwUBFpnc0cqJ0QqVsJbit9YDYzdMA4xi4=", "HlRX+6LZ2lbU6+lX4qSWCkXOm7jJQeKxvLhh8cHYi/o=", "KdKDnr9Yb6x905XOAANuBTC8+vAcZhlIlJT3im99XsQ=", "BNi8u95mIAXXvU/xbvkR3R/XTkTYUPZl+v/g1HJAY+E=", "HxEFZOFwjCcFy9lfWSphhAb6jMvOv+O0+pQgY2dkx7g=", "FYjYkf89hSbSgb+5AOorTelgpdKzdAwlYvao7VPzdLM=", "BjnyZ3cQ1Z0nCOPthRqA5xM/YDrgJ27FQrIxgf/zCQc=", "Ki4pcC8ex4pHQBWFVp97SOY+OXvWTdvvWf+s5i+1WR4=", "FyuR72V01dBE8+A+aeJwJX6Ayc0PEADLkdenGJcd3cY=", "CT9NO5abvAI7od5IV5em7PxC4unwNOrQSxeDDyl8FfM=", "AetYXlY80DtDDglHlV5bkG25sWmvM87xRnGGWgS73Hw=", "FRZ1FNMjUAKUaesnSAbYHWuoCYHEaU/QMPC9k8j/zzE=", "EkBYHGwIZ1dzWXudULkYfxYPp9enOWMPlD5N+bGAEjc=", "FZjaq5gorg+UkO66nT29YoKiSQ247EeJYFKJoxCaMHk=", "FfSPxe5B64y5f+5+eLVdP9pnT+2uqRU0u1BqS0QOpWA=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "axk5O+UoalytFLb9EsUSGUZ6odx8SSN1Pnsa3utGTw==", "EquHCeC3KJxxKgAqbwv+bnKEQXdyCgQnYxVAx2leCQU=", "FFZioHiKAdgbvA33LW6vDoh9IqHkrqwJCQDEMsQTL6U=", "HUA2VXVdzADCmBN7x+Ap8UC52ecdMOkUX23SoED+u5s=", "I3BDS5U90dJsTu7WyuUBo3WAFNutFL/vHD0mzQ9hWDc=", "HxOWiiOtkedL4FSJr8Sy3LQWIfb7i1L3PCe8L2TRmO8=", "MBL2OCwb/6nfAkCg9msxCnRj5J5890+swFTH/RJOIMg=", "HaXJOAMzkv/sNIh7+wbmMXZVwwlGcaaCR+r6cNYwwUQ=", "GpRBTSN8StKc3vJeRvSeXpOdlpnpo2gk9RqmX/KtywQ=", "CiNOeZmdn1WiHcA8Q+r14BgDXStYjV7IzS0d9y+DzYc=", "CfDIbXz0AE0HHgZzFqjah11EBQRLDnmWFuIslqEUDCY=", "Eb34gkoJVdBLX8lqusCAScD6nNZ4vwVf7C1DY0Fw8FI=", "IOdKR1qfr5L0mY61WboNjwVlnd4Oy3V5UOimq/AV1LU=", "E2YyGwbBK5d8LDlpdKKmsMTljwmlNTEhPGIG0HL00HQ=", "GytH4+qaOd9qBUh5zuH/0s/XiazXgj52XGdSQcOs9Jg=", "HpShROGOr8AUsarJFX7C+qma/6UKBfioro7LFSvbhco=", "L8levmK/1c/5+iRkv8Z7hUqyquZQ2mPElNhylHNTBag=", "HMrxEFBOH9Tuxsqx0g+GP+/zkQ2DL7eJ7H4xcT0mK9s=", "FRBm+Bv+e08ezQ96j+CaSO1AsMlFBHYEK8QwNgKJHQ0=", "IvBQKid88n8zbZ8+4ft9Z/o1WiQh1KAdEh8QIORK5Ds=", "AjRGXRfVyhFgf7a38+1dUtDAbat7F2E1bLvwIntXd94=", "DuDIzhSQncXXNgfboZ45cGeDSI8AuMrGSVRtk02+qlQ=", "waEvj2ALzQ3Slj/PtxctWEKxKv8IGoFj/M8ersMoTg==", "J4E/cgt6f+47RLL7+JiIxmTZYL/Nd1gWzrcAUObSYwg=", "DvEpriJ1RFCBBKec3Q+7noJHw1LJcZC5C15Ykv64KK4=", "AcWbysuS8wEsYpnMa0O6kmlIHNEHwWFAY0nbT3KL/mY=", "CJRKt9rrtohAeKjWGBBbiENQOpC6UYVcB5sTtqr1tPY=", "IVv5E2yLgfm9WyIdN/0Poyf5I9rJ1SuoJcvT0tYkWf0=", "DqYIoU8LS0BQF/pjcjeGNVKpjLubweFRt+2+jm14tZg=", "DBqtmmdd+I3szDhk+MbhbL7nTbVEGm//Qlor8qb4TWc=", "JD46lbrQNwXzUQmvTIw3eYPwb+9MrdlcA4M9wG6lEpY=", "Ka/fYdhrJVigz2CDBpFX5QOa0XKZfIrnaFf3PgXKPq4=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GoXoBu/eB6VOnMg+rJJ+5fU0sB/UE4j4BimLKFAaXwQ=", "EJ2LutfDx3urGoUG1NWI5/W3AzYabOcNR0eOdGSnNXQ=", "EvBLH5MlEchZaow7Xz2/H38dkVVAIPxD2waNlbjmFos=", "HyhjbYcWTSIX+zk7I9C/v+wdkS3KP8AAuh8+LvRriyE=", "FheaHPqpLJBeA5BH2zjiiNM2s1UCmxzhBIFo5VvB1wE=", "FsPerBFz4U/ItUxNobH/Ybe8TuK5xiwocdcKFFg0MuA=", "F21hSGJMReIQg33X/YfU3J6J+O+k3qfDz/BwL8K/BC8=", "INu2k3Tpd1NvHNxKCE7e70678MnDzEGR/EpweWH6Oc8=", "K6sQ57WF1Bg5lFTH2A/Ti7IxkO7MX4X0ENhTAEh7nuk=", "G9uf9iGDNGigR2mGvm1tcZd57FgcwoOhGqpCxREdIyo=", "BmYLwr4IflBe7X8dTl2EGNVeeZAIzdT5G/1TaQDp97M=", "DUvq5jeHs0R/gT8kX9i31vScg9Y/50pADc1myz02OvU=", "HXZhP0R+03tkAAqSiztI4ujdUhquh02X2tf+m0xXiGw=", "H4Sg7J2tzTk3oEVWG2IFOFwSwupMVivUIPPSfOMmd+Y=", "H2Qk8S5pUFZHRbMFCAyIHqkx2Qg2SWMWh6WjAvHYb9Q=", "K/Ym3sazwTDr8TemVpiDl94GASUOOYIhUtMWU3qJH94=", "E0cxSCtm+Hd2Y5rlE/oyRVQPodNObXTTL36Vh7hR3jI=", "DMiUyb5DZjveExek41ka/2bBir3w2LkNhy2GAS4vyL0=", "IuaQ+EmRlAElxk2FE74UzT+oHB78EruApr6tqAxwkeE=", "FCh2WSFqbLlkluoZi/rhQIaWxVYfAelQTVkEBE2cwe4=", "I3tmcDu3l9pI4MZN1mM94Y7FBt7C1NcrKP6Tq6MLFiE=", "HrIBw+JmMyL4WsyNZBo2KsHrHatXXRBa8P6shtaOuxQ=", "DyWIcDQx4bmw0Fn5AFcvgiLfXndJ3A+TwJokKF/VPk0=", "GKiQXnZaSbUQYN3Abqy/v7/MBzb2ISFt4PmhoRzGZIQ=", "EOHhINv3UZjDQrWFtJvQmZYz/VMQhA5yVkKuhzr0pT8=", "DmUxAUjV3A+wD8E1rQcdmwfiizLf992PsaLgZwI43pk=", "G5JKbNgisOsMYifIEKUcVA/p2dB/kG4kpX7G/s52OeM=", "FPcI96fBQw6fat86I/HcOMkq4vF1s5Zxqil9WQ94Brs=", "LIcM1WmfekAqRzs2EK3AsbHfuheYswaB3pNZM0iRtdE=", "LCeTzUifKguo792oSzUDT4G8R8Exo8a2+BB/fLxasFg=", "DxK0hvdDuGE2ha8LUIw7PEFgjTS4LH3D2PFSd+MYQrY=", "DqI8zN6CUq3DWEEFSLo8U+IkoxaebKlYRYlA8xi776M=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Hlptum/eYGMTbQ2X9G1fKS8GW4qduPKrB7wX0xVmyjs=", "L1u2KB+zCFyc9QgoioCUdqI8FCpFmUklT5ngRhSWiXw=", "IwEz+pwhS2zWNwHDoILuIRwtT/pwN9DQpMtjp371tpY=", "B7m+uM4d0TwVPTa2NqevVts4ANl8FkAChLVWOxkseAM=", "GKYr1mPzZL/Qx51/Ptu6q19Y6qRMD8IHKRyPcSIgWdM=", "CQnXJ2oCqsGQl03jRViSHT3I5s4ilk8Ol7aYWLvzkQg=", "GRziZuScrdUOtAPn+tB8yc7Y2B2NI989xlPMaajmIxA=", "Kc0CnbrygaW3LG1zBnS1PLx3PftUJCjUWhHUQ67gyQY=", "EjXy46oqVmOx3DLYbTKo4t3L3k6Xo+3YlMfPL3meVFw=", "ETEDCEZOgFA02ECpTSWjuL0MIG1mP0HRRfpmQVwtvBI=", "IAf2fDsdY42iljEgamvvpuITZaoe2zmm86Cr/pT9I5I=", "ASHVJ/EX23sKYUrRvm/qH4Q2mkxuRRwNXSU3mD+2uRM=", "HKSmx+4yro89Vee1+HU//dy8El4XDce3yLotYnAa64A=", "L0/5UF359dwO5VhGMebzMSE9ZUQ1tdJZPSSbP/TmSAI=", "GGr3B80ZJwRcuK0bFRDUFQko2DnQfIyaPZNBEmI1Eyc=", "KRyqOLLkCDEZxXmtCDKIB9Ss596yT3il1NIIzOlQVaM=", "J+YtVi0pNu9d/Qqu5ky0LWqpAAam+nSnzO55TXjA+qs=", "JwbsICHvbyj8ysVHz7GqstoC9FPaxbLa85Osm7+mNEQ=", "LGwLaXEDJuS/c4QGAWJtlMrnXJLKN6pbXG5hcGzeWls=", "A7xRmHQlUo7uekoxd6juRXHMvQKMcK2ku7P45to/WOs=", "ASc5QNQi8W17kY5ba8Pf26KyKrtCzWeqFU7XVJYYYCU=", "JTCU+8M0JAq2fIY3jJ2NdDXz2H1daPOukB+tIU4NrIU=", "HNpxjqC9SuQJIMVMnSA/iN7vPgCzpsOlvJJDlXwgEzo=", "ElMIWEdmpOyYFZUccqCZue9CP6speDycj4uhTvgiHsw=", "EwrxbvZykyeEc0TNyEOQedR4cXUe0/C4cdwkjGuFa0Q=", "L3MNXb0jAY2Mkb6TueZmz6npwHfTsnJMQ6FgkhcNcEA=", "J4rSdTTvGvpdN0LgO/vsgVaqZgsNZjsFSl/v8Emuosg=", "BtNcgxCV9d70r+wYQcdKrxsYiA6qtCVt26NOSWU8YWk=", "Kp6wO7KjrRECc8UGAx3m9DK2ZzZVJVxBif0tstmVbSQ=", "I3utbolV/gSF9PcrQCSFXzWQO215XP/SdGinvQ5HBWs=", "DuCRMZc2/MCmSLxssbMe42uVsgxNQPkTksMV5fzyYVA=", "BApzDzmmZf2csMk5ibKR0oGVgFfpuJjQtQx1L5NxqWw=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "AwR48lQ+kaOxybP6wj/IbAYDLKD8pL7pOHcihixEnPw=", "BBt6zNgFSoj07WQ5RHP7orE9m56gb8zQ91Q5yKCflo8=", "EbyqzKoA3EyAxDFyqDOm+lD6R4J7PU3wwiHu3LfpNbo=", "ASdrHsTVHPI8U7EEp9HhJwWLkfWkzSv+pCDBU1W0NVM=", "FE3I37whkYq7R+wGHH5qL3+psyur8nAEei9GW3+PbeU=", "HdBGvq8ehHYwivAImvGdoyKFI0axj/pYSvnZhhncj1M=", "D6fig9Vt7SPgOhbXnJQpgUPSWdjFPI4N4mHRl6ShwHE=", "LhqBmrrPrbVemO/bxby1fiFvp+2dYKTtkgsqHej9ExY=", "JWk47jsYJkL3ePdCvDvACmCqoluzzp9/yWVZzyGyhXA=", "DmozTjV3krUYLYtE2JPOMimWkTyrZAoAbBqLc8AjKE8=", "JAc+QVS2hEWeDL6mkO9YP+71VvCSsrF8gsMXdnJdqQY=", "LfvksXYICKw3kC37HhhpGQG0E7h8bYyK5U15iU3tbIA=", "IPRH9qZ9O4kp4e/d5miPpT1Hlkhz2G6gESbx4NRH2VE=", "LFArWrICV38BVDHMK2S2H4X0hhYaxOzWTJYD/m01PQE=", "Bcqitu0rhQpevMaGtxmGBJQdSNMJMqCeLekAb/phr7c=", "Cj0C7CYLAu8qTVHCl5zBsizaJ7VDobrXXZ5UezpcdR0=", "ByS/VIbJvSDCQn+8HWk26mXQUvRCpBchXNCJueRTeEM=", "HqhCacqrfCc9kuhsooeohQmVya3yYk2qhYkyZl/tZuo=", "HX5tNpWuUAO53GlQrziva1MZz1Kaeh1QdlEt/ZKwme8=", "CZZC2JEJLqqN8b+8RdebE5NMQvN/jh3Jaf1RyupPwkY=", "C5S/D9j5BwQMFMH8iqKQrqYfyIGqgtogrlaMNJkPxwU=", "KPsNdVM6gmPvLsa4XJe1ryHlJkcQVjVSU/xfb9M2E3U=", "EEgIQeRFG/NmwRHI0/2/CnrJwEuaotjVRyhd2JHnfrE=", "ESJ0xI3s40egia7JcfDPude7GhWzKtNnjnfRXPcQf/Y=", "AajG1BHdxuLe3S+sZMMk2Iq4qUb+8RdMlz3A9lgnX14=", "DQpKmYU2xJA5a+h00CwD3la8r6PPRVkBhPe1PvXDzYc=", "AiAWuVffgvpcgl9PuPz4Y05lSYi2PZ+ZM7x7fyVufGc=", "Am0qmw24Mln2x9CBotUDFwOQdrr2FR8XNIg/psMiskM=", "FZO08z3TBTJY2+qBF/Q18h1oduf9KQfpi9gdE+H4rv4=", "HsgK1+4raF/Xmzi4QrDUILaF48CQrPPnUHpXc5/3YYU=", "EFcxE7sNQcGFE87wg/u6kSZt+nF4Z0iIrOXVZuEwju4=", "LFvKI4wsO+bVz1lx7pLvMXTUoEDd1rBDE1TOQ03pibQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "L3cjjAV+GHeXlQxQ2s1Tmnt6G+e6o6Pzphf4jsBVE8E=", "Hksyfd8HzAZbN6mvf22XuJxAR5kIvmGy5jEsNRpNXvc=", "H6AEhAnaYM2xKiowE/tgJXlA7l9PjCsbtWNi4SGwyKU=", "HJLOLDU1gmisVqdW9cqUO0PbjH7JZXcNpitknEW68bg=", "JaYpErw5qsxmBV62y0BLak8JtwOjRLdSxSbcuT52jHM=", "Lz48kb5vWwNLANr6b9sz7QBzX0j7IwCng6szB6aqx5M=", "EmGAc/cmBlJbdD46uMJ0m8g+vDHNR+z/L4Ua3rOXtfg=", "B+GhSl/poSeTCx7ppLu687M+zAwj17O5BvWZJcBnD4U=", "GFhmwgch4QGKTq8kEDG2ntHyqiXgUxCkSgFa7UUANXY=", "GEX5ZWmQpos25H6Dtn5tU/Qt9qg8upWwFsNJ/xkd28E=", "KF21vQRRaqBBbCxSzGUcJpC8hGYh3ewv8wNxZcMERLE=", "IwaXzRp5wwNIkjLy0GAYLEEB4PtLbTrDi4KjcNWcopU=", "LV1CQ2sZvUkW8DXzI9as3a6aJS68dEWtsde/VgtGS/8=", "HvlDWMkEJGZpkHUkulv/vb18mlr88WDkTQDxnNgE/Yc=", "DckCwcL2Oq68Kmnts3MxymwFNRPymZG/yvbb+c2p+K8=", "A4z+xxAbLulU+lvRFW2lxWYrx34rThbTkTm78WX14zE=", "I5QOGwZX26Qe48ftvobX7586RQFqYcLc3DnwMhr1D6I=", "MA77YSqgmnIcj+tXdcY5IEwJK/Wtv51CaN0/JKQG6Wk=", "HNqrQdgUFST0A4lBhXYIj3yKumL+tp6JXTmEMGjdVnk=", "HwNbb5V+hMHq7sceMbGVGPPeyZZHU6LKoaM7oUh50OQ=", "Cf8bZm5HpDMIgyn5RUW8RKF5/2HnmI7IyGcVzdJSN/s=", "l60AStM5pqtG+SqA4wPl1DH813tGpbRDXzg69o99CA==", "IYm5NOFgKvbjDXhqDig/CHdyDLj+dzacN/esiViG3B4=", "AZA7zeON3eFOIiCdcoN/m4E+Q3CZ9xJj+E4YvGQU7nQ=", "CBiH5r6cFOG53tUenNv+uiAByeYJjW7OkFoPzqmPZFI=", "JsevHxzuhlY+kpIzb7ZXOglwryxtSdRptoIYitVVYa0=", "JD4hQFNnwCt4ydqCyRAt+cMqJt6iHaAL62LKnk5x/sU=", "FuPmu5XyjS8yHntj9qzd891sLpoFrvi6S5FRsd4Qp4o=", "CwERQsGML9N0DAdRNhJ5TBRQatMJT0QEINUmXyJahPQ=", "CDa1Gv2O8RClfT2CvLHClKPQyUKsIPb0B8sgrp8K3cM=", "HvEqVHcH190nUp6GdeXljD81vVDeRk1emxc1qyLZVWU=", "EvG0VqP8q7EWWGEH4InMs4uOoKwv3m9tRkMCxfYsV3Y=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FuI7w7phLo1BBKWmCMzg0ovzoGxvkCT4+Cnt18hP9eE=", "DUrPzqI35EAJs1jZmJYbRxn+USqizdZDiqMN1bqm2rA=", "CTytF6rtQedZz+sVRh8CIq3feMOgrt6nGGQxxTXtRvw=", "JeaBZqzSQfwwHbWC+Ja44xTjmNrVbenykm+fExqB1cA=", "CNmxo4x8cbL9XayH75dN209xGVI9gfiLDX4W1XfbBgw=", "FQxb8GoHG+beKItt6wC27lHuQflvcc3MmAo2bkBJWA0=", "GCDgUz6nVATvJj5XAlDiX5wL6hIo35+pCl2oF2FU8Ik=", "Ip/HtjfPgxbtwpFF7V8GCpGI8Q9x4Hjby4h9GV6NqJk=", "HMVHDGvV1z7uY5lkgaKEZkmXUaCpx4Sr2xw/7+ZD3YE=", "DE2ni1MQ0EhTJCoR34IbqEhg+sGi/un8BOJcYDm+6PQ=", "CUzBVeEU/4JLI+Z+uyiyvaU6pSb9PxGSfbcGDt7dK8E=", "DdhyZ4uAjhEEWmVyUBchgeH8fZ4uq/iT8J/Dxr46k8g=", "IXfHgwrGssttAerSZqNxMg9waaDeBFTl3TolZv+etxY=", "Iy3Z/9l91QaLEEH+PtbgjhYiZenoFLhRFqZWFDCq9y4=", "CHcm/zyrtilNIQaTGzFggJ1NHmae194lN0OQr4yjm08=", "A2T2B7Ic+xKSns3WX3YY72XI6cqsxPQsRAmU2LXc01s=", "MEsZX6C/+ty7I64iZ2k8fadgfqr0DIgIQ7pxUh7e60A=", "GWYQNoqHZPz08CeGASMrwKWqe6bSDixUIKeGInKwZ0k=", "IY9SgmuOK4LobYfXvIf+XMaRcUMEiCggYtcAgGnInd4=", "KnDzmy2M8hL+cGVF0cwVTQdAXBQXcSs4jJGbNSY8E0M=", "Blvk6k1sqkElutrxa4MFOFJ0FOzXGKkjw0F8R0/PUDI=", "BSer+PprZFWchrae67PwrNlMnyOgFDj/ePA0yAKR2WQ=", "JjB4q+RXDLltJ86hf+m0k/rbOgIGBcxHS+CK0XPdQk4=", "Jhay4KiXDagBkggzXUzMqkicbLjaaoYvGGfiRuHzZzY=", "JV8t8fmG8VR2jw/IpaLO0fGNOV/wEWXnfWy9o+i3u9k=", "GAb/F5XZ1skpL5gMlXA4rPoCrDJVbJq4JrwUqWjazIA=", "CHG68BPy+xbAZ4WIRM05WlINiouxer4gfTE4vVkdz74=", "KPBJPVx0eICnGoJkTCDcI80734TgXL4MChpI+icxJIQ=", "KkXvAv4d1BZBx4e4YRETvsSIGlZ4T8+iG9iWqCBXmPs=", "B+0mJADixmk0uWjj+HE9ZuhfrnKrc8bNM+r1srSA9s4=", "F5hBYtOXorOzvzuwSvcFMsS+roGgdtC44bTFTl/rL3w=", "KW7ikfxjYF25WUJB3+tldmA6MMQtbWMdQSOYKtv1TOo=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GZM/x9Guo27UUW6kdoYowI0gboyuEuU6YRR/IwHffDE=", "Lv15LFatGQMvTiMH9+4ziJVVbeZTvPUCOfVqb1laWeM=", "DWyUdQWOYCnKMWKw2zfnHKVwpibngS+JONtbufVPNSw=", "LW447RLto4VlkuA0jMtPrSR3YZvIo3I31OSKixLQ1+U=", "GyJ5i7a25XESNpM+JZaQXsGk6vPCJMuOGDhYV99HWuo=", "DuK/rcbHcbgnnYL1R3Csq3mOXX5rbJMSPNbYcawPnLI=", "IdyOfhlRti6spAVQYYzvDTL/gvQlJk3/J0Pih1lNfVQ=", "HnW/eCtgKyjLEfSJoXqzI9/ogadlSvF1z6ut92XStI4=", "LEm3BF9FNH6oSY3y9dXrVgFU81eQFnctwBf21Dz6Vj4=", "GgrDdzXqviV7nAwlwOjO1HeDPiNoZ4xkScGqS68PIxI=", "HzXiE5FMAaXr6zSDhhBXik+6LEoG0kjg1rdiEu8zlWA=", "I2qwgvLL0maPU+1amsXymCJEDksGVDtv85RHOe2wClI=", "EiYVNPCcS08UNxfsTosK/lj8OZZx/yn1/Iw90wLrcO4=", "FCHY0yI1yuuOkDebOrrOodfOQrsa6SiECoc52FrLMSc=", "DTMK/ovmPYrOOjqDt9oYgEkS47PBqKs+VWsyVvDFUck=", "FWO1Xt9EOJDEcppshNUj4RM9VL7DcAC5r9qOw5PA0v0=", "L2qsoAkTyKBWhn9C9kAW1ymC4+3dYvdQjEuGZR0vwlM=", "LzGSeiGM6NWTGQdUKQmpqKQkhXIYVzWF4aEarDSkrFk=", "IkXVbGnJvL5H7lcPosroAIqLwwQkENKfhM9lrfsdZfY=", "Cm0aUDJr+HCWvPtaz8OoS98RLv+Guf0Q6TWz6lz+UvI=", "Dcovyy/KNUGfOtZzdBc1Dk/ks0KOZdT0GBQ7lyBDVbs=", "Dv8NNYBsaS+T82XHzm1UibUTrKeeygpmY+m72IIPVow=", "B2GhpTbPI6ofV6WhAUDUscuWjp4wVIM80zt2nbHN0Ks=", "BP4KXyckmeERmEy5X2ka01MwCK5wY0uu+eYLsICP7sM=", "Dl4aaaDyUhpny6qWeDIUOZgYrc9RBMjamNRfOVHfPXk=", "MEL5mhdR6pYoKK1WPoptbcQ4RZ+bkSs7XyVnrjG3TPU=", "IZHy3VaZ5/Rt/HoPsBxau5o0dAxTRpDteJo77b4V+mU=", "F4hu1H8T0dScnCSDZlVoPPSB8+idK2W53ni1kal7h+Y=", "GRPRdUGyNNg/2feFF4JRbaS/T/6TVcGUAK28mVxBf8M=", "Jx6Z6tbfr/hADjkFQc7PUUauDzuG0NlImKd7Z9D1m4k=", "C1fBFvOmBwlK6LPnorfvEjY1vxMQicqPyNAmRxW7cuE=", "Hgl9R9SoK3l6WrZO7PvFAmrSXJqrlMvPvu0E5Hrsfng=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Dv9lwBINaSkhK+Vejm7C5GjX/d63lRsBrQFJSMF0uXE=", "Klwd4b8X8fuzSYfUReIuO9qVEAYu6Bgh0glE3yfR1vE=", "EGF4Rwkx5p0CKI/XOr7peZRwTSz0whQkmP2ySHr//JE=", "Hy0X3rGiXsBFcIOOj1yqRyUMG8FsBAYBf1sq+yssi08=", "He0/nv3i3byhHiKAA43tN+r5pFQslZ2ep+2ylVcRjAA=", "EyYR0wwhtJCao55DMdL+Kh9TIZjzRYjmfckqN1sdlb0=", "L1dBBD7Ye3Jyx6DbIK1GJq9iEHHNCqZ1n6s1GPQg51E=", "IHScEFGSebfMuC3c8cq2ehSyazCAAimXwFzrR9oCEeA=", "L0sSy+/+icyODrj8zgGtkD0UdQU0sQfRpQlbU/LrmUw=", "GfQ3pM+dadkY4r0sGs5DCeEo+5EZJsQ5YDl5DbFnchE=", "IYkUK46OYtPqutfTqckqL/wHZ327OSelUDVDak/pkIQ=", "Jt65AoBMUPRDl2E0c63TF5n4WyDRIyzNwiA1fofgREs=", "Bg/rbRPcdTjN6mJ0lpUHunhDAep2zvivDrkUqyM5voI=", "B270LdC7BphA92FVjiAFr3k+pb6sNJw9+55hCTOxco0=", "IXGN8O29LSFnD6mQ/Ck/ifU8sWlzm/fNK3MpZ/1Ok2s=", "IenhAV0Fpny3oxT97N0drFY9vuK57asziOxO+eWO6yI=", "BfwXQQnI53edOTIdm4Q838Hg2J2IBuGZ4V7fPL1yT44=", "CWqntzFcGB1LtlJ8Gr5ddYkIoR0UQ+4wwHBrMbtD2j8=", "EAFx/4BfgI8XpAqegLT2UWul05yunPYpGeCF7ctG4NI=", "KKb2aYpNJXJqfnvLUCZLZqnzd/bdQumv/Ad7W+5WgKw=", "K+THLn81QhlITx8Yc+s4qKylkkUJyJLB/QciQdAsxiQ=", "Eg4JqbW6HRPbY6TQEaL/OIRVZOBXxkFlfsJL9c6OUy8=", "JsBEsecuLth+YgwwEKzzAtbxnLjU1chVSTHS4pqSPak=", "FiGpUCRLXTLa4n8YmXCuENFPCAPZL2fYkS63WIRpRx4=", "BQZd91XFNrpUvMgW8wjC40HwXRYlQRbQ4pusnNgnJQw=", "GBZa4QAWSMjZmH44v/hLr+00FLotwJ65N7c6HmNvQ8c=", "LoTdaMzNBpytb+5l3rJ8UBsqCox1+msBK2RRl3oc/RQ=", "KYaO0L7ZMtKuD073MSUaSuWUcMzkMlC+n3/VXFQ85jU=", "KWtBzkvIzdBu7wAhxWRkYzK77UqM1CFu/6SgmgFbHiI=", "LBVY81VS+x+f2W+/oc8YerKWyUHw3PGvGAY9uHICjVc=", "CLG8Xeuv4swB6SsxCpvRtiJ42a7694pCzhadvXzLx2k=", "LGTrlrKfoOB++9hrzaofz9NC/yb8wRrbFjo+d4CS+0Q=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GULg5NxmZtBQVl4wQbCdefwg6Zs5Oyo8U/Z0Z8PcnNE=", "KmH9wheg/VG0TNpWaeuMgbTkzaM8B9lqOzq/dbu1k6E=", "J2dskkXfKa9J0WFLAyyG2Z29/gThrpUekcqIJn3p/lk=", "B5YWWlAgmGXwwS63aGge1xB/bnl2x2o2/hlqw2/bxbc=", "DD7gx8v4YjRHyQuQ4T0pDTE7bQxGbgxOFinlTuoXUJI=", "DKeJQw4JxylxukmrjPvojH7pFXHBvc69tRKtsGFZfyA=", "BVx4/yyk5gyNH748VbFezCj4bzDok/vAAYNswGMslV0=", "AbHtGY6lr/XodQ5P3RtRyeTbRaZRstnhshGsw7Ek4x4=", "BoCgExkh/xW29zftHvmbv1VOXEHvT9biAL93ETRRKpQ=", "HARXTU9DXfJKOKav0FbEnt1hzh3LsWDGnGq0kHFvS9U=", "H3n7NJ23BaJH5omi2wkSRMMGgNy9p2X7rPPzb7f+ujY=", "G29FvfDtE6gsMwpdJuuZLbyYAvEb/CZp4/7vHDELrq0=", "HOOMsrvdlMA4afa9geW3oMNZqTK2dsC6Y2n8TuknFYQ=", "LZGPYPjHvimgtustbETFbwzdhl/YoZ7XR/TIOkGi0p8=", "Kx5r7ybDwqX37DnDvk3hwKW7jB3ENFcNHPmBHHHB4tw=", "GCMaRiWhHgV0EtJ4mxAUSYWtFZZv2yaAmrgJGwbjzjw=", "K6F3fsBCIqn5jcq6OlwgI+d6gHGieccms1SC1jR/7OE=", "GD4tYwGx5HLgHiNg4CvIVbbxomKk0DUXvsoTrCU5+lA=", "BObDKbiGM8akW+b3f1qdDVTtqFpOAV73w2i7FFxpeOs=", "H30rU6JFbA05hBc4bYf092D7VBzCJdDYTZ0ACCi5T+4=", "Hn6PB/x717Ri82kkreKng+0q1H9qfUpQUbl3TWHcSAs=", "CO5txLm6o2LG2oL2w3h67Eju4fbtMxV9Gpvf8MqyB4E=", "H+30bOXwln8NJZp64Z5beBqAFGerl+ybjVAmWDJHHpI=", "BhCmIHmwyMAK00Aa0Ec/7UTcrSiv/d6Sx0ypJ6AYQD4=", "L43N1QGYj22h89gDCFMeomrS63AX6ufZfoZ8z55QENc=", "K8qa3mqgaPYMD9akTlSb/TffhJmlidv/tksA08SPtzA=", "GhRf0v3OjOP9AoMNTEyKaOMV/pKjj90PX/ejjWmMHB0=", "A4dLVUxbxsOYixYBYWxwdWo/X53kDt+/vgEgYx2lQPA=", "LrDLbQFcSK2dMGWlBf1CrYEftw2f21wtU3hD9js3jo4=", "EUVCId+6e9OJ6PAxh6ByOChCimu0NMbXvyC/5f0RS4M=", "KhDBQRCDjGkymoCwsmE72ZQ6P/0l9qHpUdCpD+1OqP8=", "HlKkLRUrhdingHKI9vcOaWNNp4RNmVslT1GHJOTDYJw=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LVTeB9hDgWAQY7bpvFB8k83tPNq2ysOHjNw8KXICeLA=", "AtjUovdi899zNWumvt4bAHRJME0GKyJns4jgWMMNMh8=", "EJ85uq8/yU5z0E/MOTprYK9sbiDVlT7kobVyhXtMDnY=", "EtUBpxEq7/zAOeMweQ/7Zro5DR3eeatf/HI/n7rih1o=", "EEqMpTdgrV2aYw2Fvx0ogPyOIql8JoZPZZe3jM2o45o=", "FWvxheYYyC/VYi2Bd55VOJQSWNHqPSaSP1mwAq5/SMU=", "F3d0kjykJsu1SCfisO6pnTLFdhAbrAc5ShXYk1Tm7d8=", "ETpbzrWSdFSfwYAdFsGXQvyPwhOf5YTFKnu7oqMpkk4=", "DGUFynR8s45DXu0keGYX1b9pA0Eyp09kZMboAvofq9Y=", "EYBp1MS7R3mjwjG0+bsQyeUb17xXz81gLuem/A4av5U=", "A4WYDTXRTpDWTpdocB68zBJYkWVPu41reaTqF4QqSXU=", "GRYxM2Xgv+C7e+1bX3vQPbMU3nHOgEIgZcUDGBu2HCs=", "C/h0gnlyO6QF/DDBiyK00ci9LuihM7c8PjYXD74qBLo=", "GOYz4/k/UngFzHvfph6rDvwYm1VvfFSfFZbquZ0uDms=", "FSvHbQcDUrXjtPNQ9LB8jO/SPp+lxCWouXTWiqPAdzA=", "DSfeh+QH2JrtmDudsPgWIMnf5CPUfT3kTP47JzvCv4U=", "K1BEBXKgiSscg722/SA3ya1yDxMUF5j4hXKD4BsSkOA=", "C1sNj2J45B/1fL4YvgOONGfxvMJVFWpmDP0Wqi6prGo=", "HEu8abp86DwbIj3dsDBEKOtn3/RhtxlQTSpVx784Ck4=", "Ikt9dyx6XW/eJvK6leAA6vb7z6UDmFecCDMJPWq41+Y=", "Ew0GBJGmvZDD5e5rz/QYHZEm9SDFbX2CMxIOhEnwNw8=", "JuH3qqZoZVrD4JK5yImZlMqeWWupkvqIY7UrMTfNqSo=", "DZEN/N4vC5OUjyZehhVjr9ndYybN4qnJSJ0i1i29MHE=", "GpKm+6kyaLQ5hFMymIU1YkyTthbS6XJlb/sVF1RV5UI=", "DbNebue5dSxWTpEyaW8wUuOaRt8cSCP9BeJG6SiWPWQ=", "GQSE+4eX7/8zgSesaYd3icuA6qR/Z0yuIDXi2QO23Us=", "KBsV0UbE1W3r+fZrwMgTi3xb5UyyBqkYCYfxEENHZGw=", "L6Rtic5oBmvxq00wTY2RY8ggPxR1ju7LruwHJc1mOBM=", "AvLO0oVTzZP9ly4jHe2hyLU+wzAOlhfcqtDS0l8tYfo=", "Ku5UhGFmMsdRE0bUrJAOtd56BJlOuVtDQ9OvHjiPp0s=", "K8CFmBM3wlAPuA8iWdVelWlj7zd+weIHHIRjmhmlgfs=", "Iy2Rd9I4p+LZL/EmDmDh0RmTZfTNb5Ed0IMVKXu2xkg=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FS4jKqLwtc6GqbuOx8kWpm6n0+ztIMMRn6SzIiekQiQ=", "LVQTgVVrLbDpNMJEvU+Ou+GY01vN+lbHetcCzitMDFw=", "AuPcC++CYkFNgCRc60EVEUZ0OYefU4cB6e4JT3wU5Ag=", "FqAR0H8F1qoFnVw57CleJ9aXuU4OuO6A0JAlNifVTOE=", "Dy5x+4se+mf53p+h8qCJz48amVvy76cztAzEBrbiXM4=", "EjHXd34twlOKagyFTNpZ1zTwzgqHe1JxodOMZ+aCBo4=", "JNeLhSbnscBjfyeXlokR8QFGJTXh3016TBUbxv8s4EA=", "IqmINkot6rws50dBjcAv7zjObIEe5gdP69QmqlnhNaQ=", "Fd4AqTLiZ58BQC22IfQiY0iwVDb5z0tNbWQZ53cNFWU=", "KZ4Dc81pylutLiygBP9tyhk6mqLg5R3hyJdw0sJg4ik=", "H0jbh0OO8olU3lcCmS/BgOEgSxOc2CWvZjHY6wpMm/4=", "G9/0ODrWUDamGTz9n3dgH0gJWttf+kS7MaSsuL9ot0w=", "F2RKpoKoUjNapbFTLG/ampgP/16UwrY1jKg6tYqad+0=", "G/3UYA3mlDaK9kR+FtxUT4VlU00w+VgbXYHMJKZQPiY=", "GMgjDUytfIFbO3HZBYJqlAIqgc0YomQn/boyNmZ7JP8=", "DhlJPxbwsFpsvIxu4T8zTwRYaMs2x+YBO1YA4urirvo=", "DS85PnEhTzbP1qj39PArFkwL9BFul/cZhED7kSJYPk8=", "D+4xLuYOGNPnprpr+pXoJvJ6jqCoZePHp/tOEw0cTAk=", "IqBWzX21gVNHotA17O/aBz3PdTv/6UFa/SVGIfw3Dqs=", "D16rybxfuxmGTvIRP8THVua189Ha+4q97dOwTQuArmY=", "fCNawZvZN5xMwBtFS0MhivW1c1Iq7TERSEBPOlx0PQ==", "LZQqr9RMRjX3zC9Y5LkxS6pG4YeukbaacM5a0IquQrE=", "GLdTbd8rrzGPfZXOrnwFmJiplwmbDgBrFKlhlzTRAa0=", "B4NUk3LYMIBMzPm/yt8buAXfDNdP39iljteLLNVJMDc=", "DQ/1ZYGJnaXF4Gkp+SESJKvBcBzFkFceQkOsU4AlHXU=", "EOssoB28ac8UOgfRrjPUZcIbAE2T/Yqz7MwzDoiXoG0=", "HK/3lMMveDzuOd7ivxMOqJMWp02b9laOHQvlojYvQnM=", "JuQ4c3h6l27mgFCNsmaPTmyO3gZ5XOVHYuqbfKdlTbo=", "CNN4qjmC0q7gj1HUzPda8rBvUqsDhk2V1Wq6m7/M5+g=", "L/XQ0DtLT50LAdPg2zGdwokG5Nyj37u0s3+ZqF0bOOI=", "GFINGgvqReDT2L9D8lujJcby/CqFRHfde+vdmslAOMU=", "SJgcUbd8rjIaJJtYDLl7MnB1+8wOeJthfo02lEd+Ug==", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FIcBUhgTj/qgpZ+oU5asUeB12JJack/TJUJNkoxlSsQ=", "FY53CSVr5bRt8I0eGwvhk4qm9OXHAZdDH18oAcuBzpo=", "I+rTHjrbVa8N5A+OxOXkBJQZKhN/NtZGjKyLn466eIg=", "DaUrhCw5UplD+/86+pw6ddWAAl3zxwjKfjEjlufHumI=", "IGQaEs4yCUNwZSxjWSGu4Dgx3i276FS1LZg9xmmgz6Q=", "DoVMR528LkZ0qPspfzNRPqyn0XBecc1AOzv9p9WU0GM=", "IuO7TWV3IN+RdLW8ch7EnqITFX4KWdD6Ly7v6ai9I3Y=", "A/NdWrmocV2zeRi3kUgLMZBJMmZ0fpOyuSLxfEqNMDs=", "Bx2RhprEOaI8UY7/5hzmi91XggTccIeOqUm5gOjKV2U=", "Clr+ZnGzmogPKVPVITJ2ed/ALSz6c54Q7AzomKfmBvw=", "GhMWHunIPMXa0gGeMgtlycD7E6/mpHOwMkL9936AYHo=", "AwJs9AMqtzytP7U2NkezYXF5/0A9ywc4aIhIJS1bby4=", "JD4MfRPe3AClpm6KwwQd6cwPEHxp444KWsgH/FdSNCQ=", "Kp/MMdW6dc4Trdmi+91L+EePPShmOCZ+jZiJI2q0iZk=", "EjVdOqp3IFQHohjGe/KS9zieSAeOrTrYtEp/JrGTpXE=", "L6Bv1yGqxYGfuNchGM/DaDWpaldGbF2cfe1if/Xwklw=", "IAmhBH+a3K9dB366odgnunP/+B1IapveefZt3Pe5VnA=", "I6/T08Di6HWyqEfNKmhsH8PFg39Bk1yv+kvEE69FFJE=", "JybdHz/f0Fwz7+VH7Zcq02pgZ0iJuY0XhqUF9zvP4pY=", "Ch95+N62oXakogqJwvMTT38iiOXmmNja+WYveaffclM=", "Iz26z8m6jG5HWICFzvqQ98zyI6sFDEkAqysmLegjXBM=", "JOfB0YOFc1x76O2XshBlrTRGs6RFQOEpYF78rIsdJ+0=", "IhixFOakk9e1t2dzaq3Ql+ythrD1iXKsDvpUal8aRyY=", "D+YOJPhAgJUOefLdXcjvbcxeyjvGzWCPkbngWkV12zs=", "HT6+3zyR5WszMcI17fqwwd4bN8T8x1BnVafpC4apiO8=", "BbGFMNfq0d/Q0wXiQkTJD45mvj/1GV76LH+TF9ty8X4=", "Dd0FKZmIaOdhaogHk9S/udmiX3y89PiU18kUQ906Pg8=", "BYYR+zLeRfa4ACAKt2441NiBUr64bs4UYsISlQlzJnI=", "L0lUzhedgzNmpsrOC7IWI1tfyDMaDvNqtAzwCIGhWS8=", "ENrkZC1N4pFD3Vroty9W+3gA1mTuDBIcmZDoiXbOuHg=", "CdGz+DiIw7mgGPd5ymnHSAqmCGih3RriLTKN9GZ6xnI=", "AfjLBLXGFV3TIZIMEpRl+AMxYfZqZimsv2fQzoYJzy8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "BpdGj6SP++8t72+IWcEnb0DthgO1TzNqn1v2yYbcRHI=", "FIRa5SVsz59S73VNbp+T3xMgqGsdCFtkLprDX8jGWdQ=", "IKDiDKlp1HxXpvvx18e+b6IhALfFnwcB1YncOhUO5ZU=", "GlSxBl35an/lK6vdHI/HCXXBkZDX4/DLb/ET7tCslgE=", "BgqVv3LUVCfvzx330DdM5WTYJL2Tca+/A7WKfCuCV70=", "DGuuLzX4M80QmWJqJUqN/aHvsqoZm3T5+pl3cxRojYw=", "LgddVOL3g3xYojBJxMW8IQcxd171ypNonY5BHT4lwFs=", "cxW2CucEzYCjZJr8MmCOhHXBuH/4iWbY5L3da9XKlw==", "HF+NIP2mQtzY20PpNh1BiKj0ja6QIbhAc8omGuUPMt8=", "E2cYIxAsrGJq5sEz+ubMQOKi4tf4oRkYiZiBVLYFp0A=", "EPOIns7hvsSl5sfwM299GTrLHNbMG13oFdrqSzt2D40=", "BikMSx+M5t3HQFDKXVgUI4nt/KrKCzsjUU6GTorq3nk=", "DDWdOo5pE3FcNpkIpX+Td1t+/MKNMAMXqcgIEtmRWh8=", "G3kGyMKeoeqlLqMHPIDGZqaGkSzVLg+IBNYQh9OWj4Y=", "FA52Nrua9soLwaJXV6fd8UMl+ZrAfjTCL6yVzCW0fSo=", "Gi/7dU9N8kNx4nSiCA3vHx6ukhsnKBNEYUK3CCGaQnc=", "CJJVdMPdbTk0fc8NGI5gO6hshditjHu5a1A74aSwH8A=", "DE1VdlL9GkBEm1JFSU9GGuBoh3HG9Mbih2Mu89nhnYY=", "LpwR+dhI9GH0ZzERdNaK823XXq7o/esJOP7zQSzQnkg=", "GYNQ7qSUibq2Z7rA9MeLGPMcDS+2FfNHWtAFC8DplSU=", "Af6qIftqpA5tO5nUZPDJ8hwObSn8RzO79lE6QP8V5Ns=", "C/5sh9ZYM7i3lj2MkJt4nTecCoIsA+M1kad73mmTZWE=", "CdMa1jNm8Z9d4xyib93xIjUzy5gJrHc8Zk6G75Q6XJc=", "IJKyvBRcQzIHSCWy3u0c9zWmBmh7S9Yta3AUdzTaR/I=", "LGUL4Z3LYAUJJXDGmBtsZwHJma74WFDddSTJmw61B3I=", "GYfaHgYwiOUF/hwiJ5ou7iukkuLa7b+bt/9/oOoMIkQ=", "LZZObJfxzp/pjsE+A+OaFBj3tYbva2JMmxT6elbUPlc=", "DkTi3RbNgTR6piMlI1zb6sdJb7NryYpAX7ZYiRvoM10=", "Kz87539Or17mWx3JQg+0eZJvcHtklORcDDRWybEUmsE=", "BFEBSM7KqjEeiBX2LgwRFVogS56EGUMHCPJwzJA2lUE=", "Eh9eUrXtbZdNXYtenVNetpwgfN+klOdamaJq/xPJw64=", "JQiXwI1bixCd+wpgox4lCev7WkU6VwRMtNHO4cs2JUo=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Fw3tYuR6JNAx4NCalznBgaBf+mwHKgrkR2yEWQJqyS8=", "B6fZPwdyC3KdD8Eep8YKgZqRXPCD/FWQyANLPimboMc=", "KzhnSBkTTqdDYUVQoT/x6MSuLcpMCY265xecjso4JBE=", "JxKJ3BdngryAKkDiuYk14fDNnM4c91GH6L2/xf2t36U=", "BQ4NSXY/mWUWnIFa1tl28sFQLVBEJylOxlAWKzLRYkk=", "HhanYZNp9yI1YmCfhXEpT/MTS20pAIGJWKu4Ae0loqQ=", "BVvjJ+jpF320jngThcfLn6Hq9/lErVgGuAQNAhMo/0w=", "HiGPiiOBizWKkwqqxogCUOqoFPTl9Ks3ILy1PNsfBtc=", "A0T/vfc+AMWslgO7ggXt16ddRKhmPaAo/WQ9TW9MK6E=", "En/mvKAXivk/Yh1cuMDwAMgQlvC22X299ReFrh01WBo=", "KG3yI2B9lbuGGknwg7bdnqxYtj3umuqUuH9KcObgblI=", "COPlb/QFbqDM5yysfxqzo/A51ZSL/iTFlmcFbt5w4f8=", "BVMChsDn6uDGtpOgUD/QJxeFsamo0Vnq1osnd7B/tVI=", "DlqNxU9HYqgI44T5a5r0rFb+mgRqPONUzj97Av5fiEA=", "Eq4JGi086wUCYvcyNm0EYXJWge9qLJjmyyJG4IIUYvM=", "G7ErAdR2+y2Hnj2A44KUCRZwZUu6TyzCVWv0en+j5TM=", "GDQI9XWu6sCFpgXqmTTdRSlMdmW/NBfC7lX+15+j/04=", "E+0GjyMl1gmL+X9CAQE8nMNmwiEoFzA6VA+iGlMLIYY=", "CGoYVMwSYS3cKdgTCiJESPuz8H+s7vHEV7IShly69/M=", "KOCQX7KwzaJIBQdgVeepdEh8Fj9uJ13m8KecKVP0JoY=", "E0gqfovxfL8NcpqHe5N0ub3DgoGNCCnfd4UWHIRd9aQ=", "BBHx66mAocIkbp27/JXtUHhlkemXBu6pO1D9TrdzJ5I=", "Lk0u8p+nhVqEecOF7lheGRr+BeSUjTr7JhcTrjhGlEo=", "FNCwGLMyIj2NOkWFNv1LssirJ2WzXPvRtPWvK8fuu4U=", "B62msFoV4ijHA+od7tDYmgkMiI4ErquTuQMmDTH7Y6s=", "Ar+PFILUF4In2puoFB+Y12TX0lcj0SpHSgqvK29QD98=", "F3HsXo0gKvn7tabM2SgIBp/5ihA8o45gIW9MKb0TgCc=", "HMRYGDg+cfqrsfCUen8uLG/fhM5Dva6zEI65XIU7lRw=", "IcpPuzjF77SJqFjtm1VQy+gHZYB93rVAOVapHTvqOSE=", "CyZFRMEUdEut0UCoExJIbG7OFQhRB/5BdD/7xCRXGQs=", "Bj+XPY95VbIww/Yj6GdpqPH/9qLxb1QqpdJUUNd9+iY=", "DKVnyMYHS6+Jds+xxdby0zndabkcO4Y2C7crbN3yoFo=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "DoRUbUMVbspuqZRaHwv+DQcMe19ZahZdb1stsl1wyJg=", "JVIkRoE3+lcx9KeVMbDkFGf8Fnpz7/mi+GBupLiFQVc=", "XkROC/swAlku3zsaF7YaypbMT1U2nqC4WNAKJClBOw==", "LJVHzIwwJ5Vy9D9smOV9AHqNjgCv4yMvIshtks+zMC4=", "Eo0efdM7in7/OHcSEMPi4yVCknq4pb9wswTqxlpeiaU=", "EX6lUDh5iaJyZwWdBOqycXHZetF3tHIrkHaseFBGklk=", "CcLZYoAegUJ0JMO4KjwlkPPToBX10F364D8WRuhbg6g=", "JtEVHDTURNYTgPYYE3zRLThWpREsGiKQh9Ujf841JAI=", "Bx3iqpWTpr5g2CXfmPQzzK/1aej0VLV6GpKjoXlBm0A=", "B4r2lcoZJtAhGgx0sVymohshUwdRtsifFqdlPXt0knM=", "EPrAJK+pKXT09LQ3d8MfDq7IOAaOJBc0FuPlXxj3Qik=", "JSokFky2lpcPJpaCTterQKQizS9WHBrdWnuU2ch4hBY=", "LcHMo4BZm42cdFJPXzcOzEHSLEx5Jxen/5GJPJ6Hi9I=", "DxlwxWbIAspR8yjXphZocyZguEcB283HOI3dsNUD0ys=", "FEEK4Ua6GUQb38mfiP0kJaMEWO+BqXywdXJ43nxxtuM=", "DqndOXBsJ9p7B0ODh3FMjphqN8a8uc/gqkE+2x1CZiA=", "EqDsVyFNeDOW5z5mzY0WOuIHr96gk/YsoIwdA4SeuB4=", "FfbjzQhotOO97thnDMvTWwhLLsfZ9w4bDhv5F59OeqI=", "Jz/6P5a2+ZDlusPakSH+rUxV6aU6TMze2O93aHd+BLc=", "Jlx9UDAKzNRR+dEKBWoKnEthlgq8esB/QFVE0r6YHNM=", "JXBOyCvPJFgXwLDDhCj4Dgl9GB/kvmdMVqQxcEuBIgs=", "K8AEpw+Tgl/H3aRhFkKBnVZn0MhN4C0Qj6JOdVOo7Z4=", "LGew6T3s891D7PKv+2yOwmgbUw6J8ChZJkn7hTq2kT0=", "JdGVcJMAXE7d8PUJYOxmuwpx6Z3+Y184giJLpQ6ioZw=", "DAWq199hBTm+5pD/M4QmcA7lcBLf5EtFYEfBaNnyMPI=", "Cgn+tFtEFoX5YHhPIKnapnn/7YNDmX4Cj9Un8clhXxw=", "DDMXtuDxcCTz6NSNe+eN5R5gA3sJiTX3FcX3r+7uVVk=", "GGAC4AaHUBXHmVtRKrKXubairOL4sfIzhPVFpHoJ600=", "BgfyGaCkLWWHGAOUb0aP4amQl496fcCmVlKCJAvv6F0=", "CDBUxzFT8llCgvQlr7IbwGB2ggoqk2yi6IqpPRmK2J8=", "HSefGKSySLvGG/Jkc5S9ztD7lcis7m3QNsDt4MJQBJ4=", "Lp/eibotzs9KDRGBW23SqTrQB2YLZ8FOhOSEVSG0d1U=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Bmv88Hpki86qGd7BAx+rxXOVxNyjUDAAqY66GcVP6XA=", "J2rH0VafZx7o8j6mizSyAEiLp/GNkF5nqwFIvKFS0lo=", "LyDy9CYYavDuMhKCsAoqZB7islE5lzTRXhmvJ+zULeM=", "HJakYOd49K9QFfUs04zyxBpqnoX2owu180NdvMt7nk4=", "In2nyZMP3ABHbKaShylBG55lvc02GtJ7ZuxMTltSmlc=", "J7ESexzm8GhuByLVxaDPiEesaN2OtJihovYSSk59Pso=", "ClEMy1L0RsSKnYhta3pnBWgDVlAOY7St/ENgijDA1a0=", "GHKXgRp4yEXcyCHYGT0q4szIvm/AVS8+gQ7ZotBE1/o=", "IpeT2YwZjjVYOK2UENFpMOiP8B4KhrgHT/dTNq//WW8=", "EhTPbGmcRu+I/zcTvp877sTqJ8r+7SkzJsfbQWazHOk=", "IJnPrMqqyyXowXMP+dkcb4L89DZYmxjRoJL2HHZq+cI=", "IyKGaFTQwD29iRvKA08XbkEd2gQgO0fKBMosKoKqXyM=", "Cv5BhPuK966Rd97ZOvtR3/VQyQ/Uq2JMlbngvbJ1/8U=", "GJgexOey3Vt1BXFxMyFQ1i4uvtW8Y+5jKmzLQUZ0X5Q=", "H7asCIb52vzaB30nDv/rk6oHTCamLqbP0UG4IyTf9VY=", "Kuraz6hBCkwHq9p0v4WAa3A0eFJ5qVsXxux6DsvE9y0=", "DmQNAeXtJDlhvUNh4tO2abzFvzW70wGB4jFQPg6gQyk=", "LoeLpXHwrkPF15zAS+zHyOZTFsm2uDwM1WEk3VGWb/w=", "DkZxVIME3GMB4wNgAW832CiehXDE/dEYnMf628AvZxk=", "BJ8yoRBDfhVSrmFj4IkNU0sES74v84OeuYCscrFcqD0=", "Kb5/0hTVrDoh6TB3PqRATK2Oe3UbAuGGcR4HeXNivms=", "BtQkf+dwtr9Rx7c5++zDqkGPWSDu92JGdoNawa4GHWY=", "IcAqnuyJShrC61bSdBCtYgEi46Wt+4qPg+5hf5Uly9I=", "IytHBVgRIfYs/yt50MjqQ9tHUU+tx0GzMGppAKC7kCE=", "AqMTfQ4KmYfQby/S3J9hwi499V1JKaIyIkLWprNuYUE=", "EoFCUKc0UAQB5Bxl2olJZj16/oxoaGQ6Hf0IY4nCnRU=", "HSIVh+as3NBBvA4WSpyoSXCAfeRqdnODxEJiy/ob+XI=", "EV7AhdqKODkhKuSekyQ6JfOy80xTtXhtVXbopeYmMZ4=", "DN0I1ccQ5JelgxZpIzYNFiFa2aOhYp2qqwWHtF3pULk=", "CSHEVPez0ZqMdmh1ljMF9LTW9/i+GixBGTFd/yXBEag=", "G4fRMtCP5aZHiyzk9A1zuNRSL+I6SybpazHJu2o77Wk=", "Iq4r5Vuzx2QEdyhr5ol3bhUUyIcuHgNh7jaxMTjQ9vw=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "I3rGqq0uKt54u75GttU2RsdASi+6MXlcMx242kFF5aw=", "KHcYn0wNn+AbqjOiuCC4Sko6i5KWTqnHshSeSiVH1Sc=", "E2puADHSdyiNWGgkmUzdPaMiIfyUvZyWHLtKNxxtFuQ=", "GKl+ehIOefJdyHZQpWpYBgStD+mae1yTspW3Ix/BPjU=", "KYqJAzBAjS6z5qoxNH5NaMG7l5oj2ccmbmO0dYD6yRM=", "GR1de5WnObt1vxnWP454fdFP6UVAiqmHx0msAaTl1HY=", "JEni1SbikgYn2ZPu189N5XFVoA5fBx8Fm5Tq7XNkWzU=", "AaA2TuaMucinoOgB2q4MzAfZK4Joa/W95ywHQkf2dno=", "Hoja7yJywPH5eSpthfKbQD3usfTyNFItKBEsRmeQznE=", "LEsNHGYGKvlvccayPqdw9eU8OZZ/DTsalQ32fJdmQy4=", "B62Gn50T2bJws3zyVbV3NGyihviXnlRhgsS5E5No0YY=", "IBXZaTfoI7SdjrL3vPO+gqi26pv1O1/bUqS/csQ3Wp4=", "GuguIijwCAs3rA13CDw2E/rYJCtCDeGiT9Y3bNyNefY=", "J/Dr+m4uyf7SOiXAfN9op92L7DnOBFwV+g6SG3XfMd0=", "GxKSEerfSNIo56E6m62gQu3VFk6lldUjUDcnQZpbalw=", "FUG0471C6Sh7XgveWtfDznbdMmoOU0GIkgZ6bPu8G/E=", "A8uc/1D02dF0/+RuOCGE2amTBvNQlxFWuFnXbROkIA4=", "IZEXbS/ms2ByJ/F67NcR0xrOGnGYeWLatZ4tTb39yj8=", "AzOpj4SiIKWbI7QabuxfEpOq5lqcFBL9vQW2xzDn/oY=", "HTEz3Eee0EF5Hv2fRJrGt6KrZwicKurcAzsSOJU0yMo=", "EalXyKzAQ+HdAiijvD4spQVNrRPBxoXT/RxwFdxUG4g=", "CasdV2TRqzcncOcqc08yNOlE8jHVW0gC/u6iH/AM/+0=", "KrB/ygCa43hNkXLNDeegOrG0EyB3VCSdVOARVnHGFkg=", "LybctbAUtyv4p98BAIR3VOwJv2mrIwUKpqtFuL1JqLQ=", "EoMZFDdfq0vwLVkj1PsH9Z6n7Hb8Qk6tqGIof6wBIao=", "DwG3ZkZN8qlHF+C1Zw22NUaBbQ7JUedPq9IHA2RRPhA=", "HuwVluByFfEgxx87f+LIcsDR8OzCRHzQOC/8Gz10zLk=", "E6nfP2ycA2PI6Buy7AasASTKzDqvv8uZzg0SsVwdlg8=", "CZQaF64e2Nac4UASXEkwbK6eoKA3VjzZPa3MCcG4mUo=", "B5D8PUR+0QWL1eylfTetuo1kXVxC50QeXFCObLKn1YE=", "DhH4lR7cVRrcBzMmE47zST7IEu1kNADFPaAtSQM5Y8A=", "HvUNQ44PsyYOYV8gRN9AvPcL+txrgZSBIi3cNuOc8cI=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GabJ5RdUoboKxvKDgapFPpKZUUA3lNP1dWatylRZPO4=", "L+KzICegSKs8n+V+Dg5jFowb6r6cw/Uyi/xuJiDRwKg=", "JSo1OGXRv2304kO66mEtjWeljJuRtovm9quf1s+m8FI=", "JEW5RaZa/SyMbR4SIk8OG1p6TqFYpn3UYX+NQII5vWg=", "Ku3DqD3DJKIfwGsG8TlNalY2wvGR8lLp2SfMqzuKR9I=", "Ee88I3Ktjg/trSral0DPEE/d/l8mp0dZ4XTu+m9arkk=", "FlQKT22Gc4iGbnmk8yfFC8Bser+I30+rGvVblpPAgz0=", "ImqM87T9k/sCdgKoTlyE4Z+r2zxrBkGQMQcjjnRz9NA=", "FYKZSTMa7PAAap6PRvAooT77d1SXZyFiLWW2+crFdW8=", "IZoGM8v/oSm4vmZMMqFdjG8wf7APonJnYo3op8vU2hI=", "De884wTgsfhopANvtii844GpKTHejdZY+aTbaYCMLFw=", "K8y82iInDWxi7/uOOSu3+5djeZO8ECU4xc1Y6Ioiik4=", "GIFy/ngdexgEyYdecyrlupLaMOP+eRkxcqmyrSZrkS8=", "HzDl1wzFFMeKh4KZ9S8pjq77xzgR/WmorwTW4bI1+Pw=", "A23X6y03xY8AZO9TnECf8bKGbz43mVoOa2PS4SeUpl0=", "KUPRccxnjUs+e96fuozGvsEj/Z4YABcEB0xrU7LX+lU=", "FtO9mKE2zG7RfXHn7RUOZZvCHjBIWdfpHbSnUxGxLBc=", "LMRjYZVLFW8i3qS05YNtAXrV6Gbfb5F5aWg26wuezeU=", "IJNzKZNFjB3FB1qQdy7rKCOVA+vSruCwgx8lO1eV9DE=", "JvsKM9i6mfnWZv4iFJtLnCiPejVvfU1iygGcQm6uVvY=", "LKnlNEkotMX29tcuxLv58zFWO5P3jFtsaT+coFoDudc=", "D4as6e6s79Ez5vnlsn52jU3EH6ikttC2Q9WamblyuX4=", "FqplKMPlygcGDUDK8gUPx8EZnz6gjEvShB+IFvjdu7Y=", "Gq8KNRJ1FEGrr2Y7UbzMgrSqngMflfxa2DG29RBLMug=", "AWk9EtwzNzBlkhCUxv+1nx8DYbDFzhsg6PP08broBd8=", "Glse7F2FXMcWq6zWte95rUgTvHT6MmXg9JZnaAiOJKU=", "Gpghmql4RfA5MJrjFOFljK8zxyI11aBFoRIxBI3IWHE=", "J9OP6y88pzvm54svUduekEvXjT9+1JVjSyLCmyiEeUM=", "J7Iet1FqhCILx5xrpaNf3gxYBNTcK0afA0+TJFzVjmQ=", "EIgsxUx2wFfoTilthWj9aKQahrtZXP5kTe9d7hbitgw=", "KloBXu/3zUjF+dZrruZkfr9B/nPxWZm4Wqc4JJZn+Ak=", "C7VcqOwmNZMIGn8UDIj/DsqBVIzmwvxm08kEHn5hpS0=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ealfr3eCZE5m3WkHcL6NWK/5shwlKhc1MVno5qnNLQQ=", "GAm8T3T42g5WMgF5s1z8zwhTGjg/jzjwVVZ/VN5AiFY=", "KVduvotHKqs8QYhmtle0vq1a6+tGcxrBaGI0+ZfIBk0=", "AV/ddSp04HajusxCWsF++XSrTOANmOO3ZuTp2lBjOL8=", "Cjmv6xF3LyC9RCEsxSdNuq65EsBzqxIKDjpc/y+VMhs=", "G9PIOXZ4DbdPS/JhtglQW6F9QmmoI/rDYBOBQvtIK8I=", "JFUDWXWVIpmvq2eOkBeAF65ZwC6ItmrL/TOpqX5AU+w=", "D1TG5YJweUDTeoEFfgMxlnMo8EArE59AoVKlNwUNTuo=", "Dz7fSxAh357nW/dyiONcE1vvLmQTF62/8srNHNY9+mg=", "FaSynvLePmbk7L2Ztj/nhMPRY1NAh9bnUpNeOmaoEGE=", "Ai3gHFJe2sBM5kGORN9iz86Bq8MjjAgypXIegUEBJNs=", "L3XPuy1yqTZhaRs8MT1zy/SOVwr/SomBVlaR2+bnJE4=", "F2IV5t3kWLqU/mzTKIarSQxE0/NXCPuDrAMpV0d0cOU=", "ElIkZRYyvq4jYmifPymMPRzd4geGtwDPFU2t8ErqArI=", "Ja3ASAq5BmKs4Y7XHU7CQ7XRGL7fhmiA5REieGIWV+o=", "DxZWMjz1EsoT3Z1Ttv6kjQvAO3oKUQodHDdtfIecCm0=", "H3/KNfGdm8mpxRC9kER3qCp3nfUrPZOKNK03C8vhB6k=", "FlDxDXAgDEz5GIrnK2OKSO+ohdDVfk7vO60ZCBF8rkc=", "Lvperw2YSKK6BCa+yw7bQSf0r6C5Uy88yPY/3G+fFKM=", "CtQCwUqK78sNxntdPB3xiNHOzj3g9TyzE71jBZTiASM=", "CYdOeqyATgpywh7/aADZkydjbBvQV1LNOYwuGSEKksI=", "En1uZtxN5ycrwOYXTKQPSGGOHJDOcfFz4DYyeObibts=", "F4sNIZ3J+w1JH9yijYnU9B0OZQwp2Al6bvmCo9RWhu4=", "CFZWNhFifZ0Xb2KWaMGacZWwvvg6AgEUhVlsD7N1lbw=", "BPAeE+fgHw+2B/OaM05axaFGScZQB98uASXSwH8WX0w=", "L90fakdG/8NyH+YBsxM1h0ojwDU7IXzGpl+YtSxIwyw=", "F3MsyaerdWs+0k9LXNNIsnxHawgEpH6OgCT8oouFgCI=", "CPnkol72WITdaxWcOWRH8R83TPeBqJMrQ25CjYQH77A=", "GFU2NkAQiI7IJyY702KCoGCVVgIZIK2DSRWcgNaJU5g=", "H9CHn5Yot26vAy2wkrtsr4oDxDeo58wMgclTEhPWG4s=", "Ei/AKg0G3KqLwbpS3HkFyhPydmAjqOeBGHYHHLC8uvg=", "CBMAUv/vf73G0b04M0IS8083FfC9HfwbNutYMx9ekQY=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "IchUU7XI9Ts+Q0mRWczvUVL8m8OxTPHWfkqA5JvYOw==", "Jz007WDpRf6XK2fCwVVlPhxcOMTN/3xXU958aNO8MmE=", "Dtj4wLZEI4lWZO4EyZT/vxrtFuuPbSwFtG7fB6VtJ3c=", "CdvBYsOTdc9iR94xWoXhcwxFHllnFJm3urn3PsR8cMI=", "K8wyjbfFcfiS09k0rnwDF5JXHXFvUUlOixD61gufUq8=", "DyMz46ssejwTQg1DgPKo/IZ1ONt4gqX6ao2JnkmBiJo=", "G+u9fD6Itj7TfDc+NZp0GjjRuN5gitzAULBR3/e1FYA=", "EBsc/OCemvvMmVruhXEVdN43H/dqKT7LJrR5aha8V+k=", "CYZrh23lOXPVSqAaMJVxkDHgpep44mGUQi36qAx+Obg=", "DTS76t0QoFVqQMsOX4T/2WuqgmIdfYUCYBFTEv7xpc4=", "Hc3N3MCqfuKFIuWzMbKAX7laddLpD4dpQAkcTFc0VDM=", "IiAT4csEtW0jL4BmZPS5UL7hyJZdSd/lnH2afze+cKQ=", "FA6wpA9gCYm8cJN+L7PbDhy/TulTu137EcOsJXEFrL8=", "AcKhDAEEaivQbsoaeFDYgV26nctQAnENRpdj7hLOcz4=", "BL5cnBoW6vJPD9YmA+36sqcxSIxvAGaim92W+FlfkD8=", "KqG9dUbBXQVFLB7OwHvhqW0akW9jBvEer1IUW+PvxB0=", "HqnXEIBpWCxNtAAP6cmZ1QpnMv7/UAme1YY5lqD038I=", "AkSwI0bB56oiPhzXPMhN4canKeciQQvNnGwhwQ+BrKM=", "CBjzgilPDSrR5QyQjW1YsFZ+rORSSRx+fi7I8C3N8w8=", "GoidQXhh8HYDMEWBa9nRUtw4pkNEh2Q1xDFFVR6TjFc=", "AqdB4PGEJJf79IH9uDivdvAWx8f5AtDxz5GUbZsZuPA=", "BtpaV7oeHw4CtlJU17pBcK2fQvjC4gndNILZ0QDctpw=", "KwFdl+mGwi9jnUOZWOVYIZKuKjxeY6k4du4s7wHMZKo=", "Dm/YTs5EBTKx0qhHlKLAkF0U3t8h8cuI7wEdbUCkSWY=", "GAzED5saVR1vIaJhajH7FK495s0/kJBQkBEvCM0qUX8=", "ETva59zbVaWilEngGWp8oZeF6PQGqvgddPfGWGBNe1o=", "CuoaERuVYjjiA0vYLrZWZynWt0RzjQ+QfCTpHPDicNk=", "LYd8DTY33MvOb87RTeDbGJ6jfiGSWV0x73vjUEK0l4k=", "BkoTaeVDmAFZf19OKpUFjgAcw7fUSaqH+ZHIEhlZBZI=", "EzQFu25eJFoOw3hc0wDtVXBvRlGRzGrwXev8Cf8yPu0=", "IovKf5OQ4M/hElrwt86ysij+fTc+O/4Hc4VoJmndYjE=", "CQEWOE6laQgr30NzQcAwlKHziO4hfA5qujmHpVz2LT8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Lc7cwSlZq6G4FRUOwkBR+03YRAIIsPTu9wbzZHCf1k4=", "BKoFCeepRVRJCIXwvABVtPI6AD4Uos3FGo8VALc4USw=", "GtO2Y0pj0b2X2NdFiIOH5wML4r1SGchN5aSyH25tXJ8=", "JyL/kfqzEdXNSTMFyi5YHSOrNRA7ejHXQ2+0NR5RZ8I=", "F1bjT3rwvjLcQxLJFKxItg7YkuCpQYZrWZDEdTJqCgg=", "H5aBom1YGsh/xIbYRTgqqK+zF4L83BauPplr956JENo=", "LEB1k6pv6pRtDsEonlncmT28HWiaAu/v2RbEK1bU4FY=", "EtWh81o77nvoe+tpC+87Qi1NsZ8Y9Fc0XFsTcyIT3kE=", "HkRNRRDiy1QqS9GvUjKrg3blmY9pGTJDUJsFZItZ4xc=", "HFEYa9Vz9tjjncnl+FrZVO5klRuiRV3Nn0FbLvRIE64=", "JMhGF9DwJm/PGEZOsIQi9RYzkVOAaWtXHfzVL9yrOCU=", "SJTSb7uWlFQofhVgyB8L0z6ToP8ONg+ILwNiH/u3JA==", "DWaeFwxEKAibtJDorze/K0iF9h9JFU6vS8poZzITMM8=", "BU6tHnCmiipb8PmDHIs34MRpKECl7szi8QhCqp/0x30=", "Cv/LzKbTU9wAYPbA6Hp+1pJtZRji4gGB52sOvD5Vc4s=", "IfymIQFqdxoYHvyv9TZHz4rFXDCBPH4bfgxUsbFNT+E=", "EvLkaVe4iRDDDJVU/QF4DgdIcPud8CUstzXexw391t8=", "FrqtRTYaUFLGAIoCgDZWEI2Lzxq2Xz0e6chm4qBPFxM=", "ICz9xMuFznA7esQcv5BFk0gclR+fqlLkRZTD0K/18HA=", "J4KDc2Y2bC+blDcU5qEQlzITlHE1d/5Z2+cqePTZN0E=", "DdhjvG6aCr2UeyaEq+VVomnaHrekkepsXTxE4MvbwNY=", "KxqwpbVRbXpPMbaMk/IWOKO7ue0yG5kVQStCKSno1C0=", "JHxoTMhy31LCOW1S9caR5FnhgVRs1kT7pBhDvto18H8=", "F7Cb69/9rMbTq9/U/d6wodBBUFYxGd72DZrp3msT0Lk=", "IDd8asHWZ+6viOABZI2hSeom7LqsrwefCgif1uxCaU0=", "J7qui5qToJRZ/0yIFQuT6fo/3rTXGdN+T7A7Ka/eGw8=", "DhBbBNHW77De+d0/Q2VRgcvkoeoynnec7DNeJxkNCEA=", "FoSpRjsBKG5d2sdrmQxq4oXIH8T353FbHdyCflyqgvQ=", "GhFx0vDjwTG6tO1hP6ERu4XzYFAoAo9cEze0q1Qq81Y=", "IodC+SbBEsRDvC42K+ikTEntZuFwOPe+KX1RSCxUitQ=", "EL2E7qlF/rtH9yluW7gzN47Cb2HDbZVLh6VCN1Sw0dE=", "AtF8rJbyJYmAOOXsFlYPZWP3aKfhJ78Q/4zhu6Y9Ay8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "IwkdYnTXLwUWwR5SxiqJ4sIYrPzsJp2FiCRrxj2v0wc=", "CUALfpeBK/gyG5azxLtpXatQmTThl++Tk9mSGjIP3F4=", "HJyOJpt7XSUn4gtdNA8peP5PC5aeKx8zta2KzgWTEDY=", "KbyvmXj+MB7mTwMvO2xa7kf6iaEYSQ7Ol15HZaaI4nc=", "LEPuRi5eqldAmISkv4IRb8dPBgzT7YeySQZr11PleDM=", "AQReqe/dLTdlTy9Bm8HB4H3/wTp454Mp1mqA6Ba3Xg8=", "C92ZDwnA+/yvsK1dLnYJ/GOfRkMmK5/mBksc2fWf6p8=", "HMOuy2XYjBF+B3dzsqwyHx41VSu4Ls+vwZptf1jMoLU=", "I0ynXtormNp6pLy9rwG5SguhFqfNTe8IZOJ7pWYjrFY=", "HlhEpHnvh0NJQW7+StFMaRu9TWC2oGn/b8zwtCaDaKg=", "Fc9LkJ7dzAr4TUWqKlzkDwBM6iM33oIhS1sbi8Jfr8c=", "Ify6oj25gW9Fn+XepgNfRBa/6p5GsasVAzX8mGpdNFQ=", "IwltGTxUIBX16nKUXkJ2AdjFITZSzHvtFaJhGECPNSg=", "Ee85MPrlVuVoiy5cW2Rqm88syMnthGmXmOOAU02huho=", "CygEoMOeBAYiDSPlGA6jR0O4IyWdxcA34n+hTZeqEjY=", "ApNhinE6524AFlQ5bx586YhfB1FdGlKuYYi7aEEc3hk=", "IIO8Uj9I8jEP0E20N45zs+SndMBMgnIcNH2EHNQpwe4=", "CvezYshIEt8gUtDgStB9gwEAB5MnVnp0Hw4zsF8go68=", "Lwqb+gJFcanq67i2yDjuFTKY+NZigmZbjUE+Z/uc/nU=", "COX5fPI5hGxLsiFRxPxrVPbAeDOdSINMtnQQjrzVM9g=", "Kte+YLNMEy1idYppnuK5uZArWmb00KFzKVf6MSaTEws=", "K9gT6oH9K+BM90Nhqp7AOJCuncnyxi45KqAHe871w58=", "LnIFUQEbC5nYoCZfhw7ID5uGagpfFYorr1ZH8H6+mYI=", "K/GLamktTGQYW1lSP9daBFpIRNjfLZMcc5+kU3QLPME=", "HBZvfMtppZ22s3SzVfsI1Q6vTfd2CywwhLIp6CLYWNQ=", "B5thDXfALppxYovblSTXWumCK5jTL1vIYk41EvrawJc=", "GRbeiE/pysE4BsT3BhSI8KV6vRrkA6sCV9IbSKDkEe4=", "DxB/ocnUp3TPwQvLw7OP1weODzdLXpvbOOHgTSbTw4M=", "Gz7xSCwVkjZm4c1drcqCZhv+wKOlj4nlT76P4kKGaek=", "Cie6JKKnrTXsU6EloER6v/zMaKkVhSP/iM/XOLAhKAI=", "GlJe1i7/Br0Tnz+ljQiMg2w4Gp74Wb8W0MTtJABGOk8=", "CCLrlkXJZdT2tncZEpTgtcdX1EjOUmb3auj/iJi20N8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GvRvCPbPGadeLeyiUKBiJEpUFBPMpxg837j/NJYoNnc=", "GDnOYbjHK9rBFvsm5o2xE2sh52KoDcJjQ0zq6T5x4iY=", "B7zSnnpGxXutMlYxudxw93l0bk4+g7YUnPfWUiQpnME=", "Cljes0oap6l/vW3lUpStbtkRcx2g8Zc7swzE5Q+XRjM=", "wYmGLXZ8nVUSi1X7rSxTw8fwnzzDgFQEurgdiBwfeQ==", "A/CPXbAsjEGX+7dDFj+pjiFQk7gzygwdcJowUX8b/2c=", "G9mXxa5i9GpPoIxx3YKB+iDaF3xFpbXg6ky+QqnXaLw=", "Hc3GFaHSl4bCprnTVuFfFLBRYCLaDII3Mp2c4x5skGQ=", "ISXBBl2MQq8NvA1EvilyPeMDFrsZDkh/rHnGxlGAxto=", "Kp3YRrmpJQMD6hjafdL2fYUlB01CWWVrnQ3vfy7gGNE=", "Kh2kYKtwfzFlOGKrbfC/r0dNOcuQnXuEMUSCrYAVvLg=", "L0YgvoPdQqmBDO+BaAHNinfVkUZ1P9lYmkQ39DxE4pU=", "I5C8PuIoqy3K4H/XfS8rgrOb5KP6nRWoJnjUh6TO1+M=", "CgJFrnyTqroRCXlWLxuzji1uR/j1gUbC4K8ppCqPIiU=", "J+PZ98DWwyqduMeaP/9yJ4JWebrEScxVZ/Ie3CE9lKk=", "IXLnQVH8A+sgHj4wCyoIV5jm0nQm2pueLs6sQDdMlbY=", "JGpoUkapQD6wHNs4Czm0mzXWSRNocJVCYK/CPlESlGA=", "BPBQ9wQ7GDzzX2XlWQvR75saiLmhFU5aa0i5A2dnnM8=", "GtWMcKwTcUtyHH4eQ0dJg1JL9e116go3WWTBfu+Jes0=", "CdNxnVIYZCHL6HCo3BbKEtR5RHu8G3IJmR0q2pzdBVI=", "Cy1gW4DS0WuLzJNr6RqbWL83IWDFghTV0FNAJo2yk+c=", "Fe/BvhcvDBz4DCiBYWPWKBeW/j92dEnc5wADGpgJOC4=", "GKcsp1gGGKZ3LcN9otDsNyETCpPtK69+6KRYIVNRxb0=", "GElfH6KwlXOwEipvO7xi3I7aDHc8JM/slGYxvSJqUiI=", "IoNeUVNQc5eDw2HLdFQZAyvm16FsJ83nds2aQ1CdUCc=", "D78fpTak104etRfctxXb1X6ch5/dEYSVbhrqdCxLDBE=", "G/pK1ZG8Ak8Vb2nBxs4DPmVQf28qG1D5o3Dqlt/7T+E=", "C0juAMGjuHPaBAgiyNhKfUE7B4BsXvbuFnBQKieXeI0=", "Gwwsn/Fkn9oGFVr5xAGVfa0GuhHJ1sKErD1/ay4CGW8=", "EbmFfHrB5V1mlrkyPqzSt16OZNhjIh9MSbUMCvTdyQc=", "BNKRPkNIZLytzQoPGHdR28/uaPjULtoAr9+fzCVKkpc=", "DUeoa6TkwzqzfwCq7++s9pLBuvmzfbBoCX9hn0QGH7E=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LuCMDk1/Fj/NETU5tL521bjG3MMGmUAW4vULQGWsDGU=", "Lk7jdx5XDKw2Fmb7tiMAM/DS5d9aQyB/TIxGQvycpHM=", "IueMm9GDEdIlufiMEXyxjmWHR9UAu79hwpH+fr4r7Q==", "GwFc+kkPpwW+O59WRdTaojwgmMsJOfAZ0WlwGbAKRDU=", "FT1xZTKxhWtCWwfFz3P37EutNFj/ngMdbBkdoMUVD1o=", "Jd3/dkXBzaq7UqOuJpMWIKQYbtNcuRSwy3a+xR97Vho=", "Ib3qcXR6RRx+gl5QjuTEDfQEBMARzV991iztBfOEFDc=", "L+2mLbJVtlXzvpakhH0vFpHOZYRWaX7MYCWJw/8GdNs=", "DTGHVBAHk2ljzUu2yTWWt8+lbYKN852fj/Bdk03vD/4=", "JuYz+XDbugOP+jDXNf80VBEI4ve8Dlj7JbjQOOtXTB0=", "I8hHP5UEvAQmb6dr9wZNiYD6yEVPv0T2jF6T/De7/Zs=", "GHp6Mo6+MPP+92IOxYKuO0V+0djf+KMNYMUYwdP4UCo=", "EHKkGZ3VMq49NvLD8HNZFIvk2Byh8ewGvOwslLUAMNU=", "AdnJxkzO0Zc0xW9i9q3tzPVKrbFw1JmpFhfHvDTwIHo=", "GwmUUXmCJRG8Czsgr7dvFGsRkFHixsj1ud3gPMdhsXA=", "KdE3n0DAnZqBBfGBT5z0z6hBnVRCwiV1oPmDb/ZyghY=", "IAgJtucRQISiOyWcxt2NSqm+yj7oBlV6JQ+YUjNj1YM=", "Exafh/TVvNyAJ3/Uv5MXRKCdSwMy5OVNw1HsFvJW2yQ=", "IkhtzStQxabosIzb4BKQcIOBcHO5dahCdRqqSXOJoJI=", "mGrtexD8nP9KgNXjOPaerkqiW0XZMUmfvnCA/hOoQQ==", "KjNGyXSn+qjwIccrS1FtxScDPdlt2HopATpU/yNQadA=", "GsCEh7U1M48Y85u7JBDgwE/u0bAjwrMaacQoQ7Rse04=", "LbTrJCDVcSPchvgsKJeI9PWIIUPnAjfteu0rMY8vP2o=", "F54Vbw9iKeYlnctlba3bJz773Fe3ixgAs/1JKtTi7oU=", "GPHtQsLcqZW6aytBg3gVkAXaX9bUbzHUJOQE/fhezQ4=", "EtHdsxJcFcYeGgdwns0XgsrZKDEr9NMtq8DzJEuYwGc=", "GaVV7ppXsPJJ92LmPwL8ncQUIVaeQBRtJ7gF1pJtvRc=", "IpBQOeuS8GjaTafyuv5lsXQ/wqwV29HftQtqi4kPyTM=", "Kq0ws/2liMQzZzIDI8Zups8xN83PEwbpPRc/Gl9bqwo=", "BmHZXa/qPaZYRMcxR9hrihUqDHN8ZVDSpZBZe2viiYY=", "FJ9pvuaxJSnSoTMqIv9srkE7hk2lIyGB3OUoNDSI+5w=", "L0AQfaLrpOHYFs981IiGGGOkYOXgB4DDwH9WyUYJayQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "CJUXOZ/a/MCQ/6y/oPgrGjVsGCqbi+5aElr6FEFmk6A=", "AesDIM5o5cCoubbIzu3d8u7EqN/8d19DqpVF9EMvFZc=", "CbOzgCke1G2uXsZ3mvUX1MglPvYJ54o2EeCaap68+3Y=", "JxLqReqIpU5Imd4TP50CRUAEIJrqBDTtB80zyTBcAQc=", "E+TOxsX8t6VdLFyeDcqw/zo/fCbttcDF9bwAwDaBfp0=", "Ey9z86WnD+Er0HfDQHUuaDfr6+pOfowGZyw+DAmqJDY=", "JPWuhIx3Ze1MsgQXEUxgLoGG+wLSCbIiYu9rL59MLU8=", "HzID4pRsPnhNoZDqdmKNmM5GzsUNdyDGKJuaELApECs=", "BAWxewknNk74oZBHLPacyPuRM4rQoDemzNa3HT2KVyE=", "DXvpCcbSA/fruyb2iMEEWZ407a171Pp/wRxr6NIAUjQ=", "I7hDJmB282DCTjmvUKX3St87oAKFm2u31QOr9FzJ0zg=", "EuzcpA56WrUTp4hi13+QQ1zkygg1qWYRLkJFfJNSADk=", "JICWxHMHHHwtXI3YQAbCRcYVLg+GIh2C+dCy72igweo=", "EgAif2MVWOLYPFtsOG28zYwBmzJxkK5sIfXmq0S/xkQ=", "HXV6uxmabITZYKq0Q87+ttbkM7XOv+sZj4A+7j7/wK4=", "JzwZ7mvjW0uJmTSce3uDy1eqFl8LMCothSvmHoNAnZ0=", "LRyibKXV3OHqQtsZQmvQdBV9NeKKyY6dDiXMcQNU7Yg=", "Auy9LqKTQbcH15ogdEdAmCOQZVJ5VC+YN+d/ibEn1KY=", "JmpmQ/SxwyP9Iti9NMT5xDEDLwWwyFbhB9kscNS9UTQ=", "EGLpnV2+5KsMBHrEHMsBIbSS5gT+EOLbStQ932d/QmY=", "FfKxjQBvtfK/WAH4lzu5TsPUsD6NZWpZvAmVR4PuK2w=", "ByNowNXv97WfWweydUDoXqBCocgO8GNVT1OYK8WB3ds=", "F6pSFkUCDZpJFOVnm9xwwHcu2rrg+CwOxewpKJ4M8oY=", "L5aM0hJtuSYL6YrFpkJQ1rHcYNt1LOhjQt6p19bu4gk=", "GCTtCcqncWnDGIoKMof6ooTtelGXeCbx9kocK+MskJ8=", "K4+6vymdnaOPvQM9xhREriUAwSBbeFpfq4mW3Z/Szmg=", "G+WY7qYIKOEODEy+qVc2WE64PGrIQnMggC2Qg/Xm3TE=", "BGOvNMryDHss/DulQKwSj65EBpDB+/S9gV6iuFQYPqU=", "LbwaooC7Q8Blc/2Qq18FMK1FC5krzsJ5fOCt9gk36+8=", "Aqp81BYl7u0vjkYM5j0rr9ZDKZWdQMwub+HVxIvlxQE=", "DjyAQ5Y28rQLHtjTP3kvKl0uYC2mUUkZE7pF32Pnd94=", "OuTXjpD6iflD3AtMVtMvXIRnNAceob9rr+7Z6D9A9A==", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Hzum8qCs5ngH/1T7N1KnQLkNQJj/VHGN8Hz2uZtKNhE=", "Ky2GiGIaC2KWjGTKsNsn9BpRsyqEmA7zF2DSNl0sPDE=", "J+yyh/PZqvETfUBYq9dJ/rwoC99w37flthp++9syNxo=", "DaehdpH2QEgzH9+hNdxWpjaxu44cCLp8sG6bsaj13CI=", "Io6Hz/SKwe7N3SL6P1AhT+BQXM61joqlFamyGiLN6UA=", "C7HglFJ0If3poSKf9IeO73ZhUt8pmPz6RKx7cZBr3vs=", "AhYuWxJ9fqX7Z1qmvjEBPCudlCkyT6tiupzhyiGzxfI=", "BefCqcWavpAYlhWhWtk+FGwnZCqtwp5OQLjdnLc19Oc=", "A7fnzQphyKlTzha7at+PYfSbVg4ZkUl+w69nhBNTXhI=", "K0im194IVT+ukGhS/H+xZh5vUDYYWj8adcmpq9DHhM8=", "FFHJYubV3STkXcfgeNxk/PWWNAc8E8vcW4eSpR/7jjc=", "Iquk1J68MG9Le04rx7eh/0QR2JiQ+fpbokCM/fv9GK4=", "CO3XamZrkmTDSwBpxi0sthu+7lWILqFiXT4XhUTK5KM=", "HPqb2p/jP52wsdGQ7qB/sNxoVbdO8WZ0Or+AqqFQT7s=", "IYJagiC8Q78UsG29K5JCRUej/NDosNesdUP1Y4L5hzI=", "IqA8n0NhKUYh+QKkMAiBLVv6ythxFywwBLe1gSZpDcA=", "LE1Fn897WOfXMIrwTZQ1MJVc7eAON9PtSRuG8FxJvq4=", "DgmWWalGgkgwsfxeF9TWA0Pyh570iPpFqeOzrz6AoUM=", "A7JWpUN/qO2vbXv5p7LmlfBty+gK69yk8w4oyMSkmII=", "BHPB3usBZkim1fPQ+kvzHR1Lm2zrDH9KdgUVFRBKYX0=", "CiFzXisQQNjfxGhcXFpC7QegLCFkZczdMTTBVzYZldM=", "AaC5buGGiXgI2RMFJXeOE9IlmkBigkVrLt+EQ04IFxY=", "EQ1dOGaqUqxiCyM9wNiSw5+eN2MHpzEMmUyK6sEjP00=", "H6nOnQi8nvQyAJKbVRIjaFLU/ftgf17yTMtmbb3wU8Q=", "CLj7V823ndrfQd09og773NUC6JyOITI+yZ8KqZsn3+o=", "IORR9Ie/fzCv5olSWN+YDHMkQFZ+8r5yD2g7TZvOk+Q=", "GJNMzWuU09J6+PzY8Cs7KuviFGW5JZx971F5nx2XGQE=", "JQKy/Las/fe/3aPpaK/GIrlJ5V1WcQDEAH+guUBZNuE=", "HiKpr4/f6RhTRuIqKOT6Q19kyODzgu8g8nwPGd9R5SA=", "G6zXh3AhnN5Hm43umdRgxzoi9nTtAGbsxV0jRMcqD+0=", "AcXcx3hMsaIwMEppBbBWIWGLiUmKgn6ncpO5bY+tn+M=", "FRT3phhNL13phRHTWFctfYnTO7LG0npf3XaBeK9Nd4k=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "KHHatK7Yzye/DpovAvDn+cRgV+qA+mTTWMSs0r+/Nco=", "FrSLwHGy2ddcZxXpWXiKXCxjSn7pUfYcbCUvn0yW4Tk=", "JCOZHizsuMfQy/H2x1qW/dnMPh00BIkQVAcIiM9YwCc=", "CvZInc/6BHEWbdt11GvLrlfSOekAUdNgEArK2GMJuzQ=", "Co+0yA8odk+0iZJvAy4Pa9a7h4q1YyuU5vlg6EF4AHI=", "KrPDHPndqzfwdCqu4mGQKSlSujketnZO1pQ00FUwheE=", "EopTcDNYO4dkQuS1J0SD0OdmoB7kqzEIOfbYpmwFK6Q=", "Dse/qmL4FG7yuxOvczzqZGMbIRBs1H1FaCOz2pLkFTA=", "HSbyeQDDzyYppUDKo/L+CJaXd4LOvsSnxfxhCq+fKI4=", "DNcpb8AIajiVdws9Cn4nMCyAODoBfkMraf4lAwAdFNU=", "Be+17o4izPeJRd3d6z9qsMzdKYCu7UdjaQEd0gF9LNw=", "L9MFjoJ2w+EEQQLjfIusn5zso9SJjexSJxUr2sSHYGM=", "MEHQ3icsxABzMaEhe6BGK0H5OWolFAeWTpD3fSDSvlQ=", "IrRLbceE23pAwuZwgA5GJ1i1JJ14khUWKT/hpRhm6+s=", "AUcvnGt0RxNILPfJ8sgu2wzcuB8jjdtTBaFOFkkJqWM=", "EcxQ5kcIaiHBjZJOXLQH4IldRDN7dg2V/BJUtpC4V6g=", "H2hwMYqXs0WEgsKy6PSJbRu/qzF9lUeGU4R7/if3OlY=", "BSe3eWe7RASlp42ORJRm6l3YXTbSl5L8rkribzDDklM=", "EUd2kGYIpFOASmqzyh+xNX7x5odyznjU+lPCGbR8Tss=", "Inyr8Rh6joyLmD5EUrQH060IIOnMAA6jjSKYzrr17RA=", "LNsW5xVNM2boghf/lDgrin3Ia0fs1QYgtl7NX5iq/Yk=", "C7qSpWfNFc0JI8t57EkfF1ldavgEY+m34rLJxuZi/kE=", "FiGgN3dOuF+7KuE2iTkkquXsA5R2TyvSBObjws0FPmY=", "Gy9LSXT+nE0va6jztRCEuIahFdraVU4xORDmoKKnNr4=", "F/BYlUVDuABdnlzwOTtml5AHblI9u1vORz1n2YtGYKE=", "KhMdDiwZOPU7+tUuX7MxIOsS2UEt+nwsebIKSp5hipY=", "Hh8XuCyOwGdHtjYp2Z5y9fPL6+i97SDAvX/Nf/hCIyE=", "D5La5bUHBTUkeqcGLRXf8NzVM/fveYVWsfcErMcqGpE=", "HibLHmfEykiEl1pdvUTfjAX2p6gT2cMmf6f3NcwUTbM=", "J45Gkxa80AgpYg5DivN3c0cZEk+DxQnUhHIpS+mRD5s=", "LZMeIca9cN0zeiHrAGzMxXDI4kg1jiVmVdTrQJ24glY=", "HzqudJyGwTkVFZBhX865tV14sENtaEbkqywwq+7WKKY=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Fkzs2jrsOWPeXeqpGaQZ58Pn7WewDtP+N8lBvTrO7EE=", "GuXAhwQ9wZbnbywfzQBPB792IvkUgML0Pf83Rmgk4oo=", "IG0SGl1cDlDGaWpPajziPYboQttIuYAGERzfnrZQE2I=", "JzhTUW0DD5ZlA77QfZuyXpp42qqooW3UbOTq2LDOuSs=", "Kkc7F9qoBSAjSW+B/zRxx2uuJ+14CyO2WQViiPnIDo0=", "EmcArRKybIfI98kOim7cxhNTDwnQQljR0Ozwcy0UPPA=", "Bw9pAOIRotPtNZpEwZSURyZNUVgGefqE2s5Smg3hnUI=", "HRllNhZqr+mQBnVsu7FeYhkDzPsZNGzUWrlRsBNIq9E=", "FqZBO/02Pu6NKM7f8AyMhuFXRd7lCyrhXUX015YhPRU=", "FP459rwfsOCkH5zbFCuG/5XxADUZyzp3oF6WowFTEyw=", "LzcZhiGU7S3so3eh8bWOypqgtybT2ChZrFrLVRMVnwg=", "LKNl9mtZzDiFfWXhq1qEFXTVv7zQ+cJge3BCMtfYWgI=", "GCPTbhszhB6zSkYBZoWW/iDgjCj4dyyjlY/OU74sbCA=", "FdJyebfxt1FNAHNF9HAoUlB9B7ZKLxZlcY7+W3RXiJg=", "EbPvr71T+W7X0JNzU08plWIzUEWlHkPLGu30ACt9a7I=", "EqCpGmAlVGkRBo5vUP3RxuNopSr8dplSxPvZc09QBLg=", "qdf8ZPyQuRK0l0j6pKTcrqyPPhXfCfyS9wZrVZBFOA==", "FTcbdeit6kiUgiVEyNfLa2cHQa6x8cRl41eG/JxkXfg=", "JfsurdzeNFGeUR5lbVGpDbhRi2N1ZG/5LKpKkUAH1Rc=", "Lfu28eISAGw5vYndSmVD6w/PlIgv68HJWOuBAS8XzFM=", "KVk7t/lxuYfB76r5HNPXBHizuPUZ4hDRCUE63E3nKAc=", "E0zhlWqEi+xOz5tgM3EMZVtCX+ei5CqRQ9mJyHbge24=", "Iy5YmzJ0JKN03MZBUuwDApy8ax5pNeGHjIn32sovuMM=", "AqxPTZ0e1SDiH7/emLTpFpqtj3AblfeqbhonmdcrWZs=", "E4Q6waSAGaUArCqoMTqRQ7BF3TOBIL/EtOkcF1Cye7U=", "EjNm/mg/7oxYv+36BykS3Bv1DJBhFYgNSVR2PmSKfJI=", "FHvHfR9+9/BgSmacO7+jqlNXEaQ6jrwl94bbjJUd16k=", "K7XrhvKDf2mRHcOv5xbF/Il+1UocqEx+RzqSASOUFm8=", "JelTVZHfiD13BNvNjuh74296QPqdNguN+1o4iSk21H0=", "DPIqZ4fpPkrx1YUgXwOf4wKARg4CxktKpqD9Nh+gkhA=", "FdqolTYCMRn08yg2FACIvOkILNMtsY7cKkuWPtYWZbg=", "JqQavIsJadojyfURtKR6l4QG7RR/sGh9FG/3Pwo/KQg=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "JGA+PVIyY7pp0hYfe9PAG5kLlqpHm0fY57/aV3mzGnA=", "BvBoJ/ClKyQ0dR8b0jvvcO3IA3BIkBFKM7wbFzzT+hY=", "GIIazR0aGDs5dHFLTBW5qjONopmashmmXvBNZTjJ5oE=", "JdHHXBm9NMMeXerQ27q+y3ChlSrzuazJRea7t695q4U=", "LRbNSNXrnTiEeClg/F8nUpViGQxckgPxsLIgsH6+IlE=", "G7LrFUzqRRp1kbyJXPnLZWWBM8b2NTOntFNiGX2IPmc=", "LBwJnsVjNF/d8DpsVOKRXxp8iQtlVMxJaFZVPSshc8g=", "FN58im911cCYQ5YIrv2dPyIk/X/y0wHGKucowTzty1Y=", "KhKxZmaHqPOhTmFZCrAEWHoFjkLF9FhAvPDHoDSH80w=", "Ek9oEmgCj067ZnjgcJUcqpa8rwk1C/9PcsCTwpc9Fq4=", "DGHuGX5ZZ2lzyxsNzNo9YYmBuT0kKFRA8iMUanrtP4w=", "HWoTNFwWlj0Pw3KjOjzLnXET5CuDNs5KDPaMbBw7wk8=", "DpD+BEJl4JPoKgDLFAyeyEjDgHyiFq5coGCLNgVH5y4=", "KKAQarZIs/sZY+i1H2omzOirYtdasmIUw4ngxxlzcAI=", "GQOj8UzMxAU1Ggo7ojEGECgwwTTRTDeCJtOmWZ51Un4=", "Dmm2pF+Y3JTTbn+ABF5W+oknQW+Wv5srYDwyxtACZzA=", "JAKAgyQPBBWuJ9JQtenSYRxbr2uDygHF+giyw5hLo3s=", "ELl9ezK3VBzd9WnT+juk/HkvZ/tLyKvxQruXZas/u8Y=", "GFFOa2Zj6S0LcC9oMFQvhBhyqYZegRa2i/A9VTUu2Ug=", "B+hKkcIt9fIuRlw19mXGpWx9QebyDz1jWJq6ShaJgaA=", "JMZ8Peus/0x19atgEdOaa6kFp4mAYD+bUg3F8Hgm0s8=", "IwLXKkj3KEqp3UYBPyGKzxVRJJwi2DMd/kjBgaBsoo4=", "EzL7ntWlqGxfcM/biZzQU68c+5VXrxpRN74ecn4xaQ==", "Ds0+eVX6YDr0bmn80WmdXVfbXqw7kJXAx+C20k3H9UI=", "C3AS+VRGpuVrNbpf6ryBg++IKrXpm0jdpqAKpLUoLvQ=", "LZqd5AIB6K7bbIOqZNaAGvdJtGTKI9sqdDu23xPHKYY=", "Kb1KGcJncy0fITpHjJxnekeASlJd9SCumVurbHnww3U=", "FGL1rgVDGmSYM/TTPXGZxq8KJ6M8aqdFFNcGvF+ssRA=", "KR+WCDBDkR5FuHmVzuLVKgxMHxolN7bokNKTsfv8Bdo=", "BBHLqQ5gilGo02NdfoQv9YxBN9t+7vDvFkIkArWIdm8=", "D3tepVZYFru4wWv6lGxhRdYH53PsELdIRFERYUabr2A=", "AzjN+rTOj9yfCBx387elj1Mx0yIM9UginIvcn15Juq4=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ek9g/wCg5i3cCjVpJqg7iJKn+4YC1dO5VfQfkTSVMQc=", "B+xnMDmDCg8GcBrXB952LpfeJorYIY9OdxzP73D8qtY=", "B0Dl0GOrzmkGe3Gfsz4w5LPae2xm8mvS17UyCgTc45Y=", "eAis0+oMJJ+I78E2DxxuU5Vh8xII6GCSExGxwptZig==", "ESv38Q6hdKk5rc846RURx8AJkL8XbTR4ulxbz5xG2J8=", "GXsZslwq/pNjGnjPy+/uTX7E96XpyH9aowhhql9EEEk=", "HuMHDkDA4OdApnRJw3ibax9bZAR7mtxKGn+RlKftfGI=", "Lqf5cOrvJl3wun1lwgv0dJJbvX7/TJrwh8OLW9pcikA=", "CH42K2OMHhfNg34U+VT8AswaAgxi5Ba89RBsDoSkLk4=", "Bmxw7fmJOeVV/cKbxsjbcDr9X3MXqX7IBcGqKHWAgb8=", "C3zQGBPbIKbFa+5HHrFnGfrSc3GarNunxHW5zZ/W7S4=", "G6704oRwCtmedZR+UZiPiyGzBuhVUslYYVnNL6YtYgg=", "LXBDW7ew0iQrG/TPqb1IzvpPSUkwWVbwfGzp9ApPY8s=", "LJ9LBxJYQNCo2ymyyPcj2pFKvSNX3i0L38dh7R0ssZA=", "GmjG7s9hIQRZAPLRRvbg3B/6la/KATD0Aj7MhUrJCXk=", "K96bIXLgHgM8iZ59y2kQRB4LJrphiFgXwZJXxnpwRFk=", "GWNkaIvmwAfVyvfwqmDd56nU31pyIBoBCGb1HVuORNE=", "BeJb3rIDxMHBAnJCLET4g99hvYc6EYEAWTesaJe4IME=", "D5OSl1+zus7s7InOjd4z1hL3tRgJxwx5Vg5a7E6g+X4=", "CzqUoNf6aAjVQOp8lKyEMpUA/GHBySH24aAr5y4FUuU=", "BX8vd/bzn8wwnOIiesmH+IAgwRVqUh2LSmKY6jvsH5U=", "KHFBdI7leC1G2RQSCVuK6KgXNBeXc0zu0v3wAPe9LKY=", "HUV3FvXicRXxs71gJ0PdtiUkJXXOQH54zsXAMzgP6gs=", "E5MwQiG3r+Bk85ViolohyJamXCfNk+2J9QDp61s5stc=", "EACwrNg7i1ERMRn9F4PTBDAX2i6zKVRFa2xh+qoq4p4=", "GcnHk4+GBzECW9K7HNSt1K1ziUM2g+x/0cLApAhAQAs=", "IYvXi+n+g7iBSpWe+BCWi+DNjyDKd3hJb1IlGxpXA7o=", "JyS8nBeca2Y0GQUekBtFo8Ntn1nWP0Hd3MwSDfw6u8c=", "HpEw0K1dqoG4B9hsuXfu/kSbkIHN+6Wb+OG0O7pMEHc=", "LXXIS4glutInICiXB/JwnFldel/435shkDWUANLpJeE=", "J2KNJ0y8dsK79QBXAq0UvYtEq4zezGXC8yPyMtt4hVc=", "KjnLPTYzzb3c0LfMN0Tkav80UFJN1XO49no8fjucegk=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "CgmvscVPHbRUT2wAc6pDwP4X3e3k6y6WWgAgs3NLPkA=", "AYwbyXqsTNlzVYhBO+FzSOcdGn0Up78XXIpItbhem1Q=", "Gjcw3APn+EToh27c4qLQATVwLaA4oyY/rtOdBIr45GY=", "AlF24m+JFlXk7Lmjg4RqKqFbtJk2wftWhRlhWg0QMnw=", "ARkJIcosIFSvJ4vriufpAvL5/AMvHuLmYfwEXdZDVpo=", "AnMB9FYjOqLqpeWMpiNHFACliF4GZVbtrAaOgYe9U/w=", "FN97QMhTF4QnEzjrYQGnxWUpe7n9Fg9WM9H+iiTyKw8=", "IBt7ztw/iTKF3WqNcGQQhgkdsnfEfXIf2jWt4zVNN1Y=", "DX7H3Oho3uA/PMkUw1vQYcjAdasrOiTWNRTkPmETfyU=", "H0Nm+9IXMXI6Y3c2nK/B6tBm0OljNqbAzfREN6xpmfg=", "DU9yC9Gx2N0tpTMBVkOrviVpwhQrOCf3ab1Mj62et+M=", "JVUyW5hes39XrekxsHaE0xPF/XK63FPyGM3zY34orCA=", "GVd8mOvGGfkqD/CZz1w8eLGPTlIw6ufbXi+IoYFIu0s=", "CqsV0YvDmZaYePAwOynoWqPtW18NMC76lwc9BYC87lQ=", "AVpbdNX4Dv/wLbHfUH+yYHJCODcfnaIX2ySbgGUPwqs=", "B4Y2d7rBLZyKy44jX+1xnsp0SX4MhfEZETLnL4d7RZQ=", "BGIt1I6raGpjEvALrHflasYJgywaNxAGLi0Z+hOyUFk=", "G/03Og38pgBwqc0MX3AQY2bq+sNNdMrWUUmEHDHldlk=", "EsPBBNRVxyPDCiWCqf7QR4CJ7N1iVqahTV3Tpz5X5Ys=", "HbYtWpeD3W43IZgBYcjp9AspBmRx7CuzlbTecVIckzc=", "ChM44z0NecjBFDwelEB741DeAWqhkCN+D99qrRlOw9s=", "IwzYExCpl4+sKCjeSsOMGf41qrIXnx6DoxJ3RdxwmEY=", "HUZUU3T4uBF/5qr79AwWLPo7E/dDkZHENXL/jKcT2HQ=", "Lwu22v9pzL5B4RY10aRRgWwaOeO6pzWUk3VBEcDUU9E=", "ApMpaV8Wg3DjsxVuOuKCSmYu23eMKiPrAW0TXK9yzZ0=", "G5+PSk2M8IeMO1tX6CCWlyt9dzoZe2zUEpVtmZT0I5M=", "EVDKSFiW0fqIRF8Y3v+eRmOVeUU9yL2VLesQxT/GkCU=", "Dv/F6Y8iiFjknKFbuYMSOFzQaleomLgqVh9v2bWvEXA=", "dqnF7OQiFk12ifWGOjdSrTaBooOF4CLGbbo1uMh99w==", "HqRNwTZMpdGpwhdIjpaxE42l6sz6YqNBjWh9oTCBmaA=", "IjkOD7XJgogdYvevklWyxndVm1JecOHpkxIOOcs4b9c=", "KDiAya88XuKtF1uXqREOkE6m8RcrCr7dhyahlCvSG68=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "DrGw7OKvXN5CBDQwuccO1nnCuuEACQMHJVHsrabcCm8=", "LabpB3Ssm/WgeXEIVpjN/2M8KOtS8vV5NbcSxAbjcGY=", "CoEluTXo2h2y0a2ahB77EPqwlmtDjgptrCBMzIMrqVE=", "DU47JEBgK8TQGdqA8p7izoakTwmOMuakfFEvpzFz6ww=", "DKdTqlf6UrpXJYfqpHwYrZGqSYBISD2aAZRX0BTKCOI=", "D56oFBh7xtuljG98Hss9v2KrLqKdB1r7QPp1+v2mzN0=", "FiXjb6ywunVY9BY+L2m0gs/xACtuY6ApfdA1tREm4hQ=", "Go9ZhsOvR5qVDy94wc+55u78aTVo2zIVuj2ouVz1mZc=", "IJLOKDDZHOvZfmmtSqy/WUfI7dnoCdM6rf8KnETGDdI=", "LDQ5bepWfho7a78hUYuLeL0IUn2VXsjD9xwVM1GXWkg=", "J+9dkHwSskc6Ak7xzivzdwu3ZxGKuVeRFgirmfUBHj0=", "HykLIL70V+6/DMzgC7w56hnqTCYl5U4NzP49sRLgZ9E=", "HbV3iMMPLxj/85CM6RnqEKyFG4YrUFJG6B1hvbUeD3A=", "KwQdvPeEbE5y3loOXSAfpTBsjnl7wMQ3At7iFkl+uiM=", "IqMepVcmEXahD4A2x/mqMtc5KjPmTtkNrh+j2YAPAHc=", "Ls7QCCp6yQBRv9GQ2XMZ40AhvVcdmU9PtjPCmXWYdr8=", "Fx8/KVxnyA+XuwZ4rQXCFubfF8RplcfI+AGBG0f3Xbk=", "Am3gdvm5zUzY5/Q3OzVpycLthnsYK+aVUoxx4d/DRVM=", "GGhNCtj4QfwyFR3FDvYC5FYLKGM52aKZ5kUdU1WW9B0=", "F7rwttiWIeppQgKCwy+UrTpS23OUuqrMKhyjAyZWuDQ=", "GbrTjqqSxD7hv5KJ6eZuMqKFahQe8uNoaJdWF3ZcChM=", "BS7aaddyNIFddqWpsE6PckW5RXVBxBRdAP0mO8+axW8=", "LeXmQNjC/DrPKOmd8X/VbfuR/BCR0wR3NjikUwN7F7I=", "B7B14AS/6oDmn74cRgWGpQsmAom+zCbMkupu4YrVyJc=", "JOuzgZcFe73ABqLtbRwoDlAFOfmNxT+DwrWFA7r6jKY=", "HOUVc+JKQ111tlShu4DfjsOPEr+WYNKrrTZuyJdww/g=", "D/Iem8rpMkSwm97n/rGEEhnRS22ejObFqgeRW12BkD0=", "n38csYC4ERtqOyJFjPlNyyie+K3cSty6kT2ZVnvEPw==", "Ioowu5Fhg1o8pY6ta5dS0DMv14YIsUEqQC/ARe9DDw==", "Femx4FhRyWs71/CUWWadhS5lYj8baPn1l6t6DdpeIIs=", "GWs9ZSylnVlmNpbvF5iLoUraAuxQbLfkyvJwYAGVO+w=", "HIdJhVwVnytM+Dky858mdtxWJY08v94x1Sa0ta4+66A=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ih3Yp9SVreHf5qbhGYRa3SjU/KFzb+p082essvDCxrY=", "BLQjF3Ftyjxdgq3vmWEAk1zzgnkELem2v1Cyn2ogLzQ=", "BHWJTLZNuqb6ai3bdIFmcL3m7Sux9TWp1fhjSDaUlMY=", "AcOUazke0GnidJOc7oZqXz1Nfc1EvSjFm86qeVO6Rd0=", "GCW3k/0u2ECvaEjYjBD608FCNKfdODQSGWWhGSbFzl4=", "KC7G9iFZB+DL7OcuxQpakKLxfD9RTYWYa5mDu2j3PLc=", "DY94AWg6ZIj11U2SiebPM2MQB3caNYB0ZEbgXUjrt0E=", "AYVUErogKiqXtLxNFB+9VHpAGfI82k2nJv0arE1An0g=", "F5jxxpAQdqvXfXxAtAHJO9cR1YrxuXUQbecqb24rJQs=", "Lt2Xhl1/qkZJRprZal4FQsNWKOkD4r43Ogq38cpaIH0=", "E2ds15YewluH96uLYj0s+thstmI2OGzORpOG/XmY2VY=", "FsCpHp6cJ2lAHyZyjJNeRnaTr6w19kdtf0XDWTSWpLw=", "KVU9Bp8ROCKrk5qAfIlhQhTVhmovwX4y0hx4buJs2R4=", "DLZoCFgf43XNQbtUEJdzeSZcIN/kAtVAC8k6wktLA/M=", "JD3/ZIyfDHZUZpsGKIgskwnlvChYfMKyObriHb+vA+4=", "LhcRkZUc71KDMGT9TUBngW8unIktfslZX88VKG/FgwY=", "Ar25WSNVAgn6fLoqdG8MJoEZWw7MxebCUyJ7YsZX5mI=", "CFqhOlL0tiPdUWpqR4/NiOMMOWQsIvffwORyPjH9DV4=", "FfXfsvIuIM8Iwb+Mp/4Y7hJgdhXFw8Gnwsn+dAu5mQs=", "D8WJSb2KE2w4xwaZHFKIUR2idtb6uV7zFcetMEP19hk=", "KE6VafyLp3tARbhW2/8cKe7HHoUL7RfhUzAo4tB83Y0=", "BfuXiF2U8y6Js37YFs/nkRirX3B4SzpUalDDLFLF18o=", "FYj17dXbc+nkLhA48+aBf+z/ABpwTRj76W7VcCLWhTs=", "FoFJgQJP3OpavKUT5WdOfvdXOBO2UNquvzRDCpMNBuw=", "Gwt8BE5anMYGMd+t1iv3X3l2Rg0KHd1UyR9awARhups=", "F9aAmO1EtqbEKm5+b5/i2grHBZ0ezwsm6uAa+hF5Mb4=", "ajKhs1jLUoiDCyc2cTBtbhr2VxjDtO8aPCxt3w6/SA==", "EkiZIG74Zu49MlMCSJR0EWb1P0jvf4bClVGE2ZPLbZg=", "KC0bgAXnxeIa3xRrvDqApBIH0f9+57O9LD5r3VvzEhw=", "K6hgsOOSIU2+5v8jeYlmXDCURhertLMdZLKthfOX4zw=", "CN7kJckjClN7M0Rf/Q8DKozTNbsKbJVZHhvGQc+12sM=", "E+H3KeggMq4Fo34+zN+VWRthoBb1zf3mW51hyE4PCgk=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "I0x3CInuxaJLyI9aMdVudh90hxmSdsim7uWxpomXgSo=", "JFv/90d4MSBadtCqHpxV0kvAQUOzv13skBBWn5RZkaA=", "CPQGnAsQh1psWkdKZjL6qcpalx0gftCJX7kvirNjdx8=", "CDdynU/IUwHWsEem3HHS7XujPuXiXO8iruylnwFeqdw=", "KU7yDzKK5oUtf4eJGM/c6e2VC+WJJdmXrFM8kdW2r9U=", "H2K0um52UOiD+cU8Eq23rEGNPUinUU8YMhjI2Mny6IE=", "CI5i7ggFoS91EsWOu755JcjZTRPMrpM6+M5a0dnBH8k=", "KhWst5mjZTZpjBRxuT0gYyDychwToy3y0w9A+5sfz00=", "IlXvIzsuBR64/l+7TwPV0EUKsiX5Jswt304PDZ3lmfU=", "CzMk919Q+6iSSSKMN/LJoyY6G6A8Yk/2tB0cDupPb3o=", "Jnq7h2zxMOXsDlRbQcthTmsN+16ytmjKat5SIN5tJp4=", "GQQGeHItrJTMVo/zwLnt1y3us8/OPz2fyBr31JVUr98=", "CQFVCSZ9PXQ1X4uMtYPsTUxBsBd0+7dFyliy7jz+1gg=", "JXklh+7n5pOi37ftX9Qp9QGj7rkX5sF2FP082AtzVv4=", "JYgjBFXBZA7viDsmUN6kt0+nwLJnWGmzaAqGfz+Zg/4=", "Cl2OQm6KhjPLDa+r1PMtlG7mscnYDgFy0qmVLg+F7FY=", "L0eJRCbLaYPXHBAKAyYJDI7JeEVLNZoC1hittx+tgoI=", "I72kXkXiD7bCdPmpnHCD+k7FluwoOnjRs2grxExTI4M=", "BkKOJZQc+EJoYEysR7iYa/MGglfTvonD1trI9XCTplA=", "GZ2TuTV1aw5vHqYMcmZ7DlaG6xsS1s2I2tX11E2b9vo=", "FxzkYj8KSf8fCzMgX72ikJ+cGJsnXNenF/Sjilq9qRA=", "Dm2zeM5+HeAzSNP3t7FyZL5a3wmV3o4Cc8OarTgimg==", "F7K4bNZqc6YORlEazX3sD7OjLWy4v6789EebfTWPzoE=", "DSzncexJeauzDIooH7++cBqucRIGaoEzk95E5WFhIH0=", "CGmYqjWhn7hq01qRFsJyiHomyVdD2CFPHyofx1BQ+Gc=", "Bb4RNNoGkrj5JUXLMm3rhiE2JVeU+oOD4dPyZvMWIkM=", "G8trjen4ZqOXaEZtFfUhzx514endvDDAWkW1OstfWOk=", "G56SaGfsQC5PtL/SQKgvJA7affYcm16jrxmE90CJqTs=", "9Ajs0kE/MMV5Tnd7igvefdae4OJKkYJT6c77x9mJEw==", "LX8FLru5v1JwAW95Z1n5gFa4ko78NcCf6eGqJvGAEOc=", "LalRmE9PAxcUE+FzmDEgHnNGpFu+mvidOyP/otYVqVI=", "C1V+xGp7+4oLwhvKpW7bbhwL4VLYi1f7V1DNooUcYjE=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "E9P+8+r/m5VjoYJ2N60AeJJo0rVaH7ZoH4sFLQSaP7M=", "K8HMlZCZ9i7aUn1zhc6tYDtjeijJoiPoF8mEj9ePR1Q=", "DarId0My5QmYYXg0ToyvipHG0BonW5od9GnltzW9UII=", "J3c/IlAM35L+yA8VSEcYmj91+F6M3jXOkXEiXTzYtnY=", "ecSZ4TDth0oTg7l43TwA/VttDBi/O0kc/WN4cjDLnw==", "Hr/bNp/HTRRpxuRh9kIG5JB7b1tRsCSWNorvHFQZjLc=", "DKniPR9AcRElQ9TowbMDhlpAZO1OQRDuoRMTApLR4pk=", "I1ffvcvIaeqAaLss4FaFT3oKdlohevSgoxeIiwiuCvk=", "LJ59GtecSbN9/ZP/LUqkPIUy/MYGkn6XWyFWSpwQcPI=", "CDf/KIwKqc+z+nzTgxLKa4O5sqP/TexQasoa8RdqQkg=", "I9jeBNMriKG1EChjQWMYARtBKxHx5gk4bF2Nh9qHjlQ=", "DiVkQxztmq3d5DPnys7kKgTQnTAm88od0O4/swha29k=", "BhyuqroWP+95ZctmXwzzBd7u8WQstj4SLYRcX2sJW+E=", "IzVpQu9NJdKzVC9dy1SnfPF9j6ZLoGBGKjtxyztz1Q4=", "GGY3OQKpqVPAdoZG83lByAVljDH3Yd055rTSksjLzQ==", "CGu1u3jLEUmv62cOHvNHDFY08QsY6qJUUOh8WpvzUUY=", "JFHg8ae63near1TdimKLktnMint8AHQHb4YPh74vj7o=", "CEvzdApUYBK2EKW8eK6JeXO4XCvgSvsy+uDjnQwIUlU=", "De9+BSjqgg1wzJ+reTXWy1s/R/yLWrqSS7I3twd/AnU=", "G3r2ClefbW+WJaiw98T9sqavWY2vCFAfFVZlqzdvfsY=", "BPku44MtjEJTJ4936e2QC+GG+MGCo5Zi9Z5HACE8mNw=", "FHuUjus4XXGSK+zFS6EhMP9WQ+SfcbcyfDI/8OJXHJU=", "A2f6aMkZ74xqJMefa7oH5+g5yVErkqaQ0aZGvOCDiLo=", "Cq24/69rAqak9C6Xr6zytNSbXUIBvs86AT36v6BotaA=", "Hyn75B0zZ4jPZmpDeLHILVgZwI4nEVdiJ3Y3I1uQhK0=", "CUOX2jD6juSAzEy8DLM4MhjO+WAszR60ZVBxx73PMAE=", "FqCRuaXNlSZnsvETCcxOOfLGw6wutDRl2ZtAmrB3Efs=", "FiXPTi+7b3olU2okv+Z5x5PjvAFXTYrxI9Yda5jdsM8=", "F/Hd9hCIGa1yqpFBHggmTFoHVu7zEBNRq9Ex6DMugnY=", "JyrGr4Zw7wTqxdYhlJ88Tsftu2WjjEvX1f9EDKsfehU=", "Ksgevfg4yJOnTesaV1ySnaCm4S0ubhsHKb8EV81+E00=", "KBmKan3gmr5UXtQo+D+cqVp7yfkRhjBa3IDZpWEEXd8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Icj1IS5DqISgcpmG/BGvdbt9LOzfAHpxddAAqtHIniE=", "EuSpYeGAFmAii7WSIE/JiGUmC+EOHgKIRg9CtSfEhtg=", "CawAiB/8t/9FpPRTDRv2OvPeTD636JgvNU0RnQmbIMI=", "Irklkd6+rVv1Vt/QQGiHAZOaLcciZMG3TA57ibRVdnA=", "I4ii384DbVyJikZas8iPveP834gQyH5jn3q+vsnez4A=", "CeLfa1TZI90SvERAbCRygSQJJFZ6epk+QabrAn6VlgE=", "CwX8zAZ0r43uq31zZG4qKN8PTXaAOotv56Kl+fREA34=", "FIxywy4Coh29PEhZBGBi96CjoKnFQlpSkb6sXz9UNh0=", "DMckR682CMkJCvZ6Omg+jZiWiPIjm85Dc01YCN48BIs=", "DZI8AUSN0wmNEBQAZ6s/Xq7bCltz/W8p8oyx8zoWFfc=", "CRRWkKhCaVJIHpxfU8WHqtJfq6Lyr3o41GTGyG6InIA=", "DKNv/zobS+1/h2n9UBlcHM/3I/sb7A2zB2fpIu1cW7o=", "FR8alUbEOArIlJa9wHirVOwJ4c4wO8+Z9fcjfMexUOk=", "FsBG2EBMRB6wPlwIRvuVgkFBI+r5lnge4LcmjrSyBoI=", "JRw/OG6Oks1uy68swq2dkQ+UE11BRmaYYQ8HLnGMpBA=", "FHXmNJ++JlEreSAsAlVfD8aw34x08Soc9Fn6vfTsmCw=", "K0wAZ3cIMi168u1rKuxExJJkVrLTgps1F/QGSTPoW8o=", "CMBrWS6usvrSJ/3c0ILLxANZ16yOAb8W+MkH5kwXDKU=", "IR42Tg7sotzee35eReIZMf7HiYlj8gV57grMBxHWYFI=", "DNerKkSOA/VYRMS/trFpeQoMjXBjjX3cS15yN1lwpzg=", "GTCsLk4qtwOHTa6NbYTLbeJmsRRwrOtoHcYZiJ5h5FQ=", "Hv4/wDbaayKmZSnqjwRlG6iMSohRJxGjL03LqElSvf8=", "H8V1974UALDX9XIXoJk2SUlPb9Tcga+P9PRp7iX008o=", "D1me6v5K/nUqtnvJQ6Y7vVWbENbXNAsZxaSP6s6+2y4=", "ExYf8Swzjl/qPqtwhuobXJ4HToxDQ/WXjcqp/nfSO/s=", "GejOi8z002VIkFgwzML58TxuDZl/tXyJQV3M7yApjZQ=", "C613cM4gV7PMIPIck6abRL57lUA+bUzNNz2NhV9C1I4=", "DWjCWSnrcUJZWMe7MIJF2GpSxN1Xrx8D7BfXO9FKexU=", "GiD2yXzVnAM54JUjb7KVW1A1b6WSRPYXPxyvGN6sTAg=", "E/vWHuxSyD0t/Gtiyx0ctA5xxj/OFyZa6dYx3m1oPxc=", "DFwk/mpvzngxuciy28ML2dyDUseNRDH1r+xdlKGPJSI=", "Dm9jvtIfLLmyiG2pe7DY8OFV8AjB5QOcLtcIDWvnBDE=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "ATueSmacP6vgxD8zOZKl9pjgipq7qtd81ACykS9e9+g=", "Kwy7WCFGV2kz8ByRwN0rCVotpDz1KPInMTF4jxpph8s=", "LjD7hdGZ3KlUdVIbUHALaZxQ8deq5bLeTpuZB4DOKdY=", "BP98qH4mi0ojrxVMEQLItwXsRoLwis4Sc/q7OoZcr8Y=", "I7NxrDxeRdbZMN94n2CtUQt4Sv6e5OgodggewMp+9+U=", "KMX8gxYBmYuWzMqwHAKNYTwgDv8dDiyqcJjuoWXBGaA=", "GmSadi4VyeM7bdOkxdqu0IrC5aeEXfKJ0sfd/cN3H5c=", "G3aAlgiyyleT00bFJCaq9yKLfkoJCDwrVRvOj8MCKg0=", "JJ3m9s1lr6e/IGrGofyGSJilE10LDvqtD0yGd0oVPZ0=", "FiyLO19yVq8Ke9g7o30litfUq08p0ki90ArTbmEvYFU=", "A6ixl537lQwEUeu6TpE314lD2er4ib7NKRpmkDFoDR8=", "H7muZl3GD9F90LQoSy7qsIRebUpdb7gbd+n3xrQ9Fwo=", "DmHtsSpBdOSKe0e2YOgXX0KqeSb/Q4yQaS5DvDlrxv0=", "KiGtgkFDanXuipCGeq3hgFiajJxjsFJTvodvGSZBsfo=", "FmYgiVqTUlCU+L7OZa5vueFJUdS/fPEKIWnOXL2LTLg=", "IvdEH7DoFpNciBOFTtX9bMzl57aoXZHStaOnpcikzPA=", "JSNzOuUnWqX7icdN5+yACRcn9JXnKeqbxVdRayXizfs=", "FQ8qxPVz9fntoNjmX+hmWB8bwR5GrNOZzqQdwe47QII=", "LixqCBEnwRqA1g3hYsHVvXDJ4bExL9Mfl01BnXTnKkU=", "KI9eSjXWqI5BERPoMk0q9gsHqrtIZQ0nJh+eAXLAY/k=", "HpTEjWzOwHpq7EZ86dscfPL0jyBAZIO7hz9pbLYTnHw=", "IxdVUJnvEYrBpnA0kzNduJWuq2yx18seRsqqDp107PE=", "EStlMySRm0MApunKoI86NsNy2Gv91LzxBSbvPC6MhmU=", "ENZNnb/uhLfY5CZAT09jAs0vUHyVNlWfAFCyt3oVuF4=", "DONAmmkqzuU3ImbJfEfCVk0yaPUST9MJT/s10lLvzR0=", "GXYjLGtbxv9358bSZuo5DF+9T7PK2ezmI87VashgmWo=", "CF/pkFPT+UemZUlfaCka3ixwZgDlba6ZG2KDPnXSHF8=", "JTh19DlPWWL+B/eEx/yuHfbTbRhA6usOfCNuPWeG7/o=", "CBHvO9zTyDeqVB0N8y1EfsVDkZEZEePgc5t//Urv/Nw=", "C+4cVU+fyYz8ay+Yb98geFnXjidX0ZnpqSsVAe+SygY=", "LkbcOzC1SSXDE3MVAcXwA6qNFJCxbP4ou9oz/NC5sKg=", "KaVXJyZGqLCWstHorsFySRhSr48FV3l3kEPgSO2O3Gs=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LPVn2vHjK34hKGBYPqoXg9hxoarMYbHhcnTSnUPD1Cs=", "DeToEhH2aYzxtVE5Y1MLe50LjswRQ1514fjTdD2+2xw=", "JEHGnjRRgJ2lrqVCLU4hY3RptDhDcvBsXW2cFMZoCYE=", "Kuq3cO0qy2POQCbJ+wveoCvNbQ5FsciYVMLIJ/Cfh0M=", "GAhr6kFzItFz07Z/C76nJwEdWKEwdmTSCGh9UAGMCEk=", "GlVUoQT/Q6bmS320dm4c5t9zXdfV0VvASyJKgUU7WmA=", "I3K7tVisyPCibt22IzOHVa6hsnk9fhEwGQ/ixuxjk6I=", "EMM9EfviK5dzYXTqrnnrpAvM8xvIRtjQqLREcMKvjLE=", "A0JhY9g2XcSEfVu/d5xVdzUuNP9rrauDNZfd7huuP1Q=", "HGMoHjaJNrogRvTH8LQnnb/AKuevAiTUuwPYR+FXdz4=", "IZK8zucba5VfFG78waF4HB4cXOJN2aVdJljwVGFHUe4=", "BGU4O4ykE2CVOZ4jxEqp+0VKR85lkOqq6FF7l+R2w5Y=", "BX5MJYgYBr1ElIHsNSCIYn+6IC20zUuT29FAnvzIA2w=", "kHWtdubrGVGIp3WrFqtloAGsbu0vsUVSgsv+2AoFlA==", "C+ho57/fqIQ0KBoS4XU80TtE3xO55PMa3nEI3iSkCek=", "LlEOg3VxN0eb9qd0eDRMELsH+rofl9qcBTfam+UVxeM=", "DaDqamEGBo71XNpBXTDzCsDjCHfi4Dq/YY6i152YCCA=", "JFLJFqJSrTx8J6Ulf0yDKNkCfWZTTZjMyaQ0IdcNg7I=", "D5x3u1HKxNWuOpckO1uWemX2R1mBl3IbSHr99Ap/aPc=", "H54EUFD6Fx4O4p32zUNra/QqV2tP9QwskTruvAhPkRU=", "Ln1Ftm7UanIFyK8bU0PR0/4y8icHQcRQBpeDpMW+DdM=", "JRaTXqHSSA5DUPlh53jXL1bgK1epjokrC62A/47r16Y=", "EF3hLnQp7FlLhXCBKIk/j/IB9vprblii+FQD4Es+OFI=", "H8n3ypFabLa2fvU9mFAh7CNGmXDF6vGAsN6w3s47660=", "KBG2adtbGjcchHCTJEyi+NZTU304LxbAct+RfNWc3dI=", "EXy/vP3NcYHqKxgr3GpD9yp4vJprHCfVpNTwc7Ul+Gs=", "HooFyE5SUsufP0yB2lxUGc7Vk4JUDzLPlJtEL2dRL3g=", "AkM3prHLoy/+U9ckQ5xFVKJDDELakCmXwJbCbno+iMg=", "L5CqbmVPy3QievkGCZHgpo1H2AIfeWjThEBLnUR2ck8=", "Cxgfx5Ay+EN8W/IUJbJkqiitxOkqsUoeV5ZMefFQIVs=", "CZ2mBY7X+V/kzIXzvXCGIPNxybMsGOI1xEtBX0wSvzA=", "CSEvBNgoHmKzbQIlMt9AW45dvYHBXwDdCUEw1DAJtM8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "EQfZOec1ch1tv3nV8wYCR6OTFupSSrjA7GF7LsIBoms=", "Lxw0dSMpnZWfwVkPM1NPwqDlrfxd4Pzg+g7dr1VkyyE=", "FJ73N4jFFJ9kOg01Yjz6JGtrg/OINHUGDuYT90rsYW0=", "Ko/Rjo497QrR45teFZ6bEpi9oFZGrGbd21DmQoCIlnA=", "BH280hH2x8puYK0XGWXh3UnQewVbhGjTPrfBYrNidWU=", "I8oicLFCIcdrd6H5GXZKk5nbDew9tb0o/rLTY+Rd5gg=", "CuGLGTsRQuJioW0NEiFU5IhJ1c2CG4hSoswqLnQB6ZY=", "GFfRtt7wr0XvfT0k3HUp0oJv+wC8fHx6rnTHQMq6PK8=", "DzzIRibEWrlOC4csN3nf4/QVl8OQlIhGeN452MGWGJE=", "DoIJV4eL5ihaYwEJ3XHVq5js8cHjQcfwW+FEpoCJYek=", "Hd311xYF25qrAtcYZryqPzBHBwEOsSlj4w9UJwaE9oY=", "IstV64bGgszOZm7H/dUWevmKBMVzFHfO5BQB9wvwXIk=", "IoVoWzLjD6y6NreBOpSuFIZQL3xVDEm4Zc7IP0bCkYs=", "CJ64A0nD3LD1tWJN6/un2pDwQd6bvLXw3V6RXJI3cZc=", "GuamQOlSKZwq7S/9/uqzJzLpxeLclTFNIX8GQoFr46c=", "LuWMSNuH6Hh6Zbet2mioRKotzi67lbhaA3IhnVRpk00=", "GOQl8YFqP9I3FxewIQ3xShhqGEwUgRJFsNL7OONNp/g=", "LQtMAO8DmFncqPXsIkLe4H6wi0DBNIE93SDx5Jy0YAM=", "G78bnoQmpD2mnwtxipM0izOre/tJ8yeS0LQKHfV5Hyo=", "K8pz3kMRHMl+fIYP+Gx1wptmxcr9BPNqBnPQvjX7s0M=", "GnfTQ2TiGG7alqTAV2pjLKU6hXnqJLoXKR63Hcky5eU=", "EnV9vdHsG0gWSAQfSbYANQ7YOVgP5MAigQ4fnsroCxI=", "JJGnW7bDIxuQSDsPN1lvB5JqdGqmiE8Ifxt2lNGRtR0=", "CZiricdr2fYgq9Qc/4Kz00ID9OavDuDzLn9y+I5CCc4=", "InHDORQJGnsHYMJ1KhL/L8zU9RIXX/3ZSb3v6bVERIY=", "K3bZmMj7n9ehkuW/OtWUhDnMBhGCRW+ey2D87JfWnvE=", "C6CJ0k+qg92dNEJllvQwURnCuqwFxPcnNjzAfcN84A4=", "Fovlbzw4EHqzlXg1Wtj0msCoBmGXfDp1jCmgijp3M64=", "LN0PX+tER7USDmcK26hsEtceX5hg7Es+rihSSCXKbjo=", "A2r1+rorF3ersZmzUzTRKkoBqSSF1T/W6SEZScQzCbc=", "LB3LaFzEfB2+nbQ9gJ7Vbtb1+ayS12v7JxwQtmti/Hc=", "JGM9BcBjA2F2JPw3m0aniLDWm95AV9/DbrM1kFURi/8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "IiTzWD8AeED3esYzca3ioigF/7mZpU/Q/qu6REzOvhg=", "JnFDEddXtDPJDLvvadp58nST3UjCaqAIkqafSUEtceE=", "L8xxb39XrcTpz3Zfp9DW+FsucbfUldEtQWV9qS1QtAI=", "KUo/XKUjm7WnsWVHBHSrWLWgfis9orRUPSz/Th8KFiQ=", "FLS+tj2Qk0XPwokdUr4YJ1/UNt/mTe8+6aBW2m3zFnQ=", "CERgr4fEakJ2z9Khzq+tyDrl6RdmnoOT7OnVIQLUTKA=", "FBvG7f09arDXbM1kUvdG4eKgTX2+oZfCyiptSYWF3mw=", "HnV6zakmkGQ6Nwucac/qxfLL3ccP6YSvr6fY6xUZhG8=", "CektqD4qa4uuKmXIDpT4rQ3Vqt2TdPm2ZuUpKxxD7cc=", "KLU5988bY2Ev4OPwGd2AVXYFQM0qmYtwvfXHVVVKYe0=", "BPExWh4xqz+O7YMSpD29G0tyNizNY37U3+utPTUPJGc=", "AQaqFYze27Is5cqj32RL3i2XY7MgEqX7OR36OnYeLjM=", "IFvNYOJyUdNWzuDJ+/5c7BBgaq3N333ue21QQpJIzyk=", "H6RTlRnvHMG8VzyK9bq23w74aXeHcBCfjeNJtga7ykE=", "F8qyGZwaE91GCKnh5LO8SWViLYtXTKZTOiUq7JOVqwU=", "LDTWWBCn5aS4UfAqZqxNGtVOrSq2M//diMld02SxZCA=", "EodFqaVfQG/5Mn6XaQ74E3ZIqKxYWx1IPoe+APseiGY=", "DXl+sFYwyHtyrFfav9Xol/Bnm88HmGUqMnu2oCv8684=", "LUmsP546yLjAs3RC6ATESHJJBHzWproyKCxV7nK59L0=", "JEe7T+7JHUsEi//ejeOd/fh8ipo2I8tWP/nWIDxtodE=", "B5DNZNmDxyH4g8u29KoV6naqoZ3Dmx9ExNupk7yQEM8=", "Fjo7YuGiboYE+reP8b4KNpmmsI0yn+6hNwYv2sIUsLE=", "Bk2QA/wSwGkj95j7wPSbM6YlDjUhgO7df9hGt/lZPdc=", "Hw2UrynxYtCErXDCsTimUy242WdXNBij7oLLMcyNqiY=", "DDDH34lWd0aH+B44gazOXFUfqJ6qX/c2nSybaM+XooM=", "GBRyO8fCOWuAuT9BrjdzVDojKw/MgNePktSMkIzsx3o=", "Hv0woIzwYuoQkimzvC385WQjLcaxgQMNLAPuSGvKbTU=", "FOkjzJGc52fI0MMIAx8VRnQNUSxoBaSLgc4r1+lc2dU=", "IddL6OND6T91lYjNfSnNZKOvpOu0jhIEo9VzrR1W9No=", "G44Aht5N5SLVyB6wqZaVXqcASqbpDT3J83s7+DSwhDA=", "AX5agOwTXgyTLwY5cteF2fietF/+RN2pqP/BFGgIFkU=", "GlyvdFMvLFkP7oUDoTuw7o6TG2y5Lo8eUsM388fhiPU=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GsQtewpui48KCX0R2GUXmKpfJnZXRBjyO3/mFo8oJXs=", "HsZ1V9G/Dm+FHImDXCnSM0lnODuWd8ceEPEs7aNZPkE=", "L0erWKWOUjQN+EWngtbOmDNm+mafTZNz+EnA48+8onI=", "CPISpWUMSy9oqLehR4kZitLCJPrMVi4HNgkE8K2479M=", "JZLHJ2yftOliuPf1u7lQGNFzA6bopbUTsvPvh7ZtUTU=", "KO7jTBAp5u6gzBLiAtwfS1DnOGWs1qe2kwKhtF8sGQc=", "ARvZQH8MnhuevjeTQrKkJuoU2HM1Ui6KqogCNvUSn9A=", "Fp8pPzlv0BLSCzI/mz60U2Ll0nLSNCaW3fHj7+0DwGk=", "Hh9GiQ04mlCsFuVCL3nUSaYBHFvp5TwmYoWvzH9bJgg=", "Eo2njmCwdYGJmC69pDrNd8UetkVdcgRVlV/2MakiYzo=", "AQaSUfy50v3/UKBBFU5szHV5o2DOqxw2DSBARjDeVWU=", "HtODpNbEM8aAG2hTtcQPZ8xP7yfCYQqslUDVNVxs24g=", "BumzNXvYN9GluMdZhBLHghbaoCu7JZcBguCJhyzqTh0=", "Avti3Rc+RAI7PnhK5Fe/yTrd4eCOmPNjHG4BvGNDxbw=", "IEeX2bFtRbCTuzTG714nMEr5rHynxKJSE007YbaVS00=", "L6izXk6UBefvTy2AggOWyo8Cbz4zB3U2iFDUIzlLIwE=", "EMOOhZ6oVOLGu/46zWE+1Z1wBTdyxv10l+0tTZmykH4=", "H0QnCFMTLitxckAhv9dB45w0FOjGP3sUg3GpITVbUIU=", "LrTWpfFt4+WywsM4AUIcLe6HoiI3T0yywvyh/uT7HOg=", "Bx4kQ7S5AY0qfKBXs14gUOWUCcaI/cqSiclkRDeEhqw=", "FCOlEmoniQgrz8IaaQERG2tSmcT3bTQciwwuncRxJyY=", "JuHnti2Jp1+UYwghtThebEipe4xcWuGzsfEURE6KELg=", "FP0+3hCqe7OCmRoRKDQOsebOCo1XP2Q72K3VotjopFs=", "KqqQSOzfIeBtokGGhVHPVI9oOIBhU2imos+HVU2JOxE=", "Lgg6xC+oiTnUgKl25zxnc9JsRYMHQHPWwqn5AHG8gw0=", "EswqDcXAITFryX4mo1qfWwYgh7eCJFJlQfUorL3i0cQ=", "Iq23sOnUwzXlXHr/i8ogSKWcAQEJnoq5m3nmS+RuzH4=", "FYy+lOE5YgCQtwD5/e9jfXAIGq/fGv8u3bteL2vALdg=", "DLQvS8odyilOfol9CguebMclMcvIcniSZfqQSqwAJSs=", "BjFWI22H02c+B7c54Y15oipvHJnCpMPeS5grV2XE3kk=", "C38IGLZAdjwSaJEr5QIwSTORqG2d6VeBD7LRVIOXoIg=", "Kq7aWOgxQw1ppXBZ+TP6Xet/0E++27AWqRm/X02IV8U=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "HToBNETnd7xOgWxvkZRka2AJ1e0JkxvYAR9dO7sBN44=", "GOSSTyWJMEILH8Rc+qMfrn6+0383WhfxuOxul2dUA/E=", "J8YwIesFV3sX1QZ2ZpptWQU1thFPdNbBSrs+/TWJeBs=", "FZ0SpAuGlNnc2hFJ3Ji8Miju3rGQQGgqLFJUcjpgvGE=", "HAQRXoAr1xYi4bFCVJb5OUFHN7yo3LofBw2KRPbaLSE=", "BNCgbQzj3CrCjuX3d0iY15EHFEWbOFtYdKxG3ektedY=", "MBKNg0+mvSgRaqbMGUU7b3MaCXDfEkFsjE54MO8/bzc=", "GrfqqvPlMwVFlataFtN69LAou2YSAXI1QyF5gC40rmc=", "KjDEE7jNECFIl3sP0fUdTN0mhJleuJkVZDivt7tP35s=", "HrZ5Xx5j+JM+1I3OVdJX2/lyKY+RhsVtCICudv5WJzA=", "IdHvM5Fuan6+BVIzxeOOOI724r+6xVMOxYdxkYLMC0A=", "CeKverPZIGw/VN7Sigj4t4OWy6nePXaWlk0lKaBRfFk=", "JFZPsCR6ClPoGUb58DZcXUUlfs7yiNbWfQvckQVagNY=", "G53tnxH+W23XkGa9Dha5JTk16NC8K/wTDbI6ghXQ3hM=", "GScR0/gNRSg57L//ba4yySvedNBRp1vBQXC8aQ5p+cI=", "Gzrx+iXDLaGlRn/vHf+5zKG3uSxNUOP3rQVI/yxNocU=", "Iry7vmuaOeMQoDqb8OSRRRaY1Nh0qhkrgowaT8uG87s=", "A6lHxp4J1kvmjXvyMW9M3GR8kSprxKk2IyyyttMgr1I=", "LSH0WW2YrDti3ZGVUIWadZLlBACdJou39b6g841KqkY=", "KycIssr8gmIH+AGJcz5sU9bsHrs8VGVmicEKhSaWe7I=", "E+abx6XezWICdhFvQPl0Pkh8whnfHcHXabGquOt0MWo=", "EYqqjzZM/0hl35U1SIk1w0r6GUOx4oqgjUQKen1y2Ao=", "Ea07+glGlcI6dLHyPZz3gI55Frnw66kOxXHgbk8xAQY=", "L0tsBtC5lvrGiekicHrYFbQRU5+FeHHNGmuao0OG8Qg=", "piiDYO4QwbAqKmptNAUrE855+hypH43b7UhdupLuuQ==", "Jd246mC+QefpnJe2taeCLwcQJ5MpNmc8ApAOvd3aqI8=", "JMjIf4iyHqJKwDzxpJjWQVeov+J+4N9wGH9tEeuFbSw=", "L5WKiYJ+tTWquHGvjz4f2p4LbdBUHXyYMDISAtRnQQo=", "LSsyIdnXU5xicxXiQiribata4QPNiovRnYlc6X4Z+GY=", "E73fI3kdCYnBf9mb1DVDe9i89nbGicoFlaDQSv2cJgM=", "LBWhrjUoG9L+emEVI912e+mcWjKoUByhmxqJQOEGKCY=", "DOxeGOUL61qyx/XJ6tqf4/PoaJsJAa+sgJkt2ju/iAM=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "HSP/TyLbsUKl1EZa7o/NL73Y5FDRz28pGCRF1ElqLl4=", "Fy7lhoXoOnlcdhkXQs6d8Ydl7G8enRIzv3PuT7xTJ20=", "A1LPYfdVh9SoIibijtmjiGPX4/5mRxF80oxzbLKJO1o=", "HlcbU/EmCn/U7XngPTLiOyYngE6lwDhhiiObKHOWH90=", "FQ1+/T7Ey36qZwO7eJE1J8d7B+OMk6gAhBoSPr8+3rw=", "E82usAQ4tcakDA2KA5qBFyaeFfWAuARCFOVjjy6Ho3s=", "CddujaE/h1RbdMX1Ba8A4gTrJBShhrVObcO3uMJOJ/A=", "C27Ja392EkfrvCf2T7QnXxEoRy5+0R6KcSogbLnhZHc=", "HgZtoEjPA1vMF/vE+uGDSPS7EUDZUZ8bzoEUTaSZpTY=", "BCav66Y9KFdYFlqV213yqoaTK6n1AxTF98pECLw+qoY=", "LOaLo/QPpQJi8Tchn/peNDZQl2stXS0egLaH5A5CbRo=", "Hh28PszSCgqWhGh3GCsI69uovLFkkvzbYKyqQjF++Os=", "KCri+kJfkUGdze375oAKASKlIRNFUkucMgz3dqIBtGc=", "AUveCGz7GTcmkMU7DgStDsqniourviHeikenlq6XMOU=", "ARTnbSdVum+/AYUZVbBRy159Z32z/aWU1mWK1PwJkjY=", "J5bsXaIzfv+m/GXLhTbqgrXmCxTxCwBbBzCLUtMBHS4=", "JSxuN0ca/ZOLLIQLKBjtGOt5AK2+kgngOJOfiDojbyE=", "K24HISzy5DBKMHrP0W7cmEwXDZbnlTRg0crNPoTcnnU=", "KtqpnMClFQz91OF/9jkMlz8kkdTicjkY01rFW13u+0k=", "F3WcuJOG+TZfqHViC29ufLa1zuLXfwtzVdnDO6DmpGA=", "ERuwccLKFxId4R82unz3n2mZYN124JKVYQoTav0gDmE=", "DzlMuPvaq9MeQ9S661UjlF4p309yDQJv4RW9FpOoiBg=", "JB1Y4c8+1dlL2vnwxGP7ZFtl+hnFLBk61n8dOPyzQ/w=", "FnE6e12M8+1MJdeAp5aKgPcMVm5rogiFnmzWmAGZUkI=", "GZCbp/07j8sDtvgQ8kbzhFY+vFiW/WFJZzf2W1Ni3QI=", "Kp39LdMEiwNH3UKu9lYaJ3rfPYb+gyA98XeFNubCSso=", "GFMu4U6G5ghVXaAgiSCG8VXGhVYSchEef0tskXgYZNA=", "JQnNnr2WwNfNiKO6soC0IGhpHakuA/beWTCuZ//gT1E=", "EcCHcpDzNId6JjJs4ubKepbdcyKI0nPvyrvAKU4trwk=", "JgCdvk/v6mc54ooKb7Hf+zXYUW4GkUhi24c4u7r7/Rs=", "Dp91/VM/pQmkmZRQVc/dYD3ZkwpQY05BqTUJjVcQEqg=", "HzWSVXQo9AueZYJTau0rcmTJFmCTt23z7Wj/Azx/+To=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ab79bawqy+qDy8iCxmHoC1C4WvICHHzncMvU5M1I9pw=", "LdtVNp8CraCEE29AkiWO/wvo4XDMqe624rZTEe2s358=", "Et1nCRufHXEByyzvdP0hb79J1M8zVI5tgxBEblYst6k=", "HoJHZqN8sdHH514/nCYfSu+q9lCA+HDpcrFBMueqbNc=", "BK+PA4I9N87dQMF5GsdFt2jHNSNPV1bWOLIA4cE0ux0=", "G2WicdeH54OCqe5aFxXJqiPjVw6S2s11AErtRrXk93g=", "GyOdTruAzgmDVuhkYy7b5q/8Plo02S+5UYq4nxbKTyI=", "Cp8jM39NhqgsXdmpIWzBgqWmtutvxeQnl98CLidoRso=", "CG4PLswh4wgJ4fJpfNA2u9YkHWhmiybvy6WmO/r4QDc=", "Kb22A1C0mLXh/xT3Ng3u5qoDzKTe4alMQYGijw/Sqfc=", "LtZsHaHFTLaFxIoy1lDSTBcWKjx1jrGa65d5/TXOVJk=", "I3MdVkVgOFthGHejcfJu9TpkJEcoqOjF+3rx15Pgx8Y=", "BdIHHd2/4CCh1U076FSF/aVelGNMPH+StqDn34xUy0c=", "D0PiSCIAQZ59a9MkJZit0hyjx6bxKXQBpIru7d+MQsk=", "FHqEo3ExxORun5yll7mE17SkI5QloSzjL4/RFIdKjLQ=", "BqzsUGFholNt+GV8yunec9QAtzQSQ2jMTab9hu9nChk=", "I8oYfatlXKgOGvhdccslTwXSe2+AAONmRDr76DxMxyU=", "L4oXkizYbGBpFpX5O/D0MvHvnwXi5j6VMqsnf6R8Apc=", "GEa5dpqPMn7dwvpS4jWzxUgz8124x5ifQ0LWZ93yyvI=", "JDJwwuSjK7wZ0r1SJxuajaP3YCUa4vLXg9KFTXSdCrI=", "KeTwHA2hZV2YiH3AHqL6ozuvk0Zg8sk0GH6mkC9eDbo=", "A+Rt1VllpwrI0Ej273J0Lv6JeopcrCSgoyNFKnOKQnE=", "MDKtqSoG5yXP1c9xh5KTw7hixwYiG2BL8ASQAYJYjoc=", "CappYiWLpXVJ1UlhBL4dRNNq2tARjOd4D0cGVeenm54=", "JPTD+bL7fd4j9FWrSl52rGBhfka7eQDdl3aUIJEbWcs=", "EOQIz9zo1vm3txDSzJOTfNtD2G1ZWA/1QXFgdFyAt/0=", "DH4flDntb5cBDlU57PVr8VGilV+O4gsuyJh52BzSShY=", "IL9920LUydfIvB4bEQ8GVmXb5GYUVAK6Oj/rzg+/s9k=", "BIVyTghVW3PYTqr9qXAqY5uvTeAEaHXR8M9gmhJw1yA=", "Lme+A0IasfgiBHhhpyptCElOZbv9E8P3/m/0jLhjdJs=", "D3lQnAPaDBZVfHP7EShvn93Y+G0jUHHqp6pxqF9UcTM=", "HfHuCrEgyGc808yMbvLhXXSBCgOAnGHhbourPyCils8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "IU429eBfJLPP9YbJYDGuk4+By4Ykt2aXp+HnmYbxy5Q=", "Am5fVq+TwlwcZqZER0SbAlZDPUfWQTwLL89iEO5fE4w=", "CzGkrZ7AZpiddCGw8csG12g79aZODDBn4LGjvKWmSio=", "CFYUdHd+fxeTQRI6t4KvrU/2Mt4Jhg7/br4p5PsaDDY=", "D/tXNlJSu/VlaVYjJ/jbMvM3ABoY5W/OsAZ0Gg3jA+0=", "GGmJgh57p1iKhjTYchBVLuyI+EbjcBuzNqW38FB9Abs=", "K2hlV1j4QtCqbayszUYer925gbdRZuVdwe4sIIMI5fM=", "LTmfWGyJxgVWp2UflAmwGquPfZ2TIuyu3JPFkNnND8A=", "LaW/nJ6dpMOUUZWAQFtB5lRYhgY6gwQ33sMtfxva3kc=", "K2VVToklhWiOVNW7SeMh9Qe8MF/lb7eA5B2BbdkVg2k=", "K6QTGc32pBbJ4RvKhEHMYQxufkXCEI2uRxhA9x3qxxQ=", "JA8jz5Bm+PUwiiyw8z4bQM9jSYCp92u2/wfihzCGj1Q=", "Ix/5oSIjR6sgoF+qjUO/jLYvD/nfVh968BXHPRkf/pg=", "BIL6JdwCQ2fI3VQptW56BzbIZv6E6hr//D9dD0If5lE=", "KSNzLaa4v27lxzzjTTrGD5Zg7aIHI10dWvl4QQPw+zs=", "F1P5a895EbwzK8/9FR6egiSKRFF0dCBLPpiIc45Yxfg=", "FeHSF62LzMuaezAJ8mwJV26ag6APN1H9SuSzlmZ74IQ=", "AY46HHT9ULTPWPMJbtEp7/HhKTAlB+bv3MRMV3/yNAM=", "K6Z4AHHWZG+9qA0j+r67rwJyqVP7oySeOvC1byLOgSA=", "H39eI4sQNylifVwix42S7eGaVplZcspGoxfv3Cf8cOA=", "LqG99txLs7psPQaOCFo2HshnbG/izmboQohbgwMVN4w=", "Cm/Kd+pvZDf8K/p/K+t2jdkI27voeqda0wPGJ5CzTRc=", "Bs5J1uPX9G0hda6aF2FTv9OjuPkyN6XkXKnE7gTrxdo=", "CgHNzQbD8kGHvvDUqDuOIaVHRvJ/Dw2Rngi3zw0kF3Y=", "E8aOb3UjTdhrlWjqVt2YvObBuNZPpL3pfc11YtCphEs=", "ChYtv+Wd4FLH8b/VpqDth8XWEg1TjEClN+zQ86wS2Is=", "KvTHja57IP1+M36Dr7H+ribFVaVE2MqPxclVVCP+HB0=", "L2x19DMBxKW9w9MvwdZv2qpPOwQjZCft6H683LbH/lk=", "KkqpuLlGS2q2xYRkXIcpWcn2i6ZcBXwjW34v3oFg5C0=", "LY3MeMZljBGI1g0ID7PNizTuX9GtzMikfUmeYspyWwU=", "FNY4BUfmxUoBfQTKKyy+MFpGOLMrQWMZW0WdsHP6mHI=", "BHi0PTX3jLNVeW4OoOjp9ai41sWc0s9Y3026waVd7+8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "HvlsUcK3sw8eLFmhPp528HnJB6RxizsYJyKII7nYFy4=", "ApMhqXEh8okiDrZvU4LvY8Vqs9KJORxNthydrNRKgjo=", "FIG/JOe0XelnCv5X/epBuL7uz7I0Iug8g96faEXqlXY=", "Ae+EfTwblPfV3/QxnIFpGhNU92/HPbxgBjhHJXDIxGU=", "DCZmZt4vi7uqIKyntK8t40LPGTBVJ4TDADQvOJZwO54=", "FJuw9bnZBM3vfARe4ja8OKM9q4+rJDgbvRSqwwsS68E=", "LuF2rnapGWJisdm3jOIkfPITPnB8zNlS432S/XHYjZo=", "E3bFVz67cmX3CsuEP3Sf+rb2nTRsAej6WaHGEJHlPwM=", "EJinkgqY+1DKo1QMXvyPbbPf/pssgGrrIFAc0OCaW0U=", "CwHMcOi5/Uj3CT3MK6ZYmHcctDAjiOOdlQlbRG+/a8Y=", "AbDh1daGtcaHlBPfXFEPtnKm1mIr7oYAjzLAwy0je5Q=", "H3SrXlYaNgb/O5szTc58ZddyyiwdirDiWR17jbvXhw0=", "IN5/jmpJGreaHWOPerdg/FwnKF6QyHrVEuhqG/87JH8=", "LkhJHt7l2u+e5jrFLLFzSqaeFbaNjJ4NporXGIWDl9I=", "Dr3ch1vgJhOyJwHa3F860QIKeXRpoCwGRUWt/ftz2v8=", "Fx0EPyUbcBR1v4eziO4StaRpzwtfTBILNLe43zpQuJg=", "EcfCu3+s2MTQ438iACaBhJatlvAAmXXK3lqF3QsxnTo=", "ArhgWMCAVZ+EwR0zzg3Xfo9Kzv+GRKHM94kHtvAvKi4=", "G9Yx1n2aw1eh393hySpisMf8/dwGN2dGtFIxh4uD2nU=", "LL3Yb16q7aY0KNSjnHiN9+CMvmICfUI9MGD3oE/kDRM=", "Eg4JYMASgF82dDpUDDuJ9Rnjn6YxuhfSVC0T7ydGnLg=", "jhiKz223YeJtZUBLv9egtVN9TgXYX4Gd6LsIsfnm3Q==", "LaOnGeO5dzTeyJTN/2KELbyvj/w3BAvdPyJJ0y30LmU=", "F2rO2+LcjNutCTsqWRKSsjEomTk5GZG+O56/JydoedE=", "FZZBid+yA71csKScnQ/jMLyCpm5itL8pz5qHi3QTPJI=", "B+aDNyWhppTikKNM9tclQBt7psGwt0Aia/04tmrNGwI=", "Dk+kTEN8C3hx19uR/uQlrvTexUYcCMuPfomQq4qjByQ=", "Lj8L7f/r3TUJvmt5JTDyBBsEFx5yndyXGKLK8Vr4Szg=", "FQTcjQ3OzDTaVupVIqK8eWDQ3S4OokRmuE9Zql2wFac=", "F4yaOZkQawR5UvuTOVwhQSX5iPsc6//+ze9CeKB247I=", "GveDJZbu88TMhjBhWIOhQ7e2mT6QtDMuZvNs3xZ7yDg=", "KCLc7uzrei4c8/JaAY+Ovfz8cgo543DGfUMz5RXdxyQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Jc4NGYQOgAt5ipAzJpsU8XJqT9Zgy9O23DyznAfyf1M=", "F1+CGVrDjp8R2wdziHqTM47gfShSWH+0Im8R2UIrgyg=", "AgF714ONC/o+onL/Log6gOY8coikQzmXsYtMXw2l9+M=", "GBiy2TpNgM4AaP2c5G3b0gC2BAOZ9DVRlO3J8sVbWsQ=", "F8WdgcIeb4P4ly/gfgyps1LQTvcw+3bdcpMZJcmnhCc=", "ATaUrmjhxV3QKluMGRX4eO373a8StF++n6J6KVSyE6k=", "EgIh2KhFcXJkc7/IStR/GwT/cOeo2OnB6R4RZem08Y8=", "FNZctvOy5Lrlrl7Ryvs+aOqGFE0n+o8zrqupKc/vTYA=", "GmEE2ulieZK2J7h9hOZWAJu2mjp6m/7piqgNvyG7bKY=", "Hjr4e9RSVVctHRTMug17L439ebeQaMbziDyp/uUoMKc=", "Dz0N9FqnvWKpdozSD4Rmw3t+xWYZaLLNGKvVc2cxkHk=", "E7ivAAQjS/NfIKfMe5/MyZnQ2OT1/28mwjeDWh/gQvw=", "FuC/DJok1GfjjDd4x2suIlD7HAb9Rln/+jCT9JOp7KI=", "JtKMNFOz1+ygjoemxGv4ppg4X/NY4j7bseF07+XCM8U=", "Jvz47uux6nsXVMBHusmtiI7b7OQoRA/iEC1Glp2q5kA=", "JzHMuvI0B5wQOOarGC7+Dx26PEfv/D4h0uGV4/AxlQM=", "DHhfD+Fl1dJva18qD/t97UQI60qS8+s9E5R+sJQpDZc=", "JYHH+qI94Yslls/BX/AdvIS+oPpIBsfRoKvEPnbuDzw=", "J+P3a3M1/5/M/8hl//uDs2iZVSHpib1N1qhs9ZXUoX4=", "EyNND+SfA8SijtXsK4BE6cfdIMuDHlQbfFQNtsGABjc=", "Eabq8qpVGDdO6kGZwR89k3pCZJS6YU3bxqxuodyAT/M=", "H8w2e23g6saMtSTPgAjmrb14PowTghiJAx+IZkdmSgw=", "FFgDi/vJPBKXT3R0r+W9yUy9U5yRMQAWnMy90UMVGiw=", "DySv/6qp8E6IWZ7WltvU6uKER8LwW5lxlOyDIYnN/iU=", "B8jhVzJUN66UXDxnxMdXSTB2uuOucgsA0MNcNkU/aCY=", "ERmBgZULSiR13AEIi3IRWpQoX/7EwqXKYU0TsaFPsxk=", "DtV8jUq+xeKQyiK+cLxedU4TV3HVNI99cR1zg2F+zzY=", "DOxrN+BwnUydWoziUoQK2m3V+5VgNyCvZIMZNwlBv8M=", "GS8LGM8XhVv+lCFKpHYE7sxZj430KdnHqfDIB6RnURw=", "EDI9bjhEFN2hEPUNZ70GYzNhlgo1f5xt5j+DdVPLWLU=", "Ct2QG95bZyvq0jhV/6pDGU5ma5MtYE9HAA8I0dJkBRE=", "Ft1l9BLPnxMlo89Omo8CwnNxssPZCIjn1O6CcT2+uq8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "DIavo5NT7bObUrv/icXBor++K0EA3wiV+nyC2Od8SC4=", "DEZhPWfWborjEZGtblu64lORaRNMUxHSXAbKVOnzq3c=", "A5VnjyRJw+Gna1ud8Gjl2r524VuoWJ4HA++j/BJEGEo=", "Gc3QNQCBRq8nGNfC6nL6clvi0Q77BwswPICbhht4i1E=", "GgR8Uclkc1SJHqSstYIpbfuQvGXJfoiJ8dB1/PIXy0g=", "DGzf6aDUJxoVAYouPy2A37dGjiFjl+heE40gvnkLIwc=", "vFkQVHBAiljtLogWqu0cKd069Gni5+rz4aw2bUDTEg==", "K9caNgvCfs0PLO3beX/8WmYtyWzGTPFeA+LmOhmqBFM=", "BF4Sf+6rjV35V4nf2WQmroTDRyP8c1hl+A2Y7lPq3V0=", "FT38tRnK7ngNvPhdFK8f0D1oiKj4814PXRb+3i/DviA=", "FOaglTkpE1LYANzG0H4NChW1REYLagDACyNv5b7+xDE=", "LrAmozUKbZKzmar6flKl4XMNY7khLmQxRz3sNLIn62M=", "FkG7I4xSDXstqA10P2MlsBP38q8E+DFiMUykVU5MA0o=", "Lis4VwMshlnEUz/b1Z0+EY2BDvh5lDmI5iOfqAi6+00=", "LDfWieIrHzMtwS/LhJDsG2eaXhWx9Lm17cwWUHrb/ZI=", "MCWmDKXg1WuVBzEMyainptrHv26UKIPG9zNW+KDCr7c=", "B/nhRubHdc7ucrKO2r4PRzWsE275AKYUdXDw6m3geCo=", "Axi8cct9ydX4sJnBZdJlRf4LvxEhZ4YIJchMGASTxr8=", "LG/j9+GAEAJd9ea4RkjQZpBnpHPYSbThgcP04D1CsSg=", "K/ou4V0cBhklM5lFE1AOY4a9dnx4ORFg3E7X7DI+V6k=", "EvfgCF1yTJ4oVH9Pt1g6aw/UaF8fqdjAErr0cBeGJws=", "BY8ny55LuLxN+LZuqbWl+LkM3HKzRcSwowCx7LbiqmM=", "HzTKMvlW604JmrZG2VryeK2Ntc0A3bHIpEWT6i/vA+w=", "DHM0Pb0dYgRqLfDVVYErq/LuNbH8EDv2k414OtC0RJk=", "AY5f3jEVoZ0gesK2h+E15DjZFctJXHSgBp/aM3D0YIM=", "Eg/eTcxqdEd3X/ToceMh69/qaaWJrJBxTqT5qWCOHiM=", "LUYB3d/s/hMXXfjUgVXpr/j89Ena+jmiRbjWyxcG9JA=", "FzYytPYfIIPLs+BIU6y1uv7sjHXcRAcSPiEzwGCQXtU=", "JrKI4f+FSUjjjP95SZZZcQizNfZ7H6JZjFqyaRqSdzA=", "KmiK4WK62TnG3k2ImRDfE40ffcyJidSMr3Lh4iuVZCI=", "AWD0uPSbIm825yNZUJ49rDKbE3Kn+2PwVdf5sATVc0o=", "DdsGLQb5nzRULtA7yvB6WaRWIB0m8V1FuPEi6VZdQEQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "E3hcSWi7l8jHaSV2U65YpzuUokVT+uDgCYiyn0erVJw=", "Dskczgex6bd4/axcuf+NjmQ4KSeBNRvtw92kVK/uR0o=", "Iq1YX+Pd3bMjPzkOw89DpXDMT1YHbtNmpjpQtJOm1lU=", "EfUc1wf1GapNDwfeeb0Yofe2XSuWtgI9GKh0WTls/9Y=", "FtIpC/80L64+D2NmxKPMtExhF5fnfrwn1/WsMf3Gy1E=", "FtTkf4LuOz2B1IozW+KPRSH5CpNWQaRRCXuCmNrwomw=", "Jp5qgNWNvBnvceaCsfqn3HOUY2/BXHR9BKyVBJb24Rg=", "LBaEIp8OriSvFPiUAjzryrDjhHA+ca1WGZxMjHDi3QY=", "LZ7eLomTxFeUkoGQeBtib8xAasOpdyNfnW5QJn7xj7A=", "EdZ4BScctdhqknMDrNf8RSGAmKuZ7u+XVuYhNb932nA=", "FwIG+aTk4NfvVcXNZEqsziMfdyfH+Y2XQXtyC8N8eIE=", "FKMMa1U2x0+Y9/xX0AQSnU+IfPGLqfhpvVYw1m00EyQ=", "JYBMxpOw4RjoEfOhkanW5HpTfLZBKSk8lHIG2SkOfRA=", "GnoXtACTS+kpAdTpGtPPyYIxqoQeCWJ8zpdbq3wV8ts=", "LAYylz9gXO1pmENafQytdsjJwiPCgAgPtqjJIq0J2uU=", "MESxZyHl7YHTnyq9KdXwp2HBP+JrtPU9CdWgViCZf8E=", "Diy04Ysm5OpEXHBHSLx2grwoNM7zXOa9wEO+7ihgJdI=", "HAM93BqXIDEsw1QeiGyyJ9LTfqwc+GxFiOmCA2kpQfE=", "HvKM6C+rgGpJ+jEcb06NBCPQUeCjUA25eP9zGpN4vuI=", "BR19N4UjSgnbGTmuTOqvFKRpKBie/I6g+hiJ5a0NEiQ=", "BGLJ5TPkdFxS3yNiOwty88nrjjqfKiKnG1zmykGSdCU=", "JqMygDMdSOKqnF+PY8RCOm3IAZuWM/Sa6722pV6lzJM=", "CO2LG5YYott+R0YRXZbMJexRQRvLB5helSm2ERA56Q8=", "AY/l2ZHep3p7GPG9XBg6N3y55cnCWRhn6y+Oh2xAxB8=", "JaP1z2bQ6CvgXqkuOpgqazKJ2ajlFhj5sh6g45ow5bY=", "Bhgv1h4bNbbwCOmQn+mZBL+u9lGWGOQ1EwFV0o0d6i4=", "GvatFkQktskMpCQTgsoM0mYMo4h3WXOwjmcoVwoi2EQ=", "BrU0YBYZ5ViJqqhVwGOiztiJxrS6QZDaMnyKYSwlVUQ=", "BQVVvAPL+vuqo4GR8M3lTo3PT94cyvta9cfgDDFtZVw=", "BXnPQK38BpoLPKwCpJX7qrAXX+lI3Jeshfdpnsm+l6Q=", "HZZwtyDnr4/PZ7PIMtQ6Dps2wc4RtnlVQIbT69N0OBU=", "C58bQ3Ld8rVS+1Xn0Ckmeg7U8JxPldG5mgjB1lhabnQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "CAYQv4lGwsx4LIPsPq6jZoSiy2Y2apqAG2P60zMujsE=", "KDfIun8QTbx1A6vaAxcxtKeh3uPuj9xwhlGnOF5W/HI=", "DkNIYZqkBb3E+f2WXawmWuc9zfwPcb+jqUPPmJZWEP0=", "GZ6eJQzhKxZny3MPgBM0FX8pBEQQsdmLLW8qJhovd2g=", "CgQJpK7chIDfSpn5vQvbAVHl7Dy7ZwellNiq1jNNTHU=", "JxnZ8ehQFeoGtQ1AavWCw21ek3UiyXRyex56Turv2/M=", "EGahf+xebNIgJ5IBXa5VNFFn6jW2plq3p/KvkdpZyh8=", "DksKScNxRXug7abNlf3Dy4EmStcVIC5D4t7FaZ++TYI=", "AktYqSSuO/aslvwR/6uSIaIoODDpU3fesuUALCvdEyM=", "JZyGBr4MZGe27wVsakGSd2xsNTb/qCyJ8DjIVoYq8kw=", "IdbAoqVMWunvndXyqnN2TzjfHpI6r9JC5fUjtTMrvQU=", "A8CZzcP2HKqi5J1ISrsrMOlpQW9OGlZ4uwJTGOQWZ40=", "HU1LjFUu8NMYqajt2AovNjwcCh3NqzWIDcxr88VIJi8=", "fkz2SOksJ2GFxBbWzm9bDA58vC7vHiUFVWma/f7AoA==", "KZKwIwHdGOAEgqmUDVmmkGgSfwaqpQoyMi36KvIR89k=", "FocVMeb+gRc9gILYBZJw5wrEEl0JUWFv835LSqaXVZg=", "IhwIoLfcWso1elLwEneX+engHrBdc2VfbHef9D8pXx4=", "J1aj1E6IvWVH0C+kRgwJoumCpNUFo0IWJbm8omBL2GI=", "KSP9473ldR2OrHqaFW0kRNuStikYXgHlYAxPtaLqU6w=", "F56+DSsXEopn+Pzl/ELuJsZU0qiSxOs8ZXdEjV/VVro=", "ChgU7dT4Rm9yId2Y+O8pEHoYxmMgglrN3djeZP6wJ1s=", "HPA9AyJseLI2n3m+7xDwj943wVDU56oZeXg2WtC9MWw=", "L9PpI+45+rw4fSFw6muaYpsKfigpbIS6iEP48D7Du8I=", "Esa9TyXC0ELk0O06HlzAEkfHiukOSa5yLTKlhChuG00=", "EbeKCyQ71FqqTzzbHHmrIG6VxAESicRO1NjKmWhsm54=", "CJRTCBB7pWSGARiY5rsmqZ7A8LkHGtnOCvgg0nJ/RZ0=", "IXL4WvxFDNZ8Hv69a+y8ARFLyLO2K0CB5MyjQYaTsyM=", "LbgbzIXlSL71BZsllbTwa1U4a5rroS9IP0mXjsapz70=", "DvXQq4Br5Ix9C0aizsF2YIPu9LpDc6FquyImgDMFIH0=", "F8r4IulvTLaDJZQ0QuZXNsDx4BuEWqlwgko7GTzPizA=", "IxW48O6YmxG5g12K1622fgNfhcJINaTVPMfXtZ/xUEE=", "H1x96hqIKAqI4qV8EBWvXF1OhNqQC7MN5fuMUli0Z5Q=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "CSpnRnw3mvlCT/3NmoFlewQomZICfjqEG/4yKSTgALE=", "CMcPWPAkRkY5BokbJgTS+vMSysAObCVPMK6Fh0wRJUY=", "D0r2flOVtir5idAcH6n70hmtGqSqK+RiRGCUC8DBKjw=", "F/faCApxWTFqGZSocXfwpGduJJJHoqV3w/xU6oz3+yc=", "FZG7qcYg+HEyuM7qHeTExfCYcnFP4dYyWeDvgLXzM6g=", "DMMPFSgKvqR6vgEUXl81vYd1ULea5CYvYb5lpe0Msk0=", "H8nLZwpX+ELUe7kGIjsCqatjUrpiKAT/pR7pnaPtqsM=", "jot5irYC0WkQo07fPwkzMwQa7WcEpm14LXoxnc2gkQ==", "FUhxTHNAluLK3vSuiN3pyIhgKeIen/VpaXHxHc5spuI=", "ChM6OdKW1CdZj4rPchvcBX8s1jmjMXv+8+7RvzjGEN0=", "CkGQ7Qs8lmttfQvwv+TVhud7hM1Vu/Mi3WLEznomKRQ=", "JkR+4EaGVCKW0GyPU5AmcueVFHcLPWSQc17p9d81hZ4=", "LR1Rzbeo/bDNfaX9wz25S92NUSgSNpOrH0qj544XeHA=", "F7IEI2sRvVxcSO395h2Be3PXzy9aMqiIFEx7CI0//dk=", "GRUQa2b98ghgftaIjVA/RHI8h6XFrsnu1lhRTzaSgo8=", "AcFx8G6oLSGLJCE0eYVtZjlOFg2+CyfmWacpTgf6ppw=", "KkxAwi4XwLyfUJ6x4wrOvt0Y692hgl45FSOnTUqyP1A=", "IFFaXYZYGwL5F21yvsaeeFp3xBoW+saOG+sq1B7iHxI=", "DEAZRd09jbzKifr45YsEaefnUg8uiYIhSk3CRNzKXNE=", "KL8IDq93NjOM5hSmLLsoBe6iKwv66sHQzSzesoMK4N8=", "IO2H7OzVTcSc6VWoP9TbYYkYZbJL0Jw+rIUDe9acUsM=", "K699bnhjqmhVX4v9dkjRtEJvbDn+2CusGXNos9Iur/Y=", "H89plEzIiVaSacUDHMH+ih77CxlT7H+Vc79jZx7HqUc=", "CYC96zDgSY88Re1OF6SuTIw77pEJWmNAIHtptN2ruDo=", "JFVSJybDyV3BTn/LX8HACLVzblafgFBecUVPiqrPqsU=", "I1QVkKxmUCluqcO5NQCeecRGKA2b8QELjmbN2p+JcNk=", "HRSvT0tU8Mk5jgUdKiIxk8eJl9WRpjkQmBi4zdAvVWw=", "IqdHh3vTXcuXUgoPSoEse3hwK60YEjfAGgX+6EKEDk0=", "Aur+F0DKZ/gNiuWV6EwXA5oFYLy5YosISpfZ/0r69rI=", "HbqE6ZSlSiFmbe8ivvuBq/Sf7HbEPD8g2pBDyYdO8tg=", "E3tHzy89OvwC80aenRZeSaISrCVWkaG9NWW84Eb88VM=", "HusaDtwzo+abhEVYHujw3fhHSP2QFUfUlEDIY8oQyuo=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "A+VybyssYJBt6wCjFDN6nG5O7nBJekqVPqIG0gDbjWk=", "BSjQN0MQ3QQtX4Cy5yC2HEIAU5/R4aI+4fjzRwQa8Ns=", "HaQd5yCmHM9uO5uXyjbXQ52hLJJUmhHSOEdeBfkDegM=", "IcHZK6liqxJjHk9xD8mwZsNp70rtcJ/V9pkvV74lG5k=", "Lry29JS30Go00tCXwPRu+SlkbFKfbvyg7ern5zOwJ40=", "JroYvL5D7hoq5uG03YkVHsF+E0GDm5Tksr+9cHYar0k=", "DwXZs5wLmzyhd+5aixLeRX0AZD1aZoqPsw1sugJmrjE=", "DbsSAS7EZycdGJGE0Ibqy1MMG8kGiVhQvICvcutuSaQ=", "Hj1jdVSIR58FAsNOCXx0/tGSa2E+l51TpTU+qVnubJ8=", "KTn+Q/RpDebswlG3y//8oIL988hB1ewap33mQBbSPA0=", "KbMExK+VA6Wh7XTPs3yemCNUBKhR6RX5tHb5bPlyCOk=", "F/WPr/3duSiUynza1M03najBdAdqJQw6aUQdZJzgS8Y=", "GRRW/uh4hqeuPUGQGgXnVdijzColGcwBGoByTUMOkYo=", "BDAfuyYJPlnrWBiXFGfBN+t2M6AOjR9RhW8uOFlvPS8=", "En/p8zKbwzdZEUlQ2K/khKmOMwEdpuQKQdwfTKLOh6Y=", "IBrZkdpHXRRthdqoXFyj0tnKSP94hrBuN9us+372lmQ=", "JKPYUAbgzN09b8YmI/xbNrGCetV/dRGpZ3zDYyfOvmU=", "JzGT2bKYZ2e4k0hJk4x9EVfrwyV478x1KNmmoYo1SVM=", "K7ZKO4JaYfbItXeZOqY6wAZZIhyv6SQFvogQJtpylnY=", "D2Vuc1k90JBUf7WzuDYdFyyT+UozTl/t3AWf0DiQaQ4=", "KInBj6LrVy1HS27ugQt1CUJYbyeSsUb0VaAjuJVC01M=", "EO1ff2C6tbRzKFrL1Z8OPdKZ9tLR5kEjIuv5N49KoDE=", "CU0PLS2sS1SaGsax4RLstunrM3wAhsssOcW5ihgDkcw=", "G2lQKWyamJMNKswXPUHkeI5w5C4/VoqX2qD7etjS7rk=", "InwvaXnZyjTtFxYgfz1w54ubdrH9vz6peuS1SCYZDiE=", "Az7nDuCfwmT/HPqQYHeM93tyXSTFWWeEb2rrRoGJ9o4=", "EDq5hiKm3RvZAJSjtptjWHOkv7CxZFlkuNAzkBkqJko=", "BG9bsLormozBmvUL0f6dPnPk3zA27lab7vGftHu6F04=", "GVVoX29vk2qIf0iS/Wauli84/sIoZ4i9JG9+ykW11/M=", "B+qp3mae8UQtxtYW7AgNbJIflec7h7fDdSeC14RtWhY=", "EQPJi8YMsnasJUF4tmjnQ7Z5PeRjCf9yKRdn5pdRZSI=", "FOEUHgFjrSp5UiV4xQJRSdStC0hOoIN8Qn/9eYtcIRw=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "BLkT6CSQOkt4/7+pBDEXQC+BbSS2lb4UfSb7YzrOj7Y=", "EblZyVpNpF2doFYC8H5pa4rAzmeBcCoTaNgH0h6qty8=", "H7/Ib8WOH6QDIwkWUYSsi23IHcH4HAn/EAdYNHJD8ok=", "D6eGUyeu+CRvRaxz26lmaoU/qOceHtwkCWRyB5IqkEE=", "MCAXDee26GsrD80EQ569qqjOAQiWALgBlF3e0MkG2D0=", "EOctjkYprHyP/93KP4N0dZBA+PYeGyQZzyZiVdaEltM=", "BekPGJI2O5kWE0WrSTF+N5LrmlNvRz6F+kdIC5DdKoY=", "AkDhkNC5L5qnzXvOAIcZw/jV//WH3zlYyF9aEoYoj2M=", "FuhBsu5oJRPbJ+I7mD9fq75q06PUQwOWKRAwLq8whA8=", "CKOXtXX7hvrSiM60j0MxXXA5nIvZz0ryX66tk10CJ3o=", "LtrVIUWxCz0Ly9AhZXS1LMK0QvkwirUooBiniulwZ/E=", "HKyi7Dw9Zhf+++aQHEJS7AHsfN2nV729X5zGLpEc2mE=", "FXMD6f4RSXBJ7PUw20L+pch9exTMFTEgurt0OTXzDeA=", "INk4A6NfBtdqtdruwo5FkdAGYnHYTt8mZg4DUNMKkEk=", "CXDa4zYnopmpy/BJUF2UzmzRJWyApjIq1HR5RIvICKI=", "F4tmeL/Fwdn61vp66iR8trT6z/vUn9hGxk8UEbLC9rA=", "BlA7mKbMUlvShrVufsgas2g1yWnUEBrCSdPdZYNP2Zw=", "ISGOwKeD3JJK59nzgmB1DwoOA5pABMwJXVu4jh+b53E=", "DAKJySIGc5l/A5MmeymrBIdhA0oW9rbgdrBj7GAxhG0=", "GYTwN3n/TZtMz9h9I3APIEs4w6YGsCeTJ8qB/5VgtI0=", "F6pgQmdvODODJiBY4oq3xw09GbT4rU9UpDhp4DdHAlg=", "LuGwCaqaG6WJQRA5SnnnOXVNnyNWzPkpOy2FHdtqbFI=", "IqWG647zuCV0ebyi2RmvxW/QhG2/9POp255C5DNLhyc=", "BkOx3mMLS5olCw6xhXxDI7zhcBr9sC/yxlN6BIR6xbQ=", "ElurKPXrXBXcCz6c4rHmuyRuvFbET+mUPcHqSRWDADM=", "G8EK9w9xJdhfNK1O9uc0fuuioRMh2hmJTF+CaIDXcK0=", "D2uqYonPdtuG2RWsGa8FNXcxV+ObVCO0Ox89DfKk71w=", "LoDvdgU/bYFfWnefunTpsDv427ihnUBVDFGaNfORMBw=", "Ax79tdJF/RYoPOqrH7XUrBzQiRjAwiJl9/EUqe8iBYo=", "Al77jqyR86s9d+qO9SPIb6VVUW0yeYOXpq0AYiCVubA=", "FM3O6RUOhnk+Wf0mkKKqECwux/eNHaKGgmo3BoyIWbU=", "EBMgq/StW/3Xvzf9G15a+o8bRywC4GKnBYeA/CFTlsQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "BNBln+7miMxNuq6k8Fsln3YUz1pdlwCHAWyy8us0O/Q=", "KR3LJVEKNlUGboYK3kYeI/pPibwm9SO2W4iq1adTYjw=", "HEC1WJpRpbw+dG+TwY7ob1EzHo2jokaQm2owYzk6G24=", "BQU11YprIGdtnd4YehXJZ2eB62weRhWfnmPX23UMZBA=", "FTJ2XTr1qtM8fK5SNZKJTPNUrZiQR51mLOPNUXIReME=", "CKaBiz1EjUPBte81dIjACIPjQmkKIdP+0h99YhQt1Yk=", "F9tMXFn/Gt55wBxF28e2E0ySnKUpLNeJOgFlc+dpZ1Y=", "Kn4fLTZc6bWr0+6vmDxvZDTNul6lkiL2vTpdPs12P1o=", "BiYeW01xiKyehNNB8RUqRRj4jT5wHtW/1xEFd84d+o8=", "GZxajwcDdn/jLaooBBn4xnk7sIiOzfy7TrFjMvvAKKk=", "EziNnYeSmEWSTgeCQ6jX4kdtd8z4TxwF9/t8faNxve4=", "B9BEv3pP1pimdXwYbAjXw5wgg8jLxb4plk5IFZLuZoQ=", "KDzZX0dD0havBMF1kbGSNnKA3SRA70c0mo84T2OIfNg=", "E1Y5H3UW2xrQSB6/+nMDRBbKojYr0mEqn0IDTjXpPic=", "Jv1+H21lexvYMz4/m1SPVJQbnRODC8iLghDls1mwD2g=", "J+yUjKICiFCpd63dapzMxpdATU1LR+qttUVYxXQ1+RY=", "J1KdgV79q0+k8hgpujEDmCq3nmBS+oYwRDlPtfyNXcc=", "Hc4/YfNGOe76CjRP6nUKV1HaBpXld0NPIKOGWM7pbwk=", "CRfJfUbVtP+JtczkvXhcS2jzjFO+rpzsfozjH3sRq14=", "Hzifdc3gbHyjEForV2nPORUpLrtE5YGSKf4/M/8R0Do=", "LZqsHHKwo2oGfsd3bAziE47tPpDDw4HROyjEPyl/8wA=", "C496jkwNLVdXxQHkSlHl9RYKAUQCgevUR5uFhhTPwJ0=", "CqFVNt8uxZBYd+Lr+dB9N2Oj+U6bTetcZjm9ie+4aso=", "CwPdd6dCT6jZRUQPB3+EjkE3MjRC4R4bSi7+l98yFK4=", "BwiYpxlSr60+8AYuhCDpLZT6e93FW+s1Xc0dNSb1ONI=", "KdVBO6JBai20nBSxZcskc2KCFJTXOLV4l6C75stTooc=", "B/P4B4cruOxy3SzLIjQHoZxbZOCGzbDDinuSRYxffI0=", "L2kzCST1yono6kGwM0eWqZYd8krQq671EG2JljoDjwo=", "Kr3PGUC/JOZ6tMjAlC3300QNBDWdpChUGw8Sj29TGE4=", "IJ3jdjXVf5/w6opr587Fxw1wEVa7NOJcCUjHCQsxnsE=", "ebSF3iatWCaKOxvVzfOh284pHn4wodZFpyaNNAqPHw==", "Lacxt5Qt5zVmNpi10gVwQC0mbfRI2KgBEFV2Q6kGuj8=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LI+EilbDOK/hKQ8StntX0A/46XToBKxTsXTqQsmXDv0=", "LQLxdxe/DbSKw2rQoZ5iHL9zsEk2TZRa0qli1IEAFDA=", "IVCwnH4Qq1II5jL439MLwyOAfFxrEipng7n+VFioWcg=", "BbEO8A5hiicN3G8xPoYZevK7ER7GI/KWRRiTjk0auM4=", "CBOu8IwauBFvLtjKp+rAB2KvrQ/PD+15B3hFsrgYiKM=", "IXeYQp3z9O/guAEKMwX2GM+kCzEian8Bqs8FdQ+F4wg=", "E93dmPB9o8hain5YSlQaPRwwEx5Y/RmnnTWD4eqwjbk=", "IAx16V0VTNXZ9CuUD9cJB2RZTgF521bkYsgNobV+CCY=", "JMYKp37sgNpWQgKAPjZ4BuhAVuqEVx53AucI7/IDULw=", "IAgGD5EM1XvQGKf+ee3FCOEYlxmRBjI6BDacCy8RAZM=", "FUsXMONXEda14Flqfp/fQKNpyW6YiVc3cuNRU3gNBqU=", "ILSPSlAZqw8CKchhPET0DWyn/4Drxr1vT1lZR8nj6aY=", "CNpmeMtFE8eecGGMf2okc3YpKij0uKJteyLP6JJiQi8=", "HjKUTssMjlOL6LcC9FdIy9kQxiG6jARioDptU26PPPg=", "EwODBl40IhQAO+9s16wiTfwip5mxOgic7+2ciHLAVsQ=", "K7HpRvkBng8KOm8xxU0T2QDpW5Jlf7SaC7HYsIWqe9w=", "EsZwZyRia0olEdXvTNwi5WnaV0M2P1mLCYXaP3TrzGY=", "EF9IdrNxUS/dho514CMyy0nyKPf2w86QEvyle5WH/ac=", "Hs32/M6e6mAXlJS+Uxe3YaM39cHup9S9ezbEsTa6iTw=", "Cc0u9tRdu8oNxlc4TdtWPzZwQgEN68JL8CakucWfDac=", "JUrGhV0FBGdFiJKVxIWqDRQUIcLn5GkHxq5gpQ7i+Lo=", "CpnAVLmji74ZkwkG5kwRJsnwqusWq2wz0eDilBjtzKQ=", "IgtAFvreV3golqw6yI5cadyl5Y8dbr4l98ruZzcbhaQ=", "Cxl52hwEj2714CMu95PxNNuyqeLI+DpxCUThzL2wjaU=", "Lu8tkkuIQUtfif+p39S2IEehLQ4IEY0NOaGh+pndkeU=", "Emrj0tysyokuyLmyM4lT070qCzQbftWYYTja4Utrq3c=", "GefDLPbiNfleL/bpU3sj+Psu9QtaH3NOt1c1KnTq9Jg=", "L5vLXgzVZgNQ6mFR5KUUrITcYGStrDk+m8Tapigpf8Y=", "GqSW+WNyWJp0zbFSNpGx/Qcr01Vg0wuMSBCdhsd3a3U=", "LqWo0NoT06AFGn8bGGs11vDrmGonaa7oUNOUXuJAlDk=", "CmM8Jf9ru9B+Nl7gGMdtw750tAYZiS8QbN7PPMT/g3I=", "D0EhSBWJVcaaMCubQuX+2zMNWrSmzzGyXU/R2BNcmQA=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "Ly7RSGmQuUMb6PwUhbbqyGn+9c2P0qlMfU1dp+SW2xI=", "DVFAiGwj8mceaYw3M6KWvh9Oy5f3UgsCfZBhif11WGA=", "DRuUJwgKmGVUO2++VQKJkZiyKNAvLukoe9G8G3FoA3A=", "JfFHhEGeDYbrpiqc8ssi8GPK7KUpvhivH6CExzKHw/0=", "HN92ea6xeEzYHmnkGAc3dnEWM3LKUBQ+WzDu9aMavqk=", "B6vW86TFPI067+SbJXs+fAqs6IYQemFoqfk+M3M8EiQ=", "GY6N3mLkuADkpQgcxD//zlugLds0l5Wpuo0so26uzv8=", "KhD8u8GF/3ridRFfVmQKmriN/ujS83HiH63jH/nn0kk=", "A/dOcCVZoUnDzLXdg5s/gM4QDCZnGSkjak1wPG5T1Ts=", "HpzSQfllWTZgeYCbA02Y3DRaSBSn6Ufhe0Ghm0oRm3U=", "B2QLO0iyzskGHIfOR0DSgcyupi2GXQs9pyb/zWfS1CY=", "DyJPKj7rACRS4l+lSzYIBNyd0aBlZVoxIw6RofeJbto=", "KWslZS/7ggQTVmNLUFrsDRG8j/6rBrbudvl9PpDhExY=", "JLHoUqYWjKBb/g6CP0qYSzuZ7Zvz9lHN08oxotk6Iek=", "EXA4DzWwwTHKXS6nH0L+2LPK78SuLdtC/85Mct+XVSE=", "KiEUZFiptc0iMlROyEucLjwHt1y8Si4n8UWJlaXPdmU=", "LPQMOA2h6EAm5YvKc/yIIaaVb3hmu8ZZEzDHsIdtHkg=", "Ck5ajCXHkpHm55Bqi7mJfb2RVnBhq75OsrgPflkautU=", "IZzMrB/4KO5Q2UE2KcgLhw7SkNWyGXoLnbYZYJE+sp4=", "GKSnQ6BUSIRLRqvhKQAZUzBiNuzMzhuMiF5xIISuQNk=", "I/XApl1tP0sBemjVE0E+cCqyGVoS0wB1iaetQjB5Kpk=", "JIZJ0iu9Nds8MX+28eIJRK34ByD9CFOU5gb+WMk7In4=", "HaRcunQNtLUPxLJXHkBZCtIMclr3OT0uIJb3gsqEUbA=", "BZyYlNOacozjX1aci1ms/yqYkDpz1pNSNqxquLtl59c=", "E3r8HaKh3RbkBJw+I5UfI+UyThL+BGZSvrTNpEmiHNM=", "HGfwC2g2CR1mQlkqQMJ7m4dfUcyeuAQiETDT+IPSl2U=", "vqzXkSm5tseTspRQzmRYyGR1lRym8JQf+qpzYicJvA==", "HXGU8LmXCxA+PUvVpGtQVKtFvUL1NzJMtv7DxnLNXwo=", "A4x0H4YHp48yhyWtGNK6+GQsAFQpxT9bf5uL5RyKUHs=", "AdMu6G0KENETuEAKMwHunfC0+WZsTJYgc7q38C8MVec=", "7HjoK6YC9Ktn6Yf/PrRWKwgYxIHG6P6/SkoVfs6hWg==", "Lg3mrs0YSm1HpqeuQrdjRvFfmLxPD2juGlWSmTmnhCo=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "CT0TzZsEOltqWsst4LxU3mi3HIjo1hwsPDvVL+v6tog=", "CA+rTi422pJ25GEBl7MtKOz/KNzxVfXbWWA35BooiK4=", "B9LSRXZMhWNyKXxJ/2Q2WpkTes+oEEGTK0Mkh34z2bY=", "CrajafPUeraLqa3YC0a2ENOVMeIqdaMN8/MvS+3hinM=", "B6aDzTxOaGIig4WO/xIc86XsLLSHY8KQpJhPfnWoYTk=", "H9RMhNniVLHG5gy4wWgvXnilyfnMiOU7i9HY6b8gY48=", "KsK93a4B7K1sCX7BOffUQrelxIxJHAqDoAbp3RxEybk=", "JKA4AN94q42sOxcquocO/eZjF2WY4kif4TcfG4/Zzgk=", "EuRTZSGU3cj/XySfBCFNLgVxrkbtolHtZsneb0EuCL8=", "BZKnmPQv5Y8n9QPyrFEihvyaAnHtu7Q9JjNYaXtzFmg=", "CpKpbVW14CyP6Eb4z++S8iQ8vVNbazwORNPG/K/AGWM=", "L0PixuivBjjhY+L000qt8t69s6XfUxKW7ivF39KqjUE=", "AxF+mGEw0cJe7Tnds+Hkr+94PgMdYLwX4GgSiPLZEMo=", "Jcr7tDSu4G31+QJBcCAYxv5ne6C/rEb2tbgxTvj11Ac=", "KLeXpJnCsQgramdKwC71zCRA1u7h6hvh7VpSem5czJU=", "I785OleTlAA+ZMw5lQaAeqaEMUopmS47uztn/uf1DiQ=", "KGVlZNZ31Y30QN5DEVCJoXkNGqlRg7OQNJaI6MiqPjI=", "AkGmlQD14TTJkyUv4QUsnNfiNdUBs7I0PuDkhX4tAgk=", "A3ROAs6F5ZkUcWKki4CVxh71gr0bQCdkmktwbp2Z81U=", "BZt6F+HA6ITe94kDNmTYi6ESmA7l185DIPS1kJKkk+o=", "Km79aOXavJEuwrX3gU5uG3uIk6zRDpPY6Ir1zs6eQz8=", "IIJv6YCAn75X1699YCYqvVZieNcOA8fb0keYycmRzls=", "GB5WLTeSK62XmslvViARMR8JGHYT4ZY5jTzqZOf8x8o=", "HE5w+9TJ4J07NB4an/h9CI5rxNiKXLILw5oiFumi54s=", "Fwxu43qPrlqUA4hxfB7YI3+cLFHgdx/hxRFPAgcgscI=", "BocS8A6umbMQkWLDocimuDYDH3s/6mFHfSdPw5z1O1M=", "GTegLnyOOdfzqIqCw43Bsran9DJs6veso/ii/RY/E4g=", "CLmbazOK2q7Ifw9OQQbhp2k4vcsLVdZrmvJX9G2lxt4=", "E20RCKjUvOqACQuu4zVW9Z3PJqg2W29lemYlAptz81Q=", "LYpWc4z23EeF/bxo9ED6Oy1N4NWrbS18bBFknsLk2mU=", "J/Fv6vb+FSXNZ+70WCl9FpbcRb9fjx6hjheAE5nzyk8=", "A0D41mShr+T70GeThCEzzUPuTgshc0Be+hBEX0Ohg2o=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "FK1DXPmp9B+/qmJpjqKwHXePpq0+bXXWKOU1zsZvYYM=", "Ip8UhFFHCChctshm+reIeLvDmuw2K5214ljBAac4KAY=", "BVEE7A3765EKoIGGS9WUl8/mWswgkcLMZ167fHsqMY8=", "DXWx8YFENx9aDeMtyRJCMESPF1hO+T7YQwAnC27z1M8=", "Ch2jpYHeIzfoI9EMAK9k7YFSozdavHyOA4WSiT4C+Hk=", "Fc5kTJx1PytQhZXSTAkFs3EkEfi9eMHd22CmHjV09Qo=", "AkklECmzp9g6RELvJ6LzvKPtvfyojDMJX1V87OyiP6c=", "IZDgZXt/RZLtF4hOSGqgmD+W0F1JfxLZuwj8umXhRqI=", "GOfn0DHqS4ZUdeypz6LxVtK+vY9XxsZmMPKz6b3zqhs=", "DCPdaM45d5D6nUjiIQgHKtAt8PgPaEkm/6S2bohxse4=", "E0a+OUWCcSgYsS5AnhovgPJYvgjo9Sc+QiMEim7GhZY=", "InQTo2rmFT5DHE3Fku61l60YsKEZ8cZE2HQcXRMCv10=", "CwrjcUJV65q+w8YNPp04UsM9uVDoe8F4GP8CQpVapZQ=", "H2X8RhFpElU8bJveF5oJKIvCmrAB+n9YsrNuEASdp6E=", "HDUoTtuhzTkdYYdUsX9kLuvtQSc4K4L3wosucKj3DUA=", "AQgKP94OQq192G3gQcq3/dAllRZBlCN0wavPYmJvSKM=", "FCjrKh8tkXB/VGry4KFP1vEe7iyhLv9NNmNKCKJQHYs=", "AzUDxDRIdzHXVOktbozjJ87suuZhcRBFBg4WXtKE/Sk=", "E3pdZ9jC19kvg0UaINBpjz7GnZvtyo/fI+TMdhwwiVw=", "Az/1SgVDqFnRDSORnZNT6xx9+MN8931xwDNCf4eF738=", "LvRdlep6Km6/fNQtG7Pu3kXM7rPBMST+Pkv5vUORmu8=", "FQPMLJ9oael8PzVvwIiM7hGxIldresGeU+IuZFQbhkw=", "E7fgC7FT3gfOyt0lJfBADsgcfz8BsvjA1NkjYm9QdNs=", "FWDoKkRDjHXL5ee/QkLpsxjoTQ9wwke0lBIUpU4uy90=", "FubL2gWeqYzTiLyXtAehUNA8vFTbRDFKzS/cuFbtWeo=", "Ik4RCcHrRQ1mXbmqWjJHVOneDzZFw2pPQsBlJaagLxc=", "H64elcwUWxthGumDUpIeViFWMBm87FTvmqCgBsXKnA8=", "KcLJJoNDr8JEhJMgXY7+PKEv9LpFGV4SWxpYWzwVNiw=", "F0WqAabez79HQspOtPtGk2xZOo+7F1Pksb2KwmEH3LY=", "K44UnwrUCtIcdLo1Am3dv4nc58Iiffz8lKVRMLKCNI0=", "Iesgs2+QbSaT835rJfEKJR2uiO6eW+2X0L/qnZXrYVU=", "Li02fr0Dq56GOicqDLQCQCIvMtHvP3p53pkWAjbN5Dk=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LhQtUbs8Y+EWh76iewPSwfR/9GF9zxeE/LBhOXGL3A==", "L5oNjSK7F9yR+0AUarYRwk/Xr/JyETnuvGfxA6uqir4=", "HNNEb+dL089Oh5CGnKUCMV4steYb/VabeeS866fdGMU=", "BIgs3zaaa2JM3N8UBSHi9dTwVtW+iTjq/asCsrayg2U=", "Daq9ltCACJzAm3U6ET8Dx5zduHn81P6S9kCGrzVTIK8=", "Efradl2EA3EVnTk9k4OEanWEUhZHeLFWrQfS+XscgdU=", "Dxu3fGVofViPOv3S6B7TGwsU56azSz8ZQBMxCkMOcv8=", "G2y72iUEtscVcHDKsYpkz6Z7JRdEMK40+I9B0Gpd9hw=", "LKrbmBXt0LAIkciVL0OWVL/2HEgNNDBKVZsu4QboVVs=", "KdZHwv8X2Q2KxQDNhivHzzvNY8rkXRO6Ky9b2BnN8Ao=", "D5V3KBwBE751UFbFogDAO2Uc0XXvTBxRUmomLbeLYBI=", "HHpBBLHrNEqdEK40/p8Nm5RLHye5rWDnjQdvFLFXndE=", "KIM3ZDB8ByNrjWTx6HKhXya5PLqmMGLFcotqYSais9g=", "JF/5HTbfmpMBzJmKEeoCdgWuoNrDCiCjL8W5VG/18i0=", "CcO43cPIqDs9vAmM9Ue1HRl/oWVxymzhv6YD8jR0GIs=", "IxI7DxaQ88YaPXh38m8zxMJv64V5lmuHj5MT8qe7ByQ=", "L0LvLxdHSMRPY3Z7ldXmayVU91oWTgCDMzap2ZD+Qnk=", "HYAAdH4D6Tw3/iG4ib2+/cI0uqKQpoq6UdNReiYOaUQ=", "ED93mwiZ1CUNo/wl0n4ERKGEmP/AvwznrX+xBroxGhg=", "B/TJ6sq/GAuEDMMESNSSZpLkpNS2yXDg6BjF4R16mEs=", "F+XgPs8BQIpSDBxbuOGkR3sBEXiuwYQE5BRVT9eNp3k=", "EWzRpd6zF6wiANkXIctMeU/RvbngTIDSIrKud83+BBI=", "JZhH/NaUE6i3h6RSlQy5lwmBzoas6TMRLyBbGLIK8aw=", "ByRLQXSYCJkZP3AxjEwJI5oBFDGx8L0/XHno42NH5Sw=", "J6YSLFiCmWuLh5I6m2aipJcMmETNMDToR/7NkdaxP8w=", "LAvvaIXZpNdvQ6Kd3eYW+oF0zSSrWNTccHul+SRznEE=", "LQzUjjlS9NZOTzdHfiwKxl/LeGgtzY+kxOnXRMEgWvk=", "CNjtyegd+6bNcwXBv+c/QtclLbsZiJ4SXFya7xN4BMc=", "IIYKcxwVesG3rYVLO4UdDHOfERmVqBIqqnFHzmE1Whs=", "KyQs9R4/yEH5JRU7rGrpS4TA5IOdpww2Oa5VSi/7U4s=", "BxZC+PsAjKNmxWLOB1W9Dtwss7GFHZGHH3whfGwXuBI=", "EGKDkOuMlIndAFIMTR87y3kX7oSersXQPWYhkuQOTAU=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "LGV89VZVKsANPGoxL5QcIXUtgPb7lx9vI3ufBn9V71A=", "InTlr9QfSE1LuEbCP00V7siS7RKr/Feq3HHEMd7A7JQ=", "IePurYKSOEzU6auJaYZ0rPiZsxDE+xR0pQ7WirFe55s=", "J1sOCQiNGhQ7ODTtCbq/ykVpQwHrOWgMfgFFaRhZYUA=", "Ep6uDQ79ZinyhG4mWdERkPmV5/eXbbpnBtUnX4rkLis=", "I8Mpar6tmFspjS9zWdb8a2ZChGnv738zzOcvfSYeIA4=", "Eg6zlJobxtrbmet5fFCJ9sgbhIno0v22SHWfm32VDJI=", "J3soM4Vlvr5irREo39J35x3MD1y/FYhPP0QxqqAiriw=", "BPNuOJ/567O81oENiyM8DMzS0KmobwxuztAbzN9FOpQ=", "JUj6ZUdWWAZuKC4EP7fjouWRatY18nl30pKwrT7z5OU=", "BFZVd8VTc+7ZXJqvXJ0gLCcM433BoaIjLIVviN/5Nk8=", "Iz5yeEwR2oree58XKTXkSnSMjLlJWRIvnabH7WWmzxA=", "FYty8wh+Amczbif8OSHuOjpTS5Jf7LgnyiX33HdSMzQ=", "FcJg88MgIL5JOsgdaWns6cjoqrOcsRrYxpvZdRaIZSI=", "I5Y2LVdLIr9PKxYt22h5rkrugDYJxa+BsMyW4d13+2k=", "LQvfvZFHGVkH7TVoroMJ/rNJ/f85fDa1Zwma4Uo3cP8=", "LNSHxiOVdXSNzpobHpy6qqnfS9u/pk9oq27Z+WhYmOw=", "HnOjKXaEsJjP0+Jw7EKZ/IjZcKkkWWAU6af2Au6bCBs=", "JIhismZnv55xJVyEc8TU9Ji/Atb+bFVOnWqBlLRDx7E=", "Etre1lAtFcx8z9OZjgHDmFFhFin9mmVi9ijvg8eRC40=", "FemY8AzE3ST/VZCJzUO+xVZvJQW4E2xat02aQm2HXHU=", "IX+iPVsUqf+oN/zHRMSmT9E+b+Fid3/INL8RnfMGyMc=", "DK3PmMBqunxvNUzQW7KIV/N5i4MRFlLd2m4vj61qBRg=", "HFwJBvAtSm4/4xXyaJHa4RMkNrPP0Ej4l6KYirsU4AU=", "CEUsQTGnpPVzDod1Gd4bknoCJg9Wqw588j3UEBAJPO0=", "By5FGJmLsqp98aCU5KEDKk8WUUA6AGr/fY0/jgQxs5o=", "CrmIjSkjK+pNzXfJYnaTpPKSN11quBSC6wzXGK3MR1I=", "D8Ll32C7ShiSU+c/BwJbNNrJ+PbCFaJsU/pbOxSC4QU=", "BQ6C6QpBn5HmkGJcUa09oVavylHtE1MbDmejuJOFJzs=", "L4ikQV1+iM/TzfCltLvCayQzGeINDkzoYaLypQQuk8s=", "HhDndtXhXgeGzV0O+W0aszLrBXc4M+ogzVoZiR342pY=", "F95kcizSFt8jrF/CD0KYvFwj8X3oLIDTYaHMEMPzt6M=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "G5wsTuu+dRZIFSJxTM77z59Gsdms0ypwdPbiR61syGw=", "AbQMOdutEkxXASXrCyWG7JniYEEeDdhxz/eGnsOGTfk=", "AzzZsXGoPyGmQ8nbYXT9sKEu1w6W5NvNfNE4iMSz61U=", "GcuODAVEADR/rP/2bqzZfXlL1htZMjr0Ea0Pvi84CUI=", "JsIYUR+HC1XzBeF4fksZ4atoK4yCMVOr+H1rk9gI5Nk=", "KeEseUhIv+Ulq4HOZZ0s8REf6z/XEY+U4iqGtviLU88=", "OmZYqDTE42FtxfkX+gYtJRyLpMzNCVMuyg13mBsBcA==", "ForavWeDj6279Gydlxb3FJSrB39Cys+cReSJ00Kj4Vo=", "EXQoYwOaZ4jfNGTSZEwjmxkpw/FvQ++vUF4kFvXiOhw=", "Emq62V4rUf2YkXPrJNFw2zWHnS7ZWutT/EPze5Lg2kg=", "I8ISM1Vpzl85VT6zKBWf7726meo3vpc2X+gEnlUMk9o=", "L03RFwzVaB3UnP+isxEF5/F3LBAnfaZDYgiqGklsDKM=", "HxrdXbRgUC59d6Wr4GtTkb/ZNj7IRfc3ymwHL0bSYWQ=", "DeRkjBXuHClvS7xQ/PAzaAr+h2TJO1JNDH+WoXyPoME=", "KUDz+AO3mmnsE2cMO871izqmIlxf8bn9i88c59nag6k=", "YCKiwOZ6Vsoh8glSDreJicMkQ9bWamWd74+wnkHcOw==", "JhSyLtccHr9WMEivrXtkk05RxsF4f3nWyssM+kAWkvM=", "CuA1Gj84IY0/ZGgupbS70ZydojErbWbJik5Xk/VgN7Y=", "KssUJGqDcvNulrribQKY0N7CqANzJYSFQNCSknskevc=", "BKwfO/Wf+CWHVYeJGZESGckB5F02jkhf1YFwKTXlk7g=", "Y3w3IvWofzwUhFNFa0vZHd6GSo1om3OxI3lVjl/kJw==", "LtEPh8V+bk148x4Y8cfp7nwLWRF6bQNOLq0qrhFMqjI=", "LbU57/KbHE6TIYxuEOlVIXn7ewP8cwiIL6mtpanrR3Y=", "DK7cYuuI6hmm6l/eFY2ofHT1kQmcVqEQRn/LstzSH3k=", "BIXVgktNiLXDKnFWBUh6a1iuk0YbFREPKn9xiHBplA4=", "IPocGEY5P8d2xYaMbrC4QeZOr2E8IAXqNhsxfau8pT4=", "Lhf7NCCCVBctA5KN6MVrjMKfh+Keiu8febE7+1566Q0=", "HUX1d9sl9JAnYAg3bPi1mgjyDUadhnYBD38oHVzRrrE=", "BI6ozZKVoaPkjLIlB+cjfQplZrWOR0fAiW++/Xqgx8I=", "MFkZZCjgVNVY0OagkVWf9Bnd/quOKqG6eW6YhJCY9AQ=", "EXDrAC9oJHEVci0GOPzqfCt/cAJJU8czvIzZSobCPKc=", "Jfy183X/PVzEnKKTaxIdlZG+Pgn8iO/upM+QUhqgS5c=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "I0RHBzJfx2g6Rhwt6iFz2EcsC1sTcBs0uHIDv/6PSqQ=", "KycuANodHR12S32pOEzS77jbhgTAG58rgzp8FSA2njs=", "F7WaNbyhea/d8kmToqKEZoYjKNZs8Y136L5flQ1/lXw=", "IEYNXH5FSHcsYZ2+iiILR3iCAFGAiHN3wOy0tMIM5iU=", "DRNGro/PrvyWSWI16KS2ysMAooT5e+aPCkU8VVaeLhw=", "KdXI6QHW9lniybUfXahzx3alXen+CpWRDFiT2dZMGA0=", "EJKXxXlQ1ew043GvFP5AYV4m10pP0lYtuviwz8DaZ7U=", "CvopSwuJc+dMa8vN8JU3JmeSaN9LerOgrwSW2A9OkVo=", "HM2ueJSDQU78WWt6dNIMxa8t51ldU8gMZ2LlmcTBmRg=", "B9gN9Oly1ZYuhEdFQDPZEhJ9KTD9UinRJ0qsuTqzVGc=", "Gefd0FB3s3EPxs8VoXRv8/LOewrZNVvcxZnogogbeBI=", "GcUqQ7ilO7FG+vaB6Y/IZwgAtrnd5H6jioSbgsHxeSA=", "LtL9LzoveMNdTsVKQbmUHUBAv08HZphcd2tnJnRu/rc=", "EX6bku8wXhzs75DLQE9rF4sdLCFujDv2UK1bn2daJEY=", "J9vkmAllVGGilAhQqoxBzm29UiFACp3OSfnz/5sE3Vc=", "i8hasve50xUv7Df9HGbvaI4tceMl26QO7thNztTqEQ==", "GFUKeDCOR+WsdaPNgtQ4mjfGkY7UK/+ondEoxrTNb1M=", "ItBsT7bytyWpPLnpfwj0ZsLSB4lT9D9BWb2v46m7wtI=", "Hz8v9epLYETQ0ULChQqJB97OJKnnxQjAmzt8vx0tszo=", "KYWi5NZvGywYw/ZH1ERHTUMv1ZfcI2ccyzv2HBNR6ZA=", "F36Kg7zGg4BeGvfnRCBuBfyZ+FtgWxDz8IZ5E/9FpSE=", "CXZmh0cXaI26PZVG/3HLP6gp0QHyvsmhkbWRXsEgtlg=", "FQVdIXe9g65u825PET96U//yGJhPc1iJiKy3+JBGFpg=", "DgGXs48WccP7ageMtEPs4SK/3Z9HSG8/xd3Nr+/cnFw=", "B4uMAaZ8TlyxVzhBZJex1LPY/OdjHO+RnrSjkBW7W44=", "JvWBcdQ/XVJTVGj5fz9KdqVtQ7sMhWCsmK1vxAnGiVs=", "LbPYkvVUrosbWBn71K558jofRic4NlbJO+Lj/0L358E=", "GWt0/dQ8n6T3cRGRHc7WhWs5exnaR0dP4ajw3mK8V/w=", "BiONXjzaojjHZw79ZNvM5IGBWWX91V76irFwbXpDqjg=", "IjMqTOa3oiPUXHd8e9yWBmnkqAG0p2uItm0FA5pT7qA=", "H4j+ywjgEB5HD13O4si4RtJWL4nNJ9kuawD6rK4wOJ8=", "DCraU6X8+0hNCmXFCTBfo/ANuKL5YdRRXBScheZ3yNQ=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "GyiSbNg7Rliv0tnP39zmuHqpoHJjSIkyCjXNy5IV5bk=", "FdZEj3bPGyAmJCjx5Ba70a+GMPs2HX9kRjmtW2DY8YA=", "KvXfoZzMkY3kSdXTtZLm0E14vXlubwcJjmRjDyB50ck=", "GdD/FpmUtQ2cqJa/+9kffztcfZrVE2P+Xw0vthhcJBA=", "J1X+hm334tlbwsgHLlQCym9Yi38nNKKlSkxRnKgpdHQ=", "B3oHJYv6IeKsJV4goNMdmgHMhcrUvALmkhpQftXfRyg=", "Ls4lD2jNIx37vdNDw2dibzzEE6Mr4I66+ZbcgVAAO18=", "KNXyn13yobT7XceY3S+y2Qmam7FeBpM8yzgtP3EqvFY=", "Kvjh/PN9z19VaZ2ZKe9fxlBd+nngYXguvGpL2jEA/sU=", "GjkeCKOTdQAQrb36fGIdOCopuYiG0kHP4MVnuzd0iVQ=", "HaP0BYzCzmVUhCWI2v5fRRdmFzAYPwuZ+a6sq/x6z80=", "HjsYAgBf5yltEUQcB8vqYeMrr1SE1A4xXLSeIGO7SUI=", "HspnKKWLmX0JrJ2ergW82Gr67sWADf1z+wKA7cmW1hs=", "KZHa2iaXl14F4PdLSmlWBVfTS+8TL/c/PszlAUYfWcE=", "E6nknnh1wVRTnSDP71BlNckUIgVM0EqhleEmlaBzSHs=", "DpfvMyXsOZNUVsKjMENe8QbVCz0kp05VBFxY2neNJzM=", "I0/U5Q3cQrGkCxQQrX2bvifSHrYdG0qwVRZCIhQFnuY=", "DOFn4XXrAh/iuRsKu5DJRmfqdsmhE5uVjs8U1kxhdyI=", "FYcQEHWZcqh5sYpNGLrAhwAT7h9kbWP0vGP83ihHroc=", "Fo2B9ig5qw4pxOA8D1cPnkS9de7N43FhHpi6yaeMUcs=", "LAwVdHnUJo5aQBeasKkVByuRiJsesG4bsOMMWTberDs=", "LBxuoSxPk0OoD9U9QWloZwX/tR0/8nZv1MYfgD5kjoU=", "EsLJtwhqs5dS6koK+9hwO6L/ZsMJ1I9ATX607bkKrfo=", "FqkOkWR3hwyxPPwez6c/6TZdNoVO/ofblKLY8Bmj7oM=", "HlZ0tvkL417zQ1QLGRsO5FcHvdNEUkB62QNd070oJ5k=", "La8PutH+Zzf3vKQF403QQypLzVrKquKd357Y/8HwwzY=", "KQjNR3MLmwMdFPd4xTtkrsKDjzNw+IMqwf16stEKMuE=", "E4UjD9EJWlxHinmAcSlLihHJgF0Q1PJ7ZwqGje/wpFE=", "HRY8WM9Iu44C6zGTzf7j75yFEzwU+H2xgpZj500QYgo=", "LlV8OGdMQQ9NfHLuGjaJj5wWzL9b9HCfSeHnJ9/6KlU=", "HAXvCMBobiN8zNfJ9yeeWr28OfeifdpyOOc/N1JjRt8=", "JSfU10Sb5dICrsMyWaQ8Xa8l2wNbpViwMwggOg4z9xc=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "EKSSrltIfyWGUaOu0CJ8wC9seodhWGiUx05QuErYCBo=", "AkA9XARWQKOGfT//IsM9Wn1Mychvt/dG8M+qbPAAkWU=", "LV0deprytaQ0BmuoKa1RqdWWx3XXfc6bteU53whpCT0=", "CahjxwDdztF0q5ovUv6ram/FDWQPfNoSjT4Nt8xtVCE=", "KqsYD24xb62Jr+GMrJU/4Hla07Jn1jLUGSzfen8J+28=", "DZYEClUMqdpTQQwpG7A/JZdUa+IiwY7MPOGmuTTJ55w=", "Fi8n9YinaEsFnc/ofm9Q134LK3wqBNayv+peZnfAcSQ=", "C5IxlkRPZ7t7mjVJlH2g0dZcLYYwYoIBWee4oVdj++I=", "IATqt85kzloz0JO//bP1yMBiYpqC3xHBudAjchllOrc=", "Eie/h3dCt5rh8/lPSn2Z4u06ap5THyJPhl71BKW8rqA=", "IPd2+G2TwFxVn0J3XJFL7+6LanfOieE37p+vQUoJhdc=", "AXKqZcczpgNc2kvZMXM+ywXxYN6l+sGRyFt/lsA8dv8=", "CL5C8PuNC9CRiuDJoj1sNQmSoDZSoUQ+EGdu8Kq3dY8=", "H9C+bEmVIVHNJ4rlYx1nYPC3+qHaXPH4bojwQzKWKw0=", "+axQNC/RV6DPCsrHvOr0SYFAgX37Vz6BvGtFUSKrxw==", "DLPf3bqNcE9qvpyNTDHDa6eqvYszhm1cNJIKYaCXHKY=", "DncPMUfLDjIXAdduEJAXPTAXHWy0dhjpbwORz+iahXw=", "BzfYh+/m/o+UcpAUh8zl3WHmCyezo5h6UQfMDHR8c9M=", "GjheL9us7+P8UFwOiGbtNmV66T+WP02LmvQ1qYzJH6s=", "BHdlkB015bnIjEPdX0FBy6TevmvGdeSaCAabeHJSo8E=", "HaSk7eNvCOK28AAHYOAi5Mh7SCj13wZwN+B+0KPbcKo=", "CEfSxmV9L6AJtzbYPjPJhhsBkiEv6O3ZDdnf4W9S+GE=", "AwOe1akrK2rH4N2kdihSkszWSUQlCJNkQtTTzB1VI4M=", "d5Udzx0u2TvluRtyC1OH2zpAl+Vcx3gbacJ/Xu7+BA==", "C1hWIrH164/fyq0cPNf5RCVaRhjr/J+drPM56HTfYgo=", "Gip7vWLZe7Jl0SfUT+NLF9najudYE7XFG54W7o3XtAI=", "DcSOwtq9leBtKYf9GCSpWeCE1OYtGyxeUDsz2+azDQI=", "KQ3pWq5lhFvhJAakWF9xh9PWUov32vAKhNoB6N+2nh8=", "DAF+RqTzmhZpo1DuSV561oVisiLecRSmwQGt70eFMpM=", "LwtfsC0Yp4HnREA5IdguVMSRnRaG2CS/TmKy5MwIjPk=", "Dn5pmx3Zxg8AGNh06TZCEOuSBYPQ0tcVZ9OPQzO/pHQ=", "CUcsbtK2SUQzqTGfKwk/L9GSMFm2ACpuiW/uA+GVRrg=", "GWt2zv3Mf2pUxx1AEUoLuCaUyTbxVzrHrB6j/M4f6Tg=", "KopACT4ryWJ/45qoSreMHOEmXoy+KFaRNvi4Pb8eGg4=", "Idm59wlLNGKqphFIsnL7plVlFNyznPtHtUFKx3aUT4I=", "Ir4CMovGJgXKbYkFZblyboO52Pkl5wJBLt8pG3d98Cc=", "J7XX3e8BjhdWnTPYxOkAOuNjgrtXyvlrsiS3JM8jclQ=", "BU7BQcWUus5ciKQXZ+glF/jc2OAt1U+P3BxyI9NhSYI=", "F/dkVKfTsEncNMCQEnBlYDUd0S/wUhh7pSKMn9WrxkY=", "GJoIL1wQEX/7awZDKbMQJshSzUHgE1Lmx7nRJoYgBZg=", "DFl9rxwqj2AjIvJ5ahvKKqMQHLjJqHbuGVqb2pDaXVs=", "KsLhA3NX4piF1ziCiZZSxc2vhWCuNWu9997RHBOdxmM=", "BsqVDzivgHysO210yyk3rwoih1dreP3f1yAPBuZuXyI=", "BzYgm9+MGsZDuOzQlQ0rtNzYdFvnyM9kQy2iZPxMajM=", "HpbZ/Q8ttbzuFs54JAOjozrK1wsjcQZoatC72LvADR8=", "LX9WNeSxJ6qwZ5VJm7GmyXxUgG15gj/3hx5Rn0CBzBw=", "HY0YsY3Qe7if4MhKd0D67QmMaisM3l9Cb7jIt2Q7+Vw=", "KNUdRVGQS78E7Bab7YU0UzWAQu92oI6o0VX4Z3oFHM0=", "GJvjZfrOELmkGD1vIQSNbDbKnCiwcgxx1y7VKWVKpiQ=", "Ew/FRHf9lTN3/COrvXpBvmdkiSqHh8dZwUQP4BM8hS0=", "LJyR9IZhdxuu72d0V4p49pw1XI6QcVb98m2znSRGQT8=", "HewLr6PoGQYh5eCV73UeoDyDbbuARbKnP405fPuBUZI=", "Cl9SrW7EqKo3fY3SrjqvbuoMaMY6HQNPvaZxM8oLhcs=", "IKtzlL/as0TLtvISOACg4jUI4hJb/nlatKdnzstNkwY=", "EQ6jIrDCZHbGe/osG50XE/k7O5z4Mgzg3NS2Qoi9oHo=", "BU6r5hMWgfoB+8bb8+fVNZXQ+ICZhxghQriQrIr4nL4=", "Ik2BH73vjsCgBtN2oBnlfJO9WWIToHgjt9Srzh/Y5iE=", "DmkfykIxKKfUr8qlgrGpR5m6H10qXVO8K7pWu+yyJ6E=", "GJ4nnJLeC6tmcH5ubjEFJOYVzUxqrMZlNyo7jjctjOY=", "HZvLvRe5OxkT0vec3xKEREEjcgbwKUdG2T+OW9zrRyU=", "EXkYRjWpeA7hMS3MPRXH7wQrGK6UCWcOKMTH8PubYI4=", "DkhGYYKugzOvGJGmqhlzZ0HtBoDVfJMe3hP8B66C6Is=", "HJ1W9xwvIsRNOowXv1tARS4FRx8Lbf6f/kcl6yn3NGQ=", "IjRUb16FQej3KteUiRlQsysc2JHMZndcW2NZYWQunBU=", "FMCdFVxdQoGYwjS1U9ozjyJ8vBKw5C8rnOcVY+4UlcA="]] };
  var S = M.unstringifyBigInts(CI);
  var zI = 8;
  var gI = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];
  var dI = 16;
  var k = 31;
  var L = new i(B.fromString("21888242871839275222246405745257275088548364400416034343698204186575808495617"));
  var x = (G7) => L.mul(G7, L.square(L.square(G7)));
  var h = class h2 {
    static hash(I5) {
      if (!(I5.length > 0 && I5.length <= gI.length))
        throw new Error("Invalid inputs");
      let E4 = I5.length + 1, A5 = zI, o4 = gI[E4 - 2], D4 = S.C[E4 - 2], s3 = S.S[E4 - 2], t = S.M[E4 - 2], H4 = S.P[E4 - 2], J4 = [L.zero, ...I5.map((K4) => L.e(K4))];
      J4 = J4.map((K4, C5) => L.add(K4, D4[C5]));
      for (let K4 = 0; K4 < A5 / 2 - 1; K4++)
        J4 = J4.map((C5) => x(C5)), J4 = J4.map((C5, F4) => L.add(C5, D4[(K4 + 1) * E4 + F4])), J4 = J4.map((C5, F4) => J4.reduce((c3, g5, r) => L.add(c3, L.mul(t[r][F4], g5)), L.zero));
      J4 = J4.map((K4) => x(K4)), J4 = J4.map((K4, C5) => L.add(K4, D4[(A5 / 2 - 1 + 1) * E4 + C5])), J4 = J4.map((K4, C5) => J4.reduce((F4, c3, g5) => L.add(F4, L.mul(H4[g5][C5], c3)), L.zero));
      for (let K4 = 0; K4 < o4; K4++) {
        J4[0] = x(J4[0]), J4[0] = L.add(J4[0], D4[(A5 / 2 + 1) * E4 + K4]);
        let C5 = J4.reduce((F4, c3, g5) => L.add(F4, L.mul(s3[(E4 * 2 - 1) * K4 + g5], c3)), L.zero);
        for (let F4 = 1; F4 < E4; F4++)
          J4[F4] = L.add(J4[F4], L.mul(J4[0], s3[(E4 * 2 - 1) * K4 + E4 + F4 - 1]));
        J4[0] = C5;
      }
      for (let K4 = 0; K4 < A5 / 2 - 1; K4++)
        J4 = J4.map((C5) => x(C5)), J4 = J4.map((C5, F4) => L.add(C5, D4[(A5 / 2 + 1) * E4 + o4 + K4 * E4 + F4])), J4 = J4.map((C5, F4) => J4.reduce((c3, g5, r) => L.add(c3, L.mul(t[r][F4], g5)), L.zero));
      return J4 = J4.map((K4) => x(K4)), J4 = J4.map((K4, C5) => J4.reduce((F4, c3, g5) => L.add(F4, L.mul(t[g5][C5], c3)), L.zero)), L.normalize(J4[0]);
    }
    static hashBytes(I5) {
      return h2.hashBytesX(I5, dI);
    }
    static hashBytesX(I5, E4) {
      let A5 = new Array(E4).fill(BigInt(0)), o4 = false, D4, s3 = 0;
      for (let t = 0; t < parseInt(`${I5.length / k}`); t += 1)
        if (o4 = true, A5[s3] = M.beBuff2int(I5.slice(k * t, k * (t + 1))), s3 === E4 - 1) {
          D4 = h2.hash(A5), o4 = false, A5[0] = D4, A5.fill(BigInt(0), 1, k);
          for (let H4 = 1; H4 < E4; H4 += 1)
            A5[H4] = BigInt(0);
          s3 = 1;
        } else
          s3 += 1;
      if (I5.length % k != 0) {
        let t = new Uint8Array(k);
        I5.slice(parseInt(`${I5.length / k}`) * k).forEach((J4, K4) => {
          t[K4] = J4;
        }), A5[s3] = M.beBuff2int(t), o4 = true;
      }
      return o4 && (D4 = h2.hash(A5)), D4;
    }
    static spongeHashX(I5, E4) {
      if (E4 < 2 || E4 > 16)
        throw new Error("incorrect frame size");
      let A5 = new Array(E4).fill(BigInt(0)), o4 = false, D4, s3 = 0;
      for (let t = 0; t < I5.length; t++)
        o4 = true, A5[s3] = I5[t], s3 === E4 - 1 ? (D4 = this.hash(A5), o4 = false, A5 = new Array(E4).fill(BigInt(0)), A5[0] = D4, s3 = 1) : s3++;
      if (o4 && (D4 = this.hash(A5)), !D4)
        throw new Error("hash is undefined");
      return D4;
    }
  };
  h.F = L;
  var _ = h;
  var $ = _;
  var jI = Uint8Array.from([1]);
  var _I = Uint8Array.from([129]);
  function v(G7, I5, E4, A5) {
    let o4 = G7[I5 * 2] ^ G7[E4 * 2], D4 = G7[I5 * 2 + 1] ^ G7[E4 * 2 + 1];
    A5 >= 32 && (D4 = D4 ^ o4, o4 = D4 ^ o4, D4 = D4 ^ o4, A5 -= 32), A5 === 0 ? (G7[I5 * 2] = o4 >>> 0, G7[I5 * 2 + 1] = D4 >>> 0) : (G7[I5 * 2] = (o4 >>> A5 | D4 << 32 - A5) >>> 0, G7[I5 * 2 + 1] = (D4 >>> A5 | o4 << 32 - A5) >>> 0);
  }
  function Q(G7, I5, E4, A5, o4, D4, s3, t) {
    let H4 = Y.sigma, J4 = Y.u512, K4;
    K4 = G7[A5 * 2 + 1] + ((I5[H4[E4][t] * 2 + 1] ^ J4[H4[E4][t + 1] * 2 + 1]) >>> 0) + G7[o4 * 2 + 1], G7[A5 * 2] = G7[A5 * 2] + ((I5[H4[E4][t] * 2] ^ J4[H4[E4][t + 1] * 2]) >>> 0) + G7[o4 * 2] + ~~(K4 / 4294967296) >>> 0, G7[A5 * 2 + 1] = K4 >>> 0, v(G7, s3, A5, 32), K4 = G7[D4 * 2 + 1] + G7[s3 * 2 + 1], G7[D4 * 2] = G7[D4 * 2] + G7[s3 * 2] + ~~(K4 / 4294967296) >>> 0, G7[D4 * 2 + 1] = K4 >>> 0, v(G7, o4, D4, 25), K4 = G7[A5 * 2 + 1] + ((I5[H4[E4][t + 1] * 2 + 1] ^ J4[H4[E4][t] * 2 + 1]) >>> 0) + G7[o4 * 2 + 1], G7[A5 * 2] = G7[A5 * 2] + ((I5[H4[E4][t + 1] * 2] ^ J4[H4[E4][t] * 2]) >>> 0) + G7[o4 * 2] + ~~(K4 / 4294967296) >>> 0, G7[A5 * 2 + 1] = K4 >>> 0, v(G7, s3, A5, 16), K4 = G7[D4 * 2 + 1] + G7[s3 * 2 + 1], G7[D4 * 2] = G7[D4 * 2] + G7[s3 * 2] + ~~(K4 / 4294967296) >>> 0, G7[D4 * 2 + 1] = K4 >>> 0, v(G7, o4, D4, 11);
  }
  var e = class e2 {
    constructor() {
      this._h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this._s = [0, 0, 0, 0, 0, 0, 0, 0], this._block = new Uint8Array(128), this._blockOffset = 0, this._length = [0, 0, 0, 0], this._nullt = false, this._zo = jI, this._oo = _I;
    }
    _lengthCarry(I5) {
      for (let E4 = 0; E4 < I5.length && !(I5[E4] < 4294967296); ++E4)
        I5[E4] -= 4294967296, I5[E4 + 1] += 1;
    }
    _compress() {
      let I5 = e2.u512, E4 = new Array(32), A5 = new Array(32), o4, D4 = new DataView(this._block.buffer);
      for (o4 = 0; o4 < 32; ++o4)
        A5[o4] = D4.getUint32(o4 * 4);
      for (o4 = 0; o4 < 16; ++o4)
        E4[o4] = this._h[o4] >>> 0;
      for (o4 = 16; o4 < 24; ++o4)
        E4[o4] = (this._s[o4 - 16] ^ I5[o4 - 16]) >>> 0;
      for (o4 = 24; o4 < 32; ++o4)
        E4[o4] = I5[o4 - 16];
      for (this._nullt || (E4[24] = (E4[24] ^ this._length[1]) >>> 0, E4[25] = (E4[25] ^ this._length[0]) >>> 0, E4[26] = (E4[26] ^ this._length[1]) >>> 0, E4[27] = (E4[27] ^ this._length[0]) >>> 0, E4[28] = (E4[28] ^ this._length[3]) >>> 0, E4[29] = (E4[29] ^ this._length[2]) >>> 0, E4[30] = (E4[30] ^ this._length[3]) >>> 0, E4[31] = (E4[31] ^ this._length[2]) >>> 0), o4 = 0; o4 < 16; ++o4)
        Q(E4, A5, o4, 0, 4, 8, 12, 0), Q(E4, A5, o4, 1, 5, 9, 13, 2), Q(E4, A5, o4, 2, 6, 10, 14, 4), Q(E4, A5, o4, 3, 7, 11, 15, 6), Q(E4, A5, o4, 0, 5, 10, 15, 8), Q(E4, A5, o4, 1, 6, 11, 12, 10), Q(E4, A5, o4, 2, 7, 8, 13, 12), Q(E4, A5, o4, 3, 4, 9, 14, 14);
      for (o4 = 0; o4 < 16; ++o4)
        this._h[o4 % 8 * 2] = (this._h[o4 % 8 * 2] ^ E4[o4 * 2]) >>> 0, this._h[o4 % 8 * 2 + 1] = (this._h[o4 % 8 * 2 + 1] ^ E4[o4 * 2 + 1]) >>> 0;
      for (o4 = 0; o4 < 8; ++o4)
        this._h[o4 * 2] = (this._h[o4 * 2] ^ this._s[o4 % 4 * 2]) >>> 0, this._h[o4 * 2 + 1] = (this._h[o4 * 2 + 1] ^ this._s[o4 % 4 * 2 + 1]) >>> 0;
    }
    _padding() {
      let I5 = this._length.slice();
      I5[0] += this._blockOffset * 8, this._lengthCarry(I5);
      let E4 = new Uint8Array(16), A5 = new DataView(E4.buffer);
      for (let o4 = 0; o4 < 4; ++o4)
        A5.setUint32(o4 * 4, I5[3 - o4]);
      this._blockOffset === 111 ? (this._length[0] -= 8, this.update(this._oo)) : (this._blockOffset < 111 ? (this._blockOffset === 0 && (this._nullt = true), this._length[0] -= (111 - this._blockOffset) * 8, this.update(e2.padding.slice(0, 111 - this._blockOffset))) : (this._length[0] -= (128 - this._blockOffset) * 8, this.update(e2.padding.slice(0, 128 - this._blockOffset)), this._length[0] -= 111 * 8, this.update(e2.padding.slice(1, 1 + 111)), this._nullt = true), this.update(this._zo), this._length[0] -= 8), this._length[0] -= 128, this.update(new Uint8Array(A5.buffer));
    }
    digest() {
      this._padding();
      let I5 = new Uint8Array(64), E4 = new DataView(I5.buffer);
      for (let A5 = 0; A5 < 16; ++A5)
        E4.setUint32(A5 * 4, this._h[A5]);
      return new Uint8Array(E4.buffer);
    }
    update(I5) {
      let E4 = this._block, A5 = 0;
      for (; this._blockOffset + I5.length - A5 >= E4.length; ) {
        for (let o4 = this._blockOffset; o4 < E4.length; )
          E4[o4++] = I5[A5++];
        this._length[0] += E4.length * 8, this._lengthCarry(this._length), this._compress(), this._blockOffset = 0;
      }
      for (; A5 < I5.length; )
        E4[this._blockOffset++] = I5[A5++];
      return this;
    }
  };
  e.sigma = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3], [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4], [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8], [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13], [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9], [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11], [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10], [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5], [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3], [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4], [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8], [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13], [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]], e.u256 = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479], e.u512 = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731, 3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113], e.padding = Uint8Array.from([128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var Y = e;
  var II = class G {
    constructor() {
      this.babyJub = n;
    }
    static pruneBuffer(I5) {
      return I5[0] = I5[0] & 248, I5[31] = I5[31] & 127, I5[31] = I5[31] | 64, I5;
    }
    static prv2pub(I5) {
      let E4 = this.pruneBuffer(new Y().update(I5).digest()), A5 = B.fromRprLE(E4, 0, 32);
      return n.mulPointEscalar(n.Base8, B.shr(A5, 3n));
    }
    static signPoseidon(I5, E4) {
      let A5 = new Y().update(I5).digest(), o4 = G.pruneBuffer(A5.slice(0, 32)), D4 = M.leBuff2int(o4), s3 = n.mulPointEscalar(n.Base8, B.shr(D4, 3n)), t = M.leInt2Buff(E4, 32), H4 = new Uint8Array(64);
      H4.set(A5.slice(32, 64), 0), H4.set(t, 32);
      let J4 = new Y().update(H4).digest(), K4 = M.leBuff2int(J4), C5 = new i(n.subOrder);
      K4 = C5.e(K4);
      let F4 = n.mulPointEscalar(n.Base8, K4), c3 = $.hash([F4[0], F4[1], s3[0], s3[1], E4]), g5 = C5.add(K4, C5.mul(c3, D4));
      return { R8: F4, S: g5 };
    }
    static verifyPoseidon(I5, E4, A5) {
      if (typeof E4 != "object" || !Array.isArray(E4.R8) || E4.R8.length != 2 || !n.inCurve(E4.R8) || !Array.isArray(A5) || A5.length != 2 || !n.inCurve(A5) || E4.S >= n.subOrder)
        return false;
      let D4 = $.hash([E4.R8[0], E4.R8[1], A5[0], A5[1], I5]), s3 = n.mulPointEscalar(n.Base8, E4.S), t = n.mulPointEscalar(A5, B.mul(D4, 8n));
      return t = n.addPoint(E4.R8, t), !(!n.F.eq(s3[0], t[0]) || !n.F.eq(s3[1], t[1]));
    }
    static packSignature(I5) {
      let E4 = new Uint8Array(64), A5 = n.packPoint(I5.R8);
      return E4.set(A5, 0), B.toRprLE(E4, 32, I5.S, 32), E4;
    }
    static unpackSignature(I5) {
      return { R8: n.unpackPoint(I5.slice(0, 32)), S: B.fromRprLE(I5, 32, 32) };
    }
  };
  var a = II;
  var U = class U2 {
    static encodeLength(I5) {
      return I5 * 2;
    }
    static encode(I5) {
      let E4 = new Uint8Array(U2.encodeLength(I5.length)), A5 = 0;
      for (let o4 = 0; o4 < I5.length; o4++)
        E4[A5] = U2.HEX_TABLE[I5[o4] >> 4].charCodeAt(0), E4[A5 + 1] = U2.HEX_TABLE[I5[o4] & 15].charCodeAt(0), A5 += 2;
      return E4;
    }
    static decodeString(I5) {
      return U2.decode(I5);
    }
    static fromHexChar(I5) {
      if ("0".charCodeAt(0) <= I5 && I5 <= "9".charCodeAt(0))
        return I5 - "0".charCodeAt(0);
      if ("a".charCodeAt(0) <= I5 && I5 <= "f".charCodeAt(0))
        return I5 - "a".charCodeAt(0) + 10;
      if ("A".charCodeAt(0) <= I5 && I5 <= "F".charCodeAt(0))
        return I5 - "A".charCodeAt(0) + 10;
      throw new Error(`Invalid byte char ${I5}`);
    }
    static decode(I5) {
      let E4 = 0, A5 = 1, o4 = [];
      for (; A5 < I5.length; A5 += 2) {
        let D4 = U2.fromHexChar(I5[A5 - 1].charCodeAt(0)), s3 = U2.fromHexChar(I5[A5].charCodeAt(0));
        o4[E4] = D4 << 4 | s3, E4++;
      }
      if (I5.length % 2 == 1)
        throw new Error("Invalid hex string");
      return Uint8Array.from(o4);
    }
    static encodeString(I5) {
      return new TextDecoder().decode(U2.encode(I5));
    }
  };
  U.HEX_TABLE = "0123456789abcdef", U.textEncoder = new TextEncoder();
  var b = U;
  var EI = class G2 {
    constructor(I5, E4) {
      this.R8 = I5, this.S = E4;
    }
    static newFromCompressed(I5) {
      if (I5.length !== 64)
        throw new Error("buf must be 64 bytes");
      let E4 = a.unpackSignature(I5);
      if (E4.R8 == null)
        throw new Error("unpackSignature failed");
      return new G2(E4.R8, E4.S);
    }
    compress() {
      return a.packSignature(this);
    }
    toString() {
      return this.compress().toString();
    }
    hex() {
      return b.encodeString(this.compress());
    }
  };
  var AI = class G3 {
    constructor(I5) {
      this.p = I5;
    }
    static newFromCompressed(I5) {
      if (I5.length !== 32)
        throw new Error("buf must be 32 bytes");
      let E4 = n.unpackPoint(I5);
      if (E4 == null)
        throw new Error("unpackPoint failed");
      return new G3(E4);
    }
    static newFromHex(I5) {
      let E4 = b.decodeString(I5);
      return G3.newFromCompressed(E4);
    }
    compress() {
      return n.packPoint(this.p);
    }
    toString() {
      return this.compress().toString();
    }
    hex() {
      return b.encodeString(this.compress());
    }
    verifyPoseidon(I5, E4) {
      return a.verifyPoseidon(I5, E4, this.p);
    }
  };
  var FI = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var uE = (G7) => {
    let I5 = [], E4 = "", A5 = 0, o4 = 0, D4;
    for (let s3 = 0; s3 < G7.length; s3++)
      for (A5 = 0, o4 = G7[s3], E4 += o4 || E4.length ^ s3 ? "" : "1"; A5 in I5 || o4; )
        D4 = I5[A5], D4 = D4 ? D4 * 256 + o4 : o4, o4 = D4 / 58 | 0, I5[A5] = D4 % 58, A5++;
    for (; A5--; )
      E4 += FI[I5[A5]];
    return E4;
  };
  var yE = (G7) => {
    let I5 = [], E4 = [], A5 = 0, o4 = 0, D4 = 0;
    for (let s3 = 0; s3 < G7.length; s3++) {
      if (A5 = 0, o4 = FI.indexOf(G7[s3]), o4 < 0)
        throw new Error(`Can't convert base58 string ${G7} to bytes`);
      for (o4 || E4.length ^ s3 || E4.push(0); A5 in I5 || o4; )
        D4 = I5[A5], D4 = D4 ? D4 * 58 + o4 : o4, o4 = D4 >> 8, I5[A5] = D4 % 256, A5++;
    }
    for (; A5--; )
      E4.push(I5[A5]);
    return new Uint8Array(E4);
  };
  var $I = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
  function GI(G7, I5, E4, A5, o4) {
    let D4, s3, t, H4, J4, K4, C5, F4, c3, g5, r, u4, O3;
    for (; o4 >= 64; ) {
      for (D4 = I5[0], s3 = I5[1], t = I5[2], H4 = I5[3], J4 = I5[4], K4 = I5[5], C5 = I5[6], F4 = I5[7], g5 = 0; g5 < 16; g5++)
        r = A5 + g5 * 4, G7[g5] = (E4[r] & 255) << 24 | (E4[r + 1] & 255) << 16 | (E4[r + 2] & 255) << 8 | E4[r + 3] & 255;
      for (g5 = 16; g5 < 64; g5++)
        c3 = G7[g5 - 2], u4 = (c3 >>> 17 | c3 << 32 - 17) ^ (c3 >>> 19 | c3 << 32 - 19) ^ c3 >>> 10, c3 = G7[g5 - 15], O3 = (c3 >>> 7 | c3 << 32 - 7) ^ (c3 >>> 18 | c3 << 32 - 18) ^ c3 >>> 3, G7[g5] = (u4 + G7[g5 - 7] | 0) + (O3 + G7[g5 - 16] | 0);
      for (g5 = 0; g5 < 64; g5++)
        u4 = (((J4 >>> 6 | J4 << 32 - 6) ^ (J4 >>> 11 | J4 << 32 - 11) ^ (J4 >>> 25 | J4 << 32 - 25)) + (J4 & K4 ^ ~J4 & C5) | 0) + (F4 + ($I[g5] + G7[g5] | 0) | 0) | 0, O3 = ((D4 >>> 2 | D4 << 32 - 2) ^ (D4 >>> 13 | D4 << 32 - 13) ^ (D4 >>> 22 | D4 << 32 - 22)) + (D4 & s3 ^ D4 & t ^ s3 & t) | 0, F4 = C5, C5 = K4, K4 = J4, J4 = H4 + u4 | 0, H4 = t, t = s3, s3 = D4, D4 = u4 + O3 | 0;
      I5[0] += D4, I5[1] += s3, I5[2] += t, I5[3] += H4, I5[4] += J4, I5[5] += K4, I5[6] += C5, I5[7] += F4, A5 += 64, o4 -= 64;
    }
    return A5;
  }
  var oI = class {
    constructor() {
      this.digestLength = 32;
      this.blockSize = 64;
      this.state = new Int32Array(8);
      this.temp = new Int32Array(64);
      this.buffer = new Uint8Array(128);
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
      this.reset();
    }
    reset() {
      return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.bufferLength = 0, this.bytesHashed = 0, this.finished = false, this;
    }
    clean() {
      for (let I5 = 0; I5 < this.buffer.length; I5++)
        this.buffer[I5] = 0;
      for (let I5 = 0; I5 < this.temp.length; I5++)
        this.temp[I5] = 0;
      this.reset();
    }
    update(I5, E4 = I5.length) {
      if (this.finished)
        throw new Error("SHA256: can't update because hash was finished.");
      let A5 = 0;
      if (this.bytesHashed += E4, this.bufferLength > 0) {
        for (; this.bufferLength < 64 && E4 > 0; )
          this.buffer[this.bufferLength++] = I5[A5++], E4--;
        this.bufferLength === 64 && (GI(this.temp, this.state, this.buffer, 0, 64), this.bufferLength = 0);
      }
      for (E4 >= 64 && (A5 = GI(this.temp, this.state, I5, A5, E4), E4 %= 64); E4 > 0; )
        this.buffer[this.bufferLength++] = I5[A5++], E4--;
      return this;
    }
    finish(I5) {
      if (!this.finished) {
        let E4 = this.bytesHashed, A5 = this.bufferLength, o4 = E4 / 536870912 | 0, D4 = E4 << 3, s3 = E4 % 64 < 56 ? 64 : 128;
        this.buffer[A5] = 128;
        for (let t = A5 + 1; t < s3 - 8; t++)
          this.buffer[t] = 0;
        this.buffer[s3 - 8] = o4 >>> 24 & 255, this.buffer[s3 - 7] = o4 >>> 16 & 255, this.buffer[s3 - 6] = o4 >>> 8 & 255, this.buffer[s3 - 5] = o4 >>> 0 & 255, this.buffer[s3 - 4] = D4 >>> 24 & 255, this.buffer[s3 - 3] = D4 >>> 16 & 255, this.buffer[s3 - 2] = D4 >>> 8 & 255, this.buffer[s3 - 1] = D4 >>> 0 & 255, GI(this.temp, this.state, this.buffer, 0, s3), this.finished = true;
      }
      for (let E4 = 0; E4 < 8; E4++)
        I5[E4 * 4 + 0] = this.state[E4] >>> 24 & 255, I5[E4 * 4 + 1] = this.state[E4] >>> 16 & 255, I5[E4 * 4 + 2] = this.state[E4] >>> 8 & 255, I5[E4 * 4 + 3] = this.state[E4] >>> 0 & 255;
      return this;
    }
    digest() {
      let I5 = new Uint8Array(this.digestLength);
      return this.finish(I5), I5;
    }
    _saveState(I5) {
      for (let E4 = 0; E4 < this.state.length; E4++)
        I5[E4] = this.state[E4];
    }
    _restoreState(I5, E4) {
      for (let A5 = 0; A5 < this.state.length; A5++)
        this.state[A5] = I5[A5];
      this.bytesHashed = E4, this.finished = false, this.bufferLength = 0;
    }
  };
  function OE(G7) {
    let I5 = new oI().update(G7), E4 = I5.digest();
    return I5.clean(), E4;
  }

  // node_modules/@iden3/js-iden3-core/dist/browser/esm/index.js
  var s = Object.freeze({ ERRORS: { DATA_OVERFLOW: new Error("data does not fits SNARK size"), INCORRECT_ID_POSITION: new Error("incorrect ID position"), NO_ID: new Error("ID is not set"), INVALID_SUBJECT_POSITION: new Error("invalid subject position"), INCORRECT_MERKLIZED_POSITION: new Error("incorrect Merklize position"), NO_MERKLIZED_ROOT: new Error("Merklized root is not set"), NETWORK_NOT_SUPPORTED_FOR_DID: new Error("network in not supported for did"), UNSUPPORTED_BLOCKCHAIN_FOR_DID: new Error("not supported blockchain for did"), UNSUPPORTED_DID_METHOD: new Error("not supported DID method"), UNKNOWN_DID_METHOD: new Error("unknown DID method"), INCORRECT_DID: new Error("incorrect DID"), UNSUPPORTED_ID: new Error("unsupported Id") }, SCHEMA: { HASH_LENGTH: 16 }, ETH_ADDRESS_LENGTH: 20, BYTES_LENGTH: 32, ELEM_BYTES_LENGTH: 4, NONCE_BYTES_LENGTH: 8, Q: BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617"), ID: { TYPE_DEFAULT: Uint8Array.from([0, 0]), TYPE_READONLY: Uint8Array.from([0, 1]), ID_LENGTH: 31 }, DID: { DID_SCHEMA: "did" }, GENESIS_LENGTH: 27 });
  var o = { Ethereum: "eth", Polygon: "polygon", Privado: "privado", Linea: "linea", Unknown: "unknown", NoChain: "", ReadOnly: "readonly" };
  var a2 = { Main: "main", Mumbai: "mumbai", Amoy: "amoy", Goerli: "goerli", Sepolia: "sepolia", Zkevm: "zkevm", Cardona: "cardona", Test: "test", Unknown: "unknown", NoNetwork: "" };
  var h3 = { Iden3: "iden3", PolygonId: "polygonid", Other: "" };
  var l2 = { [`${o.Ethereum}:${a2.Main}`]: 1, [`${o.Ethereum}:${a2.Goerli}`]: 5, [`${o.Ethereum}:${a2.Sepolia}`]: 11155111, [`${o.Polygon}:${a2.Main}`]: 137, [`${o.Polygon}:${a2.Mumbai}`]: 80001, [`${o.Polygon}:${a2.Amoy}`]: 80002, [`${o.Polygon}:${a2.Zkevm}`]: 1101, [`${o.Polygon}:${a2.Cardona}`]: 2442, [`${o.Privado}:${a2.Main}`]: 21e3, [`${o.Privado}:${a2.Test}`]: 21001, [`${o.Linea}:${a2.Main}`]: 59144, [`${o.Linea}:${a2.Sepolia}`]: 59141 };
  var u = { [h3.Iden3]: 1, [h3.PolygonId]: 2, [h3.Other]: 255 };
  var c = { [`${o.ReadOnly}:${a2.NoNetwork}`]: 0, [`${o.Polygon}:${a2.Main}`]: 17, [`${o.Polygon}:${a2.Mumbai}`]: 18, [`${o.Polygon}:${a2.Amoy}`]: 19, [`${o.Polygon}:${a2.Zkevm}`]: 20, [`${o.Polygon}:${a2.Cardona}`]: 21, [`${o.Ethereum}:${a2.Main}`]: 33, [`${o.Ethereum}:${a2.Goerli}`]: 34, [`${o.Ethereum}:${a2.Sepolia}`]: 35, [`${o.Privado}:${a2.Main}`]: 161, [`${o.Privado}:${a2.Test}`]: 162, [`${o.Linea}:${a2.Main}`]: 73, [`${o.Linea}:${a2.Sepolia}`]: 72 };
  var d2 = { [h3.Iden3]: { ...c }, [h3.PolygonId]: { ...c }, [h3.Other]: { [`${o.Unknown}:${a2.Unknown}`]: 255 } };
  var I = new TextEncoder();
  function g(t) {
    const e7 = BigInt(256);
    let r = BigInt(0), n4 = BigInt(1);
    return t.forEach((t2) => {
      r += n4 * BigInt(t2), n4 *= e7;
    }), r;
  }
  function E(t) {
    return g(t.reverse());
  }
  function f2(t, e7 = 31) {
    const r = BigInt(256), n4 = new Uint8Array(e7);
    let i4 = 0;
    for (; t > BigInt(0); )
      n4[i4] = Number(t % r), t /= r, i4 += 1;
    return n4;
  }
  function y2(t, e7 = 31) {
    return f2(t, e7).reverse();
  }
  function w2(t) {
    const e7 = new ArrayBuffer(4);
    return new DataView(e7).setUint32(0, t, true), new Uint8Array(e7);
  }
  function m2(t) {
    const e7 = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
    return new DataView(e7).getUint32(0, true);
  }
  function _2(t) {
    const e7 = new ArrayBuffer(8);
    return new DataView(e7).setBigUint64(0, t, true), new Uint8Array(e7);
  }
  function S2(t) {
    const e7 = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
    return new DataView(e7).getBigUint64(0, true);
  }
  function b2(t) {
    return Math.floor(t.getTime() / 1e3);
  }
  function p2(t) {
    return new Date(1e3 * t);
  }
  function x2(t) {
    return t < s.Q;
  }
  function N2(t) {
    return t.every((t2) => x2(t2));
  }
  function D(e7, r, n4) {
    return $.hash([e7, r, n4]);
  }
  var O = class {
    static isNotValidIDChar(t) {
      return O.isNotAlpha(t) && O.isNotDigit(t) && "." !== t && "-" !== t;
    }
    static isNotValidParamChar(t) {
      return O.isNotAlpha(t) && O.isNotDigit(t) && "." !== t && "-" !== t && "_" !== t && ":" !== t;
    }
    static isNotValidQueryOrFragmentChar(t) {
      return O.isNotValidPathChar(t) && "/" !== t && "?" !== t;
    }
    static isNotValidPathChar(t) {
      return O.isNotUnreservedOrSubdelim(t) && ":" !== t && "@" !== t;
    }
    static isNotUnreservedOrSubdelim(t) {
      switch (t) {
        case "-":
        case ".":
        case "_":
        case "~":
        case "!":
        case "$":
        case "&":
        case "'":
        case "(":
        case ")":
        case "*":
        case "+":
        case ",":
        case ";":
        case "=":
          return false;
        default:
          return !(!O.isNotAlpha(t) || !O.isNotDigit(t));
      }
    }
    static isNotHexDigit(t) {
      return O.isNotDigit(t) && (t < "A" || t > "F") && (t < "a" || t > "f");
    }
    static isNotDigit(t) {
      return t < "0" || t > "9";
    }
    static isNotAlpha(t) {
      return O.isNotSmallLetter(t) && O.isNotBigLetter(t);
    }
    static isNotBigLetter(t) {
      return t < "A" || t > "Z";
    }
    static isNotSmallLetter(t) {
      return t < "a" || t > "z";
    }
  };
  var T2 = (t) => Uint8Array.from([...new Uint8Array(7), ...t]);
  var R2 = class {
    static intToBytes(t) {
      return R2.intToNBytes(t, s.BYTES_LENGTH);
    }
    static intToNBytes(t, e7) {
      return Uint8Array.from(f2(t, e7));
    }
    static checkChecksum(t) {
      const { typ: e7, genesis: r, checksum: n4 } = R2.decomposeBytes(t);
      if (!n4.length || JSON.stringify(Uint8Array.from([0, 0])) === JSON.stringify(n4))
        return false;
      const i4 = R2.calculateChecksum(e7, r);
      return JSON.stringify(i4) === JSON.stringify(n4);
    }
    static decomposeBytes(t) {
      const e7 = t.length - 2;
      return { typ: t.slice(0, 2), genesis: t.slice(2, e7), checksum: t.slice(-2) };
    }
    static calculateChecksum(t, e7) {
      const r = [...t, ...e7].reduce((t2, e8) => t2 + e8, 0), n4 = [r >> 8, 255 & r];
      return Uint8Array.from(n4.reverse());
    }
    static hashBytes(t) {
      const r = OE(I.encode(t));
      return new Uint8Array(r);
    }
    static hexToBytes(t) {
      return b.decodeString(t);
    }
    static bytesToHex(t) {
      const e7 = [];
      for (let r = 0; r < t.length; r++) {
        const n4 = t[r] < 0 ? t[r] + 256 : t[r];
        e7.push((n4 >>> 4).toString(16)), e7.push((15 & n4).toString(16));
      }
      return e7.join("");
    }
    static bytesToInt(t) {
      return g(t);
    }
  };
  var B2 = class {
    constructor(t) {
      if (this._bytes = new Uint8Array(s.BYTES_LENGTH), t && (this._bytes = t), this._bytes.length !== s.BYTES_LENGTH)
        throw new Error("Invalid bytes length");
    }
    get bytes() {
      return this._bytes;
    }
    set bytes(t) {
      this._bytes = t;
    }
    toBigInt() {
      return R2.bytesToInt(this._bytes);
    }
    setBigInt(t) {
      if (!x2(t))
        throw s.ERRORS.DATA_OVERFLOW;
      return this._bytes = R2.intToBytes(t), this;
    }
    slotFromHex(t) {
      const e7 = b.decodeString(t);
      if (e7.length !== s.BYTES_LENGTH)
        throw new Error("Invalid bytes length");
      return this._bytes.set(e7, 0), this;
    }
    hex() {
      return b.encodeString(this._bytes);
    }
    static elemBytesToInts(t) {
      const e7 = [];
      for (let r = 0; r < t.length; r++) {
        const n4 = t[r];
        e7.push(n4.toBigInt());
      }
      return e7;
    }
    static fromInt(t) {
      if (!x2(t))
        throw s.ERRORS.DATA_OVERFLOW;
      const e7 = R2.intToBytes(t);
      return new B2(e7);
    }
  };
  var k2 = class {
    constructor(t) {
      if (this._bytes = new Uint8Array(s.SCHEMA.HASH_LENGTH), t && (this._bytes = t), this.bytes.length !== s.SCHEMA.HASH_LENGTH)
        throw new Error(`Schema hash must be ${s.SCHEMA.HASH_LENGTH} bytes long`);
    }
    get bytes() {
      return this._bytes;
    }
    marshalTextBytes() {
      return b.encode(this.bytes);
    }
    marshalText() {
      return b.encodeString(this.bytes);
    }
    static newSchemaHashFromHex(t) {
      const e7 = b.decodeString(t);
      if (e7.length !== s.SCHEMA.HASH_LENGTH)
        throw new Error(`invalid schema hash length: ${e7.length}`);
      return new k2(e7);
    }
    static newSchemaHashFromInt(t) {
      const e7 = R2.intToNBytes(t, s.SCHEMA.HASH_LENGTH), r = s.SCHEMA.HASH_LENGTH - e7.length;
      return new k2(R2.intToBytes(t).slice(r, s.SCHEMA.HASH_LENGTH));
    }
    bigInt() {
      return R2.bytesToInt(this.bytes);
    }
  };
  k2.authSchemaHash = new k2(Uint8Array.from([204, 163, 55, 26, 108, 177, 183, 21, 0, 68, 7, 227, 37, 189, 153, 60]));
  var $2 = class {
    constructor(t, e7) {
      this._checksum = R2.calculateChecksum(t, e7), this._bytes = Uint8Array.from([...t, ...e7, ...this._checksum]);
    }
    static getFromBytes(t) {
      const { typ: e7, genesis: r } = R2.decomposeBytes(t);
      return new $2(e7, r);
    }
    checksum() {
      return this._checksum;
    }
    string() {
      return uE(this._bytes);
    }
    get bytes() {
      return this._bytes;
    }
    set bytes(t) {
      this._bytes = t;
    }
    type() {
      return this._bytes.slice(0, 2);
    }
    bigInt() {
      return g(this._bytes);
    }
    equal(t) {
      return JSON.stringify(this._bytes) === JSON.stringify(t.bytes);
    }
    marshal() {
      return new TextEncoder().encode(this.string());
    }
    static unMarshal(t) {
      return $2.fromString(new TextDecoder().decode(t));
    }
    static fromBytes(t) {
      const e7 = t ?? Uint8Array.from([]);
      if (e7.length !== s.ID.ID_LENGTH)
        throw new Error("fromBytes error: byte array incorrect length");
      if (e7.every((t2) => 0 === t2))
        throw new Error("fromBytes error: byte array empty");
      const r = $2.getFromBytes(e7);
      if (!R2.checkChecksum(e7))
        throw new Error("fromBytes error: checksum error");
      return r;
    }
    static fromString(t) {
      const e7 = yE(t);
      return $2.fromBytes(e7);
    }
    static fromBigInt(t) {
      const e7 = R2.intToNBytes(t, s.ID.ID_LENGTH);
      return $2.fromBytes(e7);
    }
    static profileId(e7, r) {
      const n4 = $.hash([e7.bigInt(), r]), { typ: i4 } = R2.decomposeBytes(e7.bytes), s3 = R2.intToNBytes(n4, 27);
      return new $2(i4, s3);
    }
    static idGenesisFromIdenState(t, e7) {
      const r = B2.fromInt(e7), n4 = r.bytes.slice(r.bytes.length - 27);
      return new $2(t, n4);
    }
    static ethAddressFromId(t) {
      if (!t.bytes.slice(2, 9).every((t2) => 0 === t2))
        throw new Error("can't get Ethereum address: high bytes of genesis are not zero");
      return t.bytes.slice(9).slice(0, s.ETH_ADDRESS_LENGTH);
    }
  };
  var H;
  var A;
  var U3;
  var v2;
  var V2;
  var L2;
  !function(t) {
    t.IndexA = "IndexA", t.IndexB = "IndexB", t.ValueA = "ValueA", t.ValueB = "ValueB";
  }(H || (H = {}));
  var M2 = class extends Error {
    constructor(t) {
      super(`Slot ${t} not in field (too large)`), Object.setPrototypeOf(this, M2.prototype);
    }
  };
  !function(t) {
    t[t.Self = 0] = "Self", t[t.Invalid = 1] = "Invalid", t[t.OtherIdenIndex = 2] = "OtherIdenIndex", t[t.OtherIdenValue = 3] = "OtherIdenValue";
  }(A || (A = {})), function(t) {
    t[t.None = 0] = "None", t[t.Index = 1] = "Index", t[t.Value = 2] = "Value";
  }(U3 || (U3 = {})), function(t) {
    t[t.None = 0] = "None", t[t.Index = 32] = "Index", t[t.Value = 64] = "Value", t[t.Invalid = 128] = "Invalid";
  }(v2 || (v2 = {})), function(t) {
    t[t.None = 0] = "None", t[t.Index = 1] = "Index", t[t.Value = 2] = "Value";
  }(V2 || (V2 = {})), function(t) {
    t[t.ByteIdx = 16] = "ByteIdx", t[t.ExpirationBitIdx = 3] = "ExpirationBitIdx", t[t.UpdatableBitIdx = 4] = "UpdatableBitIdx";
  }(L2 || (L2 = {}));
  var P2 = class {
    constructor() {
      this._index = [], this._value = [];
      for (let t = 0; t < s.ELEM_BYTES_LENGTH; t++)
        this._index[t] = new B2(), this._value[t] = new B2();
    }
    static newClaim(t, ...e7) {
      const r = new P2();
      r.setSchemaHash(t);
      for (let t2 = 0; t2 < e7.length; t2++) {
        (0, e7[t2])(r);
      }
      return r;
    }
    getSchemaHash() {
      return new k2(this._index[0].bytes.slice(0, s.SCHEMA.HASH_LENGTH));
    }
    get value() {
      return this._value;
    }
    set value(t) {
      this._value = t;
    }
    get index() {
      return this._index;
    }
    set index(t) {
      this._index = t;
    }
    setSchemaHash(t) {
      this._index[0] = new B2(Uint8Array.from([...t.bytes, ...new Array(s.SCHEMA.HASH_LENGTH).fill(0)]));
    }
    setSubject(t) {
      this._index[0].bytes[L2.ByteIdx] &= 248, this._index[0].bytes[L2.ByteIdx] |= t;
    }
    getSubject() {
      let t = this._index[0].bytes[L2.ByteIdx];
      return t &= 7, t;
    }
    setFlagExpiration(t) {
      t ? this._index[0].bytes[L2.ByteIdx] |= 1 << L2.ExpirationBitIdx : this._index[0].bytes[L2.ByteIdx] &= ~(1 << L2.ExpirationBitIdx);
    }
    getFlagExpiration() {
      const t = 1 << L2.ExpirationBitIdx;
      return (this._index[0].bytes[L2.ByteIdx] & t) > 0;
    }
    getIdPosition() {
      switch (this.getSubject()) {
        case A.Self:
          return U3.None;
        case A.OtherIdenIndex:
          return U3.Index;
        case A.OtherIdenValue:
          return U3.Value;
        default:
          throw s.ERRORS.INVALID_SUBJECT_POSITION;
      }
    }
    setValueDataInts(t, e7) {
      this._value[2] = this.setSlotInt(t, H.ValueA), this._value[3] = this.setSlotInt(e7, H.ValueB);
    }
    setValueDataBytes(t, e7) {
      this._value[2] = this.setSlotBytes(t, H.ValueA), this._value[3] = this.setSlotBytes(e7, H.ValueB);
    }
    setValueData(t, e7) {
      if (!N2([t.toBigInt(), e7.toBigInt()]))
        throw s.ERRORS.DATA_OVERFLOW;
      this._value[2] = t, this._value[3] = e7;
    }
    setIndexDataInts(t, e7) {
      this._index[2] = this.setSlotInt(t, H.IndexA), this._index[3] = this.setSlotInt(e7, H.IndexB);
    }
    setIndexDataBytes(t, e7) {
      this._index[2] = this.setSlotBytes(t, H.IndexA), this._index[3] = this.setSlotBytes(e7, H.IndexB);
    }
    setSlotBytes(t, e7) {
      const r = new B2(t);
      if (!x2(r.toBigInt()))
        throw new M2(e7);
      return r;
    }
    setFlagMerklized(t) {
      let e7;
      switch (t) {
        case V2.Index:
          e7 = v2.Index;
          break;
        case V2.Value:
          e7 = v2.Value;
          break;
        default:
          e7 = v2.None;
      }
      this.index[0].bytes[L2.ByteIdx] &= 31, this.index[0].bytes[L2.ByteIdx] |= e7;
    }
    getMerklized() {
      let t = this.index[0].bytes[L2.ByteIdx];
      return t &= 224, t;
    }
    getMerklizedPosition() {
      switch (this.getMerklized()) {
        case v2.None:
          return V2.None;
        case v2.Index:
          return V2.Index;
        case v2.Value:
          return V2.Value;
        default:
          throw s.ERRORS.INCORRECT_MERKLIZED_POSITION;
      }
    }
    setSlotInt(t, e7) {
      if (t || (t = BigInt(0)), !x2(t))
        throw new M2(e7);
      return new B2().setBigInt(t);
    }
    setIndexData(t, e7) {
      if (!N2([t.toBigInt(), e7.toBigInt()]))
        throw s.ERRORS.DATA_OVERFLOW;
      this._index[2] = t, this._index[3] = e7;
    }
    resetExpirationDate() {
      this.setFlagExpiration(false);
      const t = Array.from({ length: s.NONCE_BYTES_LENGTH }, () => 0), e7 = Array.from(this._value[0].bytes);
      e7.splice(s.NONCE_BYTES_LENGTH, s.NONCE_BYTES_LENGTH, ...t), this._value[0] = new B2(Uint8Array.from(e7));
    }
    getExpirationDate() {
      if (this.getFlagExpiration()) {
        const t = S2(this._value[0].bytes.slice(8, 16));
        return p2(Number(t));
      }
      return null;
    }
    setExpirationDate(t) {
      this.setFlagExpiration(true);
      const e7 = _2(BigInt(b2(t))), r = Array.from(this._value[0].bytes);
      r.splice(s.NONCE_BYTES_LENGTH, s.NONCE_BYTES_LENGTH, ...e7), this._value[0] = new B2(Uint8Array.from(r));
    }
    getRevocationNonce() {
      return S2(this._value[0].bytes.slice(0, 8));
    }
    setRevocationNonce(t) {
      const e7 = _2(t);
      if (e7.length > s.NONCE_BYTES_LENGTH)
        throw new Error("Nonce length is not valid");
      const r = Array.from(this._value[0].bytes);
      r.splice(0, s.NONCE_BYTES_LENGTH, ...e7), this._value[0] = new B2(Uint8Array.from(r));
    }
    getValueId() {
      return $2.fromBytes(this._value[1].bytes.slice(0, -1));
    }
    setValueId(t) {
      this.resetIndexId(), this.setSubject(A.OtherIdenValue);
      const e7 = Array.from(this._index[1].bytes);
      e7.splice(0, t.bytes.length, ...t.bytes), this._value[1] = new B2(Uint8Array.from(e7));
    }
    resetIndexId() {
      this._index[1] = new B2(new Uint8Array(s.BYTES_LENGTH).fill(0));
    }
    resetValueId() {
      this._value[1] = new B2(new Uint8Array(s.BYTES_LENGTH).fill(0));
    }
    getIndexId() {
      return $2.fromBytes(this._index[1].bytes.slice(0, -1));
    }
    setIndexId(t) {
      this.resetValueId(), this.setSubject(A.OtherIdenIndex);
      const e7 = Array.from(this._index[1].bytes);
      e7.splice(0, t.bytes.length, ...t.bytes), this._index[1] = new B2(Uint8Array.from(e7));
    }
    setVersion(t) {
      const e7 = w2(t);
      this._index[0].bytes[20] = e7[0], this._index[0].bytes[21] = e7[1], this._index[0].bytes[22] = e7[2], this._index[0].bytes[23] = e7[3];
    }
    getVersion() {
      return m2(this._index[0].bytes.slice(20, 24));
    }
    setFlagUpdatable(t) {
      t ? this._index[0].bytes[L2.ByteIdx] |= 1 << L2.UpdatableBitIdx : this._index[0].bytes[L2.ByteIdx] &= ~(1 << L2.UpdatableBitIdx);
    }
    hIndex() {
      return $.hash(B2.elemBytesToInts(this._index));
    }
    getFlagUpdatable() {
      const t = 1 << L2.UpdatableBitIdx;
      return (this._index[0].bytes[L2.ByteIdx] & t) > 0;
    }
    hValue() {
      return $.hash(B2.elemBytesToInts(this._value));
    }
    hiHv() {
      return { hi: this.hIndex(), hv: this.hValue() };
    }
    setIndexMerklizedRoot(t) {
      this.resetValueMerklizedRoot(), this.setFlagMerklized(V2.Index), this.index[2] = this.setSlotInt(t, H.IndexA);
    }
    resetIndexMerklizedRoot() {
      this._index[2] = new B2(new Uint8Array(s.BYTES_LENGTH).fill(0));
    }
    setValueMerklizedRoot(t) {
      this.resetIndexMerklizedRoot(), this.setFlagMerklized(V2.Value), this.value[2] = this.setSlotInt(t, H.ValueA);
    }
    resetValueMerklizedRoot() {
      this._value[2] = new B2(new Uint8Array(s.BYTES_LENGTH).fill(0));
    }
    getMerklizedRoot() {
      switch (this.getMerklized()) {
        case v2.Index:
          return this.index[2].toBigInt();
        case v2.Value:
          return this.value[2].toBigInt();
        default:
          throw s.ERRORS.NO_MERKLIZED_ROOT;
      }
    }
    resetId() {
      this.resetIndexId(), this.resetValueId(), this.setSubject(A.Self);
    }
    getId() {
      switch (this.getSubject()) {
        case A.OtherIdenIndex:
          return this.getIndexId();
        case A.OtherIdenValue:
          return this.getValueId();
        default:
          throw s.ERRORS.NO_ID;
      }
    }
    rawSlots() {
      return { index: this._index, value: this._value };
    }
    rawSlotsAsInts() {
      return [...B2.elemBytesToInts(this._index), ...B2.elemBytesToInts(this._value)];
    }
    clone() {
      return JSON.parse(JSON.stringify(this));
    }
    marshalJson() {
      return this.rawSlotsAsInts().map((t) => t.toString());
    }
    unMarshalJson(t) {
      const e7 = JSON.parse(t).map((t2) => BigInt(t2));
      if (e7.length !== this._index.length + this._value.length)
        throw new Error("invalid number of claim's slots");
      this._index = [], this._value = [];
      for (let t2 = 0, r = s.ELEM_BYTES_LENGTH; t2 < e7.length / 2; t2++, r++)
        this._index[t2] = new B2(), this._index[t2].setBigInt(e7[t2]), this._value[t2] = new B2(), this._value[t2].setBigInt(e7[r]);
      return this;
    }
    marshalBinary() {
      const t = (t2) => t2.reduce((t3, e7) => [...t3, ...e7.bytes], []);
      return Uint8Array.from(t(this._index).concat(t(this._value)));
    }
    hex() {
      const t = this.marshalBinary();
      return b.encodeString(t);
    }
    fromHex(t) {
      const e7 = b.decodeString(t);
      return this.unMarshalBinary(e7), this;
    }
    unMarshalBinary(t) {
      const e7 = 2 * s.ELEM_BYTES_LENGTH * s.BYTES_LENGTH;
      if (t.length !== e7)
        throw new Error("unexpected length of input data");
      this._index = [], this._value = [];
      for (let e8 = 0, r = s.ELEM_BYTES_LENGTH; e8 < s.ELEM_BYTES_LENGTH; e8++, r++)
        this._index[e8] = new B2(t.slice(e8 * s.BYTES_LENGTH, (e8 + 1) * s.BYTES_LENGTH)), this._value[e8] = new B2(t.slice(r * s.BYTES_LENGTH, (r + 1) * s.BYTES_LENGTH));
    }
  };
  var C = class {
    static withFlagUpdatable(t) {
      return (e7) => e7.setFlagUpdatable(t);
    }
    static withVersion(t) {
      return (e7) => e7.setVersion(t);
    }
    static withIndexId(t) {
      return (e7) => e7.setIndexId(t);
    }
    static withValueId(t) {
      return (e7) => e7.setValueId(t);
    }
    static withFlagMerklized(t) {
      return (e7) => e7.setFlagMerklized(t);
    }
    static withId(t, e7) {
      return (r) => {
        switch (e7) {
          case U3.Index:
            r.setIndexId(t);
            break;
          case U3.Value:
            r.setValueId(t);
            break;
          default:
            throw s.ERRORS.INCORRECT_ID_POSITION;
        }
      };
    }
    static withRevocationNonce(t) {
      return (e7) => e7.setRevocationNonce(t);
    }
    static withExpirationDate(t) {
      return (e7) => e7.setExpirationDate(t);
    }
    static withIndexData(t, e7) {
      return (r) => r.setIndexData(t, e7);
    }
    static withIndexDataBytes(t, e7) {
      return (r) => r.setIndexDataBytes(t, e7);
    }
    static withIndexDataInts(t, e7) {
      return (r) => r.setIndexDataInts(t, e7);
    }
    static withValueData(t, e7) {
      return (r) => r.setValueData(t, e7);
    }
    static withValueDataBytes(t, e7) {
      return (r) => r.setValueDataBytes(t, e7);
    }
    static withValueDataInts(t, e7) {
      return (r) => r.setValueDataInts(t, e7);
    }
    static withIndexMerklizedRoot(t) {
      return (e7) => {
        e7.setFlagMerklized(V2.Index), e7.index[2] = e7.setSlotInt(t, H.IndexA);
      };
    }
    static withValueMerklizedRoot(t) {
      return (e7) => {
        e7.setFlagMerklized(V2.Value), e7.value[2] = e7.setSlotInt(t, H.ValueA);
      };
    }
    static withMerklizedRoot(t, e7) {
      return (r) => {
        switch (e7) {
          case V2.Index:
            r.setFlagMerklized(V2.Index), r.index[2] = r.setSlotInt(t, H.IndexA);
            break;
          case V2.Value:
            r.setFlagMerklized(V2.Value), r.value[2] = r.setSlotInt(t, H.ValueA);
            break;
          default:
            throw s.ERRORS.INCORRECT_MERKLIZED_POSITION;
        }
      };
    }
  };
  var F = class {
    constructor(t, e7) {
      this.blockchain = t, this.networkId = e7;
    }
    toString() {
      return `${this.blockchain}:${this.networkId}`;
    }
    static fromString(t) {
      const [e7, r] = t.split(":");
      return new F(e7.replace("_", ""), r.replace("_", ""));
    }
  };
  function G4(t, e7, r) {
    const n4 = u[t];
    if (!n4)
      throw s.ERRORS.UNSUPPORTED_DID_METHOD;
    const i4 = d2[t];
    if (!i4)
      throw s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;
    const o4 = i4[new F(e7, r).toString()];
    if ("number" != typeof o4)
      throw new Error(`blockchain ${e7.toString() ?? "-"} and network ${r.toString() ?? "-"} is not defined in core lib`);
    return Uint8Array.from([n4, o4]);
  }
  function z2(t, e7) {
    const r = d2[t];
    if (!r)
      throw s.ERRORS.UNSUPPORTED_DID_METHOD;
    for (const [t2, n4] of Object.entries(r))
      if (n4 === e7)
        return F.fromString(t2).networkId;
    throw s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID;
  }
  function Y2(t, e7) {
    const r = d2[t];
    if (!r)
      throw new Error(`${s.ERRORS.NETWORK_NOT_SUPPORTED_FOR_DID}: did method ${t} is not defined in core lib`);
    for (const [t2, n4] of Object.entries(r))
      if (n4 === e7)
        return F.fromString(t2).blockchain;
    throw s.ERRORS.UNSUPPORTED_BLOCKCHAIN_FOR_DID;
  }
  function j2(t) {
    for (const [e7, r] of Object.entries(u))
      if (r === t)
        return e7;
    throw s.ERRORS.UNSUPPORTED_DID_METHOD;
  }
  var K = class {
    constructor(t, e7) {
      this.name = t, this.value = e7;
    }
    toString() {
      return this.name ? this.value ? `${this.name}=${this.value}` : this.name : "";
    }
  };
  var J = Object.freeze({ method: "", id: "", idStrings: [], params: [], path: "", pathSegments: [], query: "", fragment: "" });
  var W2 = class {
    constructor(t) {
      this.input = t, this.currentIndex = 0, this.out = { ...J };
    }
    checkLength() {
      if (this.input.length < 7)
        throw new Error("input length is less than 7");
      return this.parseScheme.bind(this);
    }
    parseScheme() {
      if ("did:" !== this.input.slice(0, 4))
        throw new Error("input does not begin with 'did:' prefix");
      return this.currentIndex = 3, this.parseMethod.bind(this);
    }
    parseMethod() {
      const t = this.input, e7 = t.length;
      let r = this.currentIndex + 1;
      const n4 = r;
      for (; ; ) {
        if (r === e7)
          throw new Error("input does not have a second `:` marking end of method name");
        const i4 = t[r];
        if (":" === i4) {
          if (r === n4)
            throw new Error(`method is empty, ${r}`);
          break;
        }
        if (O.isNotDigit(i4) && O.isNotSmallLetter(i4))
          throw new Error(`"character is not a-z OR 0-9, ${r}`);
        r += 1;
      }
      return this.currentIndex = r, this.out.method = t.slice(n4, r), this.parseId.bind(this);
    }
    parseId() {
      const t = this.input, e7 = t.length;
      let r = this.currentIndex + 1;
      const n4 = r;
      let i4 = null;
      for (; ; ) {
        if (r === e7) {
          i4 = null;
          break;
        }
        const n5 = t[r];
        if (":" === n5) {
          i4 = this.parseId;
          break;
        }
        if (";" === n5) {
          i4 = this.parseParamName;
          break;
        }
        if ("/" === n5) {
          i4 = this.parsePath;
          break;
        }
        if ("?" === n5) {
          i4 = this.parseQuery;
          break;
        }
        if ("#" === n5) {
          i4 = this.parseFragment;
          break;
        }
        if (O.isNotValidIDChar(n5))
          throw new Error(`byte is not ALPHA OR DIGIT OR '.' OR '-', ${r}`);
        r += 1;
      }
      if (r === n4)
        throw new Error(`idstring must be at least one char long, ${r}`);
      return this.currentIndex = r, this.out.idStrings = [...this.out.idStrings, t.slice(n4, r)], i4 ? i4.bind(this) : null;
    }
    parseParamName() {
      const t = this.input, e7 = this.currentIndex + 1, r = this.paramTransition(), n4 = this.currentIndex;
      if (n4 === e7)
        throw new Error(`Param name must be at least one char long, ${n4}`);
      return this.out.params = [...this.out.params, new K(t.slice(e7, n4), "")], r ? r.bind(this) : null;
    }
    parseParamValue() {
      const t = this.input, e7 = this.currentIndex + 1, r = this.paramTransition(), n4 = this.currentIndex;
      return this.out.params[this.out.params.length - 1].value = t.slice(e7, n4), r ? r.bind(this) : null;
    }
    paramTransition() {
      const t = this.input, e7 = t.length;
      let r, n4, i4, s3 = this.currentIndex + 1;
      for (; ; ) {
        if (s3 === e7) {
          n4 = null;
          break;
        }
        const o4 = t[s3];
        if (";" === o4) {
          n4 = this.parseParamName;
          break;
        }
        if ("=" === o4) {
          n4 = this.parseParamValue;
          break;
        }
        if ("/" === o4) {
          n4 = this.parsePath;
          break;
        }
        if ("?" === o4) {
          n4 = this.parseQuery;
          break;
        }
        if ("#" == o4) {
          n4 = this.parseFragment;
          break;
        }
        if ("%" == o4) {
          if (s3 + 2 >= e7 || O.isNotHexDigit(t[s3 + 1]) || O.isNotHexDigit(t[s3 + 2]))
            throw new Error(`% is not followed by 2 hex digits', ${s3}`);
          i4 = true, r = 3;
        } else
          i4 = false, r = 1;
        if (!i4 && O.isNotValidParamChar(o4))
          throw new Error(`character is not allowed in param - ${o4}',  ${s3}`);
        s3 += r;
      }
      return this.currentIndex = s3, n4 ? n4.bind(this) : null;
    }
    parsePath() {
      const t = this.input, e7 = t.length;
      let r = this.currentIndex + 1;
      const n4 = r;
      let i4, s3, o4;
      for (; ; ) {
        if (r === e7) {
          s3 = null;
          break;
        }
        const n5 = t[r];
        if ("/" === n5) {
          s3 = this.parsePath;
          break;
        }
        if ("?" === n5) {
          s3 = this.parseQuery;
          break;
        }
        if ("%" === n5) {
          if (r + 2 >= e7 || O.isNotHexDigit(t[r + 1]) || O.isNotHexDigit(t[r + 2]))
            throw new Error(`% is not followed by 2 hex digits, ${r}`);
          o4 = true, i4 = 3;
        } else
          o4 = false, i4 = 1;
        if (!o4 && O.isNotValidPathChar(n5))
          throw new Error(`character is not allowed in path, ${r}`);
        r += i4;
      }
      if (r == n4 && 0 === this.out.pathSegments.length)
        throw new Error(`first path segment must have at least one character, ${r}`);
      return this.currentIndex = r, this.out.pathSegments = [...this.out.pathSegments, t.slice(n4, r)], s3 ? s3.bind(this) : null;
    }
    parseQuery() {
      const t = this.input, e7 = t.length;
      let r = this.currentIndex + 1;
      const n4 = r;
      let i4, s3, o4 = null;
      for (; r !== e7; ) {
        const n5 = t[r];
        if ("#" === n5) {
          o4 = this.parseFragment;
          break;
        }
        if ("%" === n5) {
          if (r + 2 >= e7 || O.isNotHexDigit(t[r + 1]) || O.isNotHexDigit(t[r + 2]))
            throw new Error(`% is not followed by 2 hex digits, ${r}`);
          s3 = true, i4 = 3;
        } else
          s3 = false, i4 = 1;
        if (!s3 && O.isNotValidQueryOrFragmentChar(n5))
          throw new Error(`character is not allowed in query - ${n5}`);
        r += i4;
      }
      return this.currentIndex = r, this.out.query = t.slice(n4, r), o4 ? o4.bind(this) : null;
    }
    parseFragment() {
      const t = this.input, e7 = this.input.length;
      let r = this.currentIndex + 1;
      const n4 = r;
      let i4, s3;
      for (; r !== e7; ) {
        const n5 = t[r];
        if ("%" === n5) {
          if (r + 2 >= e7 || O.isNotHexDigit(t[r + 1]) || O.isNotHexDigit(t[r + 2]))
            throw new Error(`% is not followed by 2 hex digits, ${r}`);
          s3 = true, i4 = 3;
        } else
          s3 = false, i4 = 1;
        if (!s3 && O.isNotValidQueryOrFragmentChar(n5))
          throw new Error(`character is not allowed in fragment - ${n5}`);
        r += i4;
      }
      return this.currentIndex = r, this.out.fragment = t.slice(n4, r), null;
    }
  };
  var Q2 = class {
    constructor(t) {
      this.method = "", this.id = "", this.idStrings = [], this.params = [], this.path = "", this.pathSegments = [], this.query = "", this.fragment = "", t && Object.assign(this, t);
    }
    isUrl() {
      return this.params.length > 0 || !!this.path || this.pathSegments.length > 0 || !!this.query || !!this.fragment;
    }
    string() {
      const t = ["did:"];
      if (!this.method)
        return "";
      if (t.push(`${this.method}:`), this.id)
        t.push(this.id);
      else {
        if (!this.idStrings.length)
          return "";
        t.push(this.idStrings.join(":"));
      }
      if (this.params.length)
        for (const e7 of this.params) {
          const r = e7.toString();
          if (!r)
            return "";
          t.push(`;${r}`);
        }
      return this.path ? t.push(`/${this.path}`) : this.pathSegments.length && t.push(`/${this.pathSegments.join("/")}`), this.query && t.push(`?${this.query}`), this.fragment && t.push(`#${this.fragment}`), t.join("");
    }
    toJSON() {
      return this.string();
    }
    static parse(t) {
      const e7 = new W2(t);
      let r = e7.checkLength();
      for (; r; )
        r = r();
      return e7.out.id = e7.out.idStrings.join(":"), e7.out.path = e7.out.pathSegments.join("/"), new Q2(e7.out);
    }
    static decodePartsFromId(t) {
      const e7 = j2(t.bytes[0]);
      return { method: e7, blockchain: Y2(e7, t.bytes[1]), networkId: z2(e7, t.bytes[1]) };
    }
    static networkIdFromId(t) {
      return Q2.throwIfDIDUnsupported(t).networkId;
    }
    static methodFromId(t) {
      return Q2.throwIfDIDUnsupported(t).method;
    }
    static blockchainFromId(t) {
      return Q2.throwIfDIDUnsupported(t).blockchain;
    }
    static throwIfDIDUnsupported(t) {
      const { method: e7, blockchain: r, networkId: n4 } = Q2.decodePartsFromId(t);
      if (Q2.isUnsupported(e7, r, n4))
        throw new Error(`${s.ERRORS.UNKNOWN_DID_METHOD.message}: unsupported DID`);
      return { method: e7, blockchain: r, networkId: n4 };
    }
    static newFromIdenState(t, e7) {
      const r = $2.idGenesisFromIdenState(t, e7);
      return Q2.parseFromId(r);
    }
    static new(t, e7) {
      return Q2.parseFromId(new $2(t, e7));
    }
    static parseFromId(t) {
      if (!R2.checkChecksum(t.bytes))
        throw new Error(`${s.ERRORS.UNSUPPORTED_ID.message}: invalid checksum`);
      const { method: e7, blockchain: r, networkId: n4 } = Q2.throwIfDIDUnsupported(t), i4 = [s.DID.DID_SCHEMA, e7.toString(), r.toString()];
      n4 && i4.push(n4.toString()), i4.push(t.string());
      const o4 = i4.join(":");
      return Q2.parse(o4);
    }
    static idFromDID(t) {
      let e7;
      try {
        e7 = Q2.getIdFromDID(t);
      } catch (e8) {
        if (e8.message === s.ERRORS.UNKNOWN_DID_METHOD.message)
          return Q2.idFromUnsupportedDID(t);
        throw e8;
      }
      return e7;
    }
    static isUnsupported(t, e7, r) {
      return t == h3.Other && e7 == o.Unknown && r == a2.Unknown;
    }
    static idFromUnsupportedDID(t) {
      const r = OE(I.encode(t.string())), n4 = new Uint8Array(27), i4 = r.slice(r.length - s.GENESIS_LENGTH);
      for (let t2 = 0; t2 < n4.length; t2++)
        n4[t2] = i4[t2] ?? 0;
      const l6 = new F(o.Unknown, a2.Unknown), c3 = Uint8Array.from([u[h3.Other], d2[h3.Other][l6.toString()]]);
      return new $2(c3, n4);
    }
    static getIdFromDID(t) {
      const e7 = t.method;
      if (!u[e7] || e7 === h3.Other)
        throw s.ERRORS.UNKNOWN_DID_METHOD;
      if (t.idStrings.length > 3 || t.idStrings.length < 2)
        throw new Error(`${s.ERRORS.INCORRECT_DID}: unexpected number of ID strings`);
      const r = $2.fromString(t.idStrings[t.idStrings.length - 1]);
      if (!R2.checkChecksum(r.bytes))
        throw new Error(`${s.ERRORS.INCORRECT_DID}: incorrect ID checksum`);
      const { method: n4, blockchain: i4, networkId: o4 } = Q2.decodePartsFromId(r);
      if (n4.toString() !== e7.toString())
        throw new Error(`${s.ERRORS.INCORRECT_DID}: methods in Id and DID are different`);
      if (i4.toString() !== t.idStrings[0])
        throw new Error(`${s.ERRORS.INCORRECT_DID}: blockchains in ID and DID are different`);
      if (t.idStrings.length > 2 && o4.toString() != t.idStrings[1])
        throw new Error(`${s.ERRORS.INCORRECT_DID}: networkIDs in Id and DID are different`);
      return r;
    }
  };
  var Z2 = (t) => {
    o[t] = t;
  };
  var q2 = (t) => {
    a2[t] = t;
  };
  var X2 = (t, e7) => {
    const r = u[h3.Other];
    if (e7 >= r)
      throw new Error(`Can't register DID method byte: current '${e7.toString(2)}', maximum byte allowed: '${(r - 1).toString(2)}'`);
    if ("number" != typeof u[t] || u[t] !== e7) {
      if (Object.values(u).includes(e7))
        throw new Error(`can't register method '${t}' because DID method byte '${e7.toString(2)}' already registered for another method`);
      h3[t] = t, u[t] = e7;
    }
  };
  var tt = (t, e7, r) => {
    const n4 = `${t}:${e7}`;
    if ("number" != typeof l2[n4] || l2[n4] !== r) {
      if (Object.values(l2).includes(r))
        throw new Error(`can't register chainId ${r} for '${t}:${e7}' because it's already registered for another chain id`);
      l2[n4] = r;
    }
  };
  var et = (t, e7) => {
    e7 && (t += `:${e7}`);
    const r = l2[t];
    if (!r)
      throw new Error(`chainId not found for ${t}`);
    return r;
  };
  var rt = (t) => {
    const e7 = Q2.idFromDID(t), r = Q2.blockchainFromId(e7), n4 = Q2.networkIdFromId(e7), i4 = l2[`${r}:${n4}`];
    if ("number" != typeof i4)
      throw new Error(`chainId not found for ${r}:${n4}`);
    return i4;
  };
  var nt = ({ method: t, methodByte: e7, blockchain: r, network: n4, chainId: i4, networkFlag: s3 }) => {
    Z2(r), q2(n4), "number" == typeof e7 && X2(t, e7), d2[t] || (d2[t] = {}), "number" == typeof i4 && tt(r, n4, i4);
    const o4 = `${r}:${n4}`, a4 = d2[t][o4];
    if ("number" != typeof a4 || a4 !== s3) {
      if (Object.values(d2[t]).includes(s3))
        throw new Error(`DID network flag ${s3.toString(2)} is already registered for the another network id for '${t}' method`);
      d2[t][o4] = s3;
    }
  };

  // node_modules/@iden3/js-merkletree/dist/browser/esm/index.js
  var i2 = 32;
  var o2 = new Uint8Array(65);
  var h4 = "empty";
  var l3 = 32;
  var w3 = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
  var y3 = w3 - BigInt("1");
  function g2(t, e7, i4, s3) {
    if ("a" === i4 && !s3)
      throw new TypeError("Private accessor was defined without a getter");
    if ("function" == typeof e7 ? t !== e7 || !s3 : !e7.has(t))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return "m" === i4 ? s3 : "a" === i4 ? s3.call(t) : s3 ? s3.value : e7.get(t);
  }
  function v3(t, e7, i4, s3, n4) {
    if ("m" === s3)
      throw new TypeError("Private method is not writable");
    if ("a" === s3 && !n4)
      throw new TypeError("Private accessor was defined without a setter");
    if ("function" == typeof e7 ? t !== e7 || !n4 : !e7.has(t))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return "a" === s3 ? n4.call(t, i4) : n4 ? n4.value = i4 : e7.set(t, i4), i4;
  }
  var p3 = (t) => t < w3;
  var b3 = (t, e7) => t.every((t2, i4) => t2 === e7[i4]);
  var m3 = (t) => t.slice().reverse();
  var x3 = (t) => "0b" + t.reduce((t2, e7) => t2 + e7.toString(2).padStart(8, "0"), "");
  var I2 = (t, e7) => 0 != (t[parseInt((e7 / 8).toString())] & 1 << e7 % 8);
  var k3 = (t, e7) => 0 != (t[t.length - parseInt("" + e7 / 8) - 1] & 1 << e7 % 8);
  var A2 = (t, e7) => {
    t[t.length - parseInt("" + e7 / 8) - 1] |= 1 << e7 % 8;
  };
  var R3 = "0123456789abcdef";
  var S3 = (t) => {
    const e7 = new Array(2 * t.length);
    let i4 = 0;
    return t.forEach((t2) => {
      e7[i4] = R3[parseInt((t2 >> 4).toString(10))], e7[i4 + 1] = R3[parseInt((15 & t2).toString(10))], i4 += 2;
    }), e7.join("");
  };
  var B3 = (t) => new Uint8Array(2 * t.length).map((e7, i4) => t.charCodeAt(i4));
  var N3 = (t, e7) => {
    const i4 = new Array(t);
    for (let s3 = 0; s3 < t; s3 += 1)
      i4[s3] = I2(e7, s3);
    return i4;
  };
  var U4 = (t) => {
    const e7 = new ArrayBuffer(i2 * t.length), s3 = new Uint8Array(e7);
    return t.forEach((t2, e8) => {
      s3.set(t2.value, e8 * i2);
    }), s3;
  };
  var K2 = (t) => {
    const e7 = BigInt(256), s3 = new Uint8Array(i2);
    let n4 = 0;
    for (; t > BigInt(0); )
      s3[31 - n4] = Number(t % e7), t /= e7, n4 += 1;
    return s3;
  };
  var V3 = class {
    constructor(t) {
      if (t?.length) {
        if (t.length !== i2)
          throw new Error(`Expected 32 bytes, found ${t.length} bytes`);
        this.bytes = t;
      } else
        this.bytes = new Uint8Array(i2);
    }
    get value() {
      return this.bytes;
    }
    set value(t) {
      if (t.length !== i2)
        throw `Expected 32 bytes, found ${t.length} bytes`;
      this.bytes = m3(t);
    }
    string() {
      return this.bigInt().toString(10);
    }
    hex() {
      return S3(this.bytes);
    }
    equals(t) {
      return b3(this.value, t.value);
    }
    bigInt() {
      const t = m3(this.value);
      return BigInt(x3(t));
    }
    static fromString(t) {
      try {
        return V3.fromBigInt(BigInt(t));
      } catch (e7) {
        const i4 = JSON.parse(t), s3 = Uint8Array.from(Object.values(i4.bytes));
        return new V3(s3);
      }
    }
    static fromBigInt(t) {
      if (!p3(t))
        throw new Error("NewBigIntFromHashBytes: Value not inside the Finite Field");
      const e7 = K2(t);
      return new V3(m3(e7));
    }
    static fromHex(e7) {
      return e7 ? new V3(b.decodeString(e7)) : M3;
    }
    toJSON() {
      return this.string();
    }
  };
  var M3 = new V3();
  var _3 = (t) => {
    const i4 = $.hash(t);
    return V3.fromBigInt(i4);
  };
  var P3 = (t, i4) => {
    const s3 = $.hash([...i4, t]);
    return V3.fromBigInt(s3);
  };
  var J2 = (t, e7) => {
    for (let i4 = t.length; i4 < e7; i4 += 1)
      t.push(M3);
    return t;
  };
  var T3;
  var H2;
  var j3 = class {
    constructor(t) {
      T3.set(this, void 0), H2.set(this, void 0), this.prefix = t, v3(this, T3, {}, "f"), v3(this, H2, M3, "f");
    }
    async get(t) {
      const e7 = new Uint8Array([...this.prefix, ...t]);
      return g2(this, T3, "f")[e7.toString()] ? g2(this, T3, "f")[e7.toString()] : void 0;
    }
    async put(t, e7) {
      const i4 = new Uint8Array([...this.prefix, ...t]);
      g2(this, T3, "f")[i4.toString()] = e7;
    }
    async getRoot() {
      return g2(this, H2, "f");
    }
    async setRoot(t) {
      v3(this, H2, t, "f");
    }
  };
  T3 = /* @__PURE__ */ new WeakMap(), H2 = /* @__PURE__ */ new WeakMap();
  var z3 = async (t, e7) => P3(BigInt(1), [t.bigInt(), e7.bigInt()]);
  var C2 = (t, e7, i4) => {
    const s3 = new Uint8Array(65), n4 = K2(e7.bigInt()), r = K2(i4.bigInt());
    s3[0] = t;
    for (let t2 = 1; t2 < 33; t2 += 1)
      s3[t2] = n4[t2 - 1];
    for (let t2 = 33; t2 <= 65; t2 += 1)
      s3[t2] = r[t2 - 33];
    return s3;
  };
  var q3;
  var F2;
  var D2;
  var G5;
  var Q3 = class {
    constructor(t, e7) {
      q3.set(this, void 0), this.type = 1, this.entry = [t, e7], v3(this, q3, M3, "f");
    }
    async getKey() {
      return g2(this, q3, "f") === M3 ? await z3(this.entry[0], this.entry[1]) : g2(this, q3, "f");
    }
    get value() {
      return C2(this.type, this.entry[0], this.entry[1]);
    }
    get string() {
      return `Leaf I:${this.entry[0]} D:${this.entry[1]}`;
    }
  };
  q3 = /* @__PURE__ */ new WeakMap();
  var X3 = class {
    constructor(t, e7) {
      F2.set(this, void 0), this.type = 0, this.childL = t, this.childR = e7, v3(this, F2, M3, "f");
    }
    async getKey() {
      return g2(this, F2, "f") === M3 ? _3([this.childL.bigInt(), this.childR.bigInt()]) : g2(this, F2, "f");
    }
    get value() {
      return C2(this.type, this.childL, this.childR);
    }
    get string() {
      return `Middle L:${this.childL} R:${this.childR}`;
    }
  };
  F2 = /* @__PURE__ */ new WeakMap();
  var Y3 = class {
    constructor() {
      D2.set(this, void 0), this.type = 2, v3(this, D2, M3, "f");
    }
    async getKey() {
      return M3;
    }
    get value() {
      return o2;
    }
    get string() {
      return h4;
    }
  };
  D2 = /* @__PURE__ */ new WeakMap();
  var Z3 = class {
    constructor(t) {
      this._prefix = t, G5.set(this, void 0);
      const e7 = localStorage.getItem(S3(t));
      if (e7) {
        const t2 = JSON.parse(e7);
        v3(this, G5, new V3(Uint8Array.from(t2)), "f");
      } else
        v3(this, G5, M3, "f");
    }
    async get(t) {
      const e7 = new Uint8Array([...this._prefix, ...t]), i4 = S3(e7), s3 = localStorage.getItem(i4);
      if (null === s3)
        return;
      const n4 = JSON.parse(s3);
      switch (n4.type) {
        case 2:
          return new Y3();
        case 0:
          const t2 = new V3(Uint8Array.from(n4.childL)), e8 = new V3(Uint8Array.from(n4.childR));
          return new X3(t2, e8);
        case 1:
          const i5 = new V3(Uint8Array.from(n4.entry[0])), s4 = new V3(Uint8Array.from(n4.entry[1]));
          return new Q3(i5, s4);
      }
      throw `error: value found for key ${S3(e7)} is not of type Node`;
    }
    async put(t, e7) {
      const i4 = new Uint8Array([...this._prefix, ...t]), s3 = S3(i4), n4 = { type: e7.type };
      e7 instanceof X3 ? (n4.childL = Array.from(e7.childL.bytes), n4.childR = Array.from(e7.childR.bytes)) : e7 instanceof Q3 && (n4.entry = [Array.from(e7.entry[0].bytes), Array.from(e7.entry[1].bytes)]);
      const r = JSON.stringify(n4);
      localStorage.setItem(s3, r);
    }
    async getRoot() {
      return g2(this, G5, "f");
    }
    async setRoot(t) {
      v3(this, G5, t, "f"), localStorage.setItem(S3(this._prefix), JSON.stringify(Array.from(t.bytes)));
    }
  };
  function tt2(t) {
    return new Promise((e7, i4) => {
      t.oncomplete = t.onsuccess = () => e7(t.result), t.onabort = t.onerror = () => i4(t.error);
    });
  }
  function et2(t, e7) {
    const i4 = indexedDB.open(t);
    i4.onupgradeneeded = () => i4.result.createObjectStore(e7);
    const s3 = tt2(i4);
    return (t2, i5) => s3.then((s4) => i5(s4.transaction(e7, t2).objectStore(e7)));
  }
  var it;
  function st() {
    return it || (it = et2("keyval-store", "keyval")), it;
  }
  function nt2(t, e7 = st()) {
    return e7("readonly", (e8) => tt2(e8.get(t)));
  }
  function rt2(t, e7, i4 = st()) {
    return i4("readwrite", (i5) => (i5.put(e7, t), tt2(i5.transaction)));
  }
  var at;
  var ot;
  var ht;
  G5 = /* @__PURE__ */ new WeakMap();
  var lt = class {
    constructor(t, e7) {
      this._prefix = t, at.set(this, void 0), v3(this, at, M3, "f"), this._prefixHash = S3(t), this._store = et2(`${e7 ?? lt.storageName}-db`, lt.storageName);
    }
    async get(t) {
      const e7 = new Uint8Array([...this._prefix, ...t]), i4 = S3(e7), s3 = await nt2(i4, this._store);
      if (null != s3) {
        if (2 === s3.type)
          return new Y3();
        if (0 === s3.type) {
          const t2 = new V3(Uint8Array.from(s3.childL.bytes)), e8 = new V3(Uint8Array.from(s3.childR.bytes));
          return new X3(t2, e8);
        }
        if (1 === s3.type) {
          const t2 = new V3(Uint8Array.from(s3.entry[0].bytes)), e8 = new V3(Uint8Array.from(s3.entry[1].bytes));
          return new Q3(t2, e8);
        }
        throw new Error(`error: value found for key ${i4} is not of type Node`);
      }
    }
    async put(t, e7) {
      const i4 = new Uint8Array([...this._prefix, ...t]), s3 = S3(i4);
      await rt2(s3, e7, this._store);
    }
    async getRoot() {
      if (!g2(this, at, "f").equals(M3))
        return g2(this, at, "f");
      const t = await nt2(this._prefixHash, this._store);
      return v3(this, at, t ? new V3(t.bytes) : M3, "f"), g2(this, at, "f");
    }
    async setRoot(t) {
      await rt2(this._prefixHash, t, this._store), v3(this, at, t, "f");
    }
  };
  at = /* @__PURE__ */ new WeakMap(), lt.storageName = "merkle-tree";
  ot = /* @__PURE__ */ new WeakMap();
  ht = /* @__PURE__ */ new WeakMap();
  var dt;
  var wt;
  var yt;
  dt = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap();
  var vt = (t) => t.map((t2) => t2.bigInt());
  var pt = (t) => {
    const e7 = vt(t.data.value);
    let i4 = true;
    return e7.forEach((t2) => {
      p3(t2) || (i4 = false);
    }), i4;
  };
  var mt = "Key not found in the MerkleTree";
  var It = "reached maximum level of the merkle tree";
  var kt = "found an invalid node in the DB";
  var St = "the entry index already exists in the tree";
  var Lt = "Merkle Tree not writable";
  var Bt = "key not found";
  var Nt = class {
    constructor(t = M3, e7 = [], i4 = M3, s3 = M3, n4 = false, r = M3, a4 = M3, o4 = 0) {
      this.root = t, this.siblings = e7, this.oldKey = i4, this.oldValue = s3, this.isOld0 = n4, this.key = r, this.value = a4, this.fnc = o4;
    }
  };
  var Ut = class {
    constructor(t = M3, e7 = M3, i4 = [], s3 = M3, n4 = M3, r = M3, a4 = M3, o4 = false, h6 = 0) {
      this.oldRoot = t, this.newRoot = e7, this.siblings = i4, this.oldKey = s3, this.oldValue = n4, this.newKey = r, this.newValue = a4, this.isOld0 = o4, this.fnc = h6;
    }
  };
  var Et = "non-existence proof being checked against hIndex equal to nodeAux";
  var Kt = class {
    constructor(t) {
      this.existence = t?.existence ?? false, this.depth = 0, this.nodeAux = t?.nodeAux;
      const { siblings: e7, notEmpties: i4 } = this.reduceSiblings(t?.siblings);
      this.siblings = e7, this.notEmpties = i4;
    }
    bytes() {
      let t = 2 + this.notEmpties.length + l3 * this.siblings.length;
      void 0 !== this.nodeAux && (t += 64);
      const e7 = new ArrayBuffer(t), i4 = new Uint8Array(e7);
      this.existence || (i4[0] |= 1), i4[1] = this.depth, i4.set(this.notEmpties, 2);
      const s3 = U4(this.siblings);
      return i4.set(s3, this.notEmpties.length + 2), void 0 !== this.nodeAux && (i4[0] |= 2, i4.set(this.nodeAux.key.value, i4.length - 64), i4.set(this.nodeAux.value.value, i4.length - 32)), i4;
    }
    toJSON() {
      return { existence: this.existence, siblings: this.allSiblings().map((t) => t.toJSON()), node_aux: this.nodeAux ? { key: this.nodeAux.key.toJSON(), value: this.nodeAux.value.toJSON() } : void 0 };
    }
    reduceSiblings(t) {
      const e7 = [], i4 = new Uint8Array(30);
      if (!t)
        return { siblings: e7, notEmpties: i4 };
      for (let s3 = 0; s3 < t.length; s3++) {
        const n4 = t[s3];
        JSON.stringify(t[s3]) !== JSON.stringify(M3) && (A2(i4, s3), e7.push(n4), this.depth = s3 + 1);
      }
      return { notEmpties: i4, siblings: e7 };
    }
    static fromJSON(t) {
      let e7;
      const i4 = t.node_aux ?? t.nodeAux;
      i4 && (e7 = { key: V3.fromString(i4.key), value: V3.fromString(i4.value) });
      const s3 = t.existence ?? false, n4 = t.siblings.map((t2) => V3.fromString(t2));
      return new Kt({ existence: s3, nodeAux: e7, siblings: n4 });
    }
    allSiblings() {
      return Kt.buildAllSiblings(this.depth, this.notEmpties, this.siblings);
    }
    static buildAllSiblings(t, e7, i4) {
      let s3 = 0;
      const n4 = [];
      for (let r = 0; r < t; r += 1)
        k3(e7, r) ? (n4.push(i4[s3]), s3 += 1) : n4.push(M3);
      return n4;
    }
  };
  var Mt = async (t, e7, i4, s3) => {
    try {
      const n4 = await Wt(e7, i4, s3);
      return b3(t.value, n4.value);
    } catch (t2) {
      if (t2 === Et)
        return false;
      throw t2;
    }
  };
  var Wt = async (t, e7, i4) => {
    const s3 = V3.fromBigInt(e7), n4 = V3.fromBigInt(i4);
    let r;
    if (t.existence)
      r = await z3(s3, n4);
    else if (void 0 === t.nodeAux)
      r = M3;
    else {
      const e8 = t.nodeAux;
      if (b3(s3.value, e8.key.value))
        throw Et;
      r = await z3(e8.key, e8.value);
    }
    const a4 = t.allSiblings(), o4 = N3(a4.length, s3.value);
    for (let t2 = a4.length - 1; t2 >= 0; t2 -= 1)
      r = o4[t2] ? await new X3(a4[t2], r).getKey() : await new X3(r, a4[t2]).getKey();
    return r;
  };
  var $t;
  var Ot;
  var _t;
  var Pt;
  var Jt = class {
    constructor(t, e7, i4) {
      $t.set(this, void 0), Ot.set(this, void 0), _t.set(this, void 0), Pt.set(this, void 0), v3(this, $t, t, "f"), v3(this, _t, e7, "f"), v3(this, Pt, i4, "f");
    }
    async root() {
      return g2(this, Ot, "f") || v3(this, Ot, await g2(this, $t, "f").getRoot(), "f"), g2(this, Ot, "f");
    }
    get maxLevels() {
      return g2(this, Pt, "f");
    }
    async add(t, e7) {
      if (!g2(this, _t, "f"))
        throw Lt;
      v3(this, Ot, await this.root(), "f");
      const i4 = V3.fromBigInt(t), s3 = V3.fromBigInt(e7), n4 = new Q3(i4, s3), r = N3(this.maxLevels, i4.value), a4 = await this.addLeaf(n4, g2(this, Ot, "f"), 0, r);
      v3(this, Ot, a4, "f"), await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
    }
    async updateNode(t) {
      if (!g2(this, _t, "f"))
        throw Lt;
      if (2 === t.type)
        return await t.getKey();
      const e7 = await t.getKey();
      return await g2(this, $t, "f").put(e7.value, t), e7;
    }
    async addNode(t) {
      if (!g2(this, _t, "f"))
        throw Lt;
      if (2 === t.type)
        return await t.getKey();
      const e7 = await t.getKey();
      return await g2(this, $t, "f").put(e7.value, t), e7;
    }
    async addEntry(t) {
      if (!g2(this, _t, "f"))
        throw Lt;
      if (!pt(t))
        throw "elements not inside the finite field over r";
      v3(this, Ot, await g2(this, $t, "f").getRoot(), "f");
      const e7 = await t.hIndex(), i4 = await t.hValue(), s3 = new Q3(e7, i4), n4 = N3(this.maxLevels, e7.value), r = await this.addLeaf(s3, g2(this, Ot, "f"), 0, n4);
      v3(this, Ot, r, "f"), await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
    }
    async pushLeaf(t, e7, i4, s3, n4) {
      if (i4 > g2(this, Pt, "f") - 2)
        throw new Error(It);
      let r;
      if (s3[i4] === n4[i4]) {
        const a5 = await this.pushLeaf(t, e7, i4 + 1, s3, n4);
        return r = s3[i4] ? new X3(new V3(), a5) : new X3(a5, new V3()), await this.addNode(r);
      }
      const a4 = await e7.getKey(), o4 = await t.getKey();
      return r = s3[i4] ? new X3(a4, o4) : new X3(o4, a4), await this.addNode(t), await this.addNode(r);
    }
    async addLeaf(t, e7, i4, s3) {
      if (i4 > g2(this, Pt, "f") - 1)
        throw new Error(It);
      const n4 = await this.getNode(e7);
      if (void 0 === n4)
        throw Bt;
      switch (n4.type) {
        case 2:
          return this.addNode(t);
        case 1: {
          const e8 = n4.entry[0], r = t.entry[0];
          if (b3(e8.value, r.value))
            throw St;
          const a4 = N3(this.maxLevels, e8.value);
          return this.pushLeaf(t, n4, i4, s3, a4);
        }
        case 0: {
          let e8;
          if (s3[i4]) {
            const r = await this.addLeaf(t, n4.childR, i4 + 1, s3);
            e8 = new X3(n4.childL, r);
          } else {
            const r = await this.addLeaf(t, n4.childL, i4 + 1, s3);
            e8 = new X3(r, n4.childR);
          }
          return this.addNode(e8);
        }
        default:
          throw kt;
      }
    }
    async get(t) {
      const e7 = V3.fromBigInt(t), i4 = N3(this.maxLevels, e7.value);
      let s3 = await this.root();
      const n4 = [];
      for (let t2 = 0; t2 < this.maxLevels; t2++) {
        const e8 = await this.getNode(s3);
        if (void 0 === e8)
          throw mt;
        switch (e8.type) {
          case 2:
            return { key: BigInt("0"), value: BigInt("0"), siblings: n4 };
          case 1:
            return { key: e8.entry[0].bigInt(), value: e8.entry[1].bigInt(), siblings: n4 };
          case 0:
            i4[t2] ? (s3 = e8.childR, n4.push(e8.childL)) : (s3 = e8.childL, n4.push(e8.childR));
            break;
          default:
            throw kt;
        }
      }
      throw new Error(It);
    }
    async update(t, e7) {
      if (!g2(this, _t, "f"))
        throw Lt;
      if (!p3(t))
        throw "key not inside the finite field";
      if (!p3(e7))
        throw "key not inside the finite field";
      const i4 = V3.fromBigInt(t), s3 = V3.fromBigInt(e7), n4 = N3(this.maxLevels, i4.value), r = new Ut();
      r.fnc = 1, r.oldRoot = await this.root(), r.oldKey = i4, r.newKey = i4, r.newValue = s3;
      let a4 = await this.root();
      const o4 = [];
      for (let t2 = 0; t2 < this.maxLevels; t2 += 1) {
        const e8 = await this.getNode(a4);
        if (void 0 === e8)
          throw Bt;
        switch (e8.type) {
          case 2:
            throw mt;
          case 1:
            if (b3(i4.value, e8.entry[0].value)) {
              r.oldValue = e8.entry[1], r.siblings = J2([...o4], this.maxLevels);
              const t3 = new Q3(i4, s3);
              await this.updateNode(t3);
              const a5 = await this.recalculatePathUntilRoot(n4, t3, o4);
              return v3(this, Ot, a5, "f"), await g2(this, $t, "f").setRoot(a5), r.newRoot = a5, r;
            }
            break;
          case 0:
            n4[t2] ? (a4 = e8.childR, o4.push(e8.childL)) : (a4 = e8.childL, o4.push(e8.childR));
            break;
          default:
            throw kt;
        }
      }
      throw mt;
    }
    async getNode(t) {
      return b3(t.value, M3.value) ? new Y3() : await g2(this, $t, "f").get(t.value);
    }
    async recalculatePathUntilRoot(t, e7, i4) {
      for (let s3 = i4.length - 1; s3 >= 0; s3 -= 1) {
        const n4 = await e7.getKey();
        e7 = t[s3] ? new X3(i4[s3], n4) : new X3(n4, i4[s3]), await this.addNode(e7);
      }
      return await e7.getKey();
    }
    async delete(t) {
      if (!g2(this, _t, "f"))
        throw Lt;
      const e7 = V3.fromBigInt(t), i4 = N3(this.maxLevels, e7.value);
      let s3 = g2(this, Ot, "f");
      const n4 = [];
      for (let t2 = 0; t2 < g2(this, Pt, "f"); t2 += 1) {
        const r = await this.getNode(s3);
        if (void 0 === r)
          throw Bt;
        switch (r.type) {
          case 2:
            throw mt;
          case 1:
            if (b3(e7.bytes, r.entry[0].value))
              return void await this.rmAndUpload(i4, e7, n4);
            throw mt;
          case 0:
            i4[t2] ? (s3 = r.childR, n4.push(r.childL)) : (s3 = r.childL, n4.push(r.childR));
            break;
          default:
            throw kt;
        }
      }
      throw mt;
    }
    async rmAndUpload(t, e7, i4) {
      if (0 === i4.length)
        return v3(this, Ot, M3, "f"), void await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
      const s3 = i4[i4.length - 1];
      i4.length < 2 && (v3(this, Ot, i4[0], "f"), await g2(this, $t, "f").setRoot(g2(this, Ot, "f")));
      const n4 = await g2(this, $t, "f").get(s3.bytes);
      if (0 === n4?.type) {
        let e8;
        e8 = t[i4.length - 1] ? new X3(s3, M3) : new X3(M3, s3), await this.addNode(e8);
        const n5 = await this.recalculatePathUntilRoot(t, e8, i4.slice(0, i4.length - 1));
        return v3(this, Ot, n5, "f"), void await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
      }
      for (let e8 = i4.length - 2; e8 >= 0; e8 -= 1) {
        if (!b3(i4[e8].value, M3.value)) {
          let n5;
          n5 = t[e8] ? new X3(i4[e8], s3) : new X3(s3, i4[e8]), await this.addNode(n5);
          const r = await this.recalculatePathUntilRoot(t, n5, i4.slice(0, e8));
          v3(this, Ot, r, "f"), await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
          break;
        }
        if (0 === e8) {
          v3(this, Ot, s3, "f"), await g2(this, $t, "f").setRoot(g2(this, Ot, "f"));
          break;
        }
      }
    }
    async recWalk(t, e7) {
      const i4 = await this.getNode(t);
      if (void 0 === i4)
        throw Bt;
      switch (i4.type) {
        case 2:
        case 1:
          await e7(i4);
          break;
        case 0:
          await e7(i4), await this.recWalk(i4.childL, e7), await this.recWalk(i4.childR, e7);
          break;
        default:
          throw kt;
      }
    }
    async walk(t, e7) {
      b3(t.value, M3.value) && (t = await this.root()), await this.recWalk(t, e7);
    }
    async generateCircomVerifierProof(t, e7) {
      const i4 = await this.generateSCVerifierProof(t, e7);
      return i4.siblings = J2(i4.siblings, this.maxLevels), i4;
    }
    async generateSCVerifierProof(t, e7) {
      b3(e7.value, M3.value) && (e7 = await this.root());
      const { proof: i4, value: s3 } = await this.generateProof(t, e7), n4 = new Nt();
      return n4.root = e7, n4.siblings = i4.allSiblings(), void 0 !== i4.nodeAux ? (n4.oldKey = i4.nodeAux.key, n4.oldValue = i4.nodeAux.value) : (n4.oldKey = M3, n4.oldValue = M3), n4.key = V3.fromBigInt(t), n4.value = V3.fromBigInt(s3), i4.existence ? n4.fnc = 0 : n4.fnc = 1, n4;
    }
    async generateProof(t, e7) {
      let i4;
      const s3 = V3.fromBigInt(t), n4 = N3(this.maxLevels, s3.value);
      e7 || (e7 = await this.root());
      let r = e7, a4 = 0, o4 = false;
      const h6 = [];
      let l6;
      for (a4 = 0; a4 < this.maxLevels; a4 += 1) {
        const t2 = await this.getNode(r);
        if (void 0 === t2)
          throw Bt;
        switch (t2.type) {
          case 2:
            return { proof: new Kt({ existence: o4, nodeAux: l6, siblings: h6 }), value: BigInt("0") };
          case 1:
            return b3(s3.value, t2.entry[0].value) ? (o4 = true, { proof: new Kt({ existence: o4, nodeAux: l6, siblings: h6 }), value: t2.entry[1].bigInt() }) : (l6 = { key: t2.entry[0], value: t2.entry[1] }, { proof: new Kt({ existence: o4, nodeAux: l6, siblings: h6 }), value: t2.entry[1].bigInt() });
          case 0:
            n4[a4] ? (r = t2.childR, i4 = t2.childL) : (r = t2.childL, i4 = t2.childR);
            break;
          default:
            throw kt;
        }
        h6.push(i4);
      }
      throw mt;
    }
    async addAndGetCircomProof(t, e7) {
      const i4 = new Ut();
      i4.fnc = 2, i4.oldRoot = await this.root();
      let s3 = BigInt("0"), n4 = BigInt("0"), r = [];
      try {
        const e8 = await this.get(t);
        s3 = e8.key, n4 = e8.value, r = e8.siblings;
      } catch (t2) {
        if (t2 !== mt)
          throw t2;
      }
      if (void 0 === s3 || void 0 === n4)
        throw "key/value undefined";
      return i4.oldKey = V3.fromBigInt(s3), i4.oldValue = V3.fromBigInt(n4), b3(i4.oldKey.value, M3.value) && (i4.isOld0 = true), i4.siblings = J2(r, this.maxLevels), await this.add(t, e7), i4.newKey = V3.fromBigInt(t), i4.newValue = V3.fromBigInt(e7), i4.newRoot = await this.root(), i4;
    }
    async graphViz(t) {
      let e7 = 0;
      await this.walk(t, async (t2) => {
        const i4 = await t2.getKey();
        let s3, n4;
        switch (t2.type) {
          case 2:
            break;
          case 1:
            console.log(`"${i4.string()}" [style=filled]`);
            break;
          case 0:
            s3 = [t2.childL.string(), t2.childR.string()], n4 = "", s3.forEach((t3, i5) => {
              "0" === t3 && (s3[i5] = `empty${e7}`, n4 += `"${s3[i5]}" [style=dashed,label=0];
`, e7 += 1);
            }), console.log(`"${i4.string()}" -> {"${s3[1]}"}`), console.log(n4);
        }
      }), console.log("}\n");
    }
    async printGraphViz(t) {
      b3(t.value, M3.value) && (t = await this.root()), console.log(`--------
GraphViz of the MerkleTree with RootKey ${t.bigInt().toString(10)}
`), await this.graphViz(M3), console.log(`End of GraphViz of the MerkleTree with RootKey ${t.bigInt().toString(10)}
--------
`);
    }
  };
  $t = /* @__PURE__ */ new WeakMap(), Ot = /* @__PURE__ */ new WeakMap(), _t = /* @__PURE__ */ new WeakMap(), Pt = /* @__PURE__ */ new WeakMap();

  // node_modules/@iden3/js-jsonld-merklization/dist/browser/esm/index.js
  var i3 = Object.freeze({ ERRORS: { CONTEXT_NOT_DEFINED: new Error("error: context not defined on the object"), PARSED_CONTEXT_IS_NULL: new Error("error: parsed context is null"), TERM_IS_NOT_DEFINED: new Error("error: term is not defined"), NO_ID_ATTR: new Error("error: no @id attribute is defined"), CTX_TYP_IS_EMPTY: new Error("error: ctx type is empty"), FIELD_PATH_IS_EMPTY: new Error("error: filed path is empty"), UNEXPECTED_ARR_ELEMENT: new Error("error: unexpected array elements"), INVALID_REFERENCE_TYPE: new Error("error: invalid reference type"), MULTIPLE_PARENTS_FOUND: new Error("error: multiple parents found"), PARENT_NOT_FOUND: new Error("error: parent not found"), GRAPH_NOT_FOUND: new Error("error: graph not found"), QUAD_NOT_FOUND: new Error("error: quad not found"), MT_VALUE_INCORRECT_TYPE: new Error("error: incorrect type") }, DEFAULT_GRAPH_NODE_NAME: "@default", DEFAULT_GRAPH_TERM_TYPE: "DefaultGraph", QUADS_FORMAT: "application/n-quads", DIGITS_ONLY_REGEX: /^\d+$/, Q: BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617") });
  var o3 = class {
    constructor(t = $) {
      this._hasher = t;
    }
    async hash(e7) {
      return this._hasher.hash(e7);
    }
    async hashBytes(e7) {
      return this._hasher.hashBytes(e7);
    }
    prime() {
      return i3.Q;
    }
  };
  var a3 = new o3();
  var s2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
  function l4(e7) {
    return e7 && e7.__esModule && Object.prototype.hasOwnProperty.call(e7, "default") ? e7.default : e7;
  }
  function u2(e7) {
    if (e7.__esModule)
      return e7;
    var t = e7.default;
    if ("function" == typeof t) {
      var r = function e8() {
        return this instanceof e8 ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
      };
      r.prototype = t.prototype;
    } else
      r = {};
    return Object.defineProperty(r, "__esModule", { value: true }), Object.keys(e7).forEach(function(t2) {
      var n4 = Object.getOwnPropertyDescriptor(e7, t2);
      Object.defineProperty(r, t2, n4.get ? n4 : { enumerable: true, get: function() {
        return e7[t2];
      } });
    }), r;
  }
  var c2 = { exports: {} };
  c2.exports = function() {
    var e7 = Math.imul, t = Math.clz32;
    function r(e8) {
      return r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e9) {
        return typeof e9;
      } : function(e9) {
        return e9 && "function" == typeof Symbol && e9.constructor === Symbol && e9 !== Symbol.prototype ? "symbol" : typeof e9;
      }, r(e8);
    }
    function n4(e8, t2) {
      if (!(e8 instanceof t2))
        throw new TypeError("Cannot call a class as a function");
    }
    function i4(e8, t2) {
      for (var r2, n5 = 0; n5 < t2.length; n5++)
        (r2 = t2[n5]).enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e8, r2.key, r2);
    }
    function o4(e8, t2, r2) {
      return t2 && i4(e8.prototype, t2), r2 && i4(e8, r2), Object.defineProperty(e8, "prototype", { writable: false }), e8;
    }
    function a4(e8, t2) {
      if ("function" != typeof t2 && null !== t2)
        throw new TypeError("Super expression must either be null or a function");
      e8.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e8, writable: true, configurable: true } }), Object.defineProperty(e8, "prototype", { writable: false }), t2 && l6(e8, t2);
    }
    function s3(e8) {
      return s3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e9) {
        return e9.__proto__ || Object.getPrototypeOf(e9);
      }, s3(e8);
    }
    function l6(e8, t2) {
      return l6 = Object.setPrototypeOf || function(e9, t3) {
        return e9.__proto__ = t3, e9;
      }, l6(e8, t2);
    }
    function u4() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), true;
      } catch (e8) {
        return false;
      }
    }
    function c3() {
      return c3 = u4() ? Reflect.construct : function(e8, t2, r2) {
        var n5 = [null];
        n5.push.apply(n5, t2);
        var i5 = new (Function.bind.apply(e8, n5))();
        return r2 && l6(i5, r2.prototype), i5;
      }, c3.apply(null, arguments);
    }
    function d5(e8) {
      return -1 !== Function.toString.call(e8).indexOf("[native code]");
    }
    function h6(e8) {
      var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return h6 = function(e9) {
        function r2() {
          return c3(e9, arguments, s3(this).constructor);
        }
        if (null === e9 || !d5(e9))
          return e9;
        if ("function" != typeof e9)
          throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== t2) {
          if (t2.has(e9))
            return t2.get(e9);
          t2.set(e9, r2);
        }
        return r2.prototype = Object.create(e9.prototype, { constructor: { value: r2, enumerable: false, writable: true, configurable: true } }), l6(r2, e9);
      }, h6(e8);
    }
    function f5(e8) {
      if (void 0 === e8)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e8;
    }
    function p6(e8, t2) {
      if (t2 && ("object" == typeof t2 || "function" == typeof t2))
        return t2;
      if (void 0 !== t2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return f5(e8);
    }
    function m5(e8) {
      var t2 = u4();
      return function() {
        var r2, n5 = s3(e8);
        if (t2) {
          var i5 = s3(this).constructor;
          r2 = Reflect.construct(n5, arguments, i5);
        } else
          r2 = n5.apply(this, arguments);
        return p6(this, r2);
      };
    }
    function y5(e8, t2) {
      return g5(e8) || v6(e8, t2) || w5(e8, t2) || _5();
    }
    function g5(e8) {
      if (Array.isArray(e8))
        return e8;
    }
    function v6(e8, t2) {
      var r2 = null == e8 ? null : "undefined" != typeof Symbol && e8[Symbol.iterator] || e8["@@iterator"];
      if (null != r2) {
        var n5, i5, o5 = [], a5 = true, s4 = false;
        try {
          for (r2 = r2.call(e8); !(a5 = (n5 = r2.next()).done) && (o5.push(n5.value), !t2 || o5.length !== t2); a5 = true)
            ;
        } catch (e9) {
          s4 = true, i5 = e9;
        } finally {
          try {
            a5 || null == r2.return || r2.return();
          } finally {
            if (s4)
              throw i5;
          }
        }
        return o5;
      }
    }
    function w5(e8, t2) {
      if (e8) {
        if ("string" == typeof e8)
          return b7(e8, t2);
        var r2 = Object.prototype.toString.call(e8).slice(8, -1);
        return "Object" === r2 && e8.constructor && (r2 = e8.constructor.name), "Map" === r2 || "Set" === r2 ? Array.from(e8) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? b7(e8, t2) : void 0;
      }
    }
    function b7(e8, t2) {
      (null == t2 || t2 > e8.length) && (t2 = e8.length);
      for (var r2 = 0, n5 = Array(t2); r2 < t2; r2++)
        n5[r2] = e8[r2];
      return n5;
    }
    function _5() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function E4(e8, t2) {
      var r2 = "undefined" != typeof Symbol && e8[Symbol.iterator] || e8["@@iterator"];
      if (!r2) {
        if (Array.isArray(e8) || (r2 = w5(e8)) || t2 && e8 && "number" == typeof e8.length) {
          r2 && (e8 = r2);
          var n5 = 0, i5 = function() {
          };
          return { s: i5, n: function() {
            return n5 >= e8.length ? { done: true } : { done: false, value: e8[n5++] };
          }, e: function(e9) {
            throw e9;
          }, f: i5 };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o5, a5 = true, s4 = false;
      return { s: function() {
        r2 = r2.call(e8);
      }, n: function() {
        var e9 = r2.next();
        return a5 = e9.done, e9;
      }, e: function(e9) {
        s4 = true, o5 = e9;
      }, f: function() {
        try {
          a5 || null == r2.return || r2.return();
        } finally {
          if (s4)
            throw o5;
        }
      } };
    }
    var T6 = function(e8) {
      var t2 = Math.abs, i5 = Math.max, s4 = Math.floor;
      function l7(e9, t3) {
        var r2;
        if (n4(this, l7), (r2 = u5.call(this, e9)).sign = t3, Object.setPrototypeOf(f5(r2), l7.prototype), e9 > l7.__kMaxLength)
          throw new RangeError("Maximum BigInt size exceeded");
        return r2;
      }
      a4(l7, e8);
      var u5 = m5(l7);
      return o4(l7, [{ key: "toDebugString", value: function() {
        var e9, t3 = ["BigInt["], r2 = E4(this);
        try {
          for (r2.s(); !(e9 = r2.n()).done; ) {
            var n5 = e9.value;
            t3.push((n5 ? (n5 >>> 0).toString(16) : n5) + ", ");
          }
        } catch (e10) {
          r2.e(e10);
        } finally {
          r2.f();
        }
        return t3.push("]"), t3.join("");
      } }, { key: "toString", value: function() {
        var e9 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
        if (2 > e9 || 36 < e9)
          throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (e9 & e9 - 1) ? l7.__toStringBasePowerOfTwo(this, e9) : l7.__toStringGeneric(this, e9, false);
      } }, { key: "valueOf", value: function() {
        throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
      } }, { key: "__copy", value: function() {
        for (var e9 = new l7(this.length, this.sign), t3 = 0; t3 < this.length; t3++)
          e9[t3] = this[t3];
        return e9;
      } }, { key: "__trim", value: function() {
        for (var e9 = this.length, t3 = this[e9 - 1]; 0 === t3; )
          t3 = this[--e9 - 1], this.pop();
        return 0 === e9 && (this.sign = false), this;
      } }, { key: "__initializeDigits", value: function() {
        for (var e9 = 0; e9 < this.length; e9++)
          this[e9] = 0;
      } }, { key: "__clzmsd", value: function() {
        return l7.__clz30(this.__digit(this.length - 1));
      } }, { key: "__inplaceMultiplyAdd", value: function(e9, t3, r2) {
        r2 > this.length && (r2 = this.length);
        for (var n5 = 32767 & e9, i6 = e9 >>> 15, o5 = 0, a5 = t3, s5 = 0; s5 < r2; s5++) {
          var u6 = this.__digit(s5), c4 = 32767 & u6, d6 = u6 >>> 15, h7 = l7.__imul(c4, n5), f6 = l7.__imul(c4, i6), p7 = l7.__imul(d6, n5), m6 = a5 + h7 + o5;
          o5 = m6 >>> 30, m6 &= 1073741823, o5 += (m6 += ((32767 & f6) << 15) + ((32767 & p7) << 15)) >>> 30, a5 = l7.__imul(d6, i6) + (f6 >>> 15) + (p7 >>> 15), this.__setDigit(s5, 1073741823 & m6);
        }
        if (0 !== o5 || 0 !== a5)
          throw new Error("implementation bug");
      } }, { key: "__inplaceAdd", value: function(e9, t3, r2) {
        for (var n5, i6 = 0, o5 = 0; o5 < r2; o5++)
          i6 = (n5 = this.__halfDigit(t3 + o5) + e9.__halfDigit(o5) + i6) >>> 15, this.__setHalfDigit(t3 + o5, 32767 & n5);
        return i6;
      } }, { key: "__inplaceSub", value: function(e9, t3, r2) {
        var n5 = 0;
        if (1 & t3) {
          t3 >>= 1;
          for (var i6 = this.__digit(t3), o5 = 32767 & i6, a5 = 0; a5 < r2 - 1 >>> 1; a5++) {
            var s5 = e9.__digit(a5), l8 = (i6 >>> 15) - (32767 & s5) - n5;
            n5 = 1 & l8 >>> 15, this.__setDigit(t3 + a5, (32767 & l8) << 15 | 32767 & o5), n5 = 1 & (o5 = (32767 & (i6 = this.__digit(t3 + a5 + 1))) - (s5 >>> 15) - n5) >>> 15;
          }
          var u6 = e9.__digit(a5), c4 = (i6 >>> 15) - (32767 & u6) - n5;
          if (n5 = 1 & c4 >>> 15, this.__setDigit(t3 + a5, (32767 & c4) << 15 | 32767 & o5), t3 + a5 + 1 >= this.length)
            throw new RangeError("out of bounds");
          0 == (1 & r2) && (n5 = 1 & (o5 = (32767 & (i6 = this.__digit(t3 + a5 + 1))) - (u6 >>> 15) - n5) >>> 15, this.__setDigit(t3 + e9.length, 1073709056 & i6 | 32767 & o5));
        } else {
          t3 >>= 1;
          for (var d6 = 0; d6 < e9.length - 1; d6++) {
            var h7 = this.__digit(t3 + d6), f6 = e9.__digit(d6), p7 = (32767 & h7) - (32767 & f6) - n5, m6 = (h7 >>> 15) - (f6 >>> 15) - (n5 = 1 & p7 >>> 15);
            n5 = 1 & m6 >>> 15, this.__setDigit(t3 + d6, (32767 & m6) << 15 | 32767 & p7);
          }
          var y6 = this.__digit(t3 + d6), g6 = e9.__digit(d6), v7 = (32767 & y6) - (32767 & g6) - n5;
          n5 = 1 & v7 >>> 15;
          var w6 = 0;
          0 == (1 & r2) && (n5 = 1 & (w6 = (y6 >>> 15) - (g6 >>> 15) - n5) >>> 15), this.__setDigit(t3 + d6, (32767 & w6) << 15 | 32767 & v7);
        }
        return n5;
      } }, { key: "__inplaceRightShift", value: function(e9) {
        if (0 !== e9) {
          for (var t3, r2 = this.__digit(0) >>> e9, n5 = this.length - 1, i6 = 0; i6 < n5; i6++)
            t3 = this.__digit(i6 + 1), this.__setDigit(i6, 1073741823 & t3 << 30 - e9 | r2), r2 = t3 >>> e9;
          this.__setDigit(n5, r2);
        }
      } }, { key: "__digit", value: function(e9) {
        return this[e9];
      } }, { key: "__unsignedDigit", value: function(e9) {
        return this[e9] >>> 0;
      } }, { key: "__setDigit", value: function(e9, t3) {
        this[e9] = 0 | t3;
      } }, { key: "__setDigitGrow", value: function(e9, t3) {
        this[e9] = 0 | t3;
      } }, { key: "__halfDigitLength", value: function() {
        var e9 = this.length;
        return 32767 >= this.__unsignedDigit(e9 - 1) ? 2 * e9 - 1 : 2 * e9;
      } }, { key: "__halfDigit", value: function(e9) {
        return 32767 & this[e9 >>> 1] >>> 15 * (1 & e9);
      } }, { key: "__setHalfDigit", value: function(e9, t3) {
        var r2 = e9 >>> 1, n5 = this.__digit(r2), i6 = 1 & e9 ? 32767 & n5 | t3 << 15 : 1073709056 & n5 | 32767 & t3;
        this.__setDigit(r2, i6);
      } }], [{ key: "BigInt", value: function(e9) {
        var t3 = Number.isFinite;
        if ("number" == typeof e9) {
          if (0 === e9)
            return l7.__zero();
          if (l7.__isOneDigitInt(e9))
            return 0 > e9 ? l7.__oneDigit(-e9, true) : l7.__oneDigit(e9, false);
          if (!t3(e9) || s4(e9) !== e9)
            throw new RangeError("The number " + e9 + " cannot be converted to BigInt because it is not an integer");
          return l7.__fromDouble(e9);
        }
        if ("string" == typeof e9) {
          var n5 = l7.__fromString(e9);
          if (null === n5)
            throw new SyntaxError("Cannot convert " + e9 + " to a BigInt");
          return n5;
        }
        if ("boolean" == typeof e9)
          return true === e9 ? l7.__oneDigit(1, false) : l7.__zero();
        if ("object" === r(e9)) {
          if (e9.constructor === l7)
            return e9;
          var i6 = l7.__toPrimitive(e9);
          return l7.BigInt(i6);
        }
        throw new TypeError("Cannot convert " + e9 + " to a BigInt");
      } }, { key: "toNumber", value: function(e9) {
        var t3 = e9.length;
        if (0 === t3)
          return 0;
        if (1 === t3) {
          var r2 = e9.__unsignedDigit(0);
          return e9.sign ? -r2 : r2;
        }
        var n5 = e9.__digit(t3 - 1), i6 = l7.__clz30(n5), o5 = 30 * t3 - i6;
        if (1024 < o5)
          return e9.sign ? -1 / 0 : 1 / 0;
        var a5 = o5 - 1, s5 = n5, u6 = t3 - 1, c4 = i6 + 3, d6 = 32 === c4 ? 0 : s5 << c4;
        d6 >>>= 12;
        var h7 = c4 - 12, f6 = 12 <= c4 ? 0 : s5 << 20 + c4, p7 = 20 + c4;
        for (0 < h7 && 0 < u6 && (u6--, d6 |= (s5 = e9.__digit(u6)) >>> 30 - h7, f6 = s5 << h7 + 2, p7 = h7 + 2); 0 < p7 && 0 < u6; )
          u6--, s5 = e9.__digit(u6), f6 |= 30 <= p7 ? s5 << p7 - 30 : s5 >>> 30 - p7, p7 -= 30;
        var m6 = l7.__decideRounding(e9, p7, u6, s5);
        if ((1 === m6 || 0 === m6 && 1 == (1 & f6)) && 0 == (f6 = f6 + 1 >>> 0) && 0 != ++d6 >>> 20 && (d6 = 0, 1023 < ++a5))
          return e9.sign ? -1 / 0 : 1 / 0;
        var y6 = e9.sign ? -2147483648 : 0;
        return a5 = a5 + 1023 << 20, l7.__kBitConversionInts[1] = y6 | a5 | d6, l7.__kBitConversionInts[0] = f6, l7.__kBitConversionDouble[0];
      } }, { key: "unaryMinus", value: function(e9) {
        if (0 === e9.length)
          return e9;
        var t3 = e9.__copy();
        return t3.sign = !e9.sign, t3;
      } }, { key: "bitwiseNot", value: function(e9) {
        return e9.sign ? l7.__absoluteSubOne(e9).__trim() : l7.__absoluteAddOne(e9, true);
      } }, { key: "exponentiate", value: function(e9, t3) {
        if (t3.sign)
          throw new RangeError("Exponent must be positive");
        if (0 === t3.length)
          return l7.__oneDigit(1, false);
        if (0 === e9.length)
          return e9;
        if (1 === e9.length && 1 === e9.__digit(0))
          return e9.sign && 0 == (1 & t3.__digit(0)) ? l7.unaryMinus(e9) : e9;
        if (1 < t3.length)
          throw new RangeError("BigInt too big");
        var r2 = t3.__unsignedDigit(0);
        if (1 === r2)
          return e9;
        if (r2 >= l7.__kMaxLengthBits)
          throw new RangeError("BigInt too big");
        if (1 === e9.length && 2 === e9.__digit(0)) {
          var n5 = 1 + (0 | r2 / 30), i6 = new l7(n5, e9.sign && 0 != (1 & r2));
          i6.__initializeDigits();
          var o5 = 1 << r2 % 30;
          return i6.__setDigit(n5 - 1, o5), i6;
        }
        var a5 = null, s5 = e9;
        for (0 != (1 & r2) && (a5 = e9), r2 >>= 1; 0 !== r2; r2 >>= 1)
          s5 = l7.multiply(s5, s5), 0 != (1 & r2) && (a5 = null === a5 ? s5 : l7.multiply(a5, s5));
        return a5;
      } }, { key: "multiply", value: function(e9, t3) {
        if (0 === e9.length)
          return e9;
        if (0 === t3.length)
          return t3;
        var r2 = e9.length + t3.length;
        30 <= e9.__clzmsd() + t3.__clzmsd() && r2--;
        var n5 = new l7(r2, e9.sign !== t3.sign);
        n5.__initializeDigits();
        for (var i6 = 0; i6 < e9.length; i6++)
          l7.__multiplyAccumulate(t3, e9.__digit(i6), n5, i6);
        return n5.__trim();
      } }, { key: "divide", value: function(e9, t3) {
        if (0 === t3.length)
          throw new RangeError("Division by zero");
        if (0 > l7.__absoluteCompare(e9, t3))
          return l7.__zero();
        var r2, n5 = e9.sign !== t3.sign, i6 = t3.__unsignedDigit(0);
        if (1 === t3.length && 32767 >= i6) {
          if (1 === i6)
            return n5 === e9.sign ? e9 : l7.unaryMinus(e9);
          r2 = l7.__absoluteDivSmall(e9, i6, null);
        } else
          r2 = l7.__absoluteDivLarge(e9, t3, true, false);
        return r2.sign = n5, r2.__trim();
      } }, { key: "remainder", value: function(e9, t3) {
        if (0 === t3.length)
          throw new RangeError("Division by zero");
        if (0 > l7.__absoluteCompare(e9, t3))
          return e9;
        var r2 = t3.__unsignedDigit(0);
        if (1 === t3.length && 32767 >= r2) {
          if (1 === r2)
            return l7.__zero();
          var n5 = l7.__absoluteModSmall(e9, r2);
          return 0 === n5 ? l7.__zero() : l7.__oneDigit(n5, e9.sign);
        }
        var i6 = l7.__absoluteDivLarge(e9, t3, false, true);
        return i6.sign = e9.sign, i6.__trim();
      } }, { key: "add", value: function(e9, t3) {
        var r2 = e9.sign;
        return r2 === t3.sign ? l7.__absoluteAdd(e9, t3, r2) : 0 <= l7.__absoluteCompare(e9, t3) ? l7.__absoluteSub(e9, t3, r2) : l7.__absoluteSub(t3, e9, !r2);
      } }, { key: "subtract", value: function(e9, t3) {
        var r2 = e9.sign;
        return r2 === t3.sign ? 0 <= l7.__absoluteCompare(e9, t3) ? l7.__absoluteSub(e9, t3, r2) : l7.__absoluteSub(t3, e9, !r2) : l7.__absoluteAdd(e9, t3, r2);
      } }, { key: "leftShift", value: function(e9, t3) {
        return 0 === t3.length || 0 === e9.length ? e9 : t3.sign ? l7.__rightShiftByAbsolute(e9, t3) : l7.__leftShiftByAbsolute(e9, t3);
      } }, { key: "signedRightShift", value: function(e9, t3) {
        return 0 === t3.length || 0 === e9.length ? e9 : t3.sign ? l7.__leftShiftByAbsolute(e9, t3) : l7.__rightShiftByAbsolute(e9, t3);
      } }, { key: "unsignedRightShift", value: function() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      } }, { key: "lessThan", value: function(e9, t3) {
        return 0 > l7.__compareToBigInt(e9, t3);
      } }, { key: "lessThanOrEqual", value: function(e9, t3) {
        return 0 >= l7.__compareToBigInt(e9, t3);
      } }, { key: "greaterThan", value: function(e9, t3) {
        return 0 < l7.__compareToBigInt(e9, t3);
      } }, { key: "greaterThanOrEqual", value: function(e9, t3) {
        return 0 <= l7.__compareToBigInt(e9, t3);
      } }, { key: "equal", value: function(e9, t3) {
        if (e9.sign !== t3.sign)
          return false;
        if (e9.length !== t3.length)
          return false;
        for (var r2 = 0; r2 < e9.length; r2++)
          if (e9.__digit(r2) !== t3.__digit(r2))
            return false;
        return true;
      } }, { key: "notEqual", value: function(e9, t3) {
        return !l7.equal(e9, t3);
      } }, { key: "bitwiseAnd", value: function(e9, t3) {
        if (!e9.sign && !t3.sign)
          return l7.__absoluteAnd(e9, t3).__trim();
        if (e9.sign && t3.sign) {
          var r2 = i5(e9.length, t3.length) + 1, n5 = l7.__absoluteSubOne(e9, r2), o5 = l7.__absoluteSubOne(t3);
          return n5 = l7.__absoluteOr(n5, o5, n5), l7.__absoluteAddOne(n5, true, n5).__trim();
        }
        if (e9.sign) {
          var a5 = [t3, e9];
          e9 = a5[0], t3 = a5[1];
        }
        return l7.__absoluteAndNot(e9, l7.__absoluteSubOne(t3)).__trim();
      } }, { key: "bitwiseXor", value: function(e9, t3) {
        if (!e9.sign && !t3.sign)
          return l7.__absoluteXor(e9, t3).__trim();
        if (e9.sign && t3.sign) {
          var r2 = i5(e9.length, t3.length), n5 = l7.__absoluteSubOne(e9, r2), o5 = l7.__absoluteSubOne(t3);
          return l7.__absoluteXor(n5, o5, n5).__trim();
        }
        var a5 = i5(e9.length, t3.length) + 1;
        if (e9.sign) {
          var s5 = [t3, e9];
          e9 = s5[0], t3 = s5[1];
        }
        var u6 = l7.__absoluteSubOne(t3, a5);
        return u6 = l7.__absoluteXor(u6, e9, u6), l7.__absoluteAddOne(u6, true, u6).__trim();
      } }, { key: "bitwiseOr", value: function(e9, t3) {
        var r2 = i5(e9.length, t3.length);
        if (!e9.sign && !t3.sign)
          return l7.__absoluteOr(e9, t3).__trim();
        if (e9.sign && t3.sign) {
          var n5 = l7.__absoluteSubOne(e9, r2), o5 = l7.__absoluteSubOne(t3);
          return n5 = l7.__absoluteAnd(n5, o5, n5), l7.__absoluteAddOne(n5, true, n5).__trim();
        }
        if (e9.sign) {
          var a5 = [t3, e9];
          e9 = a5[0], t3 = a5[1];
        }
        var s5 = l7.__absoluteSubOne(t3, r2);
        return s5 = l7.__absoluteAndNot(s5, e9, s5), l7.__absoluteAddOne(s5, true, s5).__trim();
      } }, { key: "asIntN", value: function(e9, t3) {
        if (0 === t3.length)
          return t3;
        if (0 > (e9 = s4(e9)))
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === e9)
          return l7.__zero();
        if (e9 >= l7.__kMaxLengthBits)
          return t3;
        var r2 = 0 | (e9 + 29) / 30;
        if (t3.length < r2)
          return t3;
        var n5 = t3.__unsignedDigit(r2 - 1), i6 = 1 << (e9 - 1) % 30;
        if (t3.length === r2 && n5 < i6)
          return t3;
        if ((n5 & i6) !== i6)
          return l7.__truncateToNBits(e9, t3);
        if (!t3.sign)
          return l7.__truncateAndSubFromPowerOfTwo(e9, t3, true);
        if (0 == (n5 & i6 - 1)) {
          for (var o5 = r2 - 2; 0 <= o5; o5--)
            if (0 !== t3.__digit(o5))
              return l7.__truncateAndSubFromPowerOfTwo(e9, t3, false);
          return t3.length === r2 && n5 === i6 ? t3 : l7.__truncateToNBits(e9, t3);
        }
        return l7.__truncateAndSubFromPowerOfTwo(e9, t3, false);
      } }, { key: "asUintN", value: function(e9, t3) {
        if (0 === t3.length)
          return t3;
        if (0 > (e9 = s4(e9)))
          throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === e9)
          return l7.__zero();
        if (t3.sign) {
          if (e9 > l7.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          return l7.__truncateAndSubFromPowerOfTwo(e9, t3, false);
        }
        if (e9 >= l7.__kMaxLengthBits)
          return t3;
        var r2 = 0 | (e9 + 29) / 30;
        if (t3.length < r2)
          return t3;
        var n5 = e9 % 30;
        if (t3.length == r2) {
          if (0 === n5)
            return t3;
          if (0 == t3.__digit(r2 - 1) >>> n5)
            return t3;
        }
        return l7.__truncateToNBits(e9, t3);
      } }, { key: "ADD", value: function(e9, t3) {
        if (e9 = l7.__toPrimitive(e9), t3 = l7.__toPrimitive(t3), "string" == typeof e9)
          return "string" != typeof t3 && (t3 = t3.toString()), e9 + t3;
        if ("string" == typeof t3)
          return e9.toString() + t3;
        if (e9 = l7.__toNumeric(e9), t3 = l7.__toNumeric(t3), l7.__isBigInt(e9) && l7.__isBigInt(t3))
          return l7.add(e9, t3);
        if ("number" == typeof e9 && "number" == typeof t3)
          return e9 + t3;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      } }, { key: "LT", value: function(e9, t3) {
        return l7.__compare(e9, t3, 0);
      } }, { key: "LE", value: function(e9, t3) {
        return l7.__compare(e9, t3, 1);
      } }, { key: "GT", value: function(e9, t3) {
        return l7.__compare(e9, t3, 2);
      } }, { key: "GE", value: function(e9, t3) {
        return l7.__compare(e9, t3, 3);
      } }, { key: "EQ", value: function(e9, t3) {
        for (; ; ) {
          if (l7.__isBigInt(e9))
            return l7.__isBigInt(t3) ? l7.equal(e9, t3) : l7.EQ(t3, e9);
          if ("number" == typeof e9) {
            if (l7.__isBigInt(t3))
              return l7.__equalToNumber(t3, e9);
            if ("object" !== r(t3))
              return e9 == t3;
            t3 = l7.__toPrimitive(t3);
          } else if ("string" == typeof e9) {
            if (l7.__isBigInt(t3))
              return null !== (e9 = l7.__fromString(e9)) && l7.equal(e9, t3);
            if ("object" !== r(t3))
              return e9 == t3;
            t3 = l7.__toPrimitive(t3);
          } else if ("boolean" == typeof e9) {
            if (l7.__isBigInt(t3))
              return l7.__equalToNumber(t3, +e9);
            if ("object" !== r(t3))
              return e9 == t3;
            t3 = l7.__toPrimitive(t3);
          } else if ("symbol" === r(e9)) {
            if (l7.__isBigInt(t3))
              return false;
            if ("object" !== r(t3))
              return e9 == t3;
            t3 = l7.__toPrimitive(t3);
          } else {
            if ("object" !== r(e9))
              return e9 == t3;
            if ("object" === r(t3) && t3.constructor !== l7)
              return e9 == t3;
            e9 = l7.__toPrimitive(e9);
          }
        }
      } }, { key: "NE", value: function(e9, t3) {
        return !l7.EQ(e9, t3);
      } }, { key: "DataViewGetBigInt64", value: function(e9, t3) {
        var r2 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2];
        return l7.asIntN(64, l7.DataViewGetBigUint64(e9, t3, r2));
      } }, { key: "DataViewGetBigUint64", value: function(e9, t3) {
        var r2 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], n5 = y5(r2 ? [4, 0] : [0, 4], 2), i6 = n5[0], o5 = n5[1], a5 = e9.getUint32(t3 + i6, r2), s5 = e9.getUint32(t3 + o5, r2), u6 = new l7(3, false);
        return u6.__setDigit(0, 1073741823 & s5), u6.__setDigit(1, (268435455 & a5) << 2 | s5 >>> 30), u6.__setDigit(2, a5 >>> 28), u6.__trim();
      } }, { key: "DataViewSetBigInt64", value: function(e9, t3, r2) {
        var n5 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
        l7.DataViewSetBigUint64(e9, t3, r2, n5);
      } }, { key: "DataViewSetBigUint64", value: function(e9, t3, r2) {
        var n5 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3], i6 = 0, o5 = 0;
        if (0 < (r2 = l7.asUintN(64, r2)).length && (o5 = r2.__digit(0), 1 < r2.length)) {
          var a5 = r2.__digit(1);
          o5 |= a5 << 30, i6 = a5 >>> 2, 2 < r2.length && (i6 |= r2.__digit(2) << 28);
        }
        var s5 = y5(n5 ? [4, 0] : [0, 4], 2), u6 = s5[0], c4 = s5[1];
        e9.setUint32(t3 + u6, i6, n5), e9.setUint32(t3 + c4, o5, n5);
      } }, { key: "__zero", value: function() {
        return new l7(0, false);
      } }, { key: "__oneDigit", value: function(e9, t3) {
        var r2 = new l7(1, t3);
        return r2.__setDigit(0, e9), r2;
      } }, { key: "__decideRounding", value: function(e9, t3, r2, n5) {
        if (0 < t3)
          return -1;
        var i6;
        if (0 > t3)
          i6 = -t3 - 1;
        else {
          if (0 === r2)
            return -1;
          r2--, n5 = e9.__digit(r2), i6 = 29;
        }
        var o5 = 1 << i6;
        if (0 == (n5 & o5))
          return -1;
        if (0 != (n5 & (o5 -= 1)))
          return 1;
        for (; 0 < r2; )
          if (r2--, 0 !== e9.__digit(r2))
            return 1;
        return 0;
      } }, { key: "__fromDouble", value: function(e9) {
        l7.__kBitConversionDouble[0] = e9;
        var t3, r2 = (2047 & l7.__kBitConversionInts[1] >>> 20) - 1023, n5 = 1 + (0 | r2 / 30), i6 = new l7(n5, 0 > e9), o5 = 1048575 & l7.__kBitConversionInts[1] | 1048576, a5 = l7.__kBitConversionInts[0], s5 = 20, u6 = r2 % 30, c4 = 0;
        if (u6 < s5) {
          var d6 = s5 - u6;
          c4 = d6 + 32, t3 = o5 >>> d6, o5 = o5 << 32 - d6 | a5 >>> d6, a5 <<= 32 - d6;
        } else if (u6 === s5)
          c4 = 32, t3 = o5, o5 = a5, a5 = 0;
        else {
          var h7 = u6 - s5;
          c4 = 32 - h7, t3 = o5 << h7 | a5 >>> 32 - h7, o5 = a5 << h7, a5 = 0;
        }
        i6.__setDigit(n5 - 1, t3);
        for (var f6 = n5 - 2; 0 <= f6; f6--)
          0 < c4 ? (c4 -= 30, t3 = o5 >>> 2, o5 = o5 << 30 | a5 >>> 2, a5 <<= 30) : t3 = 0, i6.__setDigit(f6, t3);
        return i6.__trim();
      } }, { key: "__isWhitespace", value: function(e9) {
        return !!(13 >= e9 && 9 <= e9) || (159 >= e9 ? 32 == e9 : 131071 >= e9 ? 160 == e9 || 5760 == e9 : 196607 >= e9 ? 10 >= (e9 &= 131071) || 40 == e9 || 41 == e9 || 47 == e9 || 95 == e9 || 4096 == e9 : 65279 == e9);
      } }, { key: "__fromString", value: function(e9) {
        var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, r2 = 0, n5 = e9.length, i6 = 0;
        if (i6 === n5)
          return l7.__zero();
        for (var o5 = e9.charCodeAt(i6); l7.__isWhitespace(o5); ) {
          if (++i6 === n5)
            return l7.__zero();
          o5 = e9.charCodeAt(i6);
        }
        if (43 === o5) {
          if (++i6 === n5)
            return null;
          o5 = e9.charCodeAt(i6), r2 = 1;
        } else if (45 === o5) {
          if (++i6 === n5)
            return null;
          o5 = e9.charCodeAt(i6), r2 = -1;
        }
        if (0 === t3) {
          if (t3 = 10, 48 === o5) {
            if (++i6 === n5)
              return l7.__zero();
            if (88 === (o5 = e9.charCodeAt(i6)) || 120 === o5) {
              if (t3 = 16, ++i6 === n5)
                return null;
              o5 = e9.charCodeAt(i6);
            } else if (79 === o5 || 111 === o5) {
              if (t3 = 8, ++i6 === n5)
                return null;
              o5 = e9.charCodeAt(i6);
            } else if (66 === o5 || 98 === o5) {
              if (t3 = 2, ++i6 === n5)
                return null;
              o5 = e9.charCodeAt(i6);
            }
          }
        } else if (16 === t3 && 48 === o5) {
          if (++i6 === n5)
            return l7.__zero();
          if (88 === (o5 = e9.charCodeAt(i6)) || 120 === o5) {
            if (++i6 === n5)
              return null;
            o5 = e9.charCodeAt(i6);
          }
        }
        if (0 !== r2 && 10 !== t3)
          return null;
        for (; 48 === o5; ) {
          if (++i6 === n5)
            return l7.__zero();
          o5 = e9.charCodeAt(i6);
        }
        var a5 = n5 - i6, s5 = l7.__kMaxBitsPerChar[t3], u6 = l7.__kBitsPerCharTableMultiplier - 1;
        if (a5 > 1073741824 / s5)
          return null;
        var c4 = new l7(0 | (29 + (s5 * a5 + u6 >>> l7.__kBitsPerCharTableShift)) / 30, false), d6 = 10 > t3 ? t3 : 10, h7 = 10 < t3 ? t3 - 10 : 0;
        if (0 == (t3 & t3 - 1)) {
          s5 >>= l7.__kBitsPerCharTableShift;
          var f6 = [], p7 = [], m6 = false;
          do {
            for (var y6, g6 = 0, v7 = 0; ; ) {
              if (y6 = void 0, o5 - 48 >>> 0 < d6)
                y6 = o5 - 48;
              else {
                if (!((32 | o5) - 97 >>> 0 < h7)) {
                  m6 = true;
                  break;
                }
                y6 = (32 | o5) - 87;
              }
              if (v7 += s5, g6 = g6 << s5 | y6, ++i6 === n5) {
                m6 = true;
                break;
              }
              if (o5 = e9.charCodeAt(i6), 30 < v7 + s5)
                break;
            }
            f6.push(g6), p7.push(v7);
          } while (!m6);
          l7.__fillFromParts(c4, f6, p7);
        } else {
          c4.__initializeDigits();
          var w6 = false, b8 = 0;
          do {
            for (var _6, E5 = 0, T7 = 1; ; ) {
              if (_6 = void 0, o5 - 48 >>> 0 < d6)
                _6 = o5 - 48;
              else {
                if (!((32 | o5) - 97 >>> 0 < h7)) {
                  w6 = true;
                  break;
                }
                _6 = (32 | o5) - 87;
              }
              var x6 = T7 * t3;
              if (1073741823 < x6)
                break;
              if (T7 = x6, E5 = E5 * t3 + _6, b8++, ++i6 === n5) {
                w6 = true;
                break;
              }
              o5 = e9.charCodeAt(i6);
            }
            var I5 = 0 | (s5 * b8 + (u6 = 30 * l7.__kBitsPerCharTableMultiplier - 1) >>> l7.__kBitsPerCharTableShift) / 30;
            c4.__inplaceMultiplyAdd(T7, E5, I5);
          } while (!w6);
        }
        if (i6 !== n5) {
          if (!l7.__isWhitespace(o5))
            return null;
          for (i6++; i6 < n5; i6++)
            if (o5 = e9.charCodeAt(i6), !l7.__isWhitespace(o5))
              return null;
        }
        return c4.sign = -1 === r2, c4.__trim();
      } }, { key: "__fillFromParts", value: function(e9, t3, r2) {
        for (var n5 = 0, i6 = 0, o5 = 0, a5 = t3.length - 1; 0 <= a5; a5--) {
          var s5 = t3[a5], l8 = r2[a5];
          i6 |= s5 << o5, 30 === (o5 += l8) ? (e9.__setDigit(n5++, i6), o5 = 0, i6 = 0) : 30 < o5 && (e9.__setDigit(n5++, 1073741823 & i6), i6 = s5 >>> l8 - (o5 -= 30));
        }
        if (0 !== i6) {
          if (n5 >= e9.length)
            throw new Error("implementation bug");
          e9.__setDigit(n5++, i6);
        }
        for (; n5 < e9.length; n5++)
          e9.__setDigit(n5, 0);
      } }, { key: "__toStringBasePowerOfTwo", value: function(e9, t3) {
        var r2 = e9.length, n5 = t3 - 1, i6 = n5 = (15 & (n5 = (51 & (n5 = (85 & n5 >>> 1) + (85 & n5)) >>> 2) + (51 & n5)) >>> 4) + (15 & n5), o5 = t3 - 1, a5 = e9.__digit(r2 - 1), s5 = 0 | (30 * r2 - l7.__clz30(a5) + i6 - 1) / i6;
        if (e9.sign && s5++, 268435456 < s5)
          throw new Error("string too long");
        for (var u6 = Array(s5), c4 = s5 - 1, d6 = 0, h7 = 0, f6 = 0; f6 < r2 - 1; f6++) {
          var p7 = e9.__digit(f6), m6 = (d6 | p7 << h7) & o5;
          u6[c4--] = l7.__kConversionChars[m6];
          var y6 = i6 - h7;
          for (d6 = p7 >>> y6, h7 = 30 - y6; h7 >= i6; )
            u6[c4--] = l7.__kConversionChars[d6 & o5], d6 >>>= i6, h7 -= i6;
        }
        var g6 = (d6 | a5 << h7) & o5;
        for (u6[c4--] = l7.__kConversionChars[g6], d6 = a5 >>> i6 - h7; 0 !== d6; )
          u6[c4--] = l7.__kConversionChars[d6 & o5], d6 >>>= i6;
        if (e9.sign && (u6[c4--] = "-"), -1 !== c4)
          throw new Error("implementation bug");
        return u6.join("");
      } }, { key: "__toStringGeneric", value: function(e9, t3, r2) {
        var n5 = e9.length;
        if (0 === n5)
          return "";
        if (1 === n5) {
          var i6 = e9.__unsignedDigit(0).toString(t3);
          return false === r2 && e9.sign && (i6 = "-" + i6), i6;
        }
        var o5, a5, s5 = 30 * n5 - l7.__clz30(e9.__digit(n5 - 1)), u6 = l7.__kMaxBitsPerChar[t3] - 1, c4 = s5 * l7.__kBitsPerCharTableMultiplier, d6 = 1 + (c4 = 0 | (c4 += u6 - 1) / u6) >> 1, h7 = l7.exponentiate(l7.__oneDigit(t3, false), l7.__oneDigit(d6, false)), f6 = h7.__unsignedDigit(0);
        if (1 === h7.length && 32767 >= f6) {
          (o5 = new l7(e9.length, false)).__initializeDigits();
          for (var p7, m6 = 0, y6 = 2 * e9.length - 1; 0 <= y6; y6--)
            p7 = m6 << 15 | e9.__halfDigit(y6), o5.__setHalfDigit(y6, 0 | p7 / f6), m6 = 0 | p7 % f6;
          a5 = m6.toString(t3);
        } else {
          var g6 = l7.__absoluteDivLarge(e9, h7, true, true);
          o5 = g6.quotient;
          var v7 = g6.remainder.__trim();
          a5 = l7.__toStringGeneric(v7, t3, true);
        }
        o5.__trim();
        for (var w6 = l7.__toStringGeneric(o5, t3, true); a5.length < d6; )
          a5 = "0" + a5;
        return false === r2 && e9.sign && (w6 = "-" + w6), w6 + a5;
      } }, { key: "__unequalSign", value: function(e9) {
        return e9 ? -1 : 1;
      } }, { key: "__absoluteGreater", value: function(e9) {
        return e9 ? -1 : 1;
      } }, { key: "__absoluteLess", value: function(e9) {
        return e9 ? 1 : -1;
      } }, { key: "__compareToBigInt", value: function(e9, t3) {
        var r2 = e9.sign;
        if (r2 !== t3.sign)
          return l7.__unequalSign(r2);
        var n5 = l7.__absoluteCompare(e9, t3);
        return 0 < n5 ? l7.__absoluteGreater(r2) : 0 > n5 ? l7.__absoluteLess(r2) : 0;
      } }, { key: "__compareToNumber", value: function(e9, r2) {
        if (l7.__isOneDigitInt(r2)) {
          var n5 = e9.sign, i6 = 0 > r2;
          if (n5 !== i6)
            return l7.__unequalSign(n5);
          if (0 === e9.length) {
            if (i6)
              throw new Error("implementation bug");
            return 0 === r2 ? 0 : -1;
          }
          if (1 < e9.length)
            return l7.__absoluteGreater(n5);
          var o5 = t2(r2), a5 = e9.__unsignedDigit(0);
          return a5 > o5 ? l7.__absoluteGreater(n5) : a5 < o5 ? l7.__absoluteLess(n5) : 0;
        }
        return l7.__compareToDouble(e9, r2);
      } }, { key: "__compareToDouble", value: function(e9, t3) {
        if (t3 != t3)
          return t3;
        if (t3 === 1 / 0)
          return -1;
        if (t3 === -1 / 0)
          return 1;
        var r2 = e9.sign;
        if (r2 !== 0 > t3)
          return l7.__unequalSign(r2);
        if (0 === t3)
          throw new Error("implementation bug: should be handled elsewhere");
        if (0 === e9.length)
          return -1;
        l7.__kBitConversionDouble[0] = t3;
        var n5 = 2047 & l7.__kBitConversionInts[1] >>> 20;
        if (2047 == n5)
          throw new Error("implementation bug: handled elsewhere");
        var i6 = n5 - 1023;
        if (0 > i6)
          return l7.__absoluteGreater(r2);
        var o5 = e9.length, a5 = e9.__digit(o5 - 1), s5 = l7.__clz30(a5), u6 = 30 * o5 - s5, c4 = i6 + 1;
        if (u6 < c4)
          return l7.__absoluteLess(r2);
        if (u6 > c4)
          return l7.__absoluteGreater(r2);
        var d6 = 1048576 | 1048575 & l7.__kBitConversionInts[1], h7 = l7.__kBitConversionInts[0], f6 = 20, p7 = 29 - s5;
        if (p7 !== (0 | (u6 - 1) % 30))
          throw new Error("implementation bug");
        var m6, y6 = 0;
        if (p7 < f6) {
          var g6 = f6 - p7;
          y6 = g6 + 32, m6 = d6 >>> g6, d6 = d6 << 32 - g6 | h7 >>> g6, h7 <<= 32 - g6;
        } else if (p7 === f6)
          y6 = 32, m6 = d6, d6 = h7, h7 = 0;
        else {
          var v7 = p7 - f6;
          y6 = 32 - v7, m6 = d6 << v7 | h7 >>> 32 - v7, d6 = h7 << v7, h7 = 0;
        }
        if ((a5 >>>= 0) > (m6 >>>= 0))
          return l7.__absoluteGreater(r2);
        if (a5 < m6)
          return l7.__absoluteLess(r2);
        for (var w6 = o5 - 2; 0 <= w6; w6--) {
          0 < y6 ? (y6 -= 30, m6 = d6 >>> 2, d6 = d6 << 30 | h7 >>> 2, h7 <<= 30) : m6 = 0;
          var b8 = e9.__unsignedDigit(w6);
          if (b8 > m6)
            return l7.__absoluteGreater(r2);
          if (b8 < m6)
            return l7.__absoluteLess(r2);
        }
        if (0 !== d6 || 0 !== h7) {
          if (0 === y6)
            throw new Error("implementation bug");
          return l7.__absoluteLess(r2);
        }
        return 0;
      } }, { key: "__equalToNumber", value: function(e9, r2) {
        return l7.__isOneDigitInt(r2) ? 0 === r2 ? 0 === e9.length : 1 === e9.length && e9.sign === 0 > r2 && e9.__unsignedDigit(0) === t2(r2) : 0 === l7.__compareToDouble(e9, r2);
      } }, { key: "__comparisonResultToBool", value: function(e9, t3) {
        return 0 === t3 ? 0 > e9 : 1 === t3 ? 0 >= e9 : 2 === t3 ? 0 < e9 : 3 === t3 ? 0 <= e9 : void 0;
      } }, { key: "__compare", value: function(e9, t3, r2) {
        if (e9 = l7.__toPrimitive(e9), t3 = l7.__toPrimitive(t3), "string" == typeof e9 && "string" == typeof t3)
          switch (r2) {
            case 0:
              return e9 < t3;
            case 1:
              return e9 <= t3;
            case 2:
              return e9 > t3;
            case 3:
              return e9 >= t3;
          }
        if (l7.__isBigInt(e9) && "string" == typeof t3)
          return null !== (t3 = l7.__fromString(t3)) && l7.__comparisonResultToBool(l7.__compareToBigInt(e9, t3), r2);
        if ("string" == typeof e9 && l7.__isBigInt(t3))
          return null !== (e9 = l7.__fromString(e9)) && l7.__comparisonResultToBool(l7.__compareToBigInt(e9, t3), r2);
        if (e9 = l7.__toNumeric(e9), t3 = l7.__toNumeric(t3), l7.__isBigInt(e9)) {
          if (l7.__isBigInt(t3))
            return l7.__comparisonResultToBool(l7.__compareToBigInt(e9, t3), r2);
          if ("number" != typeof t3)
            throw new Error("implementation bug");
          return l7.__comparisonResultToBool(l7.__compareToNumber(e9, t3), r2);
        }
        if ("number" != typeof e9)
          throw new Error("implementation bug");
        if (l7.__isBigInt(t3))
          return l7.__comparisonResultToBool(l7.__compareToNumber(t3, e9), 2 ^ r2);
        if ("number" != typeof t3)
          throw new Error("implementation bug");
        return 0 === r2 ? e9 < t3 : 1 === r2 ? e9 <= t3 : 2 === r2 ? e9 > t3 : 3 === r2 ? e9 >= t3 : void 0;
      } }, { key: "__absoluteAdd", value: function(e9, t3, r2) {
        if (e9.length < t3.length)
          return l7.__absoluteAdd(t3, e9, r2);
        if (0 === e9.length)
          return e9;
        if (0 === t3.length)
          return e9.sign === r2 ? e9 : l7.unaryMinus(e9);
        var n5 = e9.length;
        (0 === e9.__clzmsd() || t3.length === e9.length && 0 === t3.__clzmsd()) && n5++;
        for (var i6, o5 = new l7(n5, r2), a5 = 0, s5 = 0; s5 < t3.length; s5++)
          a5 = (i6 = e9.__digit(s5) + t3.__digit(s5) + a5) >>> 30, o5.__setDigit(s5, 1073741823 & i6);
        for (; s5 < e9.length; s5++) {
          var u6 = e9.__digit(s5) + a5;
          a5 = u6 >>> 30, o5.__setDigit(s5, 1073741823 & u6);
        }
        return s5 < o5.length && o5.__setDigit(s5, a5), o5.__trim();
      } }, { key: "__absoluteSub", value: function(e9, t3, r2) {
        if (0 === e9.length)
          return e9;
        if (0 === t3.length)
          return e9.sign === r2 ? e9 : l7.unaryMinus(e9);
        for (var n5, i6 = new l7(e9.length, r2), o5 = 0, a5 = 0; a5 < t3.length; a5++)
          o5 = 1 & (n5 = e9.__digit(a5) - t3.__digit(a5) - o5) >>> 30, i6.__setDigit(a5, 1073741823 & n5);
        for (; a5 < e9.length; a5++) {
          var s5 = e9.__digit(a5) - o5;
          o5 = 1 & s5 >>> 30, i6.__setDigit(a5, 1073741823 & s5);
        }
        return i6.__trim();
      } }, { key: "__absoluteAddOne", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n5 = e9.length;
        null === r2 ? r2 = new l7(n5, t3) : r2.sign = t3;
        for (var i6, o5 = 1, a5 = 0; a5 < n5; a5++)
          o5 = (i6 = e9.__digit(a5) + o5) >>> 30, r2.__setDigit(a5, 1073741823 & i6);
        return 0 !== o5 && r2.__setDigitGrow(n5, 1), r2;
      } }, { key: "__absoluteSubOne", value: function(e9, t3) {
        for (var r2, n5 = e9.length, i6 = new l7(t3 = t3 || n5, false), o5 = 1, a5 = 0; a5 < n5; a5++)
          o5 = 1 & (r2 = e9.__digit(a5) - o5) >>> 30, i6.__setDigit(a5, 1073741823 & r2);
        if (0 !== o5)
          throw new Error("implementation bug");
        for (var s5 = n5; s5 < t3; s5++)
          i6.__setDigit(s5, 0);
        return i6;
      } }, { key: "__absoluteAnd", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n5 = e9.length, i6 = t3.length, o5 = i6;
        if (n5 < i6) {
          o5 = n5;
          var a5 = e9, s5 = n5;
          e9 = t3, n5 = i6, t3 = a5, i6 = s5;
        }
        var u6 = o5;
        null === r2 ? r2 = new l7(u6, false) : u6 = r2.length;
        for (var c4 = 0; c4 < o5; c4++)
          r2.__setDigit(c4, e9.__digit(c4) & t3.__digit(c4));
        for (; c4 < u6; c4++)
          r2.__setDigit(c4, 0);
        return r2;
      } }, { key: "__absoluteAndNot", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n5 = e9.length, i6 = t3.length, o5 = i6;
        n5 < i6 && (o5 = n5);
        var a5 = n5;
        null === r2 ? r2 = new l7(a5, false) : a5 = r2.length;
        for (var s5 = 0; s5 < o5; s5++)
          r2.__setDigit(s5, e9.__digit(s5) & ~t3.__digit(s5));
        for (; s5 < n5; s5++)
          r2.__setDigit(s5, e9.__digit(s5));
        for (; s5 < a5; s5++)
          r2.__setDigit(s5, 0);
        return r2;
      } }, { key: "__absoluteOr", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n5 = e9.length, i6 = t3.length, o5 = i6;
        if (n5 < i6) {
          o5 = n5;
          var a5 = e9, s5 = n5;
          e9 = t3, n5 = i6, t3 = a5, i6 = s5;
        }
        var u6 = n5;
        null === r2 ? r2 = new l7(u6, false) : u6 = r2.length;
        for (var c4 = 0; c4 < o5; c4++)
          r2.__setDigit(c4, e9.__digit(c4) | t3.__digit(c4));
        for (; c4 < n5; c4++)
          r2.__setDigit(c4, e9.__digit(c4));
        for (; c4 < u6; c4++)
          r2.__setDigit(c4, 0);
        return r2;
      } }, { key: "__absoluteXor", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n5 = e9.length, i6 = t3.length, o5 = i6;
        if (n5 < i6) {
          o5 = n5;
          var a5 = e9, s5 = n5;
          e9 = t3, n5 = i6, t3 = a5, i6 = s5;
        }
        var u6 = n5;
        null === r2 ? r2 = new l7(u6, false) : u6 = r2.length;
        for (var c4 = 0; c4 < o5; c4++)
          r2.__setDigit(c4, e9.__digit(c4) ^ t3.__digit(c4));
        for (; c4 < n5; c4++)
          r2.__setDigit(c4, e9.__digit(c4));
        for (; c4 < u6; c4++)
          r2.__setDigit(c4, 0);
        return r2;
      } }, { key: "__absoluteCompare", value: function(e9, t3) {
        var r2 = e9.length - t3.length;
        if (0 != r2)
          return r2;
        for (var n5 = e9.length - 1; 0 <= n5 && e9.__digit(n5) === t3.__digit(n5); )
          n5--;
        return 0 > n5 ? 0 : e9.__unsignedDigit(n5) > t3.__unsignedDigit(n5) ? 1 : -1;
      } }, { key: "__multiplyAccumulate", value: function(e9, t3, r2, n5) {
        if (0 !== t3) {
          for (var i6 = 32767 & t3, o5 = t3 >>> 15, a5 = 0, s5 = 0, u6 = 0; u6 < e9.length; u6++, n5++) {
            var c4 = r2.__digit(n5), d6 = e9.__digit(u6), h7 = 32767 & d6, f6 = d6 >>> 15, p7 = l7.__imul(h7, i6), m6 = l7.__imul(h7, o5), y6 = l7.__imul(f6, i6);
            a5 = (c4 += s5 + p7 + a5) >>> 30, c4 &= 1073741823, a5 += (c4 += ((32767 & m6) << 15) + ((32767 & y6) << 15)) >>> 30, s5 = l7.__imul(f6, o5) + (m6 >>> 15) + (y6 >>> 15), r2.__setDigit(n5, 1073741823 & c4);
          }
          for (; 0 !== a5 || 0 !== s5; n5++) {
            var g6 = r2.__digit(n5);
            g6 += a5 + s5, s5 = 0, a5 = g6 >>> 30, r2.__setDigit(n5, 1073741823 & g6);
          }
        }
      } }, { key: "__internalMultiplyAdd", value: function(e9, t3, r2, n5, i6) {
        for (var o5 = r2, a5 = 0, s5 = 0; s5 < n5; s5++) {
          var u6 = e9.__digit(s5), c4 = l7.__imul(32767 & u6, t3), d6 = l7.__imul(u6 >>> 15, t3), h7 = c4 + ((32767 & d6) << 15) + a5 + o5;
          o5 = h7 >>> 30, a5 = d6 >>> 15, i6.__setDigit(s5, 1073741823 & h7);
        }
        if (i6.length > n5)
          for (i6.__setDigit(n5++, o5 + a5); n5 < i6.length; )
            i6.__setDigit(n5++, 0);
        else if (0 !== o5 + a5)
          throw new Error("implementation bug");
      } }, { key: "__absoluteDivSmall", value: function(e9, t3) {
        var r2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        null === r2 && (r2 = new l7(e9.length, false));
        for (var n5 = 0, i6 = 2 * e9.length - 1; 0 <= i6; i6 -= 2) {
          var o5 = (n5 << 15 | e9.__halfDigit(i6)) >>> 0, a5 = 0 | o5 / t3, s5 = 0 | (o5 = ((n5 = 0 | o5 % t3) << 15 | e9.__halfDigit(i6 - 1)) >>> 0) / t3;
          n5 = 0 | o5 % t3, r2.__setDigit(i6 >>> 1, a5 << 15 | s5);
        }
        return r2;
      } }, { key: "__absoluteModSmall", value: function(e9, t3) {
        for (var r2 = 0, n5 = 2 * e9.length - 1; 0 <= n5; n5--)
          r2 = 0 | ((r2 << 15 | e9.__halfDigit(n5)) >>> 0) % t3;
        return r2;
      } }, { key: "__absoluteDivLarge", value: function(e9, t3, r2, n5) {
        var i6 = t3.__halfDigitLength(), o5 = t3.length, a5 = e9.__halfDigitLength() - i6, s5 = null;
        r2 && (s5 = new l7(a5 + 2 >>> 1, false)).__initializeDigits();
        var u6 = new l7(i6 + 2 >>> 1, false);
        u6.__initializeDigits();
        var c4 = l7.__clz15(t3.__halfDigit(i6 - 1));
        0 < c4 && (t3 = l7.__specialLeftShift(t3, c4, 0));
        for (var d6 = l7.__specialLeftShift(e9, c4, 1), h7 = t3.__halfDigit(i6 - 1), f6 = 0, p7 = a5; 0 <= p7; p7--) {
          var m6 = 32767, y6 = d6.__halfDigit(p7 + i6);
          if (y6 !== h7) {
            var g6 = (y6 << 15 | d6.__halfDigit(p7 + i6 - 1)) >>> 0;
            m6 = 0 | g6 / h7;
            for (var v7 = 0 | g6 % h7, w6 = t3.__halfDigit(i6 - 2), b8 = d6.__halfDigit(p7 + i6 - 2); l7.__imul(m6, w6) >>> 0 > (v7 << 16 | b8) >>> 0 && (m6--, !(32767 < (v7 += h7))); )
              ;
          }
          l7.__internalMultiplyAdd(t3, m6, 0, o5, u6);
          var _6 = d6.__inplaceSub(u6, p7, i6 + 1);
          0 !== _6 && (_6 = d6.__inplaceAdd(t3, p7, i6), d6.__setHalfDigit(p7 + i6, 32767 & d6.__halfDigit(p7 + i6) + _6), m6--), r2 && (1 & p7 ? f6 = m6 << 15 : s5.__setDigit(p7 >>> 1, f6 | m6));
        }
        if (n5)
          return d6.__inplaceRightShift(c4), r2 ? { quotient: s5, remainder: d6 } : d6;
        if (r2)
          return s5;
        throw new Error("unreachable");
      } }, { key: "__clz15", value: function(e9) {
        return l7.__clz30(e9) - 15;
      } }, { key: "__specialLeftShift", value: function(e9, t3, r2) {
        var n5 = e9.length, i6 = new l7(n5 + r2, false);
        if (0 === t3) {
          for (var o5 = 0; o5 < n5; o5++)
            i6.__setDigit(o5, e9.__digit(o5));
          return 0 < r2 && i6.__setDigit(n5, 0), i6;
        }
        for (var a5, s5 = 0, u6 = 0; u6 < n5; u6++)
          a5 = e9.__digit(u6), i6.__setDigit(u6, 1073741823 & a5 << t3 | s5), s5 = a5 >>> 30 - t3;
        return 0 < r2 && i6.__setDigit(n5, s5), i6;
      } }, { key: "__leftShiftByAbsolute", value: function(e9, t3) {
        var r2 = l7.__toShiftAmount(t3);
        if (0 > r2)
          throw new RangeError("BigInt too big");
        var n5 = 0 | r2 / 30, i6 = r2 % 30, o5 = e9.length, a5 = 0 !== i6 && 0 != e9.__digit(o5 - 1) >>> 30 - i6, s5 = o5 + n5 + (a5 ? 1 : 0), u6 = new l7(s5, e9.sign);
        if (0 === i6) {
          for (var c4 = 0; c4 < n5; c4++)
            u6.__setDigit(c4, 0);
          for (; c4 < s5; c4++)
            u6.__setDigit(c4, e9.__digit(c4 - n5));
        } else {
          for (var d6 = 0, h7 = 0; h7 < n5; h7++)
            u6.__setDigit(h7, 0);
          for (var f6, p7 = 0; p7 < o5; p7++)
            f6 = e9.__digit(p7), u6.__setDigit(p7 + n5, 1073741823 & f6 << i6 | d6), d6 = f6 >>> 30 - i6;
          if (a5)
            u6.__setDigit(o5 + n5, d6);
          else if (0 !== d6)
            throw new Error("implementation bug");
        }
        return u6.__trim();
      } }, { key: "__rightShiftByAbsolute", value: function(e9, t3) {
        var r2 = e9.length, n5 = e9.sign, i6 = l7.__toShiftAmount(t3);
        if (0 > i6)
          return l7.__rightShiftByMaximum(n5);
        var o5 = 0 | i6 / 30, a5 = i6 % 30, s5 = r2 - o5;
        if (0 >= s5)
          return l7.__rightShiftByMaximum(n5);
        var u6 = false;
        if (n5) {
          if (0 != (e9.__digit(o5) & (1 << a5) - 1))
            u6 = true;
          else
            for (var c4 = 0; c4 < o5; c4++)
              if (0 !== e9.__digit(c4)) {
                u6 = true;
                break;
              }
        }
        u6 && 0 === a5 && 0 == ~e9.__digit(r2 - 1) && s5++;
        var d6 = new l7(s5, n5);
        if (0 === a5) {
          d6.__setDigit(s5 - 1, 0);
          for (var h7 = o5; h7 < r2; h7++)
            d6.__setDigit(h7 - o5, e9.__digit(h7));
        } else {
          for (var f6, p7 = e9.__digit(o5) >>> a5, m6 = r2 - o5 - 1, y6 = 0; y6 < m6; y6++)
            f6 = e9.__digit(y6 + o5 + 1), d6.__setDigit(y6, 1073741823 & f6 << 30 - a5 | p7), p7 = f6 >>> a5;
          d6.__setDigit(m6, p7);
        }
        return u6 && (d6 = l7.__absoluteAddOne(d6, true, d6)), d6.__trim();
      } }, { key: "__rightShiftByMaximum", value: function(e9) {
        return e9 ? l7.__oneDigit(1, true) : l7.__zero();
      } }, { key: "__toShiftAmount", value: function(e9) {
        if (1 < e9.length)
          return -1;
        var t3 = e9.__unsignedDigit(0);
        return t3 > l7.__kMaxLengthBits ? -1 : t3;
      } }, { key: "__toPrimitive", value: function(e9) {
        var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "default";
        if ("object" !== r(e9))
          return e9;
        if (e9.constructor === l7)
          return e9;
        if ("undefined" != typeof Symbol && "symbol" === r(Symbol.toPrimitive)) {
          var n5 = e9[Symbol.toPrimitive];
          if (n5) {
            var i6 = n5(t3);
            if ("object" !== r(i6))
              return i6;
            throw new TypeError("Cannot convert object to primitive value");
          }
        }
        var o5 = e9.valueOf;
        if (o5) {
          var a5 = o5.call(e9);
          if ("object" !== r(a5))
            return a5;
        }
        var s5 = e9.toString;
        if (s5) {
          var u6 = s5.call(e9);
          if ("object" !== r(u6))
            return u6;
        }
        throw new TypeError("Cannot convert object to primitive value");
      } }, { key: "__toNumeric", value: function(e9) {
        return l7.__isBigInt(e9) ? e9 : +e9;
      } }, { key: "__isBigInt", value: function(e9) {
        return "object" === r(e9) && null !== e9 && e9.constructor === l7;
      } }, { key: "__truncateToNBits", value: function(e9, t3) {
        for (var r2 = 0 | (e9 + 29) / 30, n5 = new l7(r2, t3.sign), i6 = r2 - 1, o5 = 0; o5 < i6; o5++)
          n5.__setDigit(o5, t3.__digit(o5));
        var a5 = t3.__digit(i6);
        if (0 != e9 % 30) {
          var s5 = 32 - e9 % 30;
          a5 = a5 << s5 >>> s5;
        }
        return n5.__setDigit(i6, a5), n5.__trim();
      } }, { key: "__truncateAndSubFromPowerOfTwo", value: function(e9, t3, r2) {
        for (var n5, i6 = Math.min, o5 = 0 | (e9 + 29) / 30, a5 = new l7(o5, r2), s5 = 0, u6 = o5 - 1, c4 = 0, d6 = i6(u6, t3.length); s5 < d6; s5++)
          c4 = 1 & (n5 = 0 - t3.__digit(s5) - c4) >>> 30, a5.__setDigit(s5, 1073741823 & n5);
        for (; s5 < u6; s5++)
          a5.__setDigit(s5, 0 | 1073741823 & -c4);
        var h7, f6 = u6 < t3.length ? t3.__digit(u6) : 0, p7 = e9 % 30;
        if (0 === p7)
          h7 = 0 - f6 - c4, h7 &= 1073741823;
        else {
          var m6 = 32 - p7, y6 = 1 << 32 - m6;
          h7 = y6 - (f6 = f6 << m6 >>> m6) - c4, h7 &= y6 - 1;
        }
        return a5.__setDigit(u6, h7), a5.__trim();
      } }, { key: "__digitPow", value: function(e9, t3) {
        for (var r2 = 1; 0 < t3; )
          1 & t3 && (r2 *= e9), t3 >>>= 1, e9 *= e9;
        return r2;
      } }, { key: "__isOneDigitInt", value: function(e9) {
        return (1073741823 & e9) === e9;
      } }]), l7;
    }(h6(Array));
    return T6.__kMaxLength = 33554432, T6.__kMaxLengthBits = T6.__kMaxLength << 5, T6.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], T6.__kBitsPerCharTableShift = 5, T6.__kBitsPerCharTableMultiplier = 1 << T6.__kBitsPerCharTableShift, T6.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], T6.__kBitConversionBuffer = new ArrayBuffer(8), T6.__kBitConversionDouble = new Float64Array(T6.__kBitConversionBuffer), T6.__kBitConversionInts = new Int32Array(T6.__kBitConversionBuffer), T6.__clz30 = t ? function(e8) {
      return t(e8) - 2;
    } : function(e8) {
      var t2 = Math.LN2, r2 = Math.log;
      return 0 === e8 ? 30 : 0 | 29 - (0 | r2(e8 >>> 0) / t2);
    }, T6.__imul = e7 || function(e8, t2) {
      return 0 | e8 * t2;
    }, T6;
  }();
  var d3 = l4(c2.exports);
  var h5 = {};
  function f3(e7, t) {
    Object.defineProperty(e7.prototype, Symbol.toStringTag, { value: t, writable: false, enumerable: false, configurable: true });
    for (const t2 of Object.getOwnPropertyNames(e7)) {
      const r = Object.getOwnPropertyDescriptor(e7, t2);
      r.configurable && r.enumerable && (r.enumerable = false, Object.defineProperty(e7, t2, r));
    }
    for (const t2 of Object.getOwnPropertyNames(e7.prototype)) {
      const r = Object.getOwnPropertyDescriptor(e7.prototype, t2);
      r.configurable && r.enumerable && (r.enumerable = false, Object.defineProperty(e7.prototype, t2, r));
    }
    p4(t, e7), p4(`${t}.prototype`, e7.prototype);
  }
  function p4(e7, t) {
    const r = `%${e7}%`;
    if (void 0 !== h5[r])
      throw new Error(`intrinsic ${e7} already exists`);
    h5[r] = t;
  }
  function m4(e7) {
    return h5[e7];
  }
  var y4;
  var g3;
  var v4 = "slot-epochNanoSeconds";
  var w4 = "slot-timezone-identifier";
  var b4 = "slot-year";
  var _4 = "slot-month";
  var E2 = "slot-day";
  var T4 = "slot-hour";
  var x4 = "slot-minute";
  var I3 = "slot-second";
  var S4 = "slot-millisecond";
  var R4 = "slot-microsecond";
  var k4 = "slot-nanosecond";
  var j4 = "slot-calendar";
  var D3 = "slot-date-brand";
  var N4 = "slot-year-month-brand";
  var O2 = "slot-month-day-brand";
  var C3 = "slot-cached-instant";
  var A3 = "slot-time-zone";
  var M4 = "slot-years";
  var L3 = "slot-months";
  var P4 = "slot-weeks";
  var B4 = "slot-days";
  var $3 = "slot-hours";
  var F3 = "slot-minutes";
  var U5 = "slot-seconds";
  var q4 = "slot-milliseconds";
  var Y4 = "slot-microseconds";
  var W3 = "slot-nanoseconds";
  var z4 = "slot-calendar-identifier";
  var G6 = /* @__PURE__ */ new WeakMap();
  var H3 = Symbol.for("@@Temporal__GetSlots");
  (y4 = globalThis)[H3] || (y4[H3] = function(e7) {
    return G6.get(e7);
  });
  var J3 = globalThis[H3];
  var V4 = Symbol.for("@@Temporal__CreateSlots");
  (g3 = globalThis)[V4] || (g3[V4] = function(e7) {
    G6.set(e7, /* @__PURE__ */ Object.create(null));
  });
  var Q4 = globalThis[V4];
  function Z4(e7, ...t) {
    if (!e7 || "object" != typeof e7)
      return false;
    const r = J3(e7);
    return !!r && t.every((e8) => e8 in r);
  }
  function K3(e7, t) {
    const r = J3(e7)?.[t];
    if (void 0 === r)
      throw new TypeError(`Missing internal slot ${t}`);
    return r;
  }
  function X4(e7, t, r) {
    const n4 = J3(e7);
    if (void 0 === n4)
      throw new TypeError("Missing slots for the given container");
    if (n4[t])
      throw new TypeError(`${t} already has set`);
    n4[t] = r;
  }
  var ee = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
  var te = new RegExp("(?:" + [`(?:${ee.source})(?:\\/(?:${ee.source}))*`, "Etc/GMT(?:0|[-+]\\d{1,2})", "GMT[-+]?0", "EST5EDT", "CST6CDT", "MST7MDT", "PST8PDT", /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|") + ")");
  var re = /(?:[+\u2212-]\d{6}|\d{4})/;
  var ne = /(?:0[1-9]|1[0-2])/;
  var ie = /(?:0[1-9]|[12]\d|3[01])/;
  var oe = new RegExp(`(${re.source})(?:-(${ne.source})-(${ie.source})|(${ne.source})(${ie.source}))`);
  var ae = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
  var se = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
  var le = new RegExp(`([zZ])|${se.source}?`);
  var ue = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g;
  var ce = new RegExp([`^${oe.source}`, `(?:(?:T|\\s+)${ae.source}(?:${le.source})?)?`, `(?:\\[!?(${te.source})\\])?`, `((?:${ue.source})*)$`].join(""), "i");
  var de = new RegExp([`^T?${ae.source}`, `(?:${le.source})?`, `(?:\\[!?${te.source}\\])?`, `((?:${ue.source})*)$`].join(""), "i");
  var he = new RegExp(`^(${re.source})-?(${ne.source})(?:\\[!?${te.source}\\])?((?:${ue.source})*)$`);
  var fe = new RegExp(`^(?:--)?(${ne.source})-?(${ie.source})(?:\\[!?${te.source}\\])?((?:${ue.source})*)$`);
  var pe = /(\d+)(?:[.,](\d{1,9}))?/;
  var me = new RegExp(`(?:${pe.source}H)?(?:${pe.source}M)?(?:${pe.source}S)?`);
  var ye = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${me.source})?$`, "i");
  var ge = Array.prototype.includes;
  var ve = Array.prototype.push;
  var we = globalThis.Intl.DateTimeFormat;
  var be = Math.min;
  var _e = Math.max;
  var Ee = Math.abs;
  var Te = Math.floor;
  var xe = Math.sign;
  var Ie = Math.trunc;
  var Se = Number.isNaN;
  var Re = Number.isFinite;
  var ke = Number;
  var je = String;
  var De = Number.MAX_SAFE_INTEGER;
  var Ne = Object.create;
  var Oe = Object.getOwnPropertyDescriptor;
  var Ce = Reflect.apply;
  var Ae = Reflect.ownKeys;
  var Me = d3.BigInt(0);
  var Le = d3.BigInt(1);
  var Pe = d3.BigInt(60);
  var Be = d3.BigInt(24);
  var $e = d3.BigInt(1e3);
  var Fe = d3.BigInt(1e6);
  var Ue = d3.BigInt(1e9);
  var qe = d3.BigInt(-1);
  var Ye = d3.multiply(d3.BigInt(3600), Ue);
  var We = d3.multiply(Pe, Ue);
  var ze = d3.multiply(Ye, Be);
  var Ge = d3.multiply(d3.BigInt(-86400), d3.BigInt(1e17));
  var He = d3.multiply(d3.BigInt(86400), d3.BigInt(1e17));
  var Je = -271821;
  var Ve = 275760;
  var Qe = d3.multiply(d3.BigInt(-388152), d3.BigInt(1e13));
  var Ze = d3.multiply(ze, d3.BigInt(3660));
  var Ke = d3.multiply(ze, d3.BigInt(366));
  var Xe = d3.multiply(ze, d3.BigInt(14));
  var et3 = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
  function tt3(e7) {
    return d3.equal(e7, Me);
  }
  function rt3(e7, t) {
    const r = e7[t];
    if (void 0 !== r)
      return r;
  }
  function nt3(e7, t, r) {
    return Ce(e7, t, arguments.length > 2 ? r : []);
  }
  function it2(e7) {
    return "object" == typeof e7 && null !== e7 || "function" == typeof e7;
  }
  function ot2(e7) {
    if ("bigint" == typeof e7)
      throw new TypeError("Cannot convert BigInt to number");
    return ke(e7);
  }
  function at2(e7) {
    const t = ot2(e7);
    if (Se(t) || 0 === t)
      return 0;
    if (!Re(t))
      return t;
    const r = Te(Ee(t));
    return 0 === r ? 0 : xe(t) * r;
  }
  function st2(e7) {
    if ("number" != typeof e7 || Se(e7) || !Re(e7))
      return false;
    const t = Ee(e7);
    return Te(t) === t;
  }
  function lt2(e7) {
    if ("symbol" == typeof e7)
      throw new TypeError("Cannot convert a Symbol value to a String");
    return je(e7);
  }
  function ut(e7) {
    const t = ot2(e7);
    if (0 === t)
      return 0;
    if (Se(t) || !Re(t))
      throw new RangeError("invalid number value");
    const r = Ie(t);
    return 0 === r ? 0 : r;
  }
  function ct(e7, t) {
    const r = ut(e7);
    if (r <= 0) {
      if (void 0 !== t)
        throw new RangeError(`property '${t}' cannot be a a number less than one`);
      throw new RangeError("Cannot convert a number less than one to a positive integer");
    }
    return r;
  }
  function dt2(e7) {
    const t = ot2(e7);
    if (!Re(t))
      throw new RangeError("infinity is out of range");
    if (!st2(t))
      throw new RangeError(`unsupported fractional value ${e7}`);
    return 0 === t ? 0 : t;
  }
  function ht2(e7, t) {
    return { quotient: d3.divide(e7, t), remainder: d3.remainder(e7, t) };
  }
  function ft(e7) {
    return d3.lessThan(e7, Me);
  }
  function pt2(e7) {
    return tt3(e7) ? 0 : ft(e7) ? -1 : 1;
  }
  function mt2(e7) {
    return d3.lessThan(e7, Me) ? d3.multiply(e7, qe) : e7;
  }
  var yt2 = /* @__PURE__ */ new Map([["year", ut], ["month", ct], ["monthCode", lt2], ["day", ct], ["hour", ut], ["minute", ut], ["second", ut], ["millisecond", ut], ["microsecond", ut], ["nanosecond", ut], ["years", dt2], ["months", dt2], ["weeks", dt2], ["days", dt2], ["hours", dt2], ["minutes", dt2], ["seconds", dt2], ["milliseconds", dt2], ["microseconds", dt2], ["nanoseconds", dt2], ["era", lt2], ["eraYear", at2], ["offset", lt2]]);
  var gt = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
  var vt2 = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
  var wt2 = new Map(vt2.map((e7) => [e7[0], e7[1]]));
  var bt = new Map(vt2.map(([e7, t]) => [t, e7]));
  var _t2 = vt2.map(([, e7]) => e7);
  var Et2 = Array.from(wt2.keys()).sort();
  var Tt = /* @__PURE__ */ new Map();
  function xt(e7) {
    let t = Tt.get(e7);
    return void 0 === t && (t = new we("en-us", { timeZone: je(e7), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), Tt.set(e7, t)), t;
  }
  function It2(e7) {
    if (null == e7)
      throw new TypeError(`Expected object not ${e7}`);
    return Object(e7);
  }
  function St2(e7, t, r, n4) {
    if (null == t)
      return;
    const i4 = Ae(t);
    for (const o4 of i4)
      if (!r.some((e8) => Object.is(e8, o4)) && Object.prototype.propertyIsEnumerable.call(t, o4)) {
        const r2 = t[o4];
        if (n4 && n4.some((e8) => Object.is(e8, r2)))
          continue;
        e7[o4] = r2;
      }
  }
  function Rt(e7) {
    return Z4(e7, v4) && !Z4(e7, A3, j4);
  }
  function kt2(e7) {
    return Z4(e7, w4);
  }
  function jt(e7) {
    return Z4(e7, z4);
  }
  function Dt(e7) {
    return Z4(e7, M4, L3, B4, $3, F3, U5, q4, Y4, W3);
  }
  function Nt2(e7) {
    return Z4(e7, D3);
  }
  function Ot2(e7) {
    return Z4(e7, T4, x4, I3, S4, R4, k4) && !Z4(e7, b4, _4, E2);
  }
  function Ct(e7) {
    return Z4(e7, b4, _4, E2, T4, x4, I3, S4, R4, k4);
  }
  function At(e7) {
    return Z4(e7, N4);
  }
  function Mt2(e7) {
    return Z4(e7, O2);
  }
  function Lt2(e7) {
    return Z4(e7, v4, A3, j4);
  }
  function Pt2(e7) {
    if (Z4(e7, j4) || Z4(e7, A3))
      throw new TypeError("with() does not support a calendar or timeZone property");
    if (Ot2(e7))
      throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
    if (void 0 !== e7.calendar)
      throw new TypeError("with() does not support a calendar property");
    if (void 0 !== e7.timeZone)
      throw new TypeError("with() does not support a timeZone property");
  }
  function Bt2(e7, t) {
    return "never" === t ? "" : $t2(Vr(e7), t);
  }
  function $t2(e7, t) {
    return "never" === t || "auto" === t && "iso8601" === e7 ? "" : `[${"critical" === t ? "!" : ""}u-ca=${e7}]`;
  }
  function Ft(e7) {
    const t = ce.exec(e7);
    if (!t)
      throw new RangeError(`invalid ISO 8601 string: ${e7}`);
    let r = t[1];
    if ("\u2212" === r[0] && (r = `-${r.slice(1)}`), "-000000" === r)
      throw new RangeError(`invalid ISO 8601 string: ${e7}`);
    const n4 = at2(r), i4 = at2(t[2] || t[4]), o4 = at2(t[3] || t[5]), a4 = at2(t[6]), s3 = void 0 !== t[6], l6 = at2(t[7] || t[10]);
    let u4 = at2(t[8] || t[11]);
    60 === u4 && (u4 = 59);
    const c3 = (t[9] || t[12]) + "000000000", d5 = at2(c3.slice(0, 3)), h6 = at2(c3.slice(3, 6)), f5 = at2(c3.slice(6, 9));
    let p6, m5 = false;
    if (t[13])
      p6 = void 0, m5 = true;
    else if (t[14] && t[15]) {
      const e8 = "-" === t[14] || "\u2212" === t[14] ? "-" : "+", r2 = t[15] || "00", n5 = t[16] || "00", i5 = t[17] || "00";
      let o5 = t[18] || "0";
      if (p6 = `${e8}${r2}:${n5}`, +o5) {
        for (; o5.endsWith("0"); )
          o5 = o5.slice(0, -1);
        p6 += `:${i5}.${o5}`;
      } else
        +i5 && (p6 += `:${i5}`);
      "-00:00" === p6 && (p6 = "+00:00");
    }
    const y5 = t[19], g5 = t[20];
    let v6;
    for (const [, e8, t2, r2] of g5.matchAll(ue))
      if ("u-ca" === t2)
        void 0 === v6 && (v6 = r2);
      else if ("!" === e8)
        throw new RangeError(`Unrecognized annotation: !${t2}=${r2}`);
    return li(n4, i4, o4, a4, l6, u4, d5, h6, f5), { year: n4, month: i4, day: o4, hasTime: s3, hour: a4, minute: l6, second: u4, millisecond: d5, microsecond: h6, nanosecond: f5, ianaName: y5, offset: p6, z: m5, calendar: v6 };
  }
  function Ut2(e7) {
    const t = he.exec(e7);
    let r, n4, i4, o4;
    if (t) {
      let o5 = t[1];
      if ("\u2212" === o5[0] && (o5 = `-${o5.slice(1)}`), "-000000" === o5)
        throw new RangeError(`invalid ISO 8601 string: ${e7}`);
      r = at2(o5), n4 = at2(t[2]);
      const a4 = t[3];
      for (const [, e8, t2, r2] of a4.matchAll(ue))
        if ("u-ca" === t2)
          void 0 === i4 && (i4 = r2);
        else if ("!" === e8)
          throw new RangeError(`Unrecognized annotation: !${t2}=${r2}`);
      if (void 0 !== i4 && "iso8601" !== i4)
        throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
    } else {
      let t2;
      if ({ year: r, month: n4, calendar: i4, day: o4, z: t2 } = Ft(e7), t2)
        throw new RangeError("Z designator not supported for PlainYearMonth");
    }
    return { year: r, month: n4, calendar: i4, referenceISODay: o4 };
  }
  function qt(e7) {
    const t = fe.exec(e7);
    let r, n4, i4, o4;
    if (t) {
      r = at2(t[1]), n4 = at2(t[2]);
      const e8 = t[3];
      for (const [, t2, r2, n5] of e8.matchAll(ue))
        if ("u-ca" === r2)
          void 0 === i4 && (i4 = n5);
        else if ("!" === t2)
          throw new RangeError(`Unrecognized annotation: !${r2}=${n5}`);
      if (void 0 !== i4 && "iso8601" !== i4)
        throw new RangeError("MM-DD format is only valid with iso8601 calendar");
    } else {
      let t2;
      if ({ month: r, day: n4, calendar: i4, year: o4, z: t2 } = Ft(e7), t2)
        throw new RangeError("Z designator not supported for PlainMonthDay");
    }
    return { month: r, day: n4, calendar: i4, referenceISOYear: o4 };
  }
  function Yt(e7, t, r, n4) {
    let i4 = e7, o4 = t, a4 = r;
    switch (n4) {
      case "reject":
        oi(i4, o4, a4);
        break;
      case "constrain":
        ({ year: i4, month: o4, day: a4 } = ni(i4, o4, a4));
    }
    return { year: i4, month: o4, day: a4 };
  }
  function Wt2(e7, t, r, n4, i4, o4, a4) {
    let s3 = e7, l6 = t, u4 = r, c3 = n4, d5 = i4, h6 = o4;
    switch (a4) {
      case "reject":
        si(s3, l6, u4, c3, d5, h6);
        break;
      case "constrain":
        ({ hour: s3, minute: l6, second: u4, millisecond: c3, microsecond: d5, nanosecond: h6 } = function(e8, t2, r2, n5, i5, o5) {
          return { hour: ri(e8, 0, 23), minute: ri(t2, 0, 59), second: ri(r2, 0, 59), millisecond: ri(n5, 0, 999), microsecond: ri(i5, 0, 999), nanosecond: ri(o5, 0, 999) };
        }(s3, l6, u4, c3, d5, h6));
    }
    return { hour: s3, minute: l6, second: u4, millisecond: c3, microsecond: d5, nanosecond: h6 };
  }
  function zt(e7) {
    if (!it2(e7))
      return function(e8) {
        const t2 = ye.exec(e8);
        if (!t2)
          throw new RangeError(`invalid duration: ${e8}`);
        if (t2.slice(2).every((e9) => void 0 === e9))
          throw new RangeError(`invalid duration: ${e8}`);
        const r2 = "-" === t2[1] || "\u2212" === t2[1] ? -1 : 1, n5 = void 0 === t2[2] ? 0 : ut(t2[2]) * r2, i5 = void 0 === t2[3] ? 0 : ut(t2[3]) * r2, o5 = void 0 === t2[4] ? 0 : ut(t2[4]) * r2, a5 = void 0 === t2[5] ? 0 : ut(t2[5]) * r2, s4 = void 0 === t2[6] ? 0 : ut(t2[6]) * r2, l7 = t2[7], u5 = t2[8], c4 = t2[9], d6 = t2[10], h7 = t2[11];
        let f5 = 0, p6 = 0, m5 = 0;
        if (void 0 !== l7) {
          if (u5 ?? c4 ?? d6 ?? h7)
            throw new RangeError("only the smallest unit can be fractional");
          m5 = 3600 * at2((l7 + "000000000").slice(0, 9)) * r2;
        } else if (f5 = void 0 === u5 ? 0 : ut(u5) * r2, void 0 !== c4) {
          if (d6 ?? h7)
            throw new RangeError("only the smallest unit can be fractional");
          m5 = 60 * at2((c4 + "000000000").slice(0, 9)) * r2;
        } else
          p6 = void 0 === d6 ? 0 : ut(d6) * r2, void 0 !== h7 && (m5 = at2((h7 + "000000000").slice(0, 9)) * r2);
        const y5 = m5 % 1e3, g5 = Ie(m5 / 1e3) % 1e3, v6 = Ie(m5 / 1e6) % 1e3;
        return p6 += Ie(m5 / 1e9) % 60, f5 += Ie(m5 / 6e10), di(n5, i5, o5, a5, s4, f5, p6, v6, g5, y5), { years: n5, months: i5, weeks: o5, days: a5, hours: s4, minutes: f5, seconds: p6, milliseconds: v6, microseconds: g5, nanoseconds: y5 };
      }(lt2(e7));
    if (Dt(e7))
      return { years: K3(e7, M4), months: K3(e7, L3), weeks: K3(e7, P4), days: K3(e7, B4), hours: K3(e7, $3), minutes: K3(e7, F3), seconds: K3(e7, U5), milliseconds: K3(e7, q4), microseconds: K3(e7, Y4), nanoseconds: K3(e7, W3) };
    const t = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
    let r = function(e8) {
      if (!it2(e8))
        throw new TypeError("invalid duration-like");
      const t2 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
      let r2 = false;
      for (const n5 of Et2) {
        const i5 = e8[n5];
        void 0 !== i5 && (r2 = true, t2[n5] = dt2(i5));
      }
      if (!r2)
        throw new TypeError("invalid duration-like");
      return t2;
    }(e7);
    for (const e8 of Et2) {
      const n5 = r[e8];
      void 0 !== n5 && (t[e8] = n5);
    }
    let { years: n4, months: i4, weeks: o4, days: a4, hours: s3, minutes: l6, seconds: u4, milliseconds: c3, microseconds: d5, nanoseconds: h6 } = t;
    return di(n4, i4, o4, a4, s3, l6, u4, c3, d5, h6), { years: n4, months: i4, weeks: o4, days: a4, hours: s3, minutes: l6, seconds: u4, milliseconds: c3, microseconds: d5, nanoseconds: h6 };
  }
  function Gt(e7) {
    return void 0 === e7 ? "constrain" : no(e7, "overflow", ["constrain", "reject"], "constrain");
  }
  function Ht(e7) {
    return void 0 === e7 ? "compatible" : no(e7, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
  }
  function Jt2(e7, t) {
    return no(e7, "roundingMode", ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"], t);
  }
  function Vt(e7, t) {
    return void 0 === e7 ? t : no(e7, "offset", ["prefer", "use", "ignore", "reject"], t);
  }
  function Qt(e7) {
    return no(e7, "calendarName", ["auto", "always", "never", "critical"], "auto");
  }
  function Zt(e7) {
    let t = e7.roundingIncrement;
    if (void 0 === t)
      return 1;
    if (t = ot2(t), !Re(t))
      throw new RangeError("roundingIncrement must be finite");
    const r = Ie(t);
    if (r < 1 || r > 1e9)
      throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t}`);
    return r;
  }
  function Kt2(e7, t, r) {
    const n4 = r ? t : t - 1;
    if (e7 > n4)
      throw new RangeError(`roundingIncrement must be at least 1 and less than ${n4}, not ${e7}`);
    if (t % e7 != 0)
      throw new RangeError(`Rounding increment must divide evenly into ${t}`);
  }
  function Xt(e7) {
    const t = e7.fractionalSecondDigits;
    if (void 0 === t)
      return "auto";
    if ("number" != typeof t) {
      if ("auto" !== lt2(t))
        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`);
      return "auto";
    }
    const r = Te(t);
    if (!Re(r) || r < 0 || r > 9)
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`);
    return r;
  }
  function er(e7, t) {
    switch (e7) {
      case "minute":
        return { precision: "minute", unit: "minute", increment: 1 };
      case "second":
        return { precision: 0, unit: "second", increment: 1 };
      case "millisecond":
        return { precision: 3, unit: "millisecond", increment: 1 };
      case "microsecond":
        return { precision: 6, unit: "microsecond", increment: 1 };
      case "nanosecond":
        return { precision: 9, unit: "nanosecond", increment: 1 };
    }
    switch (t) {
      case "auto":
        return { precision: t, unit: "nanosecond", increment: 1 };
      case 0:
        return { precision: t, unit: "second", increment: 1 };
      case 1:
      case 2:
      case 3:
        return { precision: t, unit: "millisecond", increment: 10 ** (3 - t) };
      case 4:
      case 5:
      case 6:
        return { precision: t, unit: "microsecond", increment: 10 ** (6 - t) };
      case 7:
      case 8:
      case 9:
        return { precision: t, unit: "nanosecond", increment: 10 ** (9 - t) };
      default:
        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t}`);
    }
  }
  var tr = Symbol("~required~");
  function rr(e7, t, r, n4, i4 = []) {
    const o4 = [];
    for (const [, e8, t2] of vt2)
      "datetime" !== r && r !== t2 || o4.push(e8);
    o4.push(...i4);
    let a4 = n4;
    a4 === tr ? a4 = void 0 : void 0 !== a4 && o4.push(a4);
    const s3 = [...o4];
    for (const e8 of o4) {
      const t2 = bt.get(e8);
      void 0 !== t2 && s3.push(t2);
    }
    let l6 = no(e7, t, s3, a4);
    if (void 0 === l6 && n4 === tr)
      throw new RangeError(`${t} is required`);
    return wt2.has(l6) ? wt2.get(l6) : l6;
  }
  function nr(e7) {
    const t = e7.relativeTo;
    if (void 0 === t)
      return t;
    let r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6, f5, p6 = "option", m5 = false;
    if (it2(t)) {
      if (Lt2(t) || Nt2(t))
        return t;
      if (Ct(t))
        return ln(t);
      d5 = Jr(t);
      const e8 = kr(d5, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
      e8.push("timeZone", "offset");
      const m6 = ar(t, e8, []), y5 = Ne(null);
      y5.overflow = "constrain", { year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = ur(d5, m6, y5), f5 = m6.offset, void 0 === f5 && (p6 = "wall"), h6 = m6.timeZone, void 0 !== h6 && (h6 = nn(h6));
    } else {
      let e8, y5;
      if ({ year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3, calendar: d5, ianaName: e8, offset: f5, z: y5 } = Ft(lt2(t)), e8)
        h6 = nn(e8), y5 ? p6 = "exact" : f5 || (p6 = "wall"), m5 = true;
      else if (y5)
        throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
      if (d5 || (d5 = "iso8601"), !io(d5))
        throw new RangeError(`invalid calendar identifier ${d5}`);
      d5 = oo(d5);
    }
    return void 0 === h6 ? wr(r, n4, i4, d5) : Rr(yr(r, n4, i4, o4, a4, s3, l6, u4, c3, p6, "option" === p6 ? Rn(f5) : 0, h6, "compatible", "reject", m5), h6, d5);
  }
  function ir(e7, t, r, n4, i4, o4, a4, s3, l6, u4) {
    for (const [c3, d5] of [["years", e7], ["months", t], ["weeks", r], ["days", n4], ["hours", i4], ["minutes", o4], ["seconds", a4], ["milliseconds", s3], ["microseconds", l6], ["nanoseconds", u4]])
      if (0 !== d5)
        return wt2.get(c3);
    return "nanosecond";
  }
  function or(e7, t) {
    return _t2.indexOf(e7) > _t2.indexOf(t) ? t : e7;
  }
  function ar(e7, t, r, { emptySourceErrorMessage: n4 } = { emptySourceErrorMessage: "no supported properties found" }) {
    const i4 = Ne(null);
    let o4 = false;
    t.sort();
    for (const n5 of t) {
      let t2 = e7[n5];
      if (void 0 !== t2)
        o4 = true, yt2.has(n5) && (t2 = yt2.get(n5)(t2)), i4[n5] = t2;
      else if ("partial" !== r) {
        if (ge.call(r, n5))
          throw new TypeError(`required property '${n5}' missing or undefined`);
        t2 = gt.get(n5), i4[n5] = t2;
      }
    }
    if ("partial" === r && !o4)
      throw new TypeError(n4);
    return i4;
  }
  function sr(e7, t = "complete") {
    const r = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], n4 = ar(e7, r, "partial", { emptySourceErrorMessage: "invalid time-like" }), i4 = {};
    for (const e8 of r) {
      const r2 = Oe(n4, e8);
      void 0 !== r2 ? i4[e8] = r2.value : "complete" === t && (i4[e8] = 0);
    }
    return i4;
  }
  function lr(e7, t) {
    let r = e7;
    if (it2(r)) {
      if (Nt2(r))
        return r;
      if (Lt2(r) && (Gt(t), r = hn(K3(r, A3), K3(r, C3), K3(r, j4))), Ct(r))
        return Gt(t), wr(K3(r, b4), K3(r, _4), K3(r, E2), K3(r, j4));
      const e8 = Jr(r);
      return en(e8, ar(r, kr(e8, ["day", "month", "monthCode", "year"]), []), t);
    }
    Gt(t);
    let { year: n4, month: i4, day: o4, calendar: a4, z: s3 } = function(e8) {
      return Ft(e8);
    }(lt2(r));
    if (s3)
      throw new RangeError("Z designator not supported for PlainDate");
    if (a4 || (a4 = "iso8601"), !io(a4))
      throw new RangeError(`invalid calendar identifier ${a4}`);
    return a4 = oo(a4), wr(n4, i4, o4, a4);
  }
  function ur(e7, t, r) {
    let { hour: n4, minute: i4, second: o4, millisecond: a4, microsecond: s3, nanosecond: l6 } = sr(t);
    const u4 = Gt(r), c3 = en(e7, t, r), d5 = K3(c3, b4), h6 = K3(c3, _4), f5 = K3(c3, E2);
    return { hour: n4, minute: i4, second: o4, millisecond: a4, microsecond: s3, nanosecond: l6 } = Wt2(n4, i4, o4, a4, s3, l6, u4), { year: d5, month: h6, day: f5, hour: n4, minute: i4, second: o4, millisecond: a4, microsecond: s3, nanosecond: l6 };
  }
  function cr(e7, t) {
    let r, n4, i4, o4, a4, s3, l6, u4, c3, d5;
    if (it2(e7)) {
      if (Ct(e7))
        return e7;
      if (Lt2(e7))
        return Gt(t), hn(K3(e7, A3), K3(e7, C3), K3(e7, j4));
      if (Nt2(e7))
        return Gt(t), _r(K3(e7, b4), K3(e7, _4), K3(e7, E2), 0, 0, 0, 0, 0, 0, K3(e7, j4));
      d5 = Jr(e7);
      const h6 = ar(e7, kr(d5, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
      ({ year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = ur(d5, h6, t));
    } else {
      let h6;
      if (Gt(t), { year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3, calendar: d5, z: h6 } = function(e8) {
        return Ft(e8);
      }(lt2(e7)), h6)
        throw new RangeError("Z designator not supported for PlainDateTime");
      if (li(r, n4, i4, o4, a4, s3, l6, u4, c3), d5 || (d5 = "iso8601"), !io(d5))
        throw new RangeError(`invalid calendar identifier ${d5}`);
      d5 = oo(d5);
    }
    return _r(r, n4, i4, o4, a4, s3, l6, u4, c3, d5);
  }
  function dr(e7) {
    if (Dt(e7))
      return e7;
    let { years: t, months: r, weeks: n4, days: i4, hours: o4, minutes: a4, seconds: s3, milliseconds: l6, microseconds: u4, nanoseconds: c3 } = zt(e7);
    return new (m4("%Temporal.Duration%"))(t, r, n4, i4, o4, a4, s3, l6, u4, c3);
  }
  function hr(e7) {
    if (Rt(e7))
      return e7;
    if (Lt2(e7))
      return new (m4("%Temporal.Instant%"))(K3(e7, v4));
    const t = function(e8) {
      let { year: t2, month: r, day: n4, hour: i4, minute: o4, second: a4, millisecond: s3, microsecond: l6, nanosecond: u4, offset: c3, z: d5 } = function(e9) {
        const t3 = Ft(e9);
        if (!t3.z && !t3.offset)
          throw new RangeError("Temporal.Instant requires a time zone offset");
        return t3;
      }(e8);
      if (!d5 && !c3)
        throw new RangeError("Temporal.Instant requires a time zone offset");
      const h6 = d5 ? 0 : Rn(c3);
      ({ year: t2, month: r, day: n4, hour: i4, minute: o4, second: a4, millisecond: s3, microsecond: l6, nanosecond: u4 } = Hn(t2, r, n4, i4, o4, a4, s3, l6, u4 - h6));
      const f5 = On(t2, r, n4, i4, o4, a4, s3, l6, u4);
      if (null === f5)
        throw new RangeError("DateTime outside of supported range");
      return f5;
    }(lt2(e7));
    return new (m4("%Temporal.Instant%"))(t);
  }
  function fr(e7, t) {
    let r = e7;
    if (it2(r)) {
      if (Mt2(r))
        return r;
      let e8, n5;
      if (Z4(r, j4))
        e8 = K3(r, j4), n5 = false;
      else {
        let t2 = r.calendar;
        n5 = void 0 === t2, void 0 === t2 && (t2 = "iso8601"), e8 = Hr(t2);
      }
      const i5 = ar(r, kr(e8, ["day", "month", "monthCode", "year"]), []);
      return n5 && void 0 !== i5.month && void 0 === i5.monthCode && void 0 === i5.year && (i5.year = 1972), rn(e8, i5, t);
    }
    Gt(t);
    let { month: n4, day: i4, referenceISOYear: o4, calendar: a4 } = qt(lt2(r));
    if (void 0 === a4 && (a4 = "iso8601"), !io(a4))
      throw new RangeError(`invalid calendar identifier ${a4}`);
    return a4 = oo(a4), void 0 === o4 ? (oi(1972, n4, i4), Tr(n4, i4, a4)) : rn(a4, Tr(n4, i4, a4, o4));
  }
  function pr(e7, t = "constrain") {
    let r, n4, i4, o4, a4, s3, l6 = e7;
    if (it2(l6)) {
      if (Ot2(l6))
        return l6;
      if (Lt2(l6) && (l6 = hn(K3(l6, A3), K3(l6, C3), K3(l6, j4))), Ct(l6))
        return new (m4("%Temporal.PlainTime%"))(K3(l6, T4), K3(l6, x4), K3(l6, I3), K3(l6, S4), K3(l6, R4), K3(l6, k4));
      ({ hour: r, minute: n4, second: i4, millisecond: o4, microsecond: a4, nanosecond: s3 } = sr(l6)), { hour: r, minute: n4, second: i4, millisecond: o4, microsecond: a4, nanosecond: s3 } = Wt2(r, n4, i4, o4, a4, s3, t);
    } else
      ({ hour: r, minute: n4, second: i4, millisecond: o4, microsecond: a4, nanosecond: s3 } = function(e8) {
        const t2 = de.exec(e8);
        let r2, n5, i5, o5, a5, s4, l7;
        if (t2) {
          r2 = at2(t2[1]), n5 = at2(t2[2] || t2[5]), i5 = at2(t2[3] || t2[6]), 60 === i5 && (i5 = 59);
          const e9 = (t2[4] || t2[7]) + "000000000";
          o5 = at2(e9.slice(0, 3)), a5 = at2(e9.slice(3, 6)), s4 = at2(e9.slice(6, 9)), l7 = t2[14];
          for (const [, e10, t3, r3] of l7.matchAll(ue))
            if ("u-ca" !== t3 && "!" === e10)
              throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
          if (t2[8])
            throw new RangeError("Z designator not supported for PlainTime");
        } else {
          let t3, l8;
          if ({ hasTime: l8, hour: r2, minute: n5, second: i5, millisecond: o5, microsecond: a5, nanosecond: s4, z: t3 } = Ft(e8), !l8)
            throw new RangeError(`time is missing in string: ${e8}`);
          if (t3)
            throw new RangeError("Z designator not supported for PlainTime");
        }
        if (/[tT ][0-9][0-9]/.test(e8))
          return { hour: r2, minute: n5, second: i5, millisecond: o5, microsecond: a5, nanosecond: s4 };
        try {
          const { month: t3, day: r3 } = qt(e8);
          oi(1972, t3, r3);
        } catch {
          try {
            const { year: t3, month: r3 } = Ut2(e8);
            oi(t3, r3, 1);
          } catch {
            return { hour: r2, minute: n5, second: i5, millisecond: o5, microsecond: a5, nanosecond: s4 };
          }
        }
        throw new RangeError(`invalid ISO 8601 time-only string ${e8}; may need a T prefix`);
      }(lt2(l6))), si(r, n4, i4, o4, a4, s3);
    return new (m4("%Temporal.PlainTime%"))(r, n4, i4, o4, a4, s3);
  }
  function mr(e7, t) {
    if (it2(e7)) {
      if (At(e7))
        return e7;
      const r2 = Jr(e7);
      return tn(r2, ar(e7, kr(r2, ["month", "monthCode", "year"]), []), t);
    }
    Gt(t);
    let { year: r, month: n4, referenceISODay: i4, calendar: o4 } = Ut2(lt2(e7));
    if (void 0 === o4 && (o4 = "iso8601"), !io(o4))
      throw new RangeError(`invalid calendar identifier ${o4}`);
    return o4 = oo(o4), void 0 === i4 ? (oi(r, n4, 1), Ir(r, n4, o4)) : tn(o4, Ir(r, n4, o4, i4));
  }
  function yr(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, h6, f5, p6, y5) {
    const g5 = new (m4("%Temporal.PlainDateTime%"))(e7, t, r, n4, i4, o4, a4, s3, l6);
    if ("wall" === u4 || "ignore" === p6)
      return K3(fn(h6, g5, f5), v4);
    if ("exact" === u4 || "use" === p6) {
      const u5 = On(e7, t, r, n4, i4, o4, a4, s3, l6);
      if (null === u5)
        throw new RangeError("ZonedDateTime outside of supported range");
      return d3.subtract(u5, d3.BigInt(c3));
    }
    const b7 = mn(h6, g5);
    for (const e8 of b7) {
      const t2 = cn(h6, e8), r2 = d3.toNumber(Li(d3.BigInt(t2), We, "halfExpand"));
      if (t2 === c3 || y5 && r2 === c3)
        return K3(e8, v4);
    }
    if ("reject" === p6) {
      const e8 = Dn(c3), t2 = kt2(h6) ? K3(h6, w4) : "time zone";
      throw new RangeError(`Offset ${e8} is invalid for ${g5.toString()} in ${t2}`);
    }
    return K3(pn(b7, h6, g5, f5), v4);
  }
  function gr(e7, t) {
    let r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6, f5, p6, m5, y5 = false, g5 = "option";
    if (it2(e7)) {
      if (Lt2(e7))
        return e7;
      f5 = Jr(e7);
      const y6 = kr(f5, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
      y6.push("timeZone", "offset");
      const v7 = ar(e7, y6, ["timeZone"]);
      d5 = nn(v7.timeZone), h6 = v7.offset, void 0 === h6 && (g5 = "wall"), p6 = Ht(t), m5 = Vt(t, "reject"), { year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = ur(f5, v7, t);
    } else {
      let v7, w5;
      if ({ year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3, ianaName: v7, offset: h6, z: w5, calendar: f5 } = function(e8) {
        const t2 = Ft(e8);
        if (!t2.ianaName)
          throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
        return t2;
      }(lt2(e7)), d5 = nn(v7), w5 ? g5 = "exact" : h6 || (g5 = "wall"), f5 || (f5 = "iso8601"), !io(f5))
        throw new RangeError(`invalid calendar identifier ${f5}`);
      f5 = oo(f5), y5 = true, p6 = Ht(t), m5 = Vt(t, "reject"), Gt(t);
    }
    let v6 = 0;
    return "option" === g5 && (v6 = Rn(h6)), Rr(yr(r, n4, i4, o4, a4, s3, l6, u4, c3, g5, v6, d5, p6, m5, y5), d5, f5);
  }
  function vr(e7, t, r, n4, i4) {
    oi(t, r, n4), ai(t, r, n4), Q4(e7), X4(e7, b4, t), X4(e7, _4, r), X4(e7, E2, n4), X4(e7, j4, i4), X4(e7, D3, true);
  }
  function wr(e7, t, r, n4 = "iso8601") {
    const i4 = m4("%Temporal.PlainDate%"), o4 = Ne(i4.prototype);
    return vr(o4, e7, t, r, n4), o4;
  }
  function br(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3) {
    li(t, r, n4, i4, o4, a4, s3, l6, u4), ui(t, r, n4, i4, o4, a4, s3, l6, u4), Q4(e7), X4(e7, b4, t), X4(e7, _4, r), X4(e7, E2, n4), X4(e7, T4, i4), X4(e7, x4, o4), X4(e7, I3, a4), X4(e7, S4, s3), X4(e7, R4, l6), X4(e7, k4, u4), X4(e7, j4, c3);
  }
  function _r(e7, t, r, n4, i4, o4, a4, s3, l6, u4 = "iso8601") {
    const c3 = m4("%Temporal.PlainDateTime%"), d5 = Ne(c3.prototype);
    return br(d5, e7, t, r, n4, i4, o4, a4, s3, l6, u4), d5;
  }
  function Er(e7, t, r, n4, i4) {
    oi(i4, t, r), ai(i4, t, r), Q4(e7), X4(e7, _4, t), X4(e7, E2, r), X4(e7, b4, i4), X4(e7, j4, n4), X4(e7, O2, true);
  }
  function Tr(e7, t, r = "iso8601", n4 = 1972) {
    const i4 = m4("%Temporal.PlainMonthDay%"), o4 = Ne(i4.prototype);
    return Er(o4, e7, t, r, n4), o4;
  }
  function xr(e7, t, r, n4, i4) {
    oi(t, r, i4), function(e8, t2) {
      ii(e8, Je, Ve), e8 === Je ? ii(t2, 4, 12) : e8 === Ve && ii(t2, 1, 9);
    }(t, r), Q4(e7), X4(e7, b4, t), X4(e7, _4, r), X4(e7, E2, i4), X4(e7, j4, n4), X4(e7, N4, true);
  }
  function Ir(e7, t, r = "iso8601", n4 = 1) {
    const i4 = m4("%Temporal.PlainYearMonth%"), o4 = Ne(i4.prototype);
    return xr(o4, e7, t, r, n4), o4;
  }
  function Sr(e7, t, r, n4) {
    ci(t), Q4(e7), X4(e7, v4, t), X4(e7, A3, r), X4(e7, j4, n4);
    const i4 = new (m4("%Temporal.Instant%"))(K3(e7, v4));
    X4(e7, C3, i4);
  }
  function Rr(e7, t, r = "iso8601") {
    const n4 = m4("%Temporal.ZonedDateTime%"), i4 = Ne(n4.prototype);
    return Sr(i4, e7, t, r), i4;
  }
  function kr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.fields%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "fields"), e7, [t]), n4 = [];
    for (const e8 of r) {
      if ("string" != typeof e8)
        throw new TypeError("bad return from calendar.fields()");
      ve.call(n4, e8);
    }
    return n4;
  }
  function jr(e7, t, r) {
    if ("string" == typeof e7) {
      const n5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.mergeFields%"), n5, [t, r]);
    }
    const n4 = nt3(rt3(e7, "mergeFields"), e7, [t, r]);
    if (!it2(n4))
      throw new TypeError("bad return from calendar.mergeFields()");
    return n4;
  }
  function Dr(e7, t, r, n4, i4) {
    let o4 = i4;
    if ("string" == typeof e7) {
      const i5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.dateAdd%"), i5, [t, r, n4]);
    }
    void 0 === o4 && (o4 = rt3(e7, "dateAdd"));
    const a4 = Ce(o4, e7, [t, r, n4]);
    if (!Nt2(a4))
      throw new TypeError("invalid result");
    return a4;
  }
  function Nr(e7, t, r, n4, i4) {
    let o4 = i4;
    if ("string" == typeof e7) {
      const i5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.dateUntil%"), i5, [t, r, n4]);
    }
    void 0 === o4 && (o4 = rt3(e7, "dateUntil"));
    const a4 = Ce(o4, e7, [t, r, n4]);
    if (!Dt(a4))
      throw new TypeError("invalid result");
    return a4;
  }
  function Or(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.year%"), r2, [t]);
    }
    let r = nt3(rt3(e7, "year"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar year result must be an integer");
    if (!st2(r))
      throw new RangeError("calendar year result must be an integer");
    return r;
  }
  function Cr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.month%"), r2, [t]);
    }
    let r = nt3(rt3(e7, "month"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar month result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar month result must be a positive integer");
    return r;
  }
  function Ar(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.monthCode%"), r2, [t]);
    }
    let r = nt3(rt3(e7, "monthCode"), e7, [t]);
    if ("string" != typeof r)
      throw new TypeError("calendar monthCode result must be a string");
    return r;
  }
  function Mr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.day%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "day"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar day result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar day result must be a positive integer");
    return r;
  }
  function Lr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.era%"), r2, [t]);
    }
    let r = nt3(rt3(e7, "era"), e7, [t]);
    if (void 0 === r)
      return r;
    if ("string" != typeof r)
      throw new TypeError("calendar era result must be a string or undefined");
    return r;
  }
  function Pr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.eraYear%"), r2, [t]);
    }
    let r = nt3(rt3(e7, "eraYear"), e7, [t]);
    if (void 0 === r)
      return r;
    if ("number" != typeof r)
      throw new TypeError("calendar eraYear result must be an integer or undefined");
    if (!st2(r))
      throw new RangeError("calendar eraYear result must be an integer or undefined");
    return r;
  }
  function Br(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.dayOfWeek%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "dayOfWeek"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar dayOfWeek result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar dayOfWeek result must be a positive integer");
    return r;
  }
  function $r(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.dayOfYear%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "dayOfYear"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar dayOfYear result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar dayOfYear result must be a positive integer");
    return r;
  }
  function Fr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.weekOfYear%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "weekOfYear"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar weekOfYear result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar weekOfYear result must be a positive integer");
    return r;
  }
  function Ur(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.yearOfWeek%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "yearOfWeek"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar yearOfWeek result must be an integer");
    if (!st2(r))
      throw new RangeError("calendar yearOfWeek result must be an integer");
    return r;
  }
  function qr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.daysInWeek%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "daysInWeek"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar daysInWeek result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar daysInWeek result must be a positive integer");
    return r;
  }
  function Yr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.daysInMonth%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "daysInMonth"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar daysInMonth result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar daysInMonth result must be a positive integer");
    return r;
  }
  function Wr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.daysInYear%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "daysInYear"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar daysInYear result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar daysInYear result must be a positive integer");
    return r;
  }
  function zr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.monthsInYear%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "monthsInYear"), e7, [t]);
    if ("number" != typeof r)
      throw new TypeError("calendar monthsInYear result must be a positive integer");
    if (!st2(r) || r < 1)
      throw new RangeError("calendar monthsInYear result must be a positive integer");
    return r;
  }
  function Gr(e7, t) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.inLeapYear%"), r2, [t]);
    }
    const r = nt3(rt3(e7, "inLeapYear"), e7, [t]);
    if ("boolean" != typeof r)
      throw new TypeError("calendar inLeapYear result must be a boolean");
    return r;
  }
  function Hr(e7) {
    if (it2(e7)) {
      if (Z4(e7, j4))
        return K3(e7, j4);
      if (!function(e8) {
        return !!jt(e8) || "dateAdd" in e8 && "dateFromFields" in e8 && "dateUntil" in e8 && "day" in e8 && "dayOfWeek" in e8 && "dayOfYear" in e8 && "daysInMonth" in e8 && "daysInWeek" in e8 && "daysInYear" in e8 && "fields" in e8 && "id" in e8 && "inLeapYear" in e8 && "mergeFields" in e8 && "month" in e8 && "monthCode" in e8 && "monthDayFromFields" in e8 && "monthsInYear" in e8 && "weekOfYear" in e8 && "year" in e8 && "yearMonthFromFields" in e8 && "yearOfWeek" in e8;
      }(e7))
        throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
      return e7;
    }
    const t = lt2(e7);
    if (io(t))
      return oo(t);
    let r;
    try {
      ({ calendar: r } = Ft(t));
    } catch {
      try {
        ({ calendar: r } = Ut2(t));
      } catch {
        ({ calendar: r } = qt(t));
      }
    }
    if (r || (r = "iso8601"), !io(r))
      throw new RangeError(`invalid calendar identifier ${r}`);
    return oo(r);
  }
  function Jr(e7) {
    if (Z4(e7, j4))
      return K3(e7, j4);
    const { calendar: t } = e7;
    return void 0 === t ? "iso8601" : Hr(t);
  }
  function Vr(e7) {
    if ("string" == typeof e7)
      return e7;
    const t = e7.id;
    if ("string" != typeof t)
      throw new TypeError("calendar.id should be a string");
    return t;
  }
  function Qr(e7) {
    return it2(e7) ? e7 : new (m4("%Temporal.Calendar%"))(e7);
  }
  function Zr(e7, t) {
    return e7 === t || Vr(e7) === Vr(t);
  }
  function Kr(e7, t, r) {
    if (e7 === t)
      return;
    const n4 = Vr(e7), i4 = Vr(t);
    if (n4 !== i4)
      throw new RangeError(`cannot ${r} of ${n4} and ${i4} calendars`);
  }
  function Xr(e7, t) {
    if (e7 === t)
      return t;
    const r = Vr(e7), n4 = Vr(t);
    if (r === n4 || "iso8601" === r)
      return t;
    if ("iso8601" === n4)
      return e7;
    throw new RangeError("irreconcilable calendars");
  }
  function en(e7, t, r, n4) {
    if ("string" == typeof e7) {
      const n5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.dateFromFields%"), n5, [t, r]);
    }
    const i4 = nt3(n4 ?? rt3(e7, "dateFromFields"), e7, [t, r]);
    if (!Nt2(i4))
      throw new TypeError("invalid result");
    return i4;
  }
  function tn(e7, t, r) {
    if ("string" == typeof e7) {
      const n5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.yearMonthFromFields%"), n5, [t, r]);
    }
    let n4 = nt3(rt3(e7, "yearMonthFromFields"), e7, [t, r]);
    if (!At(n4))
      throw new TypeError("invalid result");
    return n4;
  }
  function rn(e7, t, r) {
    if ("string" == typeof e7) {
      const n5 = new (m4("%Temporal.Calendar%"))(e7);
      return nt3(m4("%Temporal.Calendar.prototype.monthDayFromFields%"), n5, [t, r]);
    }
    let n4 = nt3(rt3(e7, "monthDayFromFields"), e7, [t, r]);
    if (!Mt2(n4))
      throw new TypeError("invalid result");
    return n4;
  }
  function nn(e7) {
    if (it2(e7)) {
      if (Lt2(e7))
        return K3(e7, A3);
      if (!function(e8) {
        return !!kt2(e8) || "getOffsetNanosecondsFor" in e8 && "getPossibleInstantsFor" in e8 && "id" in e8;
      }(e7))
        throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
      return e7;
    }
    return function(e8) {
      const { ianaName: t, offset: r, z: n4 } = function(e9) {
        if (new RegExp(`^${te.source}$`, "i").test(e9))
          return { ianaName: e9 };
        try {
          const t2 = Ft(e9);
          if (t2.z || t2.offset || t2.ianaName)
            return t2;
        } catch {
        }
        throw new RangeError(`Invalid time zone: ${e9}`);
      }(e8);
      return t ? kn(t) : n4 ? "UTC" : Dn(Rn(r));
    }(lt2(e7));
  }
  function on(e7) {
    if ("string" == typeof e7)
      return e7;
    const t = e7.id;
    if ("string" != typeof t)
      throw new TypeError("timeZone.id should be a string");
    return t;
  }
  function an(e7) {
    return it2(e7) ? e7 : new (m4("%Temporal.TimeZone%"))(e7);
  }
  function sn(e7, t) {
    return e7 === t || on(e7) === on(t);
  }
  function ln(e7) {
    return wr(K3(e7, b4), K3(e7, _4), K3(e7, E2), K3(e7, j4));
  }
  function un(e7) {
    return new (m4("%Temporal.PlainTime%"))(K3(e7, T4), K3(e7, x4), K3(e7, I3), K3(e7, S4), K3(e7, R4), K3(e7, k4));
  }
  function cn(e7, t, r) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.TimeZone%"))(e7);
      return nt3(m4("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), r2, [t]);
    }
    const n4 = nt3(r ?? rt3(e7, "getOffsetNanosecondsFor"), e7, [t]);
    if ("number" != typeof n4)
      throw new TypeError("bad return from getOffsetNanosecondsFor");
    if (!st2(n4) || Ee(n4) >= 864e11)
      throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
    return n4;
  }
  function dn(e7, t) {
    return Dn(cn(e7, t));
  }
  function hn(e7, t, r) {
    const n4 = K3(t, v4), i4 = cn(e7, t);
    let { year: o4, month: a4, day: s3, hour: l6, minute: u4, second: c3, millisecond: d5, microsecond: h6, nanosecond: f5 } = Cn(n4);
    return { year: o4, month: a4, day: s3, hour: l6, minute: u4, second: c3, millisecond: d5, microsecond: h6, nanosecond: f5 } = Hn(o4, a4, s3, l6, u4, c3, d5, h6, f5 + i4), _r(o4, a4, s3, l6, u4, c3, d5, h6, f5, r);
  }
  function fn(e7, t, r) {
    return pn(mn(e7, t), e7, t, r);
  }
  function pn(e7, t, r, n4) {
    const i4 = m4("%Temporal.Instant%"), o4 = e7.length;
    if (1 === o4)
      return e7[0];
    if (o4)
      switch (n4) {
        case "compatible":
        case "earlier":
          return e7[0];
        case "later":
          return e7[o4 - 1];
        case "reject":
          throw new RangeError("multiple instants found");
      }
    const a4 = K3(r, b4), s3 = K3(r, _4), l6 = K3(r, E2), u4 = K3(r, T4), c3 = K3(r, x4), h6 = K3(r, I3), f5 = K3(r, S4), p6 = K3(r, R4), y5 = K3(r, k4), g5 = On(a4, s3, l6, u4, c3, h6, f5, p6, y5);
    if (null === g5)
      throw new RangeError("DateTime outside of supported range");
    const v6 = new i4(d3.subtract(g5, ze)), w5 = new i4(d3.add(g5, ze)), D4 = cn(t, v6), N10 = cn(t, w5) - D4;
    switch (n4) {
      case "earlier": {
        const e8 = K3(r, j4), n5 = m4("%Temporal.PlainDateTime%"), i5 = ki(a4, s3, l6, u4, c3, h6, f5, p6, y5, e8, 0, 0, 0, 0, 0, 0, 0, 0, 0, -N10, void 0);
        return mn(t, new n5(i5.year, i5.month, i5.day, i5.hour, i5.minute, i5.second, i5.millisecond, i5.microsecond, i5.nanosecond, e8))[0];
      }
      case "compatible":
      case "later": {
        const e8 = K3(r, j4), n5 = m4("%Temporal.PlainDateTime%"), i5 = ki(a4, s3, l6, u4, c3, h6, f5, p6, y5, e8, 0, 0, 0, 0, 0, 0, 0, 0, 0, N10, void 0), o5 = mn(t, new n5(i5.year, i5.month, i5.day, i5.hour, i5.minute, i5.second, i5.millisecond, i5.microsecond, i5.nanosecond, e8));
        return o5[o5.length - 1];
      }
      case "reject":
        throw new RangeError("no such instant found");
    }
  }
  function mn(e7, t, r) {
    if ("string" == typeof e7) {
      const r2 = new (m4("%Temporal.TimeZone%"))(e7);
      return nt3(m4("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), r2, [t]);
    }
    const n4 = nt3(r ?? rt3(e7, "getPossibleInstantsFor"), e7, [t]), i4 = [];
    for (const e8 of n4) {
      if (!Rt(e8))
        throw new TypeError("bad return from getPossibleInstantsFor");
      ve.call(i4, e8);
    }
    return i4;
  }
  function yn(e7) {
    let t;
    return t = e7 < 0 || e7 > 9999 ? (e7 < 0 ? "-" : "+") + `000000${Ee(e7)}`.slice(-6) : `0000${e7}`.slice(-4), t;
  }
  function gn(e7) {
    return `00${e7}`.slice(-2);
  }
  function vn(e7, t, r, n4, i4) {
    if ("minute" === i4)
      return "";
    const o4 = `:${gn(e7)}`;
    let a4, s3 = 1e6 * t + 1e3 * r + n4;
    if ("auto" === i4) {
      if (0 === s3)
        return o4;
      for (a4 = `${s3}`.padStart(9, "0"); "0" === a4[a4.length - 1]; )
        a4 = a4.slice(0, -1);
    } else {
      if (0 === i4)
        return o4;
      a4 = `${s3}`.padStart(9, "0").slice(0, i4);
    }
    return `${o4}.${a4}`;
  }
  function wn(e7, t, r) {
    let n4 = t;
    void 0 === n4 && (n4 = "UTC");
    const i4 = hn(n4, e7, "iso8601"), o4 = yn(K3(i4, b4)), a4 = gn(K3(i4, _4)), s3 = gn(K3(i4, E2)), l6 = gn(K3(i4, T4)), u4 = gn(K3(i4, x4)), c3 = vn(K3(i4, I3), K3(i4, S4), K3(i4, R4), K3(i4, k4), r);
    let d5 = "Z";
    return void 0 !== t && (d5 = Nn(cn(n4, e7))), `${o4}-${a4}-${s3}T${l6}:${u4}${c3}${d5}`;
  }
  function bn(e7, t = "auto", r) {
    function n4(e8) {
      return e8 <= De ? e8.toString(10) : d3.BigInt(e8).toString(10);
    }
    const i4 = K3(e7, M4), o4 = K3(e7, L3), a4 = K3(e7, P4), s3 = K3(e7, B4), l6 = K3(e7, $3), u4 = K3(e7, F3);
    let c3 = K3(e7, U5), h6 = K3(e7, q4), f5 = K3(e7, Y4), p6 = K3(e7, W3);
    const m5 = Wn(i4, o4, a4, s3, l6, u4, c3, h6, f5, p6);
    if (r) {
      const { unit: e8, increment: t2, roundingMode: n5 } = r;
      ({ seconds: c3, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = Wi(0, 0, 0, 0, 0, 0, c3, h6, f5, p6, t2, e8, n5));
    }
    const y5 = [];
    i4 && y5.push(`${n4(Ee(i4))}Y`), o4 && y5.push(`${n4(Ee(o4))}M`), a4 && y5.push(`${n4(Ee(a4))}W`), s3 && y5.push(`${n4(Ee(s3))}D`);
    const g5 = [];
    l6 && g5.push(`${n4(Ee(l6))}H`), u4 && g5.push(`${n4(Ee(u4))}M`);
    const v6 = [];
    let w5, b7, _5, E4, T6 = Vn(0, 0, 0, c3, h6, f5, p6, 0);
    ({ quotient: T6, remainder: w5 } = ht2(T6, $e)), { quotient: T6, remainder: b7 } = ht2(T6, $e), { quotient: E4, remainder: _5 } = ht2(T6, $e);
    const x6 = 1e6 * Ee(d3.toNumber(_5)) + 1e3 * Ee(d3.toNumber(b7)) + Ee(d3.toNumber(w5));
    let I5;
    if ("auto" === t) {
      if (0 !== x6)
        for (I5 = `${x6}`.padStart(9, "0"); "0" === I5[I5.length - 1]; )
          I5 = I5.slice(0, -1);
    } else
      0 !== t && (I5 = `${x6}`.padStart(9, "0").slice(0, t));
    return I5 && v6.unshift(".", I5), d3.equal(E4, Me) && !v6.length && "auto" === t || v6.unshift(mt2(E4).toString()), v6.length && g5.push(`${v6.join("")}S`), g5.length && g5.unshift("T"), y5.length || g5.length ? `${m5 < 0 ? "-" : ""}P${y5.join("")}${g5.join("")}` : "PT0S";
  }
  function _n(e7, t = "auto") {
    return `${yn(K3(e7, b4))}-${gn(K3(e7, _4))}-${gn(K3(e7, E2))}${Bt2(K3(e7, j4), t)}`;
  }
  function En(e7, t, r = "auto", n4) {
    let i4 = K3(e7, b4), o4 = K3(e7, _4), a4 = K3(e7, E2), s3 = K3(e7, T4), l6 = K3(e7, x4), u4 = K3(e7, I3), c3 = K3(e7, S4), d5 = K3(e7, R4), h6 = K3(e7, k4);
    if (n4) {
      const { unit: e8, increment: t2, roundingMode: r2 } = n4;
      ({ year: i4, month: o4, day: a4, hour: s3, minute: l6, second: u4, millisecond: c3, microsecond: d5, nanosecond: h6 } = Bi(i4, o4, a4, s3, l6, u4, c3, d5, h6, t2, e8, r2));
    }
    return `${yn(i4)}-${gn(o4)}-${gn(a4)}T${gn(s3)}:${gn(l6)}${vn(u4, c3, d5, h6, t)}${Bt2(K3(e7, j4), r)}`;
  }
  function Tn(e7, t = "auto") {
    let r = `${gn(K3(e7, _4))}-${gn(K3(e7, E2))}`;
    const n4 = Vr(K3(e7, j4));
    "always" !== t && "critical" !== t && "iso8601" === n4 || (r = `${yn(K3(e7, b4))}-${r}`);
    const i4 = $t2(n4, t);
    return i4 && (r += i4), r;
  }
  function xn(e7, t = "auto") {
    let r = `${yn(K3(e7, b4))}-${gn(K3(e7, _4))}`;
    const n4 = Vr(K3(e7, j4));
    "always" !== t && "critical" !== t && "iso8601" === n4 || (r += `-${gn(K3(e7, E2))}`);
    const i4 = $t2(n4, t);
    return i4 && (r += i4), r;
  }
  function In(e7, t, r = "auto", n4 = "auto", i4 = "auto", o4) {
    let a4 = K3(e7, C3);
    if (o4) {
      const { unit: t2, increment: r2, roundingMode: n5 } = o4, i5 = Pi(K3(e7, v4), r2, t2, n5);
      a4 = new (m4("%Temporal.Instant%"))(i5);
    }
    const s3 = K3(e7, A3), l6 = hn(s3, a4, "iso8601");
    let u4 = `${yn(K3(l6, b4))}-${gn(K3(l6, _4))}-${gn(K3(l6, E2))}T${gn(K3(l6, T4))}:${gn(K3(l6, x4))}${vn(K3(l6, I3), K3(l6, S4), K3(l6, R4), K3(l6, k4), t)}`;
    return "never" !== i4 && (u4 += Nn(cn(s3, a4))), "never" !== n4 && (u4 += `[${"critical" === n4 ? "!" : ""}${on(s3)}]`), u4 += Bt2(K3(e7, j4), r), u4;
  }
  function Sn(e7) {
    return ao.test(je(e7));
  }
  function Rn(e7) {
    const t = ao.exec(je(e7));
    if (!t)
      throw new RangeError(`invalid time zone offset: ${e7}`);
    return ("-" === t[1] || "\u2212" === t[1] ? -1 : 1) * (1e9 * (60 * (60 * +t[2] + +(t[3] || 0)) + +(t[4] || 0)) + +((t[5] || 0) + "000000000").slice(0, 9));
  }
  function kn(e7) {
    return Sn(e7) ? Dn(Rn(e7)) : xt(je(e7)).resolvedOptions().timeZone;
  }
  function jn(e7, t) {
    const { year: r, month: n4, day: i4, hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = An(e7, t), h6 = r % 400, f5 = (r - h6) / 400, p6 = d3.multiply(d3.BigInt(146097), ze), m5 = On(h6, n4, i4, o4, a4, s3, l6, u4, c3), y5 = d3.add(m5, d3.multiply(p6, d3.BigInt(f5)));
    return d3.toNumber(d3.subtract(y5, t));
  }
  function Dn(e7) {
    const t = e7 < 0 ? "-" : "+", r = Ee(e7), n4 = r % 1e9, i4 = Te(r / 1e9) % 60, o4 = Te(r / 6e10) % 60, a4 = gn(Te(r / 36e11)), s3 = gn(o4), l6 = gn(i4);
    let u4 = "";
    if (n4) {
      let e8 = `${n4}`.padStart(9, "0");
      for (; "0" === e8[e8.length - 1]; )
        e8 = e8.slice(0, -1);
      u4 = `:${l6}.${e8}`;
    } else
      i4 && (u4 = `:${l6}`);
    return `${t}${a4}:${s3}${u4}`;
  }
  function Nn(e7) {
    let t = d3.toNumber(Li(d3.BigInt(e7), We, "halfExpand"));
    const r = t < 0 ? "-" : "+";
    t = Ee(t);
    const n4 = t / 6e10 % 60;
    return `${r}${gn(Te(t / 36e11))}:${gn(n4)}`;
  }
  function On(e7, t, r, n4, i4, o4, a4, s3, l6) {
    const u4 = new Date();
    u4.setUTCHours(n4, i4, o4, a4), u4.setUTCFullYear(e7, t - 1, r);
    const c3 = u4.getTime();
    if (Se(c3))
      return null;
    let h6 = d3.multiply(d3.BigInt(c3), Fe);
    return h6 = d3.add(h6, d3.multiply(d3.BigInt(s3), $e)), h6 = d3.add(h6, d3.BigInt(l6)), d3.lessThan(h6, Ge) || d3.greaterThan(h6, He) ? null : h6;
  }
  function Cn(e7) {
    const { quotient: t, remainder: r } = ht2(e7, Fe);
    let n4 = d3.toNumber(t), i4 = d3.toNumber(r);
    i4 < 0 && (i4 += 1e6, n4 -= 1);
    const o4 = Te(i4 / 1e3) % 1e3, a4 = i4 % 1e3, s3 = new Date(n4);
    return { epochMilliseconds: n4, year: s3.getUTCFullYear(), month: s3.getUTCMonth() + 1, day: s3.getUTCDate(), hour: s3.getUTCHours(), minute: s3.getUTCMinutes(), second: s3.getUTCSeconds(), millisecond: s3.getUTCMilliseconds(), microsecond: o4, nanosecond: a4 };
  }
  function An(e7, t) {
    const { epochMilliseconds: r, millisecond: n4, microsecond: i4, nanosecond: o4 } = Cn(t), { year: a4, month: s3, day: l6, hour: u4, minute: c3, second: d5 } = function(e8, t2) {
      return function(e9) {
        const t3 = e9.split(/[^\w]+/);
        if (7 !== t3.length)
          throw new RangeError(`expected 7 parts in "${e9}`);
        const r2 = +t3[0], n5 = +t3[1];
        let i5 = +t3[2];
        const o5 = t3[3].toUpperCase();
        if ("B" === o5 || "BC" === o5)
          i5 = 1 - i5;
        else if ("A" !== o5 && "AD" !== o5)
          throw new RangeError(`Unknown era ${o5} in "${e9}`);
        let a5 = +t3[4];
        24 === a5 && (a5 = 0);
        const s4 = +t3[5], l7 = +t3[6];
        if (!(Re(i5) && Re(r2) && Re(n5) && Re(a5) && Re(s4) && Re(l7)))
          throw new RangeError(`Invalid number in "${e9}`);
        return { year: i5, month: r2, day: n5, hour: a5, minute: s4, second: l7 };
      }(xt(e8).format(new Date(t2)));
    }(e7, r);
    return Hn(a4, s3, l6, u4, c3, d5, n4, i4, o4);
  }
  function Mn(e7, t) {
    return d3.lessThan(e7, t) ? t : e7;
  }
  function Ln() {
    return d3.add(Zi(), Ze);
  }
  function Pn(e7, t) {
    if (d3.lessThan(t, Qe))
      return Pn(e7, Qe);
    const r = d3.add(t, Ke), n4 = Mn(Ln(), r);
    let i4 = Mn(Qe, t);
    const o4 = jn(e7, i4);
    let a4 = i4, s3 = o4;
    for (; o4 === s3 && d3.lessThan(d3.BigInt(i4), n4); ) {
      if (a4 = d3.add(i4, Xe), d3.greaterThan(a4, He))
        return null;
      s3 = jn(e7, a4), o4 === s3 && (i4 = a4);
    }
    return o4 === s3 ? null : so((t2) => jn(e7, t2), i4, a4, o4, s3);
  }
  function Bn(e7, t) {
    const r = Ln(), n4 = d3.greaterThan(t, r), i4 = n4 ? d3.subtract(t, Ke) : Qe;
    if ("Africa/Casablanca" === e7 || "Africa/El_Aaiun" === e7) {
      const r2 = K3(hr("2088-01-01T00Z"), v4);
      if (d3.lessThan(r2, t))
        return Bn(e7, r2);
    }
    let o4 = d3.subtract(t, Le);
    if (d3.lessThan(o4, Qe))
      return null;
    const a4 = jn(e7, o4);
    let s3 = o4, l6 = a4;
    for (; a4 === l6 && d3.greaterThan(o4, i4); ) {
      if (s3 = d3.subtract(o4, Xe), d3.lessThan(s3, Qe))
        return null;
      l6 = jn(e7, s3), a4 === l6 && (o4 = s3);
    }
    if (a4 === l6) {
      if (n4) {
        const t2 = d3.subtract(r, ze);
        return Bn(e7, t2);
      }
      return null;
    }
    return so((t2) => jn(e7, t2), s3, o4, l6, a4);
  }
  function $n(e7) {
    return void 0 !== e7 && !(e7 % 4 != 0 || e7 % 100 == 0 && e7 % 400 != 0);
  }
  function Fn(e7, t) {
    return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[$n(e7) ? "leapyear" : "standard"][t - 1];
  }
  function Un(e7, t, r) {
    const n4 = t + (t < 3 ? 10 : -2), i4 = e7 - (t < 3 ? 1 : 0), o4 = Te(i4 / 100), a4 = i4 - 100 * o4, s3 = (r + Te(2.6 * n4 - 0.2) + (a4 + Te(a4 / 4)) + (Te(o4 / 4) - 2 * o4)) % 7;
    return s3 + (s3 <= 0 ? 7 : 0);
  }
  function qn(e7, t, r) {
    let n4 = r;
    for (let r2 = t - 1; r2 > 0; r2--)
      n4 += Fn(e7, r2);
    return n4;
  }
  function Yn(e7, t, r) {
    const n4 = qn(e7, t, r), i4 = Un(e7, t, r) || 7, o4 = Un(e7, 1, 1), a4 = Te((n4 - i4 + 10) / 7);
    return a4 < 1 ? 5 === o4 || 6 === o4 && $n(e7 - 1) ? { week: 53, year: e7 - 1 } : { week: 52, year: e7 - 1 } : 53 === a4 && ($n(e7) ? 366 : 365) - n4 < 4 - i4 ? { week: 1, year: e7 + 1 } : { week: a4, year: e7 };
  }
  function Wn(e7, t, r, n4, i4, o4, a4, s3, l6, u4) {
    for (const c3 of [e7, t, r, n4, i4, o4, a4, s3, l6, u4])
      if (0 !== c3)
        return c3 < 0 ? -1 : 1;
    return 0;
  }
  function zn(e7, t) {
    let r = e7, n4 = t;
    if (!Re(r) || !Re(n4))
      throw new RangeError("infinity is out of range");
    return n4 -= 1, r += Te(n4 / 12), n4 %= 12, n4 < 0 && (n4 += 12), n4 += 1, { year: r, month: n4 };
  }
  function Gn(e7, t, r) {
    let n4 = e7, i4 = t, o4 = r;
    if (!Re(o4))
      throw new RangeError("infinity is out of range");
    ({ year: n4, month: i4 } = zn(n4, i4));
    const a4 = 146097;
    if (Ee(o4) > a4) {
      const e8 = Ie(o4 / a4);
      n4 += 400 * e8, o4 -= e8 * a4;
    }
    let s3 = 0, l6 = i4 > 2 ? n4 : n4 - 1;
    for (; s3 = $n(l6) ? 366 : 365, o4 < -s3; )
      n4 -= 1, l6 -= 1, o4 += s3;
    for (l6 += 1; s3 = $n(l6) ? 366 : 365, o4 > s3; )
      n4 += 1, l6 += 1, o4 -= s3;
    for (; o4 < 1; )
      ({ year: n4, month: i4 } = zn(n4, i4 - 1)), o4 += Fn(n4, i4);
    for (; o4 > Fn(n4, i4); )
      o4 -= Fn(n4, i4), { year: n4, month: i4 } = zn(n4, i4 + 1);
    return { year: n4, month: i4, day: o4 };
  }
  function Hn(e7, t, r, n4, i4, o4, a4, s3, l6) {
    const { deltaDays: u4, hour: c3, minute: d5, second: h6, millisecond: f5, microsecond: p6, nanosecond: m5 } = Jn(n4, i4, o4, a4, s3, l6), { year: y5, month: g5, day: v6 } = Gn(e7, t, r + u4);
    return { year: y5, month: g5, day: v6, hour: c3, minute: d5, second: h6, millisecond: f5, microsecond: p6, nanosecond: m5 };
  }
  function Jn(e7, t, r, n4, i4, o4) {
    let a4, s3 = d3.BigInt(e7), l6 = d3.BigInt(t), u4 = d3.BigInt(r), c3 = d3.BigInt(n4), h6 = d3.BigInt(i4), f5 = d3.BigInt(o4);
    return { quotient: a4, remainder: f5 } = Gi(f5, $e), h6 = d3.add(h6, a4), { quotient: a4, remainder: h6 } = Gi(h6, $e), c3 = d3.add(c3, a4), { quotient: a4, remainder: c3 } = Gi(c3, $e), u4 = d3.add(u4, a4), { quotient: a4, remainder: u4 } = Gi(u4, Pe), l6 = d3.add(l6, a4), { quotient: a4, remainder: l6 } = Gi(l6, Pe), s3 = d3.add(s3, a4), { quotient: a4, remainder: s3 } = Gi(s3, Be), { deltaDays: d3.toNumber(a4), hour: d3.toNumber(s3), minute: d3.toNumber(l6), second: d3.toNumber(u4), millisecond: d3.toNumber(c3), microsecond: d3.toNumber(h6), nanosecond: d3.toNumber(f5) };
  }
  function Vn(e7, t, r, n4, i4, o4, a4, s3) {
    const l6 = d3.BigInt(e7);
    let u4 = d3.BigInt(a4);
    0 !== e7 && (u4 = d3.subtract(d3.BigInt(a4), d3.BigInt(s3)));
    const c3 = d3.add(d3.BigInt(t), d3.multiply(l6, d3.BigInt(24))), h6 = d3.add(d3.BigInt(r), d3.multiply(c3, Pe)), f5 = d3.add(d3.BigInt(n4), d3.multiply(h6, Pe)), p6 = d3.add(d3.BigInt(i4), d3.multiply(f5, $e)), m5 = d3.add(d3.BigInt(o4), d3.multiply(p6, $e));
    return d3.add(d3.BigInt(u4), d3.multiply(m5, $e));
  }
  function Qn(e7, t) {
    const r = m4("%Temporal.Instant%"), n4 = xe(d3.toNumber(e7));
    let i4 = d3.BigInt(e7), o4 = 864e11;
    if (0 === n4)
      return { days: 0, nanoseconds: Me, dayLengthNs: o4 };
    if (!Lt2(t)) {
      let e8;
      return { quotient: e8, remainder: i4 } = ht2(i4, d3.BigInt(o4)), { days: d3.toNumber(e8), nanoseconds: i4, dayLengthNs: o4 };
    }
    const a4 = K3(t, v4), s3 = K3(t, C3), l6 = d3.add(a4, i4), u4 = new r(l6), c3 = K3(t, A3), h6 = K3(t, j4), f5 = hn(c3, s3, h6), p6 = hn(c3, u4, h6);
    let { days: y5 } = mi(K3(f5, b4), K3(f5, _4), K3(f5, E2), K3(f5, T4), K3(f5, x4), K3(f5, I3), K3(f5, S4), K3(f5, R4), K3(f5, k4), K3(p6, b4), K3(p6, _4), K3(p6, E2), K3(p6, T4), K3(p6, x4), K3(p6, I3), K3(p6, S4), K3(p6, R4), K3(p6, k4), h6, "day", Ne(null)), g5 = ji(s3, c3, h6, 0, 0, 0, y5, 0, 0, 0, 0, 0, 0), w5 = d3.BigInt(y5);
    if (1 === n4)
      for (; d3.greaterThan(w5, Me) && d3.greaterThan(g5, l6); )
        w5 = d3.subtract(w5, Le), g5 = ji(s3, c3, h6, 0, 0, 0, d3.toNumber(w5), 0, 0, 0, 0, 0, 0);
    i4 = d3.subtract(l6, g5);
    let D4 = false, N10 = new r(g5);
    do {
      const e8 = ji(N10, c3, h6, 0, 0, 0, n4, 0, 0, 0, 0, 0, 0), t2 = K3(N10, v4);
      o4 = d3.toNumber(d3.subtract(e8, t2)), D4 = d3.greaterThanOrEqual(d3.multiply(d3.subtract(i4, d3.BigInt(o4)), d3.BigInt(n4)), Me), D4 && (i4 = d3.subtract(i4, d3.BigInt(o4)), N10 = new r(e8), w5 = d3.add(w5, d3.BigInt(n4)));
    } while (D4);
    if (!tt3(w5) && pt2(w5) !== n4)
      throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
    if (!tt3(i4) && pt2(i4) !== n4) {
      if (ft(i4) && 1 === n4)
        throw new Error("assert not reached");
      throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
    }
    if (d3.greaterThanOrEqual(mt2(i4), mt2(d3.BigInt(o4))))
      throw new Error("assert not reached");
    return { days: d3.toNumber(w5), nanoseconds: i4, dayLengthNs: Ee(o4) };
  }
  function Zn(e7, t, r, n4, i4, o4, a4, s3, l6) {
    let u4 = Kn(e7, t, r, n4, i4, o4, a4, s3, l6);
    if ("positive overflow" === u4 || "negative overflow" === u4)
      throw new RangeError("Duration out of range");
    return u4;
  }
  function Kn(e7, t, r, n4, i4, o4, a4, s3, l6) {
    let u4, c3, h6, f5, p6, m5, y5 = e7;
    if (Lt2(l6)) {
      const e8 = ji(K3(l6, C3), K3(l6, A3), K3(l6, j4), 0, 0, 0, y5, t, r, n4, i4, o4, a4), s4 = K3(l6, v4);
      u4 = d3.subtract(e8, s4);
    } else
      u4 = Vn(y5, t, r, n4, i4, o4, a4, 0);
    "year" === s3 || "month" === s3 || "week" === s3 || "day" === s3 ? { days: y5, nanoseconds: u4 } = Qn(u4, l6) : y5 = 0;
    const g5 = d3.lessThan(u4, Me) ? -1 : 1;
    switch (u4 = mt2(u4), c3 = h6 = f5 = p6 = m5 = Me, s3) {
      case "year":
      case "month":
      case "week":
      case "day":
      case "hour":
        ({ quotient: c3, remainder: u4 } = ht2(u4, $e)), { quotient: h6, remainder: c3 } = ht2(c3, $e), { quotient: f5, remainder: h6 } = ht2(h6, $e), { quotient: p6, remainder: f5 } = ht2(f5, Pe), { quotient: m5, remainder: p6 } = ht2(p6, Pe);
        break;
      case "minute":
        ({ quotient: c3, remainder: u4 } = ht2(u4, $e)), { quotient: h6, remainder: c3 } = ht2(c3, $e), { quotient: f5, remainder: h6 } = ht2(h6, $e), { quotient: p6, remainder: f5 } = ht2(f5, Pe);
        break;
      case "second":
        ({ quotient: c3, remainder: u4 } = ht2(u4, $e)), { quotient: h6, remainder: c3 } = ht2(c3, $e), { quotient: f5, remainder: h6 } = ht2(h6, $e);
        break;
      case "millisecond":
        ({ quotient: c3, remainder: u4 } = ht2(u4, $e)), { quotient: h6, remainder: c3 } = ht2(c3, $e);
        break;
      case "microsecond":
        ({ quotient: c3, remainder: u4 } = ht2(u4, $e));
        break;
      case "nanosecond":
        break;
      default:
        throw new Error("assert not reached");
    }
    const w5 = d3.toNumber(m5) * g5, b7 = d3.toNumber(p6) * g5, _5 = d3.toNumber(f5) * g5, E4 = d3.toNumber(h6) * g5, T6 = d3.toNumber(c3) * g5, x6 = d3.toNumber(u4) * g5;
    for (const e8 of [y5, w5, b7, _5, E4, T6, x6])
      if (!Re(e8))
        return 1 === g5 ? "positive overflow" : "negative overflow";
    return { days: y5, hours: w5, minutes: b7, seconds: _5, milliseconds: E4, microseconds: T6, nanoseconds: x6 };
  }
  function Xn(e7, t, r, n4, i4, o4) {
    const a4 = m4("%Temporal.Duration%"), s3 = Wn(e7, t, r, n4, 0, 0, 0, 0, 0, 0);
    if (0 === s3)
      return { years: e7, months: t, weeks: r, days: n4 };
    const l6 = d3.BigInt(s3);
    let u4, c3, h6 = d3.BigInt(e7), f5 = d3.BigInt(t), p6 = d3.BigInt(r), y5 = d3.BigInt(n4);
    o4 && (c3 = lr(o4), u4 = K3(c3, j4));
    const g5 = new a4(s3), v6 = new a4(0, s3), w5 = new a4(0, 0, s3);
    switch (i4) {
      case "year":
        break;
      case "month":
        {
          if (!u4)
            throw new RangeError("a starting point is required for months balancing");
          let e8, t2;
          for ("string" != typeof u4 && (e8 = rt3(u4, "dateAdd"), t2 = rt3(u4, "dateUntil")); !tt3(h6); ) {
            const r2 = Dr(u4, c3, g5, void 0, e8), n5 = Ne(null);
            n5.largestUnit = "month";
            const i5 = Nr(u4, c3, r2, n5, t2), o5 = d3.BigInt(K3(i5, L3));
            c3 = r2, f5 = d3.add(f5, o5), h6 = d3.subtract(h6, l6);
          }
        }
        break;
      case "week": {
        if (!u4)
          throw new RangeError("a starting point is required for weeks balancing");
        const e8 = "string" != typeof u4 ? rt3(u4, "dateAdd") : void 0;
        for (; !tt3(h6); ) {
          let t2;
          ({ relativeTo: c3, days: t2 } = Ui(u4, c3, g5, e8)), y5 = d3.add(y5, d3.BigInt(t2)), h6 = d3.subtract(h6, l6);
        }
        for (; !tt3(f5); ) {
          let t2;
          ({ relativeTo: c3, days: t2 } = Ui(u4, c3, v6, e8)), y5 = d3.add(y5, d3.BigInt(t2)), f5 = d3.subtract(f5, l6);
        }
        break;
      }
      default: {
        if (tt3(h6) && tt3(f5) && tt3(p6))
          break;
        if (!u4)
          throw new RangeError("a starting point is required for balancing calendar units");
        const e8 = "string" != typeof u4 ? rt3(u4, "dateAdd") : void 0;
        for (; !tt3(h6); ) {
          let t2;
          ({ relativeTo: c3, days: t2 } = Ui(u4, c3, g5, e8)), y5 = d3.add(y5, d3.BigInt(t2)), h6 = d3.subtract(h6, l6);
        }
        for (; !tt3(f5); ) {
          let t2;
          ({ relativeTo: c3, days: t2 } = Ui(u4, c3, v6, e8)), y5 = d3.add(y5, d3.BigInt(t2)), f5 = d3.subtract(f5, l6);
        }
        for (; !tt3(p6); ) {
          let t2;
          ({ relativeTo: c3, days: t2 } = Ui(u4, c3, w5, e8)), y5 = d3.add(y5, d3.BigInt(t2)), p6 = d3.subtract(p6, l6);
        }
        break;
      }
    }
    return { years: d3.toNumber(h6), months: d3.toNumber(f5), weeks: d3.toNumber(p6), days: d3.toNumber(y5) };
  }
  function ei(e7, t, r, n4, i4) {
    if (Lt2(e7)) {
      const o4 = K3(e7, C3), a4 = K3(e7, A3), s3 = K3(e7, j4), l6 = cn(a4, o4), u4 = ji(o4, a4, s3, t, r, n4, i4, 0, 0, 0, 0, 0, 0);
      return cn(a4, new (m4("%Temporal.Instant%"))(u4)) - l6;
    }
    return 0;
  }
  function ti(e7) {
    return new (m4("%Temporal.Duration%"))(-K3(e7, M4), -K3(e7, L3), -K3(e7, P4), -K3(e7, B4), -K3(e7, $3), -K3(e7, F3), -K3(e7, U5), -K3(e7, q4), -K3(e7, Y4), -K3(e7, W3));
  }
  function ri(e7, t, r) {
    return be(r, _e(t, e7));
  }
  function ni(e7, t, r) {
    const n4 = ri(t, 1, 12);
    return { year: e7, month: n4, day: ri(r, 1, Fn(e7, n4)) };
  }
  function ii(e7, t, r) {
    if (e7 < t || e7 > r)
      throw new RangeError(`value out of range: ${t} <= ${e7} <= ${r}`);
  }
  function oi(e7, t, r) {
    ii(t, 1, 12), ii(r, 1, Fn(e7, t));
  }
  function ai(e7, t, r) {
    ui(e7, t, r, 12, 0, 0, 0, 0, 0);
  }
  function si(e7, t, r, n4, i4, o4) {
    ii(e7, 0, 23), ii(t, 0, 59), ii(r, 0, 59), ii(n4, 0, 999), ii(i4, 0, 999), ii(o4, 0, 999);
  }
  function li(e7, t, r, n4, i4, o4, a4, s3, l6) {
    oi(e7, t, r), si(n4, i4, o4, a4, s3, l6);
  }
  function ui(e7, t, r, n4, i4, o4, a4, s3, l6) {
    if (ii(e7, Je, Ve), e7 === Je && null == On(e7, t, r + 1, n4, i4, o4, a4, s3, l6 - 1) || e7 === Ve && null == On(e7, t, r - 1, n4, i4, o4, a4, s3, l6 + 1))
      throw new RangeError("DateTime outside of supported range");
  }
  function ci(e7) {
    if (d3.lessThan(e7, Ge) || d3.greaterThan(e7, He))
      throw new RangeError("Instant outside of supported range");
  }
  function di(e7, t, r, n4, i4, o4, a4, s3, l6, u4) {
    const c3 = Wn(e7, t, r, n4, i4, o4, a4, s3, l6, u4);
    for (const d5 of [e7, t, r, n4, i4, o4, a4, s3, l6, u4]) {
      if (!Re(d5))
        throw new RangeError("infinite values not allowed as duration fields");
      const e8 = xe(d5);
      if (0 !== e8 && e8 !== c3)
        throw new RangeError("mixed-sign values not allowed as duration fields");
    }
  }
  function hi(e7, t, r, n4, i4, o4, a4) {
    switch (a4) {
      case "year":
      case "month": {
        const s3 = -zi(e7, t, r, n4, i4, o4);
        if (0 === s3)
          return { years: 0, months: 0, weeks: 0, days: 0 };
        const l6 = { year: e7, month: t, day: r }, u4 = { year: n4, month: i4, day: o4 };
        let c3 = u4.year - l6.year, d5 = xi(e7, t, r, c3, 0, 0, 0, "constrain"), h6 = -zi(d5.year, d5.month, d5.day, n4, i4, o4);
        if (0 === h6)
          return "year" === a4 ? { years: c3, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * c3, weeks: 0, days: 0 };
        let f5 = u4.month - l6.month;
        if (h6 !== s3 && (c3 -= s3, f5 += 12 * s3), d5 = xi(e7, t, r, c3, f5, 0, 0, "constrain"), h6 = -zi(d5.year, d5.month, d5.day, n4, i4, o4), 0 === h6)
          return "year" === a4 ? { years: c3, months: f5, weeks: 0, days: 0 } : { years: 0, months: f5 + 12 * c3, weeks: 0, days: 0 };
        h6 !== s3 && (f5 -= s3, f5 === -s3 && (c3 -= s3, f5 = 11 * s3), d5 = xi(e7, t, r, c3, f5, 0, 0, "constrain"));
        let p6 = 0;
        return p6 = d5.month === u4.month ? u4.day - d5.day : s3 < 0 ? -d5.day - (Fn(u4.year, u4.month) - u4.day) : u4.day + (Fn(d5.year, d5.month) - d5.day), "month" === a4 && (f5 += 12 * c3, c3 = 0), { years: c3, months: f5, weeks: 0, days: p6 };
      }
      case "week":
      case "day": {
        let s3, l6, u4;
        zi(e7, t, r, n4, i4, o4) < 0 ? (l6 = { year: e7, month: t, day: r }, s3 = { year: n4, month: i4, day: o4 }, u4 = 1) : (l6 = { year: n4, month: i4, day: o4 }, s3 = { year: e7, month: t, day: r }, u4 = -1);
        let c3 = qn(s3.year, s3.month, s3.day) - qn(l6.year, l6.month, l6.day);
        for (let e8 = l6.year; e8 < s3.year; ++e8)
          c3 += $n(e8) ? 366 : 365;
        let d5 = 0;
        return "week" === a4 && (d5 = Te(c3 / 7), c3 %= 7), d5 *= u4, c3 *= u4, { years: 0, months: 0, weeks: d5, days: c3 };
      }
      default:
        throw new Error("assert not reached");
    }
  }
  function fi(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5) {
    let h6 = a4 - e7, f5 = s3 - t, p6 = l6 - r, m5 = u4 - n4, y5 = c3 - i4, g5 = d5 - o4;
    const v6 = Wn(0, 0, 0, 0, h6, f5, p6, m5, y5, g5);
    h6 *= v6, f5 *= v6, p6 *= v6, m5 *= v6, y5 *= v6, g5 *= v6;
    let w5 = 0;
    if ({ deltaDays: w5, hour: h6, minute: f5, second: p6, millisecond: m5, microsecond: y5, nanosecond: g5 } = Jn(h6, f5, p6, m5, y5, g5), 0 != w5)
      throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
    return h6 *= v6, f5 *= v6, p6 *= v6, m5 *= v6, y5 *= v6, g5 *= v6, { hours: h6, minutes: f5, seconds: p6, milliseconds: m5, microseconds: y5, nanoseconds: g5 };
  }
  function pi(e7, t, r, n4, i4, o4) {
    const a4 = d3.subtract(t, e7);
    let s3 = 0, l6 = 0, u4 = d3.toNumber(d3.remainder(a4, $e)), c3 = d3.toNumber(d3.remainder(d3.divide(a4, $e), $e)), h6 = d3.toNumber(d3.remainder(d3.divide(a4, Fe), $e)), f5 = d3.toNumber(d3.divide(a4, Ue));
    return { hours: s3, minutes: l6, seconds: f5, milliseconds: h6, microseconds: c3, nanoseconds: u4 } = Wi(0, 0, 0, 0, 0, 0, f5, h6, c3, u4, r, n4, o4), Zn(0, s3, l6, f5, h6, c3, u4, i4);
  }
  function mi(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6, f5, p6, m5, y5, g5, v6, w5, b7) {
    let _5 = e7, E4 = t, T6 = r, { hours: x6, minutes: I5, seconds: S6, milliseconds: R5, microseconds: k5, nanoseconds: j5 } = fi(n4, i4, o4, a4, s3, l6, h6, f5, p6, m5, y5, g5);
    const D4 = Wn(0, 0, 0, 0, x6, I5, S6, R5, k5, j5);
    zi(u4, c3, d5, _5, E4, T6) === -D4 && ({ year: _5, month: E4, day: T6 } = Gn(_5, E4, T6 - D4), { hours: x6, minutes: I5, seconds: S6, milliseconds: R5, microseconds: k5, nanoseconds: j5 } = Zn(-D4, x6, I5, S6, R5, k5, j5, w5));
    const N10 = wr(_5, E4, T6, v6), O3 = wr(u4, c3, d5, v6), C5 = or("day", w5), A5 = ro(b7);
    A5.largestUnit = C5;
    let { years: M6, months: L4, weeks: P5, days: B6 } = Nr(v6, N10, O3, A5);
    return { days: B6, hours: x6, minutes: I5, seconds: S6, milliseconds: R5, microseconds: k5, nanoseconds: j5 } = Zn(B6, x6, I5, S6, R5, k5, j5, w5), { years: M6, months: L4, weeks: P5, days: B6, hours: x6, minutes: I5, seconds: S6, milliseconds: R5, microseconds: k5, nanoseconds: j5 };
  }
  function yi(e7, t, r, n4, i4, o4) {
    const a4 = d3.subtract(t, e7);
    if (d3.equal(a4, Me))
      return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
    const s3 = m4("%Temporal.Instant%"), l6 = new s3(e7), u4 = new s3(t), c3 = hn(r, l6, n4), h6 = hn(r, u4, n4);
    let { years: f5, months: p6, weeks: y5, days: g5 } = mi(K3(c3, b4), K3(c3, _4), K3(c3, E2), K3(c3, T4), K3(c3, x4), K3(c3, I3), K3(c3, S4), K3(c3, R4), K3(c3, k4), K3(h6, b4), K3(h6, _4), K3(h6, E2), K3(h6, T4), K3(h6, x4), K3(h6, I3), K3(h6, S4), K3(h6, R4), K3(h6, k4), n4, i4, o4);
    const v6 = ji(l6, r, n4, f5, p6, y5, 0, 0, 0, 0, 0, 0, 0);
    let w5 = d3.subtract(t, v6);
    const j5 = Rr(v6, r, n4);
    ({ nanoseconds: w5, days: g5 } = Qn(w5, j5));
    const { hours: D4, minutes: N10, seconds: O3, milliseconds: C5, microseconds: A5, nanoseconds: M6 } = Zn(0, 0, 0, 0, 0, 0, d3.toNumber(w5), "hour");
    return { years: f5, months: p6, weeks: y5, days: g5, hours: D4, minutes: N10, seconds: O3, milliseconds: C5, microseconds: A5, nanoseconds: M6 };
  }
  function gi(e7, t, r, n4, i4, o4) {
    const a4 = vt2.reduce((e8, t2) => {
      const i5 = t2[0], o5 = t2[1], a5 = t2[2];
      return "datetime" !== r && a5 !== r || n4.includes(o5) || e8.push(o5, i5), e8;
    }, []);
    let s3 = rr(t, "largestUnit", r, "auto");
    if (n4.includes(s3))
      throw new RangeError(`largestUnit must be one of ${a4.join(", ")}, not ${s3}`);
    const l6 = Zt(t);
    let u4 = Jt2(t, "trunc");
    "since" === e7 && (u4 = function(e8) {
      switch (e8) {
        case "ceil":
          return "floor";
        case "floor":
          return "ceil";
        case "halfCeil":
          return "halfFloor";
        case "halfFloor":
          return "halfCeil";
        default:
          return e8;
      }
    }(u4));
    const c3 = rr(t, "smallestUnit", r, i4);
    if (n4.includes(c3))
      throw new RangeError(`smallestUnit must be one of ${a4.join(", ")}, not ${c3}`);
    const d5 = or(o4, c3);
    if ("auto" === s3 && (s3 = d5), or(s3, c3) !== s3)
      throw new RangeError(`largestUnit ${s3} cannot be smaller than smallestUnit ${c3}`);
    const h6 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[c3];
    return void 0 !== h6 && Kt2(l6, h6, false), { largestUnit: s3, roundingIncrement: l6, roundingMode: u4, smallestUnit: c3 };
  }
  function vi(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = hr(r), a4 = gi(e7, ro(n4), "time", [], "nanosecond", "second"), s3 = K3(t, v4), l6 = K3(o4, v4);
    let { hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = pi(s3, l6, a4.roundingIncrement, a4.smallestUnit, a4.largestUnit, a4.roundingMode);
    return new (m4("%Temporal.Duration%"))(0, 0, 0, 0, i4 * u4, i4 * c3, i4 * d5, i4 * h6, i4 * f5, i4 * p6);
  }
  function wi(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = lr(r), a4 = K3(t, j4);
    Kr(a4, K3(o4, j4), "compute difference between dates");
    const s3 = ro(n4), l6 = gi(e7, s3, "date", [], "day", "day");
    s3.largestUnit = l6.largestUnit;
    let { years: u4, months: c3, weeks: d5, days: h6 } = Nr(a4, t, o4, s3);
    return "day" === l6.smallestUnit && 1 === l6.roundingIncrement || ({ years: u4, months: c3, weeks: d5, days: h6 } = Wi(u4, c3, d5, h6, 0, 0, 0, 0, 0, 0, l6.roundingIncrement, l6.smallestUnit, l6.roundingMode, t)), new (m4("%Temporal.Duration%"))(i4 * u4, i4 * c3, i4 * d5, i4 * h6, 0, 0, 0, 0, 0, 0);
  }
  function bi(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = cr(r), a4 = K3(t, j4);
    Kr(a4, K3(o4, j4), "compute difference between dates");
    const s3 = ro(n4), l6 = gi(e7, s3, "datetime", [], "nanosecond", "day");
    let { years: u4, months: c3, weeks: d5, days: h6, hours: f5, minutes: p6, seconds: y5, milliseconds: g5, microseconds: v6, nanoseconds: w5 } = mi(K3(t, b4), K3(t, _4), K3(t, E2), K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4), K3(o4, b4), K3(o4, _4), K3(o4, E2), K3(o4, T4), K3(o4, x4), K3(o4, I3), K3(o4, S4), K3(o4, R4), K3(o4, k4), a4, l6.largestUnit, s3);
    const D4 = ln(t);
    return { years: u4, months: c3, weeks: d5, days: h6, hours: f5, minutes: p6, seconds: y5, milliseconds: g5, microseconds: v6, nanoseconds: w5 } = Wi(u4, c3, d5, h6, f5, p6, y5, g5, v6, w5, l6.roundingIncrement, l6.smallestUnit, l6.roundingMode, D4), { days: h6, hours: f5, minutes: p6, seconds: y5, milliseconds: g5, microseconds: v6, nanoseconds: w5 } = Zn(h6, f5, p6, y5, g5, v6, w5, l6.largestUnit), new (m4("%Temporal.Duration%"))(i4 * u4, i4 * c3, i4 * d5, i4 * h6, i4 * f5, i4 * p6, i4 * y5, i4 * g5, i4 * v6, i4 * w5);
  }
  function _i(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = pr(r), a4 = gi(e7, ro(n4), "time", [], "nanosecond", "hour");
    let { hours: s3, minutes: l6, seconds: u4, milliseconds: c3, microseconds: d5, nanoseconds: h6 } = fi(K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4), K3(o4, T4), K3(o4, x4), K3(o4, I3), K3(o4, S4), K3(o4, R4), K3(o4, k4));
    return { hours: s3, minutes: l6, seconds: u4, milliseconds: c3, microseconds: d5, nanoseconds: h6 } = Wi(0, 0, 0, 0, s3, l6, u4, c3, d5, h6, a4.roundingIncrement, a4.smallestUnit, a4.roundingMode), { hours: s3, minutes: l6, seconds: u4, milliseconds: c3, microseconds: d5, nanoseconds: h6 } = Zn(0, s3, l6, u4, c3, d5, h6, a4.largestUnit), new (m4("%Temporal.Duration%"))(0, 0, 0, 0, i4 * s3, i4 * l6, i4 * u4, i4 * c3, i4 * d5, i4 * h6);
  }
  function Ei(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = mr(r), a4 = K3(t, j4);
    Kr(a4, K3(o4, j4), "compute difference between months");
    const s3 = ro(n4), l6 = gi(e7, s3, "date", ["week", "day"], "month", "year");
    s3.largestUnit = l6.largestUnit;
    const u4 = kr(a4, ["monthCode", "year"]), c3 = ar(t, u4, []);
    c3.day = 1;
    const d5 = en(a4, c3), h6 = ar(o4, u4, []);
    h6.day = 1;
    const f5 = en(a4, h6);
    let { years: p6, months: y5 } = Nr(a4, d5, f5, s3);
    return "month" === l6.smallestUnit && 1 === l6.roundingIncrement || ({ years: p6, months: y5 } = Wi(p6, y5, 0, 0, 0, 0, 0, 0, 0, 0, l6.roundingIncrement, l6.smallestUnit, l6.roundingMode, d5)), new (m4("%Temporal.Duration%"))(i4 * p6, i4 * y5, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  function Ti(e7, t, r, n4) {
    const i4 = "since" === e7 ? -1 : 1, o4 = gr(r), a4 = K3(t, j4);
    Kr(a4, K3(o4, j4), "compute difference between dates");
    const s3 = ro(n4), l6 = gi(e7, s3, "datetime", [], "nanosecond", "hour");
    s3.largestUnit = l6.largestUnit;
    const u4 = K3(t, v4), c3 = K3(o4, v4);
    let d5, h6, f5, p6, y5, g5, w5, b7, _5, E4;
    if ("year" !== l6.largestUnit && "month" !== l6.largestUnit && "week" !== l6.largestUnit && "day" !== l6.largestUnit)
      d5 = 0, h6 = 0, f5 = 0, p6 = 0, { hours: y5, minutes: g5, seconds: w5, milliseconds: b7, microseconds: _5, nanoseconds: E4 } = pi(u4, c3, l6.roundingIncrement, l6.smallestUnit, l6.largestUnit, l6.roundingMode);
    else {
      const e8 = K3(t, A3);
      if (!sn(e8, K3(o4, A3)))
        throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
      ({ years: d5, months: h6, weeks: f5, days: p6, hours: y5, minutes: g5, seconds: w5, milliseconds: b7, microseconds: _5, nanoseconds: E4 } = yi(u4, c3, e8, a4, l6.largestUnit, s3)), { years: d5, months: h6, weeks: f5, days: p6, hours: y5, minutes: g5, seconds: w5, milliseconds: b7, microseconds: _5, nanoseconds: E4 } = Wi(d5, h6, f5, p6, y5, g5, w5, b7, _5, E4, l6.roundingIncrement, l6.smallestUnit, l6.roundingMode, t), { years: d5, months: h6, weeks: f5, days: p6, hours: y5, minutes: g5, seconds: w5, milliseconds: b7, microseconds: _5, nanoseconds: E4 } = Yi(d5, h6, f5, p6, y5, g5, w5, b7, _5, E4, l6.roundingIncrement, l6.smallestUnit, l6.roundingMode, t);
    }
    return new (m4("%Temporal.Duration%"))(i4 * d5, i4 * h6, i4 * f5, i4 * p6, i4 * y5, i4 * g5, i4 * w5, i4 * b7, i4 * _5, i4 * E4);
  }
  function xi(e7, t, r, n4, i4, o4, a4, s3) {
    let l6 = e7, u4 = t, c3 = r, d5 = o4, h6 = a4;
    return l6 += n4, u4 += i4, { year: l6, month: u4 } = zn(l6, u4), { year: l6, month: u4, day: c3 } = Yt(l6, u4, c3, s3), h6 += 7 * d5, c3 += h6, { year: l6, month: u4, day: c3 } = Gn(l6, u4, c3), { year: l6, month: u4, day: c3 };
  }
  function Ii(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5) {
    let h6 = e7, f5 = t, p6 = r, m5 = n4, y5 = i4, g5 = o4;
    h6 += a4, f5 += s3, p6 += l6, m5 += u4, y5 += c3, g5 += d5;
    let v6 = 0;
    return { deltaDays: v6, hour: h6, minute: f5, second: p6, millisecond: m5, microsecond: y5, nanosecond: g5 } = Jn(h6, f5, p6, m5, y5, g5), { deltaDays: v6, hour: h6, minute: f5, second: p6, millisecond: m5, microsecond: y5, nanosecond: g5 };
  }
  function Si(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, h6, f5, p6, y5, g5, w5, b7, _5, E4, T6) {
    const x6 = or(ir(e7, t, r, n4, i4, o4, a4, s3, l6, u4), ir(c3, h6, f5, p6, y5, g5, w5, b7, _5, E4));
    let I5, S6, R5, k5, D4, N10, O3, M6, L4, P5;
    if (T6)
      if (Nt2(T6)) {
        const v6 = m4("%Temporal.Duration%"), C5 = K3(T6, j4), A5 = new v6(e7, t, r, n4, 0, 0, 0, 0, 0, 0), B6 = new v6(c3, h6, f5, p6, 0, 0, 0, 0, 0, 0), $4 = "string" != typeof C5 ? rt3(C5, "dateAdd") : void 0, F4 = Dr(C5, T6, A5, void 0, $4), U6 = Dr(C5, F4, B6, void 0, $4), q5 = or("day", x6), Y5 = Ne(null);
        Y5.largestUnit = q5, { years: I5, months: S6, weeks: R5, days: k5 } = Nr(C5, T6, U6, Y5), { days: k5, hours: D4, minutes: N10, seconds: O3, milliseconds: M6, microseconds: L4, nanoseconds: P5 } = Zn(k5, d3.add(d3.BigInt(i4), d3.BigInt(y5)), d3.add(d3.BigInt(o4), d3.BigInt(g5)), d3.add(d3.BigInt(a4), d3.BigInt(w5)), d3.add(d3.BigInt(s3), d3.BigInt(b7)), d3.add(d3.BigInt(l6), d3.BigInt(_5)), d3.add(d3.BigInt(u4), d3.BigInt(E4)), x6);
      } else {
        const d5 = m4("%Temporal.Instant%"), B6 = K3(T6, A3), $4 = K3(T6, j4), F4 = ji(K3(T6, C3), B6, $4, e7, t, r, n4, i4, o4, a4, s3, l6, u4), U6 = ji(new d5(F4), B6, $4, c3, h6, f5, p6, y5, g5, w5, b7, _5, E4);
        "year" !== x6 && "month" !== x6 && "week" !== x6 && "day" !== x6 ? (I5 = 0, S6 = 0, R5 = 0, k5 = 0, { hours: D4, minutes: N10, seconds: O3, milliseconds: M6, microseconds: L4, nanoseconds: P5 } = pi(K3(T6, v4), U6, 1, "nanosecond", x6, "halfExpand")) : { years: I5, months: S6, weeks: R5, days: k5, hours: D4, minutes: N10, seconds: O3, milliseconds: M6, microseconds: L4, nanoseconds: P5 } = yi(K3(T6, v4), U6, B6, $4, x6, Ne(null));
      }
    else {
      if ("year" === x6 || "month" === x6 || "week" === x6)
        throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
      I5 = S6 = R5 = 0, { days: k5, hours: D4, minutes: N10, seconds: O3, milliseconds: M6, microseconds: L4, nanoseconds: P5 } = Zn(n4 + p6, d3.add(d3.BigInt(i4), d3.BigInt(y5)), d3.add(d3.BigInt(o4), d3.BigInt(g5)), d3.add(d3.BigInt(a4), d3.BigInt(w5)), d3.add(d3.BigInt(s3), d3.BigInt(b7)), d3.add(d3.BigInt(l6), d3.BigInt(_5)), d3.add(d3.BigInt(u4), d3.BigInt(E4)), x6);
    }
    return di(I5, S6, R5, k5, D4, N10, O3, M6, L4, P5), { years: I5, months: S6, weeks: R5, days: k5, hours: D4, minutes: N10, seconds: O3, milliseconds: M6, microseconds: L4, nanoseconds: P5 };
  }
  function Ri(e7, t, r, n4, i4, o4, a4) {
    let s3 = Me;
    s3 = d3.add(s3, d3.BigInt(a4)), s3 = d3.add(s3, d3.multiply(d3.BigInt(o4), $e)), s3 = d3.add(s3, d3.multiply(d3.BigInt(i4), Fe)), s3 = d3.add(s3, d3.multiply(d3.BigInt(n4), Ue)), s3 = d3.add(s3, d3.multiply(d3.BigInt(r), d3.BigInt(6e10))), s3 = d3.add(s3, d3.multiply(d3.BigInt(t), d3.BigInt(36e11)));
    const l6 = d3.add(e7, s3);
    return ci(l6), l6;
  }
  function ki(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6, f5, p6, y5, g5, v6, w5, T6, x6) {
    let I5 = f5, { deltaDays: S6, hour: R5, minute: k5, second: j5, millisecond: D4, microsecond: N10, nanosecond: O3 } = Ii(n4, i4, o4, a4, s3, l6, p6, y5, g5, v6, w5, T6);
    I5 += S6;
    const C5 = m4("%Temporal.Duration%"), A5 = Dr(u4, wr(e7, t, r, u4), new C5(c3, d5, h6, I5, 0, 0, 0, 0, 0, 0), x6);
    return { year: K3(A5, b4), month: K3(A5, _4), day: K3(A5, E2), hour: R5, minute: k5, second: j5, millisecond: D4, microsecond: N10, nanosecond: O3 };
  }
  function ji(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6, f5) {
    const p6 = m4("%Temporal.Duration%");
    if (0 === Wn(n4, i4, o4, a4, 0, 0, 0, 0, 0, 0))
      return Ri(K3(e7, v4), s3, l6, u4, c3, d5, h6);
    const y5 = hn(t, e7, r), g5 = Dr(r, wr(K3(y5, b4), K3(y5, _4), K3(y5, E2), r), new p6(n4, i4, o4, a4, 0, 0, 0, 0, 0, 0), f5), w5 = _r(K3(g5, b4), K3(g5, _4), K3(g5, E2), K3(y5, T4), K3(y5, x4), K3(y5, I3), K3(y5, S4), K3(y5, R4), K3(y5, k4), r);
    return Ri(K3(fn(t, w5, "compatible"), v4), s3, l6, u4, c3, d5, h6);
  }
  function Di(e7, t, r, n4) {
    const i4 = "subtract" === e7 ? -1 : 1;
    let { years: o4, months: a4, weeks: s3, days: l6, hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = zt(r);
    const y5 = nr(eo(n4));
    return { years: o4, months: a4, weeks: s3, days: l6, hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = Si(K3(t, M4), K3(t, L3), K3(t, P4), K3(t, B4), K3(t, $3), K3(t, F3), K3(t, U5), K3(t, q4), K3(t, Y4), K3(t, W3), i4 * o4, i4 * a4, i4 * s3, i4 * l6, i4 * u4, i4 * c3, i4 * d5, i4 * h6, i4 * f5, i4 * p6, y5), new (m4("%Temporal.Duration%"))(o4, a4, s3, l6, u4, c3, d5, h6, f5, p6);
  }
  function Ni(e7, t, r) {
    const n4 = "subtract" === e7 ? -1 : 1, { hours: i4, minutes: o4, seconds: a4, milliseconds: s3, microseconds: l6, nanoseconds: u4 } = function(e8, t2) {
      let r2 = zt(e8);
      for (const e9 of t2)
        if (0 !== r2[e9])
          throw new RangeError(`Duration field ${e9} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
      return r2;
    }(r, ["years", "months", "weeks", "days"]), c3 = Ri(K3(t, v4), n4 * i4, n4 * o4, n4 * a4, n4 * s3, n4 * l6, n4 * u4);
    return new (m4("%Temporal.Instant%"))(c3);
  }
  function Oi(e7, t, r, n4) {
    const i4 = "subtract" === e7 ? -1 : 1, { years: o4, months: a4, weeks: s3, days: l6, hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = zt(r), m5 = eo(n4), y5 = K3(t, j4), { year: g5, month: v6, day: w5, hour: D4, minute: N10, second: O3, millisecond: C5, microsecond: A5, nanosecond: M6 } = ki(K3(t, b4), K3(t, _4), K3(t, E2), K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4), y5, i4 * o4, i4 * a4, i4 * s3, i4 * l6, i4 * u4, i4 * c3, i4 * d5, i4 * h6, i4 * f5, i4 * p6, m5);
    return _r(g5, v6, w5, D4, N10, O3, C5, A5, M6, y5);
  }
  function Ci(e7, t, r) {
    const n4 = "subtract" === e7 ? -1 : 1, { hours: i4, minutes: o4, seconds: a4, milliseconds: s3, microseconds: l6, nanoseconds: u4 } = zt(r);
    let { hour: c3, minute: d5, second: h6, millisecond: f5, microsecond: p6, nanosecond: y5 } = Ii(K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4), n4 * i4, n4 * o4, n4 * a4, n4 * s3, n4 * l6, n4 * u4);
    return { hour: c3, minute: d5, second: h6, millisecond: f5, microsecond: p6, nanosecond: y5 } = Wt2(c3, d5, h6, f5, p6, y5, "reject"), new (m4("%Temporal.PlainTime%"))(c3, d5, h6, f5, p6, y5);
  }
  function Ai(e7, t, r, n4) {
    let i4 = zt(r);
    "subtract" === e7 && (i4 = { years: -i4.years, months: -i4.months, weeks: -i4.weeks, days: -i4.days, hours: -i4.hours, minutes: -i4.minutes, seconds: -i4.seconds, milliseconds: -i4.milliseconds, microseconds: -i4.microseconds, nanoseconds: -i4.nanoseconds });
    let { years: o4, months: a4, weeks: s3, days: l6, hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = i4;
    ({ days: l6 } = Zn(l6, u4, c3, d5, h6, f5, p6, "day"));
    const y5 = eo(n4), g5 = K3(t, j4), v6 = kr(g5, ["monthCode", "year"]), w5 = ar(t, v6, []), b7 = Ne(null);
    St2(b7, w5, []), w5.day = 1;
    let _5 = en(g5, w5);
    const E4 = Wn(o4, a4, s3, l6, 0, 0, 0, 0, 0, 0), T6 = rt3(g5, "dateAdd"), x6 = m4("%Temporal.Duration%");
    if (E4 < 0) {
      const e8 = Dr(g5, _5, new x6(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, T6), t2 = Dr(g5, e8, new x6(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, T6);
      b7.day = Mr(g5, t2), _5 = en(g5, b7);
    }
    const I5 = new x6(o4, a4, s3, l6, 0, 0, 0, 0, 0, 0), S6 = ro(y5);
    return tn(g5, ar(Dr(g5, _5, I5, y5, T6), v6, []), S6);
  }
  function Mi(e7, t, r, n4) {
    const i4 = "subtract" === e7 ? -1 : 1, { years: o4, months: a4, weeks: s3, days: l6, hours: u4, minutes: c3, seconds: d5, milliseconds: h6, microseconds: f5, nanoseconds: p6 } = zt(r), m5 = eo(n4), y5 = K3(t, A3), g5 = K3(t, j4);
    return Rr(ji(K3(t, C3), y5, g5, i4 * o4, i4 * a4, i4 * s3, i4 * l6, i4 * u4, i4 * c3, i4 * d5, i4 * h6, i4 * f5, i4 * p6, m5), y5, g5);
  }
  function Li(e7, t, r) {
    if (d3.equal(t, Le))
      return e7;
    let { quotient: n4, remainder: i4 } = ht2(e7, t);
    if (d3.equal(i4, Me))
      return e7;
    const o4 = d3.lessThan(i4, Me) ? -1 : 1, a4 = mt2(d3.multiply(i4, d3.BigInt(2))), s3 = d3.equal(a4, t), l6 = d3.greaterThan(a4, t);
    switch (r) {
      case "ceil":
        o4 > 0 && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "floor":
        o4 < 0 && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "expand":
        n4 = d3.add(n4, d3.BigInt(o4));
        break;
      case "trunc":
        break;
      case "halfCeil":
        (l6 || s3 && o4 > 0) && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "halfFloor":
        (l6 || s3 && o4 < 0) && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "halfExpand":
        (l6 || s3) && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "halfTrunc":
        l6 && (n4 = d3.add(n4, d3.BigInt(o4)));
        break;
      case "halfEven":
        (l6 || s3 && 1 === d3.toNumber(d3.remainder(mt2(n4), d3.BigInt(2)))) && (n4 = d3.add(n4, d3.BigInt(o4)));
    }
    return d3.multiply(n4, t);
  }
  function Pi(e7, t, r, n4) {
    let { remainder: i4 } = Gi(e7, ze);
    const o4 = d3.subtract(e7, i4), a4 = Li(i4, d3.BigInt(lo[r] * t), n4);
    return d3.add(o4, a4);
  }
  function Bi(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, d5, h6 = 864e11) {
    const { deltaDays: f5, hour: p6, minute: m5, second: y5, millisecond: g5, microsecond: v6, nanosecond: w5 } = $i(n4, i4, o4, a4, s3, l6, u4, c3, d5, h6), { year: b7, month: _5, day: E4 } = Gn(e7, t, r + f5);
    return { year: b7, month: _5, day: E4, hour: p6, minute: m5, second: y5, millisecond: g5, microsecond: v6, nanosecond: w5 };
  }
  function $i(e7, t, r, n4, i4, o4, a4, s3, l6, u4 = 864e11) {
    let c3 = Me;
    switch (s3) {
      case "day":
      case "hour":
        c3 = d3.BigInt(e7);
      case "minute":
        c3 = d3.add(d3.multiply(c3, Pe), d3.BigInt(t));
      case "second":
        c3 = d3.add(d3.multiply(c3, Pe), d3.BigInt(r));
      case "millisecond":
        c3 = d3.add(d3.multiply(c3, $e), d3.BigInt(n4));
      case "microsecond":
        c3 = d3.add(d3.multiply(c3, $e), d3.BigInt(i4));
      case "nanosecond":
        c3 = d3.add(d3.multiply(c3, $e), d3.BigInt(o4));
    }
    const h6 = "day" === s3 ? u4 : lo[s3], f5 = Li(c3, d3.BigInt(h6 * a4), l6), p6 = d3.toNumber(d3.divide(f5, d3.BigInt(h6)));
    switch (s3) {
      case "day":
        return { deltaDays: p6, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
      case "hour":
        return Jn(p6, 0, 0, 0, 0, 0);
      case "minute":
        return Jn(e7, p6, 0, 0, 0, 0);
      case "second":
        return Jn(e7, t, p6, 0, 0, 0);
      case "millisecond":
        return Jn(e7, t, r, p6, 0, 0);
      case "microsecond":
        return Jn(e7, t, r, n4, p6, 0);
      case "nanosecond":
        return Jn(e7, t, r, n4, i4, p6);
      default:
        throw new Error(`Invalid unit ${s3}`);
    }
  }
  function Fi(e7, t) {
    return hi(K3(e7, b4), K3(e7, _4), K3(e7, E2), K3(t, b4), K3(t, _4), K3(t, E2), "day").days;
  }
  function Ui(e7, t, r, n4) {
    const i4 = Dr(e7, t, r, void 0, n4);
    return { relativeTo: i4, days: Fi(t, i4) };
  }
  function qi(e7, t, r, n4, i4) {
    const o4 = K3(e7, A3), a4 = K3(e7, j4);
    return Rr(ji(K3(e7, C3), o4, a4, t, r, n4, i4, 0, 0, 0, 0, 0, 0), o4, a4);
  }
  function Yi(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, h6, f5, p6) {
    let y5 = e7, g5 = t, v6 = r, w5 = n4, b7 = i4, _5 = o4, E4 = a4, T6 = s3, x6 = l6, I5 = u4;
    if (!Lt2(p6) || "year" === h6 || "month" === h6 || "week" === h6 || "day" === h6 || "nanosecond" === h6 && 1 === c3)
      return { years: y5, months: g5, weeks: v6, days: w5, hours: b7, minutes: _5, seconds: E4, milliseconds: T6, microseconds: x6, nanoseconds: I5 };
    let S6 = Vn(0, b7, _5, E4, T6, x6, I5, 0);
    const R5 = xe(d3.toNumber(S6)), k5 = K3(p6, A3), D4 = K3(p6, j4), N10 = ji(K3(p6, C3), k5, D4, y5, g5, v6, w5, 0, 0, 0, 0, 0, 0), O3 = ji(new (m4("%Temporal.Instant%"))(N10), k5, D4, 0, 0, 0, R5, 0, 0, 0, 0, 0, 0), M6 = d3.subtract(O3, N10);
    return d3.greaterThanOrEqual(d3.multiply(d3.subtract(S6, M6), d3.BigInt(R5)), Me) && ({ years: y5, months: g5, weeks: v6, days: w5 } = Si(y5, g5, v6, w5, 0, 0, 0, 0, 0, 0, 0, 0, 0, R5, 0, 0, 0, 0, 0, 0, p6), S6 = Pi(d3.subtract(S6, M6), c3, h6, f5), { hours: b7, minutes: _5, seconds: E4, milliseconds: T6, microseconds: x6, nanoseconds: I5 } = Zn(0, 0, 0, 0, 0, 0, d3.toNumber(S6), "hour")), { years: y5, months: g5, weeks: v6, days: w5, hours: b7, minutes: _5, seconds: E4, milliseconds: T6, microseconds: x6, nanoseconds: I5 };
  }
  function Wi(e7, t, r, n4, i4, o4, a4, s3, l6, u4, c3, h6, f5, p6) {
    let y5 = e7, g5 = t, v6 = r, w5 = n4, b7 = i4, _5 = o4, E4 = a4, T6 = s3, x6 = l6, I5 = d3.BigInt(u4);
    const S6 = m4("%Temporal.Duration%");
    let R5, k5, D4, N10, O3 = p6;
    if (O3) {
      if (Lt2(O3))
        k5 = O3, O3 = lr(O3);
      else if (!Nt2(O3))
        throw new TypeError("starting point must be PlainDate or ZonedDateTime");
      R5 = K3(O3, j4);
    }
    if ("year" === h6 || "month" === h6 || "week" === h6 || "day" === h6) {
      let e8, t2, r2;
      I5 = Vn(0, b7, _5, E4, T6, x6, u4, 0), k5 && (e8 = qi(k5, y5, g5, v6, w5)), { days: t2, nanoseconds: I5, dayLengthNs: r2 } = Qn(I5, e8), D4 = d3.BigInt(r2), w5 += t2, b7 = _5 = E4 = T6 = x6 = 0;
    }
    switch (h6) {
      case "year": {
        if (!R5)
          throw new RangeError("A starting point is required for years rounding");
        const e8 = new S6(y5), t2 = "string" != typeof R5 ? rt3(R5, "dateAdd") : void 0, r2 = Dr(R5, O3, e8, void 0, t2), n5 = Dr(R5, O3, new S6(y5, g5, v6), void 0, t2);
        O3 = r2, w5 += Fi(r2, n5);
        const i5 = Dr(R5, O3, new S6(0, 0, 0, w5), void 0, t2), o5 = Ne(null);
        o5.largestUnit = "year";
        const a5 = Nr(R5, O3, i5, o5).years;
        y5 += a5;
        const s4 = O3;
        O3 = Dr(R5, O3, new S6(a5), void 0, t2), w5 -= Fi(s4, O3);
        const l7 = new S6(w5 < 0 ? -1 : 1);
        let { days: u5 } = Ui(R5, O3, l7, t2);
        u5 = Ee(u5);
        const h7 = d3.multiply(d3.BigInt(u5), D4);
        I5 = d3.add(d3.add(d3.multiply(h7, d3.BigInt(y5)), d3.multiply(d3.BigInt(w5), D4)), I5);
        const p7 = Li(I5, d3.multiply(h7, d3.BigInt(c3)), f5);
        N10 = Ji(I5, h7), y5 = d3.toNumber(d3.divide(p7, h7)), I5 = Me, g5 = v6 = w5 = 0;
        break;
      }
      case "month": {
        if (!R5)
          throw new RangeError("A starting point is required for months rounding");
        const e8 = new S6(y5, g5), t2 = "string" != typeof R5 ? rt3(R5, "dateAdd") : void 0, r2 = Dr(R5, O3, e8, void 0, t2), n5 = Dr(R5, O3, new S6(y5, g5, v6), void 0, t2);
        O3 = r2, w5 += Fi(r2, n5);
        const i5 = xe(w5), o5 = new S6(0, w5 < 0 ? -1 : 1);
        let a5;
        for ({ relativeTo: O3, days: a5 } = Ui(R5, O3, o5, t2); Ee(w5) >= Ee(a5); )
          g5 += i5, w5 -= a5, { relativeTo: O3, days: a5 } = Ui(R5, O3, o5, t2);
        a5 = Ee(a5);
        const s4 = d3.multiply(d3.BigInt(a5), D4);
        I5 = d3.add(d3.add(d3.multiply(s4, d3.BigInt(g5)), d3.multiply(d3.BigInt(w5), D4)), I5);
        const l7 = Li(I5, d3.multiply(s4, d3.BigInt(c3)), f5);
        N10 = Ji(I5, s4), g5 = d3.toNumber(d3.divide(l7, s4)), I5 = Me, v6 = w5 = 0;
        break;
      }
      case "week": {
        if (!R5)
          throw new RangeError("A starting point is required for weeks rounding");
        const e8 = xe(w5), t2 = new S6(0, 0, w5 < 0 ? -1 : 1), r2 = "string" != typeof R5 ? rt3(R5, "dateAdd") : void 0;
        let n5;
        for ({ relativeTo: O3, days: n5 } = Ui(R5, O3, t2, r2); Ee(w5) >= Ee(n5); )
          v6 += e8, w5 -= n5, { relativeTo: O3, days: n5 } = Ui(R5, O3, t2, r2);
        n5 = Ee(n5);
        const i5 = d3.multiply(d3.BigInt(n5), D4);
        I5 = d3.add(d3.add(d3.multiply(i5, d3.BigInt(v6)), d3.multiply(d3.BigInt(w5), D4)), I5);
        const o5 = Li(I5, d3.multiply(i5, d3.BigInt(c3)), f5);
        N10 = Ji(I5, i5), v6 = d3.toNumber(d3.divide(o5, i5)), I5 = Me, w5 = 0;
        break;
      }
      case "day": {
        const e8 = D4;
        I5 = d3.add(d3.multiply(e8, d3.BigInt(w5)), I5);
        const t2 = Li(I5, d3.multiply(e8, d3.BigInt(c3)), f5);
        N10 = Ji(I5, e8), w5 = d3.toNumber(d3.divide(t2, e8)), I5 = Me;
        break;
      }
      case "hour": {
        const e8 = 36e11;
        let t2 = d3.multiply(d3.BigInt(b7), d3.BigInt(36e11));
        t2 = d3.add(t2, d3.multiply(d3.BigInt(_5), d3.BigInt(6e10))), t2 = d3.add(t2, d3.multiply(d3.BigInt(E4), Ue)), t2 = d3.add(t2, d3.multiply(d3.BigInt(T6), Fe)), t2 = d3.add(t2, d3.multiply(d3.BigInt(x6), $e)), t2 = d3.add(t2, I5), N10 = Ji(t2, d3.BigInt(e8));
        const r2 = Li(t2, d3.BigInt(e8 * c3), f5);
        b7 = d3.toNumber(d3.divide(r2, d3.BigInt(e8))), I5 = Me, _5 = E4 = T6 = x6 = 0;
        break;
      }
      case "minute": {
        const e8 = 6e10;
        let t2 = d3.multiply(d3.BigInt(_5), d3.BigInt(6e10));
        t2 = d3.add(t2, d3.multiply(d3.BigInt(E4), Ue)), t2 = d3.add(t2, d3.multiply(d3.BigInt(T6), Fe)), t2 = d3.add(t2, d3.multiply(d3.BigInt(x6), $e)), t2 = d3.add(t2, I5), N10 = Ji(t2, d3.BigInt(e8));
        const r2 = Li(t2, d3.BigInt(e8 * c3), f5);
        _5 = d3.toNumber(d3.divide(r2, d3.BigInt(e8))), I5 = Me, E4 = T6 = x6 = 0;
        break;
      }
      case "second": {
        const e8 = 1e9;
        let t2 = d3.multiply(d3.BigInt(E4), Ue);
        t2 = d3.add(t2, d3.multiply(d3.BigInt(T6), Fe)), t2 = d3.add(t2, d3.multiply(d3.BigInt(x6), $e)), t2 = d3.add(t2, I5), N10 = Ji(t2, d3.BigInt(e8));
        const r2 = Li(t2, d3.BigInt(e8 * c3), f5);
        E4 = d3.toNumber(d3.divide(r2, d3.BigInt(e8))), I5 = Me, T6 = x6 = 0;
        break;
      }
      case "millisecond": {
        const e8 = 1e6;
        let t2 = d3.multiply(d3.BigInt(T6), Fe);
        t2 = d3.add(t2, d3.multiply(d3.BigInt(x6), $e)), t2 = d3.add(t2, I5), N10 = Ji(t2, d3.BigInt(e8));
        const r2 = Li(t2, d3.BigInt(e8 * c3), f5);
        T6 = d3.toNumber(d3.divide(r2, d3.BigInt(e8))), I5 = Me, x6 = 0;
        break;
      }
      case "microsecond": {
        const e8 = 1e3;
        let t2 = d3.multiply(d3.BigInt(x6), $e);
        t2 = d3.add(t2, I5), N10 = Ji(t2, d3.BigInt(e8));
        const r2 = Li(t2, d3.BigInt(e8 * c3), f5);
        x6 = d3.toNumber(d3.divide(r2, d3.BigInt(e8))), I5 = Me;
        break;
      }
      case "nanosecond":
        N10 = d3.toNumber(I5), I5 = Li(d3.BigInt(I5), d3.BigInt(c3), f5);
    }
    return { years: y5, months: g5, weeks: v6, days: w5, hours: b7, minutes: _5, seconds: E4, milliseconds: T6, microseconds: x6, nanoseconds: d3.toNumber(I5), total: N10 };
  }
  function zi(e7, t, r, n4, i4, o4) {
    for (const [a4, s3] of [[e7, n4], [t, i4], [r, o4]])
      if (a4 !== s3)
        return Xi(a4 - s3);
    return 0;
  }
  function Gi(e7, t) {
    let { quotient: r, remainder: n4 } = ht2(e7, t);
    return d3.lessThan(n4, Me) && (r = d3.subtract(r, Le), n4 = d3.add(n4, t)), { quotient: r, remainder: n4 };
  }
  function Hi(e7, t) {
    const { quotient: r, remainder: n4 } = ht2(e7, t);
    return tt3(n4) || !ft(e7) == !ft(t) ? r : d3.subtract(r, Le);
  }
  function Ji(e7, t) {
    const { quotient: r, remainder: n4 } = ht2(e7, t);
    return d3.toNumber(r) + d3.toNumber(n4) / d3.toNumber(t);
  }
  function Vi(e7) {
    const t = Qi(e7);
    return void 0 !== globalThis.BigInt ? globalThis.BigInt(t.toString(10)) : t;
  }
  function Qi(e7) {
    let t = e7;
    if ("object" == typeof e7) {
      const r = e7[Symbol.toPrimitive];
      r && "function" == typeof r && (t = Ce(r, e7, ["number"]));
    }
    if ("number" == typeof t)
      throw new TypeError("cannot convert number to bigint");
    return "bigint" == typeof t ? d3.BigInt(t.toString(10)) : d3.BigInt(t);
  }
  var Zi = (() => {
    let e7 = d3.BigInt(Date.now() % 1e6);
    return () => {
      const t = d3.BigInt(Date.now()), r = d3.add(d3.multiply(t, Fe), e7);
      return e7 = d3.remainder(t, Fe), d3.greaterThan(r, He) ? He : d3.lessThan(r, Ge) ? Ge : r;
    };
  })();
  function Ki() {
    return new we().resolvedOptions().timeZone;
  }
  function Xi(e7) {
    return e7 < 0 ? -1 : e7 > 0 ? 1 : e7;
  }
  function eo(e7) {
    if (void 0 === e7)
      return Ne(null);
    if (it2(e7) && null !== e7)
      return e7;
    throw new TypeError("Options parameter must be an object, not " + (null === e7 ? "null" : typeof e7));
  }
  function to(e7, t) {
    const r = Ne(null);
    return r[e7] = t, r;
  }
  function ro(e7) {
    const t = Ne(null);
    return St2(t, eo(e7), []), t;
  }
  function no(e7, t, r, n4) {
    let i4 = e7[t];
    if (void 0 !== i4) {
      if (i4 = lt2(i4), !r.includes(i4))
        throw new RangeError(`${t} must be one of ${r.join(", ")}, not ${i4}`);
      return i4;
    }
    return n4;
  }
  function io(e7) {
    return et3.includes(oo(e7));
  }
  function oo(e7) {
    return e7.replace(/[A-Z]/g, (e8) => {
      const t = e8.charCodeAt(0);
      return String.fromCharCode(t + 32);
    });
  }
  var ao = new RegExp(`^${se.source}$`);
  function so(e7, t, r, n4 = e7(t), i4 = e7(r)) {
    let o4 = d3.BigInt(t), a4 = d3.BigInt(r), s3 = n4, l6 = i4;
    for (; d3.greaterThan(d3.subtract(a4, o4), Le); ) {
      const t2 = d3.divide(d3.add(o4, a4), d3.BigInt(2)), r2 = e7(t2);
      if (r2 === s3)
        o4 = t2, s3 = r2;
      else {
        if (r2 !== l6)
          throw new Error(`invalid state in bisection ${s3} - ${r2} - ${l6}`);
        a4 = t2, l6 = r2;
      }
    }
    return a4;
  }
  var lo = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
  var uo = Symbol("date");
  var co = Symbol("ym");
  var ho = Symbol("md");
  var fo = Symbol("time");
  var po = Symbol("datetime");
  var mo = Symbol("instant");
  var yo = Symbol("original");
  var go = Symbol("timezone");
  var vo = Symbol("calendar-id");
  var wo = Symbol("locale");
  var bo = Symbol("options");
  var _o = (e7) => ({ value: e7, enumerable: true, writable: false, configurable: true });
  var Eo = globalThis.Intl.DateTimeFormat;
  var To = Object.assign;
  var xo = Object.prototype.hasOwnProperty;
  var Io = Reflect.apply;
  function So(e7, t) {
    let r = e7[t];
    return "function" == typeof r && (r = new Eo(e7[wo], r(e7[bo])), e7[t] = r), r;
  }
  function Ro(e7, t = {}) {
    if (!(this instanceof Ro))
      return new Ro(e7, t);
    const r = void 0 !== t, n4 = r ? To({}, t) : {}, i4 = new Eo(e7, n4), o4 = i4.resolvedOptions();
    if (r) {
      const e8 = To({}, o4);
      for (const t2 in e8)
        Io(xo, n4, [t2]) || delete e8[t2];
      this[bo] = e8;
    } else
      this[bo] = n4;
    this[wo] = o4.locale, this[yo] = i4, this[go] = o4.timeZone, this[vo] = o4.calendar, this[uo] = Ao, this[co] = Oo, this[ho] = Co, this[fo] = No, this[po] = Mo, this[mo] = Lo;
  }
  Object.defineProperty(Ro, "name", { writable: true, value: "DateTimeFormat" }), Ro.supportedLocalesOf = function(e7, t) {
    return Eo.supportedLocalesOf(e7, t);
  };
  var ko = { resolvedOptions: _o(function() {
    return this[yo].resolvedOptions();
  }), format: _o(function(e7, ...t) {
    let { instant: r, formatter: n4 } = Uo(e7, this);
    return r && n4 ? n4.format(r.epochMilliseconds) : this[yo].format(e7, ...t);
  }), formatRange: _o(function(e7, t) {
    if ($o(e7) || $o(t)) {
      if (!Fo(e7, t))
        throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
      const { instant: r, formatter: n4 } = Uo(e7, this), { instant: i4, formatter: o4 } = Uo(t, this);
      if (r && i4 && n4 && o4 && n4 === o4)
        return n4.formatRange(r.epochMilliseconds, i4.epochMilliseconds);
    }
    return this[yo].formatRange(e7, t);
  }) };
  "formatToParts" in Eo.prototype && (ko.formatToParts = _o(function(e7, ...t) {
    let { instant: r, formatter: n4 } = Uo(e7, this);
    return r && n4 ? n4.formatToParts(r.epochMilliseconds) : this[yo].formatToParts(e7, ...t);
  })), "formatRangeToParts" in Eo.prototype && (ko.formatRangeToParts = _o(function(e7, t) {
    if ($o(e7) || $o(t)) {
      if (!Fo(e7, t))
        throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
      const { instant: r, formatter: n4 } = Uo(e7, this), { instant: i4, formatter: o4 } = Uo(t, this);
      if (r && i4 && n4 && o4 && n4 === o4)
        return n4.formatRangeToParts(r.epochMilliseconds, i4.epochMilliseconds);
    }
    return this[yo].formatRangeToParts(e7, t);
  })), Ro.prototype = Object.create(Eo.prototype, ko), Object.defineProperty(Ro, "prototype", { writable: false, enumerable: false, configurable: false });
  var jo = Ro;
  function Do(e7 = {}, t = {}) {
    const r = To({}, e7);
    for (const e8 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"])
      r[e8] = e8 in t ? t[e8] : r[e8], false !== r[e8] && void 0 !== r[e8] || delete r[e8];
    return r;
  }
  function No(e7) {
    let t = Do(e7, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
    return Bo(t) || (t = To({}, t, { hour: "numeric", minute: "numeric", second: "numeric" })), t;
  }
  function Oo(e7) {
    let t = Do(e7, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
    return "year" in t || "month" in t || (t = To(t, { year: "numeric", month: "numeric" })), t;
  }
  function Co(e7) {
    let t = Do(e7, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
    return "month" in t || "day" in t || (t = To({}, t, { month: "numeric", day: "numeric" })), t;
  }
  function Ao(e7) {
    let t = Do(e7, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
    return Po(t) || (t = To({}, t, { year: "numeric", month: "numeric", day: "numeric" })), t;
  }
  function Mo(e7) {
    let t = Do(e7, { timeZoneName: false });
    return Bo(t) || Po(t) || (t = To({}, t, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t;
  }
  function Lo(e7) {
    let t = e7;
    return Bo(t) || Po(t) || (t = To({}, t, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t;
  }
  function Po(e7) {
    return "year" in e7 || "month" in e7 || "day" in e7 || "weekday" in e7 || "dateStyle" in e7;
  }
  function Bo(e7) {
    return "hour" in e7 || "minute" in e7 || "second" in e7 || "timeStyle" in e7 || "dayPeriod" in e7;
  }
  function $o(e7) {
    return Nt2(e7) || Ot2(e7) || Ct(e7) || Lt2(e7) || At(e7) || Mt2(e7) || Rt(e7);
  }
  function Fo(e7, t) {
    return !(!$o(e7) || !$o(t) || Ot2(e7) && !Ot2(t) || Nt2(e7) && !Nt2(t) || Ct(e7) && !Ct(t) || Lt2(e7) && !Lt2(t) || At(e7) && !At(t) || Mt2(e7) && !Mt2(t) || Rt(e7) && !Rt(t));
  }
  function Uo(e7, t) {
    const r = m4("%Temporal.PlainDateTime%");
    if (Ot2(e7)) {
      const n4 = new r(1970, 1, 1, K3(e7, T4), K3(e7, x4), K3(e7, I3), K3(e7, S4), K3(e7, R4), K3(e7, k4), t[vo]);
      return { instant: fn(t[go], n4, "compatible"), formatter: So(t, fo) };
    }
    if (At(e7)) {
      const n4 = K3(e7, b4), i4 = K3(e7, _4), o4 = K3(e7, E2), a4 = Vr(K3(e7, j4));
      if (a4 !== t[vo])
        throw new RangeError(`cannot format PlainYearMonth with calendar ${a4} in locale with calendar ${t[vo]}`);
      const s3 = new r(n4, i4, o4, 12, 0, 0, 0, 0, 0, a4);
      return { instant: fn(t[go], s3, "compatible"), formatter: So(t, co) };
    }
    if (Mt2(e7)) {
      const n4 = K3(e7, b4), i4 = K3(e7, _4), o4 = K3(e7, E2), a4 = Vr(K3(e7, j4));
      if (a4 !== t[vo])
        throw new RangeError(`cannot format PlainMonthDay with calendar ${a4} in locale with calendar ${t[vo]}`);
      const s3 = new r(n4, i4, o4, 12, 0, 0, 0, 0, 0, a4);
      return { instant: fn(t[go], s3, "compatible"), formatter: So(t, ho) };
    }
    if (Nt2(e7)) {
      const n4 = K3(e7, b4), i4 = K3(e7, _4), o4 = K3(e7, E2), a4 = Vr(K3(e7, j4));
      if ("iso8601" !== a4 && a4 !== t[vo])
        throw new RangeError(`cannot format PlainDate with calendar ${a4} in locale with calendar ${t[vo]}`);
      const s3 = new r(n4, i4, o4, 12, 0, 0, 0, 0, 0, t[vo]);
      return { instant: fn(t[go], s3, "compatible"), formatter: So(t, uo) };
    }
    if (Ct(e7)) {
      const n4 = K3(e7, b4), i4 = K3(e7, _4), o4 = K3(e7, E2), a4 = K3(e7, T4), s3 = K3(e7, x4), l6 = K3(e7, I3), u4 = K3(e7, S4), c3 = K3(e7, R4), d5 = K3(e7, k4), h6 = Vr(K3(e7, j4));
      if ("iso8601" !== h6 && h6 !== t[vo])
        throw new RangeError(`cannot format PlainDateTime with calendar ${h6} in locale with calendar ${t[vo]}`);
      let f5 = e7;
      return "iso8601" === h6 && (f5 = new r(n4, i4, o4, a4, s3, l6, u4, c3, d5, t[vo])), { instant: fn(t[go], f5, "compatible"), formatter: So(t, po) };
    }
    if (Lt2(e7))
      throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
    return Rt(e7) ? { instant: e7, formatter: So(t, mo) } : {};
  }
  var qo = class {
    constructor(e7) {
      if (arguments.length < 1)
        throw new TypeError("missing argument: epochNanoseconds is required");
      const t = Qi(e7);
      ci(t), Q4(this), X4(this, v4, t);
    }
    get epochSeconds() {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, v4);
      return d3.toNumber(Hi(e7, Ue));
    }
    get epochMilliseconds() {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      const e7 = d3.BigInt(K3(this, v4));
      return d3.toNumber(Hi(e7, Fe));
    }
    get epochMicroseconds() {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return Vi(Hi(d3.BigInt(K3(this, v4)), $e));
    }
    get epochNanoseconds() {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return Vi(d3.BigInt(K3(this, v4)));
    }
    add(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return Ni("add", this, e7);
    }
    subtract(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return Ni("subtract", this, e7);
    }
    until(e7, t) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return vi("until", this, e7, t);
    }
    since(e7, t) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return vi("since", this, e7, t);
    }
    round(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e7)
        throw new TypeError("options parameter is required");
      const t = "string" == typeof e7 ? to("smallestUnit", e7) : eo(e7), r = Zt(t), n4 = Jt2(t, "halfExpand"), i4 = rr(t, "smallestUnit", "time", tr);
      Kt2(r, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[i4], true);
      const o4 = Pi(K3(this, v4), r, i4, n4);
      return new qo(o4);
    }
    equals(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      const t = hr(e7), r = K3(this, v4), n4 = K3(t, v4);
      return d3.equal(d3.BigInt(r), d3.BigInt(n4));
    }
    toString(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      const t = eo(e7), r = Xt(t), n4 = Jt2(t, "trunc"), i4 = rr(t, "smallestUnit", "time", void 0);
      if ("hour" === i4)
        throw new RangeError('smallestUnit must be a time unit other than "hour"');
      let o4 = t.timeZone;
      void 0 !== o4 && (o4 = nn(o4));
      const { precision: a4, unit: s3, increment: l6 } = er(i4, r), u4 = Pi(K3(this, v4), l6, s3, n4);
      return wn(new qo(u4), o4, a4);
    }
    toJSON() {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return wn(this, void 0, "auto");
    }
    toLocaleString(e7, t) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.Instant");
    }
    toZonedDateTime(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument in toZonedDateTime");
      const t = e7.calendar;
      if (void 0 === t)
        throw new TypeError("missing calendar property in toZonedDateTime");
      const r = Hr(t), n4 = e7.timeZone;
      if (void 0 === n4)
        throw new TypeError("missing timeZone property in toZonedDateTime");
      const i4 = nn(n4);
      return Rr(K3(this, v4), i4, r);
    }
    toZonedDateTimeISO(e7) {
      if (!Rt(this))
        throw new TypeError("invalid receiver");
      const t = nn(e7);
      return Rr(K3(this, v4), t, "iso8601");
    }
    static fromEpochSeconds(e7) {
      const t = ot2(e7), r = d3.multiply(d3.BigInt(t), Ue);
      return ci(r), new qo(r);
    }
    static fromEpochMilliseconds(e7) {
      const t = ot2(e7), r = d3.multiply(d3.BigInt(t), Fe);
      return ci(r), new qo(r);
    }
    static fromEpochMicroseconds(e7) {
      const t = Qi(e7), r = d3.multiply(t, $e);
      return ci(r), new qo(r);
    }
    static fromEpochNanoseconds(e7) {
      const t = Qi(e7);
      return ci(t), new qo(t);
    }
    static from(e7) {
      return Rt(e7) ? new qo(K3(e7, v4)) : hr(e7);
    }
    static compare(e7, t) {
      const r = hr(e7), n4 = hr(t), i4 = K3(r, v4), o4 = K3(n4, v4);
      return d3.lessThan(i4, o4) ? -1 : d3.greaterThan(i4, o4) ? 1 : 0;
    }
  };
  f3(qo, "Temporal.Instant");
  var Yo = Array.prototype.includes;
  var Wo = Array.prototype.push;
  var zo = globalThis.Intl.DateTimeFormat;
  var Go = Array.prototype.sort;
  var Ho = Math.abs;
  var Jo = Math.floor;
  var Vo = Object.create;
  var Qo = Object.entries;
  var Zo = Set;
  var Ko = Reflect.ownKeys;
  var Xo = Set.prototype.add;
  var ea = Set.prototype.values;
  var ta = {};
  var ra = class {
    constructor(e7) {
      if (arguments.length < 1)
        throw new RangeError("missing argument: id is required");
      const t = lt2(e7);
      if (!io(t))
        throw new RangeError(`invalid calendar identifier ${t}`);
      Q4(this), X4(this, z4, oo(t));
    }
    get id() {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return K3(this, z4);
    }
    dateFromFields(e7, t) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid fields");
      const r = eo(t), n4 = K3(this, z4);
      return ta[n4].dateFromFields(e7, r, n4);
    }
    yearMonthFromFields(e7, t) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid fields");
      const r = eo(t), n4 = K3(this, z4);
      return ta[n4].yearMonthFromFields(e7, r, n4);
    }
    monthDayFromFields(e7, t) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid fields");
      const r = eo(t), n4 = K3(this, z4);
      return ta[n4].monthDayFromFields(e7, r, n4);
    }
    fields(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = [], r = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
      for (const n4 of e7) {
        if ("string" != typeof n4)
          throw new TypeError("invalid fields");
        if (!r.has(n4))
          throw new RangeError(`invalid field name ${n4}`);
        r.delete(n4), Wo.call(t, n4);
      }
      return ta[K3(this, z4)].fields(t);
    }
    mergeFields(e7, t) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const r = It2(e7), n4 = Vo(null);
      St2(n4, r, [], [void 0]);
      const i4 = It2(t), o4 = Vo(null);
      St2(o4, i4, [], [void 0]);
      const a4 = Ko(o4), s3 = ta[K3(this, z4)].fieldKeysToIgnore(a4), l6 = Vo(null), u4 = Ko(n4);
      for (const e8 of u4) {
        let t2;
        t2 = nt3(Yo, s3, [e8]) ? o4[e8] : n4[e8], void 0 !== t2 && (l6[e8] = t2);
      }
      return St2(l6, o4, []), l6;
    }
    dateAdd(e7, t, r) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const n4 = lr(e7), i4 = dr(t), o4 = Gt(eo(r)), { days: a4 } = Zn(K3(i4, B4), K3(i4, $3), K3(i4, F3), K3(i4, U5), K3(i4, q4), K3(i4, Y4), K3(i4, W3), "day"), s3 = K3(this, z4);
      return ta[s3].dateAdd(n4, K3(i4, M4), K3(i4, L3), K3(i4, P4), a4, o4, s3);
    }
    dateUntil(e7, t, r) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const n4 = lr(e7), i4 = lr(t);
      let o4 = rr(eo(r), "largestUnit", "date", "auto");
      "auto" === o4 && (o4 = "day");
      const { years: a4, months: s3, weeks: l6, days: u4 } = ta[K3(this, z4)].dateUntil(n4, i4, o4);
      return new (m4("%Temporal.Duration%"))(a4, s3, l6, u4, 0, 0, 0, 0, 0, 0);
    }
    year(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].year(t);
    }
    month(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      if (Mt2(t))
        throw new TypeError("use monthCode on PlainMonthDay instead");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].month(t);
    }
    monthCode(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || Mt2(t) || (t = lr(t)), ta[K3(this, z4)].monthCode(t);
    }
    day(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return Mt2(t) || (t = lr(t)), ta[K3(this, z4)].day(t);
    }
    era(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].era(t);
    }
    eraYear(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].eraYear(t);
    }
    dayOfWeek(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      return ta[K3(this, z4)].dayOfWeek(t);
    }
    dayOfYear(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      return ta[K3(this, z4)].dayOfYear(t);
    }
    weekOfYear(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      return ta[K3(this, z4)].weekOfYear(t);
    }
    yearOfWeek(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      return ta[K3(this, z4)].yearOfWeek(t);
    }
    daysInWeek(e7) {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      return ta[K3(this, z4)].daysInWeek(t);
    }
    daysInMonth(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].daysInMonth(t);
    }
    daysInYear(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].daysInYear(t);
    }
    monthsInYear(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].monthsInYear(t);
    }
    inLeapYear(e7) {
      let t = e7;
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return At(t) || (t = lr(t)), ta[K3(this, z4)].inLeapYear(t);
    }
    toString() {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return K3(this, z4);
    }
    toJSON() {
      if (!jt(this))
        throw new TypeError("invalid receiver");
      return K3(this, z4);
    }
    static from(e7) {
      return Qr(Hr(e7));
    }
  };
  function na(e7) {
    if (!e7.startsWith("M"))
      throw new RangeError(`Invalid month code: ${e7}.  Month codes must start with M.`);
    const t = +e7.slice(1);
    if (isNaN(t))
      throw new RangeError(`Invalid month code: ${e7}`);
    return t;
  }
  function ia(e7, t = false) {
    return `M${e7.toString().padStart(2, "0")}${t ? "L" : ""}`;
  }
  function oa(e7, t, r = 12) {
    let { month: n4, monthCode: i4 } = e7;
    if (void 0 === i4) {
      if (void 0 === n4)
        throw new TypeError("Either month or monthCode are required");
      "reject" === t && ii(n4, 1, r), "constrain" === t && (n4 = ri(n4, 1, r)), i4 = ia(n4);
    } else {
      const e8 = na(i4);
      if (void 0 !== n4 && n4 !== e8)
        throw new RangeError(`monthCode ${i4} and month ${n4} must match if both are present`);
      if (i4 !== ia(e8))
        throw new RangeError(`Invalid month code: ${i4}`);
      if (n4 = e8, n4 < 1 || n4 > r)
        throw new RangeError(`Invalid monthCode: ${i4}`);
    }
    return { ...e7, month: n4, monthCode: i4 };
  }
  f3(ra, "Temporal.Calendar"), p4("Temporal.Calendar.from", ra.from), p4("Temporal.Calendar.prototype.dateAdd", ra.prototype.dateAdd), p4("Temporal.Calendar.prototype.dateFromFields", ra.prototype.dateFromFields), p4("Temporal.Calendar.prototype.dateUntil", ra.prototype.dateUntil), p4("Temporal.Calendar.prototype.day", ra.prototype.day), p4("Temporal.Calendar.prototype.dayOfWeek", ra.prototype.dayOfWeek), p4("Temporal.Calendar.prototype.dayOfYear", ra.prototype.dayOfYear), p4("Temporal.Calendar.prototype.daysInMonth", ra.prototype.daysInMonth), p4("Temporal.Calendar.prototype.daysInWeek", ra.prototype.daysInWeek), p4("Temporal.Calendar.prototype.daysInYear", ra.prototype.daysInYear), p4("Temporal.Calendar.prototype.era", ra.prototype.era), p4("Temporal.Calendar.prototype.eraYear", ra.prototype.eraYear), p4("Temporal.Calendar.prototype.fields", ra.prototype.fields), p4("Temporal.Calendar.prototype.inLeapYear", ra.prototype.inLeapYear), p4("Temporal.Calendar.prototype.mergeFields", ra.prototype.mergeFields), p4("Temporal.Calendar.prototype.month", ra.prototype.month), p4("Temporal.Calendar.prototype.monthCode", ra.prototype.monthCode), p4("Temporal.Calendar.prototype.monthDayFromFields", ra.prototype.monthDayFromFields), p4("Temporal.Calendar.prototype.monthsInYear", ra.prototype.monthsInYear), p4("Temporal.Calendar.prototype.weekOfYear", ra.prototype.weekOfYear), p4("Temporal.Calendar.prototype.year", ra.prototype.year), p4("Temporal.Calendar.prototype.yearMonthFromFields", ra.prototype.yearMonthFromFields), p4("Temporal.Calendar.prototype.yearOfWeek", ra.prototype.yearOfWeek), ta.iso8601 = { dateFromFields(e7, t, r) {
    let n4 = ar(e7, ["day", "month", "monthCode", "year"], ["year", "day"]);
    const i4 = Gt(t);
    n4 = oa(n4);
    let { year: o4, month: a4, day: s3 } = n4;
    return { year: o4, month: a4, day: s3 } = Yt(o4, a4, s3, i4), wr(o4, a4, s3, r);
  }, yearMonthFromFields(e7, t, r) {
    let n4 = ar(e7, ["month", "monthCode", "year"], ["year"]);
    const i4 = Gt(t);
    n4 = oa(n4);
    let { year: o4, month: a4 } = n4;
    return { year: o4, month: a4 } = function(e8, t2, r2) {
      let n5 = e8, i5 = t2;
      switch (r2) {
        case "reject":
          oi(n5, i5, 1);
          break;
        case "constrain":
          ({ year: n5, month: i5 } = ni(n5, i5));
      }
      return { year: n5, month: i5 };
    }(o4, a4, i4), Ir(o4, a4, r, 1);
  }, monthDayFromFields(e7, t, r) {
    let n4 = ar(e7, ["day", "month", "monthCode", "year"], ["day"]);
    const i4 = Gt(t);
    if (void 0 !== n4.month && void 0 === n4.year && void 0 === n4.monthCode)
      throw new TypeError("either year or monthCode required with month");
    const o4 = void 0 === n4.monthCode;
    n4 = oa(n4);
    let { month: a4, day: s3, year: l6 } = n4;
    return { month: a4, day: s3 } = Yt(o4 ? l6 : 1972, a4, s3, i4), Tr(a4, s3, r, 1972);
  }, fields: (e7) => e7, fieldKeysToIgnore(e7) {
    const t = new Zo();
    for (let r = 0; r < e7.length; r++) {
      const n4 = e7[r];
      nt3(Xo, t, [n4]), "month" === n4 ? nt3(Xo, t, ["monthCode"]) : "monthCode" === n4 && nt3(Xo, t, ["month"]);
    }
    return [...nt3(ea, t, [])];
  }, dateAdd(e7, t, r, n4, i4, o4, a4) {
    let s3 = K3(e7, b4), l6 = K3(e7, _4), u4 = K3(e7, E2);
    return { year: s3, month: l6, day: u4 } = xi(s3, l6, u4, t, r, n4, i4, o4), wr(s3, l6, u4, a4);
  }, dateUntil: (e7, t, r) => hi(K3(e7, b4), K3(e7, _4), K3(e7, E2), K3(t, b4), K3(t, _4), K3(t, E2), r), year: (e7) => K3(e7, b4), era() {
  }, eraYear() {
  }, month: (e7) => K3(e7, _4), monthCode: (e7) => ia(K3(e7, _4)), day: (e7) => K3(e7, E2), dayOfWeek: (e7) => Un(K3(e7, b4), K3(e7, _4), K3(e7, E2)), dayOfYear: (e7) => qn(K3(e7, b4), K3(e7, _4), K3(e7, E2)), weekOfYear: (e7) => Yn(K3(e7, b4), K3(e7, _4), K3(e7, E2)).week, yearOfWeek: (e7) => Yn(K3(e7, b4), K3(e7, _4), K3(e7, E2)).year, daysInWeek: () => 7, daysInMonth: (e7) => Fn(K3(e7, b4), K3(e7, _4)), daysInYear(e7) {
    let t = e7;
    return Z4(t, b4) || (t = lr(t)), $n(K3(t, b4)) ? 366 : 365;
  }, monthsInYear: () => 12, inLeapYear(e7) {
    let t = e7;
    return Z4(t, b4) || (t = lr(t)), $n(K3(t, b4));
  } };
  var aa = class {
    constructor(e7) {
      if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e7) {
        let t = 0;
        for (const r of e7.map.entries()) {
          if (++t > aa.MAX_CACHE_ENTRIES)
            break;
          this.map.set(...r);
        }
      }
    }
    get(e7) {
      const t = this.map.get(e7);
      return t && (this.hits++, this.report()), this.calls++, t;
    }
    set(e7, t) {
      this.map.set(e7, t), this.misses++, this.report();
    }
    report() {
    }
    setObject(e7) {
      if (aa.objectMap.get(e7))
        throw new RangeError("object already cached");
      aa.objectMap.set(e7, this), this.report();
    }
    static getCacheForObject(e7) {
      let t = aa.objectMap.get(e7);
      return t || (t = new aa(), aa.objectMap.set(e7, t)), t;
    }
  };
  function sa({ isoYear: e7, isoMonth: t, isoDay: r }) {
    return `${yn(e7)}-${gn(t)}-${gn(r)}T00:00Z`;
  }
  function la(e7, t) {
    return { years: e7.year - t.year, months: e7.month - t.month, days: e7.day - t.day };
  }
  aa.objectMap = /* @__PURE__ */ new WeakMap(), aa.MAX_CACHE_ENTRIES = 1e3;
  var ua = class {
    constructor() {
      this.eraLength = "short", this.hasEra = true, this.erasBeginMidYear = false;
    }
    getFormatter() {
      return void 0 === this.formatter && (this.formatter = new zo(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
    }
    isoToCalendarDate(e7, t) {
      const { year: r, month: n4, day: i4 } = e7, o4 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r, isoMonth: n4, isoDay: i4, id: this.id }), a4 = t.get(o4);
      if (a4)
        return a4;
      const s3 = this.getFormatter();
      let l6, u4;
      try {
        u4 = sa({ isoYear: r, isoMonth: n4, isoDay: i4 }), l6 = s3.formatToParts(new Date(u4));
      } catch (e8) {
        throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r, isoMonth: n4, isoDay: i4 })}`);
      }
      const c3 = {};
      for (let { type: e8, value: t2 } of l6) {
        if ("year" === e8 && (c3.eraYear = +t2), "relatedYear" === e8 && (c3.eraYear = +t2), "month" === e8) {
          const e9 = /^([0-9]*)(.*?)$/.exec(t2);
          if (!e9 || 3 != e9.length || !e9[1] && !e9[2])
            throw new RangeError(`Unexpected month: ${t2}`);
          if (c3.month = e9[1] ? +e9[1] : 1, c3.month < 1)
            throw new RangeError(`Invalid month ${t2} from ${u4}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
          if (c3.month > 13)
            throw new RangeError(`Invalid month ${t2} from ${u4}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
          e9[2] && (c3.monthExtra = e9[2]);
        }
        "day" === e8 && (c3.day = +t2), this.hasEra && "era" === e8 && null != t2 && "" !== t2 && (t2 = t2.split(" (")[0], c3.era = t2.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
      }
      if (void 0 === c3.eraYear)
        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      if (this.reviseIntlEra) {
        const { era: t2, eraYear: r2 } = this.reviseIntlEra(c3, e7);
        c3.era = t2, c3.eraYear = r2;
      }
      this.checkIcuBugs && this.checkIcuBugs(e7);
      const d5 = this.adjustCalendarDate(c3, t, "constrain", true);
      if (void 0 === d5.year)
        throw new RangeError(`Missing year converting ${JSON.stringify(e7)}`);
      if (void 0 === d5.month)
        throw new RangeError(`Missing month converting ${JSON.stringify(e7)}`);
      if (void 0 === d5.day)
        throw new RangeError(`Missing day converting ${JSON.stringify(e7)}`);
      return t.set(o4, d5), ["constrain", "reject"].forEach((r2) => {
        const n5 = JSON.stringify({ func: "calendarToIsoDate", year: d5.year, month: d5.month, day: d5.day, overflow: r2, id: this.id });
        t.set(n5, e7);
      }), d5;
    }
    validateCalendarDate(e7) {
      const { era: t, month: r, year: n4, day: i4, eraYear: o4, monthCode: a4, monthExtra: s3 } = e7;
      if (void 0 !== s3)
        throw new RangeError("Unexpected `monthExtra` value");
      if (void 0 === n4 && void 0 === o4)
        throw new TypeError("year or eraYear is required");
      if (void 0 === r && void 0 === a4)
        throw new TypeError("month or monthCode is required");
      if (void 0 === i4)
        throw new RangeError("Missing day");
      if (void 0 !== a4) {
        if ("string" != typeof a4)
          throw new RangeError("monthCode must be a string, not " + typeof a4);
        if (!/^M([01]?\d)(L?)$/.test(a4))
          throw new RangeError(`Invalid monthCode: ${a4}`);
      }
      if (this.constantEra) {
        if (void 0 !== t && t !== this.constantEra)
          throw new RangeError(`era must be ${this.constantEra}, not ${t}`);
        if (void 0 !== o4 && void 0 !== n4 && o4 !== n4)
          throw new RangeError(`eraYear ${o4} does not match year ${n4}`);
      }
      if (this.hasEra && void 0 === e7.era != (void 0 === e7.eraYear))
        throw new RangeError("properties 'era' and 'eraYear' must be provided together");
    }
    adjustCalendarDate(e7, t, r = "constrain", n4 = false) {
      if ("lunisolar" === this.calendarType)
        throw new RangeError("Override required for lunisolar calendars");
      let i4 = e7;
      if (this.validateCalendarDate(i4), this.constantEra) {
        const { year: e8, eraYear: t2 } = i4;
        i4 = { ...i4, era: this.constantEra, year: void 0 !== e8 ? e8 : t2, eraYear: void 0 !== t2 ? t2 : e8 };
      }
      const o4 = this.monthsInYear(i4, t);
      let { month: a4, monthCode: s3 } = i4;
      return { month: a4, monthCode: s3 } = oa(i4, r, o4), { ...i4, month: a4, monthCode: s3 };
    }
    regulateMonthDayNaive(e7, t, r) {
      const n4 = this.monthsInYear(e7, r);
      let { month: i4, day: o4 } = e7;
      return "reject" === t ? (ii(i4, 1, n4), ii(o4, 1, this.maximumMonthLength(e7))) : (i4 = ri(i4, 1, n4), o4 = ri(o4, 1, this.maximumMonthLength({ ...e7, month: i4 }))), { ...e7, month: i4, day: o4 };
    }
    calendarToIsoDate(e7, t = "constrain", r) {
      const n4 = e7;
      let i4 = this.adjustCalendarDate(e7, r, t, false);
      i4 = this.regulateMonthDayNaive(i4, t, r);
      const { year: o4, month: a4, day: s3 } = i4, l6 = JSON.stringify({ func: "calendarToIsoDate", year: o4, month: a4, day: s3, overflow: t, id: this.id });
      let u4, c3 = r.get(l6);
      if (c3)
        return c3;
      if (void 0 !== n4.year && void 0 !== n4.month && void 0 !== n4.day && (n4.year !== i4.year || n4.month !== i4.month || n4.day !== i4.day) && (u4 = JSON.stringify({ func: "calendarToIsoDate", year: n4.year, month: n4.month, day: n4.day, overflow: t, id: this.id }), c3 = r.get(u4), c3))
        return c3;
      let d5 = this.estimateIsoDate({ year: o4, month: a4, day: s3 });
      const h6 = (e8) => {
        let n5 = this.addDaysIso(d5, e8);
        if (i4.day > this.minimumMonthLength(i4)) {
          let e9 = this.isoToCalendarDate(n5, r);
          for (; e9.month !== a4 || e9.year !== o4; ) {
            if ("reject" === t)
              throw new RangeError(`day ${s3} does not exist in month ${a4} of year ${o4}`);
            n5 = this.addDaysIso(n5, -1), e9 = this.isoToCalendarDate(n5, r);
          }
        }
        return n5;
      };
      let f5 = 0, p6 = this.isoToCalendarDate(d5, r), m5 = la(i4, p6);
      if (0 !== m5.years || 0 !== m5.months || 0 !== m5.days) {
        const e8 = 365 * m5.years + 30 * m5.months + m5.days;
        d5 = this.addDaysIso(d5, e8), p6 = this.isoToCalendarDate(d5, r), m5 = la(i4, p6), 0 === m5.years && 0 === m5.months ? d5 = h6(m5.days) : f5 = this.compareCalendarDates(i4, p6);
      }
      let y5 = 8;
      for (; f5; ) {
        d5 = this.addDaysIso(d5, f5 * y5);
        const e8 = p6;
        p6 = this.isoToCalendarDate(d5, r);
        const o5 = f5;
        if (f5 = this.compareCalendarDates(i4, p6), f5) {
          if (m5 = la(i4, p6), 0 === m5.years && 0 === m5.months)
            d5 = h6(m5.days), f5 = 0;
          else if (o5 && f5 !== o5)
            if (y5 > 1)
              y5 /= 2;
            else {
              if ("reject" === t)
                throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...n4 })}`);
              this.compareCalendarDates(p6, e8) > 0 && (d5 = this.addDaysIso(d5, -1)), f5 = 0;
            }
        }
      }
      if (r.set(l6, d5), u4 && r.set(u4, d5), void 0 === i4.year || void 0 === i4.month || void 0 === i4.day || void 0 === i4.monthCode || this.hasEra && (void 0 === i4.era || void 0 === i4.eraYear))
        throw new RangeError("Unexpected missing property");
      return d5;
    }
    temporalToCalendarDate(e7, t) {
      const r = { year: K3(e7, b4), month: K3(e7, _4), day: K3(e7, E2) };
      return this.isoToCalendarDate(r, t);
    }
    compareCalendarDates(e7, t) {
      const r = ar(e7, ["day", "month", "year"], ["day", "month", "year"]), n4 = ar(t, ["day", "month", "year"], ["day", "month", "year"]);
      return r.year !== n4.year ? Xi(r.year - n4.year) : r.month !== n4.month ? Xi(r.month - n4.month) : r.day !== n4.day ? Xi(r.day - n4.day) : 0;
    }
    regulateDate(e7, t = "constrain", r) {
      const n4 = this.calendarToIsoDate(e7, t, r);
      return this.isoToCalendarDate(n4, r);
    }
    addDaysIso(e7, t) {
      return xi(e7.year, e7.month, e7.day, 0, 0, 0, t, "constrain");
    }
    addDaysCalendar(e7, t, r) {
      const n4 = this.calendarToIsoDate(e7, "constrain", r), i4 = this.addDaysIso(n4, t);
      return this.isoToCalendarDate(i4, r);
    }
    addMonthsCalendar(e7, t, r, n4) {
      let i4 = e7;
      const { day: o4 } = i4;
      for (let e8 = 0, r2 = Ho(t); e8 < r2; e8++) {
        const { month: e9 } = i4, r3 = i4, a4 = t < 0 ? -Math.max(o4, this.daysInPreviousMonth(i4, n4)) : this.daysInMonth(i4, n4), s3 = this.calendarToIsoDate(i4, "constrain", n4);
        let l6 = this.addDaysIso(s3, a4);
        if (i4 = this.isoToCalendarDate(l6, n4), t > 0) {
          const t2 = this.monthsInYear(r3, n4);
          for (; i4.month - 1 != e9 % t2; )
            l6 = this.addDaysIso(l6, -1), i4 = this.isoToCalendarDate(l6, n4);
        }
        i4.day !== o4 && (i4 = this.regulateDate({ ...i4, day: o4 }, "constrain", n4));
      }
      if ("reject" === r && i4.day !== o4)
        throw new RangeError(`Day ${o4} does not exist in resulting calendar month`);
      return i4;
    }
    addCalendar(e7, { years: t = 0, months: r = 0, weeks: n4 = 0, days: i4 = 0 }, o4, a4) {
      const { year: s3, day: l6, monthCode: u4 } = e7, c3 = this.adjustCalendarDate({ year: s3 + t, monthCode: u4, day: l6 }, a4), d5 = this.addMonthsCalendar(c3, r, o4, a4), h6 = i4 + 7 * n4;
      return this.addDaysCalendar(d5, h6, a4);
    }
    untilCalendar(e7, t, r, n4) {
      let i4 = 0, o4 = 0, a4 = 0, s3 = 0;
      switch (r) {
        case "day":
          i4 = this.calendarDaysUntil(e7, t, n4);
          break;
        case "week": {
          const r2 = this.calendarDaysUntil(e7, t, n4);
          i4 = r2 % 7, o4 = (r2 - i4) / 7;
          break;
        }
        case "month":
        case "year": {
          const o5 = this.compareCalendarDates(t, e7);
          if (!o5)
            return { years: 0, months: 0, weeks: 0, days: 0 };
          const l6 = t.year - e7.year, u4 = t.day - e7.day;
          if ("year" === r && l6) {
            let r2 = 0;
            t.monthCode > e7.monthCode && (r2 = 1), t.monthCode < e7.monthCode && (r2 = -1), r2 || (r2 = Math.sign(u4)), s3 = r2 * o5 < 0 ? l6 - o5 : l6;
          }
          let c3, d5 = s3 ? this.addCalendar(e7, { years: s3 }, "constrain", n4) : e7;
          do {
            a4 += o5, c3 = d5, d5 = this.addMonthsCalendar(c3, o5, "constrain", n4), d5.day !== e7.day && (d5 = this.regulateDate({ ...d5, day: e7.day }, "constrain", n4));
          } while (this.compareCalendarDates(t, d5) * o5 >= 0);
          a4 -= o5, i4 = this.calendarDaysUntil(c3, t, n4);
          break;
        }
      }
      return { years: s3, months: a4, weeks: o4, days: i4 };
    }
    daysInMonth(e7, t) {
      const { day: r } = e7, n4 = this.maximumMonthLength(e7), i4 = this.minimumMonthLength(e7);
      if (i4 === n4)
        return i4;
      const o4 = r <= n4 - i4 ? n4 : i4, a4 = this.calendarToIsoDate(e7, "constrain", t), s3 = this.addDaysIso(a4, o4), l6 = this.isoToCalendarDate(s3, t), u4 = this.addDaysIso(s3, -l6.day);
      return this.isoToCalendarDate(u4, t).day;
    }
    daysInPreviousMonth(e7, t) {
      const { day: r, month: n4, year: i4 } = e7;
      let o4 = { year: n4 > 1 ? i4 : i4 - 1, month: n4, day: 1 };
      const a4 = n4 > 1 ? n4 - 1 : this.monthsInYear(o4, t);
      o4 = { ...o4, month: a4 };
      const s3 = this.minimumMonthLength(o4), l6 = this.maximumMonthLength(o4);
      if (s3 === l6)
        return l6;
      const u4 = this.calendarToIsoDate(e7, "constrain", t), c3 = this.addDaysIso(u4, -r);
      return this.isoToCalendarDate(c3, t).day;
    }
    startOfCalendarYear(e7) {
      return { year: e7.year, month: 1, monthCode: "M01", day: 1 };
    }
    startOfCalendarMonth(e7) {
      return { year: e7.year, month: e7.month, day: 1 };
    }
    calendarDaysUntil(e7, t, r) {
      const n4 = this.calendarToIsoDate(e7, "constrain", r), i4 = this.calendarToIsoDate(t, "constrain", r);
      return this.isoDaysUntil(n4, i4);
    }
    isoDaysUntil(e7, t) {
      return hi(e7.year, e7.month, e7.day, t.year, t.month, t.day, "day").days;
    }
    monthDayFromFields(e7, t, r) {
      let n4, i4, o4, a4, s3, { monthCode: l6, day: u4 } = e7;
      if (void 0 === l6) {
        let { year: n5, era: i5, eraYear: o5 } = e7;
        if (void 0 === n5 && (void 0 === i5 || void 0 === o5))
          throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
        ({ monthCode: l6, day: u4 } = this.isoToCalendarDate(this.calendarToIsoDate(e7, t, r), r));
      }
      const c3 = this.isoToCalendarDate({ year: 1972, month: 12, day: 31 }, r), d5 = c3.monthCode > l6 || c3.monthCode === l6 && c3.day >= u4 ? c3.year : c3.year - 1;
      for (let e8 = 0; e8 < 100; e8++) {
        const c4 = this.adjustCalendarDate({ day: u4, monthCode: l6, year: d5 - e8 }, r), h6 = this.calendarToIsoDate(c4, "constrain", r), f5 = this.isoToCalendarDate(h6, r);
        if ({ year: n4, month: i4, day: o4 } = h6, f5.monthCode === l6 && f5.day === u4)
          return { month: i4, day: o4, year: n4 };
        "constrain" === t && (void 0 === a4 || f5.monthCode === a4.monthCode && f5.day > a4.day) && (a4 = f5, s3 = h6);
      }
      if ("constrain" === t && void 0 !== s3)
        return s3;
      throw new RangeError(`No recent ${this.id} year with monthCode ${l6} and day ${u4}`);
    }
  };
  var ca = class extends ua {
    constructor() {
      super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
    }
    inLeapYear(e7) {
      const { year: t } = e7;
      return (7 * t + 1) % 19 < 7;
    }
    monthsInYear(e7) {
      return this.inLeapYear(e7) ? 13 : 12;
    }
    minimumMonthLength(e7) {
      return this.minMaxMonthLength(e7, "min");
    }
    maximumMonthLength(e7) {
      return this.minMaxMonthLength(e7, "max");
    }
    minMaxMonthLength(e7, t) {
      const { month: r, year: n4 } = e7, i4 = this.getMonthCode(n4, r), o4 = Qo(this.months).find((e8) => e8[1].monthCode === i4);
      if (void 0 === o4)
        throw new RangeError(`unmatched Hebrew month: ${r}`);
      const a4 = o4[1].days;
      return "number" == typeof a4 ? a4 : a4[t];
    }
    estimateIsoDate(e7) {
      const { year: t } = e7;
      return { year: t - 3760, month: 1, day: 1 };
    }
    getMonthCode(e7, t) {
      return this.inLeapYear({ year: e7 }) ? 6 === t ? ia(5, true) : ia(t < 6 ? t : t - 1) : ia(t);
    }
    adjustCalendarDate(e7, t, r = "constrain", n4 = false) {
      let { year: i4, eraYear: o4, month: a4, monthCode: s3, day: l6, monthExtra: u4 } = e7;
      if (void 0 === i4 && void 0 !== o4 && (i4 = o4), void 0 === o4 && void 0 !== i4 && (o4 = i4), n4) {
        if (u4) {
          const e8 = this.months[u4];
          if (!e8)
            throw new RangeError(`Unrecognized month from formatToParts: ${u4}`);
          a4 = this.inLeapYear({ year: i4 }) ? e8.leap : e8.regular;
        }
        return s3 = this.getMonthCode(i4, a4), { year: i4, month: a4, day: l6, era: void 0, eraYear: o4, monthCode: s3 };
      }
      if (this.validateCalendarDate(e7), void 0 === a4)
        if (s3.endsWith("L")) {
          if ("M05L" !== s3)
            throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s3}`);
          if (a4 = 6, !this.inLeapYear({ year: i4 })) {
            if ("reject" === r)
              throw new RangeError(`Hebrew monthCode M05L is invalid in year ${i4} which is not a leap year`);
            a4 = 6, s3 = "M06";
          }
        } else {
          a4 = na(s3), this.inLeapYear({ year: i4 }) && a4 >= 6 && a4++;
          const e8 = this.monthsInYear({ year: i4 });
          if (a4 < 1 || a4 > e8)
            throw new RangeError(`Invalid monthCode: ${s3}`);
        }
      else if ("reject" === r ? (ii(a4, 1, this.monthsInYear({ year: i4 })), ii(l6, 1, this.maximumMonthLength({ year: i4, month: a4 }))) : (a4 = ri(a4, 1, this.monthsInYear({ year: i4 })), l6 = ri(l6, 1, this.maximumMonthLength({ year: i4, month: a4 }))), void 0 === s3)
        s3 = this.getMonthCode(i4, a4);
      else if (this.getMonthCode(i4, a4) !== s3)
        throw new RangeError(`monthCode ${s3} doesn't correspond to month ${a4} in Hebrew year ${i4}`);
      return { ...e7, day: l6, month: a4, monthCode: s3, year: i4, eraYear: o4 };
    }
  };
  var da = class extends ua {
    constructor() {
      super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
    }
    inLeapYear(e7, t) {
      return 30 === this.daysInMonth({ year: e7.year, month: 12, day: 1 }, t);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength() {
      return 29;
    }
    maximumMonthLength() {
      return 30;
    }
    estimateIsoDate(e7) {
      const { year: t } = this.adjustCalendarDate(e7);
      return { year: Jo(t * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
    }
  };
  var ha = class extends da {
    constructor() {
      super(...arguments), this.id = "islamic";
    }
  };
  var fa = class extends da {
    constructor() {
      super(...arguments), this.id = "islamic-umalqura";
    }
  };
  var pa = class extends da {
    constructor() {
      super(...arguments), this.id = "islamic-tbla";
    }
  };
  var ma = class extends da {
    constructor() {
      super(...arguments), this.id = "islamic-civil";
    }
  };
  var ya = class extends da {
    constructor() {
      super(...arguments), this.id = "islamic-rgsa";
    }
  };
  var ga = class extends da {
    constructor() {
      super(...arguments), this.id = "islamicc";
    }
  };
  var va = class extends ua {
    constructor() {
      super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
    }
    inLeapYear(e7, t) {
      return ha.prototype.inLeapYear.call(this, e7, t);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e7) {
      const { month: t } = e7;
      return 12 === t ? 29 : t <= 6 ? 31 : 30;
    }
    maximumMonthLength(e7) {
      const { month: t } = e7;
      return 12 === t ? 30 : t <= 6 ? 31 : 30;
    }
    estimateIsoDate(e7) {
      const { year: t } = this.adjustCalendarDate(e7);
      return { year: t + 621, month: 1, day: 1 };
    }
  };
  var wa = class extends ua {
    constructor() {
      super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
    }
    inLeapYear(e7) {
      return ba(e7.year + 78);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e7) {
      return this.getMonthInfo(e7).length;
    }
    maximumMonthLength(e7) {
      return this.getMonthInfo(e7).length;
    }
    getMonthInfo(e7) {
      const { month: t } = e7;
      let r = this.months[t];
      if (void 0 === r)
        throw new RangeError(`Invalid month: ${t}`);
      return this.inLeapYear(e7) && r.leap && (r = r.leap), r;
    }
    estimateIsoDate(e7) {
      const t = this.adjustCalendarDate(e7), r = this.getMonthInfo(t);
      return xi(t.year + 78 + (r.nextYear ? 1 : 0), r.month, r.day, 0, 0, 0, t.day - 1, "constrain");
    }
    checkIcuBugs(e7) {
      if (this.vulnerableToBceBug && e7.year < 1)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
    }
  };
  function ba(e7) {
    return e7 % 4 == 0 && (e7 % 100 != 0 || e7 % 400 == 0);
  }
  var _a = class extends ua {
    constructor(e7, t) {
      super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e7;
      const { eras: r, anchorEra: n4 } = function(e8) {
        let t2, r2 = e8;
        if (0 === r2.length)
          throw new RangeError("Invalid era data: eras are required");
        if (1 === r2.length && r2[0].reverseOf)
          throw new RangeError("Invalid era data: anchor era cannot count years backwards");
        if (1 === r2.length && !r2[0].name)
          throw new RangeError("Invalid era data: at least one named era is required");
        if (r2.filter((e9) => null != e9.reverseOf).length > 1)
          throw new RangeError("Invalid era data: only one era can count years backwards");
        r2.forEach((e9) => {
          if (e9.isAnchor || !e9.anchorEpoch && !e9.reverseOf) {
            if (t2)
              throw new RangeError("Invalid era data: cannot have multiple anchor eras");
            t2 = e9, e9.anchorEpoch = { year: e9.hasYearZero ? 0 : 1 };
          } else if (!e9.name)
            throw new RangeError("If era name is blank, it must be the anchor era");
        }), r2 = r2.filter((e9) => e9.name), r2.forEach((e9) => {
          const { reverseOf: t3 } = e9;
          if (t3) {
            const n6 = r2.find((e10) => e10.name === t3);
            if (void 0 === n6)
              throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t3}`);
            e9.reverseOf = n6, e9.anchorEpoch = n6.anchorEpoch, e9.isoEpoch = n6.isoEpoch;
          }
          void 0 === e9.anchorEpoch.month && (e9.anchorEpoch.month = 1), void 0 === e9.anchorEpoch.day && (e9.anchorEpoch.day = 1);
        }), Go.call(r2, (e9, t3) => {
          if (e9.reverseOf)
            return 1;
          if (t3.reverseOf)
            return -1;
          if (!e9.isoEpoch || !t3.isoEpoch)
            throw new RangeError("Invalid era data: missing ISO epoch");
          return t3.isoEpoch.year - e9.isoEpoch.year;
        });
        const n5 = r2[r2.length - 1].reverseOf;
        if (n5 && n5 !== r2[r2.length - 2])
          throw new RangeError("Invalid era data: invalid reverse-sign era");
        return r2.forEach((e9, t3) => {
          e9.genericName = "era" + (r2.length - 1 - t3);
        }), { eras: r2, anchorEra: t2 || r2[0] };
      }(t);
      this.anchorEra = n4, this.eras = r;
    }
    inLeapYear(e7) {
      const { year: t } = this.estimateIsoDate({ month: 1, day: 1, year: e7.year });
      return ba(t);
    }
    monthsInYear() {
      return 12;
    }
    minimumMonthLength(e7) {
      const { month: t } = e7;
      return 2 === t ? this.inLeapYear(e7) ? 29 : 28 : [4, 6, 9, 11].indexOf(t) >= 0 ? 30 : 31;
    }
    maximumMonthLength(e7) {
      return this.minimumMonthLength(e7);
    }
    completeEraYear(e7) {
      const t = (t2, r2) => {
        const n5 = e7[t2];
        if (null != n5 && n5 != r2)
          throw new RangeError(`Input ${t2} ${n5} doesn't match calculated value ${r2}`);
      }, r = (t2) => {
        let r2;
        const n5 = { ...e7, year: t2 }, i5 = this.eras.find((e8, i6) => {
          if (i6 === this.eras.length - 1) {
            if (e8.reverseOf) {
              if (t2 > 0)
                throw new RangeError(`Signed year ${t2} is invalid for era ${e8.name}`);
              return r2 = e8.anchorEpoch.year - t2, true;
            }
            return r2 = t2 - e8.anchorEpoch.year + (e8.hasYearZero ? 0 : 1), true;
          }
          return this.compareCalendarDates(n5, e8.anchorEpoch) >= 0 && (r2 = t2 - e8.anchorEpoch.year + (e8.hasYearZero ? 0 : 1), true);
        });
        if (!i5)
          throw new RangeError(`Year ${t2} was not matched by any era`);
        return { eraYear: r2, era: i5.name };
      };
      let { year: n4, eraYear: i4, era: o4 } = e7;
      if (null != n4)
        ({ eraYear: i4, era: o4 } = r(n4)), t("era", o4), t("eraYear", i4);
      else {
        if (null == i4)
          throw new RangeError("Either `year` or `eraYear` and `era` are required");
        {
          const e8 = void 0 === o4 ? void 0 : this.eras.find((e9) => e9.name === o4 || e9.genericName === o4);
          if (!e8)
            throw new RangeError(`Era ${o4} (ISO year ${i4}) was not matched by any era`);
          if (i4 < 1 && e8.reverseOf)
            throw new RangeError(`Years in ${o4} era must be positive, not ${n4}`);
          n4 = e8.reverseOf ? e8.anchorEpoch.year - i4 : i4 + e8.anchorEpoch.year - (e8.hasYearZero ? 0 : 1), t("year", n4), { eraYear: i4, era: o4 } = r(n4);
        }
      }
      return { ...e7, year: n4, eraYear: i4, era: o4 };
    }
    adjustCalendarDate(e7, t, r = "constrain") {
      let n4 = e7;
      const { month: i4, monthCode: o4 } = n4;
      return void 0 === i4 && (n4 = { ...n4, month: na(o4) }), this.validateCalendarDate(n4), n4 = this.completeEraYear(n4), super.adjustCalendarDate(n4, t, r);
    }
    estimateIsoDate(e7) {
      const t = this.adjustCalendarDate(e7), { year: r, month: n4, day: i4 } = t, { anchorEra: o4 } = this;
      return Yt(r + o4.isoEpoch.year - (o4.hasYearZero ? 0 : 1), n4, i4, "constrain");
    }
    checkIcuBugs(e7) {
      if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug && zi(e7.year, e7.month, e7.day, 1582, 10, 15) < 0)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  };
  var Ea = class extends _a {
    constructor(e7, t) {
      super(e7, t);
    }
    inLeapYear(e7) {
      const { year: t } = e7;
      return (t + 1) % 4 == 0;
    }
    monthsInYear() {
      return 13;
    }
    minimumMonthLength(e7) {
      const { month: t } = e7;
      return 13 === t ? this.inLeapYear(e7) ? 6 : 5 : 30;
    }
    maximumMonthLength(e7) {
      return this.minimumMonthLength(e7);
    }
  };
  var Ta = class extends Ea {
    constructor() {
      super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
    }
  };
  var xa = class extends Ea {
    constructor() {
      super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
    }
  };
  var Ia = class extends Ea {
    constructor() {
      super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
    }
  };
  var Sa = class extends _a {
    constructor() {
      super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
    }
  };
  var Ra = class extends _a {
    constructor() {
      super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
    }
  };
  var ka = class extends _a {
    constructor() {
      super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
    }
    reviseIntlEra(e7) {
      let { era: t, eraYear: r } = e7;
      return "bc" !== t && "b" !== t || (t = "bce"), "ad" !== t && "a" !== t || (t = "ce"), { era: t, eraYear: r };
    }
  };
  var ja = class extends _a {
    constructor() {
      super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long", this.erasBeginMidYear = true;
    }
    reviseIntlEra(e7, t) {
      const { era: r, eraYear: n4 } = e7, { year: i4 } = t;
      return this.eras.find((e8) => e8.name === r) ? { era: r, eraYear: n4 } : i4 < 1 ? { era: "bce", eraYear: 1 - i4 } : { era: "ce", eraYear: i4 };
    }
  };
  var Da = class extends ua {
    constructor() {
      super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
    }
    inLeapYear(e7, t) {
      const r = this.getMonthList(e7.year, t);
      return 13 === Qo(r).length;
    }
    monthsInYear(e7, t) {
      return this.inLeapYear(e7, t) ? 13 : 12;
    }
    minimumMonthLength() {
      return 29;
    }
    maximumMonthLength() {
      return 30;
    }
    getMonthList(e7, t) {
      if (void 0 === e7)
        throw new TypeError("Missing year");
      const r = JSON.stringify({ func: "getMonthList", calendarYear: e7, id: this.id }), n4 = t.get(r);
      if (n4)
        return n4;
      const i4 = this.getFormatter(), o4 = (e8, t2) => {
        const r2 = sa({ isoYear: e8, isoMonth: 2, isoDay: 1 }), n5 = new Date(r2);
        n5.setUTCDate(t2 + 1);
        const o5 = i4.formatToParts(n5), a5 = o5.find((e9) => "month" === e9.type).value, s4 = +o5.find((e9) => "day" === e9.type).value;
        let l7 = o5.find((e9) => "relatedYear" === e9.type);
        if (void 0 === l7)
          throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
        return l7 = +l7.value, { calendarMonthString: a5, calendarDay: s4, calendarYearToVerify: l7 };
      };
      let a4 = 17, { calendarMonthString: s3, calendarDay: l6, calendarYearToVerify: u4 } = o4(e7, a4);
      "1" !== s3 && (a4 += 29, { calendarMonthString: s3, calendarDay: l6 } = o4(e7, a4)), a4 -= l6 - 5;
      const c3 = {};
      let d5, h6, f5 = 1, p6 = false;
      do {
        ({ calendarMonthString: s3, calendarDay: l6, calendarYearToVerify: u4 } = o4(e7, a4)), d5 && (c3[h6].daysInMonth = d5 + 30 - l6), u4 !== e7 ? p6 = true : (c3[s3] = { monthIndex: f5++ }, a4 += 30), d5 = l6, h6 = s3;
      } while (!p6);
      return c3[h6].daysInMonth = d5 + 30 - l6, t.set(r, c3), c3;
    }
    estimateIsoDate(e7) {
      const { year: t, month: r } = e7;
      return { year: t, month: r >= 12 ? 12 : r + 1, day: 1 };
    }
    adjustCalendarDate(e7, t, r = "constrain", n4 = false) {
      let { year: i4, month: o4, monthExtra: a4, day: s3, monthCode: l6, eraYear: u4 } = e7;
      if (n4) {
        if (i4 = u4, a4 && "bis" !== a4)
          throw new RangeError(`Unexpected leap month suffix: ${a4}`);
        const e8 = ia(o4, void 0 !== a4), r2 = `${o4}${a4 || ""}`, n5 = this.getMonthList(i4, t)[r2];
        if (void 0 === n5)
          throw new RangeError(`Unmatched month ${r2} in Chinese year ${i4}`);
        return o4 = n5.monthIndex, { year: i4, month: o4, day: s3, era: void 0, eraYear: u4, monthCode: e8 };
      }
      if (this.validateCalendarDate(e7), void 0 === i4 && (i4 = u4), void 0 === u4 && (u4 = i4), void 0 === o4) {
        const e8 = this.getMonthList(i4, t);
        let n5 = l6.replace("L", "bis").slice(1);
        "0" === n5[0] && (n5 = n5.slice(1));
        let a5 = e8[n5];
        if (o4 = a5 && a5.monthIndex, void 0 === o4 && l6.endsWith("L") && "M13L" != l6 && "constrain" === r) {
          let t2 = l6.slice(1, -1);
          "0" === t2[0] && (t2 = t2.slice(1)), a5 = e8[t2], a5 && (o4 = a5.monthIndex, l6 = ia(t2));
        }
        if (void 0 === o4)
          throw new RangeError(`Unmatched month ${l6} in Chinese year ${i4}`);
      } else if (void 0 === l6) {
        const e8 = this.getMonthList(i4, t), n5 = Qo(e8), a5 = n5.length;
        "reject" === r ? (ii(o4, 1, a5), ii(s3, 1, this.maximumMonthLength())) : (o4 = ri(o4, 1, a5), s3 = ri(s3, 1, this.maximumMonthLength()));
        const u5 = n5.find(([, e9]) => e9.monthIndex === o4);
        if (void 0 === u5)
          throw new RangeError(`Invalid month ${o4} in Chinese year ${i4}`);
        l6 = ia(u5[0].replace("bis", ""), -1 !== u5[0].indexOf("bis"));
      } else {
        const e8 = this.getMonthList(i4, t);
        let r2 = l6.replace("L", "bis").slice(1);
        "0" === r2[0] && (r2 = r2.slice(1));
        const n5 = e8[r2];
        if (!n5)
          throw new RangeError(`Unmatched monthCode ${l6} in Chinese year ${i4}`);
        if (o4 !== n5.monthIndex)
          throw new RangeError(`monthCode ${l6} doesn't correspond to month ${o4} in Chinese year ${i4}`);
      }
      return { ...e7, year: i4, eraYear: u4, month: o4, monthCode: l6, day: s3 };
    }
  };
  var Na = class extends Da {
    constructor() {
      super(...arguments), this.id = "chinese";
    }
  };
  var Oa = class extends Da {
    constructor() {
      super(...arguments), this.id = "dangi";
    }
  };
  var Ca = class {
    constructor(e7) {
      this.helper = e7;
    }
    dateFromFields(e7, t, r) {
      const n4 = new aa(), i4 = ar(e7, this.fields(["day", "month", "monthCode", "year"]), []), o4 = Gt(t), { year: a4, month: s3, day: l6 } = this.helper.calendarToIsoDate(i4, o4, n4), u4 = wr(a4, s3, l6, r);
      return n4.setObject(u4), u4;
    }
    yearMonthFromFields(e7, t, r) {
      const n4 = new aa(), i4 = ar(e7, this.fields(["month", "monthCode", "year"]), []), o4 = Gt(t), { year: a4, month: s3, day: l6 } = this.helper.calendarToIsoDate({ ...i4, day: 1 }, o4, n4), u4 = Ir(a4, s3, r, l6);
      return n4.setObject(u4), u4;
    }
    monthDayFromFields(e7, t, r) {
      const n4 = new aa(), i4 = ar(e7, this.fields(["day", "month", "monthCode", "year"]), []), o4 = Gt(t), { year: a4, month: s3, day: l6 } = this.helper.monthDayFromFields(i4, o4, n4), u4 = Tr(s3, l6, r, a4);
      return n4.setObject(u4), u4;
    }
    fields(e7) {
      let t = e7;
      return Yo.call(t, "year") && (t = [...t, "era", "eraYear"]), t;
    }
    fieldKeysToIgnore(e7) {
      const t = new Zo();
      for (let r = 0; r < e7.length; r++) {
        const n4 = e7[r];
        switch (nt3(Xo, t, [n4]), n4) {
          case "era":
            nt3(Xo, t, ["eraYear"]), nt3(Xo, t, ["year"]);
            break;
          case "eraYear":
            nt3(Xo, t, ["era"]), nt3(Xo, t, ["year"]);
            break;
          case "year":
            nt3(Xo, t, ["era"]), nt3(Xo, t, ["eraYear"]);
            break;
          case "month":
            nt3(Xo, t, ["monthCode"]), this.helper.erasBeginMidYear && (nt3(Xo, t, ["era"]), nt3(Xo, t, ["eraYear"]));
            break;
          case "monthCode":
            nt3(Xo, t, ["month"]), this.helper.erasBeginMidYear && (nt3(Xo, t, ["era"]), nt3(Xo, t, ["eraYear"]));
            break;
          case "day":
            this.helper.erasBeginMidYear && (nt3(Xo, t, ["era"]), nt3(Xo, t, ["eraYear"]));
        }
      }
      return [...nt3(ea, t, [])];
    }
    dateAdd(e7, t, r, n4, i4, o4, a4) {
      const s3 = aa.getCacheForObject(e7), l6 = this.helper.temporalToCalendarDate(e7, s3), u4 = this.helper.addCalendar(l6, { years: t, months: r, weeks: n4, days: i4 }, o4, s3), c3 = this.helper.calendarToIsoDate(u4, "constrain", s3), { year: d5, month: h6, day: f5 } = c3, p6 = wr(d5, h6, f5, a4);
      return new aa(s3).setObject(p6), p6;
    }
    dateUntil(e7, t, r) {
      const n4 = aa.getCacheForObject(e7), i4 = aa.getCacheForObject(t), o4 = this.helper.temporalToCalendarDate(e7, n4), a4 = this.helper.temporalToCalendarDate(t, i4);
      return this.helper.untilCalendar(o4, a4, r, n4);
    }
    year(e7) {
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).year;
    }
    month(e7) {
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).month;
    }
    day(e7) {
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).day;
    }
    era(e7) {
      if (!this.helper.hasEra)
        return;
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).era;
    }
    eraYear(e7) {
      if (!this.helper.hasEra)
        return;
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).eraYear;
    }
    monthCode(e7) {
      const t = aa.getCacheForObject(e7);
      return this.helper.temporalToCalendarDate(e7, t).monthCode;
    }
    dayOfWeek(e7) {
      return ta.iso8601.dayOfWeek(e7);
    }
    dayOfYear(e7) {
      const t = aa.getCacheForObject(e7), r = this.helper.isoToCalendarDate(e7, t), n4 = this.helper.startOfCalendarYear(r);
      return this.helper.calendarDaysUntil(n4, r, t) + 1;
    }
    weekOfYear(e7) {
      return ta.iso8601.weekOfYear(e7);
    }
    yearOfWeek(e7) {
      return ta.iso8601.yearOfWeek(e7);
    }
    daysInWeek(e7) {
      return ta.iso8601.daysInWeek(e7);
    }
    daysInMonth(e7) {
      const t = aa.getCacheForObject(e7), r = this.helper.temporalToCalendarDate(e7, t), n4 = this.helper.maximumMonthLength(r);
      if (n4 === this.helper.minimumMonthLength(r))
        return n4;
      const i4 = this.helper.startOfCalendarMonth(r), o4 = this.helper.addMonthsCalendar(i4, 1, "constrain", t);
      return this.helper.calendarDaysUntil(i4, o4, t);
    }
    daysInYear(e7) {
      let t = e7;
      Z4(t, b4) || (t = lr(t));
      const r = aa.getCacheForObject(t), n4 = this.helper.temporalToCalendarDate(t, r), i4 = this.helper.startOfCalendarYear(n4), o4 = this.helper.addCalendar(i4, { years: 1 }, "constrain", r);
      return this.helper.calendarDaysUntil(i4, o4, r);
    }
    monthsInYear(e7) {
      const t = aa.getCacheForObject(e7), r = this.helper.temporalToCalendarDate(e7, t);
      return this.helper.monthsInYear(r, t);
    }
    inLeapYear(e7) {
      let t = e7;
      Z4(t, b4) || (t = lr(t));
      const r = aa.getCacheForObject(t), n4 = this.helper.temporalToCalendarDate(t, r);
      return this.helper.inLeapYear(n4, r);
    }
  };
  for (const e7 of [ca, va, Ia, Ta, xa, Na, Oa, Sa, wa, Ra, ka, ja, ha, fa, pa, ma, ya, ga]) {
    const t = new e7();
    ta[t.id] = new Ca(t);
  }
  var Aa = class {
    constructor(e7, t, r, n4 = "iso8601") {
      vr(this, ut(e7), ut(t), ut(r), Hr(n4));
    }
    get calendarId() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Vr(K3(this, j4));
    }
    get era() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Lr(K3(this, j4), this);
    }
    get eraYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Pr(K3(this, j4), this);
    }
    get year() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Or(K3(this, j4), this);
    }
    get month() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Cr(K3(this, j4), this);
    }
    get monthCode() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Ar(K3(this, j4), this);
    }
    get day() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Mr(K3(this, j4), this);
    }
    get dayOfWeek() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Br(K3(this, j4), this);
    }
    get dayOfYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return $r(K3(this, j4), this);
    }
    get weekOfYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Fr(K3(this, j4), this);
    }
    get yearOfWeek() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Ur(K3(this, j4), this);
    }
    get daysInWeek() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return qr(K3(this, j4), this);
    }
    get daysInMonth() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Yr(K3(this, j4), this);
    }
    get daysInYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Wr(K3(this, j4), this);
    }
    get monthsInYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return zr(K3(this, j4), this);
    }
    get inLeapYear() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Gr(K3(this, j4), this);
    }
    with(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      Pt2(e7);
      const r = eo(t), n4 = K3(this, j4), i4 = kr(n4, ["day", "month", "monthCode", "year"]);
      let o4 = ar(this, i4, []);
      return o4 = jr(n4, o4, ar(e7, i4, "partial")), o4 = ar(o4, i4, []), en(n4, o4, r);
    }
    withCalendar(e7) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const t = Hr(e7);
      return new Aa(K3(this, b4), K3(this, _4), K3(this, E2), t);
    }
    add(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const r = dr(e7), n4 = eo(t);
      return Dr(K3(this, j4), this, r, n4);
    }
    subtract(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const r = ti(dr(e7)), n4 = eo(t);
      return Dr(K3(this, j4), this, r, n4);
    }
    until(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return wi("until", this, e7, t);
    }
    since(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return wi("since", this, e7, t);
    }
    equals(e7) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7);
      for (const e8 of [b4, _4, E2])
        if (K3(this, e8) !== K3(t, e8))
          return false;
      return Zr(K3(this, j4), K3(t, j4));
    }
    toString(e7) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return _n(this, Qt(eo(e7)));
    }
    toJSON() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return _n(this);
    }
    toLocaleString(e7, t) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
    }
    toPlainDateTime(e7) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const t = K3(this, b4), r = K3(this, _4), n4 = K3(this, E2), i4 = K3(this, j4);
      if (void 0 === e7)
        return _r(t, r, n4, 0, 0, 0, 0, 0, 0, i4);
      const o4 = pr(e7);
      return _r(t, r, n4, K3(o4, T4), K3(o4, x4), K3(o4, I3), K3(o4, S4), K3(o4, R4), K3(o4, k4), i4);
    }
    toZonedDateTime(e7) {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      let t, r;
      if (it2(e7))
        if (kt2(e7))
          t = e7;
        else {
          const n5 = e7.timeZone;
          void 0 === n5 ? t = nn(e7) : (t = nn(n5), r = e7.plainTime);
        }
      else
        t = nn(e7);
      const n4 = K3(this, b4), i4 = K3(this, _4), o4 = K3(this, E2), a4 = K3(this, j4);
      let s3 = 0, l6 = 0, u4 = 0, c3 = 0, d5 = 0, h6 = 0;
      return void 0 !== r && (r = pr(r), s3 = K3(r, T4), l6 = K3(r, x4), u4 = K3(r, I3), c3 = K3(r, S4), d5 = K3(r, R4), h6 = K3(r, k4)), Rr(K3(fn(t, _r(n4, i4, o4, s3, l6, u4, c3, d5, h6, a4), "compatible"), v4), t, a4);
    }
    toPlainYearMonth() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return tn(e7, ar(this, kr(e7, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return rn(e7, ar(this, kr(e7, ["day", "monthCode"]), []));
    }
    getISOFields() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return { calendar: K3(this, j4), isoDay: K3(this, E2), isoMonth: K3(this, _4), isoYear: K3(this, b4) };
    }
    getCalendar() {
      if (!Nt2(this))
        throw new TypeError("invalid receiver");
      return Qr(K3(this, j4));
    }
    static from(e7, t) {
      const r = eo(t);
      return Nt2(e7) ? (Gt(r), wr(K3(e7, b4), K3(e7, _4), K3(e7, E2), K3(e7, j4))) : lr(e7, r);
    }
    static compare(e7, t) {
      const r = lr(e7), n4 = lr(t);
      return zi(K3(r, b4), K3(r, _4), K3(r, E2), K3(n4, b4), K3(n4, _4), K3(n4, E2));
    }
  };
  f3(Aa, "Temporal.PlainDate");
  var Ma = class {
    constructor(e7, t, r, n4 = 0, i4 = 0, o4 = 0, a4 = 0, s3 = 0, l6 = 0, u4 = "iso8601") {
      br(this, ut(e7), ut(t), ut(r), void 0 === n4 ? 0 : ut(n4), void 0 === i4 ? 0 : ut(i4), void 0 === o4 ? 0 : ut(o4), void 0 === a4 ? 0 : ut(a4), void 0 === s3 ? 0 : ut(s3), void 0 === l6 ? 0 : ut(l6), Hr(u4));
    }
    get calendarId() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Vr(K3(this, j4));
    }
    get year() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Or(K3(this, j4), this);
    }
    get month() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Cr(K3(this, j4), this);
    }
    get monthCode() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Ar(K3(this, j4), this);
    }
    get day() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Mr(K3(this, j4), this);
    }
    get hour() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, T4);
    }
    get minute() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, x4);
    }
    get second() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, I3);
    }
    get millisecond() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, S4);
    }
    get microsecond() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, R4);
    }
    get nanosecond() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return K3(this, k4);
    }
    get era() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Lr(K3(this, j4), this);
    }
    get eraYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Pr(K3(this, j4), this);
    }
    get dayOfWeek() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Br(K3(this, j4), this);
    }
    get dayOfYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return $r(K3(this, j4), this);
    }
    get weekOfYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Fr(K3(this, j4), this);
    }
    get yearOfWeek() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Ur(K3(this, j4), this);
    }
    get daysInWeek() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return qr(K3(this, j4), this);
    }
    get daysInYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Wr(K3(this, j4), this);
    }
    get daysInMonth() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Yr(K3(this, j4), this);
    }
    get monthsInYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return zr(K3(this, j4), this);
    }
    get inLeapYear() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Gr(K3(this, j4), this);
    }
    with(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      Pt2(e7);
      const r = eo(t), n4 = K3(this, j4), i4 = kr(n4, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
      let o4 = ar(this, i4, []);
      o4 = jr(n4, o4, ar(e7, i4, "partial")), o4 = ar(o4, i4, []);
      const { year: a4, month: s3, day: l6, hour: u4, minute: c3, second: d5, millisecond: h6, microsecond: f5, nanosecond: p6 } = ur(n4, o4, r);
      return _r(a4, s3, l6, u4, c3, d5, h6, f5, p6, n4);
    }
    withPlainTime(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const t = K3(this, b4), r = K3(this, _4), n4 = K3(this, E2), i4 = K3(this, j4);
      if (void 0 === e7)
        return _r(t, r, n4, 0, 0, 0, 0, 0, 0, i4);
      const o4 = pr(e7);
      return _r(t, r, n4, K3(o4, T4), K3(o4, x4), K3(o4, I3), K3(o4, S4), K3(o4, R4), K3(o4, k4), i4);
    }
    withPlainDate(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7), r = K3(t, b4), n4 = K3(t, _4), i4 = K3(t, E2);
      let o4 = K3(t, j4);
      const a4 = K3(this, T4), s3 = K3(this, x4), l6 = K3(this, I3), u4 = K3(this, S4), c3 = K3(this, R4), d5 = K3(this, k4);
      return o4 = Xr(K3(this, j4), o4), _r(r, n4, i4, a4, s3, l6, u4, c3, d5, o4);
    }
    withCalendar(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const t = Hr(e7);
      return new Ma(K3(this, b4), K3(this, _4), K3(this, E2), K3(this, T4), K3(this, x4), K3(this, I3), K3(this, S4), K3(this, R4), K3(this, k4), t);
    }
    add(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Oi("add", this, e7, t);
    }
    subtract(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Oi("subtract", this, e7, t);
    }
    until(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return bi("until", this, e7, t);
    }
    since(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return bi("since", this, e7, t);
    }
    round(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e7)
        throw new TypeError("options parameter is required");
      const t = "string" == typeof e7 ? to("smallestUnit", e7) : eo(e7), r = Zt(t), n4 = Jt2(t, "halfExpand"), i4 = rr(t, "smallestUnit", "time", tr, ["day"]), o4 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[i4];
      Kt2(r, o4, 1 === o4);
      let a4 = K3(this, b4), s3 = K3(this, _4), l6 = K3(this, E2), u4 = K3(this, T4), c3 = K3(this, x4), d5 = K3(this, I3), h6 = K3(this, S4), f5 = K3(this, R4), p6 = K3(this, k4);
      return { year: a4, month: s3, day: l6, hour: u4, minute: c3, second: d5, millisecond: h6, microsecond: f5, nanosecond: p6 } = Bi(a4, s3, l6, u4, c3, d5, h6, f5, p6, r, i4, n4), _r(a4, s3, l6, u4, c3, d5, h6, f5, p6, K3(this, j4));
    }
    equals(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const t = cr(e7);
      for (const e8 of [b4, _4, E2, T4, x4, I3, S4, R4, k4])
        if (K3(this, e8) !== K3(t, e8))
          return false;
      return Zr(K3(this, j4), K3(t, j4));
    }
    toString(e7) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const t = eo(e7), r = Qt(t), n4 = Xt(t), i4 = Jt2(t, "trunc"), o4 = rr(t, "smallestUnit", "time", void 0);
      if ("hour" === o4)
        throw new RangeError('smallestUnit must be a time unit other than "hour"');
      const { precision: a4, unit: s3, increment: l6 } = er(o4, n4);
      return En(this, a4, r, { unit: s3, increment: l6, roundingMode: i4 });
    }
    toJSON() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return En(this, "auto");
    }
    toLocaleString(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
    }
    toZonedDateTime(e7, t) {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const r = nn(e7);
      return Rr(K3(fn(r, this, Ht(eo(t))), v4), r, K3(this, j4));
    }
    toPlainDate() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return ln(this);
    }
    toPlainYearMonth() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return tn(e7, ar(this, kr(e7, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return rn(e7, ar(this, kr(e7, ["day", "monthCode"]), []));
    }
    toPlainTime() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return un(this);
    }
    getISOFields() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return { calendar: K3(this, j4), isoDay: K3(this, E2), isoHour: K3(this, T4), isoMicrosecond: K3(this, R4), isoMillisecond: K3(this, S4), isoMinute: K3(this, x4), isoMonth: K3(this, _4), isoNanosecond: K3(this, k4), isoSecond: K3(this, I3), isoYear: K3(this, b4) };
    }
    getCalendar() {
      if (!Ct(this))
        throw new TypeError("invalid receiver");
      return Qr(K3(this, j4));
    }
    static from(e7, t) {
      const r = eo(t);
      return Ct(e7) ? (Gt(r), _r(K3(e7, b4), K3(e7, _4), K3(e7, E2), K3(e7, T4), K3(e7, x4), K3(e7, I3), K3(e7, S4), K3(e7, R4), K3(e7, k4), K3(e7, j4))) : cr(e7, r);
    }
    static compare(e7, t) {
      const r = cr(e7), n4 = cr(t);
      for (const e8 of [b4, _4, E2, T4, x4, I3, S4, R4, k4]) {
        const t2 = K3(r, e8), i4 = K3(n4, e8);
        if (t2 !== i4)
          return Xi(t2 - i4);
      }
      return 0;
    }
  };
  f3(Ma, "Temporal.PlainDateTime");
  var La = class {
    constructor(e7 = 0, t = 0, r = 0, n4 = 0, i4 = 0, o4 = 0, a4 = 0, s3 = 0, l6 = 0, u4 = 0) {
      const c3 = void 0 === e7 ? 0 : dt2(e7), d5 = void 0 === t ? 0 : dt2(t), h6 = void 0 === r ? 0 : dt2(r), f5 = void 0 === n4 ? 0 : dt2(n4), p6 = void 0 === i4 ? 0 : dt2(i4), m5 = void 0 === o4 ? 0 : dt2(o4), y5 = void 0 === a4 ? 0 : dt2(a4), g5 = void 0 === s3 ? 0 : dt2(s3), v6 = void 0 === l6 ? 0 : dt2(l6), w5 = void 0 === u4 ? 0 : dt2(u4);
      di(c3, d5, h6, f5, p6, m5, y5, g5, v6, w5), Q4(this), X4(this, M4, c3), X4(this, L3, d5), X4(this, P4, h6), X4(this, B4, f5), X4(this, $3, p6), X4(this, F3, m5), X4(this, U5, y5), X4(this, q4, g5), X4(this, Y4, v6), X4(this, W3, w5);
    }
    get years() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, M4);
    }
    get months() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, L3);
    }
    get weeks() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, P4);
    }
    get days() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, B4);
    }
    get hours() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, $3);
    }
    get minutes() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, F3);
    }
    get seconds() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, U5);
    }
    get milliseconds() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, q4);
    }
    get microseconds() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, Y4);
    }
    get nanoseconds() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return K3(this, W3);
    }
    get sign() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return Wn(K3(this, M4), K3(this, L3), K3(this, P4), K3(this, B4), K3(this, $3), K3(this, F3), K3(this, U5), K3(this, q4), K3(this, Y4), K3(this, W3));
    }
    get blank() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return 0 === Wn(K3(this, M4), K3(this, L3), K3(this, P4), K3(this, B4), K3(this, $3), K3(this, F3), K3(this, U5), K3(this, q4), K3(this, Y4), K3(this, W3));
    }
    with(e7) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      const t = ar(e7, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial"), { years: r = K3(this, M4), months: n4 = K3(this, L3), weeks: i4 = K3(this, P4), days: o4 = K3(this, B4), hours: a4 = K3(this, $3), minutes: s3 = K3(this, F3), seconds: l6 = K3(this, U5), milliseconds: u4 = K3(this, q4), microseconds: c3 = K3(this, Y4), nanoseconds: d5 = K3(this, W3) } = t;
      return new La(r, n4, i4, o4, a4, s3, l6, u4, c3, d5);
    }
    negated() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return ti(this);
    }
    abs() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return new La(Math.abs(K3(this, M4)), Math.abs(K3(this, L3)), Math.abs(K3(this, P4)), Math.abs(K3(this, B4)), Math.abs(K3(this, $3)), Math.abs(K3(this, F3)), Math.abs(K3(this, U5)), Math.abs(K3(this, q4)), Math.abs(K3(this, Y4)), Math.abs(K3(this, W3)));
    }
    add(e7, t) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return Di("add", this, e7, t);
    }
    subtract(e7, t) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return Di("subtract", this, e7, t);
    }
    round(e7) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e7)
        throw new TypeError("options parameter is required");
      let t = K3(this, M4), r = K3(this, L3), n4 = K3(this, P4), i4 = K3(this, B4), o4 = K3(this, $3), a4 = K3(this, F3), s3 = K3(this, U5), l6 = K3(this, q4), u4 = K3(this, Y4), c3 = K3(this, W3), h6 = ir(t, r, n4, i4, o4, a4, s3, l6, u4, c3);
      const f5 = "string" == typeof e7 ? to("smallestUnit", e7) : eo(e7);
      let p6 = rr(f5, "largestUnit", "datetime", void 0, ["auto"]), y5 = nr(f5);
      const g5 = Zt(f5), v6 = Jt2(f5, "halfExpand");
      let w5 = rr(f5, "smallestUnit", "datetime", void 0), b7 = true;
      w5 || (b7 = false, w5 = "nanosecond"), h6 = or(h6, w5);
      let _5 = true;
      if (p6 || (_5 = false, p6 = h6), "auto" === p6 && (p6 = h6), !b7 && !_5)
        throw new RangeError("at least one of smallestUnit or largestUnit is required");
      if (or(p6, w5) !== p6)
        throw new RangeError(`largestUnit ${p6} cannot be smaller than smallestUnit ${w5}`);
      const E4 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[w5];
      return void 0 !== E4 && Kt2(g5, E4, false), { years: t, months: r, weeks: n4, days: i4 } = Xn(t, r, n4, i4, p6, y5), { years: t, months: r, weeks: n4, days: i4, hours: o4, minutes: a4, seconds: s3, milliseconds: l6, microseconds: u4, nanoseconds: c3 } = Wi(t, r, n4, i4, o4, a4, s3, l6, u4, c3, g5, w5, v6, y5), { years: t, months: r, weeks: n4, days: i4, hours: o4, minutes: a4, seconds: s3, milliseconds: l6, microseconds: u4, nanoseconds: c3 } = Yi(t, r, n4, i4, o4, a4, s3, l6, u4, c3, g5, w5, v6, y5), { days: i4, hours: o4, minutes: a4, seconds: s3, milliseconds: l6, microseconds: u4, nanoseconds: c3 } = Zn(i4, o4, a4, s3, l6, u4, c3, p6, y5), { years: t, months: r, weeks: n4, days: i4 } = function(e8, t2, r2, n5, i5, o5) {
        const a5 = m4("%Temporal.Duration%"), s4 = Wn(e8, t2, r2, n5, 0, 0, 0, 0, 0, 0);
        if (0 === s4)
          return { years: e8, months: t2, weeks: r2, days: n5 };
        const l7 = d3.BigInt(s4);
        let u5, c4, h7 = d3.BigInt(e8), f6 = d3.BigInt(t2), p7 = d3.BigInt(r2), y6 = d3.BigInt(n5);
        o5 && (c4 = lr(o5), u5 = K3(c4, j4));
        const g6 = new a5(s4), v7 = new a5(0, s4), w6 = new a5(0, 0, s4);
        switch (i5) {
          case "year": {
            if (!u5)
              throw new RangeError("a starting point is required for years balancing");
            const e9 = "string" != typeof u5 ? rt3(u5, "dateAdd") : void 0;
            let t3, r3, n6;
            for ({ relativeTo: t3, days: r3 } = Ui(u5, c4, g6, e9); d3.greaterThanOrEqual(mt2(y6), d3.BigInt(Ee(r3))); )
              y6 = d3.subtract(y6, d3.BigInt(r3)), h7 = d3.add(h7, l7), c4 = t3, { relativeTo: t3, days: r3 } = Ui(u5, c4, g6, e9);
            for ({ relativeTo: t3, days: n6 } = Ui(u5, c4, v7, e9); d3.greaterThanOrEqual(mt2(y6), d3.BigInt(Ee(n6))); )
              y6 = d3.subtract(y6, d3.BigInt(n6)), f6 = d3.add(f6, l7), c4 = t3, { relativeTo: t3, days: n6 } = Ui(u5, c4, v7, e9);
            t3 = Dr(u5, c4, g6, void 0, e9);
            const i6 = "string" != typeof u5 ? rt3(u5, "dateUntil") : void 0, o6 = Ne(null);
            o6.largestUnit = "month";
            let a6 = Nr(u5, c4, t3, o6, i6), s5 = K3(a6, L3);
            for (; d3.greaterThanOrEqual(mt2(f6), d3.BigInt(Ee(s5))); ) {
              f6 = d3.subtract(f6, d3.BigInt(s5)), h7 = d3.add(h7, l7), c4 = t3, t3 = Dr(u5, c4, g6, void 0, e9);
              const r4 = Ne(null);
              r4.largestUnit = "month", a6 = Nr(u5, c4, t3, r4, i6), s5 = K3(a6, L3);
            }
            break;
          }
          case "month": {
            if (!u5)
              throw new RangeError("a starting point is required for months balancing");
            const e9 = "string" != typeof u5 ? rt3(u5, "dateAdd") : void 0;
            let t3, r3;
            for ({ relativeTo: t3, days: r3 } = Ui(u5, c4, v7, e9); d3.greaterThanOrEqual(mt2(y6), d3.BigInt(Ee(r3))); )
              y6 = d3.subtract(y6, d3.BigInt(r3)), f6 = d3.add(f6, l7), c4 = t3, { relativeTo: t3, days: r3 } = Ui(u5, c4, v7, e9);
            break;
          }
          case "week": {
            if (!u5)
              throw new RangeError("a starting point is required for weeks balancing");
            const e9 = "string" != typeof u5 ? rt3(u5, "dateAdd") : void 0;
            let t3, r3;
            for ({ relativeTo: t3, days: r3 } = Ui(u5, c4, w6, e9); d3.greaterThanOrEqual(mt2(y6), d3.BigInt(Ee(r3))); )
              y6 = d3.subtract(y6, d3.BigInt(r3)), p7 = d3.add(p7, l7), c4 = t3, { relativeTo: t3, days: r3 } = Ui(u5, c4, w6, e9);
            break;
          }
        }
        return { years: d3.toNumber(h7), months: d3.toNumber(f6), weeks: d3.toNumber(p7), days: d3.toNumber(y6) };
      }(t, r, n4, i4, p6, y5), new La(t, r, n4, i4, o4, a4, s3, l6, u4, c3);
    }
    total(e7) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      let t = K3(this, M4), r = K3(this, L3), n4 = K3(this, P4), i4 = K3(this, B4), o4 = K3(this, $3), a4 = K3(this, F3), s3 = K3(this, U5), l6 = K3(this, q4), u4 = K3(this, Y4), c3 = K3(this, W3);
      if (void 0 === e7)
        throw new TypeError("options argument is required");
      const d5 = "string" == typeof e7 ? to("unit", e7) : eo(e7), h6 = nr(d5), f5 = rr(d5, "unit", "datetime", tr);
      let p6;
      ({ years: t, months: r, weeks: n4, days: i4 } = Xn(t, r, n4, i4, f5, h6)), Lt2(h6) && (p6 = qi(h6, t, r, n4, 0));
      let m5 = Kn(i4, o4, a4, s3, l6, u4, c3, f5, p6);
      if ("positive overflow" === m5)
        return 1 / 0;
      if ("negative overflow" === m5)
        return -1 / 0;
      ({ days: i4, hours: o4, minutes: a4, seconds: s3, milliseconds: l6, microseconds: u4, nanoseconds: c3 } = m5);
      const { total: y5 } = Wi(t, r, n4, i4, o4, a4, s3, l6, u4, c3, 1, f5, "trunc", h6);
      return y5;
    }
    toString(e7) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      const t = eo(e7), r = Xt(t), n4 = Jt2(t, "trunc"), i4 = rr(t, "smallestUnit", "time", void 0);
      if ("hour" === i4 || "minute" === i4)
        throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
      const { precision: o4, unit: a4, increment: s3 } = er(i4, r);
      return bn(this, o4, { unit: a4, increment: s3, roundingMode: n4 });
    }
    toJSON() {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return bn(this);
    }
    toLocaleString(e7, t) {
      if (!Dt(this))
        throw new TypeError("invalid receiver");
      return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e7, t).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), bn(this));
    }
    valueOf() {
      throw new TypeError("use compare() to compare Temporal.Duration");
    }
    static from(e7) {
      return Dt(e7) ? new La(K3(e7, M4), K3(e7, L3), K3(e7, P4), K3(e7, B4), K3(e7, $3), K3(e7, F3), K3(e7, U5), K3(e7, q4), K3(e7, Y4), K3(e7, W3)) : dr(e7);
    }
    static compare(e7, t, r) {
      const n4 = dr(e7), i4 = dr(t), o4 = nr(eo(r)), a4 = K3(n4, M4), s3 = K3(n4, L3), l6 = K3(n4, P4);
      let u4 = K3(n4, B4);
      const c3 = K3(n4, $3), h6 = K3(n4, F3), f5 = K3(n4, U5), p6 = K3(n4, q4), m5 = K3(n4, Y4);
      let y5 = K3(n4, W3);
      const g5 = K3(i4, M4), v6 = K3(i4, L3), w5 = K3(i4, P4);
      let b7 = K3(i4, B4);
      const _5 = K3(i4, $3), E4 = K3(i4, F3), T6 = K3(i4, U5), x6 = K3(i4, q4), I5 = K3(i4, Y4);
      let S6 = K3(i4, W3);
      const R5 = ei(o4, a4, s3, l6, u4), k5 = ei(o4, g5, v6, w5, b7);
      0 === a4 && 0 === g5 && 0 === s3 && 0 === v6 && 0 === l6 && 0 === w5 || ({ days: u4 } = Xn(a4, s3, l6, u4, "day", o4), { days: b7 } = Xn(g5, v6, w5, b7, "day", o4));
      const j5 = Vn(u4, c3, h6, f5, p6, m5, y5, R5), D4 = Vn(b7, _5, E4, T6, x6, I5, S6, k5);
      return Xi(d3.toNumber(d3.subtract(j5, D4)));
    }
  };
  f3(La, "Temporal.Duration");
  var Pa = Object.create;
  var Ba = class {
    constructor(e7, t, r = "iso8601", n4 = 1972) {
      Er(this, ut(e7), ut(t), Hr(r), ut(n4));
    }
    get monthCode() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Ar(K3(this, j4), this);
    }
    get day() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Mr(K3(this, j4), this);
    }
    get calendarId() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Vr(K3(this, j4));
    }
    with(e7, t) {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      Pt2(e7);
      const r = eo(t), n4 = K3(this, j4), i4 = kr(n4, ["day", "month", "monthCode", "year"]);
      let o4 = ar(this, i4, []);
      return o4 = jr(n4, o4, ar(e7, i4, "partial")), o4 = ar(o4, i4, []), rn(n4, o4, r);
    }
    equals(e7) {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      const t = fr(e7);
      for (const e8 of [_4, E2, b4])
        if (K3(this, e8) !== K3(t, e8))
          return false;
      return Zr(K3(this, j4), K3(t, j4));
    }
    toString(e7) {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Tn(this, Qt(eo(e7)));
    }
    toJSON() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Tn(this);
    }
    toLocaleString(e7, t) {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
    }
    toPlainDate(e7) {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("argument should be an object");
      const t = K3(this, j4), r = kr(t, ["day", "monthCode"]), n4 = ar(this, r, []), i4 = kr(t, ["year"]);
      let o4 = jr(t, n4, ar(e7, i4, []));
      o4 = ar(o4, [.../* @__PURE__ */ new Set([...r, ...i4])], []);
      const a4 = Pa(null);
      return a4.overflow = "reject", en(t, o4, a4);
    }
    getISOFields() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return { calendar: K3(this, j4), isoDay: K3(this, E2), isoMonth: K3(this, _4), isoYear: K3(this, b4) };
    }
    getCalendar() {
      if (!Mt2(this))
        throw new TypeError("invalid receiver");
      return Qr(K3(this, j4));
    }
    static from(e7, t) {
      const r = eo(t);
      return Mt2(e7) ? (Gt(r), Tr(K3(e7, _4), K3(e7, E2), K3(e7, j4), K3(e7, b4))) : fr(e7, r);
    }
  };
  f3(Ba, "Temporal.PlainMonthDay");
  var $a = () => new (m4("%Temporal.Instant%"))(Zi());
  var Fa = (e7, t = Ki()) => {
    const r = nn(t), n4 = Hr(e7);
    return hn(r, $a(), n4);
  };
  var Ua = (e7 = Ki()) => hn(nn(e7), $a(), "iso8601");
  var qa = (e7, t = Ki()) => {
    const r = nn(t), n4 = Hr(e7);
    return Rr(Zi(), r, n4);
  };
  var Ya = { instant: $a, plainDateTime: Fa, plainDateTimeISO: Ua, plainDate: (e7, t = Ki()) => ln(Fa(e7, t)), plainDateISO: (e7 = Ki()) => ln(Ua(e7)), plainTimeISO: (e7 = Ki()) => un(Ua(e7)), timeZoneId: () => Ki(), zonedDateTime: qa, zonedDateTimeISO: (e7 = Ki()) => qa("iso8601", e7), [Symbol.toStringTag]: "Temporal.Now" };
  Object.defineProperty(Ya, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
  var Wa = Object.assign;
  function za(e7, t, r) {
    let n4 = K3(e7, T4), i4 = K3(e7, x4), o4 = K3(e7, I3), a4 = K3(e7, S4), s3 = K3(e7, R4), l6 = K3(e7, k4);
    if (r) {
      const { unit: e8, increment: t2, roundingMode: u4 } = r;
      ({ hour: n4, minute: i4, second: o4, millisecond: a4, microsecond: s3, nanosecond: l6 } = $i(n4, i4, o4, a4, s3, l6, t2, e8, u4));
    }
    return `${gn(n4)}:${gn(i4)}${vn(o4, a4, s3, l6, t)}`;
  }
  var Ga = class {
    constructor(e7 = 0, t = 0, r = 0, n4 = 0, i4 = 0, o4 = 0) {
      const a4 = void 0 === e7 ? 0 : ut(e7), s3 = void 0 === t ? 0 : ut(t), l6 = void 0 === r ? 0 : ut(r), u4 = void 0 === n4 ? 0 : ut(n4), c3 = void 0 === i4 ? 0 : ut(i4), d5 = void 0 === o4 ? 0 : ut(o4);
      si(a4, s3, l6, u4, c3, d5), Q4(this), X4(this, T4, a4), X4(this, x4, s3), X4(this, I3, l6), X4(this, S4, u4), X4(this, R4, c3), X4(this, k4, d5);
    }
    get hour() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, T4);
    }
    get minute() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, x4);
    }
    get second() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, I3);
    }
    get millisecond() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, S4);
    }
    get microsecond() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, R4);
    }
    get nanosecond() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return K3(this, k4);
    }
    with(e7, t) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      Pt2(e7);
      const r = Gt(eo(t)), n4 = sr(e7, "partial"), i4 = sr(this);
      let { hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = Wa(i4, n4);
      return { hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = Wt2(o4, a4, s3, l6, u4, c3, r), new Ga(o4, a4, s3, l6, u4, c3);
    }
    add(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return Ci("add", this, e7);
    }
    subtract(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return Ci("subtract", this, e7);
    }
    until(e7, t) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return _i("until", this, e7, t);
    }
    since(e7, t) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return _i("since", this, e7, t);
    }
    round(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e7)
        throw new TypeError("options parameter is required");
      const t = "string" == typeof e7 ? to("smallestUnit", e7) : eo(e7), r = Zt(t), n4 = Jt2(t, "halfExpand"), i4 = rr(t, "smallestUnit", "time", tr);
      Kt2(r, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[i4], false);
      let o4 = K3(this, T4), a4 = K3(this, x4), s3 = K3(this, I3), l6 = K3(this, S4), u4 = K3(this, R4), c3 = K3(this, k4);
      return { hour: o4, minute: a4, second: s3, millisecond: l6, microsecond: u4, nanosecond: c3 } = $i(o4, a4, s3, l6, u4, c3, r, i4, n4), new Ga(o4, a4, s3, l6, u4, c3);
    }
    equals(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      const t = pr(e7);
      for (const e8 of [T4, x4, I3, S4, R4, k4])
        if (K3(this, e8) !== K3(t, e8))
          return false;
      return true;
    }
    toString(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      const t = eo(e7), r = Xt(t), n4 = Jt2(t, "trunc"), i4 = rr(t, "smallestUnit", "time", void 0);
      if ("hour" === i4)
        throw new RangeError('smallestUnit must be a time unit other than "hour"');
      const { precision: o4, unit: a4, increment: s3 } = er(i4, r);
      return za(this, o4, { unit: a4, increment: s3, roundingMode: n4 });
    }
    toJSON() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return za(this, "auto");
    }
    toLocaleString(e7, t) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
    }
    toPlainDateTime(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7), r = K3(t, b4), n4 = K3(t, _4), i4 = K3(t, E2), o4 = K3(t, j4);
      return _r(r, n4, i4, K3(this, T4), K3(this, x4), K3(this, I3), K3(this, S4), K3(this, R4), K3(this, k4), o4);
    }
    toZonedDateTime(e7) {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      const t = e7.plainDate;
      if (void 0 === t)
        throw new TypeError("missing date property");
      const r = lr(t), n4 = e7.timeZone;
      if (void 0 === n4)
        throw new TypeError("missing timeZone property");
      const i4 = nn(n4), o4 = K3(r, b4), a4 = K3(r, _4), s3 = K3(r, E2), l6 = K3(r, j4), u4 = K3(this, T4), c3 = K3(this, x4), d5 = K3(this, I3), h6 = K3(this, S4), f5 = K3(this, R4), p6 = K3(this, k4);
      return Rr(K3(fn(i4, new (m4("%Temporal.PlainDateTime%"))(o4, a4, s3, u4, c3, d5, h6, f5, p6, l6), "compatible"), v4), i4, l6);
    }
    getISOFields() {
      if (!Ot2(this))
        throw new TypeError("invalid receiver");
      return { isoHour: K3(this, T4), isoMicrosecond: K3(this, R4), isoMillisecond: K3(this, S4), isoMinute: K3(this, x4), isoNanosecond: K3(this, k4), isoSecond: K3(this, I3) };
    }
    static from(e7, t) {
      const r = Gt(eo(t));
      return Ot2(e7) ? new Ga(K3(e7, T4), K3(e7, x4), K3(e7, I3), K3(e7, S4), K3(e7, R4), K3(e7, k4)) : pr(e7, r);
    }
    static compare(e7, t) {
      const r = pr(e7), n4 = pr(t);
      for (const e8 of [T4, x4, I3, S4, R4, k4]) {
        const t2 = K3(r, e8), i4 = K3(n4, e8);
        if (t2 !== i4)
          return Xi(t2 - i4);
      }
      return 0;
    }
  };
  f3(Ga, "Temporal.PlainTime");
  var Ha = class {
    constructor(e7) {
      if (arguments.length < 1)
        throw new RangeError("missing argument: identifier is required");
      const t = kn(e7);
      Q4(this), X4(this, w4, t);
    }
    get id() {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return K3(this, w4);
    }
    getOffsetNanosecondsFor(e7) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      const t = hr(e7), r = K3(this, w4);
      return Sn(r) ? Rn(r) : jn(r, K3(t, v4));
    }
    getOffsetStringFor(e7) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return dn(this, hr(e7));
    }
    getPlainDateTimeFor(e7, t = "iso8601") {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return hn(this, hr(e7), Hr(t));
    }
    getInstantFor(e7, t) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return fn(this, cr(e7), Ht(eo(t)));
    }
    getPossibleInstantsFor(e7) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      const t = cr(e7), r = m4("%Temporal.Instant%"), n4 = K3(this, w4);
      if (Sn(n4)) {
        const e8 = On(K3(t, b4), K3(t, _4), K3(t, E2), K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4));
        if (null === e8)
          throw new RangeError("DateTime outside of supported range");
        const i5 = Rn(n4);
        return [new r(d3.subtract(e8, d3.BigInt(i5)))];
      }
      const i4 = function(e8, t2, r2, n5, i5, o4, a4, s3, l6, u4) {
        const c3 = On(t2, r2, n5, i5, o4, a4, s3, l6, u4);
        if (null === c3)
          throw new RangeError("DateTime outside of supported range");
        let h6 = d3.subtract(c3, ze);
        d3.lessThan(h6, Ge) && (h6 = c3);
        let f5 = d3.add(c3, ze);
        d3.greaterThan(f5, He) && (f5 = c3);
        const p6 = jn(e8, h6), m5 = jn(e8, f5);
        return (p6 === m5 ? [p6] : [p6, m5]).map((h7) => {
          const f6 = d3.subtract(c3, d3.BigInt(h7)), p7 = An(e8, f6);
          if (t2 === p7.year && r2 === p7.month && n5 === p7.day && i5 === p7.hour && o4 === p7.minute && a4 === p7.second && s3 === p7.millisecond && l6 === p7.microsecond && u4 === p7.nanosecond)
            return f6;
        }).filter((e9) => void 0 !== e9);
      }(n4, K3(t, b4), K3(t, _4), K3(t, E2), K3(t, T4), K3(t, x4), K3(t, I3), K3(t, S4), K3(t, R4), K3(t, k4));
      return i4.map((e8) => new r(e8));
    }
    getNextTransition(e7) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      const t = hr(e7), r = K3(this, w4);
      if (Sn(r) || "UTC" === r)
        return null;
      let n4 = K3(t, v4);
      const i4 = m4("%Temporal.Instant%");
      return n4 = Pn(r, n4), null === n4 ? null : new i4(n4);
    }
    getPreviousTransition(e7) {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      const t = hr(e7), r = K3(this, w4);
      if (Sn(r) || "UTC" === r)
        return null;
      let n4 = K3(t, v4);
      const i4 = m4("%Temporal.Instant%");
      return n4 = Bn(r, n4), null === n4 ? null : new i4(n4);
    }
    toString() {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return K3(this, w4);
    }
    toJSON() {
      if (!kt2(this))
        throw new TypeError("invalid receiver");
      return K3(this, w4);
    }
    static from(e7) {
      return an(nn(e7));
    }
  };
  f3(Ha, "Temporal.TimeZone"), p4("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", Ha.prototype.getOffsetNanosecondsFor), p4("Temporal.TimeZone.prototype.getPossibleInstantsFor", Ha.prototype.getPossibleInstantsFor);
  var Ja = Object.create;
  var Va = class {
    constructor(e7, t, r = "iso8601", n4 = 1) {
      xr(this, ut(e7), ut(t), Hr(r), ut(n4));
    }
    get year() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Or(K3(this, j4), this);
    }
    get month() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Cr(K3(this, j4), this);
    }
    get monthCode() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Ar(K3(this, j4), this);
    }
    get calendarId() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Vr(K3(this, j4));
    }
    get era() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Lr(K3(this, j4), this);
    }
    get eraYear() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Pr(K3(this, j4), this);
    }
    get daysInMonth() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Yr(K3(this, j4), this);
    }
    get daysInYear() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Wr(K3(this, j4), this);
    }
    get monthsInYear() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return zr(K3(this, j4), this);
    }
    get inLeapYear() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Gr(K3(this, j4), this);
    }
    with(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid argument");
      Pt2(e7);
      const r = eo(t), n4 = K3(this, j4), i4 = kr(n4, ["month", "monthCode", "year"]);
      let o4 = ar(this, i4, []);
      return o4 = jr(n4, o4, ar(e7, i4, "partial")), o4 = ar(o4, i4, []), tn(n4, o4, r);
    }
    add(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Ai("add", this, e7, t);
    }
    subtract(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Ai("subtract", this, e7, t);
    }
    until(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Ei("until", this, e7, t);
    }
    since(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Ei("since", this, e7, t);
    }
    equals(e7) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      const t = mr(e7);
      for (const e8 of [b4, _4, E2])
        if (K3(this, e8) !== K3(t, e8))
          return false;
      return Zr(K3(this, j4), K3(t, j4));
    }
    toString(e7) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return xn(this, Qt(eo(e7)));
    }
    toJSON() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return xn(this);
    }
    toLocaleString(e7, t) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return new jo(e7, t).format(this);
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
    }
    toPlainDate(e7) {
      if (!At(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("argument should be an object");
      const t = K3(this, j4), r = kr(t, ["monthCode", "year"]), n4 = ar(this, r, []), i4 = kr(t, ["day"]);
      let o4 = jr(t, n4, ar(e7, i4, []));
      o4 = ar(o4, [.../* @__PURE__ */ new Set([...r, ...i4])], []);
      const a4 = Ja(null);
      return a4.overflow = "reject", en(t, o4, a4);
    }
    getISOFields() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return { calendar: K3(this, j4), isoDay: K3(this, E2), isoMonth: K3(this, _4), isoYear: K3(this, b4) };
    }
    getCalendar() {
      if (!At(this))
        throw new TypeError("invalid receiver");
      return Qr(K3(this, j4));
    }
    static from(e7, t) {
      const r = eo(t);
      return At(e7) ? (Gt(r), Ir(K3(e7, b4), K3(e7, _4), K3(e7, j4), K3(e7, E2))) : mr(e7, r);
    }
    static compare(e7, t) {
      const r = mr(e7), n4 = mr(t);
      return zi(K3(r, b4), K3(r, _4), K3(r, E2), K3(n4, b4), K3(n4, _4), K3(n4, E2));
    }
  };
  f3(Va, "Temporal.PlainYearMonth");
  var Qa = jo.prototype.resolvedOptions;
  var Za = Object.create;
  var Ka = class {
    constructor(e7, t, r = "iso8601") {
      if (arguments.length < 1)
        throw new TypeError("missing argument: epochNanoseconds is required");
      Sr(this, Qi(e7), nn(t), Hr(r));
    }
    get calendarId() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Vr(K3(this, j4));
    }
    get timeZoneId() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return on(K3(this, A3));
    }
    get year() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Or(K3(this, j4), Xa(this));
    }
    get month() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Cr(K3(this, j4), Xa(this));
    }
    get monthCode() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Ar(K3(this, j4), Xa(this));
    }
    get day() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Mr(K3(this, j4), Xa(this));
    }
    get hour() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), T4);
    }
    get minute() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), x4);
    }
    get second() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), I3);
    }
    get millisecond() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), S4);
    }
    get microsecond() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), R4);
    }
    get nanosecond() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return K3(Xa(this), k4);
    }
    get era() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Lr(K3(this, j4), Xa(this));
    }
    get eraYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Pr(K3(this, j4), Xa(this));
    }
    get epochSeconds() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, v4);
      return d3.toNumber(Hi(e7, Ue));
    }
    get epochMilliseconds() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, v4);
      return d3.toNumber(Hi(e7, Fe));
    }
    get epochMicroseconds() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Vi(Hi(K3(this, v4), $e));
    }
    get epochNanoseconds() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Vi(K3(this, v4));
    }
    get dayOfWeek() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Br(K3(this, j4), Xa(this));
    }
    get dayOfYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return $r(K3(this, j4), Xa(this));
    }
    get weekOfYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Fr(K3(this, j4), Xa(this));
    }
    get yearOfWeek() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Ur(K3(this, j4), Xa(this));
    }
    get hoursInDay() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = Xa(this), t = m4("%Temporal.PlainDateTime%"), r = K3(e7, b4), n4 = K3(e7, _4), i4 = K3(e7, E2), o4 = new t(r, n4, i4, 0, 0, 0, 0, 0, 0), a4 = xi(r, n4, i4, 0, 0, 0, 1, "reject"), s3 = new t(a4.year, a4.month, a4.day, 0, 0, 0, 0, 0, 0), l6 = K3(this, A3), u4 = K3(fn(l6, o4, "compatible"), v4), c3 = K3(fn(l6, s3, "compatible"), v4);
      return Ji(d3.subtract(c3, u4), Ye);
    }
    get daysInWeek() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return qr(K3(this, j4), Xa(this));
    }
    get daysInMonth() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Yr(K3(this, j4), Xa(this));
    }
    get daysInYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Wr(K3(this, j4), Xa(this));
    }
    get monthsInYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return zr(K3(this, j4), Xa(this));
    }
    get inLeapYear() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Gr(K3(this, j4), Xa(this));
    }
    get offset() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return dn(K3(this, A3), K3(this, C3));
    }
    get offsetNanoseconds() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return cn(K3(this, A3), K3(this, C3));
    }
    with(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      if (!it2(e7))
        throw new TypeError("invalid zoned-date-time-like");
      Pt2(e7);
      const r = eo(t), n4 = K3(this, j4);
      let i4 = kr(n4, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
      i4.push("offset");
      let o4 = ar(this, i4, ["offset"]);
      o4 = jr(n4, o4, ar(e7, i4, "partial")), o4 = ar(o4, i4, ["offset"]);
      const a4 = Ht(r), s3 = Vt(r, "prefer");
      let { year: l6, month: u4, day: c3, hour: d5, minute: h6, second: f5, millisecond: p6, microsecond: m5, nanosecond: y5 } = ur(n4, o4, r);
      const g5 = Rn(o4.offset), v6 = K3(this, A3);
      return Rr(yr(l6, u4, c3, d5, h6, f5, p6, m5, y5, "option", g5, v6, a4, s3, false), v6, n4);
    }
    withPlainDate(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = lr(e7), r = K3(t, b4), n4 = K3(t, _4), i4 = K3(t, E2);
      let o4 = K3(t, j4);
      const a4 = Xa(this), s3 = K3(a4, T4), l6 = K3(a4, x4), u4 = K3(a4, I3), c3 = K3(a4, S4), d5 = K3(a4, R4), h6 = K3(a4, k4);
      o4 = Xr(K3(this, j4), o4);
      const f5 = K3(this, A3);
      return Rr(K3(fn(f5, new (m4("%Temporal.PlainDateTime%"))(r, n4, i4, s3, l6, u4, c3, d5, h6, o4), "compatible"), v4), f5, o4);
    }
    withPlainTime(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = m4("%Temporal.PlainTime%"), r = void 0 === e7 ? new t() : pr(e7), n4 = Xa(this), i4 = K3(n4, b4), o4 = K3(n4, _4), a4 = K3(n4, E2), s3 = K3(this, j4), l6 = K3(r, T4), u4 = K3(r, x4), c3 = K3(r, I3), d5 = K3(r, S4), h6 = K3(r, R4), f5 = K3(r, k4), p6 = K3(this, A3);
      return Rr(K3(fn(p6, new (m4("%Temporal.PlainDateTime%"))(i4, o4, a4, l6, u4, c3, d5, h6, f5, s3), "compatible"), v4), p6, s3);
    }
    withTimeZone(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = nn(e7);
      return Rr(K3(this, v4), t, K3(this, j4));
    }
    withCalendar(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = Hr(e7);
      return Rr(K3(this, v4), K3(this, A3), t);
    }
    add(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Mi("add", this, e7, t);
    }
    subtract(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Mi("subtract", this, e7, t);
    }
    until(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Ti("until", this, e7, t);
    }
    since(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Ti("since", this, e7, t);
    }
    round(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      if (void 0 === e7)
        throw new TypeError("options parameter is required");
      const t = "string" == typeof e7 ? to("smallestUnit", e7) : eo(e7), r = Zt(t), n4 = Jt2(t, "halfExpand"), i4 = rr(t, "smallestUnit", "time", tr, ["day"]), o4 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[i4];
      Kt2(r, o4, 1 === o4);
      const a4 = Xa(this);
      let s3 = K3(a4, b4), l6 = K3(a4, _4), u4 = K3(a4, E2), c3 = K3(a4, T4), h6 = K3(a4, x4), f5 = K3(a4, I3), p6 = K3(a4, S4), y5 = K3(a4, R4), g5 = K3(a4, k4);
      const w5 = m4("%Temporal.PlainDateTime%"), D4 = K3(this, A3), N10 = K3(this, j4), O3 = fn(D4, new w5(K3(a4, b4), K3(a4, _4), K3(a4, E2), 0, 0, 0, 0, 0, 0), "compatible"), M6 = ji(O3, D4, N10, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), L4 = d3.subtract(M6, d3.BigInt(K3(O3, v4)));
      if (d3.lessThanOrEqual(L4, Me))
        throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
      return { year: s3, month: l6, day: u4, hour: c3, minute: h6, second: f5, millisecond: p6, microsecond: y5, nanosecond: g5 } = Bi(s3, l6, u4, c3, h6, f5, p6, y5, g5, r, i4, n4, d3.toNumber(L4)), Rr(yr(s3, l6, u4, c3, h6, f5, p6, y5, g5, "option", cn(D4, K3(this, C3)), D4, "compatible", "prefer", false), D4, K3(this, j4));
    }
    equals(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = gr(e7), r = K3(this, v4), n4 = K3(t, v4);
      return !!d3.equal(d3.BigInt(r), d3.BigInt(n4)) && !!sn(K3(this, A3), K3(t, A3)) && Zr(K3(this, j4), K3(t, j4));
    }
    toString(e7) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const t = eo(e7), r = Qt(t), n4 = Xt(t), i4 = function(e8) {
        return no(e8, "offset", ["auto", "never"], "auto");
      }(t), o4 = Jt2(t, "trunc"), a4 = rr(t, "smallestUnit", "time", void 0);
      if ("hour" === a4)
        throw new RangeError('smallestUnit must be a time unit other than "hour"');
      const s3 = function(e8) {
        return no(e8, "timeZoneName", ["auto", "never", "critical"], "auto");
      }(t), { precision: l6, unit: u4, increment: c3 } = er(a4, n4);
      return In(this, l6, r, s3, i4, { unit: u4, increment: c3, roundingMode: o4 });
    }
    toLocaleString(e7, t) {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const r = eo(t), n4 = Za(null);
      if (St2(n4, r, ["timeZone"]), void 0 !== r.timeZone)
        throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
      void 0 === n4.year && void 0 === n4.month && void 0 === n4.day && void 0 === n4.weekday && void 0 === n4.dateStyle && void 0 === n4.hour && void 0 === n4.minute && void 0 === n4.second && void 0 === n4.timeStyle && void 0 === n4.dayPeriod && void 0 === n4.timeZoneName && (n4.timeZoneName = "short");
      let i4 = on(K3(this, A3));
      if (Sn(i4))
        throw new RangeError("toLocaleString does not support offset string time zones");
      i4 = kn(i4), n4.timeZone = i4;
      const o4 = new jo(e7, n4), a4 = nt3(Qa, o4, []).calendar, s3 = Vr(K3(this, j4));
      if ("iso8601" !== s3 && "iso8601" !== a4 && a4 !== s3)
        throw new RangeError(`cannot format ZonedDateTime with calendar ${s3} in locale with calendar ${a4}`);
      return o4.format(K3(this, C3));
    }
    toJSON() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return In(this, "auto");
    }
    valueOf() {
      throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
    }
    startOfDay() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = Xa(this), t = m4("%Temporal.PlainDateTime%"), r = K3(this, j4), n4 = new t(K3(e7, b4), K3(e7, _4), K3(e7, E2), 0, 0, 0, 0, 0, 0, r), i4 = K3(this, A3);
      return Rr(K3(fn(i4, n4, "compatible"), v4), i4, r);
    }
    toInstant() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return new (m4("%Temporal.Instant%"))(K3(this, v4));
    }
    toPlainDate() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return ln(Xa(this));
    }
    toPlainTime() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return un(Xa(this));
    }
    toPlainDateTime() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Xa(this);
    }
    toPlainYearMonth() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return tn(e7, ar(this, kr(e7, ["monthCode", "year"]), []));
    }
    toPlainMonthDay() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = K3(this, j4);
      return rn(e7, ar(this, kr(e7, ["day", "monthCode"]), []));
    }
    getISOFields() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      const e7 = Xa(this), t = K3(this, A3);
      return { calendar: K3(this, j4), isoDay: K3(e7, E2), isoHour: K3(e7, T4), isoMicrosecond: K3(e7, R4), isoMillisecond: K3(e7, S4), isoMinute: K3(e7, x4), isoMonth: K3(e7, _4), isoNanosecond: K3(e7, k4), isoSecond: K3(e7, I3), isoYear: K3(e7, b4), offset: dn(t, K3(this, C3)), timeZone: t };
    }
    getCalendar() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return Qr(K3(this, j4));
    }
    getTimeZone() {
      if (!Lt2(this))
        throw new TypeError("invalid receiver");
      return an(K3(this, A3));
    }
    static from(e7, t) {
      const r = eo(t);
      return Lt2(e7) ? (Ht(r), Vt(r, "reject"), Gt(r), Rr(K3(e7, v4), K3(e7, A3), K3(e7, j4))) : gr(e7, r);
    }
    static compare(e7, t) {
      const r = gr(e7), n4 = gr(t), i4 = K3(r, v4), o4 = K3(n4, v4);
      return d3.lessThan(d3.BigInt(i4), d3.BigInt(o4)) ? -1 : d3.greaterThan(d3.BigInt(i4), d3.BigInt(o4)) ? 1 : 0;
    }
  };
  function Xa(e7) {
    return hn(K3(e7, A3), K3(e7, C3), K3(e7, j4));
  }
  f3(Ka, "Temporal.ZonedDateTime");
  var es = Object.freeze({ __proto__: null, Calendar: ra, Duration: La, Instant: qo, Now: Ya, PlainDate: Aa, PlainDateTime: Ma, PlainMonthDay: Ba, PlainTime: Ga, PlainYearMonth: Va, TimeZone: Ha, ZonedDateTime: Ka });
  var ts = [qo, ra, Aa, Ma, La, Ba, Ga, Ha, Va, Ka];
  for (const e7 of ts) {
    const t = Object.getOwnPropertyDescriptor(e7, "prototype");
    (t.configurable || t.enumerable || t.writable) && (t.configurable = false, t.enumerable = false, t.writable = false, Object.defineProperty(e7, "prototype", t));
  }
  var rs;
  var ns;
  !function(e7) {
    e7.BlankNode = "BlankNode", e7.IRI = "NamedNode", e7.Literal = "Literal", e7.Undefined = "Undefined";
  }(rs || (rs = {})), function(e7) {
    e7.Boolean = "http://www.w3.org/2001/XMLSchema#boolean", e7.Integer = "http://www.w3.org/2001/XMLSchema#integer", e7.NonNegativeInteger = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", e7.NonPositiveInteger = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", e7.NegativeInteger = "http://www.w3.org/2001/XMLSchema#negativeInteger", e7.PositiveInteger = "http://www.w3.org/2001/XMLSchema#positiveInteger", e7.DateTime = "http://www.w3.org/2001/XMLSchema#dateTime", e7.Double = "http://www.w3.org/2001/XMLSchema#double";
  }(ns || (ns = {}));
  var is = (e7) => e7.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
  function os(e7) {
    if (!e7.graph.value)
      return i3.DEFAULT_GRAPH_NODE_NAME;
    if ("BlankNode" !== e7.graph.termType)
      throw new Error("graph node is not of BlankNode type");
    return e7.graph.value;
  }
  var as = (e7) => e7.sort((e8, t) => e8 < t ? -1 : e8 > t ? 1 : 0);
  var ss = new TextEncoder();
  var ls = (e7) => {
    const t = e7 / 2n;
    return { min: t - e7 + 1n, max: t };
  };
  var us = (e7, t, r) => {
    switch (e7) {
      case ns.Boolean:
        switch (t) {
          case "false":
          case "0":
            return false;
          case "true":
          case "1":
            return true;
          default:
            throw new Error("incorrect boolean value");
        }
      case ns.Integer:
      case ns.NonNegativeInteger:
      case ns.NonPositiveInteger:
      case ns.NegativeInteger:
      case ns.PositiveInteger:
        const n4 = BigInt(t), { min: i4, max: o4 } = function(e8, t2) {
          switch (e8) {
            case ns.PositiveInteger:
              return { min: 1n, max: t2 - 1n };
            case ns.NonNegativeInteger:
              return { min: 0n, max: t2 - 1n };
            case ns.Integer:
              return ls(t2);
            case ns.NegativeInteger:
              return { min: ls(t2).min, max: -1n };
            case ns.NonPositiveInteger:
              return { min: ls(t2).min, max: 0n };
            default:
              throw new Error(`unsupported XSD type: ${e8}`);
          }
        }(e7, r);
        if (n4 > o4)
          throw new Error(`integer exceeds maximum value: ${n4}`);
        if (n4 < i4)
          throw new Error(`integer is below minimum value: ${n4}`);
        return n4;
      case ns.DateTime:
        if (isNaN(Date.parse(t)))
          throw new Error(`error: error parsing time string ${t}`);
        return /^\d{4}-\d{2}-\d{2}$/.test(t) ? es.Instant.from(new Date(t).toISOString()) : es.Instant.from(t);
      case ns.Double:
        return is(parseFloat(t));
      default:
        return t;
    }
  };
  var cs;
  var ds = new TextEncoder();
  var hs = class {
    constructor(e7, t = a3) {
      this.value = e7, this.h = t;
    }
    isString() {
      return "string" == typeof this.value;
    }
    asString() {
      if (!this.isString())
        throw i3.ERRORS.MT_VALUE_INCORRECT_TYPE;
      return this.value.toString();
    }
    isTime() {
      return this.value instanceof es.Instant;
    }
    asTime() {
      if (!this.isTime())
        throw i3.ERRORS.MT_VALUE_INCORRECT_TYPE;
      return this.value;
    }
    isNumber() {
      return "number" == typeof this.value;
    }
    asNumber() {
      if (!this.isNumber())
        throw i3.ERRORS.MT_VALUE_INCORRECT_TYPE;
      return this.value;
    }
    isBool() {
      return "boolean" == typeof this.value;
    }
    asBool() {
      if (!this.isBool())
        throw i3.ERRORS.MT_VALUE_INCORRECT_TYPE;
      return this.value;
    }
    mtEntry() {
      return hs.mkValueMtEntry(this.h, this.value);
    }
    isBigInt() {
      return "bigint" == typeof this.value;
    }
    asBigInt() {
      if (!this.isBigInt())
        throw i3.ERRORS.MT_VALUE_INCORRECT_TYPE;
      return this.value;
    }
    static async mkValueInt(e7, t) {
      return t >= 0 ? BigInt(t) : e7.prime() + BigInt(t);
    }
  };
  cs = hs, hs.mkValueMtEntry = (e7, t) => {
    switch (typeof t) {
      case "number":
        return hs.mkValueInt(e7, t);
      case "string":
        return hs.mkValueString(e7, t);
      case "boolean":
        return hs.mkValueBool(e7, t);
      case "bigint":
        return hs.mkValueBigInt(e7, t);
      default:
        if (t instanceof es.Instant)
          return hs.mkValueTime(e7, t);
        throw new Error("error: unexpected type " + typeof t);
    }
  }, hs.mkValueUInt = (e7, t) => BigInt.asUintN(64, t), hs.mkValueBool = (e7, t) => t ? e7.hash([BigInt.asIntN(64, BigInt(1))]) : e7.hash([BigInt.asIntN(64, BigInt(0))]), hs.mkValueString = (e7, t) => e7.hashBytes(ds.encode(t)), hs.mkValueTime = async (e7, t) => cs.mkValueInt(e7, t.epochNanoseconds), hs.mkValueBigInt = async (e7, t) => {
    const r = e7.prime();
    if (t >= r)
      throw new Error(`value is too big: ${t}`);
    if (t < 0n) {
      const { min: e8 } = ls(r);
      if (t < e8)
        throw new Error(`value is too small: ${t}`);
      return t + r;
    }
    return t;
  };
  var fs = {};
  var ps = class e3 {
    constructor(e7, t = /* @__PURE__ */ new Map(), r = 0) {
      this.prefix = e7, this._existing = t, this.counter = r;
    }
    clone() {
      const { prefix: t, _existing: r, counter: n4 } = this;
      return new e3(t, new Map(r), n4);
    }
    getId(e7) {
      const t = e7 && this._existing.get(e7);
      if (t)
        return t;
      const r = this.prefix + this.counter;
      return this.counter++, e7 && this._existing.set(e7, r), r;
    }
    hasId(e7) {
      return this._existing.has(e7);
    }
    getOldIds() {
      return [...this._existing.keys()];
    }
  };
  var ms = self.crypto || self.msCrypto;
  var ys = class {
    constructor(e7) {
      if (!ms || !ms.subtle)
        throw new Error("crypto.subtle not found.");
      if ("sha256" === e7)
        this.algorithm = { name: "SHA-256" };
      else {
        if ("sha1" !== e7)
          throw new Error(`Unsupported algorithm "${e7}".`);
        this.algorithm = { name: "SHA-1" };
      }
      this._content = "";
    }
    update(e7) {
      this._content += e7;
    }
    async digest() {
      const e7 = new TextEncoder().encode(this._content), t = new Uint8Array(await ms.subtle.digest(this.algorithm, e7));
      let r = "";
      for (let e8 = 0; e8 < t.length; ++e8)
        r += t[e8].toString(16).padStart(2, "0");
      return r;
    }
  };
  var gs = class {
    constructor(e7) {
      this.current = e7.sort(), this.done = false, this.dir = /* @__PURE__ */ new Map();
      for (let t = 0; t < e7.length; ++t)
        this.dir.set(e7[t], true);
    }
    hasNext() {
      return !this.done;
    }
    next() {
      const { current: e7, dir: t } = this, r = e7.slice();
      let n4 = null, i4 = 0;
      const o4 = e7.length;
      for (let r2 = 0; r2 < o4; ++r2) {
        const a4 = e7[r2], s3 = t.get(a4);
        (null === n4 || a4 > n4) && (s3 && r2 > 0 && a4 > e7[r2 - 1] || !s3 && r2 < o4 - 1 && a4 > e7[r2 + 1]) && (n4 = a4, i4 = r2);
      }
      if (null === n4)
        this.done = true;
      else {
        const r2 = t.get(n4) ? i4 - 1 : i4 + 1;
        e7[i4] = e7[r2], e7[r2] = n4;
        for (const r3 of e7)
          r3 > n4 && t.set(r3, !t.get(r3));
      }
      return r;
    }
  };
  var vs = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString";
  var ws = "http://www.w3.org/2001/XMLSchema#string";
  var bs = "NamedNode";
  var _s = "BlankNode";
  var Es = "Literal";
  var Ts = "DefaultGraph";
  var xs = {};
  (() => {
    const e7 = "(?:<([^:]+:[^>]*)>)", t = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD_", r = t + "0-9-\xB7\u0300-\u036F\u203F-\u2040", n4 = "(_:(?:[" + t + "0-9])(?:(?:[" + r + ".])*(?:[" + r + "]))?)", i4 = "[ \\t]+", o4 = "[ \\t]*", a4 = "(?:" + e7 + "|" + n4 + ")" + i4, s3 = e7 + i4, l6 = "(?:" + e7 + "|" + n4 + "|" + ('(?:"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"(?:' + ("(?:\\^\\^" + e7 + ")") + "|(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*)))?)") + ")" + o4, u4 = "(?:\\.|(?:(?:" + e7 + "|" + n4 + ")" + o4 + "\\.))";
    xs.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g, xs.empty = new RegExp("^" + o4 + "$"), xs.quad = new RegExp("^" + o4 + a4 + s3 + l6 + u4 + o4 + "$");
  })();
  var Is = class e4 {
    static parse(e7) {
      const t = [], r = {}, n4 = e7.split(xs.eoln);
      let i4 = 0;
      for (const e8 of n4) {
        if (i4++, xs.empty.test(e8))
          continue;
        const n5 = e8.match(xs.quad);
        if (null === n5)
          throw new Error("N-Quads parse error on line " + i4 + ".");
        const o4 = { subject: null, predicate: null, object: null, graph: null };
        if (void 0 !== n5[1] ? o4.subject = { termType: bs, value: n5[1] } : o4.subject = { termType: _s, value: n5[2] }, o4.predicate = { termType: bs, value: n5[3] }, void 0 !== n5[4] ? o4.object = { termType: bs, value: n5[4] } : void 0 !== n5[5] ? o4.object = { termType: _s, value: n5[5] } : (o4.object = { termType: Es, value: void 0, datatype: { termType: bs } }, void 0 !== n5[7] ? o4.object.datatype.value = n5[7] : void 0 !== n5[8] ? (o4.object.datatype.value = vs, o4.object.language = n5[8]) : o4.object.datatype.value = ws, o4.object.value = js(n5[6])), void 0 !== n5[9] ? o4.graph = { termType: bs, value: n5[9] } : void 0 !== n5[10] ? o4.graph = { termType: _s, value: n5[10] } : o4.graph = { termType: Ts, value: "" }, o4.graph.value in r) {
          let e9 = true;
          const n6 = r[o4.graph.value];
          for (const t2 of n6)
            if (Ss(t2, o4)) {
              e9 = false;
              break;
            }
          e9 && (n6.push(o4), t.push(o4));
        } else
          r[o4.graph.value] = [o4], t.push(o4);
      }
      return t;
    }
    static serialize(t) {
      Array.isArray(t) || (t = e4.legacyDatasetToQuads(t));
      const r = [];
      for (const n4 of t)
        r.push(e4.serializeQuad(n4));
      return r.sort().join("");
    }
    static serializeQuadComponents(e7, t, r, n4) {
      let i4 = "";
      return e7.termType === bs ? i4 += `<${e7.value}>` : i4 += `${e7.value}`, i4 += ` <${t.value}> `, r.termType === bs ? i4 += `<${r.value}>` : r.termType === _s ? i4 += r.value : (i4 += `"${function(e8) {
        return e8.replace(Rs, function(e9) {
          switch (e9) {
            case '"':
              return '\\"';
            case "\\":
              return "\\\\";
            case "\n":
              return "\\n";
            case "\r":
              return "\\r";
          }
        });
      }(r.value)}"`, r.datatype.value === vs ? r.language && (i4 += `@${r.language}`) : r.datatype.value !== ws && (i4 += `^^<${r.datatype.value}>`)), n4.termType === bs ? i4 += ` <${n4.value}>` : n4.termType === _s && (i4 += ` ${n4.value}`), i4 += " .\n", i4;
    }
    static serializeQuad(t) {
      return e4.serializeQuadComponents(t.subject, t.predicate, t.object, t.graph);
    }
    static legacyDatasetToQuads(e7) {
      const t = [], r = { "blank node": _s, IRI: bs, literal: Es };
      for (const n4 in e7) {
        e7[n4].forEach((e8) => {
          const i4 = {};
          for (const t2 in e8) {
            const n5 = e8[t2], o4 = { termType: r[n5.type], value: n5.value };
            o4.termType === Es && (o4.datatype = { termType: bs }, "datatype" in n5 && (o4.datatype.value = n5.datatype), "language" in n5 ? ("datatype" in n5 || (o4.datatype.value = vs), o4.language = n5.language) : "datatype" in n5 || (o4.datatype.value = ws)), i4[t2] = o4;
          }
          i4.graph = "@default" === n4 ? { termType: Ts, value: "" } : { termType: n4.startsWith("_:") ? _s : bs, value: n4 }, t.push(i4);
        });
      }
      return t;
    }
  };
  function Ss(e7, t) {
    return e7.subject.termType === t.subject.termType && e7.object.termType === t.object.termType && (e7.subject.value === t.subject.value && e7.predicate.value === t.predicate.value && e7.object.value === t.object.value && (e7.object.termType !== Es || e7.object.datatype.termType === t.object.datatype.termType && e7.object.language === t.object.language && e7.object.datatype.value === t.object.datatype.value));
  }
  var Rs = /["\\\n\r]/g;
  var ks = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
  function js(e7) {
    return e7.replace(ks, function(e8, t, r, n4) {
      if (t)
        switch (t) {
          case "t":
            return "	";
          case "b":
            return "\b";
          case "n":
            return "\n";
          case "r":
            return "\r";
          case "f":
            return "\f";
          case '"':
            return '"';
          case "'":
            return "'";
          case "\\":
            return "\\";
        }
      if (r)
        return String.fromCharCode(parseInt(r, 16));
      if (n4)
        throw new Error("Unsupported U escape");
    });
  }
  var Ds = ps;
  var Ns = ys;
  var Os = gs;
  var Cs = Is;
  var As = class {
    constructor({ createMessageDigest: e7 = () => new Ns("sha256"), canonicalIdMap: t = /* @__PURE__ */ new Map(), maxDeepIterations: r = 1 / 0 } = {}) {
      this.name = "URDNA2015", this.blankNodeInfo = /* @__PURE__ */ new Map(), this.canonicalIssuer = new Ds("_:c14n", t), this.createMessageDigest = e7, this.maxDeepIterations = r, this.quads = null, this.deepIterations = null;
    }
    async main(e7) {
      this.deepIterations = /* @__PURE__ */ new Map(), this.quads = e7;
      for (const t2 of e7)
        this._addBlankNodeQuadInfo({ quad: t2, component: t2.subject }), this._addBlankNodeQuadInfo({ quad: t2, component: t2.object }), this._addBlankNodeQuadInfo({ quad: t2, component: t2.graph });
      const t = /* @__PURE__ */ new Map(), r = [...this.blankNodeInfo.keys()];
      let n4 = 0;
      for (const e8 of r)
        ++n4 % 100 == 0 && await this._yield(), await this._hashAndTrackBlankNode({ id: e8, hashToBlankNodes: t });
      const i4 = [...t.keys()].sort(), o4 = [];
      for (const e8 of i4) {
        const r2 = t.get(e8);
        if (r2.length > 1) {
          o4.push(r2);
          continue;
        }
        const n5 = r2[0];
        this.canonicalIssuer.getId(n5);
      }
      for (const e8 of o4) {
        const t2 = [];
        for (const r2 of e8) {
          if (this.canonicalIssuer.hasId(r2))
            continue;
          const e9 = new Ds("_:b");
          e9.getId(r2);
          const n5 = await this.hashNDegreeQuads(r2, e9);
          t2.push(n5);
        }
        t2.sort(Ms);
        for (const e9 of t2) {
          const t3 = e9.issuer.getOldIds();
          for (const e10 of t3)
            this.canonicalIssuer.getId(e10);
        }
      }
      const a4 = [];
      for (const e8 of this.quads) {
        const t2 = Cs.serializeQuadComponents(this._componentWithCanonicalId(e8.subject), e8.predicate, this._componentWithCanonicalId(e8.object), this._componentWithCanonicalId(e8.graph));
        a4.push(t2);
      }
      return a4.sort(), a4.join("");
    }
    async hashFirstDegreeQuads(e7) {
      const t = [], r = this.blankNodeInfo.get(e7), n4 = r.quads;
      for (const r2 of n4) {
        const n5 = { subject: null, predicate: r2.predicate, object: null, graph: null };
        n5.subject = this.modifyFirstDegreeComponent(e7, r2.subject, "subject"), n5.object = this.modifyFirstDegreeComponent(e7, r2.object, "object"), n5.graph = this.modifyFirstDegreeComponent(e7, r2.graph, "graph"), t.push(Cs.serializeQuad(n5));
      }
      t.sort();
      const i4 = this.createMessageDigest();
      for (const e8 of t)
        i4.update(e8);
      return r.hash = await i4.digest(), r.hash;
    }
    async hashRelatedBlankNode(e7, t, r, n4) {
      let i4;
      i4 = this.canonicalIssuer.hasId(e7) ? this.canonicalIssuer.getId(e7) : r.hasId(e7) ? r.getId(e7) : this.blankNodeInfo.get(e7).hash;
      const o4 = this.createMessageDigest();
      return o4.update(n4), "g" !== n4 && o4.update(this.getRelatedPredicate(t)), o4.update(i4), o4.digest();
    }
    async hashNDegreeQuads(e7, t) {
      const r = this.deepIterations.get(e7) || 0;
      if (r > this.maxDeepIterations)
        throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
      this.deepIterations.set(e7, r + 1);
      const n4 = this.createMessageDigest(), i4 = await this.createHashToRelated(e7, t), o4 = [...i4.keys()].sort();
      for (const e8 of o4) {
        n4.update(e8);
        let r2, o5 = "";
        const a4 = new Os(i4.get(e8));
        let s3 = 0;
        for (; a4.hasNext(); ) {
          const e9 = a4.next();
          ++s3 % 3 == 0 && await this._yield();
          let n5 = t.clone(), i5 = "";
          const l6 = [];
          let u4 = false;
          for (const t2 of e9)
            if (this.canonicalIssuer.hasId(t2) ? i5 += this.canonicalIssuer.getId(t2) : (n5.hasId(t2) || l6.push(t2), i5 += n5.getId(t2)), 0 !== o5.length && i5 > o5) {
              u4 = true;
              break;
            }
          if (!u4) {
            for (const e10 of l6) {
              const t2 = await this.hashNDegreeQuads(e10, n5);
              if (i5 += n5.getId(e10), i5 += `<${t2.hash}>`, n5 = t2.issuer, 0 !== o5.length && i5 > o5) {
                u4 = true;
                break;
              }
            }
            u4 || (0 === o5.length || i5 < o5) && (o5 = i5, r2 = n5);
          }
        }
        n4.update(o5), t = r2;
      }
      return { hash: await n4.digest(), issuer: t };
    }
    modifyFirstDegreeComponent(e7, t) {
      return "BlankNode" !== t.termType ? t : { termType: "BlankNode", value: t.value === e7 ? "_:a" : "_:z" };
    }
    getRelatedPredicate(e7) {
      return `<${e7.predicate.value}>`;
    }
    async createHashToRelated(e7, t) {
      const r = /* @__PURE__ */ new Map(), n4 = this.blankNodeInfo.get(e7).quads;
      let i4 = 0;
      for (const o4 of n4)
        ++i4 % 100 == 0 && await this._yield(), await Promise.all([this._addRelatedBlankNodeHash({ quad: o4, component: o4.subject, position: "s", id: e7, issuer: t, hashToRelated: r }), this._addRelatedBlankNodeHash({ quad: o4, component: o4.object, position: "o", id: e7, issuer: t, hashToRelated: r }), this._addRelatedBlankNodeHash({ quad: o4, component: o4.graph, position: "g", id: e7, issuer: t, hashToRelated: r })]);
      return r;
    }
    async _hashAndTrackBlankNode({ id: e7, hashToBlankNodes: t }) {
      const r = await this.hashFirstDegreeQuads(e7), n4 = t.get(r);
      n4 ? n4.push(e7) : t.set(r, [e7]);
    }
    _addBlankNodeQuadInfo({ quad: e7, component: t }) {
      if ("BlankNode" !== t.termType)
        return;
      const r = t.value, n4 = this.blankNodeInfo.get(r);
      n4 ? n4.quads.add(e7) : this.blankNodeInfo.set(r, { quads: /* @__PURE__ */ new Set([e7]), hash: null });
    }
    async _addRelatedBlankNodeHash({ quad: e7, component: t, position: r, id: n4, issuer: i4, hashToRelated: o4 }) {
      if ("BlankNode" !== t.termType || t.value === n4)
        return;
      const a4 = t.value, s3 = await this.hashRelatedBlankNode(a4, e7, i4, r), l6 = o4.get(s3);
      l6 ? l6.push(a4) : o4.set(s3, [a4]);
    }
    _componentWithCanonicalId(e7) {
      return "BlankNode" !== e7.termType || e7.value.startsWith(this.canonicalIssuer.prefix) ? e7 : { termType: "BlankNode", value: this.canonicalIssuer.getId(e7.value) };
    }
    async _yield() {
      return new Promise((e7) => setImmediate(e7));
    }
  };
  function Ms(e7, t) {
    return e7.hash < t.hash ? -1 : e7.hash > t.hash ? 1 : 0;
  }
  var Ls = ys;
  var Ps = As;
  var Bs = class extends Ps {
    constructor() {
      super(), this.name = "URGNA2012", this.createMessageDigest = () => new Ls("sha1");
    }
    modifyFirstDegreeComponent(e7, t, r) {
      return "BlankNode" !== t.termType ? t : "graph" === r ? { termType: "BlankNode", value: "_:g" } : { termType: "BlankNode", value: t.value === e7 ? "_:a" : "_:z" };
    }
    getRelatedPredicate(e7) {
      return e7.predicate.value;
    }
    async createHashToRelated(e7, t) {
      const r = /* @__PURE__ */ new Map(), n4 = this.blankNodeInfo.get(e7).quads;
      let i4 = 0;
      for (const o4 of n4) {
        let n5, a4;
        if ("BlankNode" === o4.subject.termType && o4.subject.value !== e7)
          a4 = o4.subject.value, n5 = "p";
        else {
          if ("BlankNode" !== o4.object.termType || o4.object.value === e7)
            continue;
          a4 = o4.object.value, n5 = "r";
        }
        ++i4 % 100 == 0 && await this._yield();
        const s3 = await this.hashRelatedBlankNode(a4, o4, t, n5), l6 = r.get(s3);
        l6 ? l6.push(a4) : r.set(s3, [a4]);
      }
      return r;
    }
  };
  var $s = ps;
  var Fs = ys;
  var Us = gs;
  var qs = Is;
  var Ys = class {
    constructor({ createMessageDigest: e7 = () => new Fs("sha256"), canonicalIdMap: t = /* @__PURE__ */ new Map(), maxDeepIterations: r = 1 / 0 } = {}) {
      this.name = "URDNA2015", this.blankNodeInfo = /* @__PURE__ */ new Map(), this.canonicalIssuer = new $s("_:c14n", t), this.createMessageDigest = e7, this.maxDeepIterations = r, this.quads = null, this.deepIterations = null;
    }
    main(e7) {
      this.deepIterations = /* @__PURE__ */ new Map(), this.quads = e7;
      for (const t2 of e7)
        this._addBlankNodeQuadInfo({ quad: t2, component: t2.subject }), this._addBlankNodeQuadInfo({ quad: t2, component: t2.object }), this._addBlankNodeQuadInfo({ quad: t2, component: t2.graph });
      const t = /* @__PURE__ */ new Map(), r = [...this.blankNodeInfo.keys()];
      for (const e8 of r)
        this._hashAndTrackBlankNode({ id: e8, hashToBlankNodes: t });
      const n4 = [...t.keys()].sort(), i4 = [];
      for (const e8 of n4) {
        const r2 = t.get(e8);
        if (r2.length > 1) {
          i4.push(r2);
          continue;
        }
        const n5 = r2[0];
        this.canonicalIssuer.getId(n5);
      }
      for (const e8 of i4) {
        const t2 = [];
        for (const r2 of e8) {
          if (this.canonicalIssuer.hasId(r2))
            continue;
          const e9 = new $s("_:b");
          e9.getId(r2);
          const n5 = this.hashNDegreeQuads(r2, e9);
          t2.push(n5);
        }
        t2.sort(Ws);
        for (const e9 of t2) {
          const t3 = e9.issuer.getOldIds();
          for (const e10 of t3)
            this.canonicalIssuer.getId(e10);
        }
      }
      const o4 = [];
      for (const e8 of this.quads) {
        const t2 = qs.serializeQuadComponents(this._componentWithCanonicalId({ component: e8.subject }), e8.predicate, this._componentWithCanonicalId({ component: e8.object }), this._componentWithCanonicalId({ component: e8.graph }));
        o4.push(t2);
      }
      return o4.sort(), o4.join("");
    }
    hashFirstDegreeQuads(e7) {
      const t = [], r = this.blankNodeInfo.get(e7), n4 = r.quads;
      for (const r2 of n4) {
        const n5 = { subject: null, predicate: r2.predicate, object: null, graph: null };
        n5.subject = this.modifyFirstDegreeComponent(e7, r2.subject, "subject"), n5.object = this.modifyFirstDegreeComponent(e7, r2.object, "object"), n5.graph = this.modifyFirstDegreeComponent(e7, r2.graph, "graph"), t.push(qs.serializeQuad(n5));
      }
      t.sort();
      const i4 = this.createMessageDigest();
      for (const e8 of t)
        i4.update(e8);
      return r.hash = i4.digest(), r.hash;
    }
    hashRelatedBlankNode(e7, t, r, n4) {
      let i4;
      i4 = this.canonicalIssuer.hasId(e7) ? this.canonicalIssuer.getId(e7) : r.hasId(e7) ? r.getId(e7) : this.blankNodeInfo.get(e7).hash;
      const o4 = this.createMessageDigest();
      return o4.update(n4), "g" !== n4 && o4.update(this.getRelatedPredicate(t)), o4.update(i4), o4.digest();
    }
    hashNDegreeQuads(e7, t) {
      const r = this.deepIterations.get(e7) || 0;
      if (r > this.maxDeepIterations)
        throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
      this.deepIterations.set(e7, r + 1);
      const n4 = this.createMessageDigest(), i4 = this.createHashToRelated(e7, t), o4 = [...i4.keys()].sort();
      for (const e8 of o4) {
        n4.update(e8);
        let r2, o5 = "";
        const a4 = new Us(i4.get(e8));
        for (; a4.hasNext(); ) {
          const e9 = a4.next();
          let n5 = t.clone(), i5 = "";
          const s3 = [];
          let l6 = false;
          for (const t2 of e9)
            if (this.canonicalIssuer.hasId(t2) ? i5 += this.canonicalIssuer.getId(t2) : (n5.hasId(t2) || s3.push(t2), i5 += n5.getId(t2)), 0 !== o5.length && i5 > o5) {
              l6 = true;
              break;
            }
          if (!l6) {
            for (const e10 of s3) {
              const t2 = this.hashNDegreeQuads(e10, n5);
              if (i5 += n5.getId(e10), i5 += `<${t2.hash}>`, n5 = t2.issuer, 0 !== o5.length && i5 > o5) {
                l6 = true;
                break;
              }
            }
            l6 || (0 === o5.length || i5 < o5) && (o5 = i5, r2 = n5);
          }
        }
        n4.update(o5), t = r2;
      }
      return { hash: n4.digest(), issuer: t };
    }
    modifyFirstDegreeComponent(e7, t) {
      return "BlankNode" !== t.termType ? t : { termType: "BlankNode", value: t.value === e7 ? "_:a" : "_:z" };
    }
    getRelatedPredicate(e7) {
      return `<${e7.predicate.value}>`;
    }
    createHashToRelated(e7, t) {
      const r = /* @__PURE__ */ new Map(), n4 = this.blankNodeInfo.get(e7).quads;
      for (const i4 of n4)
        this._addRelatedBlankNodeHash({ quad: i4, component: i4.subject, position: "s", id: e7, issuer: t, hashToRelated: r }), this._addRelatedBlankNodeHash({ quad: i4, component: i4.object, position: "o", id: e7, issuer: t, hashToRelated: r }), this._addRelatedBlankNodeHash({ quad: i4, component: i4.graph, position: "g", id: e7, issuer: t, hashToRelated: r });
      return r;
    }
    _hashAndTrackBlankNode({ id: e7, hashToBlankNodes: t }) {
      const r = this.hashFirstDegreeQuads(e7), n4 = t.get(r);
      n4 ? n4.push(e7) : t.set(r, [e7]);
    }
    _addBlankNodeQuadInfo({ quad: e7, component: t }) {
      if ("BlankNode" !== t.termType)
        return;
      const r = t.value, n4 = this.blankNodeInfo.get(r);
      n4 ? n4.quads.add(e7) : this.blankNodeInfo.set(r, { quads: /* @__PURE__ */ new Set([e7]), hash: null });
    }
    _addRelatedBlankNodeHash({ quad: e7, component: t, position: r, id: n4, issuer: i4, hashToRelated: o4 }) {
      if ("BlankNode" !== t.termType || t.value === n4)
        return;
      const a4 = t.value, s3 = this.hashRelatedBlankNode(a4, e7, i4, r), l6 = o4.get(s3);
      l6 ? l6.push(a4) : o4.set(s3, [a4]);
    }
    _componentWithCanonicalId({ component: e7 }) {
      return "BlankNode" !== e7.termType || e7.value.startsWith(this.canonicalIssuer.prefix) ? e7 : { termType: "BlankNode", value: this.canonicalIssuer.getId(e7.value) };
    }
  };
  function Ws(e7, t) {
    return e7.hash < t.hash ? -1 : e7.hash > t.hash ? 1 : 0;
  }
  var zs = ys;
  var Gs = Ys;
  var Hs = class extends Gs {
    constructor() {
      super(), this.name = "URGNA2012", this.createMessageDigest = () => new zs("sha1");
    }
    modifyFirstDegreeComponent(e7, t, r) {
      return "BlankNode" !== t.termType ? t : "graph" === r ? { termType: "BlankNode", value: "_:g" } : { termType: "BlankNode", value: t.value === e7 ? "_:a" : "_:z" };
    }
    getRelatedPredicate(e7) {
      return e7.predicate.value;
    }
    createHashToRelated(e7, t) {
      const r = /* @__PURE__ */ new Map(), n4 = this.blankNodeInfo.get(e7).quads;
      for (const i4 of n4) {
        let n5, o4;
        if ("BlankNode" === i4.subject.termType && i4.subject.value !== e7)
          o4 = i4.subject.value, n5 = "p";
        else {
          if ("BlankNode" !== i4.object.termType || i4.object.value === e7)
            continue;
          o4 = i4.object.value, n5 = "r";
        }
        const a4 = this.hashRelatedBlankNode(o4, i4, t, n5), s3 = r.get(a4);
        s3 ? s3.push(o4) : r.set(a4, [o4]);
      }
      return r;
    }
  };
  var Js = u2(Object.freeze({ __proto__: null, default: {} }));
  !function(e7) {
    const t = As, r = Bs, n4 = Ys, i4 = Hs;
    let o4;
    try {
      o4 = Js;
    } catch (e8) {
    }
    function a4(t2) {
      return Array.isArray(t2) ? t2 : e7.NQuads.legacyDatasetToQuads(t2);
    }
    e7.NQuads = Is, e7.IdentifierIssuer = ps, e7._rdfCanonizeNative = function(e8) {
      return e8 && (o4 = e8), o4;
    }, e7.canonize = async function(e8, n5) {
      const i5 = a4(e8);
      if (n5.useNative) {
        if (!o4)
          throw new Error("rdf-canonize-native not available");
        if (n5.createMessageDigest)
          throw new Error('"createMessageDigest" cannot be used with "useNative".');
        return new Promise((e9, t2) => o4.canonize(i5, n5, (r2, n6) => r2 ? t2(r2) : e9(n6)));
      }
      if ("URDNA2015" === n5.algorithm)
        return new t(n5).main(i5);
      if ("URGNA2012" === n5.algorithm) {
        if (n5.createMessageDigest)
          throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
        return new r(n5).main(i5);
      }
      if (!("algorithm" in n5))
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + n5.algorithm);
    }, e7._canonizeSync = function(e8, t2) {
      const r2 = a4(e8);
      if (t2.useNative) {
        if (!o4)
          throw new Error("rdf-canonize-native not available");
        if (t2.createMessageDigest)
          throw new Error('"createMessageDigest" cannot be used with "useNative".');
        return o4.canonizeSync(r2, t2);
      }
      if ("URDNA2015" === t2.algorithm)
        return new n4(t2).main(r2);
      if ("URGNA2012" === t2.algorithm) {
        if (t2.createMessageDigest)
          throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
        return new i4(t2).main(r2);
      }
      if (!("algorithm" in t2))
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + t2.algorithm);
    };
  }(fs);
  var Vs = fs;
  var Qs = {};
  var Zs = Qs;
  Qs.isArray = Array.isArray, Qs.isBoolean = (e7) => "boolean" == typeof e7 || "[object Boolean]" === Object.prototype.toString.call(e7), Qs.isDouble = (e7) => Qs.isNumber(e7) && (-1 !== String(e7).indexOf(".") || Math.abs(e7) >= 1e21), Qs.isEmptyObject = (e7) => Qs.isObject(e7) && 0 === Object.keys(e7).length, Qs.isNumber = (e7) => "number" == typeof e7 || "[object Number]" === Object.prototype.toString.call(e7), Qs.isNumeric = (e7) => !isNaN(parseFloat(e7)) && isFinite(e7), Qs.isObject = (e7) => "[object Object]" === Object.prototype.toString.call(e7), Qs.isString = (e7) => "string" == typeof e7 || "[object String]" === Object.prototype.toString.call(e7), Qs.isUndefined = (e7) => void 0 === e7;
  var Ks = Zs;
  var Xs = {};
  var el = Xs;
  Xs.isSubject = (e7) => {
    if (Ks.isObject(e7) && !("@value" in e7 || "@set" in e7 || "@list" in e7)) {
      return Object.keys(e7).length > 1 || !("@id" in e7);
    }
    return false;
  }, Xs.isSubjectReference = (e7) => Ks.isObject(e7) && 1 === Object.keys(e7).length && "@id" in e7, Xs.isValue = (e7) => Ks.isObject(e7) && "@value" in e7, Xs.isList = (e7) => Ks.isObject(e7) && "@list" in e7, Xs.isGraph = (e7) => Ks.isObject(e7) && "@graph" in e7 && 1 === Object.keys(e7).filter((e8) => "@id" !== e8 && "@index" !== e8).length, Xs.isSimpleGraph = (e7) => Xs.isGraph(e7) && !("@id" in e7), Xs.isBlankNode = (e7) => {
    if (Ks.isObject(e7)) {
      if ("@id" in e7) {
        const t = e7["@id"];
        return !Ks.isString(t) || 0 === t.indexOf("_:");
      }
      return 0 === Object.keys(e7).length || !("@value" in e7 || "@set" in e7 || "@list" in e7);
    }
    return false;
  };
  var tl = class extends Error {
    constructor(e7 = "An unspecified JSON-LD error occurred.", t = "jsonld.Error", r = {}) {
      super(e7), this.name = t, this.message = e7, this.details = r;
    }
  };
  var rl = l4(tl);
  var nl = el;
  var il = Zs;
  var ol = Vs.IdentifierIssuer;
  var al = tl;
  var sl = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
  var ll = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
  var ul = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
  var cl = { accept: "application/ld+json, application/json" };
  var dl = {};
  var hl = dl;
  function fl(e7, t) {
    if (il.isArray(t))
      for (let r = 0; r < t.length; ++r)
        t[r] = fl(e7, t[r]);
    else if (nl.isList(t))
      t["@list"] = fl(e7, t["@list"]);
    else if (il.isObject(t)) {
      nl.isBlankNode(t) && (t["@id"] = e7.getId(t["@id"]));
      const r = Object.keys(t).sort();
      for (let n4 = 0; n4 < r.length; ++n4) {
        const i4 = r[n4];
        "@id" !== i4 && (t[i4] = fl(e7, t[i4]));
      }
    }
    return t;
  }
  dl.IdentifierIssuer = ol, dl.REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/, dl.REGEX_KEYWORD = /^@[a-zA-Z]+$/, dl.clone = function(e7) {
    if (e7 && "object" == typeof e7) {
      let t;
      if (il.isArray(e7)) {
        t = [];
        for (let r = 0; r < e7.length; ++r)
          t[r] = dl.clone(e7[r]);
      } else if (e7 instanceof Map) {
        t = /* @__PURE__ */ new Map();
        for (const [r, n4] of e7)
          t.set(r, dl.clone(n4));
      } else if (e7 instanceof Set) {
        t = /* @__PURE__ */ new Set();
        for (const r of e7)
          t.add(dl.clone(r));
      } else if (il.isObject(e7)) {
        t = {};
        for (const r in e7)
          t[r] = dl.clone(e7[r]);
      } else
        t = e7.toString();
      return t;
    }
    return e7;
  }, dl.asArray = function(e7) {
    return Array.isArray(e7) ? e7 : [e7];
  }, dl.buildHeaders = (e7 = {}) => {
    const t = Object.keys(e7).some((e8) => "accept" === e8.toLowerCase());
    if (t)
      throw new RangeError('Accept header may not be specified; only "' + cl.accept + '" is supported.');
    return Object.assign({ Accept: cl.accept }, e7);
  }, dl.parseLinkHeader = (e7) => {
    const t = {}, r = e7.match(sl);
    for (let e8 = 0; e8 < r.length; ++e8) {
      let n4 = r[e8].match(ll);
      if (!n4)
        continue;
      const i4 = { target: n4[1] }, o4 = n4[2];
      for (; n4 = ul.exec(o4); )
        i4[n4[1]] = void 0 === n4[2] ? n4[3] : n4[2];
      const a4 = i4.rel || "";
      Array.isArray(t[a4]) ? t[a4].push(i4) : t.hasOwnProperty(a4) ? t[a4] = [t[a4], i4] : t[a4] = i4;
    }
    return t;
  }, dl.validateTypeValue = (e7, t) => {
    if (!(il.isString(e7) || il.isArray(e7) && e7.every((e8) => il.isString(e8)))) {
      if (t && il.isObject(e7))
        switch (Object.keys(e7).length) {
          case 0:
            return;
          case 1:
            if ("@default" in e7 && dl.asArray(e7["@default"]).every((e8) => il.isString(e8)))
              return;
        }
      throw new al('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.', "jsonld.SyntaxError", { code: "invalid type value", value: e7 });
    }
  }, dl.hasProperty = (e7, t) => {
    if (e7.hasOwnProperty(t)) {
      const r = e7[t];
      return !il.isArray(r) || r.length > 0;
    }
    return false;
  }, dl.hasValue = (e7, t, r) => {
    if (dl.hasProperty(e7, t)) {
      let n4 = e7[t];
      const i4 = nl.isList(n4);
      if (il.isArray(n4) || i4) {
        i4 && (n4 = n4["@list"]);
        for (let e8 = 0; e8 < n4.length; ++e8)
          if (dl.compareValues(r, n4[e8]))
            return true;
      } else if (!il.isArray(r))
        return dl.compareValues(r, n4);
    }
    return false;
  }, dl.addValue = (e7, t, r, n4) => {
    if ("propertyIsArray" in (n4 = n4 || {}) || (n4.propertyIsArray = false), "valueIsArray" in n4 || (n4.valueIsArray = false), "allowDuplicate" in n4 || (n4.allowDuplicate = true), "prependValue" in n4 || (n4.prependValue = false), n4.valueIsArray)
      e7[t] = r;
    else if (il.isArray(r)) {
      0 === r.length && n4.propertyIsArray && !e7.hasOwnProperty(t) && (e7[t] = []), n4.prependValue && (r = r.concat(e7[t]), e7[t] = []);
      for (let i4 = 0; i4 < r.length; ++i4)
        dl.addValue(e7, t, r[i4], n4);
    } else if (e7.hasOwnProperty(t)) {
      const i4 = !n4.allowDuplicate && dl.hasValue(e7, t, r);
      il.isArray(e7[t]) || i4 && !n4.propertyIsArray || (e7[t] = [e7[t]]), i4 || (n4.prependValue ? e7[t].unshift(r) : e7[t].push(r));
    } else
      e7[t] = n4.propertyIsArray ? [r] : r;
  }, dl.getValues = (e7, t) => [].concat(e7[t] || []), dl.removeProperty = (e7, t) => {
    delete e7[t];
  }, dl.removeValue = (e7, t, r, n4) => {
    "propertyIsArray" in (n4 = n4 || {}) || (n4.propertyIsArray = false);
    const i4 = dl.getValues(e7, t).filter((e8) => !dl.compareValues(e8, r));
    0 === i4.length ? dl.removeProperty(e7, t) : 1 !== i4.length || n4.propertyIsArray ? e7[t] = i4 : e7[t] = i4[0];
  }, dl.relabelBlankNodes = (e7, t) => fl((t = t || {}).issuer || new ol("_:b"), e7), dl.compareValues = (e7, t) => e7 === t || (!(!nl.isValue(e7) || !nl.isValue(t) || e7["@value"] !== t["@value"] || e7["@type"] !== t["@type"] || e7["@language"] !== t["@language"] || e7["@index"] !== t["@index"]) || !!(il.isObject(e7) && "@id" in e7 && il.isObject(t) && "@id" in t) && e7["@id"] === t["@id"]), dl.compareShortestLeast = (e7, t) => e7.length < t.length ? -1 : t.length < e7.length ? 1 : e7 === t ? 0 : e7 < t ? -1 : 1;
  var pl = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  var ml = "http://www.w3.org/2001/XMLSchema#";
  var yl;
  var gl;
  var vl = { LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context", LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context", RDF: pl, RDF_LIST: pl + "List", RDF_FIRST: pl + "first", RDF_REST: pl + "rest", RDF_NIL: pl + "nil", RDF_TYPE: pl + "type", RDF_PLAIN_LITERAL: pl + "PlainLiteral", RDF_XML_LITERAL: pl + "XMLLiteral", RDF_JSON_LITERAL: pl + "JSON", RDF_OBJECT: pl + "object", RDF_LANGSTRING: pl + "langString", XSD: ml, XSD_BOOLEAN: ml + "boolean", XSD_DOUBLE: ml + "double", XSD_INTEGER: ml + "integer", XSD_STRING: ml + "string" };
  function wl() {
    return gl || (gl = 1, yl = class {
      constructor() {
        this._requests = {};
      }
      wrapLoader(e7) {
        const t = this;
        return t._loader = e7, function() {
          return t.add.apply(t, arguments);
        };
      }
      async add(e7) {
        let t = this._requests[e7];
        if (t)
          return Promise.resolve(t);
        t = this._requests[e7] = this._loader(e7);
        try {
          return await t;
        } finally {
          delete this._requests[e7];
        }
      }
    }), yl;
  }
  var bl = Zs;
  var _l = {};
  var El = _l;
  _l.parsers = { simple: { keys: ["href", "scheme", "authority", "path", "query", "fragment"], regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/ }, full: { keys: ["href", "protocol", "scheme", "authority", "auth", "user", "password", "hostname", "port", "path", "directory", "file", "query", "fragment"], regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ } }, _l.parse = (e7, t) => {
    const r = {}, n4 = _l.parsers[t || "full"], i4 = n4.regex.exec(e7);
    let o4 = n4.keys.length;
    for (; o4--; )
      r[n4.keys[o4]] = void 0 === i4[o4] ? null : i4[o4];
    return ("https" === r.scheme && "443" === r.port || "http" === r.scheme && "80" === r.port) && (r.href = r.href.replace(":" + r.port, ""), r.authority = r.authority.replace(":" + r.port, ""), r.port = null), r.normalizedPath = _l.removeDotSegments(r.path), r;
  }, _l.prependBase = (e7, t) => {
    if (null === e7)
      return t;
    if (_l.isAbsolute(t))
      return t;
    e7 && !bl.isString(e7) || (e7 = _l.parse(e7 || ""));
    const r = _l.parse(t), n4 = { protocol: e7.protocol || "" };
    if (null !== r.authority)
      n4.authority = r.authority, n4.path = r.path, n4.query = r.query;
    else if (n4.authority = e7.authority, "" === r.path)
      n4.path = e7.path, null !== r.query ? n4.query = r.query : n4.query = e7.query;
    else {
      if (0 === r.path.indexOf("/"))
        n4.path = r.path;
      else {
        let t2 = e7.path;
        t2 = t2.substr(0, t2.lastIndexOf("/") + 1), (t2.length > 0 || e7.authority) && "/" !== t2.substr(-1) && (t2 += "/"), t2 += r.path, n4.path = t2;
      }
      n4.query = r.query;
    }
    "" !== r.path && (n4.path = _l.removeDotSegments(n4.path));
    let i4 = n4.protocol;
    return null !== n4.authority && (i4 += "//" + n4.authority), i4 += n4.path, null !== n4.query && (i4 += "?" + n4.query), null !== r.fragment && (i4 += "#" + r.fragment), "" === i4 && (i4 = "./"), i4;
  }, _l.removeBase = (e7, t) => {
    if (null === e7)
      return t;
    e7 && !bl.isString(e7) || (e7 = _l.parse(e7 || ""));
    let r = "";
    if ("" !== e7.href ? r += (e7.protocol || "") + "//" + (e7.authority || "") : t.indexOf("//") && (r += "//"), 0 !== t.indexOf(r))
      return t;
    const n4 = _l.parse(t.substr(r.length)), i4 = e7.normalizedPath.split("/"), o4 = n4.normalizedPath.split("/"), a4 = n4.fragment || n4.query ? 0 : 1;
    for (; i4.length > 0 && o4.length > a4 && i4[0] === o4[0]; )
      i4.shift(), o4.shift();
    let s3 = "";
    if (i4.length > 0) {
      i4.pop();
      for (let e8 = 0; e8 < i4.length; ++e8)
        s3 += "../";
    }
    return s3 += o4.join("/"), null !== n4.query && (s3 += "?" + n4.query), null !== n4.fragment && (s3 += "#" + n4.fragment), "" === s3 && (s3 = "./"), s3;
  }, _l.removeDotSegments = (e7) => {
    if (0 === e7.length)
      return "";
    const t = e7.split("/"), r = [];
    for (; t.length > 0; ) {
      const e8 = t.shift(), n4 = 0 === t.length;
      "." !== e8 ? ".." !== e8 ? r.push(e8) : (r.pop(), n4 && r.push("")) : n4 && r.push("");
    }
    return "/" === e7[0] && r.length > 0 && "" !== r[0] && r.unshift(""), 1 === r.length && "" === r[0] ? "/" : r.join("/");
  };
  var Tl = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
  _l.isAbsolute = (e7) => bl.isString(e7) && Tl.test(e7), _l.isRelative = (e7) => bl.isString(e7);
  var { parseLinkHeader: xl, buildHeaders: Il } = hl;
  var { LINK_HEADER_CONTEXT: Sl } = vl;
  var Rl = tl;
  var kl = wl();
  var { prependBase: jl } = El;
  var Dl = /(^|(\r\n))link:/i;
  var Nl = ({ secure: e7, headers: t = {}, xhr: r } = { headers: {} }) => {
    t = Il(t);
    return new kl().wrapLoader(async function n4(i4) {
      if (0 !== i4.indexOf("http:") && 0 !== i4.indexOf("https:"))
        throw new Rl('URL could not be dereferenced; only "http" and "https" URLs are supported.', "jsonld.InvalidUrl", { code: "loading document failed", url: i4 });
      if (e7 && 0 !== i4.indexOf("https"))
        throw new Rl(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`, "jsonld.InvalidUrl", { code: "loading document failed", url: i4 });
      let o4;
      try {
        o4 = await function(e8, t2, r2) {
          e8 = e8 || XMLHttpRequest;
          const n5 = new e8();
          return new Promise((e9, i5) => {
            n5.onload = () => e9(n5), n5.onerror = (e10) => i5(e10), n5.open("GET", t2, true);
            for (const e10 in r2)
              n5.setRequestHeader(e10, r2[e10]);
            n5.send();
          });
        }(r, i4, t);
      } catch (e8) {
        throw new Rl("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url: i4, cause: e8 });
      }
      if (o4.status >= 400)
        throw new Rl("URL could not be dereferenced: " + o4.statusText, "jsonld.LoadDocumentError", { code: "loading document failed", url: i4, httpStatusCode: o4.status });
      let a4 = { contextUrl: null, documentUrl: i4, document: o4.response }, s3 = null;
      const l6 = o4.getResponseHeader("Content-Type");
      let u4;
      Dl.test(o4.getAllResponseHeaders()) && (u4 = o4.getResponseHeader("Link"));
      if (u4 && "application/ld+json" !== l6) {
        const e8 = xl(u4), t2 = e8[Sl];
        if (Array.isArray(t2))
          throw new Rl("URL could not be dereferenced, it has more than one associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url: i4 });
        t2 && (a4.contextUrl = t2.target), s3 = e8.alternate, s3 && "application/ld+json" == s3.type && !(l6 || "").match(/^application\/(\w*\+)?json$/) && (a4 = await n4(jl(i4, s3.target)));
      }
      return a4;
    });
  };
  var Ol = {};
  var Cl;
  var Al;
  var Ml = Ol;
  Ol.setupDocumentLoaders = function(e7) {
    "undefined" != typeof XMLHttpRequest && (e7.documentLoaders.xhr = Nl, e7.useDocumentLoader("xhr"));
  }, Ol.setupGlobals = function(e7) {
    void 0 === globalThis.JsonLdProcessor && Object.defineProperty(globalThis, "JsonLdProcessor", { writable: true, enumerable: false, configurable: true, value: e7.JsonLdProcessor });
  };
  var Ll = Pl;
  function Pl(e7) {
    var t = this;
    if (t instanceof Pl || (t = new Pl()), t.tail = null, t.head = null, t.length = 0, e7 && "function" == typeof e7.forEach)
      e7.forEach(function(e8) {
        t.push(e8);
      });
    else if (arguments.length > 0)
      for (var r = 0, n4 = arguments.length; r < n4; r++)
        t.push(arguments[r]);
    return t;
  }
  function Bl(e7, t, r) {
    var n4 = t === e7.head ? new Ul(r, null, t, e7) : new Ul(r, t, t.next, e7);
    return null === n4.next && (e7.tail = n4), null === n4.prev && (e7.head = n4), e7.length++, n4;
  }
  function $l(e7, t) {
    e7.tail = new Ul(t, e7.tail, null, e7), e7.head || (e7.head = e7.tail), e7.length++;
  }
  function Fl(e7, t) {
    e7.head = new Ul(t, null, e7.head, e7), e7.tail || (e7.tail = e7.head), e7.length++;
  }
  function Ul(e7, t, r, n4) {
    if (!(this instanceof Ul))
      return new Ul(e7, t, r, n4);
    this.list = n4, this.value = e7, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
  }
  Pl.Node = Ul, Pl.create = Pl, Pl.prototype.removeNode = function(e7) {
    if (e7.list !== this)
      throw new Error("removing node which does not belong to this list");
    var t = e7.next, r = e7.prev;
    return t && (t.prev = r), r && (r.next = t), e7 === this.head && (this.head = t), e7 === this.tail && (this.tail = r), e7.list.length--, e7.next = null, e7.prev = null, e7.list = null, t;
  }, Pl.prototype.unshiftNode = function(e7) {
    if (e7 !== this.head) {
      e7.list && e7.list.removeNode(e7);
      var t = this.head;
      e7.list = this, e7.next = t, t && (t.prev = e7), this.head = e7, this.tail || (this.tail = e7), this.length++;
    }
  }, Pl.prototype.pushNode = function(e7) {
    if (e7 !== this.tail) {
      e7.list && e7.list.removeNode(e7);
      var t = this.tail;
      e7.list = this, e7.prev = t, t && (t.next = e7), this.tail = e7, this.head || (this.head = e7), this.length++;
    }
  }, Pl.prototype.push = function() {
    for (var e7 = 0, t = arguments.length; e7 < t; e7++)
      $l(this, arguments[e7]);
    return this.length;
  }, Pl.prototype.unshift = function() {
    for (var e7 = 0, t = arguments.length; e7 < t; e7++)
      Fl(this, arguments[e7]);
    return this.length;
  }, Pl.prototype.pop = function() {
    if (this.tail) {
      var e7 = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e7;
    }
  }, Pl.prototype.shift = function() {
    if (this.head) {
      var e7 = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e7;
    }
  }, Pl.prototype.forEach = function(e7, t) {
    t = t || this;
    for (var r = this.head, n4 = 0; null !== r; n4++)
      e7.call(t, r.value, n4, this), r = r.next;
  }, Pl.prototype.forEachReverse = function(e7, t) {
    t = t || this;
    for (var r = this.tail, n4 = this.length - 1; null !== r; n4--)
      e7.call(t, r.value, n4, this), r = r.prev;
  }, Pl.prototype.get = function(e7) {
    for (var t = 0, r = this.head; null !== r && t < e7; t++)
      r = r.next;
    if (t === e7 && null !== r)
      return r.value;
  }, Pl.prototype.getReverse = function(e7) {
    for (var t = 0, r = this.tail; null !== r && t < e7; t++)
      r = r.prev;
    if (t === e7 && null !== r)
      return r.value;
  }, Pl.prototype.map = function(e7, t) {
    t = t || this;
    for (var r = new Pl(), n4 = this.head; null !== n4; )
      r.push(e7.call(t, n4.value, this)), n4 = n4.next;
    return r;
  }, Pl.prototype.mapReverse = function(e7, t) {
    t = t || this;
    for (var r = new Pl(), n4 = this.tail; null !== n4; )
      r.push(e7.call(t, n4.value, this)), n4 = n4.prev;
    return r;
  }, Pl.prototype.reduce = function(e7, t) {
    var r, n4 = this.head;
    if (arguments.length > 1)
      r = t;
    else {
      if (!this.head)
        throw new TypeError("Reduce of empty list with no initial value");
      n4 = this.head.next, r = this.head.value;
    }
    for (var i4 = 0; null !== n4; i4++)
      r = e7(r, n4.value, i4), n4 = n4.next;
    return r;
  }, Pl.prototype.reduceReverse = function(e7, t) {
    var r, n4 = this.tail;
    if (arguments.length > 1)
      r = t;
    else {
      if (!this.tail)
        throw new TypeError("Reduce of empty list with no initial value");
      n4 = this.tail.prev, r = this.tail.value;
    }
    for (var i4 = this.length - 1; null !== n4; i4--)
      r = e7(r, n4.value, i4), n4 = n4.prev;
    return r;
  }, Pl.prototype.toArray = function() {
    for (var e7 = new Array(this.length), t = 0, r = this.head; null !== r; t++)
      e7[t] = r.value, r = r.next;
    return e7;
  }, Pl.prototype.toArrayReverse = function() {
    for (var e7 = new Array(this.length), t = 0, r = this.tail; null !== r; t++)
      e7[t] = r.value, r = r.prev;
    return e7;
  }, Pl.prototype.slice = function(e7, t) {
    (t = t || this.length) < 0 && (t += this.length), (e7 = e7 || 0) < 0 && (e7 += this.length);
    var r = new Pl();
    if (t < e7 || t < 0)
      return r;
    e7 < 0 && (e7 = 0), t > this.length && (t = this.length);
    for (var n4 = 0, i4 = this.head; null !== i4 && n4 < e7; n4++)
      i4 = i4.next;
    for (; null !== i4 && n4 < t; n4++, i4 = i4.next)
      r.push(i4.value);
    return r;
  }, Pl.prototype.sliceReverse = function(e7, t) {
    (t = t || this.length) < 0 && (t += this.length), (e7 = e7 || 0) < 0 && (e7 += this.length);
    var r = new Pl();
    if (t < e7 || t < 0)
      return r;
    e7 < 0 && (e7 = 0), t > this.length && (t = this.length);
    for (var n4 = this.length, i4 = this.tail; null !== i4 && n4 > t; n4--)
      i4 = i4.prev;
    for (; null !== i4 && n4 > e7; n4--, i4 = i4.prev)
      r.push(i4.value);
    return r;
  }, Pl.prototype.splice = function(e7, t, ...r) {
    e7 > this.length && (e7 = this.length - 1), e7 < 0 && (e7 = this.length + e7);
    for (var n4 = 0, i4 = this.head; null !== i4 && n4 < e7; n4++)
      i4 = i4.next;
    var o4 = [];
    for (n4 = 0; i4 && n4 < t; n4++)
      o4.push(i4.value), i4 = this.removeNode(i4);
    null === i4 && (i4 = this.tail), i4 !== this.head && i4 !== this.tail && (i4 = i4.prev);
    for (n4 = 0; n4 < r.length; n4++)
      i4 = Bl(this, i4, r[n4]);
    return o4;
  }, Pl.prototype.reverse = function() {
    for (var e7 = this.head, t = this.tail, r = e7; null !== r; r = r.prev) {
      var n4 = r.prev;
      r.prev = r.next, r.next = n4;
    }
    return this.head = t, this.tail = e7, this;
  };
  try {
    (Al || (Al = 1, Cl = function(e7) {
      e7.prototype[Symbol.iterator] = function* () {
        for (let e8 = this.head; e8; e8 = e8.next)
          yield e8.value;
      };
    }), Cl)(Pl);
  } catch (e7) {
  }
  var ql = Ll;
  var Yl = Symbol("max");
  var Wl = Symbol("length");
  var zl = Symbol("lengthCalculator");
  var Gl = Symbol("allowStale");
  var Hl = Symbol("maxAge");
  var Jl = Symbol("dispose");
  var Vl = Symbol("noDisposeOnSet");
  var Ql = Symbol("lruList");
  var Zl = Symbol("cache");
  var Kl = Symbol("updateAgeOnGet");
  var Xl = () => 1;
  var eu = (e7, t, r) => {
    const n4 = e7[Zl].get(t);
    if (n4) {
      const t2 = n4.value;
      if (tu(e7, t2)) {
        if (nu(e7, n4), !e7[Gl])
          return;
      } else
        r && (e7[Kl] && (n4.value.now = Date.now()), e7[Ql].unshiftNode(n4));
      return t2.value;
    }
  };
  var tu = (e7, t) => {
    if (!t || !t.maxAge && !e7[Hl])
      return false;
    const r = Date.now() - t.now;
    return t.maxAge ? r > t.maxAge : e7[Hl] && r > e7[Hl];
  };
  var ru = (e7) => {
    if (e7[Wl] > e7[Yl])
      for (let t = e7[Ql].tail; e7[Wl] > e7[Yl] && null !== t; ) {
        const r = t.prev;
        nu(e7, t), t = r;
      }
  };
  var nu = (e7, t) => {
    if (t) {
      const r = t.value;
      e7[Jl] && e7[Jl](r.key, r.value), e7[Wl] -= r.length, e7[Zl].delete(r.key), e7[Ql].removeNode(t);
    }
  };
  var iu = class {
    constructor(e7, t, r, n4, i4) {
      this.key = e7, this.value = t, this.length = r, this.now = n4, this.maxAge = i4 || 0;
    }
  };
  var ou = (e7, t, r, n4) => {
    let i4 = r.value;
    tu(e7, i4) && (nu(e7, r), e7[Gl] || (i4 = void 0)), i4 && t.call(n4, i4.value, i4.key, e7);
  };
  var au = class {
    constructor(e7) {
      if ("number" == typeof e7 && (e7 = { max: e7 }), e7 || (e7 = {}), e7.max && ("number" != typeof e7.max || e7.max < 0))
        throw new TypeError("max must be a non-negative number");
      this[Yl] = e7.max || 1 / 0;
      const t = e7.length || Xl;
      if (this[zl] = "function" != typeof t ? Xl : t, this[Gl] = e7.stale || false, e7.maxAge && "number" != typeof e7.maxAge)
        throw new TypeError("maxAge must be a number");
      this[Hl] = e7.maxAge || 0, this[Jl] = e7.dispose, this[Vl] = e7.noDisposeOnSet || false, this[Kl] = e7.updateAgeOnGet || false, this.reset();
    }
    set max(e7) {
      if ("number" != typeof e7 || e7 < 0)
        throw new TypeError("max must be a non-negative number");
      this[Yl] = e7 || 1 / 0, ru(this);
    }
    get max() {
      return this[Yl];
    }
    set allowStale(e7) {
      this[Gl] = !!e7;
    }
    get allowStale() {
      return this[Gl];
    }
    set maxAge(e7) {
      if ("number" != typeof e7)
        throw new TypeError("maxAge must be a non-negative number");
      this[Hl] = e7, ru(this);
    }
    get maxAge() {
      return this[Hl];
    }
    set lengthCalculator(e7) {
      "function" != typeof e7 && (e7 = Xl), e7 !== this[zl] && (this[zl] = e7, this[Wl] = 0, this[Ql].forEach((e8) => {
        e8.length = this[zl](e8.value, e8.key), this[Wl] += e8.length;
      })), ru(this);
    }
    get lengthCalculator() {
      return this[zl];
    }
    get length() {
      return this[Wl];
    }
    get itemCount() {
      return this[Ql].length;
    }
    rforEach(e7, t) {
      t = t || this;
      for (let r = this[Ql].tail; null !== r; ) {
        const n4 = r.prev;
        ou(this, e7, r, t), r = n4;
      }
    }
    forEach(e7, t) {
      t = t || this;
      for (let r = this[Ql].head; null !== r; ) {
        const n4 = r.next;
        ou(this, e7, r, t), r = n4;
      }
    }
    keys() {
      return this[Ql].toArray().map((e7) => e7.key);
    }
    values() {
      return this[Ql].toArray().map((e7) => e7.value);
    }
    reset() {
      this[Jl] && this[Ql] && this[Ql].length && this[Ql].forEach((e7) => this[Jl](e7.key, e7.value)), this[Zl] = /* @__PURE__ */ new Map(), this[Ql] = new ql(), this[Wl] = 0;
    }
    dump() {
      return this[Ql].map((e7) => !tu(this, e7) && { k: e7.key, v: e7.value, e: e7.now + (e7.maxAge || 0) }).toArray().filter((e7) => e7);
    }
    dumpLru() {
      return this[Ql];
    }
    set(e7, t, r) {
      if ((r = r || this[Hl]) && "number" != typeof r)
        throw new TypeError("maxAge must be a number");
      const n4 = r ? Date.now() : 0, i4 = this[zl](t, e7);
      if (this[Zl].has(e7)) {
        if (i4 > this[Yl])
          return nu(this, this[Zl].get(e7)), false;
        const o5 = this[Zl].get(e7).value;
        return this[Jl] && (this[Vl] || this[Jl](e7, o5.value)), o5.now = n4, o5.maxAge = r, o5.value = t, this[Wl] += i4 - o5.length, o5.length = i4, this.get(e7), ru(this), true;
      }
      const o4 = new iu(e7, t, i4, n4, r);
      return o4.length > this[Yl] ? (this[Jl] && this[Jl](e7, t), false) : (this[Wl] += o4.length, this[Ql].unshift(o4), this[Zl].set(e7, this[Ql].head), ru(this), true);
    }
    has(e7) {
      if (!this[Zl].has(e7))
        return false;
      const t = this[Zl].get(e7).value;
      return !tu(this, t);
    }
    get(e7) {
      return eu(this, e7, true);
    }
    peek(e7) {
      return eu(this, e7, false);
    }
    pop() {
      const e7 = this[Ql].tail;
      return e7 ? (nu(this, e7), e7.value) : null;
    }
    del(e7) {
      nu(this, this[Zl].get(e7));
    }
    load(e7) {
      this.reset();
      const t = Date.now();
      for (let r = e7.length - 1; r >= 0; r--) {
        const n4 = e7[r], i4 = n4.e || 0;
        if (0 === i4)
          this.set(n4.k, n4.v);
        else {
          const e8 = i4 - t;
          e8 > 0 && this.set(n4.k, n4.v, e8);
        }
      }
    }
    prune() {
      this[Zl].forEach((e7, t) => eu(this, t, false));
    }
  };
  var su = au;
  var { isArray: lu, isObject: uu, isString: cu } = Zs;
  var { asArray: du } = hl;
  var { prependBase: hu } = El;
  var fu = tl;
  var pu = class {
    constructor({ document: e7 }) {
      this.document = e7, this.cache = new su({ max: 10 });
    }
    getProcessed(e7) {
      return this.cache.get(e7);
    }
    setProcessed(e7, t) {
      this.cache.set(e7, t);
    }
  };
  function mu(e7) {
    throw new fu("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", { code: "invalid local context", context: e7 });
  }
  function yu({ context: e7, base: t }) {
    if (!e7)
      return;
    const r = e7["@context"];
    if (cu(r))
      e7["@context"] = hu(t, r);
    else if (lu(r))
      for (let e8 = 0; e8 < r.length; ++e8) {
        const n4 = r[e8];
        cu(n4) ? r[e8] = hu(t, n4) : uu(n4) && yu({ context: { "@context": n4 }, base: t });
      }
    else if (uu(r))
      for (const e8 in r)
        yu({ context: r[e8], base: t });
  }
  var gu = Vs.NQuads;
  var vu = tl;
  var { isArray: wu } = Zs;
  var { asArray: bu } = hl;
  var _u = {};
  var Eu = _u;
  function Tu({ event: e7, handlers: t }) {
    let r = true;
    for (let n4 = 0; r && n4 < t.length; ++n4) {
      r = false;
      const i4 = t[n4];
      if (wu(i4))
        r = Tu({ event: e7, handlers: i4 });
      else if ("function" == typeof i4)
        i4({ event: e7, next: () => {
          r = true;
        } });
      else {
        if ("object" != typeof i4)
          throw new vu("Invalid event handler.", "jsonld.InvalidEventHandler", { event: e7 });
        e7.code in i4 ? i4[e7.code]({ event: e7, next: () => {
          r = true;
        } }) : r = true;
      }
    }
    return r;
  }
  _u.defaultEventHandler = null, _u.setupEventHandler = ({ options: e7 = {} }) => {
    const t = [].concat(e7.safe ? _u.safeEventHandler : [], e7.eventHandler ? bu(e7.eventHandler) : [], _u.defaultEventHandler ? _u.defaultEventHandler : []);
    return 0 === t.length ? null : t;
  }, _u.handleEvent = ({ event: e7, options: t }) => {
    Tu({ event: e7, handlers: t.eventHandler });
  };
  var xu = /* @__PURE__ */ new Set(["empty object", "free-floating scalar", "invalid @language value", "invalid property", "null @id value", "null @value value", "object with only @id", "object with only @language", "object with only @list", "object with only @value", "relative @id reference", "relative @type reference", "relative @vocab reference", "reserved @id value", "reserved @reverse value", "reserved term", "blank node predicate", "relative graph reference", "relative object reference", "relative predicate reference", "relative subject reference", "rdfDirection not set"]);
  _u.safeEventHandler = function({ event: e7, next: t }) {
    if ("warning" === e7.level && xu.has(e7.code))
      throw new vu("Safe mode validation error.", "jsonld.ValidationError", { event: e7 });
    t();
  }, _u.logEventHandler = function({ event: e7, next: t }) {
    console.log(`EVENT: ${e7.message}`, { event: e7 }), t();
  }, _u.logWarningEventHandler = function({ event: e7, next: t }) {
    "warning" === e7.level && console.warn(`WARNING: ${e7.message}`, { event: e7 }), t();
  }, _u.unhandledEventHandler = function({ event: e7 }) {
    throw new vu("No handler for event.", "jsonld.UnhandledEvent", { event: e7 });
  }, _u.setDefaultEventHandler = function({ eventHandler: e7 } = {}) {
    _u.defaultEventHandler = e7 ? bu(e7) : null;
  };
  var Iu = hl;
  var Su = tl;
  var { isArray: Ru, isObject: ku, isString: ju, isUndefined: Du } = Zs;
  var { isAbsolute: Nu, isRelative: Ou, prependBase: Cu } = El;
  var { handleEvent: Au } = Eu;
  var { REGEX_BCP47: Mu, REGEX_KEYWORD: Lu, asArray: Pu, compareShortestLeast: Bu } = hl;
  var $u = /* @__PURE__ */ new Map();
  var Fu = {};
  var Uu = Fu;
  function qu(e7, t, r, n4, i4, o4) {
    if (null === t || !ju(t) || Fu.isKeyword(t))
      return t;
    if (t.match(Lu))
      return null;
    if (n4 && n4.hasOwnProperty(t) && true !== i4.get(t) && Fu.createTermDefinition({ activeCtx: e7, localCtx: n4, term: t, defined: i4, options: o4 }), (r = r || {}).vocab) {
      const r2 = e7.mappings.get(t);
      if (null === r2)
        return null;
      if (ku(r2) && "@id" in r2)
        return r2["@id"];
    }
    const a4 = t.indexOf(":");
    if (a4 > 0) {
      const r2 = t.substr(0, a4), s3 = t.substr(a4 + 1);
      if ("_" === r2 || 0 === s3.indexOf("//"))
        return t;
      n4 && n4.hasOwnProperty(r2) && Fu.createTermDefinition({ activeCtx: e7, localCtx: n4, term: r2, defined: i4, options: o4 });
      const l6 = e7.mappings.get(r2);
      if (l6 && l6._prefix)
        return l6["@id"] + s3;
      if (Nu(t))
        return t;
    }
    if (r.vocab && "@vocab" in e7) {
      t = e7["@vocab"] + t;
    } else if (r.base) {
      let r2, n5;
      "@base" in e7 ? e7["@base"] ? (n5 = Cu(o4.base, e7["@base"]), r2 = Cu(n5, t)) : (n5 = e7["@base"], r2 = t) : (n5 = o4.base, r2 = Cu(o4.base, t)), t = r2;
    }
    return t;
  }
  function Yu(e7, t) {
    if (!e7 || "object" != typeof e7 || !t || "object" != typeof t)
      return e7 === t;
    const r = Array.isArray(e7);
    if (r !== Array.isArray(t))
      return false;
    if (r) {
      if (e7.length !== t.length)
        return false;
      for (let r2 = 0; r2 < e7.length; ++r2)
        if (!Yu(e7[r2], t[r2]))
          return false;
      return true;
    }
    const n4 = Object.keys(e7), i4 = Object.keys(t);
    if (n4.length !== i4.length)
      return false;
    for (const r2 in e7) {
      let n5 = e7[r2], i5 = t[r2];
      if ("@container" === r2 && Array.isArray(n5) && Array.isArray(i5) && (n5 = n5.slice().sort(), i5 = i5.slice().sort()), !Yu(n5, i5))
        return false;
    }
    return true;
  }
  Fu.process = async ({ activeCtx: e7, localCtx: t, options: r, propagate: n4 = true, overrideProtected: i4 = false, cycles: o4 = /* @__PURE__ */ new Set() }) => {
    ku(t) && "@context" in t && Ru(t["@context"]) && (t = t["@context"]);
    if (0 === Pu(t).length)
      return e7;
    const a4 = [], s3 = [({ event: e8, next: t2 }) => {
      a4.push(e8), t2();
    }];
    r.eventHandler && s3.push(r.eventHandler);
    const l6 = r;
    r = { ...r, eventHandler: s3 };
    const u4 = await r.contextResolver.resolve({ activeCtx: e7, context: t, documentLoader: r.documentLoader, base: r.base });
    ku(u4[0].document) && "boolean" == typeof u4[0].document["@propagate"] && (n4 = u4[0].document["@propagate"]);
    let c3 = e7;
    n4 || c3.previousContext || (c3 = c3.clone(), c3.previousContext = e7);
    for (const n5 of u4) {
      let { document: s4 } = n5;
      if (e7 = c3, null === s4) {
        if (!i4 && 0 !== Object.keys(e7.protected).length)
          throw new Su("Tried to nullify a context with protected terms outside of a term definition.", "jsonld.SyntaxError", { code: "invalid context nullification" });
        c3 = e7 = Fu.getInitialContext(r).clone();
        continue;
      }
      const u5 = n5.getProcessed(e7);
      if (u5) {
        if (l6.eventHandler)
          for (const e8 of u5.events)
            Au({ event: e8, options: l6 });
        c3 = e7 = u5.context;
        continue;
      }
      if (ku(s4) && "@context" in s4 && (s4 = s4["@context"]), !ku(s4))
        throw new Su("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", { code: "invalid local context", context: s4 });
      c3 = c3.clone();
      const d5 = /* @__PURE__ */ new Map();
      if ("@version" in s4) {
        if (1.1 !== s4["@version"])
          throw new Su("Unsupported JSON-LD version: " + s4["@version"], "jsonld.UnsupportedVersion", { code: "invalid @version value", context: s4 });
        if (e7.processingMode && "json-ld-1.0" === e7.processingMode)
          throw new Su("@version: " + s4["@version"] + " not compatible with " + e7.processingMode, "jsonld.ProcessingModeConflict", { code: "processing mode conflict", context: s4 });
        c3.processingMode = "json-ld-1.1", c3["@version"] = s4["@version"], d5.set("@version", true);
      }
      if (c3.processingMode = c3.processingMode || e7.processingMode, "@base" in s4) {
        let e8 = s4["@base"];
        if (null === e8 || Nu(e8))
          ;
        else {
          if (!Ou(e8))
            throw new Su('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.', "jsonld.SyntaxError", { code: "invalid base IRI", context: s4 });
          e8 = Cu(c3["@base"], e8);
        }
        c3["@base"] = e8, d5.set("@base", true);
      }
      if ("@vocab" in s4) {
        const e8 = s4["@vocab"];
        if (null === e8)
          delete c3["@vocab"];
        else {
          if (!ju(e8))
            throw new Su('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: s4 });
          if (!Nu(e8) && Fu.processingMode(c3, 1))
            throw new Su('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: s4 });
          {
            const t2 = qu(c3, e8, { vocab: true, base: true }, void 0, void 0, r);
            Nu(t2) || r.eventHandler && Au({ event: { type: ["JsonLdEvent"], code: "relative @vocab reference", level: "warning", message: "Relative @vocab reference found.", details: { vocab: t2 } }, options: r }), c3["@vocab"] = t2;
          }
        }
        d5.set("@vocab", true);
      }
      if ("@language" in s4) {
        const e8 = s4["@language"];
        if (null === e8)
          delete c3["@language"];
        else {
          if (!ju(e8))
            throw new Su('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid default language", context: s4 });
          e8.match(Mu) || r.eventHandler && Au({ event: { type: ["JsonLdEvent"], code: "invalid @language value", level: "warning", message: "@language value must be valid BCP47.", details: { language: e8 } }, options: r }), c3["@language"] = e8.toLowerCase();
        }
        d5.set("@language", true);
      }
      if ("@direction" in s4) {
        const t2 = s4["@direction"];
        if ("json-ld-1.0" === e7.processingMode)
          throw new Su("Invalid JSON-LD syntax; @direction not compatible with " + e7.processingMode, "jsonld.SyntaxError", { code: "invalid context member", context: s4 });
        if (null === t2)
          delete c3["@direction"];
        else {
          if ("ltr" !== t2 && "rtl" !== t2)
            throw new Su('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: s4 });
          c3["@direction"] = t2;
        }
        d5.set("@direction", true);
      }
      if ("@propagate" in s4) {
        const r2 = s4["@propagate"];
        if ("json-ld-1.0" === e7.processingMode)
          throw new Su("Invalid JSON-LD syntax; @propagate not compatible with " + e7.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: s4 });
        if ("boolean" != typeof r2)
          throw new Su("Invalid JSON-LD syntax; @propagate value must be a boolean.", "jsonld.SyntaxError", { code: "invalid @propagate value", context: t });
        d5.set("@propagate", true);
      }
      if ("@import" in s4) {
        const n6 = s4["@import"];
        if ("json-ld-1.0" === e7.processingMode)
          throw new Su("Invalid JSON-LD syntax; @import not compatible with " + e7.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: s4 });
        if (!ju(n6))
          throw new Su("Invalid JSON-LD syntax; @import must be a string.", "jsonld.SyntaxError", { code: "invalid @import value", context: t });
        const i5 = await r.contextResolver.resolve({ activeCtx: e7, context: n6, documentLoader: r.documentLoader, base: r.base });
        if (1 !== i5.length)
          throw new Su("Invalid JSON-LD syntax; @import must reference a single context.", "jsonld.SyntaxError", { code: "invalid remote context", context: t });
        const o5 = i5[0].getProcessed(e7);
        if (o5)
          s4 = o5;
        else {
          const r2 = i5[0].document;
          if ("@import" in r2)
            throw new Su("Invalid JSON-LD syntax: imported context must not include @import.", "jsonld.SyntaxError", { code: "invalid context entry", context: t });
          for (const e8 in r2)
            s4.hasOwnProperty(e8) || (s4[e8] = r2[e8]);
          i5[0].setProcessed(e7, s4);
        }
        d5.set("@import", true);
      }
      d5.set("@protected", s4["@protected"] || false);
      for (const e8 in s4)
        if (Fu.createTermDefinition({ activeCtx: c3, localCtx: s4, term: e8, defined: d5, options: r, overrideProtected: i4 }), ku(s4[e8]) && "@context" in s4[e8]) {
          const t2 = s4[e8]["@context"];
          let n6 = true;
          if (ju(t2)) {
            const e9 = Cu(r.base, t2);
            o4.has(e9) ? n6 = false : o4.add(e9);
          }
          if (n6)
            try {
              await Fu.process({ activeCtx: c3.clone(), localCtx: s4[e8]["@context"], overrideProtected: true, options: r, cycles: o4 });
            } catch (t3) {
              throw new Su("Invalid JSON-LD syntax; invalid scoped context.", "jsonld.SyntaxError", { code: "invalid scoped context", context: s4[e8]["@context"], term: e8 });
            }
        }
      n5.setProcessed(e7, { context: c3, events: a4 });
    }
    return c3;
  }, Fu.createTermDefinition = ({ activeCtx: e7, localCtx: t, term: r, defined: n4, options: i4, overrideProtected: o4 = false }) => {
    if (n4.has(r)) {
      if (n4.get(r))
        return;
      throw new Su("Cyclical context definition detected.", "jsonld.CyclicalContext", { code: "cyclic IRI mapping", context: t, term: r });
    }
    let a4;
    if (n4.set(r, false), t.hasOwnProperty(r) && (a4 = t[r]), "@type" === r && ku(a4) && "@set" === (a4["@container"] || "@set") && Fu.processingMode(e7, 1.1)) {
      const e8 = ["@container", "@id", "@protected"], n5 = Object.keys(a4);
      if (0 === n5.length || n5.some((t2) => !e8.includes(t2)))
        throw new Su("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: t, term: r });
    } else {
      if (Fu.isKeyword(r))
        throw new Su("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: t, term: r });
      if (r.match(Lu))
        return void (i4.eventHandler && Au({ event: { type: ["JsonLdEvent"], code: "reserved term", level: "warning", message: 'Terms beginning with "@" are reserved for future use and dropped.', details: { term: r } }, options: i4 }));
      if ("" === r)
        throw new Su("Invalid JSON-LD syntax; a term cannot be an empty string.", "jsonld.SyntaxError", { code: "invalid term definition", context: t });
    }
    const s3 = e7.mappings.get(r);
    e7.mappings.has(r) && e7.mappings.delete(r);
    let l6 = false;
    if ((ju(a4) || null === a4) && (l6 = true, a4 = { "@id": a4 }), !ku(a4))
      throw new Su("Invalid JSON-LD syntax; @context term values must be strings or objects.", "jsonld.SyntaxError", { code: "invalid term definition", context: t });
    const u4 = {};
    e7.mappings.set(r, u4), u4.reverse = false;
    const c3 = ["@container", "@id", "@language", "@reverse", "@type"];
    Fu.processingMode(e7, 1.1) && c3.push("@context", "@direction", "@index", "@nest", "@prefix", "@protected");
    for (const e8 in a4)
      if (!c3.includes(e8))
        throw new Su("Invalid JSON-LD syntax; a term definition must not contain " + e8, "jsonld.SyntaxError", { code: "invalid term definition", context: t });
    const d5 = r.indexOf(":");
    if (u4._termHasColon = d5 > 0, "@reverse" in a4) {
      if ("@id" in a4)
        throw new Su("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.", "jsonld.SyntaxError", { code: "invalid reverse property", context: t });
      if ("@nest" in a4)
        throw new Su("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.", "jsonld.SyntaxError", { code: "invalid reverse property", context: t });
      const o5 = a4["@reverse"];
      if (!ju(o5))
        throw new Su("Invalid JSON-LD syntax; a @context @reverse value must be a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t });
      if (o5.match(Lu))
        return i4.eventHandler && Au({ event: { type: ["JsonLdEvent"], code: "reserved @reverse value", level: "warning", message: '@reverse values beginning with "@" are reserved for future use and dropped.', details: { reverse: o5 } }, options: i4 }), void (s3 ? e7.mappings.set(r, s3) : e7.mappings.delete(r));
      const l7 = qu(e7, o5, { vocab: true, base: false }, t, n4, i4);
      if (!Nu(l7))
        throw new Su("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t });
      u4["@id"] = l7, u4.reverse = true;
    } else if ("@id" in a4) {
      let o5 = a4["@id"];
      if (o5 && !ju(o5))
        throw new Su("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t });
      if (null === o5)
        u4["@id"] = null;
      else {
        if (!Fu.isKeyword(o5) && o5.match(Lu))
          return i4.eventHandler && Au({ event: { type: ["JsonLdEvent"], code: "reserved @id value", level: "warning", message: '@id values beginning with "@" are reserved for future use and dropped.', details: { id: o5 } }, options: i4 }), void (s3 ? e7.mappings.set(r, s3) : e7.mappings.delete(r));
        if (o5 !== r) {
          if (o5 = qu(e7, o5, { vocab: true, base: false }, t, n4, i4), !Nu(o5) && !Fu.isKeyword(o5))
            throw new Su("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t });
          if (r.match(/(?::[^:])|\//)) {
            if (qu(e7, r, { vocab: true, base: false }, t, new Map(n4).set(r, true), i4) !== o5)
              throw new Su("Invalid JSON-LD syntax; term in form of IRI must expand to definition.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t });
          }
          u4["@id"] = o5, u4._prefix = l6 && !u4._termHasColon && null !== o5.match(/[:\/\?#\[\]@]$/);
        }
      }
    }
    if (!("@id" in u4))
      if (u4._termHasColon) {
        const o5 = r.substr(0, d5);
        if (t.hasOwnProperty(o5) && Fu.createTermDefinition({ activeCtx: e7, localCtx: t, term: o5, defined: n4, options: i4 }), e7.mappings.has(o5)) {
          const t2 = r.substr(d5 + 1);
          u4["@id"] = e7.mappings.get(o5)["@id"] + t2;
        } else
          u4["@id"] = r;
      } else if ("@type" === r)
        u4["@id"] = r;
      else {
        if (!("@vocab" in e7))
          throw new Su("Invalid JSON-LD syntax; @context terms must define an @id.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: t, term: r });
        u4["@id"] = e7["@vocab"] + r;
      }
    if ((true === a4["@protected"] || true === n4.get("@protected") && false !== a4["@protected"]) && (e7.protected[r] = true, u4.protected = true), n4.set(r, true), "@type" in a4) {
      let r2 = a4["@type"];
      if (!ju(r2))
        throw new Su("Invalid JSON-LD syntax; an @context @type value must be a string.", "jsonld.SyntaxError", { code: "invalid type mapping", context: t });
      if ("@json" === r2 || "@none" === r2) {
        if (Fu.processingMode(e7, 1))
          throw new Su(`Invalid JSON-LD syntax; an @context @type value must not be "${r2}" in JSON-LD 1.0 mode.`, "jsonld.SyntaxError", { code: "invalid type mapping", context: t });
      } else if ("@id" !== r2 && "@vocab" !== r2) {
        if (r2 = qu(e7, r2, { vocab: true, base: false }, t, n4, i4), !Nu(r2))
          throw new Su("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.", "jsonld.SyntaxError", { code: "invalid type mapping", context: t });
        if (0 === r2.indexOf("_:"))
          throw new Su("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.", "jsonld.SyntaxError", { code: "invalid type mapping", context: t });
      }
      u4["@type"] = r2;
    }
    if ("@container" in a4) {
      const r2 = ju(a4["@container"]) ? [a4["@container"]] : a4["@container"] || [], n5 = ["@list", "@set", "@index", "@language"];
      let i5 = true;
      const o5 = r2.includes("@set");
      if (Fu.processingMode(e7, 1.1)) {
        if (n5.push("@graph", "@id", "@type"), r2.includes("@list")) {
          if (1 !== r2.length)
            throw new Su("Invalid JSON-LD syntax; @context @container with @list must have no other values", "jsonld.SyntaxError", { code: "invalid container mapping", context: t });
        } else if (r2.includes("@graph")) {
          if (r2.some((e8) => "@graph" !== e8 && "@id" !== e8 && "@index" !== e8 && "@set" !== e8))
            throw new Su("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set", "jsonld.SyntaxError", { code: "invalid container mapping", context: t });
        } else
          i5 &= r2.length <= (o5 ? 2 : 1);
        if (r2.includes("@type") && (u4["@type"] = u4["@type"] || "@id", !["@id", "@vocab"].includes(u4["@type"])))
          throw new Su("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.", "jsonld.SyntaxError", { code: "invalid type mapping", context: t });
      } else
        i5 &= !Ru(a4["@container"]), i5 &= r2.length <= 1;
      if (i5 &= r2.every((e8) => n5.includes(e8)), i5 &= !(o5 && r2.includes("@list")), !i5)
        throw new Su("Invalid JSON-LD syntax; @context @container value must be one of the following: " + n5.join(", "), "jsonld.SyntaxError", { code: "invalid container mapping", context: t });
      if (u4.reverse && !r2.every((e8) => ["@index", "@set"].includes(e8)))
        throw new Su("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.", "jsonld.SyntaxError", { code: "invalid reverse property", context: t });
      u4["@container"] = r2;
    }
    if ("@index" in a4) {
      if (!("@container" in a4) || !u4["@container"].includes("@index"))
        throw new Su(`Invalid JSON-LD syntax; @index without @index in @container: "${a4["@index"]}" on term "${r}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: t });
      if (!ju(a4["@index"]) || 0 === a4["@index"].indexOf("@"))
        throw new Su(`Invalid JSON-LD syntax; @index must expand to an IRI: "${a4["@index"]}" on term "${r}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: t });
      u4["@index"] = a4["@index"];
    }
    if ("@context" in a4 && (u4["@context"] = a4["@context"]), "@language" in a4 && !("@type" in a4)) {
      let e8 = a4["@language"];
      if (null !== e8 && !ju(e8))
        throw new Su("Invalid JSON-LD syntax; @context @language value must be a string or null.", "jsonld.SyntaxError", { code: "invalid language mapping", context: t });
      null !== e8 && (e8 = e8.toLowerCase()), u4["@language"] = e8;
    }
    if ("@prefix" in a4) {
      if (r.match(/:|\//))
        throw new Su("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term", "jsonld.SyntaxError", { code: "invalid term definition", context: t });
      if (Fu.isKeyword(u4["@id"]))
        throw new Su("Invalid JSON-LD syntax; keywords may not be used as prefixes", "jsonld.SyntaxError", { code: "invalid term definition", context: t });
      if ("boolean" != typeof a4["@prefix"])
        throw new Su("Invalid JSON-LD syntax; @context value for @prefix must be boolean", "jsonld.SyntaxError", { code: "invalid @prefix value", context: t });
      u4._prefix = true === a4["@prefix"];
    }
    if ("@direction" in a4) {
      const e8 = a4["@direction"];
      if (null !== e8 && "ltr" !== e8 && "rtl" !== e8)
        throw new Su('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: t });
      u4["@direction"] = e8;
    }
    if ("@nest" in a4) {
      const e8 = a4["@nest"];
      if (!ju(e8) || "@nest" !== e8 && 0 === e8.indexOf("@"))
        throw new Su("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.", "jsonld.SyntaxError", { code: "invalid @nest value", context: t });
      u4["@nest"] = e8;
    }
    const h6 = u4["@id"];
    if ("@context" === h6 || "@preserve" === h6)
      throw new Su("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.", "jsonld.SyntaxError", { code: "invalid keyword alias", context: t });
    if (s3 && s3.protected && !o4 && (e7.protected[r] = true, u4.protected = true, !Yu(s3, u4)))
      throw new Su("Invalid JSON-LD syntax; tried to redefine a protected term.", "jsonld.SyntaxError", { code: "protected term redefinition", context: t, term: r });
  }, Fu.expandIri = (e7, t, r, n4) => qu(e7, t, r, void 0, void 0, n4), Fu.getInitialContext = (e7) => {
    const t = JSON.stringify({ processingMode: e7.processingMode }), r = $u.get(t);
    if (r)
      return r;
    const n4 = { processingMode: e7.processingMode, mappings: /* @__PURE__ */ new Map(), inverse: null, getInverse: function() {
      const e8 = this;
      if (e8.inverse)
        return e8.inverse;
      const t2 = e8.inverse = {}, r2 = e8.fastCurieMap = {}, n5 = {}, a4 = (e8["@language"] || "@none").toLowerCase(), s3 = e8["@direction"], l6 = e8.mappings, u4 = [...l6.keys()].sort(Bu);
      for (const e9 of u4) {
        const i5 = l6.get(e9);
        if (null === i5)
          continue;
        let u5 = i5["@container"] || "@none";
        if (u5 = [].concat(u5).sort().join(""), null === i5["@id"])
          continue;
        const c3 = Pu(i5["@id"]);
        for (const l7 of c3) {
          let c4 = t2[l7];
          const d5 = Fu.isKeyword(l7);
          if (c4)
            d5 || i5._termHasColon || n5[l7].push(e9);
          else if (t2[l7] = c4 = {}, !d5 && !i5._termHasColon) {
            n5[l7] = [e9];
            const t3 = { iri: l7, terms: n5[l7] };
            l7[0] in r2 ? r2[l7[0]].push(t3) : r2[l7[0]] = [t3];
          }
          if (c4[u5] || (c4[u5] = { "@language": {}, "@type": {}, "@any": {} }), c4 = c4[u5], o4(e9, c4["@any"], "@none"), i5.reverse)
            o4(e9, c4["@type"], "@reverse");
          else if ("@none" === i5["@type"])
            o4(e9, c4["@any"], "@none"), o4(e9, c4["@language"], "@none"), o4(e9, c4["@type"], "@none");
          else if ("@type" in i5)
            o4(e9, c4["@type"], i5["@type"]);
          else if ("@language" in i5 && "@direction" in i5) {
            const t3 = i5["@language"], r3 = i5["@direction"];
            o4(e9, c4["@language"], t3 && r3 ? `${t3}_${r3}`.toLowerCase() : t3 ? t3.toLowerCase() : r3 ? `_${r3}` : "@null");
          } else
            "@language" in i5 ? o4(e9, c4["@language"], (i5["@language"] || "@null").toLowerCase()) : "@direction" in i5 ? i5["@direction"] ? o4(e9, c4["@language"], `_${i5["@direction"]}`) : o4(e9, c4["@language"], "@none") : s3 ? (o4(e9, c4["@language"], `_${s3}`), o4(e9, c4["@language"], "@none"), o4(e9, c4["@type"], "@none")) : (o4(e9, c4["@language"], a4), o4(e9, c4["@language"], "@none"), o4(e9, c4["@type"], "@none"));
        }
      }
      for (const e9 in r2)
        i4(r2, e9, 1);
      return t2;
    }, clone: function() {
      const e8 = {};
      e8.mappings = Iu.clone(this.mappings), e8.clone = this.clone, e8.inverse = null, e8.getInverse = this.getInverse, e8.protected = Iu.clone(this.protected), this.previousContext && (e8.previousContext = this.previousContext.clone());
      e8.revertToPreviousContext = this.revertToPreviousContext, "@base" in this && (e8["@base"] = this["@base"]);
      "@language" in this && (e8["@language"] = this["@language"]);
      "@vocab" in this && (e8["@vocab"] = this["@vocab"]);
      return e8;
    }, revertToPreviousContext: function() {
      if (!this.previousContext)
        return this;
      return this.previousContext.clone();
    }, protected: {} };
    return 1e4 === $u.size && $u.clear(), $u.set(t, n4), n4;
    function i4(e8, t2, r2) {
      const n5 = e8[t2], o5 = e8[t2] = {};
      let a4, s3;
      for (const e9 of n5)
        a4 = e9.iri, s3 = r2 >= a4.length ? "" : a4[r2], s3 in o5 ? o5[s3].push(e9) : o5[s3] = [e9];
      for (const e9 in o5)
        "" !== e9 && i4(o5, e9, r2 + 1);
    }
    function o4(e8, t2, r2) {
      t2.hasOwnProperty(r2) || (t2[r2] = e8);
    }
  }, Fu.getContextValue = (e7, t, r) => {
    if (null === t) {
      if ("@context" === r)
        return;
      return null;
    }
    if (e7.mappings.has(t)) {
      const n4 = e7.mappings.get(t);
      if (Du(r))
        return n4;
      if (n4.hasOwnProperty(r))
        return n4[r];
    }
    return "@language" === r && r in e7 || "@direction" === r && r in e7 ? e7[r] : "@context" !== r ? null : void 0;
  }, Fu.processingMode = (e7, t) => t.toString() >= "1.1" ? !e7.processingMode || e7.processingMode >= "json-ld-" + t.toString() : "json-ld-1.0" === e7.processingMode, Fu.isKeyword = (e7) => {
    if (!ju(e7) || "@" !== e7[0])
      return false;
    switch (e7) {
      case "@base":
      case "@container":
      case "@context":
      case "@default":
      case "@direction":
      case "@embed":
      case "@explicit":
      case "@graph":
      case "@id":
      case "@included":
      case "@index":
      case "@json":
      case "@language":
      case "@list":
      case "@nest":
      case "@none":
      case "@omitDefault":
      case "@prefix":
      case "@preserve":
      case "@protected":
      case "@requireAll":
      case "@reverse":
      case "@set":
      case "@type":
      case "@value":
      case "@version":
      case "@vocab":
        return true;
    }
    return false;
  };
  var Wu = tl;
  var { isArray: zu, isObject: Gu, isEmptyObject: Hu, isString: Ju, isUndefined: Vu } = Zs;
  var { isList: Qu, isValue: Zu, isGraph: Ku, isSubject: Xu } = el;
  var { expandIri: ec, getContextValue: tc, isKeyword: rc, process: nc, processingMode: ic } = Uu;
  var { isAbsolute: oc } = El;
  var { REGEX_BCP47: ac, REGEX_KEYWORD: sc, addValue: lc, asArray: uc, getValues: cc, validateTypeValue: dc } = hl;
  var { handleEvent: hc } = Eu;
  var fc = {};
  var pc = fc;
  function mc({ value: e7, count: t, options: r }) {
    if (0 === t || "@value" in e7 || "@list" in e7 || 1 === t && "@id" in e7) {
      if (r.eventHandler) {
        let n4, i4;
        0 === t ? (n4 = "empty object", i4 = "Dropping empty object.") : "@value" in e7 ? (n4 = "object with only @value", i4 = "Dropping object with only @value.") : "@list" in e7 ? (n4 = "object with only @list", i4 = "Dropping object with only @list.") : 1 === t && "@id" in e7 && (n4 = "object with only @id", i4 = "Dropping object with only @id."), hc({ event: { type: ["JsonLdEvent"], code: n4, level: "warning", message: i4, details: { value: e7 } }, options: r });
      }
      return null;
    }
    return e7;
  }
  async function yc({ activeCtx: e7, activeProperty: t, expandedActiveProperty: r, element: n4, expandedParent: i4, options: o4 = {}, insideList: a4, typeKey: s3, typeScopedContext: l6 }) {
    const u4 = Object.keys(n4).sort(), c3 = [];
    let d5;
    const h6 = n4[s3] && "@json" === ec(e7, zu(n4[s3]) ? n4[s3][0] : n4[s3], { vocab: true }, { ...o4, typeExpansion: true });
    for (const a5 of u4) {
      let s4, u5 = n4[a5];
      if ("@context" === a5)
        continue;
      const f5 = ec(e7, a5, { vocab: true }, o4);
      if (null === f5 || !oc(f5) && !rc(f5)) {
        o4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "invalid property", level: "warning", message: "Dropping property that did not expand into an absolute IRI or keyword.", details: { property: a5, expandedProperty: f5 } }, options: o4 });
        continue;
      }
      if (rc(f5)) {
        if ("@reverse" === r)
          throw new Wu("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.", "jsonld.SyntaxError", { code: "invalid reverse property map", value: u5 });
        if (f5 in i4 && "@included" !== f5 && "@type" !== f5)
          throw new Wu("Invalid JSON-LD syntax; colliding keywords detected.", "jsonld.SyntaxError", { code: "colliding keywords", keyword: f5 });
      }
      if ("@id" === f5) {
        if (!Ju(u5)) {
          if (!o4.isFrame)
            throw new Wu('Invalid JSON-LD syntax; "@id" value must a string.', "jsonld.SyntaxError", { code: "invalid @id value", value: u5 });
          if (Gu(u5)) {
            if (!Hu(u5))
              throw new Wu('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value: u5 });
          } else {
            if (!zu(u5))
              throw new Wu('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value: u5 });
            if (!u5.every((e8) => Ju(e8)))
              throw new Wu('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value: u5 });
          }
        }
        lc(i4, "@id", uc(u5).map((t2) => {
          if (Ju(t2)) {
            const r2 = ec(e7, t2, { base: true }, o4);
            return o4.eventHandler && (null === r2 ? hc(null === t2 ? { event: { type: ["JsonLdEvent"], code: "null @id value", level: "warning", message: "Null @id found.", details: { id: t2 } }, options: o4 } : { event: { type: ["JsonLdEvent"], code: "reserved @id value", level: "warning", message: "Reserved @id found.", details: { id: t2 } }, options: o4 }) : oc(r2) || hc({ event: { type: ["JsonLdEvent"], code: "relative @id reference", level: "warning", message: "Relative @id reference found.", details: { id: t2, expandedId: r2 } }, options: o4 })), r2;
          }
          return t2;
        }), { propertyIsArray: o4.isFrame });
        continue;
      }
      if ("@type" === f5) {
        Gu(u5) && (u5 = Object.fromEntries(Object.entries(u5).map(([e8, t2]) => [ec(l6, e8, { vocab: true }), uc(t2).map((e9) => ec(l6, e9, { base: true, vocab: true }, { ...o4, typeExpansion: true }))]))), dc(u5, o4.isFrame), lc(i4, "@type", uc(u5).map((e8) => {
          if (Ju(e8)) {
            const t2 = ec(l6, e8, { base: true, vocab: true }, { ...o4, typeExpansion: true });
            return "@json" === t2 || oc(t2) || o4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "relative @type reference", level: "warning", message: "Relative @type reference found.", details: { type: e8 } }, options: o4 }), t2;
          }
          return e8;
        }), { propertyIsArray: !!o4.isFrame });
        continue;
      }
      if ("@included" === f5 && ic(e7, 1.1)) {
        const r2 = uc(await fc.expand({ activeCtx: e7, activeProperty: t, element: u5, options: o4 }));
        if (!r2.every((e8) => Xu(e8)))
          throw new Wu("Invalid JSON-LD syntax; values of @included must expand to node objects.", "jsonld.SyntaxError", { code: "invalid @included value", value: u5 });
        lc(i4, "@included", r2, { propertyIsArray: true });
        continue;
      }
      if ("@graph" === f5 && !Gu(u5) && !zu(u5))
        throw new Wu('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid @graph value", value: u5 });
      if ("@value" === f5) {
        d5 = u5, h6 && ic(e7, 1.1) ? i4["@value"] = u5 : lc(i4, "@value", u5, { propertyIsArray: o4.isFrame });
        continue;
      }
      if ("@language" === f5) {
        if (null === u5)
          continue;
        if (!Ju(u5) && !o4.isFrame)
          throw new Wu('Invalid JSON-LD syntax; "@language" value must be a string.', "jsonld.SyntaxError", { code: "invalid language-tagged string", value: u5 });
        u5 = uc(u5).map((e8) => Ju(e8) ? e8.toLowerCase() : e8);
        for (const e8 of u5)
          Ju(e8) && !e8.match(ac) && o4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "invalid @language value", level: "warning", message: "@language value must be valid BCP47.", details: { language: e8 } }, options: o4 });
        lc(i4, "@language", u5, { propertyIsArray: o4.isFrame });
        continue;
      }
      if ("@direction" === f5) {
        if (!Ju(u5) && !o4.isFrame)
          throw new Wu('Invalid JSON-LD syntax; "@direction" value must be a string.', "jsonld.SyntaxError", { code: "invalid base direction", value: u5 });
        u5 = uc(u5);
        for (const e8 of u5)
          if (Ju(e8) && "ltr" !== e8 && "rtl" !== e8)
            throw new Wu('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", value: u5 });
        lc(i4, "@direction", u5, { propertyIsArray: o4.isFrame });
        continue;
      }
      if ("@index" === f5) {
        if (!Ju(u5))
          throw new Wu('Invalid JSON-LD syntax; "@index" value must be a string.', "jsonld.SyntaxError", { code: "invalid @index value", value: u5 });
        lc(i4, "@index", u5);
        continue;
      }
      if ("@reverse" === f5) {
        if (!Gu(u5))
          throw new Wu('Invalid JSON-LD syntax; "@reverse" value must be an object.', "jsonld.SyntaxError", { code: "invalid @reverse value", value: u5 });
        if (s4 = await fc.expand({ activeCtx: e7, activeProperty: "@reverse", element: u5, options: o4 }), "@reverse" in s4)
          for (const e8 in s4["@reverse"])
            lc(i4, e8, s4["@reverse"][e8], { propertyIsArray: true });
        let t2 = i4["@reverse"] || null;
        for (const e8 in s4) {
          if ("@reverse" === e8)
            continue;
          null === t2 && (t2 = i4["@reverse"] = {}), lc(t2, e8, [], { propertyIsArray: true });
          const r2 = s4[e8];
          for (let n5 = 0; n5 < r2.length; ++n5) {
            const i5 = r2[n5];
            if (Zu(i5) || Qu(i5))
              throw new Wu('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: s4 });
            lc(t2, e8, i5, { propertyIsArray: true });
          }
        }
        continue;
      }
      if ("@nest" === f5) {
        c3.push(a5);
        continue;
      }
      let p6 = e7;
      const m5 = tc(e7, a5, "@context");
      Vu(m5) || (p6 = await nc({ activeCtx: e7, localCtx: m5, propagate: true, overrideProtected: true, options: o4 }));
      const y5 = tc(e7, a5, "@container") || [];
      if (y5.includes("@language") && Gu(u5)) {
        s4 = vc(p6, u5, tc(p6, a5, "@direction"), o4);
      } else if (y5.includes("@index") && Gu(u5)) {
        const t2 = y5.includes("@graph"), r2 = tc(p6, a5, "@index") || "@index", n5 = "@index" !== r2 && ec(e7, r2, { vocab: true }, o4);
        s4 = await wc({ activeCtx: p6, options: o4, activeProperty: a5, value: u5, asGraph: t2, indexKey: r2, propertyIndex: n5 });
      } else if (y5.includes("@id") && Gu(u5)) {
        const e8 = y5.includes("@graph");
        s4 = await wc({ activeCtx: p6, options: o4, activeProperty: a5, value: u5, asGraph: e8, indexKey: "@id" });
      } else if (y5.includes("@type") && Gu(u5))
        s4 = await wc({ activeCtx: p6.revertToPreviousContext(), options: o4, activeProperty: a5, value: u5, asGraph: false, indexKey: "@type" });
      else {
        const n5 = "@list" === f5;
        if (n5 || "@set" === f5) {
          let e8 = t;
          n5 && "@graph" === r && (e8 = null), s4 = await fc.expand({ activeCtx: p6, activeProperty: e8, element: u5, options: o4, insideList: n5 });
        } else
          s4 = "@json" === tc(e7, a5, "@type") ? { "@type": "@json", "@value": u5 } : await fc.expand({ activeCtx: p6, activeProperty: a5, element: u5, options: o4, insideList: false });
      }
      if (null !== s4 || "@value" === f5) {
        if ("@list" !== f5 && !Qu(s4) && y5.includes("@list") && (s4 = { "@list": uc(s4) }), y5.includes("@graph") && !y5.some((e8) => "@id" === e8 || "@index" === e8)) {
          if (s4 = uc(s4), o4.isFrame || (s4 = s4.filter((e8) => null !== mc({ value: e8, count: Object.keys(e8).length, options: o4 }))), 0 === s4.length)
            continue;
          s4 = s4.map((e8) => ({ "@graph": uc(e8) }));
        }
        if (p6.mappings.has(a5) && p6.mappings.get(a5).reverse) {
          const e8 = i4["@reverse"] = i4["@reverse"] || {};
          s4 = uc(s4);
          for (let t2 = 0; t2 < s4.length; ++t2) {
            const r2 = s4[t2];
            if (Zu(r2) || Qu(r2))
              throw new Wu('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: s4 });
            lc(e8, f5, r2, { propertyIsArray: true });
          }
        } else
          lc(i4, f5, s4, { propertyIsArray: true });
      }
    }
    if ("@value" in i4) {
      if ("@json" === i4["@type"] && ic(e7, 1.1))
        ;
      else if ((Gu(d5) || zu(d5)) && !o4.isFrame)
        throw new Wu('Invalid JSON-LD syntax; "@value" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid value object value", value: d5 });
    }
    for (const u5 of c3) {
      const c4 = zu(n4[u5]) ? n4[u5] : [n4[u5]];
      for (const n5 of c4) {
        if (!Gu(n5) || Object.keys(n5).some((t2) => "@value" === ec(e7, t2, { vocab: true }, o4)))
          throw new Wu("Invalid JSON-LD syntax; nested value must be a node object.", "jsonld.SyntaxError", { code: "invalid @nest value", value: n5 });
        await yc({ activeCtx: e7, activeProperty: t, expandedActiveProperty: r, element: n5, expandedParent: i4, options: o4, insideList: a4, typeScopedContext: l6, typeKey: s3 });
      }
    }
  }
  function gc({ activeCtx: e7, activeProperty: t, value: r, options: n4 }) {
    if (null == r)
      return null;
    const i4 = ec(e7, t, { vocab: true }, n4);
    if ("@id" === i4)
      return ec(e7, r, { base: true }, n4);
    if ("@type" === i4)
      return ec(e7, r, { vocab: true, base: true }, { ...n4, typeExpansion: true });
    const o4 = tc(e7, t, "@type");
    if (("@id" === o4 || "@graph" === i4) && Ju(r)) {
      const i5 = ec(e7, r, { base: true }, n4);
      return null === i5 && r.match(sc) && n4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "reserved @id value", level: "warning", message: "Reserved @id found.", details: { id: t } }, options: n4 }), { "@id": i5 };
    }
    if ("@vocab" === o4 && Ju(r))
      return { "@id": ec(e7, r, { vocab: true, base: true }, n4) };
    if (rc(i4))
      return r;
    const a4 = {};
    if (o4 && !["@id", "@vocab", "@none"].includes(o4))
      a4["@type"] = o4;
    else if (Ju(r)) {
      const r2 = tc(e7, t, "@language");
      null !== r2 && (a4["@language"] = r2);
      const n5 = tc(e7, t, "@direction");
      null !== n5 && (a4["@direction"] = n5);
    }
    return ["boolean", "number", "string"].includes(typeof r) || (r = r.toString()), a4["@value"] = r, a4;
  }
  function vc(e7, t, r, n4) {
    const i4 = [], o4 = Object.keys(t).sort();
    for (const a4 of o4) {
      const o5 = ec(e7, a4, { vocab: true }, n4);
      let s3 = t[a4];
      zu(s3) || (s3 = [s3]);
      for (const e8 of s3) {
        if (null === e8)
          continue;
        if (!Ju(e8))
          throw new Wu("Invalid JSON-LD syntax; language map values must be strings.", "jsonld.SyntaxError", { code: "invalid language map value", languageMap: t });
        const s4 = { "@value": e8 };
        "@none" !== o5 && (a4.match(ac) || n4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "invalid @language value", level: "warning", message: "@language value must be valid BCP47.", details: { language: a4 } }, options: n4 }), s4["@language"] = a4.toLowerCase()), r && (s4["@direction"] = r), i4.push(s4);
      }
    }
    return i4;
  }
  async function wc({ activeCtx: e7, options: t, activeProperty: r, value: n4, asGraph: i4, indexKey: o4, propertyIndex: a4 }) {
    const s3 = [], l6 = Object.keys(n4).sort(), u4 = "@type" === o4;
    for (let c3 of l6) {
      if (u4) {
        const r2 = tc(e7, c3, "@context");
        Vu(r2) || (e7 = await nc({ activeCtx: e7, localCtx: r2, propagate: false, options: t }));
      }
      let l7, d5 = n4[c3];
      zu(d5) || (d5 = [d5]), d5 = await fc.expand({ activeCtx: e7, activeProperty: r, element: d5, options: t, insideList: false, insideIndex: true }), l7 = a4 ? "@none" === c3 ? "@none" : gc({ activeCtx: e7, activeProperty: o4, value: c3, options: t }) : ec(e7, c3, { vocab: true }, t), "@id" === o4 ? c3 = ec(e7, c3, { base: true }, t) : u4 && (c3 = l7);
      for (let e8 of d5) {
        if (i4 && !Ku(e8) && (e8 = { "@graph": [e8] }), "@type" === o4)
          "@none" === l7 || (e8["@type"] ? e8["@type"] = [c3].concat(e8["@type"]) : e8["@type"] = [c3]);
        else {
          if (Zu(e8) && !["@language", "@type", "@index"].includes(o4))
            throw new Wu(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${o4}".`, "jsonld.SyntaxError", { code: "invalid value object", value: e8 });
          a4 ? "@none" !== l7 && lc(e8, a4, l7, { propertyIsArray: true, prependValue: true }) : "@none" === l7 || o4 in e8 || (e8[o4] = c3);
        }
        s3.push(e8);
      }
    }
    return s3;
  }
  fc.expand = async ({ activeCtx: e7, activeProperty: t = null, element: r, options: n4 = {}, insideList: i4 = false, insideIndex: o4 = false, typeScopedContext: a4 = null }) => {
    if (null == r)
      return null;
    if ("@default" === t && (n4 = Object.assign({}, n4, { isFrame: false })), !zu(r) && !Gu(r))
      return i4 || null !== t && "@graph" !== ec(e7, t, { vocab: true }, n4) ? gc({ activeCtx: e7, activeProperty: t, value: r, options: n4 }) : (n4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "free-floating scalar", level: "warning", message: "Dropping free-floating scalar not in a list.", details: { value: r } }, options: n4 }), null);
    if (zu(r)) {
      let s4 = [];
      const l7 = tc(e7, t, "@container") || [];
      i4 = i4 || l7.includes("@list");
      for (let l8 = 0; l8 < r.length; ++l8) {
        let u5 = await fc.expand({ activeCtx: e7, activeProperty: t, element: r[l8], options: n4, insideIndex: o4, typeScopedContext: a4 });
        i4 && zu(u5) && (u5 = { "@list": u5 }), null !== u5 && (zu(u5) ? s4 = s4.concat(u5) : s4.push(u5));
      }
      return s4;
    }
    const s3 = ec(e7, t, { vocab: true }, n4), l6 = tc(e7, t, "@context");
    a4 = a4 || (e7.previousContext ? e7 : null);
    let u4 = Object.keys(r).sort(), c3 = !o4;
    if (c3 && a4 && u4.length <= 2 && !u4.includes("@context"))
      for (const t2 of u4) {
        const r2 = ec(a4, t2, { vocab: true }, n4);
        if ("@value" === r2) {
          c3 = false, e7 = a4;
          break;
        }
        if ("@id" === r2 && 1 === u4.length) {
          c3 = false;
          break;
        }
      }
    c3 && (e7 = e7.revertToPreviousContext()), Vu(l6) || (e7 = await nc({ activeCtx: e7, localCtx: l6, propagate: true, overrideProtected: true, options: n4 })), "@context" in r && (e7 = await nc({ activeCtx: e7, localCtx: r["@context"], options: n4 })), a4 = e7;
    let d5 = null;
    for (const t2 of u4) {
      if ("@type" === ec(e7, t2, { vocab: true }, n4)) {
        d5 = d5 || t2;
        const i5 = r[t2], o5 = Array.isArray(i5) ? i5.length > 1 ? i5.slice().sort() : i5 : [i5];
        for (const t3 of o5) {
          const r2 = tc(a4, t3, "@context");
          Vu(r2) || (e7 = await nc({ activeCtx: e7, localCtx: r2, options: n4, propagate: false }));
        }
      }
    }
    let h6 = {};
    await yc({ activeCtx: e7, activeProperty: t, expandedActiveProperty: s3, element: r, expandedParent: h6, options: n4, insideList: i4, typeKey: d5, typeScopedContext: a4 }), u4 = Object.keys(h6);
    let f5 = u4.length;
    if ("@value" in h6) {
      if ("@type" in h6 && ("@language" in h6 || "@direction" in h6))
        throw new Wu('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: h6 });
      let t2 = f5 - 1;
      if ("@type" in h6 && (t2 -= 1), "@index" in h6 && (t2 -= 1), "@language" in h6 && (t2 -= 1), "@direction" in h6 && (t2 -= 1), 0 !== t2)
        throw new Wu('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: h6 });
      const r2 = null === h6["@value"] ? [] : uc(h6["@value"]), i5 = cc(h6, "@type");
      if (ic(e7, 1.1) && i5.includes("@json") && 1 === i5.length)
        ;
      else if (0 === r2.length)
        n4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "null @value value", level: "warning", message: "Dropping null @value value.", details: { value: h6 } }, options: n4 }), h6 = null;
      else {
        if (!r2.every((e8) => Ju(e8) || Hu(e8)) && "@language" in h6)
          throw new Wu("Invalid JSON-LD syntax; only strings may be language-tagged.", "jsonld.SyntaxError", { code: "invalid language-tagged value", element: h6 });
        if (!i5.every((e8) => oc(e8) && !(Ju(e8) && 0 === e8.indexOf("_:")) || Hu(e8)))
          throw new Wu('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".', "jsonld.SyntaxError", { code: "invalid typed value", element: h6 });
      }
    } else if ("@type" in h6 && !zu(h6["@type"]))
      h6["@type"] = [h6["@type"]];
    else if ("@set" in h6 || "@list" in h6) {
      if (f5 > 1 && (2 !== f5 || !("@index" in h6)))
        throw new Wu('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".', "jsonld.SyntaxError", { code: "invalid set or list object", element: h6 });
      "@set" in h6 && (h6 = h6["@set"], u4 = Object.keys(h6), f5 = u4.length);
    } else
      1 === f5 && "@language" in h6 && (n4.eventHandler && hc({ event: { type: ["JsonLdEvent"], code: "object with only @language", level: "warning", message: "Dropping object with only @language.", details: { value: h6 } }, options: n4 }), h6 = null);
    return !Gu(h6) || n4.keepFreeFloatingNodes || i4 || null !== t && "@graph" !== s3 && !(tc(e7, t, "@container") || []).includes("@graph") || (h6 = mc({ value: h6, count: f5, options: n4 })), h6;
  };
  var { isKeyword: bc } = Uu;
  var _c = el;
  var Ec = Zs;
  var Tc = hl;
  var xc = tl;
  var Ic = {};
  var Sc = Ic;
  Ic.createMergedNodeMap = (e7, t) => {
    const r = (t = t || {}).issuer || new Tc.IdentifierIssuer("_:b"), n4 = { "@default": {} };
    return Ic.createNodeMap(e7, n4, "@default", r), Ic.mergeNodeMaps(n4);
  }, Ic.createNodeMap = (e7, t, r, n4, i4, o4) => {
    if (Ec.isArray(e7)) {
      for (const i5 of e7)
        Ic.createNodeMap(i5, t, r, n4, void 0, o4);
      return;
    }
    if (!Ec.isObject(e7))
      return void (o4 && o4.push(e7));
    if (_c.isValue(e7)) {
      if ("@type" in e7) {
        let t2 = e7["@type"];
        0 === t2.indexOf("_:") && (e7["@type"] = t2 = n4.getId(t2));
      }
      return void (o4 && o4.push(e7));
    }
    if (o4 && _c.isList(e7)) {
      const a5 = [];
      return Ic.createNodeMap(e7["@list"], t, r, n4, i4, a5), void o4.push({ "@list": a5 });
    }
    if ("@type" in e7) {
      const t2 = e7["@type"];
      for (const e8 of t2)
        0 === e8.indexOf("_:") && n4.getId(e8);
    }
    Ec.isUndefined(i4) && (i4 = _c.isBlankNode(e7) ? n4.getId(e7["@id"]) : e7["@id"]), o4 && o4.push({ "@id": i4 });
    const a4 = t[r], s3 = a4[i4] = a4[i4] || {};
    s3["@id"] = i4;
    const l6 = Object.keys(e7).sort();
    for (let o5 of l6) {
      if ("@id" === o5)
        continue;
      if ("@reverse" === o5) {
        const o6 = { "@id": i4 }, s4 = e7["@reverse"];
        for (const e8 in s4) {
          const i5 = s4[e8];
          for (const s5 of i5) {
            let i6 = s5["@id"];
            _c.isBlankNode(s5) && (i6 = n4.getId(i6)), Ic.createNodeMap(s5, t, r, n4, i6), Tc.addValue(a4[i6], e8, o6, { propertyIsArray: true, allowDuplicate: false });
          }
        }
        continue;
      }
      if ("@graph" === o5) {
        i4 in t || (t[i4] = {}), Ic.createNodeMap(e7[o5], t, i4, n4);
        continue;
      }
      if ("@included" === o5) {
        Ic.createNodeMap(e7[o5], t, r, n4);
        continue;
      }
      if ("@type" !== o5 && bc(o5)) {
        if ("@index" === o5 && o5 in s3 && (e7[o5] !== s3[o5] || e7[o5]["@id"] !== s3[o5]["@id"]))
          throw new xc("Invalid JSON-LD syntax; conflicting @index property detected.", "jsonld.SyntaxError", { code: "conflicting indexes", subject: s3 });
        s3[o5] = e7[o5];
        continue;
      }
      const l7 = e7[o5];
      if (0 === o5.indexOf("_:") && (o5 = n4.getId(o5)), 0 !== l7.length)
        for (let e8 of l7)
          if ("@type" === o5 && (e8 = 0 === e8.indexOf("_:") ? n4.getId(e8) : e8), _c.isSubject(e8) || _c.isSubjectReference(e8)) {
            if ("@id" in e8 && !e8["@id"])
              continue;
            const i5 = _c.isBlankNode(e8) ? n4.getId(e8["@id"]) : e8["@id"];
            Tc.addValue(s3, o5, { "@id": i5 }, { propertyIsArray: true, allowDuplicate: false }), Ic.createNodeMap(e8, t, r, n4, i5);
          } else if (_c.isValue(e8))
            Tc.addValue(s3, o5, e8, { propertyIsArray: true, allowDuplicate: false });
          else if (_c.isList(e8)) {
            const a5 = [];
            Ic.createNodeMap(e8["@list"], t, r, n4, i4, a5), e8 = { "@list": a5 }, Tc.addValue(s3, o5, e8, { propertyIsArray: true, allowDuplicate: false });
          } else
            Ic.createNodeMap(e8, t, r, n4, i4), Tc.addValue(s3, o5, e8, { propertyIsArray: true, allowDuplicate: false });
      else
        Tc.addValue(s3, o5, [], { propertyIsArray: true });
    }
  }, Ic.mergeNodeMapGraphs = (e7) => {
    const t = {};
    for (const r of Object.keys(e7).sort())
      for (const n4 of Object.keys(e7[r]).sort()) {
        const i4 = e7[r][n4];
        n4 in t || (t[n4] = { "@id": n4 });
        const o4 = t[n4];
        for (const e8 of Object.keys(i4).sort())
          if (bc(e8) && "@type" !== e8)
            o4[e8] = Tc.clone(i4[e8]);
          else
            for (const t2 of i4[e8])
              Tc.addValue(o4, e8, Tc.clone(t2), { propertyIsArray: true, allowDuplicate: false });
      }
    return t;
  }, Ic.mergeNodeMaps = (e7) => {
    const t = e7["@default"], r = Object.keys(e7).sort();
    for (const n4 of r) {
      if ("@default" === n4)
        continue;
      const r2 = e7[n4];
      let i4 = t[n4];
      i4 ? "@graph" in i4 || (i4["@graph"] = []) : t[n4] = i4 = { "@id": n4, "@graph": [] };
      const o4 = i4["@graph"];
      for (const e8 of Object.keys(r2).sort()) {
        const t2 = r2[e8];
        _c.isSubjectReference(t2) || o4.push(t2);
      }
    }
    return t;
  };
  var { isSubjectReference: Rc } = el;
  var { createMergedNodeMap: kc } = Sc;
  var jc = {};
  var Dc = jc;
  jc.flatten = (e7) => {
    const t = kc(e7), r = [], n4 = Object.keys(t).sort();
    for (let e8 = 0; e8 < n4.length; ++e8) {
      const i4 = t[n4[e8]];
      Rc(i4) || r.push(i4);
    }
    return r;
  };
  var Nc = tl;
  var Oc = el;
  var Cc = Zs;
  var { REGEX_BCP47: Ac, addValue: Mc } = hl;
  var { handleEvent: Lc } = Eu;
  var { RDF_LIST: Pc, RDF_FIRST: Bc, RDF_REST: $c, RDF_NIL: Fc, RDF_TYPE: Uc, RDF_JSON_LITERAL: qc, XSD_BOOLEAN: Yc, XSD_DOUBLE: Wc, XSD_INTEGER: zc, XSD_STRING: Gc } = vl;
  var Hc = {};
  var Jc = Hc;
  function Vc(e7, t, r, n4) {
    if (e7.termType.endsWith("Node"))
      return { "@id": e7.value };
    const i4 = { "@value": e7.value };
    if (e7.language)
      e7.language.match(Ac) || n4.eventHandler && Lc({ event: { type: ["JsonLdEvent"], code: "invalid @language value", level: "warning", message: "@language value must be valid BCP47.", details: { language: e7.language } }, options: n4 }), i4["@language"] = e7.language;
    else {
      let o4 = e7.datatype.value;
      if (o4 || (o4 = Gc), o4 === qc) {
        o4 = "@json";
        try {
          i4["@value"] = JSON.parse(i4["@value"]);
        } catch (e8) {
          throw new Nc("JSON literal could not be parsed.", "jsonld.InvalidJsonLiteral", { code: "invalid JSON literal", value: i4["@value"], cause: e8 });
        }
      }
      if (t) {
        if (o4 === Yc)
          "true" === i4["@value"] ? i4["@value"] = true : "false" === i4["@value"] && (i4["@value"] = false);
        else if (Cc.isNumeric(i4["@value"]))
          if (o4 === zc) {
            const e8 = parseInt(i4["@value"], 10);
            e8.toFixed(0) === i4["@value"] && (i4["@value"] = e8);
          } else
            o4 === Wc && (i4["@value"] = parseFloat(i4["@value"]));
        [Yc, zc, Wc, Gc].includes(o4) || (i4["@type"] = o4);
      } else if ("i18n-datatype" === r && o4.startsWith("https://www.w3.org/ns/i18n#")) {
        const [, e8, t2] = o4.split(/[#_]/);
        e8.length > 0 && (i4["@language"] = e8, e8.match(Ac) || n4.eventHandler && Lc({ event: { type: ["JsonLdEvent"], code: "invalid @language value", level: "warning", message: "@language value must be valid BCP47.", details: { language: e8 } }, options: n4 })), i4["@direction"] = t2;
      } else
        o4 !== Gc && (i4["@type"] = o4);
    }
    return i4;
  }
  Hc.fromRDF = async (e7, t) => {
    const { useRdfType: r = false, useNativeTypes: n4 = false, rdfDirection: i4 = null } = t, o4 = {}, a4 = { "@default": o4 }, s3 = {};
    if (i4) {
      if ("compound-literal" === i4)
        throw new Nc("Unsupported rdfDirection value.", "jsonld.InvalidRdfDirection", { value: i4 });
      if ("i18n-datatype" !== i4)
        throw new Nc("Unknown rdfDirection value.", "jsonld.InvalidRdfDirection", { value: i4 });
    }
    for (const l7 of e7) {
      const e8 = "DefaultGraph" === l7.graph.termType ? "@default" : l7.graph.value;
      e8 in a4 || (a4[e8] = {}), "@default" === e8 || e8 in o4 || (o4[e8] = { "@id": e8 });
      const u5 = a4[e8], c3 = l7.subject.value, d5 = l7.predicate.value, h6 = l7.object;
      c3 in u5 || (u5[c3] = { "@id": c3 });
      const f5 = u5[c3], p6 = h6.termType.endsWith("Node");
      if (p6 && !(h6.value in u5) && (u5[h6.value] = { "@id": h6.value }), d5 === Uc && !r && p6) {
        Mc(f5, "@type", h6.value, { propertyIsArray: true });
        continue;
      }
      const m5 = Vc(h6, n4, i4, t);
      if (Mc(f5, d5, m5, { propertyIsArray: true }), p6)
        if (h6.value === Fc) {
          const e9 = u5[h6.value];
          "usages" in e9 || (e9.usages = []), e9.usages.push({ node: f5, property: d5, value: m5 });
        } else
          h6.value in s3 ? s3[h6.value] = false : s3[h6.value] = { node: f5, property: d5, value: m5 };
    }
    for (const e8 in a4) {
      const t2 = a4[e8];
      if (!(Fc in t2))
        continue;
      const r2 = t2[Fc];
      if (r2.usages) {
        for (let e9 of r2.usages) {
          let r3 = e9.node, n5 = e9.property, i5 = e9.value;
          const o5 = [], a5 = [];
          let l7 = Object.keys(r3).length;
          for (; n5 === $c && Cc.isObject(s3[r3["@id"]]) && Cc.isArray(r3[Bc]) && 1 === r3[Bc].length && Cc.isArray(r3[$c]) && 1 === r3[$c].length && (3 === l7 || 4 === l7 && Cc.isArray(r3["@type"]) && 1 === r3["@type"].length && r3["@type"][0] === Pc) && (o5.push(r3[Bc][0]), a5.push(r3["@id"]), e9 = s3[r3["@id"]], r3 = e9.node, n5 = e9.property, i5 = e9.value, l7 = Object.keys(r3).length, Oc.isBlankNode(r3)); )
            ;
          delete i5["@id"], i5["@list"] = o5.reverse();
          for (const e10 of a5)
            delete t2[e10];
        }
        delete r2.usages;
      }
    }
    const l6 = [], u4 = Object.keys(o4).sort();
    for (const e8 of u4) {
      const t2 = o4[e8];
      if (e8 in a4) {
        const r2 = t2["@graph"] = [], n5 = a4[e8], i5 = Object.keys(n5).sort();
        for (const e9 of i5) {
          const t3 = n5[e9];
          Oc.isSubjectReference(t3) || r2.push(t3);
        }
      }
      Oc.isSubjectReference(t2) || l6.push(t2);
    }
    return l6;
  };
  var { createNodeMap: Qc } = Sc;
  var { isKeyword: Zc } = Uu;
  var Kc = el;
  var Xc = function e5(t) {
    return null === t || "object" != typeof t || null != t.toJSON ? JSON.stringify(t) : Array.isArray(t) ? "[" + t.reduce((t2, r, n4) => t2 + (0 === n4 ? "" : ",") + e5(void 0 === r || "symbol" == typeof r ? null : r), "") + "]" : "{" + Object.keys(t).sort().reduce((r, n4, i4) => {
      if (void 0 === t[n4] || "symbol" == typeof t[n4])
        return r;
      return r + (0 === r.length ? "" : ",") + e5(n4) + ":" + e5(t[n4]);
    }, "") + "}";
  };
  var ed = tl;
  var td = Zs;
  var rd = hl;
  var { handleEvent: nd } = Eu;
  var { RDF_FIRST: id, RDF_REST: od, RDF_NIL: ad, RDF_TYPE: sd, RDF_JSON_LITERAL: ld, RDF_LANGSTRING: ud, XSD_BOOLEAN: cd, XSD_DOUBLE: dd, XSD_INTEGER: hd, XSD_STRING: fd } = vl;
  var { isAbsolute: pd } = El;
  var md = {};
  var yd = md;
  function gd(e7, t, r, n4, i4) {
    const o4 = Object.keys(t).sort();
    for (const a4 of o4) {
      const o5 = t[a4], s3 = Object.keys(o5).sort();
      for (let t2 of s3) {
        const s4 = o5[t2];
        if ("@type" === t2)
          t2 = sd;
        else if (Zc(t2))
          continue;
        for (const o6 of s4) {
          const s5 = { termType: a4.startsWith("_:") ? "BlankNode" : "NamedNode", value: a4 };
          if (!pd(a4)) {
            i4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "relative subject reference", level: "warning", message: "Relative subject reference found.", details: { subject: a4 } }, options: i4 });
            continue;
          }
          const l6 = { termType: t2.startsWith("_:") ? "BlankNode" : "NamedNode", value: t2 };
          if (!pd(t2)) {
            i4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "relative predicate reference", level: "warning", message: "Relative predicate reference found.", details: { predicate: t2 } }, options: i4 });
            continue;
          }
          if ("BlankNode" === l6.termType && !i4.produceGeneralizedRdf) {
            i4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "blank node predicate", level: "warning", message: "Dropping blank node predicate.", details: { property: n4.getOldIds().find((e8) => n4.getId(e8) === t2) } }, options: i4 });
            continue;
          }
          const u4 = vd(o6, n4, e7, r, i4.rdfDirection, i4);
          u4 && e7.push({ subject: s5, predicate: l6, object: u4, graph: r });
        }
      }
    }
  }
  function vd(e7, t, r, n4, i4, o4) {
    const a4 = {};
    if (Kc.isValue(e7)) {
      a4.termType = "Literal", a4.value = void 0, a4.datatype = { termType: "NamedNode" };
      let t2 = e7["@value"];
      const r2 = e7["@type"] || null;
      if ("@json" === r2)
        a4.value = Xc(t2), a4.datatype.value = ld;
      else if (td.isBoolean(t2))
        a4.value = t2.toString(), a4.datatype.value = r2 || cd;
      else if (td.isDouble(t2) || r2 === dd)
        td.isDouble(t2) || (t2 = parseFloat(t2)), a4.value = t2.toExponential(15).replace(/(\d)0*e\+?/, "$1E"), a4.datatype.value = r2 || dd;
      else if (td.isNumber(t2))
        a4.value = t2.toFixed(0), a4.datatype.value = r2 || hd;
      else if ("@direction" in e7 && "i18n-datatype" === i4) {
        const r3 = `https://www.w3.org/ns/i18n#${(e7["@language"] || "").toLowerCase()}_${e7["@direction"]}`;
        a4.datatype.value = r3, a4.value = t2;
      } else {
        if ("@direction" in e7 && "compound-literal" === i4)
          throw new ed("Unsupported rdfDirection value.", "jsonld.InvalidRdfDirection", { value: i4 });
        if ("@direction" in e7 && i4)
          throw new ed("Unknown rdfDirection value.", "jsonld.InvalidRdfDirection", { value: i4 });
        "@language" in e7 ? ("@direction" in e7 && !i4 && o4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "rdfDirection not set", level: "warning", message: "rdfDirection not set for @direction.", details: { object: a4.value } }, options: o4 }), a4.value = t2, a4.datatype.value = r2 || ud, a4.language = e7["@language"]) : ("@direction" in e7 && !i4 && o4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "rdfDirection not set", level: "warning", message: "rdfDirection not set for @direction.", details: { object: a4.value } }, options: o4 }), a4.value = t2, a4.datatype.value = r2 || fd);
      }
    } else if (Kc.isList(e7)) {
      const s3 = function(e8, t2, r2, n5, i5, o5) {
        const a5 = { termType: "NamedNode", value: id }, s4 = { termType: "NamedNode", value: od }, l6 = { termType: "NamedNode", value: ad }, u4 = e8.pop(), c3 = u4 ? { termType: "BlankNode", value: t2.getId() } : l6;
        let d5 = c3;
        for (const l7 of e8) {
          const e9 = vd(l7, t2, r2, n5, i5, o5), u5 = { termType: "BlankNode", value: t2.getId() };
          r2.push({ subject: d5, predicate: a5, object: e9, graph: n5 }), r2.push({ subject: d5, predicate: s4, object: u5, graph: n5 }), d5 = u5;
        }
        if (u4) {
          const e9 = vd(u4, t2, r2, n5, i5, o5);
          r2.push({ subject: d5, predicate: a5, object: e9, graph: n5 }), r2.push({ subject: d5, predicate: s4, object: l6, graph: n5 });
        }
        return c3;
      }(e7["@list"], t, r, n4, i4, o4);
      a4.termType = s3.termType, a4.value = s3.value;
    } else {
      const t2 = td.isObject(e7) ? e7["@id"] : e7;
      a4.termType = t2.startsWith("_:") ? "BlankNode" : "NamedNode", a4.value = t2;
    }
    return "NamedNode" !== a4.termType || pd(a4.value) ? a4 : (o4.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "relative object reference", level: "warning", message: "Relative object reference found.", details: { object: a4.value } }, options: o4 }), null);
  }
  md.toRDF = (e7, t) => {
    const r = new rd.IdentifierIssuer("_:b"), n4 = { "@default": {} };
    Qc(e7, n4, "@default", r);
    const i4 = [], o4 = Object.keys(n4).sort();
    for (const e8 of o4) {
      let o5;
      if ("@default" === e8)
        o5 = { termType: "DefaultGraph", value: "" };
      else {
        if (!pd(e8)) {
          t.eventHandler && nd({ event: { type: ["JsonLdEvent"], code: "relative graph reference", level: "warning", message: "Relative graph reference found.", details: { graph: e8 } }, options: t });
          continue;
        }
        o5 = e8.startsWith("_:") ? { termType: "BlankNode" } : { termType: "NamedNode" }, o5.value = e8;
      }
      gd(i4, n4[e8], o5, r, t);
    }
    return i4;
  };
  var { isKeyword: wd } = Uu;
  var bd = el;
  var _d = Zs;
  var Ed = hl;
  var Td = El;
  var xd = tl;
  var { createNodeMap: Id, mergeNodeMapGraphs: Sd } = Sc;
  var Rd = {};
  var kd = Rd;
  function jd(e7) {
    const t = {};
    for (const r in e7)
      void 0 !== e7[r] && (t["@" + r] = [e7[r]]);
    return [t];
  }
  function Dd(e7, t, r) {
    for (let n4 = r.length - 1; n4 >= 0; --n4) {
      const i4 = r[n4];
      if (i4.graph === t && i4.subject["@id"] === e7["@id"])
        return true;
    }
    return false;
  }
  function Nd(e7, t, r) {
    const n4 = "@" + r;
    let i4 = n4 in e7 ? e7[n4][0] : t[r];
    if ("embed" === r) {
      if (true === i4)
        i4 = "@once";
      else if (false === i4)
        i4 = "@never";
      else if ("@always" !== i4 && "@never" !== i4 && "@link" !== i4 && "@first" !== i4 && "@last" !== i4 && "@once" !== i4)
        throw new xd("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame: e7 });
    }
    return i4;
  }
  function Od(e7) {
    if (!_d.isArray(e7) || 1 !== e7.length || !_d.isObject(e7[0]))
      throw new xd("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.", "jsonld.SyntaxError", { frame: e7 });
    if ("@id" in e7[0]) {
      for (const t of Ed.asArray(e7[0]["@id"]))
        if (!_d.isObject(t) && !Td.isAbsolute(t) || _d.isString(t) && 0 === t.indexOf("_:"))
          throw new xd("Invalid JSON-LD syntax; invalid @id in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame: e7 });
    }
    if ("@type" in e7[0]) {
      for (const t of Ed.asArray(e7[0]["@type"]))
        if (!_d.isObject(t) && !Td.isAbsolute(t) && "@json" !== t || _d.isString(t) && 0 === t.indexOf("_:"))
          throw new xd("Invalid JSON-LD syntax; invalid @type in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame: e7 });
    }
  }
  function Cd(e7, t, r, n4) {
    let i4 = true, o4 = false;
    for (const a4 in r) {
      let s3 = false;
      const l6 = Ed.getValues(t, a4), u4 = 0 === Ed.getValues(r, a4).length;
      if ("@id" === a4) {
        if (_d.isEmptyObject(r["@id"][0] || {}) ? s3 = true : r["@id"].length >= 0 && (s3 = r["@id"].includes(l6[0])), !n4.requireAll)
          return s3;
      } else if ("@type" === a4) {
        if (i4 = false, u4) {
          if (l6.length > 0)
            return false;
          s3 = true;
        } else if (1 === r["@type"].length && _d.isEmptyObject(r["@type"][0]))
          s3 = l6.length > 0;
        else
          for (const e8 of r["@type"])
            s3 = !(!_d.isObject(e8) || !("@default" in e8)) || (s3 || l6.some((t2) => t2 === e8));
        if (!n4.requireAll)
          return s3;
      } else {
        if (wd(a4))
          continue;
        {
          const t2 = Ed.getValues(r, a4)[0];
          let o5 = false;
          if (t2 && (Od([t2]), o5 = "@default" in t2), i4 = false, 0 === l6.length && o5)
            continue;
          if (l6.length > 0 && u4)
            return false;
          if (void 0 === t2) {
            if (l6.length > 0)
              return false;
            s3 = true;
          } else if (bd.isList(t2)) {
            const r2 = t2["@list"][0];
            if (bd.isList(l6[0])) {
              const t3 = l6[0]["@list"];
              bd.isValue(r2) ? s3 = t3.some((e8) => Bd(r2, e8)) : (bd.isSubject(r2) || bd.isSubjectReference(r2)) && (s3 = t3.some((t4) => Pd(e7, r2, t4, n4)));
            }
          } else
            s3 = bd.isValue(t2) ? l6.some((e8) => Bd(t2, e8)) : bd.isSubjectReference(t2) ? l6.some((r2) => Pd(e7, t2, r2, n4)) : !!_d.isObject(t2) && l6.length > 0;
        }
      }
      if (!s3 && n4.requireAll)
        return false;
      o4 = o4 || s3;
    }
    return i4 || o4;
  }
  function Ad(e7, t) {
    const r = e7.uniqueEmbeds[e7.graph], n4 = r[t], i4 = n4.parent, o4 = n4.property, a4 = { "@id": t };
    if (_d.isArray(i4)) {
      for (let e8 = 0; e8 < i4.length; ++e8)
        if (Ed.compareValues(i4[e8], a4)) {
          i4[e8] = a4;
          break;
        }
    } else {
      const e8 = _d.isArray(i4[o4]);
      Ed.removeValue(i4, o4, a4, { propertyIsArray: e8 }), Ed.addValue(i4, o4, a4, { propertyIsArray: e8 });
    }
    const s3 = (e8) => {
      const t2 = Object.keys(r);
      for (const n5 of t2)
        n5 in r && _d.isObject(r[n5].parent) && r[n5].parent["@id"] === e8 && (delete r[n5], s3(n5));
    };
    s3(t);
  }
  function Md(e7, t) {
    if (_d.isArray(e7))
      return e7.map((e8) => Md(e8, t));
    if (_d.isObject(e7)) {
      if ("@preserve" in e7)
        return e7["@preserve"][0];
      if (bd.isValue(e7))
        return e7;
      if (bd.isList(e7))
        return e7["@list"] = Md(e7["@list"], t), e7;
      if ("@id" in e7) {
        const r = e7["@id"];
        if (t.link.hasOwnProperty(r)) {
          const n4 = t.link[r].indexOf(e7);
          if (-1 !== n4)
            return t.link[r][n4];
          t.link[r].push(e7);
        } else
          t.link[r] = [e7];
      }
      for (const r in e7)
        "@id" === r && t.bnodesToClear.includes(e7[r]) ? delete e7["@id"] : e7[r] = Md(e7[r], t);
    }
    return e7;
  }
  function Ld(e7, t, r) {
    _d.isObject(e7) ? Ed.addValue(e7, t, r, { propertyIsArray: true }) : e7.push(r);
  }
  function Pd(e7, t, r, n4) {
    if (!("@id" in r))
      return false;
    const i4 = e7.subjects[r["@id"]];
    return i4 && Cd(e7, i4, t, n4);
  }
  function Bd(e7, t) {
    const r = t["@value"], n4 = t["@type"], i4 = t["@language"], o4 = e7["@value"] ? _d.isArray(e7["@value"]) ? e7["@value"] : [e7["@value"]] : [], a4 = e7["@type"] ? _d.isArray(e7["@type"]) ? e7["@type"] : [e7["@type"]] : [], s3 = e7["@language"] ? _d.isArray(e7["@language"]) ? e7["@language"] : [e7["@language"]] : [];
    return 0 === o4.length && 0 === a4.length && 0 === s3.length || !(!o4.includes(r) && !_d.isEmptyObject(o4[0])) && (!!(!n4 && 0 === a4.length || a4.includes(n4) || n4 && _d.isEmptyObject(a4[0])) && !!(!i4 && 0 === s3.length || s3.includes(i4) || i4 && _d.isEmptyObject(s3[0])));
  }
  Rd.frameMergedOrDefault = (e7, t, r) => {
    const n4 = { options: r, embedded: false, graph: "@default", graphMap: { "@default": {} }, subjectStack: [], link: {}, bnodeMap: {} }, i4 = new Ed.IdentifierIssuer("_:b");
    Id(e7, n4.graphMap, "@default", i4), r.merged && (n4.graphMap["@merged"] = Sd(n4.graphMap), n4.graph = "@merged"), n4.subjects = n4.graphMap[n4.graph];
    const o4 = [];
    return Rd.frame(n4, Object.keys(n4.subjects).sort(), t, o4), r.pruneBlankNodeIdentifiers && (r.bnodesToClear = Object.keys(n4.bnodeMap).filter((e8) => 1 === n4.bnodeMap[e8].length)), r.link = {}, Md(o4, r);
  }, Rd.frame = (e7, t, r, n4, i4 = null) => {
    Od(r), r = r[0];
    const o4 = e7.options, a4 = { embed: Nd(r, o4, "embed"), explicit: Nd(r, o4, "explicit"), requireAll: Nd(r, o4, "requireAll") };
    e7.link.hasOwnProperty(e7.graph) || (e7.link[e7.graph] = {});
    const s3 = e7.link[e7.graph], l6 = function(e8, t2, r2, n5) {
      const i5 = {};
      for (const o5 of t2) {
        const t3 = e8.graphMap[e8.graph][o5];
        Cd(e8, t3, r2, n5) && (i5[o5] = t3);
      }
      return i5;
    }(e7, t, r, a4), u4 = Object.keys(l6).sort();
    for (const c3 of u4) {
      const u5 = l6[c3];
      if (null === i4 ? e7.uniqueEmbeds = { [e7.graph]: {} } : e7.uniqueEmbeds[e7.graph] = e7.uniqueEmbeds[e7.graph] || {}, "@link" === a4.embed && c3 in s3) {
        Ld(n4, i4, s3[c3]);
        continue;
      }
      const d5 = { "@id": c3 };
      if (0 === c3.indexOf("_:") && Ed.addValue(e7.bnodeMap, c3, d5, { propertyIsArray: true }), s3[c3] = d5, ("@first" === a4.embed || "@last" === a4.embed) && e7.is11)
        throw new xd("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame: r });
      if (e7.embedded || !e7.uniqueEmbeds[e7.graph].hasOwnProperty(c3))
        if (!e7.embedded || "@never" !== a4.embed && !Dd(u5, e7.graph, e7.subjectStack))
          if (!e7.embedded || "@first" != a4.embed && "@once" != a4.embed || !e7.uniqueEmbeds[e7.graph].hasOwnProperty(c3)) {
            if ("@last" === a4.embed && c3 in e7.uniqueEmbeds[e7.graph] && Ad(e7, c3), e7.uniqueEmbeds[e7.graph][c3] = { parent: n4, property: i4 }, e7.subjectStack.push({ subject: u5, graph: e7.graph }), c3 in e7.graphMap) {
              let t2 = false, n5 = null;
              "@graph" in r ? (n5 = r["@graph"][0], t2 = !("@merged" === c3 || "@default" === c3), _d.isObject(n5) || (n5 = {})) : (t2 = "@merged" !== e7.graph, n5 = {}), t2 && Rd.frame({ ...e7, graph: c3, embedded: false }, Object.keys(e7.graphMap[c3]).sort(), [n5], d5, "@graph");
            }
            "@included" in r && Rd.frame({ ...e7, embedded: false }, t, r["@included"], d5, "@included");
            for (const t2 of Object.keys(u5).sort())
              if (wd(t2)) {
                if (d5[t2] = Ed.clone(u5[t2]), "@type" === t2)
                  for (const t3 of u5["@type"])
                    0 === t3.indexOf("_:") && Ed.addValue(e7.bnodeMap, t3, d5, { propertyIsArray: true });
              } else if (!a4.explicit || t2 in r)
                for (const n5 of u5[t2]) {
                  const i5 = t2 in r ? r[t2] : jd(a4);
                  if (bd.isList(n5)) {
                    const i6 = r[t2] && r[t2][0] && r[t2][0]["@list"] ? r[t2][0]["@list"] : jd(a4), o5 = { "@list": [] };
                    Ld(d5, t2, o5);
                    const s4 = n5["@list"];
                    for (const t3 of s4)
                      bd.isSubjectReference(t3) ? Rd.frame({ ...e7, embedded: true }, [t3["@id"]], i6, o5, "@list") : Ld(o5, "@list", Ed.clone(t3));
                  } else
                    bd.isSubjectReference(n5) ? Rd.frame({ ...e7, embedded: true }, [n5["@id"]], i5, d5, t2) : Bd(i5[0], n5) && Ld(d5, t2, Ed.clone(n5));
                }
            for (const e8 of Object.keys(r).sort()) {
              if ("@type" === e8) {
                if (!_d.isObject(r[e8][0]) || !("@default" in r[e8][0]))
                  continue;
              } else if (wd(e8))
                continue;
              const t2 = r[e8][0] || {};
              if (!Nd(t2, o4, "omitDefault") && !(e8 in d5)) {
                let r2 = "@null";
                "@default" in t2 && (r2 = Ed.clone(t2["@default"])), _d.isArray(r2) || (r2 = [r2]), d5[e8] = [{ "@preserve": r2 }];
              }
            }
            for (const t2 of Object.keys(r["@reverse"] || {}).sort()) {
              const n5 = r["@reverse"][t2];
              for (const r2 of Object.keys(e7.subjects)) {
                Ed.getValues(e7.subjects[r2], t2).some((e8) => e8["@id"] === c3) && (d5["@reverse"] = d5["@reverse"] || {}, Ed.addValue(d5["@reverse"], t2, [], { propertyIsArray: true }), Rd.frame({ ...e7, embedded: true }, [r2], n5, d5["@reverse"][t2], i4));
              }
            }
            Ld(n4, i4, d5), e7.subjectStack.pop();
          } else
            Ld(n4, i4, d5);
        else
          Ld(n4, i4, d5);
    }
  }, Rd.cleanupNull = (e7, t) => {
    if (_d.isArray(e7)) {
      const r = e7.map((e8) => Rd.cleanupNull(e8, t));
      return r.filter((e8) => e8);
    }
    if ("@null" === e7)
      return null;
    if (_d.isObject(e7)) {
      if ("@id" in e7) {
        const r = e7["@id"];
        if (t.link.hasOwnProperty(r)) {
          const n4 = t.link[r].indexOf(e7);
          if (-1 !== n4)
            return t.link[r][n4];
          t.link[r].push(e7);
        } else
          t.link[r] = [e7];
      }
      for (const r in e7)
        e7[r] = Rd.cleanupNull(e7[r], t);
    }
    return e7;
  };
  var $d = tl;
  var { isArray: Fd, isObject: Ud, isString: qd, isUndefined: Yd } = Zs;
  var { isList: Wd, isValue: zd, isGraph: Gd, isSimpleGraph: Hd, isSubjectReference: Jd } = el;
  var { expandIri: Vd, getContextValue: Qd, isKeyword: Zd, process: Kd, processingMode: Xd } = Uu;
  var { removeBase: eh, prependBase: th } = El;
  var { REGEX_KEYWORD: rh, addValue: nh, asArray: ih, compareShortestLeast: oh } = hl;
  var ah = {};
  var sh;
  var lh;
  var uh = ah;
  function ch(e7, t, r) {
    if ("@nest" !== Vd(e7, t, { vocab: true }, r))
      throw new $d("JSON-LD compact error; nested property must have an @nest value resolving to @nest.", "jsonld.SyntaxError", { code: "invalid @nest value" });
  }
  ah.compact = async ({ activeCtx: e7, activeProperty: t = null, element: r, options: n4 = {} }) => {
    if (Fd(r)) {
      let i5 = [];
      for (let o4 = 0; o4 < r.length; ++o4) {
        const a4 = await ah.compact({ activeCtx: e7, activeProperty: t, element: r[o4], options: n4 });
        null !== a4 && i5.push(a4);
      }
      if (n4.compactArrays && 1 === i5.length) {
        0 === (Qd(e7, t, "@container") || []).length && (i5 = i5[0]);
      }
      return i5;
    }
    const i4 = Qd(e7, t, "@context");
    if (Yd(i4) || (e7 = await Kd({ activeCtx: e7, localCtx: i4, propagate: true, overrideProtected: true, options: n4 })), Ud(r)) {
      if (n4.link && "@id" in r && n4.link.hasOwnProperty(r["@id"])) {
        const e8 = n4.link[r["@id"]];
        for (let t2 = 0; t2 < e8.length; ++t2)
          if (e8[t2].expanded === r)
            return e8[t2].compacted;
      }
      if (zd(r) || Jd(r)) {
        const i6 = ah.compactValue({ activeCtx: e7, activeProperty: t, value: r, options: n4 });
        return n4.link && Jd(r) && (n4.link.hasOwnProperty(r["@id"]) || (n4.link[r["@id"]] = []), n4.link[r["@id"]].push({ expanded: r, compacted: i6 })), i6;
      }
      if (Wd(r)) {
        if ((Qd(e7, t, "@container") || []).includes("@list"))
          return ah.compact({ activeCtx: e7, activeProperty: t, element: r["@list"], options: n4 });
      }
      const i5 = "@reverse" === t, o4 = {}, a4 = e7;
      zd(r) || Jd(r) || (e7 = e7.revertToPreviousContext());
      const s3 = Qd(a4, t, "@context");
      Yd(s3) || (e7 = await Kd({ activeCtx: e7, localCtx: s3, propagate: true, overrideProtected: true, options: n4 })), n4.link && "@id" in r && (n4.link.hasOwnProperty(r["@id"]) || (n4.link[r["@id"]] = []), n4.link[r["@id"]].push({ expanded: r, compacted: o4 }));
      let l6 = r["@type"] || [];
      l6.length > 1 && (l6 = Array.from(l6).sort());
      const u4 = e7;
      for (const t2 of l6) {
        const r2 = ah.compactIri({ activeCtx: u4, iri: t2, relativeTo: { vocab: true } }), i6 = Qd(a4, r2, "@context");
        Yd(i6) || (e7 = await Kd({ activeCtx: e7, localCtx: i6, options: n4, propagate: false }));
      }
      const c3 = Object.keys(r).sort();
      for (const s4 of c3) {
        const l7 = r[s4];
        if ("@id" !== s4)
          if ("@type" !== s4)
            if ("@reverse" !== s4)
              if ("@preserve" !== s4)
                if ("@index" !== s4)
                  if ("@graph" !== s4 && "@list" !== s4 && "@included" !== s4 && Zd(s4)) {
                    const t2 = ah.compactIri({ activeCtx: e7, iri: s4, relativeTo: { vocab: true } });
                    nh(o4, t2, l7);
                  } else {
                    if (!Fd(l7))
                      throw new $d("JSON-LD expansion error; expanded value must be an array.", "jsonld.SyntaxError");
                    if (0 === l7.length) {
                      const t2 = ah.compactIri({ activeCtx: e7, iri: s4, value: l7, relativeTo: { vocab: true }, reverse: i5 }), r2 = e7.mappings.has(t2) ? e7.mappings.get(t2)["@nest"] : null;
                      let a5 = o4;
                      r2 && (ch(e7, r2, n4), Ud(o4[r2]) || (o4[r2] = {}), a5 = o4[r2]), nh(a5, t2, l7, { propertyIsArray: true });
                    }
                    for (const t2 of l7) {
                      const r2 = ah.compactIri({ activeCtx: e7, iri: s4, value: t2, relativeTo: { vocab: true }, reverse: i5 }), a5 = e7.mappings.has(r2) ? e7.mappings.get(r2)["@nest"] : null;
                      let l8 = o4;
                      a5 && (ch(e7, a5, n4), Ud(o4[a5]) || (o4[a5] = {}), l8 = o4[a5]);
                      const u5 = Qd(e7, r2, "@container") || [], c4 = Gd(t2), d5 = Wd(t2);
                      let h6;
                      d5 ? h6 = t2["@list"] : c4 && (h6 = t2["@graph"]);
                      let f5 = await ah.compact({ activeCtx: e7, activeProperty: r2, element: d5 || c4 ? h6 : t2, options: n4 });
                      if (d5) {
                        if (Fd(f5) || (f5 = [f5]), u5.includes("@list")) {
                          nh(l8, r2, f5, { valueIsArray: true, allowDuplicate: true });
                          continue;
                        }
                        f5 = { [ah.compactIri({ activeCtx: e7, iri: "@list", relativeTo: { vocab: true } })]: f5 }, "@index" in t2 && (f5[ah.compactIri({ activeCtx: e7, iri: "@index", relativeTo: { vocab: true } })] = t2["@index"]);
                      }
                      if (c4)
                        if (u5.includes("@graph") && (u5.includes("@id") || u5.includes("@index") && Hd(t2))) {
                          let i6;
                          l8.hasOwnProperty(r2) ? i6 = l8[r2] : l8[r2] = i6 = {};
                          const o5 = (u5.includes("@id") ? t2["@id"] : t2["@index"]) || ah.compactIri({ activeCtx: e7, iri: "@none", relativeTo: { vocab: true } });
                          nh(i6, o5, f5, { propertyIsArray: !n4.compactArrays || u5.includes("@set") });
                        } else
                          u5.includes("@graph") && Hd(t2) ? (Fd(f5) && f5.length > 1 && (f5 = { "@included": f5 }), nh(l8, r2, f5, { propertyIsArray: !n4.compactArrays || u5.includes("@set") })) : (Fd(f5) && 1 === f5.length && n4.compactArrays && (f5 = f5[0]), f5 = { [ah.compactIri({ activeCtx: e7, iri: "@graph", relativeTo: { vocab: true } })]: f5 }, "@id" in t2 && (f5[ah.compactIri({ activeCtx: e7, iri: "@id", relativeTo: { vocab: true } })] = t2["@id"]), "@index" in t2 && (f5[ah.compactIri({ activeCtx: e7, iri: "@index", relativeTo: { vocab: true } })] = t2["@index"]), nh(l8, r2, f5, { propertyIsArray: !n4.compactArrays || u5.includes("@set") }));
                      else if (u5.includes("@language") || u5.includes("@index") || u5.includes("@id") || u5.includes("@type")) {
                        let i6, o5;
                        if (l8.hasOwnProperty(r2) ? i6 = l8[r2] : l8[r2] = i6 = {}, u5.includes("@language"))
                          zd(f5) && (f5 = f5["@value"]), o5 = t2["@language"];
                        else if (u5.includes("@index")) {
                          const n5 = Qd(e7, r2, "@index") || "@index", i7 = ah.compactIri({ activeCtx: e7, iri: n5, relativeTo: { vocab: true } });
                          if ("@index" === n5)
                            o5 = t2["@index"], delete f5[i7];
                          else {
                            let e8;
                            if ([o5, ...e8] = ih(f5[n5] || []), qd(o5))
                              switch (e8.length) {
                                case 0:
                                  delete f5[n5];
                                  break;
                                case 1:
                                  f5[n5] = e8[0];
                                  break;
                                default:
                                  f5[n5] = e8;
                              }
                            else
                              o5 = null;
                          }
                        } else if (u5.includes("@id")) {
                          const t3 = ah.compactIri({ activeCtx: e7, iri: "@id", relativeTo: { vocab: true } });
                          o5 = f5[t3], delete f5[t3];
                        } else if (u5.includes("@type")) {
                          const i7 = ah.compactIri({ activeCtx: e7, iri: "@type", relativeTo: { vocab: true } });
                          let a6;
                          switch ([o5, ...a6] = ih(f5[i7] || []), a6.length) {
                            case 0:
                              delete f5[i7];
                              break;
                            case 1:
                              f5[i7] = a6[0];
                              break;
                            default:
                              f5[i7] = a6;
                          }
                          1 === Object.keys(f5).length && "@id" in t2 && (f5 = await ah.compact({ activeCtx: e7, activeProperty: r2, element: { "@id": t2["@id"] }, options: n4 }));
                        }
                        o5 || (o5 = ah.compactIri({ activeCtx: e7, iri: "@none", relativeTo: { vocab: true } })), nh(i6, o5, f5, { propertyIsArray: u5.includes("@set") });
                      } else {
                        const e8 = !n4.compactArrays || u5.includes("@set") || u5.includes("@list") || Fd(f5) && 0 === f5.length || "@list" === s4 || "@graph" === s4;
                        nh(l8, r2, f5, { propertyIsArray: e8 });
                      }
                    }
                  }
                else {
                  if ((Qd(e7, t, "@container") || []).includes("@index"))
                    continue;
                  const r2 = ah.compactIri({ activeCtx: e7, iri: s4, relativeTo: { vocab: true } });
                  nh(o4, r2, l7);
                }
              else {
                const r2 = await ah.compact({ activeCtx: e7, activeProperty: t, element: l7, options: n4 });
                Fd(r2) && 0 === r2.length || nh(o4, s4, r2);
              }
            else {
              const t2 = await ah.compact({ activeCtx: e7, activeProperty: "@reverse", element: l7, options: n4 });
              for (const r2 in t2)
                if (e7.mappings.has(r2) && e7.mappings.get(r2).reverse) {
                  const i6 = t2[r2], a5 = (Qd(e7, r2, "@container") || []).includes("@set") || !n4.compactArrays;
                  nh(o4, r2, i6, { propertyIsArray: a5 }), delete t2[r2];
                }
              if (Object.keys(t2).length > 0) {
                const r2 = ah.compactIri({ activeCtx: e7, iri: s4, relativeTo: { vocab: true } });
                nh(o4, r2, t2);
              }
            }
          else {
            let t2 = ih(l7).map((e8) => ah.compactIri({ activeCtx: a4, iri: e8, relativeTo: { vocab: true } }));
            1 === t2.length && (t2 = t2[0]);
            const r2 = ah.compactIri({ activeCtx: e7, iri: "@type", relativeTo: { vocab: true } }), n5 = (Qd(e7, r2, "@container") || []).includes("@set") && Xd(e7, 1.1) || Fd(t2) && 0 === l7.length;
            nh(o4, r2, t2, { propertyIsArray: n5 });
          }
        else {
          let t2 = ih(l7).map((t3) => ah.compactIri({ activeCtx: e7, iri: t3, relativeTo: { vocab: false }, base: n4.base }));
          1 === t2.length && (t2 = t2[0]);
          o4[ah.compactIri({ activeCtx: e7, iri: "@id", relativeTo: { vocab: true } })] = t2;
        }
      }
      return o4;
    }
    return r;
  }, ah.compactIri = ({ activeCtx: e7, iri: t, value: r = null, relativeTo: n4 = { vocab: false }, reverse: i4 = false, base: o4 = null }) => {
    if (null === t)
      return t;
    e7.isPropertyTermScoped && e7.previousContext && (e7 = e7.previousContext);
    const a4 = e7.getInverse();
    if (Zd(t) && t in a4 && "@none" in a4[t] && "@type" in a4[t]["@none"] && "@none" in a4[t]["@none"]["@type"])
      return a4[t]["@none"]["@type"]["@none"];
    if (n4.vocab && t in a4) {
      const n5 = e7["@language"] || "@none", o5 = [];
      Ud(r) && "@index" in r && !("@graph" in r) && o5.push("@index", "@index@set"), Ud(r) && "@preserve" in r && (r = r["@preserve"][0]), Gd(r) ? ("@index" in r && o5.push("@graph@index", "@graph@index@set", "@index", "@index@set"), "@id" in r && o5.push("@graph@id", "@graph@id@set"), o5.push("@graph", "@graph@set", "@set"), "@index" in r || o5.push("@graph@index", "@graph@index@set", "@index", "@index@set"), "@id" in r || o5.push("@graph@id", "@graph@id@set")) : Ud(r) && !zd(r) && o5.push("@id", "@id@set", "@type", "@set@type");
      let a5 = "@language", s4 = "@null";
      if (i4)
        a5 = "@type", s4 = "@reverse", o5.push("@set");
      else if (Wd(r)) {
        "@index" in r || o5.push("@list");
        const e8 = r["@list"];
        if (0 === e8.length)
          a5 = "@any", s4 = "@none";
        else {
          let t2 = 0 === e8.length ? n5 : null, r2 = null;
          for (let n6 = 0; n6 < e8.length; ++n6) {
            const i5 = e8[n6];
            let o6 = "@none", a6 = "@none";
            if (zd(i5))
              if ("@direction" in i5) {
                o6 = `${(i5["@language"] || "").toLowerCase()}_${i5["@direction"]}`;
              } else
                "@language" in i5 ? o6 = i5["@language"].toLowerCase() : "@type" in i5 ? a6 = i5["@type"] : o6 = "@null";
            else
              a6 = "@id";
            if (null === t2 ? t2 = o6 : o6 !== t2 && zd(i5) && (t2 = "@none"), null === r2 ? r2 = a6 : a6 !== r2 && (r2 = "@none"), "@none" === t2 && "@none" === r2)
              break;
          }
          t2 = t2 || "@none", r2 = r2 || "@none", "@none" !== r2 ? (a5 = "@type", s4 = r2) : s4 = t2;
        }
      } else {
        if (zd(r))
          if ("@language" in r && !("@index" in r)) {
            o5.push("@language", "@language@set"), s4 = r["@language"];
            const e8 = r["@direction"];
            e8 && (s4 = `${s4}_${e8}`);
          } else
            "@direction" in r && !("@index" in r) ? s4 = `_${r["@direction"]}` : "@type" in r && (a5 = "@type", s4 = r["@type"]);
        else
          a5 = "@type", s4 = "@id";
        o5.push("@set");
      }
      o5.push("@none"), Ud(r) && !("@index" in r) && o5.push("@index", "@index@set"), zd(r) && 1 === Object.keys(r).length && o5.push("@language", "@language@set");
      const l7 = function(e8, t2, r2, n6, i5, o6) {
        null === o6 && (o6 = "@null");
        const a6 = [];
        if (("@id" === o6 || "@reverse" === o6) && Ud(r2) && "@id" in r2) {
          "@reverse" === o6 && a6.push("@reverse");
          const t3 = ah.compactIri({ activeCtx: e8, iri: r2["@id"], relativeTo: { vocab: true } });
          e8.mappings.has(t3) && e8.mappings.get(t3) && e8.mappings.get(t3)["@id"] === r2["@id"] ? a6.push.apply(a6, ["@vocab", "@id"]) : a6.push.apply(a6, ["@id", "@vocab"]);
        } else {
          a6.push(o6);
          const e9 = a6.find((e10) => e10.includes("_"));
          e9 && a6.push(e9.replace(/^[^_]+_/, "_"));
        }
        a6.push("@none");
        const s5 = e8.inverse[t2];
        for (const e9 of n6) {
          if (!(e9 in s5))
            continue;
          const t3 = s5[e9][i5];
          for (const e10 of a6)
            if (e10 in t3)
              return t3[e10];
        }
        return null;
      }(e7, t, r, o5, a5, s4);
      if (null !== l7)
        return l7;
    }
    if (n4.vocab && "@vocab" in e7) {
      const r2 = e7["@vocab"];
      if (0 === t.indexOf(r2) && t !== r2) {
        const n5 = t.substr(r2.length);
        if (!e7.mappings.has(n5))
          return n5;
      }
    }
    let s3 = null;
    const l6 = [];
    let u4 = e7.fastCurieMap;
    const c3 = t.length - 1;
    for (let e8 = 0; e8 < c3 && t[e8] in u4; ++e8)
      u4 = u4[t[e8]], "" in u4 && l6.push(u4[""][0]);
    for (let n5 = l6.length - 1; n5 >= 0; --n5) {
      const i5 = l6[n5], o5 = i5.terms;
      for (const n6 of o5) {
        const o6 = n6 + ":" + t.substr(i5.iri.length);
        e7.mappings.get(n6)._prefix && (!e7.mappings.has(o6) || null === r && e7.mappings.get(o6)["@id"] === t) && (null === s3 || oh(o6, s3) < 0) && (s3 = o6);
      }
    }
    if (null !== s3)
      return s3;
    for (const [r2, n5] of e7.mappings)
      if (n5 && n5._prefix && t.startsWith(r2 + ":"))
        throw new $d(`Absolute IRI "${t}" confused with prefix "${r2}".`, "jsonld.SyntaxError", { code: "IRI confused with prefix", context: e7 });
    if (!n4.vocab) {
      if ("@base" in e7) {
        if (e7["@base"]) {
          const r2 = eh(th(o4, e7["@base"]), t);
          return rh.test(r2) ? `./${r2}` : r2;
        }
        return t;
      }
      return eh(o4, t);
    }
    return t;
  }, ah.compactValue = ({ activeCtx: e7, activeProperty: t, value: r, options: n4 }) => {
    if (zd(r)) {
      const n5 = Qd(e7, t, "@type"), i5 = Qd(e7, t, "@language"), o5 = Qd(e7, t, "@direction"), a5 = Qd(e7, t, "@container") || [], s3 = "@index" in r && !a5.includes("@index");
      if (!s3 && "@none" !== n5) {
        if (r["@type"] === n5)
          return r["@value"];
        if ("@language" in r && r["@language"] === i5 && "@direction" in r && r["@direction"] === o5)
          return r["@value"];
        if ("@language" in r && r["@language"] === i5)
          return r["@value"];
        if ("@direction" in r && r["@direction"] === o5)
          return r["@value"];
      }
      const l6 = Object.keys(r).length, u4 = 1 === l6 || 2 === l6 && "@index" in r && !s3, c3 = "@language" in e7, d5 = qd(r["@value"]), h6 = e7.mappings.has(t) && null === e7.mappings.get(t)["@language"];
      if (u4 && "@none" !== n5 && (!c3 || !d5 || h6))
        return r["@value"];
      const f5 = {};
      return s3 && (f5[ah.compactIri({ activeCtx: e7, iri: "@index", relativeTo: { vocab: true } })] = r["@index"]), "@type" in r ? f5[ah.compactIri({ activeCtx: e7, iri: "@type", relativeTo: { vocab: true } })] = ah.compactIri({ activeCtx: e7, iri: r["@type"], relativeTo: { vocab: true } }) : "@language" in r && (f5[ah.compactIri({ activeCtx: e7, iri: "@language", relativeTo: { vocab: true } })] = r["@language"]), "@direction" in r && (f5[ah.compactIri({ activeCtx: e7, iri: "@direction", relativeTo: { vocab: true } })] = r["@direction"]), f5[ah.compactIri({ activeCtx: e7, iri: "@value", relativeTo: { vocab: true } })] = r["@value"], f5;
    }
    const i4 = Vd(e7, t, { vocab: true }, n4), o4 = Qd(e7, t, "@type"), a4 = ah.compactIri({ activeCtx: e7, iri: r["@id"], relativeTo: { vocab: "@vocab" === o4 }, base: n4.base });
    return "@id" === o4 || "@vocab" === o4 || "@graph" === i4 ? a4 : { [ah.compactIri({ activeCtx: e7, iri: "@id", relativeTo: { vocab: true } })]: a4 };
  };
  var dh = Vs;
  var hh = Ml;
  var fh = hl;
  var ph = class {
    constructor({ sharedCache: e7 }) {
      this.perOpCache = /* @__PURE__ */ new Map(), this.sharedCache = e7;
    }
    async resolve({ activeCtx: e7, context: t, documentLoader: r, base: n4, cycles: i4 = /* @__PURE__ */ new Set() }) {
      t && uu(t) && t["@context"] && (t = t["@context"]), t = du(t);
      const o4 = [];
      for (const a4 of t) {
        if (cu(a4)) {
          let t2 = this._get(a4);
          t2 || (t2 = await this._resolveRemoteContext({ activeCtx: e7, url: a4, documentLoader: r, base: n4, cycles: i4 })), lu(t2) ? o4.push(...t2) : o4.push(t2);
          continue;
        }
        if (null === a4) {
          o4.push(new pu({ document: null }));
          continue;
        }
        uu(a4) || mu(t);
        const s3 = JSON.stringify(a4);
        let l6 = this._get(s3);
        l6 || (l6 = new pu({ document: a4 }), this._cacheResolvedContext({ key: s3, resolved: l6, tag: "static" })), o4.push(l6);
      }
      return o4;
    }
    _get(e7) {
      let t = this.perOpCache.get(e7);
      if (!t) {
        const r = this.sharedCache.get(e7);
        r && (t = r.get("static"), t && this.perOpCache.set(e7, t));
      }
      return t;
    }
    _cacheResolvedContext({ key: e7, resolved: t, tag: r }) {
      if (this.perOpCache.set(e7, t), void 0 !== r) {
        let n4 = this.sharedCache.get(e7);
        n4 || (n4 = /* @__PURE__ */ new Map(), this.sharedCache.set(e7, n4)), n4.set(r, t);
      }
      return t;
    }
    async _resolveRemoteContext({ activeCtx: e7, url: t, documentLoader: r, base: n4, cycles: i4 }) {
      t = hu(n4, t);
      const { context: o4, remoteDoc: a4 } = await this._fetchContext({ activeCtx: e7, url: t, documentLoader: r, cycles: i4 });
      yu({ context: o4, base: n4 = a4.documentUrl || t });
      const s3 = await this.resolve({ activeCtx: e7, context: o4, documentLoader: r, base: n4, cycles: i4 });
      return this._cacheResolvedContext({ key: t, resolved: s3, tag: a4.tag }), s3;
    }
    async _fetchContext({ activeCtx: e7, url: t, documentLoader: r, cycles: n4 }) {
      if (n4.size > 10)
        throw new fu("Maximum number of @context URLs exceeded.", "jsonld.ContextUrlError", { code: "json-ld-1.0" === e7.processingMode ? "loading remote context failed" : "context overflow", max: 10 });
      if (n4.has(t))
        throw new fu("Cyclical @context URLs detected.", "jsonld.ContextUrlError", { code: "json-ld-1.0" === e7.processingMode ? "recursive context inclusion" : "context overflow", url: t });
      let i4, o4;
      n4.add(t);
      try {
        o4 = await r(t), i4 = o4.document || null, cu(i4) && (i4 = JSON.parse(i4));
      } catch (e8) {
        throw new fu("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.", "jsonld.InvalidUrl", { code: "loading remote context failed", url: t, cause: e8 });
      }
      if (!uu(i4))
        throw new fu("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.", "jsonld.InvalidUrl", { code: "invalid remote context", url: t });
      return i4 = "@context" in i4 ? { "@context": i4["@context"] } : { "@context": {} }, o4.contextUrl && (lu(i4["@context"]) || (i4["@context"] = [i4["@context"]]), i4["@context"].push(o4.contextUrl)), { context: i4, remoteDoc: o4 };
    }
  };
  var mh = fh.IdentifierIssuer;
  var yh = tl;
  var gh = au;
  var vh = gu;
  var { expand: wh } = pc;
  var { flatten: bh } = Dc;
  var { fromRDF: _h } = Jc;
  var { toRDF: Eh } = yd;
  var { frameMergedOrDefault: Th, cleanupNull: xh } = kd;
  var { isArray: Ih, isObject: Sh, isString: Rh } = Zs;
  var { isSubjectReference: kh } = el;
  var { expandIri: jh, getInitialContext: Dh, process: Nh, processingMode: Oh } = Uu;
  var { compact: Ch, compactIri: Ah } = uh;
  var { createNodeMap: Mh, createMergedNodeMap: Lh, mergeNodeMaps: Ph } = Sc;
  var { logEventHandler: Bh, logWarningEventHandler: $h, safeEventHandler: Fh, setDefaultEventHandler: Uh, setupEventHandler: qh, strictEventHandler: Yh, unhandledEventHandler: Wh } = Eu;
  var zh = function(e7) {
    const t = {}, r = new gh({ max: 100 });
    function n4(t2, { documentLoader: r2 = e7.documentLoader, ...n5 }) {
      if (t2 && "compactionMap" in t2)
        throw new yh('"compactionMap" not supported.', "jsonld.OptionsError");
      if (t2 && "expansionMap" in t2)
        throw new yh('"expansionMap" not supported.', "jsonld.OptionsError");
      return Object.assign({}, { documentLoader: r2 }, n5, t2, { eventHandler: qh({ options: t2 }) });
    }
    return e7.compact = async function(t2, i4, o4) {
      if (arguments.length < 2)
        throw new TypeError("Could not compact, too few arguments.");
      if (null === i4)
        throw new yh("The compaction context must not be null.", "jsonld.CompactError", { code: "invalid local context" });
      if (null === t2)
        return null;
      let a4;
      (o4 = n4(o4, { base: Rh(t2) ? t2 : "", compactArrays: true, compactToRelative: true, graph: false, skipExpansion: false, link: false, issuer: new mh("_:b"), contextResolver: new ph({ sharedCache: r }) })).link && (o4.skipExpansion = true), o4.compactToRelative || delete o4.base, a4 = o4.skipExpansion ? t2 : await e7.expand(t2, o4);
      const s3 = await e7.processContext(Dh(o4), i4, o4);
      let l6 = await Ch({ activeCtx: s3, element: a4, options: o4 });
      o4.compactArrays && !o4.graph && Ih(l6) ? 1 === l6.length ? l6 = l6[0] : 0 === l6.length && (l6 = {}) : o4.graph && Sh(l6) && (l6 = [l6]), Sh(i4) && "@context" in i4 && (i4 = i4["@context"]), i4 = fh.clone(i4), Ih(i4) || (i4 = [i4]);
      const u4 = i4;
      i4 = [];
      for (let e8 = 0; e8 < u4.length; ++e8)
        (!Sh(u4[e8]) || Object.keys(u4[e8]).length > 0) && i4.push(u4[e8]);
      const c3 = i4.length > 0;
      if (1 === i4.length && (i4 = i4[0]), Ih(l6)) {
        const e8 = Ah({ activeCtx: s3, iri: "@graph", relativeTo: { vocab: true } }), t3 = l6;
        l6 = {}, c3 && (l6["@context"] = i4), l6[e8] = t3;
      } else if (Sh(l6) && c3) {
        const e8 = l6;
        l6 = { "@context": i4 };
        for (const t3 in e8)
          l6[t3] = e8[t3];
      }
      return l6;
    }, e7.expand = async function(t2, i4) {
      if (arguments.length < 1)
        throw new TypeError("Could not expand, too few arguments.");
      const o4 = {}, a4 = [];
      if ("expandContext" in (i4 = n4(i4, { keepFreeFloatingNodes: false, contextResolver: new ph({ sharedCache: r }) }))) {
        const e8 = fh.clone(i4.expandContext);
        Sh(e8) && "@context" in e8 ? o4.expandContext = e8 : o4.expandContext = { "@context": e8 }, a4.push(o4.expandContext);
      }
      let s3;
      if (Rh(t2)) {
        const r2 = await e7.get(t2, i4);
        s3 = r2.documentUrl, o4.input = r2.document, r2.contextUrl && (o4.remoteContext = { "@context": r2.contextUrl }, a4.push(o4.remoteContext));
      } else
        o4.input = fh.clone(t2);
      "base" in i4 || (i4.base = s3 || "");
      let l6 = Dh(i4);
      for (const e8 of a4)
        l6 = await Nh({ activeCtx: l6, localCtx: e8, options: i4 });
      let u4 = await wh({ activeCtx: l6, element: o4.input, options: i4 });
      return Sh(u4) && "@graph" in u4 && 1 === Object.keys(u4).length ? u4 = u4["@graph"] : null === u4 && (u4 = []), Ih(u4) || (u4 = [u4]), u4;
    }, e7.flatten = async function(t2, i4, o4) {
      if (arguments.length < 1)
        return new TypeError("Could not flatten, too few arguments.");
      i4 = "function" == typeof i4 ? null : i4 || null, o4 = n4(o4, { base: Rh(t2) ? t2 : "", contextResolver: new ph({ sharedCache: r }) });
      const a4 = await e7.expand(t2, o4), s3 = bh(a4);
      if (null === i4)
        return s3;
      o4.graph = true, o4.skipExpansion = true;
      return await e7.compact(s3, i4, o4);
    }, e7.frame = async function(t2, i4, o4) {
      if (arguments.length < 2)
        throw new TypeError("Could not frame, too few arguments.");
      if (o4 = n4(o4, { base: Rh(t2) ? t2 : "", embed: "@once", explicit: false, requireAll: false, omitDefault: false, bnodesToClear: [], contextResolver: new ph({ sharedCache: r }) }), Rh(i4)) {
        const t3 = await e7.get(i4, o4);
        if (i4 = t3.document, t3.contextUrl) {
          let e8 = i4["@context"];
          e8 ? Ih(e8) ? e8.push(t3.contextUrl) : e8 = [e8, t3.contextUrl] : e8 = t3.contextUrl, i4["@context"] = e8;
        }
      }
      const a4 = i4 && i4["@context"] || {}, s3 = await e7.processContext(Dh(o4), a4, o4);
      o4.hasOwnProperty("omitGraph") || (o4.omitGraph = Oh(s3, 1.1)), o4.hasOwnProperty("pruneBlankNodeIdentifiers") || (o4.pruneBlankNodeIdentifiers = Oh(s3, 1.1));
      const l6 = await e7.expand(t2, o4), u4 = { ...o4 };
      u4.isFrame = true, u4.keepFreeFloatingNodes = true;
      const c3 = await e7.expand(i4, u4), d5 = Object.keys(i4).map((e8) => jh(s3, e8, { vocab: true }));
      u4.merged = !d5.includes("@graph"), u4.is11 = Oh(s3, 1.1);
      const h6 = Th(l6, c3, u4);
      u4.graph = !o4.omitGraph, u4.skipExpansion = true, u4.link = {}, u4.framing = true;
      let f5 = await e7.compact(h6, a4, u4);
      return u4.link = {}, f5 = xh(f5, u4), f5;
    }, e7.link = async function(t2, r2, n5) {
      const i4 = {};
      return r2 && (i4["@context"] = r2), i4["@embed"] = "@link", e7.frame(t2, i4, n5);
    }, e7.normalize = e7.canonize = async function(t2, i4) {
      if (arguments.length < 1)
        throw new TypeError("Could not canonize, too few arguments.");
      if ("inputFormat" in (i4 = n4(i4, { base: Rh(t2) ? t2 : null, algorithm: "URDNA2015", skipExpansion: false, safe: true, contextResolver: new ph({ sharedCache: r }) }))) {
        if ("application/n-quads" !== i4.inputFormat && "application/nquads" !== i4.inputFormat)
          throw new yh("Unknown canonicalization input format.", "jsonld.CanonizeError");
        const e8 = vh.parse(t2);
        return dh.canonize(e8, i4);
      }
      const o4 = { ...i4 };
      delete o4.format, o4.produceGeneralizedRdf = false;
      const a4 = await e7.toRDF(t2, o4);
      return dh.canonize(a4, i4);
    }, e7.fromRDF = async function(e8, r2) {
      if (arguments.length < 1)
        throw new TypeError("Could not convert from RDF, too few arguments.");
      r2 = n4(r2, { format: Rh(e8) ? "application/n-quads" : void 0 });
      const { format: i4 } = r2;
      let { rdfParser: o4 } = r2;
      if (i4) {
        if (o4 = o4 || t[i4], !o4)
          throw new yh("Unknown input format.", "jsonld.UnknownFormat", { format: i4 });
      } else
        o4 = () => e8;
      const a4 = await o4(e8);
      return _h(a4, r2);
    }, e7.toRDF = async function(t2, i4) {
      if (arguments.length < 1)
        throw new TypeError("Could not convert to RDF, too few arguments.");
      let o4;
      o4 = (i4 = n4(i4, { base: Rh(t2) ? t2 : "", skipExpansion: false, contextResolver: new ph({ sharedCache: r }) })).skipExpansion ? t2 : await e7.expand(t2, i4);
      const a4 = Eh(o4, i4);
      if (i4.format) {
        if ("application/n-quads" === i4.format || "application/nquads" === i4.format)
          return vh.serialize(a4);
        throw new yh("Unknown output format.", "jsonld.UnknownFormat", { format: i4.format });
      }
      return a4;
    }, e7.createNodeMap = async function(t2, i4) {
      if (arguments.length < 1)
        throw new TypeError("Could not create node map, too few arguments.");
      i4 = n4(i4, { base: Rh(t2) ? t2 : "", contextResolver: new ph({ sharedCache: r }) });
      const o4 = await e7.expand(t2, i4);
      return Lh(o4, i4);
    }, e7.merge = async function(t2, i4, o4) {
      if (arguments.length < 1)
        throw new TypeError("Could not merge, too few arguments.");
      if (!Ih(t2))
        throw new TypeError('Could not merge, "docs" must be an array.');
      i4 = "function" == typeof i4 ? null : i4 || null, o4 = n4(o4, { contextResolver: new ph({ sharedCache: r }) });
      const a4 = await Promise.all(t2.map((t3) => {
        const r2 = { ...o4 };
        return e7.expand(t3, r2);
      }));
      let s3 = true;
      "mergeNodes" in o4 && (s3 = o4.mergeNodes);
      const l6 = o4.issuer || new mh("_:b"), u4 = { "@default": {} };
      for (let e8 = 0; e8 < a4.length; ++e8) {
        const t3 = fh.relabelBlankNodes(a4[e8], { issuer: new mh("_:b" + e8 + "-") }), r2 = s3 || 0 === e8 ? u4 : { "@default": {} };
        if (Mh(t3, r2, "@default", l6), r2 !== u4)
          for (const e9 in r2) {
            const t4 = r2[e9];
            if (!(e9 in u4)) {
              u4[e9] = t4;
              continue;
            }
            const n5 = u4[e9];
            for (const e10 in t4)
              e10 in n5 || (n5[e10] = t4[e10]);
          }
      }
      const c3 = Ph(u4), d5 = [], h6 = Object.keys(c3).sort();
      for (let e8 = 0; e8 < h6.length; ++e8) {
        const t3 = c3[h6[e8]];
        kh(t3) || d5.push(t3);
      }
      if (null === i4)
        return d5;
      o4.graph = true, o4.skipExpansion = true;
      return await e7.compact(d5, i4, o4);
    }, Object.defineProperty(e7, "documentLoader", { get: () => e7._documentLoader, set: (t2) => e7._documentLoader = t2 }), e7.documentLoader = async (e8) => {
      throw new yh("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.", "jsonld.LoadDocumentError", { code: "loading document failed", url: e8 });
    }, e7.get = async function(t2, r2) {
      let n5;
      n5 = "function" == typeof r2.documentLoader ? r2.documentLoader : e7.documentLoader;
      const i4 = await n5(t2);
      try {
        if (!i4.document)
          throw new yh("No remote document found at the given URL.", "jsonld.NullRemoteDocument");
        Rh(i4.document) && (i4.document = JSON.parse(i4.document));
      } catch (e8) {
        throw new yh("Could not retrieve a JSON-LD document from the URL.", "jsonld.LoadDocumentError", { code: "loading document failed", cause: e8, remoteDoc: i4 });
      }
      return i4;
    }, e7.processContext = async function(e8, t2, i4) {
      return i4 = n4(i4, { base: "", contextResolver: new ph({ sharedCache: r }) }), null === t2 ? Dh(i4) : (t2 = fh.clone(t2), Sh(t2) && "@context" in t2 || (t2 = { "@context": t2 }), Nh({ activeCtx: e8, localCtx: t2, options: i4 }));
    }, e7.getContextValue = Uu.getContextValue, e7.documentLoaders = {}, e7.useDocumentLoader = function(t2) {
      if (!(t2 in e7.documentLoaders))
        throw new yh('Unknown document loader type: "' + t2 + '"', "jsonld.UnknownDocumentLoader", { type: t2 });
      e7.documentLoader = e7.documentLoaders[t2].apply(e7, Array.prototype.slice.call(arguments, 1));
    }, e7.registerRDFParser = function(e8, r2) {
      t[e8] = r2;
    }, e7.unregisterRDFParser = function(e8) {
      delete t[e8];
    }, e7.registerRDFParser("application/n-quads", vh.parse), e7.registerRDFParser("application/nquads", vh.parse), e7.url = El, e7.logEventHandler = Bh, e7.logWarningEventHandler = $h, e7.safeEventHandler = Fh, e7.setDefaultEventHandler = Uh, e7.strictEventHandler = Yh, e7.unhandledEventHandler = Wh, e7.util = fh, Object.assign(e7, fh), e7.promises = e7, e7.RequestQueue = wl(), e7.JsonLdProcessor = (lh || (lh = 1, sh = (e8) => {
      class t2 {
        toString() {
          return "[object JsonLdProcessor]";
        }
      }
      return Object.defineProperty(t2, "prototype", { writable: false, enumerable: false }), Object.defineProperty(t2.prototype, "constructor", { writable: true, enumerable: false, configurable: true, value: t2 }), t2.compact = function(t3, r2) {
        return arguments.length < 2 ? Promise.reject(new TypeError("Could not compact, too few arguments.")) : e8.compact(t3, r2);
      }, t2.expand = function(t3) {
        return arguments.length < 1 ? Promise.reject(new TypeError("Could not expand, too few arguments.")) : e8.expand(t3);
      }, t2.flatten = function(t3) {
        return arguments.length < 1 ? Promise.reject(new TypeError("Could not flatten, too few arguments.")) : e8.flatten(t3);
      }, t2;
    }), sh)(e7), hh.setupGlobals(e7), hh.setupDocumentLoaders(e7), e7;
  };
  var Gh = function() {
    return zh(function() {
      return Gh();
    });
  };
  zh(Gh);
  var Hh = Gh;
  function Jh(e7) {
    throw new Error('Could not dynamically require "' + e7 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var Vh = { exports: {} };
  Vh.exports = function() {
    function e7(t, r, n4) {
      function i4(a5, s3) {
        if (!r[a5]) {
          if (!t[a5]) {
            if (!s3 && Jh)
              return Jh(a5);
            if (o4)
              return o4(a5, true);
            var l6 = new Error("Cannot find module '" + a5 + "'");
            throw l6.code = "MODULE_NOT_FOUND", l6;
          }
          var u4 = r[a5] = { exports: {} };
          t[a5][0].call(u4.exports, function(e8) {
            return i4(t[a5][1][e8] || e8);
          }, u4, u4.exports, e7, t, r, n4);
        }
        return r[a5].exports;
      }
      for (var o4 = Jh, a4 = 0; a4 < n4.length; a4++)
        i4(n4[a4]);
      return i4;
    }
    return e7;
  }()({ 1: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    const n4 = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", i4 = "http://www.w3.org/2001/XMLSchema#", o4 = "http://www.w3.org/2000/10/swap/";
    r.default = { xsd: { decimal: `${i4}decimal`, boolean: `${i4}boolean`, double: `${i4}double`, integer: `${i4}integer`, string: `${i4}string` }, rdf: { type: `${n4}type`, nil: `${n4}nil`, first: `${n4}first`, rest: `${n4}rest`, langString: `${n4}langString` }, owl: { sameAs: "http://www.w3.org/2002/07/owl#sameAs" }, r: { forSome: `${o4}reify#forSome`, forAll: `${o4}reify#forAll` }, log: { implies: `${o4}log#implies` } };
  }, {}], 2: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = r.Variable = r.Triple = r.Term = r.Quad = r.NamedNode = r.Literal = r.DefaultGraph = r.BlankNode = void 0, r.escapeQuotes = b7, r.termFromId = g5, r.termToId = v6, r.unescapeQuotes = _5;
    var n4 = i4(e7("./IRIs"));
    function i4(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    const { rdf: o4, xsd: a4 } = n4.default;
    let s3, l6 = 0;
    const u4 = /^"(.*".*)(?="[^"]*$)/, c3 = { namedNode: E4, blankNode: T6, variable: I5, literal: x6, defaultGraph: S6, quad: R5, triple: R5 };
    r.default = c3;
    class d5 {
      constructor(e8) {
        this.id = e8;
      }
      get value() {
        return this.id;
      }
      equals(e8) {
        return e8 instanceof d5 ? this.id === e8.id : !!e8 && this.termType === e8.termType && this.value === e8.value;
      }
      hashCode() {
        return 0;
      }
      toJSON() {
        return { termType: this.termType, value: this.value };
      }
    }
    r.Term = d5;
    class h6 extends d5 {
      get termType() {
        return "NamedNode";
      }
    }
    r.NamedNode = h6;
    class f5 extends d5 {
      get termType() {
        return "Literal";
      }
      get value() {
        return this.id.substring(1, this.id.lastIndexOf('"'));
      }
      get language() {
        const e8 = this.id;
        let t2 = e8.lastIndexOf('"') + 1;
        return t2 < e8.length && "@" === e8[t2++] ? e8.substr(t2).toLowerCase() : "";
      }
      get datatype() {
        return new h6(this.datatypeString);
      }
      get datatypeString() {
        const e8 = this.id, t2 = e8.lastIndexOf('"') + 1, r2 = t2 < e8.length ? e8[t2] : "";
        return "^" === r2 ? e8.substr(t2 + 2) : "@" !== r2 ? a4.string : o4.langString;
      }
      equals(e8) {
        return e8 instanceof f5 ? this.id === e8.id : !!e8 && !!e8.datatype && this.termType === e8.termType && this.value === e8.value && this.language === e8.language && this.datatype.value === e8.datatype.value;
      }
      toJSON() {
        return { termType: this.termType, value: this.value, language: this.language, datatype: { termType: "NamedNode", value: this.datatypeString } };
      }
    }
    r.Literal = f5;
    class p6 extends d5 {
      constructor(e8) {
        super(`_:${e8}`);
      }
      get termType() {
        return "BlankNode";
      }
      get value() {
        return this.id.substr(2);
      }
    }
    r.BlankNode = p6;
    class m5 extends d5 {
      constructor(e8) {
        super(`?${e8}`);
      }
      get termType() {
        return "Variable";
      }
      get value() {
        return this.id.substr(1);
      }
    }
    r.Variable = m5;
    class y5 extends d5 {
      constructor() {
        return super(""), s3 || this;
      }
      get termType() {
        return "DefaultGraph";
      }
      equals(e8) {
        return this === e8 || !!e8 && this.termType === e8.termType;
      }
    }
    function g5(e8, t2, r2) {
      if (t2 = t2 || c3, !e8)
        return t2.defaultGraph();
      switch (e8[0]) {
        case "?":
          return t2.variable(e8.substr(1));
        case "_":
          return t2.blankNode(e8.substr(2));
        case '"':
          if (t2 === c3)
            return new f5(e8);
          if ('"' === e8[e8.length - 1])
            return t2.literal(e8.substr(1, e8.length - 2));
          const n5 = e8.lastIndexOf('"', e8.length - 1);
          return t2.literal(e8.substr(1, n5 - 1), "@" === e8[n5 + 1] ? e8.substr(n5 + 2) : t2.namedNode(e8.substr(n5 + 3)));
        case "[":
          e8 = JSON.parse(e8);
          break;
        default:
          if (!r2 || !Array.isArray(e8))
            return t2.namedNode(e8);
      }
      return t2.quad(g5(e8[0], t2, true), g5(e8[1], t2, true), g5(e8[2], t2, true), e8[3] && g5(e8[3], t2, true));
    }
    function v6(e8, t2) {
      if ("string" == typeof e8)
        return e8;
      if (e8 instanceof d5 && "Quad" !== e8.termType)
        return e8.id;
      if (!e8)
        return s3.id;
      switch (e8.termType) {
        case "NamedNode":
          return e8.value;
        case "BlankNode":
          return `_:${e8.value}`;
        case "Variable":
          return `?${e8.value}`;
        case "DefaultGraph":
          return "";
        case "Literal":
          return `"${e8.value}"${e8.language ? `@${e8.language}` : e8.datatype && e8.datatype.value !== a4.string ? `^^${e8.datatype.value}` : ""}`;
        case "Quad":
          const r2 = [v6(e8.subject, true), v6(e8.predicate, true), v6(e8.object, true)];
          return e8.graph && "DefaultGraph" !== e8.graph.termType && r2.push(v6(e8.graph, true)), t2 ? r2 : JSON.stringify(r2);
        default:
          throw new Error(`Unexpected termType: ${e8.termType}`);
      }
    }
    r.DefaultGraph = y5, s3 = new y5();
    class w5 extends d5 {
      constructor(e8, t2, r2, n5) {
        super(""), this._subject = e8, this._predicate = t2, this._object = r2, this._graph = n5 || s3;
      }
      get termType() {
        return "Quad";
      }
      get subject() {
        return this._subject;
      }
      get predicate() {
        return this._predicate;
      }
      get object() {
        return this._object;
      }
      get graph() {
        return this._graph;
      }
      toJSON() {
        return { termType: this.termType, subject: this._subject.toJSON(), predicate: this._predicate.toJSON(), object: this._object.toJSON(), graph: this._graph.toJSON() };
      }
      equals(e8) {
        return !!e8 && this._subject.equals(e8.subject) && this._predicate.equals(e8.predicate) && this._object.equals(e8.object) && this._graph.equals(e8.graph);
      }
    }
    function b7(e8) {
      return e8.replace(u4, (e9, t2) => `"${t2.replace(/"/g, '""')}`);
    }
    function _5(e8) {
      return e8.replace(u4, (e9, t2) => `"${t2.replace(/""/g, '"')}`);
    }
    function E4(e8) {
      return new h6(e8);
    }
    function T6(e8) {
      return new p6(e8 || "n3-" + l6++);
    }
    function x6(e8, t2) {
      if ("string" == typeof t2)
        return new f5(`"${e8}"@${t2.toLowerCase()}`);
      let r2 = t2 ? t2.value : "";
      return "" === r2 && ("boolean" == typeof e8 ? r2 = a4.boolean : "number" == typeof e8 && (Number.isFinite(e8) ? r2 = Number.isInteger(e8) ? a4.integer : a4.double : (r2 = a4.double, Number.isNaN(e8) || (e8 = e8 > 0 ? "INF" : "-INF")))), "" === r2 || r2 === a4.string ? new f5(`"${e8}"`) : new f5(`"${e8}"^^${r2}`);
    }
    function I5(e8) {
      return new m5(e8);
    }
    function S6() {
      return s3;
    }
    function R5(e8, t2, r2, n5) {
      return new w5(e8, t2, r2, n5);
    }
    r.Triple = r.Quad = w5;
  }, { "./IRIs": 1 }], 3: [function(e7, t, r) {
    (function(t2) {
      (function() {
        Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
        var n4 = o4(e7("queue-microtask")), i4 = o4(e7("./IRIs"));
        function o4(e8) {
          return e8 && e8.__esModule ? e8 : { default: e8 };
        }
        const { xsd: a4 } = i4.default, s3 = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g, l6 = { "\\": "\\", "'": "'", '"': '"', n: "\n", r: "\r", t: "	", f: "\f", b: "\b", _: "_", "~": "~", ".": ".", "-": "-", "!": "!", $: "$", "&": "&", "(": "(", ")": ")", "*": "*", "+": "+", ",": ",", ";": ";", "=": "=", "/": "/", "?": "?", "#": "#", "@": "@", "%": "%" }, u4 = /[\x00-\x20<>\\"\{\}\|\^\`]/, c3 = { _iri: true, _unescapedIri: true, _simpleQuotedString: true, _langcode: true, _blank: true, _newline: true, _comment: true, _whitespace: true, _endOfFile: true }, d5 = /$0^/;
        class h6 {
          constructor(e8) {
            if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/, this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/, this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i, this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/, this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/, this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/, this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/, this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/, this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/, this._keyword = /^@[a-z]+(?=[\s#<:])/i, this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i, this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/, this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/, this._comment = /#([^\n\r]*)/, this._whitespace = /^[ \t]+/, this._endOfFile = /^(?:#[^\n\r]*)?$/, e8 = e8 || {}, this._lineMode = !!e8.lineMode) {
              this._n3Mode = false;
              for (const e9 in this)
                !(e9 in c3) && this[e9] instanceof RegExp && (this[e9] = d5);
            } else
              this._n3Mode = false !== e8.n3;
            this._comments = !!e8.comments, this._literalClosingPos = 0;
          }
          _tokenizeToEnd(e8, t3) {
            let r2 = this._input, n5 = r2.length;
            for (; ; ) {
              let e9, s4;
              for (; e9 = this._newline.exec(r2); )
                this._comments && (s4 = this._comment.exec(e9[0])) && i5("comment", s4[1], "", this._line, e9[0].length), r2 = r2.substr(e9[0].length, r2.length), n5 = r2.length, this._line++;
              if (!e9 && (e9 = this._whitespace.exec(r2)) && (r2 = r2.substr(e9[0].length, r2.length)), this._endOfFile.test(r2))
                return t3 && (this._comments && (s4 = this._comment.exec(r2)) && i5("comment", s4[1], "", this._line, r2.length), r2 = null, i5("eof", "", "", this._line, 0)), this._input = r2;
              const l7 = this._line, c4 = r2[0];
              let d6 = "", h7 = "", f5 = "", p6 = null, m5 = 0, y5 = false;
              switch (c4) {
                case "^":
                  if (r2.length < 3)
                    break;
                  if ("^" !== r2[1]) {
                    this._n3Mode && (m5 = 1, d6 = "^");
                    break;
                  }
                  if (this._previousMarker = "^^", r2 = r2.substr(2), "<" !== r2[0]) {
                    y5 = true;
                    break;
                  }
                case "<":
                  if (p6 = this._unescapedIri.exec(r2))
                    d6 = "IRI", h7 = p6[1];
                  else if (p6 = this._iri.exec(r2)) {
                    if (h7 = this._unescape(p6[1]), null === h7 || u4.test(h7))
                      return o5(this);
                    d6 = "IRI";
                  } else
                    r2.length > 1 && "<" === r2[1] ? (d6 = "<<", m5 = 2) : this._n3Mode && r2.length > 1 && "=" === r2[1] && (d6 = "inverse", m5 = 2, h7 = ">");
                  break;
                case ">":
                  r2.length > 1 && ">" === r2[1] && (d6 = ">>", m5 = 2);
                  break;
                case "_":
                  ((p6 = this._blank.exec(r2)) || t3 && (p6 = this._blank.exec(`${r2} `))) && (d6 = "blank", f5 = "_", h7 = p6[1]);
                  break;
                case '"':
                  if (p6 = this._simpleQuotedString.exec(r2))
                    h7 = p6[1];
                  else if ({ value: h7, matchLength: m5 } = this._parseLiteral(r2), null === h7)
                    return o5(this);
                  null === p6 && 0 === m5 || (d6 = "literal", this._literalClosingPos = 0);
                  break;
                case "'":
                  if (!this._lineMode) {
                    if (p6 = this._simpleApostropheString.exec(r2))
                      h7 = p6[1];
                    else if ({ value: h7, matchLength: m5 } = this._parseLiteral(r2), null === h7)
                      return o5(this);
                    null === p6 && 0 === m5 || (d6 = "literal", this._literalClosingPos = 0);
                  }
                  break;
                case "?":
                  this._n3Mode && (p6 = this._variable.exec(r2)) && (d6 = "var", h7 = p6[0]);
                  break;
                case "@":
                  "literal" === this._previousMarker && (p6 = this._langcode.exec(r2)) ? (d6 = "langcode", h7 = p6[1]) : (p6 = this._keyword.exec(r2)) && (d6 = p6[0]);
                  break;
                case ".":
                  if (1 === r2.length ? t3 : r2[1] < "0" || r2[1] > "9") {
                    d6 = ".", m5 = 1;
                    break;
                  }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                case "+":
                case "-":
                  (p6 = this._number.exec(r2) || t3 && (p6 = this._number.exec(`${r2} `))) && (d6 = "literal", h7 = p6[0], f5 = "string" == typeof p6[1] ? a4.double : "string" == typeof p6[2] ? a4.decimal : a4.integer);
                  break;
                case "B":
                case "b":
                case "p":
                case "P":
                case "G":
                case "g":
                  (p6 = this._sparqlKeyword.exec(r2)) ? d6 = p6[0].toUpperCase() : y5 = true;
                  break;
                case "f":
                case "t":
                  (p6 = this._boolean.exec(r2)) ? (d6 = "literal", h7 = p6[0], f5 = a4.boolean) : y5 = true;
                  break;
                case "a":
                  (p6 = this._shortPredicates.exec(r2)) ? (d6 = "abbreviation", h7 = "a") : y5 = true;
                  break;
                case "=":
                  this._n3Mode && r2.length > 1 && (d6 = "abbreviation", ">" !== r2[1] ? (m5 = 1, h7 = "=") : (m5 = 2, h7 = ">"));
                  break;
                case "!":
                  if (!this._n3Mode)
                    break;
                case ",":
                case ";":
                case "[":
                case "]":
                case "(":
                case ")":
                case "}":
                  this._lineMode || (m5 = 1, d6 = c4);
                  break;
                case "{":
                  !this._lineMode && r2.length >= 2 && ("|" === r2[1] ? (d6 = "{|", m5 = 2) : (d6 = c4, m5 = 1));
                  break;
                case "|":
                  r2.length >= 2 && "}" === r2[1] && (d6 = "|}", m5 = 2);
                  break;
                default:
                  y5 = true;
              }
              if (y5 && ("@prefix" !== this._previousMarker && "PREFIX" !== this._previousMarker || !(p6 = this._prefix.exec(r2)) ? ((p6 = this._prefixed.exec(r2)) || t3 && (p6 = this._prefixed.exec(`${r2} `))) && (d6 = "prefixed", f5 = p6[1] || "", h7 = this._unescape(p6[2])) : (d6 = "prefix", h7 = p6[1] || "")), "^^" === this._previousMarker)
                switch (d6) {
                  case "prefixed":
                    d6 = "type";
                    break;
                  case "IRI":
                    d6 = "typeIRI";
                    break;
                  default:
                    d6 = "";
                }
              if (!d6)
                return t3 || !/^'''|^"""/.test(r2) && /\n|\r/.test(r2) ? o5(this) : this._input = r2;
              const g5 = m5 || p6[0].length, v6 = i5(d6, h7, f5, l7, g5);
              this.previousToken = v6, this._previousMarker = d6, r2 = r2.substr(g5, r2.length);
            }
            function i5(t4, i6, o6, a5, s4) {
              const l7 = r2 ? n5 - r2.length : n5, u5 = { type: t4, value: i6, prefix: o6, line: a5, start: l7, end: l7 + s4 };
              return e8(null, u5), u5;
            }
            function o5(t4) {
              e8(t4._syntaxError(/^\S*/.exec(r2)[0]));
            }
          }
          _unescape(e8) {
            let t3 = false;
            const r2 = e8.replace(s3, (e9, r3, n5, i5) => {
              if ("string" == typeof r3)
                return String.fromCharCode(Number.parseInt(r3, 16));
              if ("string" == typeof n5) {
                let e10 = Number.parseInt(n5, 16);
                return e10 <= 65535 ? String.fromCharCode(Number.parseInt(n5, 16)) : String.fromCharCode(55296 + ((e10 -= 65536) >> 10), 56320 + (1023 & e10));
              }
              return i5 in l6 ? l6[i5] : (t3 = true, "");
            });
            return t3 ? null : r2;
          }
          _parseLiteral(e8) {
            if (e8.length >= 3) {
              const t3 = e8.match(/^(?:"""|"|'''|'|)/)[0], r2 = t3.length;
              let n5 = Math.max(this._literalClosingPos, r2);
              for (; (n5 = e8.indexOf(t3, n5)) > 0; ) {
                let t4 = 0;
                for (; "\\" === e8[n5 - t4 - 1]; )
                  t4++;
                if (t4 % 2 == 0) {
                  const t5 = e8.substring(r2, n5), i5 = t5.split(/\r\n|\r|\n/).length - 1, o5 = n5 + r2;
                  if (1 === r2 && 0 !== i5 || 3 === r2 && this._lineMode)
                    break;
                  return this._line += i5, { value: this._unescape(t5), matchLength: o5 };
                }
                n5++;
              }
              this._literalClosingPos = e8.length - r2 + 1;
            }
            return { value: "", matchLength: 0 };
          }
          _syntaxError(e8) {
            this._input = null;
            const t3 = new Error(`Unexpected "${e8}" on line ${this._line}.`);
            return t3.context = { token: void 0, line: this._line, previousToken: this.previousToken }, t3;
          }
          _readStartingBom(e8) {
            return e8.startsWith("\uFEFF") ? e8.substr(1) : e8;
          }
          tokenize(e8, r2) {
            if (this._line = 1, "string" == typeof e8) {
              if (this._input = this._readStartingBom(e8), "function" != typeof r2) {
                const e9 = [];
                let t3;
                if (this._tokenizeToEnd((r3, n5) => r3 ? t3 = r3 : e9.push(n5), true), t3)
                  throw t3;
                return e9;
              }
              (0, n4.default)(() => this._tokenizeToEnd(r2, true));
            } else
              this._pendingBuffer = null, "function" == typeof e8.setEncoding && e8.setEncoding("utf8"), e8.on("data", (e9) => {
                null !== this._input && 0 !== e9.length && (this._pendingBuffer && (e9 = t2.concat([this._pendingBuffer, e9]), this._pendingBuffer = null), 128 & e9[e9.length - 1] ? this._pendingBuffer = e9 : (void 0 === this._input ? this._input = this._readStartingBom("string" == typeof e9 ? e9 : e9.toString()) : this._input += e9, this._tokenizeToEnd(r2, false)));
              }), e8.on("end", () => {
                "string" == typeof this._input && this._tokenizeToEnd(r2, true);
              }), e8.on("error", r2);
          }
        }
        r.default = h6;
      }).call(this);
    }).call(this, e7("buffer").Buffer);
  }, { "./IRIs": 1, buffer: 15, "queue-microtask": 19 }], 4: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    var n4 = a4(e7("./N3Lexer")), i4 = a4(e7("./N3DataFactory")), o4 = a4(e7("./IRIs"));
    function a4(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    let s3 = 0;
    class l6 {
      constructor(e8) {
        this._contextStack = [], this._graph = null, e8 = e8 || {}, this._setBase(e8.baseIRI), e8.factory && c3(this, e8.factory);
        const t2 = "string" == typeof e8.format ? e8.format.match(/\w*$/)[0].toLowerCase() : "", r2 = /turtle/.test(t2), i5 = /trig/.test(t2), o5 = /triple/.test(t2), a5 = /quad/.test(t2), s4 = this._n3Mode = /n3/.test(t2), l7 = o5 || a5;
        (this._supportsNamedGraphs = !(r2 || s4)) || (this._readPredicateOrNamedGraph = this._readPredicate), this._supportsQuads = !(r2 || i5 || o5 || s4), this._supportsRDFStar = "" === t2 || /star|\*$/.test(t2), l7 && (this._resolveRelativeIRI = (e9) => null), this._blankNodePrefix = "string" != typeof e8.blankNodePrefix ? "" : e8.blankNodePrefix.replace(/^(?!_:)/, "_:"), this._lexer = e8.lexer || new n4.default({ lineMode: l7, n3: s4 }), this._explicitQuantifiers = !!e8.explicitQuantifiers;
      }
      static _resetBlankNodePrefix() {
        s3 = 0;
      }
      _setBase(e8) {
        if (e8) {
          const t2 = e8.indexOf("#");
          t2 >= 0 && (e8 = e8.substr(0, t2)), this._base = e8, this._basePath = e8.indexOf("/") < 0 ? e8 : e8.replace(/[^\/?]*(?:\?.*)?$/, ""), e8 = e8.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i), this._baseRoot = e8[0], this._baseScheme = e8[1];
        } else
          this._base = "", this._basePath = "";
      }
      _saveContext(e8, t2, r2, n5, i5) {
        const o5 = this._n3Mode;
        this._contextStack.push({ type: e8, subject: r2, predicate: n5, object: i5, graph: t2, inverse: !!o5 && this._inversePredicate, blankPrefix: o5 ? this._prefixes._ : "", quantified: o5 ? this._quantified : null }), o5 && (this._inversePredicate = false, this._prefixes._ = this._graph ? `${this._graph.value}.` : ".", this._quantified = Object.create(this._quantified));
      }
      _restoreContext(e8, t2) {
        const r2 = this._contextStack.pop();
        if (!r2 || r2.type !== e8)
          return this._error(`Unexpected ${t2.type}`, t2);
        this._subject = r2.subject, this._predicate = r2.predicate, this._object = r2.object, this._graph = r2.graph, this._n3Mode && (this._inversePredicate = r2.inverse, this._prefixes._ = r2.blankPrefix, this._quantified = r2.quantified);
      }
      _readInTopContext(e8) {
        switch (e8.type) {
          case "eof":
            return null !== this._graph ? this._error("Unclosed graph", e8) : (delete this._prefixes._, this._callback(null, null, this._prefixes));
          case "PREFIX":
            this._sparqlStyle = true;
          case "@prefix":
            return this._readPrefix;
          case "BASE":
            this._sparqlStyle = true;
          case "@base":
            return this._readBaseIRI;
          case "{":
            if (this._supportsNamedGraphs)
              return this._graph = "", this._subject = null, this._readSubject;
          case "GRAPH":
            if (this._supportsNamedGraphs)
              return this._readNamedGraphLabel;
          default:
            return this._readSubject(e8);
        }
      }
      _readEntity(e8, t2) {
        let r2;
        switch (e8.type) {
          case "IRI":
          case "typeIRI":
            const t3 = this._resolveIRI(e8.value);
            if (null === t3)
              return this._error("Invalid IRI", e8);
            r2 = this._namedNode(t3);
            break;
          case "type":
          case "prefixed":
            const n5 = this._prefixes[e8.prefix];
            if (void 0 === n5)
              return this._error(`Undefined prefix "${e8.prefix}:"`, e8);
            r2 = this._namedNode(n5 + e8.value);
            break;
          case "blank":
            r2 = this._blankNode(this._prefixes[e8.prefix] + e8.value);
            break;
          case "var":
            r2 = this._variable(e8.value.substr(1));
            break;
          default:
            return this._error(`Expected entity but got ${e8.type}`, e8);
        }
        return !t2 && this._n3Mode && r2.id in this._quantified && (r2 = this._quantified[r2.id]), r2;
      }
      _readSubject(e8) {
        switch (this._predicate = null, e8.type) {
          case "[":
            return this._saveContext("blank", this._graph, this._subject = this._blankNode(), null, null), this._readBlankNodeHead;
          case "(":
            return this._saveContext("list", this._graph, this.RDF_NIL, null, null), this._subject = null, this._readListItem;
          case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._graph = this._blankNode(), null, null), this._readSubject) : this._error("Unexpected graph", e8);
          case "}":
            return this._readPunctuation(e8);
          case "@forSome":
            return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORSOME, this._quantifier = this._blankNode, this._readQuantifierList) : this._error('Unexpected "@forSome"', e8);
          case "@forAll":
            return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORALL, this._quantifier = this._variable, this._readQuantifierList) : this._error('Unexpected "@forAll"', e8);
          case "literal":
            if (!this._n3Mode)
              return this._error("Unexpected literal", e8);
            if (0 === e8.prefix.length)
              return this._literalValue = e8.value, this._completeSubjectLiteral;
            this._subject = this._literal(e8.value, this._namedNode(e8.prefix));
            break;
          case "<<":
            return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", e8);
          default:
            if (void 0 === (this._subject = this._readEntity(e8)))
              return;
            if (this._n3Mode)
              return this._getPathReader(this._readPredicateOrNamedGraph);
        }
        return this._readPredicateOrNamedGraph;
      }
      _readPredicate(e8) {
        const t2 = e8.type;
        switch (t2) {
          case "inverse":
            this._inversePredicate = true;
          case "abbreviation":
            this._predicate = this.ABBREVIATIONS[e8.value];
            break;
          case ".":
          case "]":
          case "}":
            return null === this._predicate ? this._error(`Unexpected ${t2}`, e8) : (this._subject = null, "]" === t2 ? this._readBlankNodeTail(e8) : this._readPunctuation(e8));
          case ";":
            return null !== this._predicate ? this._readPredicate : this._error("Expected predicate but got ;", e8);
          case "[":
            if (this._n3Mode)
              return this._saveContext("blank", this._graph, this._subject, this._subject = this._blankNode(), null), this._readBlankNodeHead;
          case "blank":
            if (!this._n3Mode)
              return this._error("Disallowed blank node as predicate", e8);
          default:
            if (void 0 === (this._predicate = this._readEntity(e8)))
              return;
        }
        return this._readObject;
      }
      _readObject(e8) {
        switch (e8.type) {
          case "literal":
            if (0 === e8.prefix.length)
              return this._literalValue = e8.value, this._readDataTypeOrLang;
            this._object = this._literal(e8.value, this._namedNode(e8.prefix));
            break;
          case "[":
            return this._saveContext("blank", this._graph, this._subject, this._predicate, this._subject = this._blankNode()), this._readBlankNodeHead;
          case "(":
            return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL), this._subject = null, this._readListItem;
          case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode()), this._readSubject) : this._error("Unexpected graph", e8);
          case "<<":
            return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", e8);
          default:
            if (void 0 === (this._object = this._readEntity(e8)))
              return;
            if (this._n3Mode)
              return this._getPathReader(this._getContextEndReader());
        }
        return this._getContextEndReader();
      }
      _readPredicateOrNamedGraph(e8) {
        return "{" === e8.type ? this._readGraph(e8) : this._readPredicate(e8);
      }
      _readGraph(e8) {
        return "{" !== e8.type ? this._error(`Expected graph but got ${e8.type}`, e8) : (this._graph = this._subject, this._subject = null, this._readSubject);
      }
      _readBlankNodeHead(e8) {
        return "]" === e8.type ? (this._subject = null, this._readBlankNodeTail(e8)) : (this._predicate = null, this._readPredicate(e8));
      }
      _readBlankNodeTail(e8) {
        if ("]" !== e8.type)
          return this._readBlankNodePunctuation(e8);
        null !== this._subject && this._emit(this._subject, this._predicate, this._object, this._graph);
        const t2 = null === this._predicate;
        return this._restoreContext("blank", e8), null !== this._object ? this._getContextEndReader() : null !== this._predicate ? this._readObject : t2 ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
      }
      _readPredicateAfterBlank(e8) {
        switch (e8.type) {
          case ".":
          case "}":
            return this._subject = null, this._readPunctuation(e8);
          default:
            return this._readPredicate(e8);
        }
      }
      _readListItem(e8) {
        let t2 = null, r2 = null, n5 = this._readListItem;
        const i5 = this._subject, o5 = this._contextStack, a5 = o5[o5.length - 1];
        switch (e8.type) {
          case "[":
            this._saveContext("blank", this._graph, r2 = this._blankNode(), this.RDF_FIRST, this._subject = t2 = this._blankNode()), n5 = this._readBlankNodeHead;
            break;
          case "(":
            this._saveContext("list", this._graph, r2 = this._blankNode(), this.RDF_FIRST, this.RDF_NIL), this._subject = null;
            break;
          case ")":
            if (this._restoreContext("list", e8), 0 !== o5.length && "list" === o5[o5.length - 1].type && this._emit(this._subject, this._predicate, this._object, this._graph), null === this._predicate) {
              if (n5 = this._readPredicate, this._subject === this.RDF_NIL)
                return n5;
            } else if (n5 = this._getContextEndReader(), this._object === this.RDF_NIL)
              return n5;
            r2 = this.RDF_NIL;
            break;
          case "literal":
            0 === e8.prefix.length ? (this._literalValue = e8.value, n5 = this._readListItemDataTypeOrLang) : (t2 = this._literal(e8.value, this._namedNode(e8.prefix)), n5 = this._getContextEndReader());
            break;
          case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode()), this._readSubject) : this._error("Unexpected graph", e8);
          default:
            if (void 0 === (t2 = this._readEntity(e8)))
              return;
        }
        if (null === r2 && (this._subject = r2 = this._blankNode()), null === i5 ? null === a5.predicate ? a5.subject = r2 : a5.object = r2 : this._emit(i5, this.RDF_REST, r2, this._graph), null !== t2) {
          if (this._n3Mode && ("IRI" === e8.type || "prefixed" === e8.type))
            return this._saveContext("item", this._graph, r2, this.RDF_FIRST, t2), this._subject = t2, this._predicate = null, this._getPathReader(this._readListItem);
          this._emit(r2, this.RDF_FIRST, t2, this._graph);
        }
        return n5;
      }
      _readDataTypeOrLang(e8) {
        return this._completeObjectLiteral(e8, false);
      }
      _readListItemDataTypeOrLang(e8) {
        return this._completeObjectLiteral(e8, true);
      }
      _completeLiteral(e8) {
        let t2 = this._literal(this._literalValue);
        switch (e8.type) {
          case "type":
          case "typeIRI":
            const r2 = this._readEntity(e8);
            if (void 0 === r2)
              return;
            t2 = this._literal(this._literalValue, r2), e8 = null;
            break;
          case "langcode":
            t2 = this._literal(this._literalValue, e8.value), e8 = null;
        }
        return { token: e8, literal: t2 };
      }
      _completeSubjectLiteral(e8) {
        return this._subject = this._completeLiteral(e8).literal, this._readPredicateOrNamedGraph;
      }
      _completeObjectLiteral(e8, t2) {
        const r2 = this._completeLiteral(e8);
        if (r2)
          return this._object = r2.literal, t2 && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph), null === r2.token ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(), this._readCallback(r2.token));
      }
      _readFormulaTail(e8) {
        return "}" !== e8.type ? this._readPunctuation(e8) : (null !== this._subject && this._emit(this._subject, this._predicate, this._object, this._graph), this._restoreContext("formula", e8), null === this._object ? this._readPredicate : this._getContextEndReader());
      }
      _readPunctuation(e8) {
        let t2, r2 = this._graph;
        const n5 = this._subject, i5 = this._inversePredicate;
        switch (e8.type) {
          case "}":
            if (null === this._graph)
              return this._error("Unexpected graph closing", e8);
            if (this._n3Mode)
              return this._readFormulaTail(e8);
            this._graph = null;
          case ".":
            this._subject = null, t2 = this._contextStack.length ? this._readSubject : this._readInTopContext, i5 && (this._inversePredicate = false);
            break;
          case ";":
            t2 = this._readPredicate;
            break;
          case ",":
            t2 = this._readObject;
            break;
          case "{|":
            if (!this._supportsRDFStar)
              return this._error("Unexpected RDF* syntax", e8);
            const o5 = this._predicate, a5 = this._object;
            this._subject = this._quad(n5, o5, a5, this.DEFAULTGRAPH), t2 = this._readPredicate;
            break;
          case "|}":
            if ("Quad" !== this._subject.termType)
              return this._error("Unexpected asserted triple closing", e8);
            this._subject = null, t2 = this._readPunctuation;
            break;
          default:
            if (this._supportsQuads && null === this._graph && void 0 !== (r2 = this._readEntity(e8))) {
              t2 = this._readQuadPunctuation;
              break;
            }
            return this._error(`Expected punctuation to follow "${this._object.id}"`, e8);
        }
        if (null !== n5) {
          const e9 = this._predicate, t3 = this._object;
          i5 ? this._emit(t3, e9, n5, r2) : this._emit(n5, e9, t3, r2);
        }
        return t2;
      }
      _readBlankNodePunctuation(e8) {
        let t2;
        switch (e8.type) {
          case ";":
            t2 = this._readPredicate;
            break;
          case ",":
            t2 = this._readObject;
            break;
          default:
            return this._error(`Expected punctuation to follow "${this._object.id}"`, e8);
        }
        return this._emit(this._subject, this._predicate, this._object, this._graph), t2;
      }
      _readQuadPunctuation(e8) {
        return "." !== e8.type ? this._error("Expected dot to follow quad", e8) : this._readInTopContext;
      }
      _readPrefix(e8) {
        return "prefix" !== e8.type ? this._error("Expected prefix to follow @prefix", e8) : (this._prefix = e8.value, this._readPrefixIRI);
      }
      _readPrefixIRI(e8) {
        if ("IRI" !== e8.type)
          return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, e8);
        const t2 = this._readEntity(e8);
        return this._prefixes[this._prefix] = t2.value, this._prefixCallback(this._prefix, t2), this._readDeclarationPunctuation;
      }
      _readBaseIRI(e8) {
        const t2 = "IRI" === e8.type && this._resolveIRI(e8.value);
        return t2 ? (this._setBase(t2), this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", e8);
      }
      _readNamedGraphLabel(e8) {
        switch (e8.type) {
          case "IRI":
          case "blank":
          case "prefixed":
            return this._readSubject(e8), this._readGraph;
          case "[":
            return this._readNamedGraphBlankLabel;
          default:
            return this._error("Invalid graph label", e8);
        }
      }
      _readNamedGraphBlankLabel(e8) {
        return "]" !== e8.type ? this._error("Invalid graph label", e8) : (this._subject = this._blankNode(), this._readGraph);
      }
      _readDeclarationPunctuation(e8) {
        return this._sparqlStyle ? (this._sparqlStyle = false, this._readInTopContext(e8)) : "." !== e8.type ? this._error("Expected declaration to end with a dot", e8) : this._readInTopContext;
      }
      _readQuantifierList(e8) {
        let t2;
        switch (e8.type) {
          case "IRI":
          case "prefixed":
            if (void 0 !== (t2 = this._readEntity(e8, true)))
              break;
          default:
            return this._error(`Unexpected ${e8.type}`, e8);
        }
        return this._explicitQuantifiers ? (null === this._subject ? this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH) : this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH), this._emit(this._subject, this.RDF_FIRST, t2, this.QUANTIFIERS_GRAPH)) : this._quantified[t2.id] = this._quantifier(this._blankNode().value), this._readQuantifierPunctuation;
      }
      _readQuantifierPunctuation(e8) {
        return "," === e8.type ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH), this._subject = null), this._readCallback = this._getContextEndReader(), this._readCallback(e8));
      }
      _getPathReader(e8) {
        return this._afterPath = e8, this._readPath;
      }
      _readPath(e8) {
        switch (e8.type) {
          case "!":
            return this._readForwardPath;
          case "^":
            return this._readBackwardPath;
          default:
            const t2 = this._contextStack, r2 = t2.length && t2[t2.length - 1];
            if (r2 && "item" === r2.type) {
              const t3 = this._subject;
              this._restoreContext("item", e8), this._emit(this._subject, this.RDF_FIRST, t3, this._graph);
            }
            return this._afterPath(e8);
        }
      }
      _readForwardPath(e8) {
        let t2, r2;
        const n5 = this._blankNode();
        if (void 0 !== (r2 = this._readEntity(e8)))
          return null === this._predicate ? (t2 = this._subject, this._subject = n5) : (t2 = this._object, this._object = n5), this._emit(t2, r2, n5, this._graph), this._readPath;
      }
      _readBackwardPath(e8) {
        const t2 = this._blankNode();
        let r2, n5;
        if (void 0 !== (r2 = this._readEntity(e8)))
          return null === this._predicate ? (n5 = this._subject, this._subject = t2) : (n5 = this._object, this._object = t2), this._emit(t2, r2, n5, this._graph), this._readPath;
      }
      _readRDFStarTailOrGraph(e8) {
        return ">>" !== e8.type ? this._supportsQuads && null === this._graph && void 0 !== (this._graph = this._readEntity(e8)) ? this._readRDFStarTail : this._error(`Expected >> to follow "${this._object.id}"`, e8) : this._readRDFStarTail(e8);
      }
      _readRDFStarTail(e8) {
        if (">>" !== e8.type)
          return this._error(`Expected >> but got ${e8.type}`, e8);
        const t2 = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);
        return this._restoreContext("<<", e8), null === this._subject ? (this._subject = t2, this._readPredicate) : (this._object = t2, this._getContextEndReader());
      }
      _getContextEndReader() {
        const e8 = this._contextStack;
        if (!e8.length)
          return this._readPunctuation;
        switch (e8[e8.length - 1].type) {
          case "blank":
            return this._readBlankNodeTail;
          case "list":
            return this._readListItem;
          case "formula":
            return this._readFormulaTail;
          case "<<":
            return this._readRDFStarTailOrGraph;
        }
      }
      _emit(e8, t2, r2, n5) {
        this._callback(null, this._quad(e8, t2, r2, n5 || this.DEFAULTGRAPH));
      }
      _error(e8, t2) {
        const r2 = new Error(`${e8} on line ${t2.line}.`);
        r2.context = { token: t2, line: t2.line, previousToken: this._lexer.previousToken }, this._callback(r2), this._callback = u4;
      }
      _resolveIRI(e8) {
        return /^[a-z][a-z0-9+.-]*:/i.test(e8) ? e8 : this._resolveRelativeIRI(e8);
      }
      _resolveRelativeIRI(e8) {
        if (!e8.length)
          return this._base;
        switch (e8[0]) {
          case "#":
            return this._base + e8;
          case "?":
            return this._base.replace(/(?:\?.*)?$/, e8);
          case "/":
            return ("/" === e8[1] ? this._baseScheme : this._baseRoot) + this._removeDotSegments(e8);
          default:
            return /^[^/:]*:/.test(e8) ? null : this._removeDotSegments(this._basePath + e8);
        }
      }
      _removeDotSegments(e8) {
        if (!/(^|\/)\.\.?($|[/#?])/.test(e8))
          return e8;
        const t2 = e8.length;
        let r2 = "", n5 = -1, i5 = -1, o5 = 0, a5 = "/";
        for (; n5 < t2; ) {
          switch (a5) {
            case ":":
              if (i5 < 0 && "/" === e8[++n5] && "/" === e8[++n5])
                for (; (i5 = n5 + 1) < t2 && "/" !== e8[i5]; )
                  n5 = i5;
              break;
            case "?":
            case "#":
              n5 = t2;
              break;
            case "/":
              if ("." === e8[n5 + 1])
                switch (a5 = e8[1 + ++n5], a5) {
                  case "/":
                    r2 += e8.substring(o5, n5 - 1), o5 = n5 + 1;
                    break;
                  case void 0:
                  case "?":
                  case "#":
                    return r2 + e8.substring(o5, n5) + e8.substr(n5 + 1);
                  case ".":
                    if (a5 = e8[1 + ++n5], void 0 === a5 || "/" === a5 || "?" === a5 || "#" === a5) {
                      if (r2 += e8.substring(o5, n5 - 2), (o5 = r2.lastIndexOf("/")) >= i5 && (r2 = r2.substr(0, o5)), "/" !== a5)
                        return `${r2}/${e8.substr(n5 + 1)}`;
                      o5 = n5 + 1;
                    }
                }
          }
          a5 = e8[++n5];
        }
        return r2 + e8.substring(o5);
      }
      parse(e8, t2, r2) {
        if (this._readCallback = this._readInTopContext, this._sparqlStyle = false, this._prefixes = /* @__PURE__ */ Object.create(null), this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${s3++}_`, this._prefixCallback = r2 || u4, this._inversePredicate = false, this._quantified = /* @__PURE__ */ Object.create(null), !t2) {
          const t3 = [];
          let r3;
          if (this._callback = (e9, n5) => {
            e9 ? r3 = e9 : n5 && t3.push(n5);
          }, this._lexer.tokenize(e8).every((e9) => this._readCallback = this._readCallback(e9)), r3)
            throw r3;
          return t3;
        }
        this._callback = t2, this._lexer.tokenize(e8, (e9, t3) => {
          null !== e9 ? (this._callback(e9), this._callback = u4) : this._readCallback && (this._readCallback = this._readCallback(t3));
        });
      }
    }
    function u4() {
    }
    function c3(e8, t2) {
      const r2 = t2.namedNode;
      e8._namedNode = r2, e8._blankNode = t2.blankNode, e8._literal = t2.literal, e8._variable = t2.variable, e8._quad = t2.quad, e8.DEFAULTGRAPH = t2.defaultGraph(), e8.RDF_FIRST = r2(o4.default.rdf.first), e8.RDF_REST = r2(o4.default.rdf.rest), e8.RDF_NIL = r2(o4.default.rdf.nil), e8.N3_FORALL = r2(o4.default.r.forAll), e8.N3_FORSOME = r2(o4.default.r.forSome), e8.ABBREVIATIONS = { a: r2(o4.default.rdf.type), "=": r2(o4.default.owl.sameAs), ">": r2(o4.default.log.implies) }, e8.QUANTIFIERS_GRAPH = r2("urn:n3:quantifiers");
    }
    r.default = l6, c3(l6.prototype, i4.default);
  }, { "./IRIs": 1, "./N3DataFactory": 2, "./N3Lexer": 3 }], 5: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    var n4 = e7("readable-stream"), i4 = u4(e7("./N3DataFactory")), o4 = s3(e7("./IRIs")), a4 = e7("./N3Util");
    function s3(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    function l6(e8) {
      if ("function" != typeof WeakMap)
        return null;
      var t2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (l6 = function(e9) {
        return e9 ? r2 : t2;
      })(e8);
    }
    function u4(e8, t2) {
      if (!t2 && e8 && e8.__esModule)
        return e8;
      if (null === e8 || "object" != typeof e8 && "function" != typeof e8)
        return { default: e8 };
      var r2 = l6(t2);
      if (r2 && r2.has(e8))
        return r2.get(e8);
      var n5 = { __proto__: null }, i5 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o5 in e8)
        if ("default" !== o5 && Object.prototype.hasOwnProperty.call(e8, o5)) {
          var a5 = i5 ? Object.getOwnPropertyDescriptor(e8, o5) : null;
          a5 && (a5.get || a5.set) ? Object.defineProperty(n5, o5, a5) : n5[o5] = e8[o5];
        }
      return n5.default = e8, r2 && r2.set(e8, n5), n5;
    }
    class c3 {
      constructor(e8, t2) {
        this._size = 0, this._graphs = /* @__PURE__ */ Object.create(null), this._id = 0, this._ids = /* @__PURE__ */ Object.create(null), this._entities = /* @__PURE__ */ Object.create(null), this._blankNodeIndex = 0, t2 || !e8 || e8[0] || (t2 = e8, e8 = null), t2 = t2 || {}, this._factory = t2.factory || i4.default, e8 && this.addQuads(e8);
      }
      _termFromId(e8, t2) {
        if ("." === e8[0]) {
          const t3 = this._entities, r2 = e8.split(".");
          return this._factory.quad(this._termFromId(t3[r2[1]]), this._termFromId(t3[r2[2]]), this._termFromId(t3[r2[3]]), r2[4] && this._termFromId(t3[r2[4]]));
        }
        return (0, i4.termFromId)(e8, t2);
      }
      _termToNumericId(e8) {
        if ("Quad" === e8.termType) {
          const t2 = this._termToNumericId(e8.subject), r2 = this._termToNumericId(e8.predicate), n5 = this._termToNumericId(e8.object);
          let i5;
          return t2 && r2 && n5 && ((0, a4.isDefaultGraph)(e8.graph) || (i5 = this._termToNumericId(e8.graph))) && this._ids[i5 ? `.${t2}.${r2}.${n5}.${i5}` : `.${t2}.${r2}.${n5}`];
        }
        return this._ids[(0, i4.termToId)(e8)];
      }
      _termToNewNumericId(e8) {
        const t2 = e8 && "Quad" === e8.termType ? `.${this._termToNewNumericId(e8.subject)}.${this._termToNewNumericId(e8.predicate)}.${this._termToNewNumericId(e8.object)}${(0, a4.isDefaultGraph)(e8.graph) ? "" : `.${this._termToNewNumericId(e8.graph)}`}` : (0, i4.termToId)(e8);
        return this._ids[t2] || (this._ids[this._entities[++this._id] = t2] = this._id);
      }
      get size() {
        let e8 = this._size;
        if (null !== e8)
          return e8;
        e8 = 0;
        const t2 = this._graphs;
        let r2, n5;
        for (const i5 in t2)
          for (const o5 in r2 = t2[i5].subjects)
            for (const t3 in n5 = r2[o5])
              e8 += Object.keys(n5[t3]).length;
        return this._size = e8;
      }
      _addToIndex(e8, t2, r2, n5) {
        const i5 = e8[t2] || (e8[t2] = {}), o5 = i5[r2] || (i5[r2] = {}), a5 = n5 in o5;
        return a5 || (o5[n5] = null), !a5;
      }
      _removeFromIndex(e8, t2, r2, n5) {
        const i5 = e8[t2], o5 = i5[r2];
        delete o5[n5];
        for (const e9 in o5)
          return;
        delete i5[r2];
        for (const e9 in i5)
          return;
        delete e8[t2];
      }
      *_findInIndex(e8, t2, r2, n5, i5, o5, a5, s4) {
        let l7, u5, c4;
        const d6 = this._entities, h7 = this._termFromId(s4, this._factory), f5 = { subject: null, predicate: null, object: null };
        t2 && ((l7 = e8, e8 = {})[t2] = l7[t2]);
        for (const t3 in e8)
          if (u5 = e8[t3]) {
            f5[i5] = this._termFromId(d6[t3], this._factory), r2 && ((l7 = u5, u5 = {})[r2] = l7[r2]);
            for (const e9 in u5)
              if (c4 = u5[e9]) {
                f5[o5] = this._termFromId(d6[e9], this._factory);
                const t4 = n5 ? n5 in c4 ? [n5] : [] : Object.keys(c4);
                for (let e10 = 0; e10 < t4.length; e10++)
                  f5[a5] = this._termFromId(d6[t4[e10]], this._factory), yield this._factory.quad(f5.subject, f5.predicate, f5.object, h7);
              }
          }
      }
      _loop(e8, t2) {
        for (const r2 in e8)
          t2(r2);
      }
      _loopByKey0(e8, t2, r2) {
        let n5, i5;
        if (n5 = e8[t2])
          for (i5 in n5)
            r2(i5);
      }
      _loopByKey1(e8, t2, r2) {
        let n5, i5;
        for (n5 in e8)
          i5 = e8[n5], i5[t2] && r2(n5);
      }
      _loopBy2Keys(e8, t2, r2, n5) {
        let i5, o5, a5;
        if ((i5 = e8[t2]) && (o5 = i5[r2]))
          for (a5 in o5)
            n5(a5);
      }
      _countInIndex(e8, t2, r2, n5) {
        let i5, o5, a5, s4 = 0;
        t2 && ((i5 = e8, e8 = {})[t2] = i5[t2]);
        for (const t3 in e8)
          if (o5 = e8[t3]) {
            r2 && ((i5 = o5, o5 = {})[r2] = i5[r2]);
            for (const e9 in o5)
              (a5 = o5[e9]) && (n5 ? n5 in a5 && s4++ : s4 += Object.keys(a5).length);
          }
        return s4;
      }
      _getGraphs(e8) {
        if (!d5(e8))
          return this._graphs;
        const t2 = {};
        return t2[e8] = this._graphs[e8], t2;
      }
      _uniqueEntities(e8) {
        const t2 = /* @__PURE__ */ Object.create(null);
        return (r2) => {
          r2 in t2 || (t2[r2] = true, e8(this._termFromId(this._entities[r2], this._factory)));
        };
      }
      add(e8) {
        return this.addQuad(e8), this;
      }
      addQuad(e8, t2, r2, n5) {
        t2 || (n5 = e8.graph, r2 = e8.object, t2 = e8.predicate, e8 = e8.subject), n5 = (0, i4.termToId)(n5);
        let o5 = this._graphs[n5];
        o5 || (o5 = this._graphs[n5] = { subjects: {}, predicates: {}, objects: {} }, Object.freeze(o5)), e8 = this._termToNewNumericId(e8), t2 = this._termToNewNumericId(t2), r2 = this._termToNewNumericId(r2);
        const a5 = this._addToIndex(o5.subjects, e8, t2, r2);
        return this._addToIndex(o5.predicates, t2, r2, e8), this._addToIndex(o5.objects, r2, e8, t2), this._size = null, a5;
      }
      addQuads(e8) {
        for (let t2 = 0; t2 < e8.length; t2++)
          this.addQuad(e8[t2]);
      }
      delete(e8) {
        return this.removeQuad(e8), this;
      }
      has(e8, t2, r2, n5) {
        return e8 && e8.subject && ({ subject: e8, predicate: t2, object: r2, graph: n5 } = e8), !this.readQuads(e8, t2, r2, n5).next().done;
      }
      importStream(e8) {
        return e8.on("data", (e9) => {
          this.addQuad(e9);
        }), e8;
      }
      removeQuad(e8, t2, r2, n5) {
        t2 || (n5 = e8.graph, r2 = e8.object, t2 = e8.predicate, e8 = e8.subject), n5 = (0, i4.termToId)(n5);
        const o5 = this._graphs;
        let a5, s4, l7;
        if (!((e8 = e8 && this._termToNumericId(e8)) && (t2 = t2 && this._termToNumericId(t2)) && (r2 = r2 && this._termToNumericId(r2)) && (a5 = o5[n5]) && (s4 = a5.subjects[e8]) && (l7 = s4[t2]) && r2 in l7))
          return false;
        for (e8 in this._removeFromIndex(a5.subjects, e8, t2, r2), this._removeFromIndex(a5.predicates, t2, r2, e8), this._removeFromIndex(a5.objects, r2, e8, t2), null !== this._size && this._size--, a5.subjects)
          return true;
        return delete o5[n5], true;
      }
      removeQuads(e8) {
        for (let t2 = 0; t2 < e8.length; t2++)
          this.removeQuad(e8[t2]);
      }
      remove(e8) {
        return e8.on("data", (e9) => {
          this.removeQuad(e9);
        }), e8;
      }
      removeMatches(e8, t2, r2, i5) {
        const o5 = new n4.Readable({ objectMode: true });
        return o5._read = () => {
          for (const n5 of this.readQuads(e8, t2, r2, i5))
            o5.push(n5);
          o5.push(null);
        }, this.remove(o5);
      }
      deleteGraph(e8) {
        return this.removeMatches(null, null, null, e8);
      }
      getQuads(e8, t2, r2, n5) {
        return [...this.readQuads(e8, t2, r2, n5)];
      }
      *readQuads(e8, t2, r2, n5) {
        n5 = n5 && (0, i4.termToId)(n5);
        const o5 = this._getGraphs(n5);
        let a5, s4, l7, u5;
        if (!(e8 && !(s4 = this._termToNumericId(e8)) || t2 && !(l7 = this._termToNumericId(t2)) || r2 && !(u5 = this._termToNumericId(r2))))
          for (const e9 in o5)
            (a5 = o5[e9]) && (s4 ? u5 ? yield* this._findInIndex(a5.objects, u5, s4, l7, "object", "subject", "predicate", e9) : yield* this._findInIndex(a5.subjects, s4, l7, null, "subject", "predicate", "object", e9) : l7 ? yield* this._findInIndex(a5.predicates, l7, u5, null, "predicate", "object", "subject", e9) : u5 ? yield* this._findInIndex(a5.objects, u5, null, null, "object", "subject", "predicate", e9) : yield* this._findInIndex(a5.subjects, null, null, null, "subject", "predicate", "object", e9));
      }
      match(e8, t2, r2, n5) {
        return new h6(this, e8, t2, r2, n5);
      }
      countQuads(e8, t2, r2, n5) {
        n5 = n5 && (0, i4.termToId)(n5);
        const o5 = this._getGraphs(n5);
        let a5, s4, l7, u5, c4 = 0;
        if (e8 && !(s4 = this._termToNumericId(e8)) || t2 && !(l7 = this._termToNumericId(t2)) || r2 && !(u5 = this._termToNumericId(r2)))
          return 0;
        for (const n6 in o5)
          (a5 = o5[n6]) && (c4 += e8 ? r2 ? this._countInIndex(a5.objects, u5, s4, l7) : this._countInIndex(a5.subjects, s4, l7, u5) : t2 ? this._countInIndex(a5.predicates, l7, u5, s4) : this._countInIndex(a5.objects, u5, s4, l7));
        return c4;
      }
      forEach(e8, t2, r2, n5, i5) {
        this.some((t3) => (e8(t3), false), t2, r2, n5, i5);
      }
      every(e8, t2, r2, n5, i5) {
        let o5 = false;
        const a5 = !this.some((t3) => (o5 = true, !e8(t3)), t2, r2, n5, i5);
        return o5 && a5;
      }
      some(e8, t2, r2, n5, i5) {
        for (const o5 of this.readQuads(t2, r2, n5, i5))
          if (e8(o5))
            return true;
        return false;
      }
      getSubjects(e8, t2, r2) {
        const n5 = [];
        return this.forSubjects((e9) => {
          n5.push(e9);
        }, e8, t2, r2), n5;
      }
      forSubjects(e8, t2, r2, n5) {
        n5 = n5 && (0, i4.termToId)(n5);
        const o5 = this._getGraphs(n5);
        let a5, s4, l7;
        if (e8 = this._uniqueEntities(e8), !(t2 && !(s4 = this._termToNumericId(t2)) || r2 && !(l7 = this._termToNumericId(r2))))
          for (n5 in o5)
            (a5 = o5[n5]) && (s4 ? l7 ? this._loopBy2Keys(a5.predicates, s4, l7, e8) : this._loopByKey1(a5.subjects, s4, e8) : l7 ? this._loopByKey0(a5.objects, l7, e8) : this._loop(a5.subjects, e8));
      }
      getPredicates(e8, t2, r2) {
        const n5 = [];
        return this.forPredicates((e9) => {
          n5.push(e9);
        }, e8, t2, r2), n5;
      }
      forPredicates(e8, t2, r2, n5) {
        n5 = n5 && (0, i4.termToId)(n5);
        const o5 = this._getGraphs(n5);
        let a5, s4, l7;
        if (e8 = this._uniqueEntities(e8), !(t2 && !(s4 = this._termToNumericId(t2)) || r2 && !(l7 = this._termToNumericId(r2))))
          for (n5 in o5)
            (a5 = o5[n5]) && (s4 ? l7 ? this._loopBy2Keys(a5.objects, l7, s4, e8) : this._loopByKey0(a5.subjects, s4, e8) : l7 ? this._loopByKey1(a5.predicates, l7, e8) : this._loop(a5.predicates, e8));
      }
      getObjects(e8, t2, r2) {
        const n5 = [];
        return this.forObjects((e9) => {
          n5.push(e9);
        }, e8, t2, r2), n5;
      }
      forObjects(e8, t2, r2, n5) {
        n5 = n5 && (0, i4.termToId)(n5);
        const o5 = this._getGraphs(n5);
        let a5, s4, l7;
        if (e8 = this._uniqueEntities(e8), !(t2 && !(s4 = this._termToNumericId(t2)) || r2 && !(l7 = this._termToNumericId(r2))))
          for (n5 in o5)
            (a5 = o5[n5]) && (s4 ? l7 ? this._loopBy2Keys(a5.subjects, s4, l7, e8) : this._loopByKey1(a5.objects, s4, e8) : l7 ? this._loopByKey0(a5.predicates, l7, e8) : this._loop(a5.objects, e8));
      }
      getGraphs(e8, t2, r2) {
        const n5 = [];
        return this.forGraphs((e9) => {
          n5.push(e9);
        }, e8, t2, r2), n5;
      }
      forGraphs(e8, t2, r2, n5) {
        for (const i5 in this._graphs)
          this.some((t3) => (e8(t3.graph), true), t2, r2, n5, i5);
      }
      createBlankNode(e8) {
        let t2, r2;
        if (e8)
          for (t2 = e8 = `_:${e8}`, r2 = 1; this._ids[t2]; )
            t2 = e8 + r2++;
        else
          do {
            t2 = "_:b" + this._blankNodeIndex++;
          } while (this._ids[t2]);
        return this._ids[t2] = ++this._id, this._entities[this._id] = t2, this._factory.blankNode(t2.substr(2));
      }
      extractLists({ remove: e8 = false, ignoreErrors: t2 = false } = {}) {
        const r2 = {}, n5 = t2 ? () => true : (e9, t3) => {
          throw new Error(`${e9.value} ${t3}`);
        }, i5 = this.getQuads(null, o4.default.rdf.rest, o4.default.rdf.nil, null), a5 = e8 ? [...i5] : [];
        return i5.forEach((t3) => {
          const i6 = [];
          let s4, l7, u5 = false;
          const c4 = t3.graph;
          let d6 = t3.subject;
          for (; d6 && !u5; ) {
            const e9 = this.getQuads(null, null, d6, null), t4 = this.getQuads(d6, null, null, null);
            let r3, h7 = null, f5 = null, p6 = null;
            for (let i7 = 0; i7 < t4.length && !u5; i7++)
              r3 = t4[i7], r3.graph.equals(c4) ? s4 ? u5 = n5(d6, "has non-list arcs out") : r3.predicate.value === o4.default.rdf.first ? h7 ? u5 = n5(d6, "has multiple rdf:first arcs") : a5.push(h7 = r3) : r3.predicate.value === o4.default.rdf.rest ? f5 ? u5 = n5(d6, "has multiple rdf:rest arcs") : a5.push(f5 = r3) : e9.length ? u5 = n5(d6, "can't be subject and object") : (s4 = r3, l7 = "subject") : u5 = n5(d6, "not confined to single graph");
            for (let t5 = 0; t5 < e9.length && !u5; ++t5)
              r3 = e9[t5], s4 ? u5 = n5(d6, "can't have coreferences") : r3.predicate.value === o4.default.rdf.rest ? p6 ? u5 = n5(d6, "has incoming rdf:rest arcs") : p6 = r3 : (s4 = r3, l7 = "object");
            h7 ? i6.unshift(h7.object) : u5 = n5(d6, "has no list head"), d6 = p6 && p6.subject;
          }
          u5 ? e8 = false : s4 && (r2[s4[l7].value] = i6);
        }), e8 && this.removeQuads(a5), r2;
      }
      *[Symbol.iterator]() {
        yield* this.readQuads();
      }
    }
    function d5(e8) {
      return "string" == typeof e8 || e8 instanceof String;
    }
    r.default = c3;
    class h6 extends n4.Readable {
      constructor(e8, t2, r2, n5, i5) {
        super({ objectMode: true }), Object.assign(this, { n3Store: e8, subject: t2, predicate: r2, object: n5, graph: i5 });
      }
      get filtered() {
        if (!this._filtered) {
          const { n3Store: e8, graph: t2, object: r2, predicate: n5, subject: i5 } = this, o5 = this._filtered = new c3({ factory: e8._factory });
          for (const a5 of e8.readQuads(i5, n5, r2, t2))
            o5.addQuad(a5);
        }
        return this._filtered;
      }
      get size() {
        return this.filtered.size;
      }
      _read() {
        for (const e8 of this)
          this.push(e8);
        this.push(null);
      }
      add(e8) {
        return this.filtered.add(e8);
      }
      delete(e8) {
        return this.filtered.delete(e8);
      }
      has(e8) {
        return this.filtered.has(e8);
      }
      match(e8, t2, r2, n5) {
        return new h6(this.filtered, e8, t2, r2, n5);
      }
      *[Symbol.iterator]() {
        yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);
      }
    }
  }, { "./IRIs": 1, "./N3DataFactory": 2, "./N3Util": 8, "readable-stream": 38 }], 6: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    var n4 = e7("readable-stream"), i4 = o4(e7("./N3Parser"));
    function o4(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    class a4 extends n4.Transform {
      constructor(e8) {
        let t2, r2;
        super({ decodeStrings: true }), this._readableState.objectMode = true, new i4.default(e8).parse({ on: (e9, n5) => {
          switch (e9) {
            case "data":
              t2 = n5;
              break;
            case "end":
              r2 = n5;
          }
        } }, (e9, t3) => {
          e9 && this.emit("error", e9) || t3 && this.push(t3);
        }, (e9, t3) => {
          this.emit("prefix", e9, t3);
        }), this._transform = (e9, r3, n5) => {
          t2(e9), n5();
        }, this._flush = (e9) => {
          r2(), e9();
        };
      }
      importStream(e8) {
        return e8.on("data", (e9) => {
          this.write(e9);
        }), e8.on("end", () => {
          this.end();
        }), e8.on("error", (e9) => {
          this.emit("error", e9);
        }), this;
      }
    }
    r.default = a4;
  }, { "./N3Parser": 4, "readable-stream": 38 }], 7: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    var n4 = e7("readable-stream"), i4 = o4(e7("./N3Writer"));
    function o4(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    class a4 extends n4.Transform {
      constructor(e8) {
        super({ encoding: "utf8", writableObjectMode: true });
        const t2 = this._writer = new i4.default({ write: (e9, t3, r2) => {
          this.push(e9), r2 && r2();
        }, end: (e9) => {
          this.push(null), e9 && e9();
        } }, e8);
        this._transform = (e9, r2, n5) => {
          t2.addQuad(e9, n5);
        }, this._flush = (e9) => {
          t2.end(e9);
        };
      }
      importStream(e8) {
        return e8.on("data", (e9) => {
          this.write(e9);
        }), e8.on("end", () => {
          this.end();
        }), e8.on("error", (e9) => {
          this.emit("error", e9);
        }), e8.on("prefix", (e9, t2) => {
          this._writer.addPrefix(e9, t2);
        }), this;
      }
    }
    r.default = a4;
  }, { "./N3Writer": 9, "readable-stream": 38 }], 8: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.inDefaultGraph = c3, r.isBlankNode = a4, r.isDefaultGraph = u4, r.isLiteral = s3, r.isNamedNode = o4, r.isVariable = l6, r.prefix = d5, r.prefixes = h6;
    var n4 = i4(e7("./N3DataFactory"));
    function i4(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    function o4(e8) {
      return !!e8 && "NamedNode" === e8.termType;
    }
    function a4(e8) {
      return !!e8 && "BlankNode" === e8.termType;
    }
    function s3(e8) {
      return !!e8 && "Literal" === e8.termType;
    }
    function l6(e8) {
      return !!e8 && "Variable" === e8.termType;
    }
    function u4(e8) {
      return !!e8 && "DefaultGraph" === e8.termType;
    }
    function c3(e8) {
      return u4(e8.graph);
    }
    function d5(e8, t2) {
      return h6({ "": e8.value || e8 }, t2)("");
    }
    function h6(e8, t2) {
      const r2 = /* @__PURE__ */ Object.create(null);
      for (const t3 in e8)
        i5(t3, e8[t3]);
      function i5(e9, n5) {
        if ("string" == typeof n5) {
          const i6 = /* @__PURE__ */ Object.create(null);
          r2[e9] = (e10) => i6[e10] || (i6[e10] = t2.namedNode(n5 + e10));
        } else if (!(e9 in r2))
          throw new Error(`Unknown prefix: ${e9}`);
        return r2[e9];
      }
      return t2 = t2 || n4.default, i5;
    }
  }, { "./N3DataFactory": 2 }], 9: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.default = void 0;
    var n4 = l6(e7("./IRIs")), i4 = s3(e7("./N3DataFactory")), o4 = e7("./N3Util");
    function a4(e8) {
      if ("function" != typeof WeakMap)
        return null;
      var t2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (a4 = function(e9) {
        return e9 ? r2 : t2;
      })(e8);
    }
    function s3(e8, t2) {
      if (!t2 && e8 && e8.__esModule)
        return e8;
      if (null === e8 || "object" != typeof e8 && "function" != typeof e8)
        return { default: e8 };
      var r2 = a4(t2);
      if (r2 && r2.has(e8))
        return r2.get(e8);
      var n5 = { __proto__: null }, i5 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o5 in e8)
        if ("default" !== o5 && Object.prototype.hasOwnProperty.call(e8, o5)) {
          var s4 = i5 ? Object.getOwnPropertyDescriptor(e8, o5) : null;
          s4 && (s4.get || s4.set) ? Object.defineProperty(n5, o5, s4) : n5[o5] = e8[o5];
        }
      return n5.default = e8, r2 && r2.set(e8, n5), n5;
    }
    function l6(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    const u4 = i4.default.defaultGraph(), { rdf: c3, xsd: d5 } = n4.default, h6 = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/, f5 = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g, p6 = { "\\": "\\\\", '"': '\\"', "	": "\\t", "\n": "\\n", "\r": "\\r", "\b": "\\b", "\f": "\\f" };
    class m5 extends i4.Term {
      equals(e8) {
        return e8 === this;
      }
    }
    class y5 {
      constructor(e8, t2) {
        if (this._prefixRegex = /$0^/, e8 && "function" != typeof e8.write && (t2 = e8, e8 = null), t2 = t2 || {}, this._lists = t2.lists, e8)
          this._outputStream = e8, this._endStream = void 0 === t2.end || !!t2.end;
        else {
          let e9 = "";
          this._outputStream = { write(t3, r2, n5) {
            e9 += t3, n5 && n5();
          }, end: (t3) => {
            t3 && t3(null, e9);
          } }, this._endStream = true;
        }
        this._subject = null, /triple|quad/i.test(t2.format) ? (this._lineMode = true, this._writeQuad = this._writeQuadLine) : (this._lineMode = false, this._graph = u4, this._prefixIRIs = /* @__PURE__ */ Object.create(null), t2.prefixes && this.addPrefixes(t2.prefixes), t2.baseIRI && (this._baseMatcher = new RegExp(`^${v6(t2.baseIRI)}${t2.baseIRI.endsWith("/") ? "" : "[#?]"}`), this._baseLength = t2.baseIRI.length));
      }
      get _inDefaultGraph() {
        return u4.equals(this._graph);
      }
      _write(e8, t2) {
        this._outputStream.write(e8, "utf8", t2);
      }
      _writeQuad(e8, t2, r2, n5, i5) {
        try {
          n5.equals(this._graph) || (this._write((null === this._subject ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") + (u4.equals(n5) ? "" : `${this._encodeIriOrBlank(n5)} {
`)), this._graph = n5, this._subject = null), e8.equals(this._subject) ? t2.equals(this._predicate) ? this._write(`, ${this._encodeObject(r2)}`, i5) : this._write(`;
    ${this._encodePredicate(this._predicate = t2)} ${this._encodeObject(r2)}`, i5) : this._write(`${(null === this._subject ? "" : ".\n") + this._encodeSubject(this._subject = e8)} ${this._encodePredicate(this._predicate = t2)} ${this._encodeObject(r2)}`, i5);
        } catch (e9) {
          i5 && i5(e9);
        }
      }
      _writeQuadLine(e8, t2, r2, n5, i5) {
        delete this._prefixMatch, this._write(this.quadToString(e8, t2, r2, n5), i5);
      }
      quadToString(e8, t2, r2, n5) {
        return `${this._encodeSubject(e8)} ${this._encodeIriOrBlank(t2)} ${this._encodeObject(r2)}${n5 && n5.value ? ` ${this._encodeIriOrBlank(n5)} .
` : " .\n"}`;
      }
      quadsToString(e8) {
        return e8.map((e9) => this.quadToString(e9.subject, e9.predicate, e9.object, e9.graph)).join("");
      }
      _encodeSubject(e8) {
        return "Quad" === e8.termType ? this._encodeQuad(e8) : this._encodeIriOrBlank(e8);
      }
      _encodeIriOrBlank(e8) {
        if ("NamedNode" !== e8.termType)
          return this._lists && e8.value in this._lists && (e8 = this.list(this._lists[e8.value])), "id" in e8 ? e8.id : `_:${e8.value}`;
        let t2 = e8.value;
        this._baseMatcher && this._baseMatcher.test(t2) && (t2 = t2.substr(this._baseLength)), h6.test(t2) && (t2 = t2.replace(f5, g5));
        const r2 = this._prefixRegex.exec(t2);
        return r2 ? r2[1] ? this._prefixIRIs[r2[1]] + r2[2] : t2 : `<${t2}>`;
      }
      _encodeLiteral(e8) {
        let t2 = e8.value;
        if (h6.test(t2) && (t2 = t2.replace(f5, g5)), e8.language)
          return `"${t2}"@${e8.language}`;
        if (this._lineMode) {
          if (e8.datatype.value === d5.string)
            return `"${t2}"`;
        } else
          switch (e8.datatype.value) {
            case d5.string:
              return `"${t2}"`;
            case d5.boolean:
              if ("true" === t2 || "false" === t2)
                return t2;
              break;
            case d5.integer:
              if (/^[+-]?\d+$/.test(t2))
                return t2;
              break;
            case d5.decimal:
              if (/^[+-]?\d*\.\d+$/.test(t2))
                return t2;
              break;
            case d5.double:
              if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(t2))
                return t2;
          }
        return `"${t2}"^^${this._encodeIriOrBlank(e8.datatype)}`;
      }
      _encodePredicate(e8) {
        return e8.value === c3.type ? "a" : this._encodeIriOrBlank(e8);
      }
      _encodeObject(e8) {
        switch (e8.termType) {
          case "Quad":
            return this._encodeQuad(e8);
          case "Literal":
            return this._encodeLiteral(e8);
          default:
            return this._encodeIriOrBlank(e8);
        }
      }
      _encodeQuad({ subject: e8, predicate: t2, object: r2, graph: n5 }) {
        return `<<${this._encodeSubject(e8)} ${this._encodePredicate(t2)} ${this._encodeObject(r2)}${(0, o4.isDefaultGraph)(n5) ? "" : ` ${this._encodeIriOrBlank(n5)}`}>>`;
      }
      _blockedWrite() {
        throw new Error("Cannot write because the writer has been closed.");
      }
      addQuad(e8, t2, r2, n5, i5) {
        void 0 === r2 ? this._writeQuad(e8.subject, e8.predicate, e8.object, e8.graph, t2) : "function" == typeof n5 ? this._writeQuad(e8, t2, r2, u4, n5) : this._writeQuad(e8, t2, r2, n5 || u4, i5);
      }
      addQuads(e8) {
        for (let t2 = 0; t2 < e8.length; t2++)
          this.addQuad(e8[t2]);
      }
      addPrefix(e8, t2, r2) {
        const n5 = {};
        n5[e8] = t2, this.addPrefixes(n5, r2);
      }
      addPrefixes(e8, t2) {
        if (!this._prefixIRIs)
          return t2 && t2();
        let r2 = false;
        for (let t3 in e8) {
          let n5 = e8[t3];
          "string" != typeof n5 && (n5 = n5.value), r2 = true, null !== this._subject && (this._write(this._inDefaultGraph ? ".\n" : "\n}\n"), this._subject = null, this._graph = ""), this._prefixIRIs[n5] = t3 += ":", this._write(`@prefix ${t3} <${n5}>.
`);
        }
        if (r2) {
          let e9 = "", t3 = "";
          for (const r3 in this._prefixIRIs)
            e9 += e9 ? `|${r3}` : r3, t3 += (t3 ? "|" : "") + this._prefixIRIs[r3];
          e9 = v6(e9), this._prefixRegex = new RegExp(`^(?:${t3})[^/]*$|^(${e9})([_a-zA-Z][\\-_a-zA-Z0-9]*)$`);
        }
        this._write(r2 ? "\n" : "", t2);
      }
      blank(e8, t2) {
        let r2, n5, i5 = e8;
        switch (void 0 === e8 ? i5 = [] : e8.termType ? i5 = [{ predicate: e8, object: t2 }] : "length" in e8 || (i5 = [e8]), n5 = i5.length) {
          case 0:
            return new m5("[]");
          case 1:
            if (r2 = i5[0], !(r2.object instanceof m5))
              return new m5(`[ ${this._encodePredicate(r2.predicate)} ${this._encodeObject(r2.object)} ]`);
          default:
            let t3 = "[";
            for (let o5 = 0; o5 < n5; o5++)
              r2 = i5[o5], r2.predicate.equals(e8) ? t3 += `, ${this._encodeObject(r2.object)}` : (t3 += `${(o5 ? ";\n  " : "\n  ") + this._encodePredicate(r2.predicate)} ${this._encodeObject(r2.object)}`, e8 = r2.predicate);
            return new m5(`${t3}
]`);
        }
      }
      list(e8) {
        const t2 = e8 && e8.length || 0, r2 = new Array(t2);
        for (let n5 = 0; n5 < t2; n5++)
          r2[n5] = this._encodeObject(e8[n5]);
        return new m5(`(${r2.join(" ")})`);
      }
      end(e8) {
        null !== this._subject && (this._write(this._inDefaultGraph ? ".\n" : "\n}\n"), this._subject = null), this._write = this._blockedWrite;
        let t2 = e8 && ((r2, n5) => {
          t2 = null, e8(r2, n5);
        });
        if (this._endStream)
          try {
            return this._outputStream.end(t2);
          } catch (e9) {
          }
        t2 && t2();
      }
    }
    function g5(e8) {
      let t2 = p6[e8];
      return void 0 === t2 && (1 === e8.length ? (t2 = e8.charCodeAt(0).toString(16), t2 = "\\u0000".substr(0, 6 - t2.length) + t2) : (t2 = (1024 * (e8.charCodeAt(0) - 55296) + e8.charCodeAt(1) + 9216).toString(16), t2 = "\\U00000000".substr(0, 10 - t2.length) + t2)), t2;
    }
    function v6(e8) {
      return e8.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
    }
    r.default = y5;
  }, { "./IRIs": 1, "./N3DataFactory": 2, "./N3Util": 8 }], 10: [function(e7, t, r) {
    Object.defineProperty(r, "__esModule", { value: true }), Object.defineProperty(r, "BlankNode", { enumerable: true, get: function() {
      return c3.BlankNode;
    } }), Object.defineProperty(r, "DataFactory", { enumerable: true, get: function() {
      return c3.default;
    } }), Object.defineProperty(r, "DefaultGraph", { enumerable: true, get: function() {
      return c3.DefaultGraph;
    } }), Object.defineProperty(r, "Lexer", { enumerable: true, get: function() {
      return n4.default;
    } }), Object.defineProperty(r, "Literal", { enumerable: true, get: function() {
      return c3.Literal;
    } }), Object.defineProperty(r, "NamedNode", { enumerable: true, get: function() {
      return c3.NamedNode;
    } }), Object.defineProperty(r, "Parser", { enumerable: true, get: function() {
      return i4.default;
    } }), Object.defineProperty(r, "Quad", { enumerable: true, get: function() {
      return c3.Quad;
    } }), Object.defineProperty(r, "Store", { enumerable: true, get: function() {
      return a4.default;
    } }), Object.defineProperty(r, "StreamParser", { enumerable: true, get: function() {
      return s3.default;
    } }), Object.defineProperty(r, "StreamWriter", { enumerable: true, get: function() {
      return l6.default;
    } }), Object.defineProperty(r, "Term", { enumerable: true, get: function() {
      return c3.Term;
    } }), Object.defineProperty(r, "Triple", { enumerable: true, get: function() {
      return c3.Triple;
    } }), r.Util = void 0, Object.defineProperty(r, "Variable", { enumerable: true, get: function() {
      return c3.Variable;
    } }), Object.defineProperty(r, "Writer", { enumerable: true, get: function() {
      return o4.default;
    } }), r.default = void 0, Object.defineProperty(r, "termFromId", { enumerable: true, get: function() {
      return c3.termFromId;
    } }), Object.defineProperty(r, "termToId", { enumerable: true, get: function() {
      return c3.termToId;
    } });
    var n4 = f5(e7("./N3Lexer")), i4 = f5(e7("./N3Parser")), o4 = f5(e7("./N3Writer")), a4 = f5(e7("./N3Store")), s3 = f5(e7("./N3StreamParser")), l6 = f5(e7("./N3StreamWriter")), u4 = h6(e7("./N3Util"));
    r.Util = u4;
    var c3 = h6(e7("./N3DataFactory"));
    function d5(e8) {
      if ("function" != typeof WeakMap)
        return null;
      var t2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
      return (d5 = function(e9) {
        return e9 ? r2 : t2;
      })(e8);
    }
    function h6(e8, t2) {
      if (!t2 && e8 && e8.__esModule)
        return e8;
      if (null === e8 || "object" != typeof e8 && "function" != typeof e8)
        return { default: e8 };
      var r2 = d5(t2);
      if (r2 && r2.has(e8))
        return r2.get(e8);
      var n5 = { __proto__: null }, i5 = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var o5 in e8)
        if ("default" !== o5 && Object.prototype.hasOwnProperty.call(e8, o5)) {
          var a5 = i5 ? Object.getOwnPropertyDescriptor(e8, o5) : null;
          a5 && (a5.get || a5.set) ? Object.defineProperty(n5, o5, a5) : n5[o5] = e8[o5];
        }
      return n5.default = e8, r2 && r2.set(e8, n5), n5;
    }
    function f5(e8) {
      return e8 && e8.__esModule ? e8 : { default: e8 };
    }
    r.default = { Lexer: n4.default, Parser: i4.default, Writer: o4.default, Store: a4.default, StreamParser: s3.default, StreamWriter: l6.default, Util: u4, DataFactory: c3.default, Term: c3.Term, NamedNode: c3.NamedNode, Literal: c3.Literal, BlankNode: c3.BlankNode, Variable: c3.Variable, DefaultGraph: c3.DefaultGraph, Quad: c3.Quad, Triple: c3.Triple, termFromId: c3.termFromId, termToId: c3.termToId };
  }, { "./N3DataFactory": 2, "./N3Lexer": 3, "./N3Parser": 4, "./N3Store": 5, "./N3StreamParser": 6, "./N3StreamWriter": 7, "./N3Util": 8, "./N3Writer": 9 }], 11: [function(e7, t, r) {
    const { AbortController: n4, AbortSignal: i4 } = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0;
    t.exports = n4, t.exports.AbortSignal = i4, t.exports.default = n4;
  }, {}], 12: [function(e7, t, r) {
    r.byteLength = c3, r.toByteArray = h6, r.fromByteArray = m5;
    for (var n4 = [], i4 = [], o4 = "undefined" != typeof Uint8Array ? Uint8Array : Array, a4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s3 = 0, l6 = a4.length; s3 < l6; ++s3)
      n4[s3] = a4[s3], i4[a4.charCodeAt(s3)] = s3;
    function u4(e8) {
      var t2 = e8.length;
      if (t2 % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r2 = e8.indexOf("=");
      return -1 === r2 && (r2 = t2), [r2, r2 === t2 ? 0 : 4 - r2 % 4];
    }
    function c3(e8) {
      var t2 = u4(e8), r2 = t2[0], n5 = t2[1];
      return 3 * (r2 + n5) / 4 - n5;
    }
    function d5(e8, t2, r2) {
      return 3 * (t2 + r2) / 4 - r2;
    }
    function h6(e8) {
      var t2, r2, n5 = u4(e8), a5 = n5[0], s4 = n5[1], l7 = new o4(d5(e8, a5, s4)), c4 = 0, h7 = s4 > 0 ? a5 - 4 : a5;
      for (r2 = 0; r2 < h7; r2 += 4)
        t2 = i4[e8.charCodeAt(r2)] << 18 | i4[e8.charCodeAt(r2 + 1)] << 12 | i4[e8.charCodeAt(r2 + 2)] << 6 | i4[e8.charCodeAt(r2 + 3)], l7[c4++] = t2 >> 16 & 255, l7[c4++] = t2 >> 8 & 255, l7[c4++] = 255 & t2;
      return 2 === s4 && (t2 = i4[e8.charCodeAt(r2)] << 2 | i4[e8.charCodeAt(r2 + 1)] >> 4, l7[c4++] = 255 & t2), 1 === s4 && (t2 = i4[e8.charCodeAt(r2)] << 10 | i4[e8.charCodeAt(r2 + 1)] << 4 | i4[e8.charCodeAt(r2 + 2)] >> 2, l7[c4++] = t2 >> 8 & 255, l7[c4++] = 255 & t2), l7;
    }
    function f5(e8) {
      return n4[e8 >> 18 & 63] + n4[e8 >> 12 & 63] + n4[e8 >> 6 & 63] + n4[63 & e8];
    }
    function p6(e8, t2, r2) {
      for (var n5, i5 = [], o5 = t2; o5 < r2; o5 += 3)
        n5 = (e8[o5] << 16 & 16711680) + (e8[o5 + 1] << 8 & 65280) + (255 & e8[o5 + 2]), i5.push(f5(n5));
      return i5.join("");
    }
    function m5(e8) {
      for (var t2, r2 = e8.length, i5 = r2 % 3, o5 = [], a5 = 16383, s4 = 0, l7 = r2 - i5; s4 < l7; s4 += a5)
        o5.push(p6(e8, s4, s4 + a5 > l7 ? l7 : s4 + a5));
      return 1 === i5 ? (t2 = e8[r2 - 1], o5.push(n4[t2 >> 2] + n4[t2 << 4 & 63] + "==")) : 2 === i5 && (t2 = (e8[r2 - 2] << 8) + e8[r2 - 1], o5.push(n4[t2 >> 10] + n4[t2 >> 4 & 63] + n4[t2 << 2 & 63] + "=")), o5.join("");
    }
    i4["-".charCodeAt(0)] = 62, i4["_".charCodeAt(0)] = 63;
  }, {}], 13: [function(e7, t, r) {
    var n4 = e7("buffer"), i4 = n4.Buffer;
    function o4(e8, t2) {
      for (var r2 in e8)
        t2[r2] = e8[r2];
    }
    function a4(e8, t2, r2) {
      return i4(e8, t2, r2);
    }
    i4.from && i4.alloc && i4.allocUnsafe && i4.allocUnsafeSlow ? t.exports = n4 : (o4(n4, r), r.Buffer = a4), o4(i4, a4), a4.from = function(e8, t2, r2) {
      if ("number" == typeof e8)
        throw new TypeError("Argument must not be a number");
      return i4(e8, t2, r2);
    }, a4.alloc = function(e8, t2, r2) {
      if ("number" != typeof e8)
        throw new TypeError("Argument must be a number");
      var n5 = i4(e8);
      return void 0 !== t2 ? "string" == typeof r2 ? n5.fill(t2, r2) : n5.fill(t2) : n5.fill(0), n5;
    }, a4.allocUnsafe = function(e8) {
      if ("number" != typeof e8)
        throw new TypeError("Argument must be a number");
      return i4(e8);
    }, a4.allocUnsafeSlow = function(e8) {
      if ("number" != typeof e8)
        throw new TypeError("Argument must be a number");
      return n4.SlowBuffer(e8);
    };
  }, { buffer: 15 }], 14: [function(e7, t, r) {
    var n4 = e7("safe-buffer").Buffer, i4 = n4.isEncoding || function(e8) {
      switch ((e8 = "" + e8) && e8.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function o4(e8) {
      if (!e8)
        return "utf8";
      for (var t2; ; )
        switch (e8) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e8;
          default:
            if (t2)
              return;
            e8 = ("" + e8).toLowerCase(), t2 = true;
        }
    }
    function a4(e8) {
      var t2 = o4(e8);
      if ("string" != typeof t2 && (n4.isEncoding === i4 || !i4(e8)))
        throw new Error("Unknown encoding: " + e8);
      return t2 || e8;
    }
    function s3(e8) {
      var t2;
      switch (this.encoding = a4(e8), this.encoding) {
        case "utf16le":
          this.text = p6, this.end = m5, t2 = 4;
          break;
        case "utf8":
          this.fillLast = d5, t2 = 4;
          break;
        case "base64":
          this.text = y5, this.end = g5, t2 = 3;
          break;
        default:
          return this.write = v6, void (this.end = w5);
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n4.allocUnsafe(t2);
    }
    function l6(e8) {
      return e8 <= 127 ? 0 : e8 >> 5 == 6 ? 2 : e8 >> 4 == 14 ? 3 : e8 >> 3 == 30 ? 4 : e8 >> 6 == 2 ? -1 : -2;
    }
    function u4(e8, t2, r2) {
      var n5 = t2.length - 1;
      if (n5 < r2)
        return 0;
      var i5 = l6(t2[n5]);
      return i5 >= 0 ? (i5 > 0 && (e8.lastNeed = i5 - 1), i5) : --n5 < r2 || -2 === i5 ? 0 : (i5 = l6(t2[n5])) >= 0 ? (i5 > 0 && (e8.lastNeed = i5 - 2), i5) : --n5 < r2 || -2 === i5 ? 0 : (i5 = l6(t2[n5])) >= 0 ? (i5 > 0 && (2 === i5 ? i5 = 0 : e8.lastNeed = i5 - 3), i5) : 0;
    }
    function c3(e8, t2, r2) {
      if (128 != (192 & t2[0]))
        return e8.lastNeed = 0, "\uFFFD";
      if (e8.lastNeed > 1 && t2.length > 1) {
        if (128 != (192 & t2[1]))
          return e8.lastNeed = 1, "\uFFFD";
        if (e8.lastNeed > 2 && t2.length > 2 && 128 != (192 & t2[2]))
          return e8.lastNeed = 2, "\uFFFD";
      }
    }
    function d5(e8) {
      var t2 = this.lastTotal - this.lastNeed, r2 = c3(this, e8);
      return void 0 !== r2 ? r2 : this.lastNeed <= e8.length ? (e8.copy(this.lastChar, t2, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e8.copy(this.lastChar, t2, 0, e8.length), void (this.lastNeed -= e8.length));
    }
    function h6(e8, t2) {
      var r2 = u4(this, e8, t2);
      if (!this.lastNeed)
        return e8.toString("utf8", t2);
      this.lastTotal = r2;
      var n5 = e8.length - (r2 - this.lastNeed);
      return e8.copy(this.lastChar, 0, n5), e8.toString("utf8", t2, n5);
    }
    function f5(e8) {
      var t2 = e8 && e8.length ? this.write(e8) : "";
      return this.lastNeed ? t2 + "\uFFFD" : t2;
    }
    function p6(e8, t2) {
      if ((e8.length - t2) % 2 == 0) {
        var r2 = e8.toString("utf16le", t2);
        if (r2) {
          var n5 = r2.charCodeAt(r2.length - 1);
          if (n5 >= 55296 && n5 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e8[e8.length - 2], this.lastChar[1] = e8[e8.length - 1], r2.slice(0, -1);
        }
        return r2;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e8[e8.length - 1], e8.toString("utf16le", t2, e8.length - 1);
    }
    function m5(e8) {
      var t2 = e8 && e8.length ? this.write(e8) : "";
      if (this.lastNeed) {
        var r2 = this.lastTotal - this.lastNeed;
        return t2 + this.lastChar.toString("utf16le", 0, r2);
      }
      return t2;
    }
    function y5(e8, t2) {
      var r2 = (e8.length - t2) % 3;
      return 0 === r2 ? e8.toString("base64", t2) : (this.lastNeed = 3 - r2, this.lastTotal = 3, 1 === r2 ? this.lastChar[0] = e8[e8.length - 1] : (this.lastChar[0] = e8[e8.length - 2], this.lastChar[1] = e8[e8.length - 1]), e8.toString("base64", t2, e8.length - r2));
    }
    function g5(e8) {
      var t2 = e8 && e8.length ? this.write(e8) : "";
      return this.lastNeed ? t2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t2;
    }
    function v6(e8) {
      return e8.toString(this.encoding);
    }
    function w5(e8) {
      return e8 && e8.length ? this.write(e8) : "";
    }
    r.StringDecoder = s3, s3.prototype.write = function(e8) {
      if (0 === e8.length)
        return "";
      var t2, r2;
      if (this.lastNeed) {
        if (void 0 === (t2 = this.fillLast(e8)))
          return "";
        r2 = this.lastNeed, this.lastNeed = 0;
      } else
        r2 = 0;
      return r2 < e8.length ? t2 ? t2 + this.text(e8, r2) : this.text(e8, r2) : t2 || "";
    }, s3.prototype.end = f5, s3.prototype.text = h6, s3.prototype.fillLast = function(e8) {
      if (this.lastNeed <= e8.length)
        return e8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e8.length), this.lastNeed -= e8.length;
    };
  }, { "safe-buffer": 13 }], 15: [function(e7, t, r) {
    (function(t2) {
      (function() {
        var t3 = e7("base64-js"), n4 = e7("ieee754");
        r.Buffer = s3, r.SlowBuffer = g5, r.INSPECT_MAX_BYTES = 50;
        var i4 = 2147483647;
        function o4() {
          try {
            var e8 = new Uint8Array(1);
            return e8.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
              return 42;
            } }, 42 === e8.foo();
          } catch (e9) {
            return false;
          }
        }
        function a4(e8) {
          if (e8 > i4)
            throw new RangeError('The value "' + e8 + '" is invalid for option "size"');
          var t4 = new Uint8Array(e8);
          return t4.__proto__ = s3.prototype, t4;
        }
        function s3(e8, t4, r2) {
          if ("number" == typeof e8) {
            if ("string" == typeof t4)
              throw new TypeError('The "string" argument must be of type string. Received type number');
            return d5(e8);
          }
          return l6(e8, t4, r2);
        }
        function l6(e8, t4, r2) {
          if ("string" == typeof e8)
            return h6(e8, t4);
          if (ArrayBuffer.isView(e8))
            return f5(e8);
          if (null == e8)
            throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e8);
          if (Q5(e8, ArrayBuffer) || e8 && Q5(e8.buffer, ArrayBuffer))
            return p6(e8, t4, r2);
          if ("number" == typeof e8)
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          var n5 = e8.valueOf && e8.valueOf();
          if (null != n5 && n5 !== e8)
            return s3.from(n5, t4, r2);
          var i5 = m5(e8);
          if (i5)
            return i5;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e8[Symbol.toPrimitive])
            return s3.from(e8[Symbol.toPrimitive]("string"), t4, r2);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e8);
        }
        function u4(e8) {
          if ("number" != typeof e8)
            throw new TypeError('"size" argument must be of type number');
          if (e8 < 0)
            throw new RangeError('The value "' + e8 + '" is invalid for option "size"');
        }
        function c3(e8, t4, r2) {
          return u4(e8), e8 <= 0 ? a4(e8) : void 0 !== t4 ? "string" == typeof r2 ? a4(e8).fill(t4, r2) : a4(e8).fill(t4) : a4(e8);
        }
        function d5(e8) {
          return u4(e8), a4(e8 < 0 ? 0 : 0 | y5(e8));
        }
        function h6(e8, t4) {
          if ("string" == typeof t4 && "" !== t4 || (t4 = "utf8"), !s3.isEncoding(t4))
            throw new TypeError("Unknown encoding: " + t4);
          var r2 = 0 | v6(e8, t4), n5 = a4(r2), i5 = n5.write(e8, t4);
          return i5 !== r2 && (n5 = n5.slice(0, i5)), n5;
        }
        function f5(e8) {
          for (var t4 = e8.length < 0 ? 0 : 0 | y5(e8.length), r2 = a4(t4), n5 = 0; n5 < t4; n5 += 1)
            r2[n5] = 255 & e8[n5];
          return r2;
        }
        function p6(e8, t4, r2) {
          if (t4 < 0 || e8.byteLength < t4)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (e8.byteLength < t4 + (r2 || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          var n5;
          return (n5 = void 0 === t4 && void 0 === r2 ? new Uint8Array(e8) : void 0 === r2 ? new Uint8Array(e8, t4) : new Uint8Array(e8, t4, r2)).__proto__ = s3.prototype, n5;
        }
        function m5(e8) {
          if (s3.isBuffer(e8)) {
            var t4 = 0 | y5(e8.length), r2 = a4(t4);
            return 0 === r2.length || e8.copy(r2, 0, 0, t4), r2;
          }
          return void 0 !== e8.length ? "number" != typeof e8.length || Z5(e8.length) ? a4(0) : f5(e8) : "Buffer" === e8.type && Array.isArray(e8.data) ? f5(e8.data) : void 0;
        }
        function y5(e8) {
          if (e8 >= i4)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i4.toString(16) + " bytes");
          return 0 | e8;
        }
        function g5(e8) {
          return +e8 != e8 && (e8 = 0), s3.alloc(+e8);
        }
        function v6(e8, t4) {
          if (s3.isBuffer(e8))
            return e8.length;
          if (ArrayBuffer.isView(e8) || Q5(e8, ArrayBuffer))
            return e8.byteLength;
          if ("string" != typeof e8)
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e8);
          var r2 = e8.length, n5 = arguments.length > 2 && true === arguments[2];
          if (!n5 && 0 === r2)
            return 0;
          for (var i5 = false; ; )
            switch (t4) {
              case "ascii":
              case "latin1":
              case "binary":
                return r2;
              case "utf8":
              case "utf-8":
                return z6(e8).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * r2;
              case "hex":
                return r2 >>> 1;
              case "base64":
                return J4(e8).length;
              default:
                if (i5)
                  return n5 ? -1 : z6(e8).length;
                t4 = ("" + t4).toLowerCase(), i5 = true;
            }
        }
        function w5(e8, t4, r2) {
          var n5 = false;
          if ((void 0 === t4 || t4 < 0) && (t4 = 0), t4 > this.length)
            return "";
          if ((void 0 === r2 || r2 > this.length) && (r2 = this.length), r2 <= 0)
            return "";
          if ((r2 >>>= 0) <= (t4 >>>= 0))
            return "";
          for (e8 || (e8 = "utf8"); ; )
            switch (e8) {
              case "hex":
                return M6(this, t4, r2);
              case "utf8":
              case "utf-8":
                return D4(this, t4, r2);
              case "ascii":
                return C5(this, t4, r2);
              case "latin1":
              case "binary":
                return A5(this, t4, r2);
              case "base64":
                return j5(this, t4, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return L4(this, t4, r2);
              default:
                if (n5)
                  throw new TypeError("Unknown encoding: " + e8);
                e8 = (e8 + "").toLowerCase(), n5 = true;
            }
        }
        function b7(e8, t4, r2) {
          var n5 = e8[t4];
          e8[t4] = e8[r2], e8[r2] = n5;
        }
        function _5(e8, t4, r2, n5, i5) {
          if (0 === e8.length)
            return -1;
          if ("string" == typeof r2 ? (n5 = r2, r2 = 0) : r2 > 2147483647 ? r2 = 2147483647 : r2 < -2147483648 && (r2 = -2147483648), Z5(r2 = +r2) && (r2 = i5 ? 0 : e8.length - 1), r2 < 0 && (r2 = e8.length + r2), r2 >= e8.length) {
            if (i5)
              return -1;
            r2 = e8.length - 1;
          } else if (r2 < 0) {
            if (!i5)
              return -1;
            r2 = 0;
          }
          if ("string" == typeof t4 && (t4 = s3.from(t4, n5)), s3.isBuffer(t4))
            return 0 === t4.length ? -1 : E4(e8, t4, r2, n5, i5);
          if ("number" == typeof t4)
            return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i5 ? Uint8Array.prototype.indexOf.call(e8, t4, r2) : Uint8Array.prototype.lastIndexOf.call(e8, t4, r2) : E4(e8, [t4], r2, n5, i5);
          throw new TypeError("val must be string, number or Buffer");
        }
        function E4(e8, t4, r2, n5, i5) {
          var o5, a5 = 1, s4 = e8.length, l7 = t4.length;
          if (void 0 !== n5 && ("ucs2" === (n5 = String(n5).toLowerCase()) || "ucs-2" === n5 || "utf16le" === n5 || "utf-16le" === n5)) {
            if (e8.length < 2 || t4.length < 2)
              return -1;
            a5 = 2, s4 /= 2, l7 /= 2, r2 /= 2;
          }
          function u5(e9, t5) {
            return 1 === a5 ? e9[t5] : e9.readUInt16BE(t5 * a5);
          }
          if (i5) {
            var c4 = -1;
            for (o5 = r2; o5 < s4; o5++)
              if (u5(e8, o5) === u5(t4, -1 === c4 ? 0 : o5 - c4)) {
                if (-1 === c4 && (c4 = o5), o5 - c4 + 1 === l7)
                  return c4 * a5;
              } else
                -1 !== c4 && (o5 -= o5 - c4), c4 = -1;
          } else
            for (r2 + l7 > s4 && (r2 = s4 - l7), o5 = r2; o5 >= 0; o5--) {
              for (var d6 = true, h7 = 0; h7 < l7; h7++)
                if (u5(e8, o5 + h7) !== u5(t4, h7)) {
                  d6 = false;
                  break;
                }
              if (d6)
                return o5;
            }
          return -1;
        }
        function T6(e8, t4, r2, n5) {
          r2 = Number(r2) || 0;
          var i5 = e8.length - r2;
          n5 ? (n5 = Number(n5)) > i5 && (n5 = i5) : n5 = i5;
          var o5 = t4.length;
          n5 > o5 / 2 && (n5 = o5 / 2);
          for (var a5 = 0; a5 < n5; ++a5) {
            var s4 = parseInt(t4.substr(2 * a5, 2), 16);
            if (Z5(s4))
              return a5;
            e8[r2 + a5] = s4;
          }
          return a5;
        }
        function x6(e8, t4, r2, n5) {
          return V5(z6(t4, e8.length - r2), e8, r2, n5);
        }
        function I5(e8, t4, r2, n5) {
          return V5(G7(t4), e8, r2, n5);
        }
        function S6(e8, t4, r2, n5) {
          return I5(e8, t4, r2, n5);
        }
        function R5(e8, t4, r2, n5) {
          return V5(J4(t4), e8, r2, n5);
        }
        function k5(e8, t4, r2, n5) {
          return V5(H4(t4, e8.length - r2), e8, r2, n5);
        }
        function j5(e8, r2, n5) {
          return 0 === r2 && n5 === e8.length ? t3.fromByteArray(e8) : t3.fromByteArray(e8.slice(r2, n5));
        }
        function D4(e8, t4, r2) {
          r2 = Math.min(e8.length, r2);
          for (var n5 = [], i5 = t4; i5 < r2; ) {
            var o5, a5, s4, l7, u5 = e8[i5], c4 = null, d6 = u5 > 239 ? 4 : u5 > 223 ? 3 : u5 > 191 ? 2 : 1;
            if (i5 + d6 <= r2)
              switch (d6) {
                case 1:
                  u5 < 128 && (c4 = u5);
                  break;
                case 2:
                  128 == (192 & (o5 = e8[i5 + 1])) && (l7 = (31 & u5) << 6 | 63 & o5) > 127 && (c4 = l7);
                  break;
                case 3:
                  o5 = e8[i5 + 1], a5 = e8[i5 + 2], 128 == (192 & o5) && 128 == (192 & a5) && (l7 = (15 & u5) << 12 | (63 & o5) << 6 | 63 & a5) > 2047 && (l7 < 55296 || l7 > 57343) && (c4 = l7);
                  break;
                case 4:
                  o5 = e8[i5 + 1], a5 = e8[i5 + 2], s4 = e8[i5 + 3], 128 == (192 & o5) && 128 == (192 & a5) && 128 == (192 & s4) && (l7 = (15 & u5) << 18 | (63 & o5) << 12 | (63 & a5) << 6 | 63 & s4) > 65535 && l7 < 1114112 && (c4 = l7);
              }
            null === c4 ? (c4 = 65533, d6 = 1) : c4 > 65535 && (c4 -= 65536, n5.push(c4 >>> 10 & 1023 | 55296), c4 = 56320 | 1023 & c4), n5.push(c4), i5 += d6;
          }
          return O3(n5);
        }
        r.kMaxLength = i4, s3.TYPED_ARRAY_SUPPORT = o4(), s3.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s3.prototype, "parent", { enumerable: true, get: function() {
          if (s3.isBuffer(this))
            return this.buffer;
        } }), Object.defineProperty(s3.prototype, "offset", { enumerable: true, get: function() {
          if (s3.isBuffer(this))
            return this.byteOffset;
        } }), "undefined" != typeof Symbol && null != Symbol.species && s3[Symbol.species] === s3 && Object.defineProperty(s3, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s3.poolSize = 8192, s3.from = function(e8, t4, r2) {
          return l6(e8, t4, r2);
        }, s3.prototype.__proto__ = Uint8Array.prototype, s3.__proto__ = Uint8Array, s3.alloc = function(e8, t4, r2) {
          return c3(e8, t4, r2);
        }, s3.allocUnsafe = function(e8) {
          return d5(e8);
        }, s3.allocUnsafeSlow = function(e8) {
          return d5(e8);
        }, s3.isBuffer = function(e8) {
          return null != e8 && true === e8._isBuffer && e8 !== s3.prototype;
        }, s3.compare = function(e8, t4) {
          if (Q5(e8, Uint8Array) && (e8 = s3.from(e8, e8.offset, e8.byteLength)), Q5(t4, Uint8Array) && (t4 = s3.from(t4, t4.offset, t4.byteLength)), !s3.isBuffer(e8) || !s3.isBuffer(t4))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (e8 === t4)
            return 0;
          for (var r2 = e8.length, n5 = t4.length, i5 = 0, o5 = Math.min(r2, n5); i5 < o5; ++i5)
            if (e8[i5] !== t4[i5]) {
              r2 = e8[i5], n5 = t4[i5];
              break;
            }
          return r2 < n5 ? -1 : n5 < r2 ? 1 : 0;
        }, s3.isEncoding = function(e8) {
          switch (String(e8).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, s3.concat = function(e8, t4) {
          if (!Array.isArray(e8))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === e8.length)
            return s3.alloc(0);
          var r2;
          if (void 0 === t4)
            for (t4 = 0, r2 = 0; r2 < e8.length; ++r2)
              t4 += e8[r2].length;
          var n5 = s3.allocUnsafe(t4), i5 = 0;
          for (r2 = 0; r2 < e8.length; ++r2) {
            var o5 = e8[r2];
            if (Q5(o5, Uint8Array) && (o5 = s3.from(o5)), !s3.isBuffer(o5))
              throw new TypeError('"list" argument must be an Array of Buffers');
            o5.copy(n5, i5), i5 += o5.length;
          }
          return n5;
        }, s3.byteLength = v6, s3.prototype._isBuffer = true, s3.prototype.swap16 = function() {
          var e8 = this.length;
          if (e8 % 2 != 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var t4 = 0; t4 < e8; t4 += 2)
            b7(this, t4, t4 + 1);
          return this;
        }, s3.prototype.swap32 = function() {
          var e8 = this.length;
          if (e8 % 4 != 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var t4 = 0; t4 < e8; t4 += 4)
            b7(this, t4, t4 + 3), b7(this, t4 + 1, t4 + 2);
          return this;
        }, s3.prototype.swap64 = function() {
          var e8 = this.length;
          if (e8 % 8 != 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var t4 = 0; t4 < e8; t4 += 8)
            b7(this, t4, t4 + 7), b7(this, t4 + 1, t4 + 6), b7(this, t4 + 2, t4 + 5), b7(this, t4 + 3, t4 + 4);
          return this;
        }, s3.prototype.toString = function() {
          var e8 = this.length;
          return 0 === e8 ? "" : 0 === arguments.length ? D4(this, 0, e8) : w5.apply(this, arguments);
        }, s3.prototype.toLocaleString = s3.prototype.toString, s3.prototype.equals = function(e8) {
          if (!s3.isBuffer(e8))
            throw new TypeError("Argument must be a Buffer");
          return this === e8 || 0 === s3.compare(this, e8);
        }, s3.prototype.inspect = function() {
          var e8 = "", t4 = r.INSPECT_MAX_BYTES;
          return e8 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e8 += " ... "), "<Buffer " + e8 + ">";
        }, s3.prototype.compare = function(e8, t4, r2, n5, i5) {
          if (Q5(e8, Uint8Array) && (e8 = s3.from(e8, e8.offset, e8.byteLength)), !s3.isBuffer(e8))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e8);
          if (void 0 === t4 && (t4 = 0), void 0 === r2 && (r2 = e8 ? e8.length : 0), void 0 === n5 && (n5 = 0), void 0 === i5 && (i5 = this.length), t4 < 0 || r2 > e8.length || n5 < 0 || i5 > this.length)
            throw new RangeError("out of range index");
          if (n5 >= i5 && t4 >= r2)
            return 0;
          if (n5 >= i5)
            return -1;
          if (t4 >= r2)
            return 1;
          if (this === e8)
            return 0;
          for (var o5 = (i5 >>>= 0) - (n5 >>>= 0), a5 = (r2 >>>= 0) - (t4 >>>= 0), l7 = Math.min(o5, a5), u5 = this.slice(n5, i5), c4 = e8.slice(t4, r2), d6 = 0; d6 < l7; ++d6)
            if (u5[d6] !== c4[d6]) {
              o5 = u5[d6], a5 = c4[d6];
              break;
            }
          return o5 < a5 ? -1 : a5 < o5 ? 1 : 0;
        }, s3.prototype.includes = function(e8, t4, r2) {
          return -1 !== this.indexOf(e8, t4, r2);
        }, s3.prototype.indexOf = function(e8, t4, r2) {
          return _5(this, e8, t4, r2, true);
        }, s3.prototype.lastIndexOf = function(e8, t4, r2) {
          return _5(this, e8, t4, r2, false);
        }, s3.prototype.write = function(e8, t4, r2, n5) {
          if (void 0 === t4)
            n5 = "utf8", r2 = this.length, t4 = 0;
          else if (void 0 === r2 && "string" == typeof t4)
            n5 = t4, r2 = this.length, t4 = 0;
          else {
            if (!isFinite(t4))
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            t4 >>>= 0, isFinite(r2) ? (r2 >>>= 0, void 0 === n5 && (n5 = "utf8")) : (n5 = r2, r2 = void 0);
          }
          var i5 = this.length - t4;
          if ((void 0 === r2 || r2 > i5) && (r2 = i5), e8.length > 0 && (r2 < 0 || t4 < 0) || t4 > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
          n5 || (n5 = "utf8");
          for (var o5 = false; ; )
            switch (n5) {
              case "hex":
                return T6(this, e8, t4, r2);
              case "utf8":
              case "utf-8":
                return x6(this, e8, t4, r2);
              case "ascii":
                return I5(this, e8, t4, r2);
              case "latin1":
              case "binary":
                return S6(this, e8, t4, r2);
              case "base64":
                return R5(this, e8, t4, r2);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return k5(this, e8, t4, r2);
              default:
                if (o5)
                  throw new TypeError("Unknown encoding: " + n5);
                n5 = ("" + n5).toLowerCase(), o5 = true;
            }
        }, s3.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var N10 = 4096;
        function O3(e8) {
          var t4 = e8.length;
          if (t4 <= N10)
            return String.fromCharCode.apply(String, e8);
          for (var r2 = "", n5 = 0; n5 < t4; )
            r2 += String.fromCharCode.apply(String, e8.slice(n5, n5 += N10));
          return r2;
        }
        function C5(e8, t4, r2) {
          var n5 = "";
          r2 = Math.min(e8.length, r2);
          for (var i5 = t4; i5 < r2; ++i5)
            n5 += String.fromCharCode(127 & e8[i5]);
          return n5;
        }
        function A5(e8, t4, r2) {
          var n5 = "";
          r2 = Math.min(e8.length, r2);
          for (var i5 = t4; i5 < r2; ++i5)
            n5 += String.fromCharCode(e8[i5]);
          return n5;
        }
        function M6(e8, t4, r2) {
          var n5 = e8.length;
          (!t4 || t4 < 0) && (t4 = 0), (!r2 || r2 < 0 || r2 > n5) && (r2 = n5);
          for (var i5 = "", o5 = t4; o5 < r2; ++o5)
            i5 += W5(e8[o5]);
          return i5;
        }
        function L4(e8, t4, r2) {
          for (var n5 = e8.slice(t4, r2), i5 = "", o5 = 0; o5 < n5.length; o5 += 2)
            i5 += String.fromCharCode(n5[o5] + 256 * n5[o5 + 1]);
          return i5;
        }
        function P5(e8, t4, r2) {
          if (e8 % 1 != 0 || e8 < 0)
            throw new RangeError("offset is not uint");
          if (e8 + t4 > r2)
            throw new RangeError("Trying to access beyond buffer length");
        }
        function B6(e8, t4, r2, n5, i5, o5) {
          if (!s3.isBuffer(e8))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (t4 > i5 || t4 < o5)
            throw new RangeError('"value" argument is out of bounds');
          if (r2 + n5 > e8.length)
            throw new RangeError("Index out of range");
        }
        function $4(e8, t4, r2, n5, i5, o5) {
          if (r2 + n5 > e8.length)
            throw new RangeError("Index out of range");
          if (r2 < 0)
            throw new RangeError("Index out of range");
        }
        function F4(e8, t4, r2, i5, o5) {
          return t4 = +t4, r2 >>>= 0, o5 || $4(e8, t4, r2, 4), n4.write(e8, t4, r2, i5, 23, 4), r2 + 4;
        }
        function U6(e8, t4, r2, i5, o5) {
          return t4 = +t4, r2 >>>= 0, o5 || $4(e8, t4, r2, 8), n4.write(e8, t4, r2, i5, 52, 8), r2 + 8;
        }
        s3.prototype.slice = function(e8, t4) {
          var r2 = this.length;
          (e8 = ~~e8) < 0 ? (e8 += r2) < 0 && (e8 = 0) : e8 > r2 && (e8 = r2), (t4 = void 0 === t4 ? r2 : ~~t4) < 0 ? (t4 += r2) < 0 && (t4 = 0) : t4 > r2 && (t4 = r2), t4 < e8 && (t4 = e8);
          var n5 = this.subarray(e8, t4);
          return n5.__proto__ = s3.prototype, n5;
        }, s3.prototype.readUIntLE = function(e8, t4, r2) {
          e8 >>>= 0, t4 >>>= 0, r2 || P5(e8, t4, this.length);
          for (var n5 = this[e8], i5 = 1, o5 = 0; ++o5 < t4 && (i5 *= 256); )
            n5 += this[e8 + o5] * i5;
          return n5;
        }, s3.prototype.readUIntBE = function(e8, t4, r2) {
          e8 >>>= 0, t4 >>>= 0, r2 || P5(e8, t4, this.length);
          for (var n5 = this[e8 + --t4], i5 = 1; t4 > 0 && (i5 *= 256); )
            n5 += this[e8 + --t4] * i5;
          return n5;
        }, s3.prototype.readUInt8 = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 1, this.length), this[e8];
        }, s3.prototype.readUInt16LE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 2, this.length), this[e8] | this[e8 + 1] << 8;
        }, s3.prototype.readUInt16BE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 2, this.length), this[e8] << 8 | this[e8 + 1];
        }, s3.prototype.readUInt32LE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), (this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16) + 16777216 * this[e8 + 3];
        }, s3.prototype.readUInt32BE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), 16777216 * this[e8] + (this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3]);
        }, s3.prototype.readIntLE = function(e8, t4, r2) {
          e8 >>>= 0, t4 >>>= 0, r2 || P5(e8, t4, this.length);
          for (var n5 = this[e8], i5 = 1, o5 = 0; ++o5 < t4 && (i5 *= 256); )
            n5 += this[e8 + o5] * i5;
          return n5 >= (i5 *= 128) && (n5 -= Math.pow(2, 8 * t4)), n5;
        }, s3.prototype.readIntBE = function(e8, t4, r2) {
          e8 >>>= 0, t4 >>>= 0, r2 || P5(e8, t4, this.length);
          for (var n5 = t4, i5 = 1, o5 = this[e8 + --n5]; n5 > 0 && (i5 *= 256); )
            o5 += this[e8 + --n5] * i5;
          return o5 >= (i5 *= 128) && (o5 -= Math.pow(2, 8 * t4)), o5;
        }, s3.prototype.readInt8 = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 1, this.length), 128 & this[e8] ? -1 * (255 - this[e8] + 1) : this[e8];
        }, s3.prototype.readInt16LE = function(e8, t4) {
          e8 >>>= 0, t4 || P5(e8, 2, this.length);
          var r2 = this[e8] | this[e8 + 1] << 8;
          return 32768 & r2 ? 4294901760 | r2 : r2;
        }, s3.prototype.readInt16BE = function(e8, t4) {
          e8 >>>= 0, t4 || P5(e8, 2, this.length);
          var r2 = this[e8 + 1] | this[e8] << 8;
          return 32768 & r2 ? 4294901760 | r2 : r2;
        }, s3.prototype.readInt32LE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), this[e8] | this[e8 + 1] << 8 | this[e8 + 2] << 16 | this[e8 + 3] << 24;
        }, s3.prototype.readInt32BE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), this[e8] << 24 | this[e8 + 1] << 16 | this[e8 + 2] << 8 | this[e8 + 3];
        }, s3.prototype.readFloatLE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), n4.read(this, e8, true, 23, 4);
        }, s3.prototype.readFloatBE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 4, this.length), n4.read(this, e8, false, 23, 4);
        }, s3.prototype.readDoubleLE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 8, this.length), n4.read(this, e8, true, 52, 8);
        }, s3.prototype.readDoubleBE = function(e8, t4) {
          return e8 >>>= 0, t4 || P5(e8, 8, this.length), n4.read(this, e8, false, 52, 8);
        }, s3.prototype.writeUIntLE = function(e8, t4, r2, n5) {
          e8 = +e8, t4 >>>= 0, r2 >>>= 0, n5 || B6(this, e8, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
          var i5 = 1, o5 = 0;
          for (this[t4] = 255 & e8; ++o5 < r2 && (i5 *= 256); )
            this[t4 + o5] = e8 / i5 & 255;
          return t4 + r2;
        }, s3.prototype.writeUIntBE = function(e8, t4, r2, n5) {
          e8 = +e8, t4 >>>= 0, r2 >>>= 0, n5 || B6(this, e8, t4, r2, Math.pow(2, 8 * r2) - 1, 0);
          var i5 = r2 - 1, o5 = 1;
          for (this[t4 + i5] = 255 & e8; --i5 >= 0 && (o5 *= 256); )
            this[t4 + i5] = e8 / o5 & 255;
          return t4 + r2;
        }, s3.prototype.writeUInt8 = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 1, 255, 0), this[t4] = 255 & e8, t4 + 1;
        }, s3.prototype.writeUInt16LE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 2, 65535, 0), this[t4] = 255 & e8, this[t4 + 1] = e8 >>> 8, t4 + 2;
        }, s3.prototype.writeUInt16BE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 2, 65535, 0), this[t4] = e8 >>> 8, this[t4 + 1] = 255 & e8, t4 + 2;
        }, s3.prototype.writeUInt32LE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 4, 4294967295, 0), this[t4 + 3] = e8 >>> 24, this[t4 + 2] = e8 >>> 16, this[t4 + 1] = e8 >>> 8, this[t4] = 255 & e8, t4 + 4;
        }, s3.prototype.writeUInt32BE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 4, 4294967295, 0), this[t4] = e8 >>> 24, this[t4 + 1] = e8 >>> 16, this[t4 + 2] = e8 >>> 8, this[t4 + 3] = 255 & e8, t4 + 4;
        }, s3.prototype.writeIntLE = function(e8, t4, r2, n5) {
          if (e8 = +e8, t4 >>>= 0, !n5) {
            var i5 = Math.pow(2, 8 * r2 - 1);
            B6(this, e8, t4, r2, i5 - 1, -i5);
          }
          var o5 = 0, a5 = 1, s4 = 0;
          for (this[t4] = 255 & e8; ++o5 < r2 && (a5 *= 256); )
            e8 < 0 && 0 === s4 && 0 !== this[t4 + o5 - 1] && (s4 = 1), this[t4 + o5] = (e8 / a5 >> 0) - s4 & 255;
          return t4 + r2;
        }, s3.prototype.writeIntBE = function(e8, t4, r2, n5) {
          if (e8 = +e8, t4 >>>= 0, !n5) {
            var i5 = Math.pow(2, 8 * r2 - 1);
            B6(this, e8, t4, r2, i5 - 1, -i5);
          }
          var o5 = r2 - 1, a5 = 1, s4 = 0;
          for (this[t4 + o5] = 255 & e8; --o5 >= 0 && (a5 *= 256); )
            e8 < 0 && 0 === s4 && 0 !== this[t4 + o5 + 1] && (s4 = 1), this[t4 + o5] = (e8 / a5 >> 0) - s4 & 255;
          return t4 + r2;
        }, s3.prototype.writeInt8 = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 1, 127, -128), e8 < 0 && (e8 = 255 + e8 + 1), this[t4] = 255 & e8, t4 + 1;
        }, s3.prototype.writeInt16LE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 2, 32767, -32768), this[t4] = 255 & e8, this[t4 + 1] = e8 >>> 8, t4 + 2;
        }, s3.prototype.writeInt16BE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 2, 32767, -32768), this[t4] = e8 >>> 8, this[t4 + 1] = 255 & e8, t4 + 2;
        }, s3.prototype.writeInt32LE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e8, this[t4 + 1] = e8 >>> 8, this[t4 + 2] = e8 >>> 16, this[t4 + 3] = e8 >>> 24, t4 + 4;
        }, s3.prototype.writeInt32BE = function(e8, t4, r2) {
          return e8 = +e8, t4 >>>= 0, r2 || B6(this, e8, t4, 4, 2147483647, -2147483648), e8 < 0 && (e8 = 4294967295 + e8 + 1), this[t4] = e8 >>> 24, this[t4 + 1] = e8 >>> 16, this[t4 + 2] = e8 >>> 8, this[t4 + 3] = 255 & e8, t4 + 4;
        }, s3.prototype.writeFloatLE = function(e8, t4, r2) {
          return F4(this, e8, t4, true, r2);
        }, s3.prototype.writeFloatBE = function(e8, t4, r2) {
          return F4(this, e8, t4, false, r2);
        }, s3.prototype.writeDoubleLE = function(e8, t4, r2) {
          return U6(this, e8, t4, true, r2);
        }, s3.prototype.writeDoubleBE = function(e8, t4, r2) {
          return U6(this, e8, t4, false, r2);
        }, s3.prototype.copy = function(e8, t4, r2, n5) {
          if (!s3.isBuffer(e8))
            throw new TypeError("argument should be a Buffer");
          if (r2 || (r2 = 0), n5 || 0 === n5 || (n5 = this.length), t4 >= e8.length && (t4 = e8.length), t4 || (t4 = 0), n5 > 0 && n5 < r2 && (n5 = r2), n5 === r2)
            return 0;
          if (0 === e8.length || 0 === this.length)
            return 0;
          if (t4 < 0)
            throw new RangeError("targetStart out of bounds");
          if (r2 < 0 || r2 >= this.length)
            throw new RangeError("Index out of range");
          if (n5 < 0)
            throw new RangeError("sourceEnd out of bounds");
          n5 > this.length && (n5 = this.length), e8.length - t4 < n5 - r2 && (n5 = e8.length - t4 + r2);
          var i5 = n5 - r2;
          if (this === e8 && "function" == typeof Uint8Array.prototype.copyWithin)
            this.copyWithin(t4, r2, n5);
          else if (this === e8 && r2 < t4 && t4 < n5)
            for (var o5 = i5 - 1; o5 >= 0; --o5)
              e8[o5 + t4] = this[o5 + r2];
          else
            Uint8Array.prototype.set.call(e8, this.subarray(r2, n5), t4);
          return i5;
        }, s3.prototype.fill = function(e8, t4, r2, n5) {
          if ("string" == typeof e8) {
            if ("string" == typeof t4 ? (n5 = t4, t4 = 0, r2 = this.length) : "string" == typeof r2 && (n5 = r2, r2 = this.length), void 0 !== n5 && "string" != typeof n5)
              throw new TypeError("encoding must be a string");
            if ("string" == typeof n5 && !s3.isEncoding(n5))
              throw new TypeError("Unknown encoding: " + n5);
            if (1 === e8.length) {
              var i5 = e8.charCodeAt(0);
              ("utf8" === n5 && i5 < 128 || "latin1" === n5) && (e8 = i5);
            }
          } else
            "number" == typeof e8 && (e8 &= 255);
          if (t4 < 0 || this.length < t4 || this.length < r2)
            throw new RangeError("Out of range index");
          if (r2 <= t4)
            return this;
          var o5;
          if (t4 >>>= 0, r2 = void 0 === r2 ? this.length : r2 >>> 0, e8 || (e8 = 0), "number" == typeof e8)
            for (o5 = t4; o5 < r2; ++o5)
              this[o5] = e8;
          else {
            var a5 = s3.isBuffer(e8) ? e8 : s3.from(e8, n5), l7 = a5.length;
            if (0 === l7)
              throw new TypeError('The value "' + e8 + '" is invalid for argument "value"');
            for (o5 = 0; o5 < r2 - t4; ++o5)
              this[o5 + t4] = a5[o5 % l7];
          }
          return this;
        };
        var q5 = /[^+/0-9A-Za-z-_]/g;
        function Y5(e8) {
          if ((e8 = (e8 = e8.split("=")[0]).trim().replace(q5, "")).length < 2)
            return "";
          for (; e8.length % 4 != 0; )
            e8 += "=";
          return e8;
        }
        function W5(e8) {
          return e8 < 16 ? "0" + e8.toString(16) : e8.toString(16);
        }
        function z6(e8, t4) {
          var r2;
          t4 = t4 || 1 / 0;
          for (var n5 = e8.length, i5 = null, o5 = [], a5 = 0; a5 < n5; ++a5) {
            if ((r2 = e8.charCodeAt(a5)) > 55295 && r2 < 57344) {
              if (!i5) {
                if (r2 > 56319) {
                  (t4 -= 3) > -1 && o5.push(239, 191, 189);
                  continue;
                }
                if (a5 + 1 === n5) {
                  (t4 -= 3) > -1 && o5.push(239, 191, 189);
                  continue;
                }
                i5 = r2;
                continue;
              }
              if (r2 < 56320) {
                (t4 -= 3) > -1 && o5.push(239, 191, 189), i5 = r2;
                continue;
              }
              r2 = 65536 + (i5 - 55296 << 10 | r2 - 56320);
            } else
              i5 && (t4 -= 3) > -1 && o5.push(239, 191, 189);
            if (i5 = null, r2 < 128) {
              if ((t4 -= 1) < 0)
                break;
              o5.push(r2);
            } else if (r2 < 2048) {
              if ((t4 -= 2) < 0)
                break;
              o5.push(r2 >> 6 | 192, 63 & r2 | 128);
            } else if (r2 < 65536) {
              if ((t4 -= 3) < 0)
                break;
              o5.push(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128);
            } else {
              if (!(r2 < 1114112))
                throw new Error("Invalid code point");
              if ((t4 -= 4) < 0)
                break;
              o5.push(r2 >> 18 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128);
            }
          }
          return o5;
        }
        function G7(e8) {
          for (var t4 = [], r2 = 0; r2 < e8.length; ++r2)
            t4.push(255 & e8.charCodeAt(r2));
          return t4;
        }
        function H4(e8, t4) {
          for (var r2, n5, i5, o5 = [], a5 = 0; a5 < e8.length && !((t4 -= 2) < 0); ++a5)
            n5 = (r2 = e8.charCodeAt(a5)) >> 8, i5 = r2 % 256, o5.push(i5), o5.push(n5);
          return o5;
        }
        function J4(e8) {
          return t3.toByteArray(Y5(e8));
        }
        function V5(e8, t4, r2, n5) {
          for (var i5 = 0; i5 < n5 && !(i5 + r2 >= t4.length || i5 >= e8.length); ++i5)
            t4[i5 + r2] = e8[i5];
          return i5;
        }
        function Q5(e8, t4) {
          return e8 instanceof t4 || null != e8 && null != e8.constructor && null != e8.constructor.name && e8.constructor.name === t4.name;
        }
        function Z5(e8) {
          return e8 != e8;
        }
      }).call(this);
    }).call(this, e7("buffer").Buffer);
  }, { "base64-js": 12, buffer: 15, ieee754: 17 }], 16: [function(e7, t, r) {
    var n4, i4 = "object" == typeof Reflect ? Reflect : null, o4 = i4 && "function" == typeof i4.apply ? i4.apply : function(e8, t2, r2) {
      return Function.prototype.apply.call(e8, t2, r2);
    };
    function a4(e8) {
      console && console.warn && console.warn(e8);
    }
    n4 = i4 && "function" == typeof i4.ownKeys ? i4.ownKeys : Object.getOwnPropertySymbols ? function(e8) {
      return Object.getOwnPropertyNames(e8).concat(Object.getOwnPropertySymbols(e8));
    } : function(e8) {
      return Object.getOwnPropertyNames(e8);
    };
    var s3 = Number.isNaN || function(e8) {
      return e8 != e8;
    };
    function l6() {
      l6.init.call(this);
    }
    t.exports = l6, t.exports.once = b7, l6.EventEmitter = l6, l6.prototype._events = void 0, l6.prototype._eventsCount = 0, l6.prototype._maxListeners = void 0;
    var u4 = 10;
    function c3(e8) {
      if ("function" != typeof e8)
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e8);
    }
    function d5(e8) {
      return void 0 === e8._maxListeners ? l6.defaultMaxListeners : e8._maxListeners;
    }
    function h6(e8, t2, r2, n5) {
      var i5, o5, s4;
      if (c3(r2), void 0 === (o5 = e8._events) ? (o5 = e8._events = /* @__PURE__ */ Object.create(null), e8._eventsCount = 0) : (void 0 !== o5.newListener && (e8.emit("newListener", t2, r2.listener ? r2.listener : r2), o5 = e8._events), s4 = o5[t2]), void 0 === s4)
        s4 = o5[t2] = r2, ++e8._eventsCount;
      else if ("function" == typeof s4 ? s4 = o5[t2] = n5 ? [r2, s4] : [s4, r2] : n5 ? s4.unshift(r2) : s4.push(r2), (i5 = d5(e8)) > 0 && s4.length > i5 && !s4.warned) {
        s4.warned = true;
        var l7 = new Error("Possible EventEmitter memory leak detected. " + s4.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        l7.name = "MaxListenersExceededWarning", l7.emitter = e8, l7.type = t2, l7.count = s4.length, a4(l7);
      }
      return e8;
    }
    function f5() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function p6(e8, t2, r2) {
      var n5 = { fired: false, wrapFn: void 0, target: e8, type: t2, listener: r2 }, i5 = f5.bind(n5);
      return i5.listener = r2, n5.wrapFn = i5, i5;
    }
    function m5(e8, t2, r2) {
      var n5 = e8._events;
      if (void 0 === n5)
        return [];
      var i5 = n5[t2];
      return void 0 === i5 ? [] : "function" == typeof i5 ? r2 ? [i5.listener || i5] : [i5] : r2 ? w5(i5) : g5(i5, i5.length);
    }
    function y5(e8) {
      var t2 = this._events;
      if (void 0 !== t2) {
        var r2 = t2[e8];
        if ("function" == typeof r2)
          return 1;
        if (void 0 !== r2)
          return r2.length;
      }
      return 0;
    }
    function g5(e8, t2) {
      for (var r2 = new Array(t2), n5 = 0; n5 < t2; ++n5)
        r2[n5] = e8[n5];
      return r2;
    }
    function v6(e8, t2) {
      for (; t2 + 1 < e8.length; t2++)
        e8[t2] = e8[t2 + 1];
      e8.pop();
    }
    function w5(e8) {
      for (var t2 = new Array(e8.length), r2 = 0; r2 < t2.length; ++r2)
        t2[r2] = e8[r2].listener || e8[r2];
      return t2;
    }
    function b7(e8, t2) {
      return new Promise(function(r2, n5) {
        function i5(r3) {
          e8.removeListener(t2, o5), n5(r3);
        }
        function o5() {
          "function" == typeof e8.removeListener && e8.removeListener("error", i5), r2([].slice.call(arguments));
        }
        E4(e8, t2, o5, { once: true }), "error" !== t2 && _5(e8, i5, { once: true });
      });
    }
    function _5(e8, t2, r2) {
      "function" == typeof e8.on && E4(e8, "error", t2, r2);
    }
    function E4(e8, t2, r2, n5) {
      if ("function" == typeof e8.on)
        n5.once ? e8.once(t2, r2) : e8.on(t2, r2);
      else {
        if ("function" != typeof e8.addEventListener)
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e8);
        e8.addEventListener(t2, function i5(o5) {
          n5.once && e8.removeEventListener(t2, i5), r2(o5);
        });
      }
    }
    Object.defineProperty(l6, "defaultMaxListeners", { enumerable: true, get: function() {
      return u4;
    }, set: function(e8) {
      if ("number" != typeof e8 || e8 < 0 || s3(e8))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e8 + ".");
      u4 = e8;
    } }), l6.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, l6.prototype.setMaxListeners = function(e8) {
      if ("number" != typeof e8 || e8 < 0 || s3(e8))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e8 + ".");
      return this._maxListeners = e8, this;
    }, l6.prototype.getMaxListeners = function() {
      return d5(this);
    }, l6.prototype.emit = function(e8) {
      for (var t2 = [], r2 = 1; r2 < arguments.length; r2++)
        t2.push(arguments[r2]);
      var n5 = "error" === e8, i5 = this._events;
      if (void 0 !== i5)
        n5 = n5 && void 0 === i5.error;
      else if (!n5)
        return false;
      if (n5) {
        var a5;
        if (t2.length > 0 && (a5 = t2[0]), a5 instanceof Error)
          throw a5;
        var s4 = new Error("Unhandled error." + (a5 ? " (" + a5.message + ")" : ""));
        throw s4.context = a5, s4;
      }
      var l7 = i5[e8];
      if (void 0 === l7)
        return false;
      if ("function" == typeof l7)
        o4(l7, this, t2);
      else {
        var u5 = l7.length, c4 = g5(l7, u5);
        for (r2 = 0; r2 < u5; ++r2)
          o4(c4[r2], this, t2);
      }
      return true;
    }, l6.prototype.addListener = function(e8, t2) {
      return h6(this, e8, t2, false);
    }, l6.prototype.on = l6.prototype.addListener, l6.prototype.prependListener = function(e8, t2) {
      return h6(this, e8, t2, true);
    }, l6.prototype.once = function(e8, t2) {
      return c3(t2), this.on(e8, p6(this, e8, t2)), this;
    }, l6.prototype.prependOnceListener = function(e8, t2) {
      return c3(t2), this.prependListener(e8, p6(this, e8, t2)), this;
    }, l6.prototype.removeListener = function(e8, t2) {
      var r2, n5, i5, o5, a5;
      if (c3(t2), void 0 === (n5 = this._events))
        return this;
      if (void 0 === (r2 = n5[e8]))
        return this;
      if (r2 === t2 || r2.listener === t2)
        0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete n5[e8], n5.removeListener && this.emit("removeListener", e8, r2.listener || t2));
      else if ("function" != typeof r2) {
        for (i5 = -1, o5 = r2.length - 1; o5 >= 0; o5--)
          if (r2[o5] === t2 || r2[o5].listener === t2) {
            a5 = r2[o5].listener, i5 = o5;
            break;
          }
        if (i5 < 0)
          return this;
        0 === i5 ? r2.shift() : v6(r2, i5), 1 === r2.length && (n5[e8] = r2[0]), void 0 !== n5.removeListener && this.emit("removeListener", e8, a5 || t2);
      }
      return this;
    }, l6.prototype.off = l6.prototype.removeListener, l6.prototype.removeAllListeners = function(e8) {
      var t2, r2, n5;
      if (void 0 === (r2 = this._events))
        return this;
      if (void 0 === r2.removeListener)
        return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== r2[e8] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete r2[e8]), this;
      if (0 === arguments.length) {
        var i5, o5 = Object.keys(r2);
        for (n5 = 0; n5 < o5.length; ++n5)
          "removeListener" !== (i5 = o5[n5]) && this.removeAllListeners(i5);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if ("function" == typeof (t2 = r2[e8]))
        this.removeListener(e8, t2);
      else if (void 0 !== t2)
        for (n5 = t2.length - 1; n5 >= 0; n5--)
          this.removeListener(e8, t2[n5]);
      return this;
    }, l6.prototype.listeners = function(e8) {
      return m5(this, e8, true);
    }, l6.prototype.rawListeners = function(e8) {
      return m5(this, e8, false);
    }, l6.listenerCount = function(e8, t2) {
      return "function" == typeof e8.listenerCount ? e8.listenerCount(t2) : y5.call(e8, t2);
    }, l6.prototype.listenerCount = y5, l6.prototype.eventNames = function() {
      return this._eventsCount > 0 ? n4(this._events) : [];
    };
  }, {}], 17: [function(e7, t, r) {
    r.read = function(e8, t2, r2, n4, i4) {
      var o4, a4, s3 = 8 * i4 - n4 - 1, l6 = (1 << s3) - 1, u4 = l6 >> 1, c3 = -7, d5 = r2 ? i4 - 1 : 0, h6 = r2 ? -1 : 1, f5 = e8[t2 + d5];
      for (d5 += h6, o4 = f5 & (1 << -c3) - 1, f5 >>= -c3, c3 += s3; c3 > 0; o4 = 256 * o4 + e8[t2 + d5], d5 += h6, c3 -= 8)
        ;
      for (a4 = o4 & (1 << -c3) - 1, o4 >>= -c3, c3 += n4; c3 > 0; a4 = 256 * a4 + e8[t2 + d5], d5 += h6, c3 -= 8)
        ;
      if (0 === o4)
        o4 = 1 - u4;
      else {
        if (o4 === l6)
          return a4 ? NaN : 1 / 0 * (f5 ? -1 : 1);
        a4 += Math.pow(2, n4), o4 -= u4;
      }
      return (f5 ? -1 : 1) * a4 * Math.pow(2, o4 - n4);
    }, r.write = function(e8, t2, r2, n4, i4, o4) {
      var a4, s3, l6, u4 = 8 * o4 - i4 - 1, c3 = (1 << u4) - 1, d5 = c3 >> 1, h6 = 23 === i4 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f5 = n4 ? 0 : o4 - 1, p6 = n4 ? 1 : -1, m5 = t2 < 0 || 0 === t2 && 1 / t2 < 0 ? 1 : 0;
      for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s3 = isNaN(t2) ? 1 : 0, a4 = c3) : (a4 = Math.floor(Math.log(t2) / Math.LN2), t2 * (l6 = Math.pow(2, -a4)) < 1 && (a4--, l6 *= 2), (t2 += a4 + d5 >= 1 ? h6 / l6 : h6 * Math.pow(2, 1 - d5)) * l6 >= 2 && (a4++, l6 /= 2), a4 + d5 >= c3 ? (s3 = 0, a4 = c3) : a4 + d5 >= 1 ? (s3 = (t2 * l6 - 1) * Math.pow(2, i4), a4 += d5) : (s3 = t2 * Math.pow(2, d5 - 1) * Math.pow(2, i4), a4 = 0)); i4 >= 8; e8[r2 + f5] = 255 & s3, f5 += p6, s3 /= 256, i4 -= 8)
        ;
      for (a4 = a4 << i4 | s3, u4 += i4; u4 > 0; e8[r2 + f5] = 255 & a4, f5 += p6, a4 /= 256, u4 -= 8)
        ;
      e8[r2 + f5 - p6] |= 128 * m5;
    };
  }, {}], 18: [function(e7, t, r) {
    var n4, i4, o4 = t.exports = {};
    function a4() {
      throw new Error("setTimeout has not been defined");
    }
    function s3() {
      throw new Error("clearTimeout has not been defined");
    }
    function l6(e8) {
      if (n4 === setTimeout)
        return setTimeout(e8, 0);
      if ((n4 === a4 || !n4) && setTimeout)
        return n4 = setTimeout, setTimeout(e8, 0);
      try {
        return n4(e8, 0);
      } catch (t2) {
        try {
          return n4.call(null, e8, 0);
        } catch (t3) {
          return n4.call(this, e8, 0);
        }
      }
    }
    function u4(e8) {
      if (i4 === clearTimeout)
        return clearTimeout(e8);
      if ((i4 === s3 || !i4) && clearTimeout)
        return i4 = clearTimeout, clearTimeout(e8);
      try {
        return i4(e8);
      } catch (t2) {
        try {
          return i4.call(null, e8);
        } catch (t3) {
          return i4.call(this, e8);
        }
      }
    }
    !function() {
      try {
        n4 = "function" == typeof setTimeout ? setTimeout : a4;
      } catch (e8) {
        n4 = a4;
      }
      try {
        i4 = "function" == typeof clearTimeout ? clearTimeout : s3;
      } catch (e8) {
        i4 = s3;
      }
    }();
    var c3, d5 = [], h6 = false, f5 = -1;
    function p6() {
      h6 && c3 && (h6 = false, c3.length ? d5 = c3.concat(d5) : f5 = -1, d5.length && m5());
    }
    function m5() {
      if (!h6) {
        var e8 = l6(p6);
        h6 = true;
        for (var t2 = d5.length; t2; ) {
          for (c3 = d5, d5 = []; ++f5 < t2; )
            c3 && c3[f5].run();
          f5 = -1, t2 = d5.length;
        }
        c3 = null, h6 = false, u4(e8);
      }
    }
    function y5(e8, t2) {
      this.fun = e8, this.array = t2;
    }
    function g5() {
    }
    o4.nextTick = function(e8) {
      var t2 = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r2 = 1; r2 < arguments.length; r2++)
          t2[r2 - 1] = arguments[r2];
      d5.push(new y5(e8, t2)), 1 !== d5.length || h6 || l6(m5);
    }, y5.prototype.run = function() {
      this.fun.apply(null, this.array);
    }, o4.title = "browser", o4.browser = true, o4.env = {}, o4.argv = [], o4.version = "", o4.versions = {}, o4.on = g5, o4.addListener = g5, o4.once = g5, o4.off = g5, o4.removeListener = g5, o4.removeAllListeners = g5, o4.emit = g5, o4.prependListener = g5, o4.prependOnceListener = g5, o4.listeners = function(e8) {
      return [];
    }, o4.binding = function(e8) {
      throw new Error("process.binding is not supported");
    }, o4.cwd = function() {
      return "/";
    }, o4.chdir = function(e8) {
      throw new Error("process.chdir is not supported");
    }, o4.umask = function() {
      return 0;
    };
  }, {}], 19: [function(e7, t, r) {
    (function(e8) {
      (function() {
        let r2;
        t.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" != typeof window ? window : e8) : (e9) => (r2 || (r2 = Promise.resolve())).then(e9).catch((e10) => setTimeout(() => {
          throw e10;
        }, 0));
      }).call(this);
    }).call(this, void 0 !== s2 ? s2 : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
  }, {}], 20: [function(e7, t, r) {
    const { AbortError: n4, codes: i4 } = e7("../../ours/errors"), { isNodeStream: o4, isWebStream: a4, kControllerErrorFunction: s3 } = e7("./utils"), l6 = e7("./end-of-stream"), { ERR_INVALID_ARG_TYPE: u4 } = i4, c3 = (e8, t2) => {
      if ("object" != typeof e8 || !("aborted" in e8))
        throw new u4(t2, "AbortSignal", e8);
    };
    t.exports.addAbortSignal = function(e8, r2) {
      if (c3(e8, "signal"), !o4(r2) && !a4(r2))
        throw new u4("stream", ["ReadableStream", "WritableStream", "Stream"], r2);
      return t.exports.addAbortSignalNoValidate(e8, r2);
    }, t.exports.addAbortSignalNoValidate = function(e8, t2) {
      if ("object" != typeof e8 || !("aborted" in e8))
        return t2;
      const r2 = o4(t2) ? () => {
        t2.destroy(new n4(void 0, { cause: e8.reason }));
      } : () => {
        t2[s3](new n4(void 0, { cause: e8.reason }));
      };
      return e8.aborted ? r2() : (e8.addEventListener("abort", r2), l6(t2, () => e8.removeEventListener("abort", r2))), t2;
    };
  }, { "../../ours/errors": 39, "./end-of-stream": 26, "./utils": 35 }], 21: [function(e7, t, r) {
    const { StringPrototypeSlice: n4, SymbolIterator: i4, TypedArrayPrototypeSet: o4, Uint8Array: a4 } = e7("../../ours/primordials"), { Buffer: s3 } = e7("buffer"), { inspect: l6 } = e7("../../ours/util");
    t.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e8) {
        const t2 = { data: e8, next: null };
        this.length > 0 ? this.tail.next = t2 : this.head = t2, this.tail = t2, ++this.length;
      }
      unshift(e8) {
        const t2 = { data: e8, next: this.head };
        0 === this.length && (this.tail = t2), this.head = t2, ++this.length;
      }
      shift() {
        if (0 === this.length)
          return;
        const e8 = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e8;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e8) {
        if (0 === this.length)
          return "";
        let t2 = this.head, r2 = "" + t2.data;
        for (; null !== (t2 = t2.next); )
          r2 += e8 + t2.data;
        return r2;
      }
      concat(e8) {
        if (0 === this.length)
          return s3.alloc(0);
        const t2 = s3.allocUnsafe(e8 >>> 0);
        let r2 = this.head, n5 = 0;
        for (; r2; )
          o4(t2, r2.data, n5), n5 += r2.data.length, r2 = r2.next;
        return t2;
      }
      consume(e8, t2) {
        const r2 = this.head.data;
        if (e8 < r2.length) {
          const t3 = r2.slice(0, e8);
          return this.head.data = r2.slice(e8), t3;
        }
        return e8 === r2.length ? this.shift() : t2 ? this._getString(e8) : this._getBuffer(e8);
      }
      first() {
        return this.head.data;
      }
      *[i4]() {
        for (let e8 = this.head; e8; e8 = e8.next)
          yield e8.data;
      }
      _getString(e8) {
        let t2 = "", r2 = this.head, i5 = 0;
        do {
          const o5 = r2.data;
          if (!(e8 > o5.length)) {
            e8 === o5.length ? (t2 += o5, ++i5, r2.next ? this.head = r2.next : this.head = this.tail = null) : (t2 += n4(o5, 0, e8), this.head = r2, r2.data = n4(o5, e8));
            break;
          }
          t2 += o5, e8 -= o5.length, ++i5;
        } while (null !== (r2 = r2.next));
        return this.length -= i5, t2;
      }
      _getBuffer(e8) {
        const t2 = s3.allocUnsafe(e8), r2 = e8;
        let n5 = this.head, i5 = 0;
        do {
          const s4 = n5.data;
          if (!(e8 > s4.length)) {
            e8 === s4.length ? (o4(t2, s4, r2 - e8), ++i5, n5.next ? this.head = n5.next : this.head = this.tail = null) : (o4(t2, new a4(s4.buffer, s4.byteOffset, e8), r2 - e8), this.head = n5, n5.data = s4.slice(e8));
            break;
          }
          o4(t2, s4, r2 - e8), e8 -= s4.length, ++i5;
        } while (null !== (n5 = n5.next));
        return this.length -= i5, t2;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e8, t2) {
        return l6(this, { ...t2, depth: 0, customInspect: false });
      }
    };
  }, { "../../ours/primordials": 40, "../../ours/util": 41, buffer: 15 }], 22: [function(e7, t, r) {
    const { pipeline: n4 } = e7("./pipeline"), i4 = e7("./duplex"), { destroyer: o4 } = e7("./destroy"), { isNodeStream: a4, isReadable: s3, isWritable: l6, isWebStream: u4, isTransformStream: c3, isWritableStream: d5, isReadableStream: h6 } = e7("./utils"), { AbortError: f5, codes: { ERR_INVALID_ARG_VALUE: p6, ERR_MISSING_ARGS: m5 } } = e7("../../ours/errors"), y5 = e7("./end-of-stream");
    t.exports = function(...e8) {
      if (0 === e8.length)
        throw new m5("streams");
      if (1 === e8.length)
        return i4.from(e8[0]);
      const t2 = [...e8];
      if ("function" == typeof e8[0] && (e8[0] = i4.from(e8[0])), "function" == typeof e8[e8.length - 1]) {
        const t3 = e8.length - 1;
        e8[t3] = i4.from(e8[t3]);
      }
      for (let r3 = 0; r3 < e8.length; ++r3)
        if (a4(e8[r3]) || u4(e8[r3])) {
          if (r3 < e8.length - 1 && !(s3(e8[r3]) || h6(e8[r3]) || c3(e8[r3])))
            throw new p6(`streams[${r3}]`, t2[r3], "must be readable");
          if (r3 > 0 && !(l6(e8[r3]) || d5(e8[r3]) || c3(e8[r3])))
            throw new p6(`streams[${r3}]`, t2[r3], "must be writable");
        }
      let r2, g5, v6, w5, b7;
      function _5(e9) {
        const t3 = w5;
        w5 = null, t3 ? t3(e9) : e9 ? b7.destroy(e9) : I5 || x6 || b7.destroy();
      }
      const E4 = e8[0], T6 = n4(e8, _5), x6 = !!(l6(E4) || d5(E4) || c3(E4)), I5 = !!(s3(T6) || h6(T6) || c3(T6));
      if (b7 = new i4({ writableObjectMode: !(null == E4 || !E4.writableObjectMode), readableObjectMode: !(null == T6 || !T6.writableObjectMode), writable: x6, readable: I5 }), x6) {
        if (a4(E4))
          b7._write = function(e10, t3, n5) {
            E4.write(e10, t3) ? n5() : r2 = n5;
          }, b7._final = function(e10) {
            E4.end(), g5 = e10;
          }, E4.on("drain", function() {
            if (r2) {
              const e10 = r2;
              r2 = null, e10();
            }
          });
        else if (u4(E4)) {
          const e10 = (c3(E4) ? E4.writable : E4).getWriter();
          b7._write = async function(t3, r3, n5) {
            try {
              await e10.ready, e10.write(t3).catch(() => {
              }), n5();
            } catch (e11) {
              n5(e11);
            }
          }, b7._final = async function(t3) {
            try {
              await e10.ready, e10.close().catch(() => {
              }), g5 = t3;
            } catch (e11) {
              t3(e11);
            }
          };
        }
        const e9 = c3(T6) ? T6.readable : T6;
        y5(e9, () => {
          if (g5) {
            const e10 = g5;
            g5 = null, e10();
          }
        });
      }
      if (I5) {
        if (a4(T6))
          T6.on("readable", function() {
            if (v6) {
              const e9 = v6;
              v6 = null, e9();
            }
          }), T6.on("end", function() {
            b7.push(null);
          }), b7._read = function() {
            for (; ; ) {
              const e9 = T6.read();
              if (null === e9)
                return void (v6 = b7._read);
              if (!b7.push(e9))
                return;
            }
          };
        else if (u4(T6)) {
          const e9 = (c3(T6) ? T6.readable : T6).getReader();
          b7._read = async function() {
            for (; ; )
              try {
                const { value: t3, done: r3 } = await e9.read();
                if (!b7.push(t3))
                  return;
                if (r3)
                  return void b7.push(null);
              } catch {
                return;
              }
          };
        }
      }
      return b7._destroy = function(e9, t3) {
        e9 || null === w5 || (e9 = new f5()), v6 = null, r2 = null, g5 = null, null === w5 ? t3(e9) : (w5 = t3, a4(T6) && o4(T6, e9));
      }, b7;
    };
  }, { "../../ours/errors": 39, "./destroy": 23, "./duplex": 24, "./end-of-stream": 26, "./pipeline": 31, "./utils": 35 }], 23: [function(e7, t, r) {
    const n4 = e7("process/"), { aggregateTwoErrors: i4, codes: { ERR_MULTIPLE_CALLBACK: o4 }, AbortError: a4 } = e7("../../ours/errors"), { Symbol: s3 } = e7("../../ours/primordials"), { kDestroyed: l6, isDestroyed: u4, isFinished: c3, isServerRequest: d5 } = e7("./utils"), h6 = s3("kDestroy"), f5 = s3("kConstruct");
    function p6(e8, t2, r2) {
      e8 && (t2 && !t2.errored && (t2.errored = e8), r2 && !r2.errored && (r2.errored = e8));
    }
    function m5(e8, t2) {
      const r2 = this._readableState, n5 = this._writableState, o5 = n5 || r2;
      return null != n5 && n5.destroyed || null != r2 && r2.destroyed ? ("function" == typeof t2 && t2(), this) : (p6(e8, n5, r2), n5 && (n5.destroyed = true), r2 && (r2.destroyed = true), o5.constructed ? y5(this, e8, t2) : this.once(h6, function(r3) {
        y5(this, i4(r3, e8), t2);
      }), this);
    }
    function y5(e8, t2, r2) {
      let i5 = false;
      function o5(t3) {
        if (i5)
          return;
        i5 = true;
        const o6 = e8._readableState, a5 = e8._writableState;
        p6(t3, a5, o6), a5 && (a5.closed = true), o6 && (o6.closed = true), "function" == typeof r2 && r2(t3), t3 ? n4.nextTick(g5, e8, t3) : n4.nextTick(v6, e8);
      }
      try {
        e8._destroy(t2 || null, o5);
      } catch (t3) {
        o5(t3);
      }
    }
    function g5(e8, t2) {
      w5(e8, t2), v6(e8);
    }
    function v6(e8) {
      const t2 = e8._readableState, r2 = e8._writableState;
      r2 && (r2.closeEmitted = true), t2 && (t2.closeEmitted = true), (null != r2 && r2.emitClose || null != t2 && t2.emitClose) && e8.emit("close");
    }
    function w5(e8, t2) {
      const r2 = e8._readableState, n5 = e8._writableState;
      null != n5 && n5.errorEmitted || null != r2 && r2.errorEmitted || (n5 && (n5.errorEmitted = true), r2 && (r2.errorEmitted = true), e8.emit("error", t2));
    }
    function b7() {
      const e8 = this._readableState, t2 = this._writableState;
      e8 && (e8.constructed = true, e8.closed = false, e8.closeEmitted = false, e8.destroyed = false, e8.errored = null, e8.errorEmitted = false, e8.reading = false, e8.ended = false === e8.readable, e8.endEmitted = false === e8.readable), t2 && (t2.constructed = true, t2.destroyed = false, t2.closed = false, t2.closeEmitted = false, t2.errored = null, t2.errorEmitted = false, t2.finalCalled = false, t2.prefinished = false, t2.ended = false === t2.writable, t2.ending = false === t2.writable, t2.finished = false === t2.writable);
    }
    function _5(e8, t2, r2) {
      const i5 = e8._readableState, o5 = e8._writableState;
      if (null != o5 && o5.destroyed || null != i5 && i5.destroyed)
        return this;
      null != i5 && i5.autoDestroy || null != o5 && o5.autoDestroy ? e8.destroy(t2) : t2 && (o5 && !o5.errored && (o5.errored = t2), i5 && !i5.errored && (i5.errored = t2), r2 ? n4.nextTick(w5, e8, t2) : w5(e8, t2));
    }
    function E4(e8, t2) {
      if ("function" != typeof e8._construct)
        return;
      const r2 = e8._readableState, i5 = e8._writableState;
      r2 && (r2.constructed = false), i5 && (i5.constructed = false), e8.once(f5, t2), e8.listenerCount(f5) > 1 || n4.nextTick(T6, e8);
    }
    function T6(e8) {
      let t2 = false;
      function r2(r3) {
        if (t2)
          return void _5(e8, null != r3 ? r3 : new o4());
        t2 = true;
        const i5 = e8._readableState, a5 = e8._writableState, s4 = a5 || i5;
        i5 && (i5.constructed = true), a5 && (a5.constructed = true), s4.destroyed ? e8.emit(h6, r3) : r3 ? _5(e8, r3, true) : n4.nextTick(x6, e8);
      }
      try {
        e8._construct((e9) => {
          n4.nextTick(r2, e9);
        });
      } catch (e9) {
        n4.nextTick(r2, e9);
      }
    }
    function x6(e8) {
      e8.emit(f5);
    }
    function I5(e8) {
      return (null == e8 ? void 0 : e8.setHeader) && "function" == typeof e8.abort;
    }
    function S6(e8) {
      e8.emit("close");
    }
    function R5(e8, t2) {
      e8.emit("error", t2), n4.nextTick(S6, e8);
    }
    function k5(e8, t2) {
      e8 && !u4(e8) && (t2 || c3(e8) || (t2 = new a4()), d5(e8) ? (e8.socket = null, e8.destroy(t2)) : I5(e8) ? e8.abort() : I5(e8.req) ? e8.req.abort() : "function" == typeof e8.destroy ? e8.destroy(t2) : "function" == typeof e8.close ? e8.close() : t2 ? n4.nextTick(R5, e8, t2) : n4.nextTick(S6, e8), e8.destroyed || (e8[l6] = true));
    }
    t.exports = { construct: E4, destroyer: k5, destroy: m5, undestroy: b7, errorOrDestroy: _5 };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "./utils": 35, "process/": 18 }], 24: [function(e7, t, r) {
    const { ObjectDefineProperties: n4, ObjectGetOwnPropertyDescriptor: i4, ObjectKeys: o4, ObjectSetPrototypeOf: a4 } = e7("../../ours/primordials");
    t.exports = u4;
    const s3 = e7("./readable"), l6 = e7("./writable");
    a4(u4.prototype, s3.prototype), a4(u4, s3);
    {
      const e8 = o4(l6.prototype);
      for (let t2 = 0; t2 < e8.length; t2++) {
        const r2 = e8[t2];
        u4.prototype[r2] || (u4.prototype[r2] = l6.prototype[r2]);
      }
    }
    function u4(e8) {
      if (!(this instanceof u4))
        return new u4(e8);
      s3.call(this, e8), l6.call(this, e8), e8 ? (this.allowHalfOpen = false !== e8.allowHalfOpen, false === e8.readable && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === e8.writable && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    let c3, d5;
    function h6() {
      return void 0 === c3 && (c3 = {}), c3;
    }
    n4(u4.prototype, { writable: { __proto__: null, ...i4(l6.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...i4(l6.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...i4(l6.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...i4(l6.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...i4(l6.prototype, "writableLength") }, writableFinished: { __proto__: null, ...i4(l6.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...i4(l6.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...i4(l6.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...i4(l6.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
    }, set(e8) {
      this._readableState && this._writableState && (this._readableState.destroyed = e8, this._writableState.destroyed = e8);
    } } }), u4.fromWeb = function(e8, t2) {
      return h6().newStreamDuplexFromReadableWritablePair(e8, t2);
    }, u4.toWeb = function(e8) {
      return h6().newReadableWritablePairFromDuplex(e8);
    }, u4.from = function(t2) {
      return d5 || (d5 = e7("./duplexify")), d5(t2, "body");
    };
  }, { "../../ours/primordials": 40, "./duplexify": 25, "./readable": 32, "./writable": 36 }], 25: [function(e7, t, r) {
    const n4 = e7("process/"), i4 = e7("buffer"), { isReadable: o4, isWritable: a4, isIterable: s3, isNodeStream: l6, isReadableNodeStream: u4, isWritableNodeStream: c3, isDuplexNodeStream: d5 } = e7("./utils"), h6 = e7("./end-of-stream"), { AbortError: f5, codes: { ERR_INVALID_ARG_TYPE: p6, ERR_INVALID_RETURN_VALUE: m5 } } = e7("../../ours/errors"), { destroyer: y5 } = e7("./destroy"), g5 = e7("./duplex"), v6 = e7("./readable"), { createDeferredPromise: w5 } = e7("../../ours/util"), b7 = e7("./from"), _5 = globalThis.Blob || i4.Blob, E4 = void 0 !== _5 ? function(e8) {
      return e8 instanceof _5;
    } : function(e8) {
      return false;
    }, T6 = globalThis.AbortController || e7("abort-controller").AbortController, { FunctionPrototypeCall: x6 } = e7("../../ours/primordials");
    class I5 extends g5 {
      constructor(e8) {
        super(e8), false === (null == e8 ? void 0 : e8.readable) && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), false === (null == e8 ? void 0 : e8.writable) && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    }
    function S6(e8) {
      let { promise: t2, resolve: r2 } = w5();
      const i5 = new T6(), o5 = i5.signal;
      return { value: e8(async function* () {
        for (; ; ) {
          const e9 = t2;
          t2 = null;
          const { chunk: i6, done: a5, cb: s4 } = await e9;
          if (n4.nextTick(s4), a5)
            return;
          if (o5.aborted)
            throw new f5(void 0, { cause: o5.reason });
          ({ promise: t2, resolve: r2 } = w5()), yield i6;
        }
      }(), { signal: o5 }), write(e9, t3, n5) {
        const i6 = r2;
        r2 = null, i6({ chunk: e9, done: false, cb: n5 });
      }, final(e9) {
        const t3 = r2;
        r2 = null, t3({ done: true, cb: e9 });
      }, destroy(e9, t3) {
        i5.abort(), t3(e9);
      } };
    }
    function R5(e8) {
      const t2 = e8.readable && "function" != typeof e8.readable.read ? v6.wrap(e8.readable) : e8.readable, r2 = e8.writable;
      let n5, i5, s4, l7, u5, c4 = !!o4(t2), d6 = !!a4(r2);
      function p7(e9) {
        const t3 = l7;
        l7 = null, t3 ? t3(e9) : e9 && u5.destroy(e9);
      }
      return u5 = new I5({ readableObjectMode: !(null == t2 || !t2.readableObjectMode), writableObjectMode: !(null == r2 || !r2.writableObjectMode), readable: c4, writable: d6 }), d6 && (h6(r2, (e9) => {
        d6 = false, e9 && y5(t2, e9), p7(e9);
      }), u5._write = function(e9, t3, i6) {
        r2.write(e9, t3) ? i6() : n5 = i6;
      }, u5._final = function(e9) {
        r2.end(), i5 = e9;
      }, r2.on("drain", function() {
        if (n5) {
          const e9 = n5;
          n5 = null, e9();
        }
      }), r2.on("finish", function() {
        if (i5) {
          const e9 = i5;
          i5 = null, e9();
        }
      })), c4 && (h6(t2, (e9) => {
        c4 = false, e9 && y5(t2, e9), p7(e9);
      }), t2.on("readable", function() {
        if (s4) {
          const e9 = s4;
          s4 = null, e9();
        }
      }), t2.on("end", function() {
        u5.push(null);
      }), u5._read = function() {
        for (; ; ) {
          const e9 = t2.read();
          if (null === e9)
            return void (s4 = u5._read);
          if (!u5.push(e9))
            return;
        }
      }), u5._destroy = function(e9, o5) {
        e9 || null === l7 || (e9 = new f5()), s4 = null, n5 = null, i5 = null, null === l7 ? o5(e9) : (l7 = o5, y5(r2, e9), y5(t2, e9));
      }, u5;
    }
    t.exports = function e8(t2, r2) {
      if (d5(t2))
        return t2;
      if (u4(t2))
        return R5({ readable: t2 });
      if (c3(t2))
        return R5({ writable: t2 });
      if (l6(t2))
        return R5({ writable: false, readable: false });
      if ("function" == typeof t2) {
        const { value: e9, write: i6, final: o5, destroy: a5 } = S6(t2);
        if (s3(e9))
          return b7(I5, e9, { objectMode: true, write: i6, final: o5, destroy: a5 });
        const l7 = null == e9 ? void 0 : e9.then;
        if ("function" == typeof l7) {
          let t3;
          const r3 = x6(l7, e9, (e10) => {
            if (null != e10)
              throw new m5("nully", "body", e10);
          }, (e10) => {
            y5(t3, e10);
          });
          return t3 = new I5({ objectMode: true, readable: false, write: i6, final(e10) {
            o5(async () => {
              try {
                await r3, n4.nextTick(e10, null);
              } catch (t4) {
                n4.nextTick(e10, t4);
              }
            });
          }, destroy: a5 });
        }
        throw new m5("Iterable, AsyncIterable or AsyncFunction", r2, e9);
      }
      if (E4(t2))
        return e8(t2.arrayBuffer());
      if (s3(t2))
        return b7(I5, t2, { objectMode: true, writable: false });
      if ("object" == typeof (null == t2 ? void 0 : t2.writable) || "object" == typeof (null == t2 ? void 0 : t2.readable))
        return R5({ readable: null != t2 && t2.readable ? u4(null == t2 ? void 0 : t2.readable) ? null == t2 ? void 0 : t2.readable : e8(t2.readable) : void 0, writable: null != t2 && t2.writable ? c3(null == t2 ? void 0 : t2.writable) ? null == t2 ? void 0 : t2.writable : e8(t2.writable) : void 0 });
      const i5 = null == t2 ? void 0 : t2.then;
      if ("function" == typeof i5) {
        let e9;
        return x6(i5, t2, (t3) => {
          null != t3 && e9.push(t3), e9.push(null);
        }, (t3) => {
          y5(e9, t3);
        }), e9 = new I5({ objectMode: true, writable: false, read() {
        } });
      }
      throw new p6(r2, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t2);
    };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "../../ours/util": 41, "./destroy": 23, "./duplex": 24, "./end-of-stream": 26, "./from": 27, "./readable": 32, "./utils": 35, "abort-controller": 11, buffer: 15, "process/": 18 }], 26: [function(e7, t, r) {
    const n4 = e7("process/"), { AbortError: i4, codes: o4 } = e7("../../ours/errors"), { ERR_INVALID_ARG_TYPE: a4, ERR_STREAM_PREMATURE_CLOSE: s3 } = o4, { kEmptyObject: l6, once: u4 } = e7("../../ours/util"), { validateAbortSignal: c3, validateFunction: d5, validateObject: h6, validateBoolean: f5 } = e7("../validators"), { Promise: p6, PromisePrototypeThen: m5 } = e7("../../ours/primordials"), { isClosed: y5, isReadable: g5, isReadableNodeStream: v6, isReadableStream: w5, isReadableFinished: b7, isReadableErrored: _5, isWritable: E4, isWritableNodeStream: T6, isWritableStream: x6, isWritableFinished: I5, isWritableErrored: S6, isNodeStream: R5, willEmitClose: k5, kIsClosedPromise: j5 } = e7("./utils");
    function D4(e8) {
      return e8.setHeader && "function" == typeof e8.abort;
    }
    const N10 = () => {
    };
    function O3(e8, t2, r2) {
      var o5, f6;
      if (2 === arguments.length ? (r2 = t2, t2 = l6) : null == t2 ? t2 = l6 : h6(t2, "options"), d5(r2, "callback"), c3(t2.signal, "options.signal"), r2 = u4(r2), w5(e8) || x6(e8))
        return C5(e8, t2, r2);
      if (!R5(e8))
        throw new a4("stream", ["ReadableStream", "WritableStream", "Stream"], e8);
      const p7 = null !== (o5 = t2.readable) && void 0 !== o5 ? o5 : v6(e8), m6 = null !== (f6 = t2.writable) && void 0 !== f6 ? f6 : T6(e8), j6 = e8._writableState, O4 = e8._readableState, A6 = () => {
        e8.writable || P5();
      };
      let M6 = k5(e8) && v6(e8) === p7 && T6(e8) === m6, L4 = I5(e8, false);
      const P5 = () => {
        L4 = true, e8.destroyed && (M6 = false), (!M6 || e8.readable && !p7) && (p7 && !B6 || r2.call(e8));
      };
      let B6 = b7(e8, false);
      const $4 = () => {
        B6 = true, e8.destroyed && (M6 = false), (!M6 || e8.writable && !m6) && (m6 && !L4 || r2.call(e8));
      }, F4 = (t3) => {
        r2.call(e8, t3);
      };
      let U6 = y5(e8);
      const q5 = () => {
        U6 = true;
        const t3 = S6(e8) || _5(e8);
        return t3 && "boolean" != typeof t3 ? r2.call(e8, t3) : p7 && !B6 && v6(e8, true) && !b7(e8, false) ? r2.call(e8, new s3()) : !m6 || L4 || I5(e8, false) ? void r2.call(e8) : r2.call(e8, new s3());
      }, Y5 = () => {
        U6 = true;
        const t3 = S6(e8) || _5(e8);
        if (t3 && "boolean" != typeof t3)
          return r2.call(e8, t3);
        r2.call(e8);
      }, W5 = () => {
        e8.req.on("finish", P5);
      };
      D4(e8) ? (e8.on("complete", P5), M6 || e8.on("abort", q5), e8.req ? W5() : e8.on("request", W5)) : m6 && !j6 && (e8.on("end", A6), e8.on("close", A6)), M6 || "boolean" != typeof e8.aborted || e8.on("aborted", q5), e8.on("end", $4), e8.on("finish", P5), false !== t2.error && e8.on("error", F4), e8.on("close", q5), U6 ? n4.nextTick(q5) : null != j6 && j6.errorEmitted || null != O4 && O4.errorEmitted ? M6 || n4.nextTick(Y5) : (p7 || M6 && !g5(e8) || !L4 && false !== E4(e8)) && (m6 || M6 && !E4(e8) || !B6 && false !== g5(e8)) ? O4 && e8.req && e8.aborted && n4.nextTick(Y5) : n4.nextTick(Y5);
      const z6 = () => {
        r2 = N10, e8.removeListener("aborted", q5), e8.removeListener("complete", P5), e8.removeListener("abort", q5), e8.removeListener("request", W5), e8.req && e8.req.removeListener("finish", P5), e8.removeListener("end", A6), e8.removeListener("close", A6), e8.removeListener("finish", P5), e8.removeListener("end", $4), e8.removeListener("error", F4), e8.removeListener("close", q5);
      };
      if (t2.signal && !U6) {
        const o6 = () => {
          const n5 = r2;
          z6(), n5.call(e8, new i4(void 0, { cause: t2.signal.reason }));
        };
        if (t2.signal.aborted)
          n4.nextTick(o6);
        else {
          const n5 = r2;
          r2 = u4((...r3) => {
            t2.signal.removeEventListener("abort", o6), n5.apply(e8, r3);
          }), t2.signal.addEventListener("abort", o6);
        }
      }
      return z6;
    }
    function C5(e8, t2, r2) {
      let o5 = false, a5 = N10;
      if (t2.signal)
        if (a5 = () => {
          o5 = true, r2.call(e8, new i4(void 0, { cause: t2.signal.reason }));
        }, t2.signal.aborted)
          n4.nextTick(a5);
        else {
          const n5 = r2;
          r2 = u4((...r3) => {
            t2.signal.removeEventListener("abort", a5), n5.apply(e8, r3);
          }), t2.signal.addEventListener("abort", a5);
        }
      const s4 = (...t3) => {
        o5 || n4.nextTick(() => r2.apply(e8, t3));
      };
      return m5(e8[j5].promise, s4, s4), N10;
    }
    function A5(e8, t2) {
      var r2;
      let n5 = false;
      return null === t2 && (t2 = l6), null !== (r2 = t2) && void 0 !== r2 && r2.cleanup && (f5(t2.cleanup, "cleanup"), n5 = t2.cleanup), new p6((r3, i5) => {
        const o5 = O3(e8, t2, (e9) => {
          n5 && o5(), e9 ? i5(e9) : r3();
        });
      });
    }
    t.exports = O3, t.exports.finished = A5;
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "../../ours/util": 41, "../validators": 37, "./utils": 35, "process/": 18 }], 27: [function(e7, t, r) {
    const n4 = e7("process/"), { PromisePrototypeThen: i4, SymbolAsyncIterator: o4, SymbolIterator: a4 } = e7("../../ours/primordials"), { Buffer: s3 } = e7("buffer"), { ERR_INVALID_ARG_TYPE: l6, ERR_STREAM_NULL_VALUES: u4 } = e7("../../ours/errors").codes;
    function c3(e8, t2, r2) {
      let c4, d5;
      if ("string" == typeof t2 || t2 instanceof s3)
        return new e8({ objectMode: true, ...r2, read() {
          this.push(t2), this.push(null);
        } });
      if (t2 && t2[o4])
        d5 = true, c4 = t2[o4]();
      else {
        if (!t2 || !t2[a4])
          throw new l6("iterable", ["Iterable"], t2);
        d5 = false, c4 = t2[a4]();
      }
      const h6 = new e8({ objectMode: true, highWaterMark: 1, ...r2 });
      let f5 = false;
      async function p6(e9) {
        const t3 = null != e9, r3 = "function" == typeof c4.throw;
        if (t3 && r3) {
          const { value: t4, done: r4 } = await c4.throw(e9);
          if (await t4, r4)
            return;
        }
        if ("function" == typeof c4.return) {
          const { value: e10 } = await c4.return();
          await e10;
        }
      }
      async function m5() {
        for (; ; ) {
          try {
            const { value: e9, done: t3 } = d5 ? await c4.next() : c4.next();
            if (t3)
              h6.push(null);
            else {
              const t4 = e9 && "function" == typeof e9.then ? await e9 : e9;
              if (null === t4)
                throw f5 = false, new u4();
              if (h6.push(t4))
                continue;
              f5 = false;
            }
          } catch (e9) {
            h6.destroy(e9);
          }
          break;
        }
      }
      return h6._read = function() {
        f5 || (f5 = true, m5());
      }, h6._destroy = function(e9, t3) {
        i4(p6(e9), () => n4.nextTick(t3, e9), (r3) => n4.nextTick(t3, r3 || e9));
      }, h6;
    }
    t.exports = c3;
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, buffer: 15, "process/": 18 }], 28: [function(e7, t, r) {
    const { ArrayIsArray: n4, ObjectSetPrototypeOf: i4 } = e7("../../ours/primordials"), { EventEmitter: o4 } = e7("events");
    function a4(e8) {
      o4.call(this, e8);
    }
    function s3(e8, t2, r2) {
      if ("function" == typeof e8.prependListener)
        return e8.prependListener(t2, r2);
      e8._events && e8._events[t2] ? n4(e8._events[t2]) ? e8._events[t2].unshift(r2) : e8._events[t2] = [r2, e8._events[t2]] : e8.on(t2, r2);
    }
    i4(a4.prototype, o4.prototype), i4(a4, o4), a4.prototype.pipe = function(e8, t2) {
      const r2 = this;
      function n5(t3) {
        e8.writable && false === e8.write(t3) && r2.pause && r2.pause();
      }
      function i5() {
        r2.readable && r2.resume && r2.resume();
      }
      r2.on("data", n5), e8.on("drain", i5), e8._isStdio || t2 && false === t2.end || (r2.on("end", l6), r2.on("close", u4));
      let a5 = false;
      function l6() {
        a5 || (a5 = true, e8.end());
      }
      function u4() {
        a5 || (a5 = true, "function" == typeof e8.destroy && e8.destroy());
      }
      function c3(e9) {
        d5(), 0 === o4.listenerCount(this, "error") && this.emit("error", e9);
      }
      function d5() {
        r2.removeListener("data", n5), e8.removeListener("drain", i5), r2.removeListener("end", l6), r2.removeListener("close", u4), r2.removeListener("error", c3), e8.removeListener("error", c3), r2.removeListener("end", d5), r2.removeListener("close", d5), e8.removeListener("close", d5);
      }
      return s3(r2, "error", c3), s3(e8, "error", c3), r2.on("end", d5), r2.on("close", d5), e8.on("close", d5), e8.emit("pipe", r2), e8;
    }, t.exports = { Stream: a4, prependListener: s3 };
  }, { "../../ours/primordials": 40, events: 16 }], 29: [function(e7, t, r) {
    const n4 = globalThis.AbortController || e7("abort-controller").AbortController, { codes: { ERR_INVALID_ARG_VALUE: i4, ERR_INVALID_ARG_TYPE: o4, ERR_MISSING_ARGS: a4, ERR_OUT_OF_RANGE: s3 }, AbortError: l6 } = e7("../../ours/errors"), { validateAbortSignal: u4, validateInteger: c3, validateObject: d5 } = e7("../validators"), h6 = e7("../../ours/primordials").Symbol("kWeak"), { finished: f5 } = e7("./end-of-stream"), p6 = e7("./compose"), { addAbortSignalNoValidate: m5 } = e7("./add-abort-signal"), { isWritable: y5, isNodeStream: g5 } = e7("./utils"), { ArrayPrototypePush: v6, MathFloor: w5, Number: b7, NumberIsNaN: _5, Promise: E4, PromiseReject: T6, PromisePrototypeThen: x6, Symbol: I5 } = e7("../../ours/primordials"), S6 = I5("kEmpty"), R5 = I5("kEof");
    function k5(e8, t2) {
      if (null != t2 && d5(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u4(t2.signal, "options.signal"), g5(e8) && !y5(e8))
        throw new i4("stream", e8, "must be writable");
      const r2 = p6(this, e8);
      return null != t2 && t2.signal && m5(t2.signal, r2), r2;
    }
    function j5(e8, t2) {
      if ("function" != typeof e8)
        throw new o4("fn", ["Function", "AsyncFunction"], e8);
      null != t2 && d5(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u4(t2.signal, "options.signal");
      let r2 = 1;
      return null != (null == t2 ? void 0 : t2.concurrency) && (r2 = w5(t2.concurrency)), c3(r2, "concurrency", 1), async function* () {
        var i5, o5;
        const a5 = new n4(), s4 = this, u5 = [], c4 = a5.signal, d6 = { signal: c4 }, h7 = () => a5.abort();
        let f6, p7;
        null != t2 && null !== (i5 = t2.signal) && void 0 !== i5 && i5.aborted && h7(), null == t2 || null === (o5 = t2.signal) || void 0 === o5 || o5.addEventListener("abort", h7);
        let m6 = false;
        function y6() {
          m6 = true;
        }
        async function g6() {
          try {
            for await (let t3 of s4) {
              var n5;
              if (m6)
                return;
              if (c4.aborted)
                throw new l6();
              try {
                t3 = e8(t3, d6);
              } catch (e9) {
                t3 = T6(e9);
              }
              t3 !== S6 && ("function" == typeof (null === (n5 = t3) || void 0 === n5 ? void 0 : n5.catch) && t3.catch(y6), u5.push(t3), f6 && (f6(), f6 = null), !m6 && u5.length && u5.length >= r2 && await new E4((e9) => {
                p7 = e9;
              }));
            }
            u5.push(R5);
          } catch (e9) {
            const t3 = T6(e9);
            x6(t3, void 0, y6), u5.push(t3);
          } finally {
            var i6;
            m6 = true, f6 && (f6(), f6 = null), null == t2 || null === (i6 = t2.signal) || void 0 === i6 || i6.removeEventListener("abort", h7);
          }
        }
        g6();
        try {
          for (; ; ) {
            for (; u5.length > 0; ) {
              const e9 = await u5[0];
              if (e9 === R5)
                return;
              if (c4.aborted)
                throw new l6();
              e9 !== S6 && (yield e9), u5.shift(), p7 && (p7(), p7 = null);
            }
            await new E4((e9) => {
              f6 = e9;
            });
          }
        } finally {
          a5.abort(), m6 = true, p7 && (p7(), p7 = null);
        }
      }.call(this);
    }
    function D4(e8 = void 0) {
      return null != e8 && d5(e8, "options"), null != (null == e8 ? void 0 : e8.signal) && u4(e8.signal, "options.signal"), async function* () {
        let t2 = 0;
        for await (const n5 of this) {
          var r2;
          if (null != e8 && null !== (r2 = e8.signal) && void 0 !== r2 && r2.aborted)
            throw new l6({ cause: e8.signal.reason });
          yield [t2++, n5];
        }
      }.call(this);
    }
    async function N10(e8, t2 = void 0) {
      for await (const r2 of M6.call(this, e8, t2))
        return true;
      return false;
    }
    async function O3(e8, t2 = void 0) {
      if ("function" != typeof e8)
        throw new o4("fn", ["Function", "AsyncFunction"], e8);
      return !await N10.call(this, async (...t3) => !await e8(...t3), t2);
    }
    async function C5(e8, t2) {
      for await (const r2 of M6.call(this, e8, t2))
        return r2;
    }
    async function A5(e8, t2) {
      if ("function" != typeof e8)
        throw new o4("fn", ["Function", "AsyncFunction"], e8);
      async function r2(t3, r3) {
        return await e8(t3, r3), S6;
      }
      for await (const e9 of j5.call(this, r2, t2))
        ;
    }
    function M6(e8, t2) {
      if ("function" != typeof e8)
        throw new o4("fn", ["Function", "AsyncFunction"], e8);
      async function r2(t3, r3) {
        return await e8(t3, r3) ? t3 : S6;
      }
      return j5.call(this, r2, t2);
    }
    class L4 extends a4 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    }
    async function P5(e8, t2, r2) {
      var i5;
      if ("function" != typeof e8)
        throw new o4("reducer", ["Function", "AsyncFunction"], e8);
      null != r2 && d5(r2, "options"), null != (null == r2 ? void 0 : r2.signal) && u4(r2.signal, "options.signal");
      let a5 = arguments.length > 1;
      if (null != r2 && null !== (i5 = r2.signal) && void 0 !== i5 && i5.aborted) {
        const e9 = new l6(void 0, { cause: r2.signal.reason });
        throw this.once("error", () => {
        }), await f5(this.destroy(e9)), e9;
      }
      const s4 = new n4(), c4 = s4.signal;
      if (null != r2 && r2.signal) {
        const e9 = { once: true, [h6]: this };
        r2.signal.addEventListener("abort", () => s4.abort(), e9);
      }
      let p7 = false;
      try {
        for await (const n5 of this) {
          var m6;
          if (p7 = true, null != r2 && null !== (m6 = r2.signal) && void 0 !== m6 && m6.aborted)
            throw new l6();
          a5 ? t2 = await e8(t2, n5, { signal: c4 }) : (t2 = n5, a5 = true);
        }
        if (!p7 && !a5)
          throw new L4();
      } finally {
        s4.abort();
      }
      return t2;
    }
    async function B6(e8) {
      null != e8 && d5(e8, "options"), null != (null == e8 ? void 0 : e8.signal) && u4(e8.signal, "options.signal");
      const t2 = [];
      for await (const n5 of this) {
        var r2;
        if (null != e8 && null !== (r2 = e8.signal) && void 0 !== r2 && r2.aborted)
          throw new l6(void 0, { cause: e8.signal.reason });
        v6(t2, n5);
      }
      return t2;
    }
    function $4(e8, t2) {
      const r2 = j5.call(this, e8, t2);
      return async function* () {
        for await (const e9 of r2)
          yield* e9;
      }.call(this);
    }
    function F4(e8) {
      if (e8 = b7(e8), _5(e8))
        return 0;
      if (e8 < 0)
        throw new s3("number", ">= 0", e8);
      return e8;
    }
    function U6(e8, t2 = void 0) {
      return null != t2 && d5(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u4(t2.signal, "options.signal"), e8 = F4(e8), async function* () {
        var r2;
        if (null != t2 && null !== (r2 = t2.signal) && void 0 !== r2 && r2.aborted)
          throw new l6();
        for await (const r3 of this) {
          var n5;
          if (null != t2 && null !== (n5 = t2.signal) && void 0 !== n5 && n5.aborted)
            throw new l6();
          e8-- <= 0 && (yield r3);
        }
      }.call(this);
    }
    function q5(e8, t2 = void 0) {
      return null != t2 && d5(t2, "options"), null != (null == t2 ? void 0 : t2.signal) && u4(t2.signal, "options.signal"), e8 = F4(e8), async function* () {
        var r2;
        if (null != t2 && null !== (r2 = t2.signal) && void 0 !== r2 && r2.aborted)
          throw new l6();
        for await (const r3 of this) {
          var n5;
          if (null != t2 && null !== (n5 = t2.signal) && void 0 !== n5 && n5.aborted)
            throw new l6();
          if (!(e8-- > 0))
            return;
          yield r3;
        }
      }.call(this);
    }
    t.exports.streamReturningOperators = { asIndexedPairs: D4, drop: U6, filter: M6, flatMap: $4, map: j5, take: q5, compose: k5 }, t.exports.promiseReturningOperators = { every: O3, forEach: A5, reduce: P5, toArray: B6, some: N10, find: C5 };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "../validators": 37, "./add-abort-signal": 20, "./compose": 22, "./end-of-stream": 26, "./utils": 35, "abort-controller": 11 }], 30: [function(e7, t, r) {
    const { ObjectSetPrototypeOf: n4 } = e7("../../ours/primordials");
    t.exports = o4;
    const i4 = e7("./transform");
    function o4(e8) {
      if (!(this instanceof o4))
        return new o4(e8);
      i4.call(this, e8);
    }
    n4(o4.prototype, i4.prototype), n4(o4, i4), o4.prototype._transform = function(e8, t2, r2) {
      r2(null, e8);
    };
  }, { "../../ours/primordials": 40, "./transform": 34 }], 31: [function(e7, t, r) {
    const n4 = e7("process/"), { ArrayIsArray: i4, Promise: o4, SymbolAsyncIterator: a4 } = e7("../../ours/primordials"), s3 = e7("./end-of-stream"), { once: l6 } = e7("../../ours/util"), u4 = e7("./destroy"), c3 = e7("./duplex"), { aggregateTwoErrors: d5, codes: { ERR_INVALID_ARG_TYPE: h6, ERR_INVALID_RETURN_VALUE: f5, ERR_MISSING_ARGS: p6, ERR_STREAM_DESTROYED: m5, ERR_STREAM_PREMATURE_CLOSE: y5 }, AbortError: g5 } = e7("../../ours/errors"), { validateFunction: v6, validateAbortSignal: w5 } = e7("../validators"), { isIterable: b7, isReadable: _5, isReadableNodeStream: E4, isNodeStream: T6, isTransformStream: x6, isWebStream: I5, isReadableStream: S6, isReadableEnded: R5 } = e7("./utils"), k5 = globalThis.AbortController || e7("abort-controller").AbortController;
    let j5, D4;
    function N10(e8, t2, r2) {
      let n5 = false;
      return e8.on("close", () => {
        n5 = true;
      }), { destroy: (t3) => {
        n5 || (n5 = true, u4.destroyer(e8, t3 || new m5("pipe")));
      }, cleanup: s3(e8, { readable: t2, writable: r2 }, (e9) => {
        n5 = !e9;
      }) };
    }
    function O3(e8) {
      return v6(e8[e8.length - 1], "streams[stream.length - 1]"), e8.pop();
    }
    function C5(e8) {
      if (b7(e8))
        return e8;
      if (E4(e8))
        return A5(e8);
      throw new h6("val", ["Readable", "Iterable", "AsyncIterable"], e8);
    }
    async function* A5(t2) {
      D4 || (D4 = e7("./readable")), yield* D4.prototype[a4].call(t2);
    }
    async function M6(e8, t2, r2, { end: n5 }) {
      let i5, a5 = null;
      const l7 = (e9) => {
        if (e9 && (i5 = e9), a5) {
          const e10 = a5;
          a5 = null, e10();
        }
      }, u5 = () => new o4((e9, t3) => {
        i5 ? t3(i5) : a5 = () => {
          i5 ? t3(i5) : e9();
        };
      });
      t2.on("drain", l7);
      const c4 = s3(t2, { readable: false }, l7);
      try {
        t2.writableNeedDrain && await u5();
        for await (const r3 of e8)
          t2.write(r3) || await u5();
        n5 && t2.end(), await u5(), r2();
      } catch (e9) {
        r2(i5 !== e9 ? d5(i5, e9) : e9);
      } finally {
        c4(), t2.off("drain", l7);
      }
    }
    async function L4(e8, t2, r2, { end: n5 }) {
      x6(t2) && (t2 = t2.writable);
      const i5 = t2.getWriter();
      try {
        for await (const t3 of e8)
          await i5.ready, i5.write(t3).catch(() => {
          });
        await i5.ready, n5 && await i5.close(), r2();
      } catch (e9) {
        try {
          await i5.abort(e9), r2(e9);
        } catch (e10) {
          r2(e10);
        }
      }
    }
    function P5(...e8) {
      return B6(e8, l6(O3(e8)));
    }
    function B6(t2, r2, o5) {
      if (1 === t2.length && i4(t2[0]) && (t2 = t2[0]), t2.length < 2)
        throw new p6("streams");
      const a5 = new k5(), s4 = a5.signal, l7 = null == o5 ? void 0 : o5.signal, u5 = [];
      function d6() {
        A6(new g5());
      }
      let m6, y6;
      w5(l7, "options.signal"), null == l7 || l7.addEventListener("abort", d6);
      const v7 = [];
      let R6, D5 = 0;
      function O4(e8) {
        A6(e8, 0 == --D5);
      }
      function A6(e8, t3) {
        if (!e8 || m6 && "ERR_STREAM_PREMATURE_CLOSE" !== m6.code || (m6 = e8), m6 || t3) {
          for (; v7.length; )
            v7.shift()(m6);
          null == l7 || l7.removeEventListener("abort", d6), a5.abort(), t3 && (m6 || u5.forEach((e9) => e9()), n4.nextTick(r2, m6, y6));
        }
      }
      for (let F4 = 0; F4 < t2.length; F4++) {
        const U6 = t2[F4], q5 = F4 < t2.length - 1, Y5 = F4 > 0, W5 = q5 || false !== (null == o5 ? void 0 : o5.end), z6 = F4 === t2.length - 1;
        if (T6(U6)) {
          let G7 = function(e8) {
            e8 && "AbortError" !== e8.name && "ERR_STREAM_PREMATURE_CLOSE" !== e8.code && O4(e8);
          };
          if (W5) {
            const { destroy: H4, cleanup: J4 } = N10(U6, q5, Y5);
            v7.push(H4), _5(U6) && z6 && u5.push(J4);
          }
          U6.on("error", G7), _5(U6) && z6 && u5.push(() => {
            U6.removeListener("error", G7);
          });
        }
        if (0 === F4)
          if ("function" == typeof U6) {
            if (R6 = U6({ signal: s4 }), !b7(R6))
              throw new f5("Iterable, AsyncIterable or Stream", "source", R6);
          } else
            R6 = b7(U6) || E4(U6) || x6(U6) ? U6 : c3.from(U6);
        else if ("function" == typeof U6) {
          var P6;
          if (R6 = x6(R6) ? C5(null === (P6 = R6) || void 0 === P6 ? void 0 : P6.readable) : C5(R6), R6 = U6(R6, { signal: s4 }), q5) {
            if (!b7(R6, true))
              throw new f5("AsyncIterable", `transform[${F4 - 1}]`, R6);
          } else {
            var B7;
            j5 || (j5 = e7("./passthrough"));
            const V5 = new j5({ objectMode: true }), Q5 = null === (B7 = R6) || void 0 === B7 ? void 0 : B7.then;
            if ("function" == typeof Q5)
              D5++, Q5.call(R6, (e8) => {
                y6 = e8, null != e8 && V5.write(e8), W5 && V5.end(), n4.nextTick(O4);
              }, (e8) => {
                V5.destroy(e8), n4.nextTick(O4, e8);
              });
            else if (b7(R6, true))
              D5++, M6(R6, V5, O4, { end: W5 });
            else {
              if (!S6(R6) && !x6(R6))
                throw new f5("AsyncIterable or Promise", "destination", R6);
              {
                const X5 = R6.readable || R6;
                D5++, M6(X5, V5, O4, { end: W5 });
              }
            }
            R6 = V5;
            const { destroy: Z5, cleanup: K4 } = N10(R6, false, true);
            v7.push(Z5), z6 && u5.push(K4);
          }
        } else if (T6(U6)) {
          if (E4(R6)) {
            D5 += 2;
            const ee2 = $4(R6, U6, O4, { end: W5 });
            _5(U6) && z6 && u5.push(ee2);
          } else if (x6(R6) || S6(R6)) {
            const te2 = R6.readable || R6;
            D5++, M6(te2, U6, O4, { end: W5 });
          } else {
            if (!b7(R6))
              throw new h6("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], R6);
            D5++, M6(R6, U6, O4, { end: W5 });
          }
          R6 = U6;
        } else if (I5(U6)) {
          if (E4(R6))
            D5++, L4(C5(R6), U6, O4, { end: W5 });
          else if (S6(R6) || b7(R6))
            D5++, L4(R6, U6, O4, { end: W5 });
          else {
            if (!x6(R6))
              throw new h6("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], R6);
            D5++, L4(R6.readable, U6, O4, { end: W5 });
          }
          R6 = U6;
        } else
          R6 = c3.from(U6);
      }
      return (null != s4 && s4.aborted || null != l7 && l7.aborted) && n4.nextTick(d6), R6;
    }
    function $4(e8, t2, r2, { end: i5 }) {
      let o5 = false;
      if (t2.on("close", () => {
        o5 || r2(new y5());
      }), e8.pipe(t2, { end: false }), i5) {
        let a5 = function() {
          o5 = true, t2.end();
        };
        R5(e8) ? n4.nextTick(a5) : e8.once("end", a5);
      } else
        r2();
      return s3(e8, { readable: true, writable: false }, (t3) => {
        const n5 = e8._readableState;
        t3 && "ERR_STREAM_PREMATURE_CLOSE" === t3.code && n5 && n5.ended && !n5.errored && !n5.errorEmitted ? e8.once("end", r2).once("error", r2) : r2(t3);
      }), s3(t2, { readable: false, writable: true }, r2);
    }
    t.exports = { pipelineImpl: B6, pipeline: P5 };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "../../ours/util": 41, "../validators": 37, "./destroy": 23, "./duplex": 24, "./end-of-stream": 26, "./passthrough": 30, "./readable": 32, "./utils": 35, "abort-controller": 11, "process/": 18 }], 32: [function(e7, t, r) {
    const n4 = e7("process/"), { ArrayPrototypeIndexOf: i4, NumberIsInteger: o4, NumberIsNaN: a4, NumberParseInt: s3, ObjectDefineProperties: l6, ObjectKeys: u4, ObjectSetPrototypeOf: c3, Promise: d5, SafeSet: h6, SymbolAsyncIterator: f5, Symbol: p6 } = e7("../../ours/primordials");
    t.exports = $4, $4.ReadableState = B6;
    const { EventEmitter: m5 } = e7("events"), { Stream: y5, prependListener: g5 } = e7("./legacy"), { Buffer: v6 } = e7("buffer"), { addAbortSignal: w5 } = e7("./add-abort-signal"), b7 = e7("./end-of-stream");
    let _5 = e7("../../ours/util").debuglog("stream", (e8) => {
      _5 = e8;
    });
    const E4 = e7("./buffer_list"), T6 = e7("./destroy"), { getHighWaterMark: x6, getDefaultHighWaterMark: I5 } = e7("./state"), { aggregateTwoErrors: S6, codes: { ERR_INVALID_ARG_TYPE: R5, ERR_METHOD_NOT_IMPLEMENTED: k5, ERR_OUT_OF_RANGE: j5, ERR_STREAM_PUSH_AFTER_EOF: D4, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: N10 } } = e7("../../ours/errors"), { validateObject: O3 } = e7("../validators"), C5 = p6("kPaused"), { StringDecoder: A5 } = e7("string_decoder"), M6 = e7("./from");
    c3($4.prototype, y5.prototype), c3($4, y5);
    const L4 = () => {
    }, { errorOrDestroy: P5 } = T6;
    function B6(t2, r2, n5) {
      "boolean" != typeof n5 && (n5 = r2 instanceof e7("./duplex")), this.objectMode = !(!t2 || !t2.objectMode), n5 && (this.objectMode = this.objectMode || !(!t2 || !t2.readableObjectMode)), this.highWaterMark = t2 ? x6(this, t2, "readableHighWaterMark", n5) : I5(false), this.buffer = new E4(), this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[C5] = null, this.errorEmitted = false, this.emitClose = !t2 || false !== t2.emitClose, this.autoDestroy = !t2 || false !== t2.autoDestroy, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t2 && t2.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t2 && t2.encoding && (this.decoder = new A5(t2.encoding), this.encoding = t2.encoding);
    }
    function $4(t2) {
      if (!(this instanceof $4))
        return new $4(t2);
      const r2 = this instanceof e7("./duplex");
      this._readableState = new B6(t2, this, r2), t2 && ("function" == typeof t2.read && (this._read = t2.read), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.construct && (this._construct = t2.construct), t2.signal && !r2 && w5(t2.signal, this)), y5.call(this, t2), T6.construct(this, () => {
        this._readableState.needReadable && J4(this, this._readableState);
      });
    }
    function F4(e8, t2, r2, n5) {
      _5("readableAddChunk", t2);
      const i5 = e8._readableState;
      let o5;
      if (i5.objectMode || ("string" == typeof t2 ? (r2 = r2 || i5.defaultEncoding, i5.encoding !== r2 && (n5 && i5.encoding ? t2 = v6.from(t2, r2).toString(i5.encoding) : (t2 = v6.from(t2, r2), r2 = ""))) : t2 instanceof v6 ? r2 = "" : y5._isUint8Array(t2) ? (t2 = y5._uint8ArrayToBuffer(t2), r2 = "") : null != t2 && (o5 = new R5("chunk", ["string", "Buffer", "Uint8Array"], t2))), o5)
        P5(e8, o5);
      else if (null === t2)
        i5.reading = false, z6(e8, i5);
      else if (i5.objectMode || t2 && t2.length > 0)
        if (n5)
          if (i5.endEmitted)
            P5(e8, new N10());
          else {
            if (i5.destroyed || i5.errored)
              return false;
            U6(e8, i5, t2, true);
          }
        else if (i5.ended)
          P5(e8, new D4());
        else {
          if (i5.destroyed || i5.errored)
            return false;
          i5.reading = false, i5.decoder && !r2 ? (t2 = i5.decoder.write(t2), i5.objectMode || 0 !== t2.length ? U6(e8, i5, t2, false) : J4(e8, i5)) : U6(e8, i5, t2, false);
        }
      else
        n5 || (i5.reading = false, J4(e8, i5));
      return !i5.ended && (i5.length < i5.highWaterMark || 0 === i5.length);
    }
    function U6(e8, t2, r2, n5) {
      t2.flowing && 0 === t2.length && !t2.sync && e8.listenerCount("data") > 0 ? (t2.multiAwaitDrain ? t2.awaitDrainWriters.clear() : t2.awaitDrainWriters = null, t2.dataEmitted = true, e8.emit("data", r2)) : (t2.length += t2.objectMode ? 1 : r2.length, n5 ? t2.buffer.unshift(r2) : t2.buffer.push(r2), t2.needReadable && G7(e8)), J4(e8, t2);
    }
    $4.prototype.destroy = T6.destroy, $4.prototype._undestroy = T6.undestroy, $4.prototype._destroy = function(e8, t2) {
      t2(e8);
    }, $4.prototype[m5.captureRejectionSymbol] = function(e8) {
      this.destroy(e8);
    }, $4.prototype.push = function(e8, t2) {
      return F4(this, e8, t2, false);
    }, $4.prototype.unshift = function(e8, t2) {
      return F4(this, e8, t2, true);
    }, $4.prototype.isPaused = function() {
      const e8 = this._readableState;
      return true === e8[C5] || false === e8.flowing;
    }, $4.prototype.setEncoding = function(e8) {
      const t2 = new A5(e8);
      this._readableState.decoder = t2, this._readableState.encoding = this._readableState.decoder.encoding;
      const r2 = this._readableState.buffer;
      let n5 = "";
      for (const e9 of r2)
        n5 += t2.write(e9);
      return r2.clear(), "" !== n5 && r2.push(n5), this._readableState.length = n5.length, this;
    };
    const q5 = 1073741824;
    function Y5(e8) {
      if (e8 > q5)
        throw new j5("size", "<= 1GiB", e8);
      return e8--, e8 |= e8 >>> 1, e8 |= e8 >>> 2, e8 |= e8 >>> 4, e8 |= e8 >>> 8, e8 |= e8 >>> 16, ++e8;
    }
    function W5(e8, t2) {
      return e8 <= 0 || 0 === t2.length && t2.ended ? 0 : t2.objectMode ? 1 : a4(e8) ? t2.flowing && t2.length ? t2.buffer.first().length : t2.length : e8 <= t2.length ? e8 : t2.ended ? t2.length : 0;
    }
    function z6(e8, t2) {
      if (_5("onEofChunk"), !t2.ended) {
        if (t2.decoder) {
          const e9 = t2.decoder.end();
          e9 && e9.length && (t2.buffer.push(e9), t2.length += t2.objectMode ? 1 : e9.length);
        }
        t2.ended = true, t2.sync ? G7(e8) : (t2.needReadable = false, t2.emittedReadable = true, H4(e8));
      }
    }
    function G7(e8) {
      const t2 = e8._readableState;
      _5("emitReadable", t2.needReadable, t2.emittedReadable), t2.needReadable = false, t2.emittedReadable || (_5("emitReadable", t2.flowing), t2.emittedReadable = true, n4.nextTick(H4, e8));
    }
    function H4(e8) {
      const t2 = e8._readableState;
      _5("emitReadable_", t2.destroyed, t2.length, t2.ended), t2.destroyed || t2.errored || !t2.length && !t2.ended || (e8.emit("readable"), t2.emittedReadable = false), t2.needReadable = !t2.flowing && !t2.ended && t2.length <= t2.highWaterMark, te2(e8);
    }
    function J4(e8, t2) {
      !t2.readingMore && t2.constructed && (t2.readingMore = true, n4.nextTick(V5, e8, t2));
    }
    function V5(e8, t2) {
      for (; !t2.reading && !t2.ended && (t2.length < t2.highWaterMark || t2.flowing && 0 === t2.length); ) {
        const r2 = t2.length;
        if (_5("maybeReadMore read 0"), e8.read(0), r2 === t2.length)
          break;
      }
      t2.readingMore = false;
    }
    function Q5(e8, t2) {
      return function() {
        const r2 = e8._readableState;
        r2.awaitDrainWriters === t2 ? (_5("pipeOnDrain", 1), r2.awaitDrainWriters = null) : r2.multiAwaitDrain && (_5("pipeOnDrain", r2.awaitDrainWriters.size), r2.awaitDrainWriters.delete(t2)), r2.awaitDrainWriters && 0 !== r2.awaitDrainWriters.size || !e8.listenerCount("data") || e8.resume();
      };
    }
    function Z5(e8) {
      const t2 = e8._readableState;
      t2.readableListening = e8.listenerCount("readable") > 0, t2.resumeScheduled && false === t2[C5] ? t2.flowing = true : e8.listenerCount("data") > 0 ? e8.resume() : t2.readableListening || (t2.flowing = null);
    }
    function K4(e8) {
      _5("readable nexttick read 0"), e8.read(0);
    }
    function X5(e8, t2) {
      t2.resumeScheduled || (t2.resumeScheduled = true, n4.nextTick(ee2, e8, t2));
    }
    function ee2(e8, t2) {
      _5("resume", t2.reading), t2.reading || e8.read(0), t2.resumeScheduled = false, e8.emit("resume"), te2(e8), t2.flowing && !t2.reading && e8.read(0);
    }
    function te2(e8) {
      const t2 = e8._readableState;
      for (_5("flow", t2.flowing); t2.flowing && null !== e8.read(); )
        ;
    }
    function re2(e8, t2) {
      "function" != typeof e8.read && (e8 = $4.wrap(e8, { objectMode: true }));
      const r2 = ne2(e8, t2);
      return r2.stream = e8, r2;
    }
    async function* ne2(e8, t2) {
      let r2, n5 = L4;
      function i5(t3) {
        this === e8 ? (n5(), n5 = L4) : n5 = t3;
      }
      e8.on("readable", i5);
      const o5 = b7(e8, { writable: false }, (e9) => {
        r2 = e9 ? S6(r2, e9) : null, n5(), n5 = L4;
      });
      try {
        for (; ; ) {
          const t3 = e8.destroyed ? null : e8.read();
          if (null !== t3)
            yield t3;
          else {
            if (r2)
              throw r2;
            if (null === r2)
              return;
            await new d5(i5);
          }
        }
      } catch (e9) {
        throw r2 = S6(r2, e9), r2;
      } finally {
        !r2 && false === (null == t2 ? void 0 : t2.destroyOnReturn) || void 0 !== r2 && !e8._readableState.autoDestroy ? (e8.off("readable", i5), o5()) : T6.destroyer(e8, null);
      }
    }
    function ie2(e8, t2) {
      if (0 === t2.length)
        return null;
      let r2;
      return t2.objectMode ? r2 = t2.buffer.shift() : !e8 || e8 >= t2.length ? (r2 = t2.decoder ? t2.buffer.join("") : 1 === t2.buffer.length ? t2.buffer.first() : t2.buffer.concat(t2.length), t2.buffer.clear()) : r2 = t2.buffer.consume(e8, t2.decoder), r2;
    }
    function oe2(e8) {
      const t2 = e8._readableState;
      _5("endReadable", t2.endEmitted), t2.endEmitted || (t2.ended = true, n4.nextTick(ae2, t2, e8));
    }
    function ae2(e8, t2) {
      if (_5("endReadableNT", e8.endEmitted, e8.length), !e8.errored && !e8.closeEmitted && !e8.endEmitted && 0 === e8.length) {
        if (e8.endEmitted = true, t2.emit("end"), t2.writable && false === t2.allowHalfOpen)
          n4.nextTick(se2, t2);
        else if (e8.autoDestroy) {
          const e9 = t2._writableState;
          (!e9 || e9.autoDestroy && (e9.finished || false === e9.writable)) && t2.destroy();
        }
      }
    }
    function se2(e8) {
      e8.writable && !e8.writableEnded && !e8.destroyed && e8.end();
    }
    let le2;
    function ue2() {
      return void 0 === le2 && (le2 = {}), le2;
    }
    $4.prototype.read = function(e8) {
      _5("read", e8), void 0 === e8 ? e8 = NaN : o4(e8) || (e8 = s3(e8, 10));
      const t2 = this._readableState, r2 = e8;
      if (e8 > t2.highWaterMark && (t2.highWaterMark = Y5(e8)), 0 !== e8 && (t2.emittedReadable = false), 0 === e8 && t2.needReadable && ((0 !== t2.highWaterMark ? t2.length >= t2.highWaterMark : t2.length > 0) || t2.ended))
        return _5("read: emitReadable", t2.length, t2.ended), 0 === t2.length && t2.ended ? oe2(this) : G7(this), null;
      if (0 === (e8 = W5(e8, t2)) && t2.ended)
        return 0 === t2.length && oe2(this), null;
      let n5, i5 = t2.needReadable;
      if (_5("need readable", i5), (0 === t2.length || t2.length - e8 < t2.highWaterMark) && (i5 = true, _5("length less than watermark", i5)), t2.ended || t2.reading || t2.destroyed || t2.errored || !t2.constructed)
        i5 = false, _5("reading, ended or constructing", i5);
      else if (i5) {
        _5("do read"), t2.reading = true, t2.sync = true, 0 === t2.length && (t2.needReadable = true);
        try {
          this._read(t2.highWaterMark);
        } catch (e9) {
          P5(this, e9);
        }
        t2.sync = false, t2.reading || (e8 = W5(r2, t2));
      }
      return n5 = e8 > 0 ? ie2(e8, t2) : null, null === n5 ? (t2.needReadable = t2.length <= t2.highWaterMark, e8 = 0) : (t2.length -= e8, t2.multiAwaitDrain ? t2.awaitDrainWriters.clear() : t2.awaitDrainWriters = null), 0 === t2.length && (t2.ended || (t2.needReadable = true), r2 !== e8 && t2.ended && oe2(this)), null === n5 || t2.errorEmitted || t2.closeEmitted || (t2.dataEmitted = true, this.emit("data", n5)), n5;
    }, $4.prototype._read = function(e8) {
      throw new k5("_read()");
    }, $4.prototype.pipe = function(e8, t2) {
      const r2 = this, i5 = this._readableState;
      1 === i5.pipes.length && (i5.multiAwaitDrain || (i5.multiAwaitDrain = true, i5.awaitDrainWriters = new h6(i5.awaitDrainWriters ? [i5.awaitDrainWriters] : []))), i5.pipes.push(e8), _5("pipe count=%d opts=%j", i5.pipes.length, t2);
      const o5 = t2 && false === t2.end || e8 === n4.stdout || e8 === n4.stderr ? v7 : s4;
      function a5(e9, t3) {
        _5("onunpipe"), e9 === r2 && t3 && false === t3.hasUnpiped && (t3.hasUnpiped = true, c4());
      }
      function s4() {
        _5("onend"), e8.end();
      }
      let l7;
      i5.endEmitted ? n4.nextTick(o5) : r2.once("end", o5), e8.on("unpipe", a5);
      let u5 = false;
      function c4() {
        _5("cleanup"), e8.removeListener("close", m6), e8.removeListener("finish", y6), l7 && e8.removeListener("drain", l7), e8.removeListener("error", p7), e8.removeListener("unpipe", a5), r2.removeListener("end", s4), r2.removeListener("end", v7), r2.removeListener("data", f6), u5 = true, l7 && i5.awaitDrainWriters && (!e8._writableState || e8._writableState.needDrain) && l7();
      }
      function d6() {
        u5 || (1 === i5.pipes.length && i5.pipes[0] === e8 ? (_5("false write response, pause", 0), i5.awaitDrainWriters = e8, i5.multiAwaitDrain = false) : i5.pipes.length > 1 && i5.pipes.includes(e8) && (_5("false write response, pause", i5.awaitDrainWriters.size), i5.awaitDrainWriters.add(e8)), r2.pause()), l7 || (l7 = Q5(r2, e8), e8.on("drain", l7));
      }
      function f6(t3) {
        _5("ondata");
        const r3 = e8.write(t3);
        _5("dest.write", r3), false === r3 && d6();
      }
      function p7(t3) {
        if (_5("onerror", t3), v7(), e8.removeListener("error", p7), 0 === e8.listenerCount("error")) {
          const r3 = e8._writableState || e8._readableState;
          r3 && !r3.errorEmitted ? P5(e8, t3) : e8.emit("error", t3);
        }
      }
      function m6() {
        e8.removeListener("finish", y6), v7();
      }
      function y6() {
        _5("onfinish"), e8.removeListener("close", m6), v7();
      }
      function v7() {
        _5("unpipe"), r2.unpipe(e8);
      }
      return r2.on("data", f6), g5(e8, "error", p7), e8.once("close", m6), e8.once("finish", y6), e8.emit("pipe", r2), true === e8.writableNeedDrain ? i5.flowing && d6() : i5.flowing || (_5("pipe resume"), r2.resume()), e8;
    }, $4.prototype.unpipe = function(e8) {
      const t2 = this._readableState, r2 = { hasUnpiped: false };
      if (0 === t2.pipes.length)
        return this;
      if (!e8) {
        const e9 = t2.pipes;
        t2.pipes = [], this.pause();
        for (let t3 = 0; t3 < e9.length; t3++)
          e9[t3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      const n5 = i4(t2.pipes, e8);
      return -1 === n5 || (t2.pipes.splice(n5, 1), 0 === t2.pipes.length && this.pause(), e8.emit("unpipe", this, r2)), this;
    }, $4.prototype.on = function(e8, t2) {
      const r2 = y5.prototype.on.call(this, e8, t2), i5 = this._readableState;
      return "data" === e8 ? (i5.readableListening = this.listenerCount("readable") > 0, false !== i5.flowing && this.resume()) : "readable" === e8 && (i5.endEmitted || i5.readableListening || (i5.readableListening = i5.needReadable = true, i5.flowing = false, i5.emittedReadable = false, _5("on readable", i5.length, i5.reading), i5.length ? G7(this) : i5.reading || n4.nextTick(K4, this))), r2;
    }, $4.prototype.addListener = $4.prototype.on, $4.prototype.removeListener = function(e8, t2) {
      const r2 = y5.prototype.removeListener.call(this, e8, t2);
      return "readable" === e8 && n4.nextTick(Z5, this), r2;
    }, $4.prototype.off = $4.prototype.removeListener, $4.prototype.removeAllListeners = function(e8) {
      const t2 = y5.prototype.removeAllListeners.apply(this, arguments);
      return "readable" !== e8 && void 0 !== e8 || n4.nextTick(Z5, this), t2;
    }, $4.prototype.resume = function() {
      const e8 = this._readableState;
      return e8.flowing || (_5("resume"), e8.flowing = !e8.readableListening, X5(this, e8)), e8[C5] = false, this;
    }, $4.prototype.pause = function() {
      return _5("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (_5("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[C5] = true, this;
    }, $4.prototype.wrap = function(e8) {
      let t2 = false;
      e8.on("data", (r3) => {
        !this.push(r3) && e8.pause && (t2 = true, e8.pause());
      }), e8.on("end", () => {
        this.push(null);
      }), e8.on("error", (e9) => {
        P5(this, e9);
      }), e8.on("close", () => {
        this.destroy();
      }), e8.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t2 && e8.resume && (t2 = false, e8.resume());
      };
      const r2 = u4(e8);
      for (let t3 = 1; t3 < r2.length; t3++) {
        const n5 = r2[t3];
        void 0 === this[n5] && "function" == typeof e8[n5] && (this[n5] = e8[n5].bind(e8));
      }
      return this;
    }, $4.prototype[f5] = function() {
      return re2(this);
    }, $4.prototype.iterator = function(e8) {
      return void 0 !== e8 && O3(e8, "options"), re2(this, e8);
    }, l6($4.prototype, { readable: { __proto__: null, get() {
      const e8 = this._readableState;
      return !(!e8 || false === e8.readable || e8.destroyed || e8.errorEmitted || e8.endEmitted);
    }, set(e8) {
      this._readableState && (this._readableState.readable = !!e8);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !(false === this._readableState.readable || !this._readableState.destroyed && !this._readableState.errored || this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e8) {
      this._readableState && (this._readableState.flowing = e8);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return !!this._readableState && this._readableState.objectMode;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return !!this._readableState && this._readableState.closed;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return !!this._readableState && this._readableState.destroyed;
    }, set(e8) {
      this._readableState && (this._readableState.destroyed = e8);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return !!this._readableState && this._readableState.endEmitted;
    } } }), l6(B6.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return false !== this[C5];
    }, set(e8) {
      this[C5] = !!e8;
    } } }), $4._fromList = ie2, $4.from = function(e8, t2) {
      return M6($4, e8, t2);
    }, $4.fromWeb = function(e8, t2) {
      return ue2().newStreamReadableFromReadableStream(e8, t2);
    }, $4.toWeb = function(e8, t2) {
      return ue2().newReadableStreamFromStreamReadable(e8, t2);
    }, $4.wrap = function(e8, t2) {
      var r2, n5;
      return new $4({ objectMode: null === (r2 = null !== (n5 = e8.readableObjectMode) && void 0 !== n5 ? n5 : e8.objectMode) || void 0 === r2 || r2, ...t2, destroy(t3, r3) {
        T6.destroyer(e8, t3), r3(t3);
      } }).wrap(e8);
    };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "../../ours/util": 41, "../validators": 37, "./add-abort-signal": 20, "./buffer_list": 21, "./destroy": 23, "./duplex": 24, "./end-of-stream": 26, "./from": 27, "./legacy": 28, "./state": 33, buffer: 15, events: 16, "process/": 18, string_decoder: 14 }], 33: [function(e7, t, r) {
    const { MathFloor: n4, NumberIsInteger: i4 } = e7("../../ours/primordials"), { ERR_INVALID_ARG_VALUE: o4 } = e7("../../ours/errors").codes;
    function a4(e8, t2, r2) {
      return null != e8.highWaterMark ? e8.highWaterMark : t2 ? e8[r2] : null;
    }
    function s3(e8) {
      return e8 ? 16 : 16384;
    }
    function l6(e8, t2, r2, l7) {
      const u4 = a4(t2, l7, r2);
      if (null != u4) {
        if (!i4(u4) || u4 < 0)
          throw new o4(l7 ? `options.${r2}` : "options.highWaterMark", u4);
        return n4(u4);
      }
      return s3(e8.objectMode);
    }
    t.exports = { getHighWaterMark: l6, getDefaultHighWaterMark: s3 };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40 }], 34: [function(e7, t, r) {
    const { ObjectSetPrototypeOf: n4, Symbol: i4 } = e7("../../ours/primordials");
    t.exports = u4;
    const { ERR_METHOD_NOT_IMPLEMENTED: o4 } = e7("../../ours/errors").codes, a4 = e7("./duplex"), { getHighWaterMark: s3 } = e7("./state");
    n4(u4.prototype, a4.prototype), n4(u4, a4);
    const l6 = i4("kCallback");
    function u4(e8) {
      if (!(this instanceof u4))
        return new u4(e8);
      const t2 = e8 ? s3(this, e8, "readableHighWaterMark", true) : null;
      0 === t2 && (e8 = { ...e8, highWaterMark: null, readableHighWaterMark: t2, writableHighWaterMark: e8.writableHighWaterMark || 0 }), a4.call(this, e8), this._readableState.sync = false, this[l6] = null, e8 && ("function" == typeof e8.transform && (this._transform = e8.transform), "function" == typeof e8.flush && (this._flush = e8.flush)), this.on("prefinish", d5);
    }
    function c3(e8) {
      "function" != typeof this._flush || this.destroyed ? (this.push(null), e8 && e8()) : this._flush((t2, r2) => {
        t2 ? e8 ? e8(t2) : this.destroy(t2) : (null != r2 && this.push(r2), this.push(null), e8 && e8());
      });
    }
    function d5() {
      this._final !== c3 && c3.call(this);
    }
    u4.prototype._final = c3, u4.prototype._transform = function(e8, t2, r2) {
      throw new o4("_transform()");
    }, u4.prototype._write = function(e8, t2, r2) {
      const n5 = this._readableState, i5 = this._writableState, o5 = n5.length;
      this._transform(e8, t2, (e9, t3) => {
        e9 ? r2(e9) : (null != t3 && this.push(t3), i5.ended || o5 === n5.length || n5.length < n5.highWaterMark ? r2() : this[l6] = r2);
      });
    }, u4.prototype._read = function() {
      if (this[l6]) {
        const e8 = this[l6];
        this[l6] = null, e8();
      }
    };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "./duplex": 24, "./state": 33 }], 35: [function(e7, t, r) {
    const { Symbol: n4, SymbolAsyncIterator: i4, SymbolIterator: o4, SymbolFor: a4 } = e7("../../ours/primordials"), s3 = n4("kDestroyed"), l6 = n4("kIsErrored"), u4 = n4("kIsReadable"), c3 = n4("kIsDisturbed"), d5 = a4("nodejs.webstream.isClosedPromise"), h6 = a4("nodejs.webstream.controllerErrorFunction");
    function f5(e8, t2 = false) {
      var r2;
      return !(!e8 || "function" != typeof e8.pipe || "function" != typeof e8.on || t2 && ("function" != typeof e8.pause || "function" != typeof e8.resume) || e8._writableState && false === (null === (r2 = e8._readableState) || void 0 === r2 ? void 0 : r2.readable) || e8._writableState && !e8._readableState);
    }
    function p6(e8) {
      var t2;
      return !(!e8 || "function" != typeof e8.write || "function" != typeof e8.on || e8._readableState && false === (null === (t2 = e8._writableState) || void 0 === t2 ? void 0 : t2.writable));
    }
    function m5(e8) {
      return !(!e8 || "function" != typeof e8.pipe || !e8._readableState || "function" != typeof e8.on || "function" != typeof e8.write);
    }
    function y5(e8) {
      return e8 && (e8._readableState || e8._writableState || "function" == typeof e8.write && "function" == typeof e8.on || "function" == typeof e8.pipe && "function" == typeof e8.on);
    }
    function g5(e8) {
      return !(!e8 || y5(e8) || "function" != typeof e8.pipeThrough || "function" != typeof e8.getReader || "function" != typeof e8.cancel);
    }
    function v6(e8) {
      return !(!e8 || y5(e8) || "function" != typeof e8.getWriter || "function" != typeof e8.abort);
    }
    function w5(e8) {
      return !(!e8 || y5(e8) || "object" != typeof e8.readable || "object" != typeof e8.writable);
    }
    function b7(e8) {
      return g5(e8) || v6(e8) || w5(e8);
    }
    function _5(e8, t2) {
      return null != e8 && (true === t2 ? "function" == typeof e8[i4] : false === t2 ? "function" == typeof e8[o4] : "function" == typeof e8[i4] || "function" == typeof e8[o4]);
    }
    function E4(e8) {
      if (!y5(e8))
        return null;
      const t2 = e8._writableState, r2 = e8._readableState, n5 = t2 || r2;
      return !!(e8.destroyed || e8[s3] || null != n5 && n5.destroyed);
    }
    function T6(e8) {
      if (!p6(e8))
        return null;
      if (true === e8.writableEnded)
        return true;
      const t2 = e8._writableState;
      return (null == t2 || !t2.errored) && ("boolean" != typeof (null == t2 ? void 0 : t2.ended) ? null : t2.ended);
    }
    function x6(e8, t2) {
      if (!p6(e8))
        return null;
      if (true === e8.writableFinished)
        return true;
      const r2 = e8._writableState;
      return (null == r2 || !r2.errored) && ("boolean" != typeof (null == r2 ? void 0 : r2.finished) ? null : !!(r2.finished || false === t2 && true === r2.ended && 0 === r2.length));
    }
    function I5(e8) {
      if (!f5(e8))
        return null;
      if (true === e8.readableEnded)
        return true;
      const t2 = e8._readableState;
      return !(!t2 || t2.errored) && ("boolean" != typeof (null == t2 ? void 0 : t2.ended) ? null : t2.ended);
    }
    function S6(e8, t2) {
      if (!f5(e8))
        return null;
      const r2 = e8._readableState;
      return (null == r2 || !r2.errored) && ("boolean" != typeof (null == r2 ? void 0 : r2.endEmitted) ? null : !!(r2.endEmitted || false === t2 && true === r2.ended && 0 === r2.length));
    }
    function R5(e8) {
      return e8 && null != e8[u4] ? e8[u4] : "boolean" != typeof (null == e8 ? void 0 : e8.readable) ? null : !E4(e8) && f5(e8) && e8.readable && !S6(e8);
    }
    function k5(e8) {
      return "boolean" != typeof (null == e8 ? void 0 : e8.writable) ? null : !E4(e8) && p6(e8) && e8.writable && !T6(e8);
    }
    function j5(e8, t2) {
      return y5(e8) ? !(!E4(e8) && (false !== (null == t2 ? void 0 : t2.readable) && R5(e8) || false !== (null == t2 ? void 0 : t2.writable) && k5(e8))) : null;
    }
    function D4(e8) {
      var t2, r2;
      return y5(e8) ? e8.writableErrored ? e8.writableErrored : null !== (t2 = null === (r2 = e8._writableState) || void 0 === r2 ? void 0 : r2.errored) && void 0 !== t2 ? t2 : null : null;
    }
    function N10(e8) {
      var t2, r2;
      return y5(e8) ? e8.readableErrored ? e8.readableErrored : null !== (t2 = null === (r2 = e8._readableState) || void 0 === r2 ? void 0 : r2.errored) && void 0 !== t2 ? t2 : null : null;
    }
    function O3(e8) {
      if (!y5(e8))
        return null;
      if ("boolean" == typeof e8.closed)
        return e8.closed;
      const t2 = e8._writableState, r2 = e8._readableState;
      return "boolean" == typeof (null == t2 ? void 0 : t2.closed) || "boolean" == typeof (null == r2 ? void 0 : r2.closed) ? (null == t2 ? void 0 : t2.closed) || (null == r2 ? void 0 : r2.closed) : "boolean" == typeof e8._closed && C5(e8) ? e8._closed : null;
    }
    function C5(e8) {
      return "boolean" == typeof e8._closed && "boolean" == typeof e8._defaultKeepAlive && "boolean" == typeof e8._removedConnection && "boolean" == typeof e8._removedContLen;
    }
    function A5(e8) {
      return "boolean" == typeof e8._sent100 && C5(e8);
    }
    function M6(e8) {
      var t2;
      return "boolean" == typeof e8._consuming && "boolean" == typeof e8._dumped && void 0 === (null === (t2 = e8.req) || void 0 === t2 ? void 0 : t2.upgradeOrConnect);
    }
    function L4(e8) {
      if (!y5(e8))
        return null;
      const t2 = e8._writableState, r2 = e8._readableState, n5 = t2 || r2;
      return !n5 && A5(e8) || !!(n5 && n5.autoDestroy && n5.emitClose && false === n5.closed);
    }
    function P5(e8) {
      var t2;
      return !(!e8 || !(null !== (t2 = e8[c3]) && void 0 !== t2 ? t2 : e8.readableDidRead || e8.readableAborted));
    }
    function B6(e8) {
      var t2, r2, n5, i5, o5, a5, s4, u5, c4, d6;
      return !(!e8 || !(null !== (t2 = null !== (r2 = null !== (n5 = null !== (i5 = null !== (o5 = null !== (a5 = e8[l6]) && void 0 !== a5 ? a5 : e8.readableErrored) && void 0 !== o5 ? o5 : e8.writableErrored) && void 0 !== i5 ? i5 : null === (s4 = e8._readableState) || void 0 === s4 ? void 0 : s4.errorEmitted) && void 0 !== n5 ? n5 : null === (u5 = e8._writableState) || void 0 === u5 ? void 0 : u5.errorEmitted) && void 0 !== r2 ? r2 : null === (c4 = e8._readableState) || void 0 === c4 ? void 0 : c4.errored) && void 0 !== t2 ? t2 : null === (d6 = e8._writableState) || void 0 === d6 ? void 0 : d6.errored));
    }
    t.exports = { kDestroyed: s3, isDisturbed: P5, kIsDisturbed: c3, isErrored: B6, kIsErrored: l6, isReadable: R5, kIsReadable: u4, kIsClosedPromise: d5, kControllerErrorFunction: h6, isClosed: O3, isDestroyed: E4, isDuplexNodeStream: m5, isFinished: j5, isIterable: _5, isReadableNodeStream: f5, isReadableStream: g5, isReadableEnded: I5, isReadableFinished: S6, isReadableErrored: N10, isNodeStream: y5, isWebStream: b7, isWritable: k5, isWritableNodeStream: p6, isWritableStream: v6, isWritableEnded: T6, isWritableFinished: x6, isWritableErrored: D4, isServerRequest: M6, isServerResponse: A5, willEmitClose: L4, isTransformStream: w5 };
  }, { "../../ours/primordials": 40 }], 36: [function(e7, t, r) {
    const n4 = e7("process/"), { ArrayPrototypeSlice: i4, Error: o4, FunctionPrototypeSymbolHasInstance: a4, ObjectDefineProperty: s3, ObjectDefineProperties: l6, ObjectSetPrototypeOf: u4, StringPrototypeToLowerCase: c3, Symbol: d5, SymbolHasInstance: h6 } = e7("../../ours/primordials");
    t.exports = A5, A5.WritableState = O3;
    const { EventEmitter: f5 } = e7("events"), p6 = e7("./legacy").Stream, { Buffer: m5 } = e7("buffer"), y5 = e7("./destroy"), { addAbortSignal: g5 } = e7("./add-abort-signal"), { getHighWaterMark: v6, getDefaultHighWaterMark: w5 } = e7("./state"), { ERR_INVALID_ARG_TYPE: b7, ERR_METHOD_NOT_IMPLEMENTED: _5, ERR_MULTIPLE_CALLBACK: E4, ERR_STREAM_CANNOT_PIPE: T6, ERR_STREAM_DESTROYED: x6, ERR_STREAM_ALREADY_FINISHED: I5, ERR_STREAM_NULL_VALUES: S6, ERR_STREAM_WRITE_AFTER_END: R5, ERR_UNKNOWN_ENCODING: k5 } = e7("../../ours/errors").codes, { errorOrDestroy: j5 } = y5;
    function D4() {
    }
    u4(A5.prototype, p6.prototype), u4(A5, p6);
    const N10 = d5("kOnFinished");
    function O3(t2, r2, n5) {
      "boolean" != typeof n5 && (n5 = r2 instanceof e7("./duplex")), this.objectMode = !(!t2 || !t2.objectMode), n5 && (this.objectMode = this.objectMode || !(!t2 || !t2.writableObjectMode)), this.highWaterMark = t2 ? v6(this, t2, "writableHighWaterMark", n5) : w5(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      const i5 = !(!t2 || false !== t2.decodeStrings);
      this.decodeStrings = !i5, this.defaultEncoding = t2 && t2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = $4.bind(void 0, r2), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, C5(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t2 || false !== t2.emitClose, this.autoDestroy = !t2 || false !== t2.autoDestroy, this.errored = null, this.closed = false, this.closeEmitted = false, this[N10] = [];
    }
    function C5(e8) {
      e8.buffered = [], e8.bufferedIndex = 0, e8.allBuffers = true, e8.allNoop = true;
    }
    function A5(t2) {
      const r2 = this instanceof e7("./duplex");
      if (!r2 && !a4(A5, this))
        return new A5(t2);
      this._writableState = new O3(t2, this, r2), t2 && ("function" == typeof t2.write && (this._write = t2.write), "function" == typeof t2.writev && (this._writev = t2.writev), "function" == typeof t2.destroy && (this._destroy = t2.destroy), "function" == typeof t2.final && (this._final = t2.final), "function" == typeof t2.construct && (this._construct = t2.construct), t2.signal && g5(t2.signal, this)), p6.call(this, t2), y5.construct(this, () => {
        const e8 = this._writableState;
        e8.writing || Y5(this, e8), H4(this, e8);
      });
    }
    function M6(e8, t2, r2, i5) {
      const o5 = e8._writableState;
      if ("function" == typeof r2)
        i5 = r2, r2 = o5.defaultEncoding;
      else {
        if (r2) {
          if ("buffer" !== r2 && !m5.isEncoding(r2))
            throw new k5(r2);
        } else
          r2 = o5.defaultEncoding;
        "function" != typeof i5 && (i5 = D4);
      }
      if (null === t2)
        throw new S6();
      if (!o5.objectMode)
        if ("string" == typeof t2)
          false !== o5.decodeStrings && (t2 = m5.from(t2, r2), r2 = "buffer");
        else if (t2 instanceof m5)
          r2 = "buffer";
        else {
          if (!p6._isUint8Array(t2))
            throw new b7("chunk", ["string", "Buffer", "Uint8Array"], t2);
          t2 = p6._uint8ArrayToBuffer(t2), r2 = "buffer";
        }
      let a5;
      return o5.ending ? a5 = new R5() : o5.destroyed && (a5 = new x6("write")), a5 ? (n4.nextTick(i5, a5), j5(e8, a5, true), a5) : (o5.pendingcb++, L4(e8, o5, t2, r2, i5));
    }
    function L4(e8, t2, r2, n5, i5) {
      const o5 = t2.objectMode ? 1 : r2.length;
      t2.length += o5;
      const a5 = t2.length < t2.highWaterMark;
      return a5 || (t2.needDrain = true), t2.writing || t2.corked || t2.errored || !t2.constructed ? (t2.buffered.push({ chunk: r2, encoding: n5, callback: i5 }), t2.allBuffers && "buffer" !== n5 && (t2.allBuffers = false), t2.allNoop && i5 !== D4 && (t2.allNoop = false)) : (t2.writelen = o5, t2.writecb = i5, t2.writing = true, t2.sync = true, e8._write(r2, n5, t2.onwrite), t2.sync = false), a5 && !t2.errored && !t2.destroyed;
    }
    function P5(e8, t2, r2, n5, i5, o5, a5) {
      t2.writelen = n5, t2.writecb = a5, t2.writing = true, t2.sync = true, t2.destroyed ? t2.onwrite(new x6("write")) : r2 ? e8._writev(i5, t2.onwrite) : e8._write(i5, o5, t2.onwrite), t2.sync = false;
    }
    function B6(e8, t2, r2, n5) {
      --t2.pendingcb, n5(r2), q5(t2), j5(e8, r2);
    }
    function $4(e8, t2) {
      const r2 = e8._writableState, i5 = r2.sync, o5 = r2.writecb;
      "function" == typeof o5 ? (r2.writing = false, r2.writecb = null, r2.length -= r2.writelen, r2.writelen = 0, t2 ? (r2.errored || (r2.errored = t2), e8._readableState && !e8._readableState.errored && (e8._readableState.errored = t2), i5 ? n4.nextTick(B6, e8, r2, t2, o5) : B6(e8, r2, t2, o5)) : (r2.buffered.length > r2.bufferedIndex && Y5(e8, r2), i5 ? null !== r2.afterWriteTickInfo && r2.afterWriteTickInfo.cb === o5 ? r2.afterWriteTickInfo.count++ : (r2.afterWriteTickInfo = { count: 1, cb: o5, stream: e8, state: r2 }, n4.nextTick(F4, r2.afterWriteTickInfo)) : U6(e8, r2, 1, o5))) : j5(e8, new E4());
    }
    function F4({ stream: e8, state: t2, count: r2, cb: n5 }) {
      return t2.afterWriteTickInfo = null, U6(e8, t2, r2, n5);
    }
    function U6(e8, t2, r2, n5) {
      for (!t2.ending && !e8.destroyed && 0 === t2.length && t2.needDrain && (t2.needDrain = false, e8.emit("drain")); r2-- > 0; )
        t2.pendingcb--, n5();
      t2.destroyed && q5(t2), H4(e8, t2);
    }
    function q5(e8) {
      if (e8.writing)
        return;
      for (let r3 = e8.bufferedIndex; r3 < e8.buffered.length; ++r3) {
        var t2;
        const { chunk: n6, callback: i5 } = e8.buffered[r3], o5 = e8.objectMode ? 1 : n6.length;
        e8.length -= o5, i5(null !== (t2 = e8.errored) && void 0 !== t2 ? t2 : new x6("write"));
      }
      const r2 = e8[N10].splice(0);
      for (let t3 = 0; t3 < r2.length; t3++) {
        var n5;
        r2[t3](null !== (n5 = e8.errored) && void 0 !== n5 ? n5 : new x6("end"));
      }
      C5(e8);
    }
    function Y5(e8, t2) {
      if (t2.corked || t2.bufferProcessing || t2.destroyed || !t2.constructed)
        return;
      const { buffered: r2, bufferedIndex: n5, objectMode: o5 } = t2, a5 = r2.length - n5;
      if (!a5)
        return;
      let s4 = n5;
      if (t2.bufferProcessing = true, a5 > 1 && e8._writev) {
        t2.pendingcb -= a5 - 1;
        const n6 = t2.allNoop ? D4 : (e9) => {
          for (let t3 = s4; t3 < r2.length; ++t3)
            r2[t3].callback(e9);
        }, o6 = t2.allNoop && 0 === s4 ? r2 : i4(r2, s4);
        o6.allBuffers = t2.allBuffers, P5(e8, t2, true, t2.length, o6, "", n6), C5(t2);
      } else {
        do {
          const { chunk: n6, encoding: i5, callback: a6 } = r2[s4];
          r2[s4++] = null, P5(e8, t2, false, o5 ? 1 : n6.length, n6, i5, a6);
        } while (s4 < r2.length && !t2.writing);
        s4 === r2.length ? C5(t2) : s4 > 256 ? (r2.splice(0, s4), t2.bufferedIndex = 0) : t2.bufferedIndex = s4;
      }
      t2.bufferProcessing = false;
    }
    function W5(e8) {
      return e8.ending && !e8.destroyed && e8.constructed && 0 === e8.length && !e8.errored && 0 === e8.buffered.length && !e8.finished && !e8.writing && !e8.errorEmitted && !e8.closeEmitted;
    }
    function z6(e8, t2) {
      let r2 = false;
      function i5(i6) {
        if (r2)
          j5(e8, null != i6 ? i6 : E4());
        else if (r2 = true, t2.pendingcb--, i6) {
          const r3 = t2[N10].splice(0);
          for (let e9 = 0; e9 < r3.length; e9++)
            r3[e9](i6);
          j5(e8, i6, t2.sync);
        } else
          W5(t2) && (t2.prefinished = true, e8.emit("prefinish"), t2.pendingcb++, n4.nextTick(J4, e8, t2));
      }
      t2.sync = true, t2.pendingcb++;
      try {
        e8._final(i5);
      } catch (e9) {
        i5(e9);
      }
      t2.sync = false;
    }
    function G7(e8, t2) {
      t2.prefinished || t2.finalCalled || ("function" != typeof e8._final || t2.destroyed ? (t2.prefinished = true, e8.emit("prefinish")) : (t2.finalCalled = true, z6(e8, t2)));
    }
    function H4(e8, t2, r2) {
      W5(t2) && (G7(e8, t2), 0 === t2.pendingcb && (r2 ? (t2.pendingcb++, n4.nextTick((e9, t3) => {
        W5(t3) ? J4(e9, t3) : t3.pendingcb--;
      }, e8, t2)) : W5(t2) && (t2.pendingcb++, J4(e8, t2))));
    }
    function J4(e8, t2) {
      t2.pendingcb--, t2.finished = true;
      const r2 = t2[N10].splice(0);
      for (let e9 = 0; e9 < r2.length; e9++)
        r2[e9]();
      if (e8.emit("finish"), t2.autoDestroy) {
        const t3 = e8._readableState;
        (!t3 || t3.autoDestroy && (t3.endEmitted || false === t3.readable)) && e8.destroy();
      }
    }
    O3.prototype.getBuffer = function() {
      return i4(this.buffered, this.bufferedIndex);
    }, s3(O3.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } }), s3(A5, h6, { __proto__: null, value: function(e8) {
      return !!a4(this, e8) || this === A5 && e8 && e8._writableState instanceof O3;
    } }), A5.prototype.pipe = function() {
      j5(this, new T6());
    }, A5.prototype.write = function(e8, t2, r2) {
      return true === M6(this, e8, t2, r2);
    }, A5.prototype.cork = function() {
      this._writableState.corked++;
    }, A5.prototype.uncork = function() {
      const e8 = this._writableState;
      e8.corked && (e8.corked--, e8.writing || Y5(this, e8));
    }, A5.prototype.setDefaultEncoding = function(e8) {
      if ("string" == typeof e8 && (e8 = c3(e8)), !m5.isEncoding(e8))
        throw new k5(e8);
      return this._writableState.defaultEncoding = e8, this;
    }, A5.prototype._write = function(e8, t2, r2) {
      if (!this._writev)
        throw new _5("_write()");
      this._writev([{ chunk: e8, encoding: t2 }], r2);
    }, A5.prototype._writev = null, A5.prototype.end = function(e8, t2, r2) {
      const i5 = this._writableState;
      let a5;
      if ("function" == typeof e8 ? (r2 = e8, e8 = null, t2 = null) : "function" == typeof t2 && (r2 = t2, t2 = null), null != e8) {
        const r3 = M6(this, e8, t2);
        r3 instanceof o4 && (a5 = r3);
      }
      return i5.corked && (i5.corked = 1, this.uncork()), a5 || (i5.errored || i5.ending ? i5.finished ? a5 = new I5("end") : i5.destroyed && (a5 = new x6("end")) : (i5.ending = true, H4(this, i5, true), i5.ended = true)), "function" == typeof r2 && (a5 || i5.finished ? n4.nextTick(r2, a5) : i5[N10].push(r2)), this;
    }, l6(A5.prototype, { closed: { __proto__: null, get() {
      return !!this._writableState && this._writableState.closed;
    } }, destroyed: { __proto__: null, get() {
      return !!this._writableState && this._writableState.destroyed;
    }, set(e8) {
      this._writableState && (this._writableState.destroyed = e8);
    } }, writable: { __proto__: null, get() {
      const e8 = this._writableState;
      return !(!e8 || false === e8.writable || e8.destroyed || e8.errored || e8.ending || e8.ended);
    }, set(e8) {
      this._writableState && (this._writableState.writable = !!e8);
    } }, writableFinished: { __proto__: null, get() {
      return !!this._writableState && this._writableState.finished;
    } }, writableObjectMode: { __proto__: null, get() {
      return !!this._writableState && this._writableState.objectMode;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return !!this._writableState && this._writableState.ending;
    } }, writableNeedDrain: { __proto__: null, get() {
      const e8 = this._writableState;
      return !!e8 && !e8.destroyed && !e8.ending && e8.needDrain;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !(false === this._writableState.writable || !this._writableState.destroyed && !this._writableState.errored || this._writableState.finished);
    } } });
    const V5 = y5.destroy;
    let Q5;
    function Z5() {
      return void 0 === Q5 && (Q5 = {}), Q5;
    }
    A5.prototype.destroy = function(e8, t2) {
      const r2 = this._writableState;
      return !r2.destroyed && (r2.bufferedIndex < r2.buffered.length || r2[N10].length) && n4.nextTick(q5, r2), V5.call(this, e8, t2), this;
    }, A5.prototype._undestroy = y5.undestroy, A5.prototype._destroy = function(e8, t2) {
      t2(e8);
    }, A5.prototype[f5.captureRejectionSymbol] = function(e8) {
      this.destroy(e8);
    }, A5.fromWeb = function(e8, t2) {
      return Z5().newStreamWritableFromWritableStream(e8, t2);
    }, A5.toWeb = function(e8) {
      return Z5().newWritableStreamFromStreamWritable(e8);
    };
  }, { "../../ours/errors": 39, "../../ours/primordials": 40, "./add-abort-signal": 20, "./destroy": 23, "./duplex": 24, "./legacy": 28, "./state": 33, buffer: 15, events: 16, "process/": 18 }], 37: [function(e7, t, r) {
    const { ArrayIsArray: n4, ArrayPrototypeIncludes: i4, ArrayPrototypeJoin: o4, ArrayPrototypeMap: a4, NumberIsInteger: s3, NumberIsNaN: l6, NumberMAX_SAFE_INTEGER: u4, NumberMIN_SAFE_INTEGER: c3, NumberParseInt: d5, ObjectPrototypeHasOwnProperty: h6, RegExpPrototypeExec: f5, String: p6, StringPrototypeToUpperCase: m5, StringPrototypeTrim: y5 } = e7("../ours/primordials"), { hideStackFrames: g5, codes: { ERR_SOCKET_BAD_PORT: v6, ERR_INVALID_ARG_TYPE: w5, ERR_INVALID_ARG_VALUE: b7, ERR_OUT_OF_RANGE: _5, ERR_UNKNOWN_SIGNAL: E4 } } = e7("../ours/errors"), { normalizeEncoding: T6 } = e7("../ours/util"), { isAsyncFunction: x6, isArrayBufferView: I5 } = e7("../ours/util").types, S6 = {};
    function R5(e8) {
      return e8 === (0 | e8);
    }
    function k5(e8) {
      return e8 === e8 >>> 0;
    }
    const j5 = /^[0-7]+$/, D4 = "must be a 32-bit unsigned integer or an octal string";
    function N10(e8, t2, r2) {
      if (void 0 === e8 && (e8 = r2), "string" == typeof e8) {
        if (null === f5(j5, e8))
          throw new b7(t2, e8, D4);
        e8 = d5(e8, 8);
      }
      return A5(e8, t2), e8;
    }
    const O3 = g5((e8, t2, r2 = c3, n5 = u4) => {
      if ("number" != typeof e8)
        throw new w5(t2, "number", e8);
      if (!s3(e8))
        throw new _5(t2, "an integer", e8);
      if (e8 < r2 || e8 > n5)
        throw new _5(t2, `>= ${r2} && <= ${n5}`, e8);
    }), C5 = g5((e8, t2, r2 = -2147483648, n5 = 2147483647) => {
      if ("number" != typeof e8)
        throw new w5(t2, "number", e8);
      if (!s3(e8))
        throw new _5(t2, "an integer", e8);
      if (e8 < r2 || e8 > n5)
        throw new _5(t2, `>= ${r2} && <= ${n5}`, e8);
    }), A5 = g5((e8, t2, r2 = false) => {
      if ("number" != typeof e8)
        throw new w5(t2, "number", e8);
      if (!s3(e8))
        throw new _5(t2, "an integer", e8);
      const n5 = r2 ? 1 : 0, i5 = 4294967295;
      if (e8 < n5 || e8 > i5)
        throw new _5(t2, `>= ${n5} && <= ${i5}`, e8);
    });
    function M6(e8, t2) {
      if ("string" != typeof e8)
        throw new w5(t2, "string", e8);
    }
    function L4(e8, t2, r2 = void 0, n5) {
      if ("number" != typeof e8)
        throw new w5(t2, "number", e8);
      if (null != r2 && e8 < r2 || null != n5 && e8 > n5 || (null != r2 || null != n5) && l6(e8))
        throw new _5(t2, `${null != r2 ? `>= ${r2}` : ""}${null != r2 && null != n5 ? " && " : ""}${null != n5 ? `<= ${n5}` : ""}`, e8);
    }
    const P5 = g5((e8, t2, r2) => {
      if (!i4(r2, e8)) {
        const n5 = o4(a4(r2, (e9) => "string" == typeof e9 ? `'${e9}'` : p6(e9)), ", ");
        throw new b7(t2, e8, "must be one of: " + n5);
      }
    });
    function B6(e8, t2) {
      if ("boolean" != typeof e8)
        throw new w5(t2, "boolean", e8);
    }
    function $4(e8, t2, r2) {
      return null != e8 && h6(e8, t2) ? e8[t2] : r2;
    }
    const F4 = g5((e8, t2, r2 = null) => {
      const i5 = $4(r2, "allowArray", false), o5 = $4(r2, "allowFunction", false);
      if (!$4(r2, "nullable", false) && null === e8 || !i5 && n4(e8) || "object" != typeof e8 && (!o5 || "function" != typeof e8))
        throw new w5(t2, "Object", e8);
    }), U6 = g5((e8, t2) => {
      if (null != e8 && "object" != typeof e8 && "function" != typeof e8)
        throw new w5(t2, "a dictionary", e8);
    }), q5 = g5((e8, t2, r2 = 0) => {
      if (!n4(e8))
        throw new w5(t2, "Array", e8);
      if (e8.length < r2)
        throw new b7(t2, e8, `must be longer than ${r2}`);
    });
    function Y5(e8, t2) {
      q5(e8, t2);
      for (let r2 = 0; r2 < e8.length; r2++)
        M6(e8[r2], `${t2}[${r2}]`);
    }
    function W5(e8, t2) {
      q5(e8, t2);
      for (let r2 = 0; r2 < e8.length; r2++)
        B6(e8[r2], `${t2}[${r2}]`);
    }
    function z6(e8, t2 = "signal") {
      if (M6(e8, t2), void 0 === S6[e8]) {
        if (void 0 !== S6[m5(e8)])
          throw new E4(e8 + " (signals must use all capital letters)");
        throw new E4(e8);
      }
    }
    const G7 = g5((e8, t2 = "buffer") => {
      if (!I5(e8))
        throw new w5(t2, ["Buffer", "TypedArray", "DataView"], e8);
    });
    function H4(e8, t2) {
      const r2 = T6(t2), n5 = e8.length;
      if ("hex" === r2 && n5 % 2 != 0)
        throw new b7("encoding", t2, `is invalid for data of length ${n5}`);
    }
    function J4(e8, t2 = "Port", r2 = true) {
      if ("number" != typeof e8 && "string" != typeof e8 || "string" == typeof e8 && 0 === y5(e8).length || +e8 != +e8 >>> 0 || e8 > 65535 || 0 === e8 && !r2)
        throw new v6(t2, e8, r2);
      return 0 | e8;
    }
    const V5 = g5((e8, t2) => {
      if (void 0 !== e8 && (null === e8 || "object" != typeof e8 || !("aborted" in e8)))
        throw new w5(t2, "AbortSignal", e8);
    }), Q5 = g5((e8, t2) => {
      if ("function" != typeof e8)
        throw new w5(t2, "Function", e8);
    }), Z5 = g5((e8, t2) => {
      if ("function" != typeof e8 || x6(e8))
        throw new w5(t2, "Function", e8);
    }), K4 = g5((e8, t2) => {
      if (void 0 !== e8)
        throw new w5(t2, "undefined", e8);
    });
    function X5(e8, t2, r2) {
      if (!i4(r2, e8))
        throw new w5(t2, `('${o4(r2, "|")}')`, e8);
    }
    const ee2 = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function te2(e8, t2) {
      if (void 0 === e8 || !f5(ee2, e8))
        throw new b7(t2, e8, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    function re2(e8) {
      if ("string" == typeof e8)
        return te2(e8, "hints"), e8;
      if (n4(e8)) {
        const t2 = e8.length;
        let r2 = "";
        if (0 === t2)
          return r2;
        for (let n5 = 0; n5 < t2; n5++) {
          const i5 = e8[n5];
          te2(i5, "hints"), r2 += i5, n5 !== t2 - 1 && (r2 += ", ");
        }
        return r2;
      }
      throw new b7("hints", e8, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
    }
    t.exports = { isInt32: R5, isUint32: k5, parseFileMode: N10, validateArray: q5, validateStringArray: Y5, validateBooleanArray: W5, validateBoolean: B6, validateBuffer: G7, validateDictionary: U6, validateEncoding: H4, validateFunction: Q5, validateInt32: C5, validateInteger: O3, validateNumber: L4, validateObject: F4, validateOneOf: P5, validatePlainFunction: Z5, validatePort: J4, validateSignalName: z6, validateString: M6, validateUint32: A5, validateUndefined: K4, validateUnion: X5, validateAbortSignal: V5, validateLinkHeaderValue: re2 };
  }, { "../ours/errors": 39, "../ours/primordials": 40, "../ours/util": 41 }], 38: [function(e7, t, r) {
    const n4 = e7("../stream"), i4 = e7("../stream/promises"), o4 = n4.Readable.destroy;
    t.exports = n4.Readable, t.exports._uint8ArrayToBuffer = n4._uint8ArrayToBuffer, t.exports._isUint8Array = n4._isUint8Array, t.exports.isDisturbed = n4.isDisturbed, t.exports.isErrored = n4.isErrored, t.exports.isReadable = n4.isReadable, t.exports.Readable = n4.Readable, t.exports.Writable = n4.Writable, t.exports.Duplex = n4.Duplex, t.exports.Transform = n4.Transform, t.exports.PassThrough = n4.PassThrough, t.exports.addAbortSignal = n4.addAbortSignal, t.exports.finished = n4.finished, t.exports.destroy = n4.destroy, t.exports.destroy = o4, t.exports.pipeline = n4.pipeline, t.exports.compose = n4.compose, Object.defineProperty(n4, "promises", { configurable: true, enumerable: true, get: () => i4 }), t.exports.Stream = n4.Stream, t.exports.default = t.exports;
  }, { "../stream": 42, "../stream/promises": 43 }], 39: [function(e7, t, r) {
    const { format: n4, inspect: i4, AggregateError: o4 } = e7("./util"), a4 = globalThis.AggregateError || o4, s3 = Symbol("kIsNodeError"), l6 = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], u4 = /^([A-Z][a-z0-9]*)+$/, c3 = "__node_internal_", d5 = {};
    function h6(e8, t2) {
      if (!e8)
        throw new d5.ERR_INTERNAL_ASSERTION(t2);
    }
    function f5(e8) {
      let t2 = "", r2 = e8.length;
      const n5 = "-" === e8[0] ? 1 : 0;
      for (; r2 >= n5 + 4; r2 -= 3)
        t2 = `_${e8.slice(r2 - 3, r2)}${t2}`;
      return `${e8.slice(0, r2)}${t2}`;
    }
    function p6(e8, t2, r2) {
      if ("function" == typeof t2)
        return h6(t2.length <= r2.length, `Code: ${e8}; The provided arguments length (${r2.length}) does not match the required ones (${t2.length}).`), t2(...r2);
      const i5 = (t2.match(/%[dfijoOs]/g) || []).length;
      return h6(i5 === r2.length, `Code: ${e8}; The provided arguments length (${r2.length}) does not match the required ones (${i5}).`), 0 === r2.length ? t2 : n4(t2, ...r2);
    }
    function m5(e8, t2, r2) {
      r2 || (r2 = Error);
      class n5 extends r2 {
        constructor(...r3) {
          super(p6(e8, t2, r3));
        }
        toString() {
          return `${this.name} [${e8}]: ${this.message}`;
        }
      }
      Object.defineProperties(n5.prototype, { name: { value: r2.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e8}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n5.prototype.code = e8, n5.prototype[s3] = true, d5[e8] = n5;
    }
    function y5(e8) {
      const t2 = c3 + e8.name;
      return Object.defineProperty(e8, "name", { value: t2 }), e8;
    }
    function g5(e8, t2) {
      if (e8 && t2 && e8 !== t2) {
        if (Array.isArray(t2.errors))
          return t2.errors.push(e8), t2;
        const r2 = new a4([t2, e8], t2.message);
        return r2.code = t2.code, r2;
      }
      return e8 || t2;
    }
    class v6 extends Error {
      constructor(e8 = "The operation was aborted", t2 = void 0) {
        if (void 0 !== t2 && "object" != typeof t2)
          throw new d5.ERR_INVALID_ARG_TYPE("options", "Object", t2);
        super(e8, t2), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    }
    m5("ERR_ASSERTION", "%s", Error), m5("ERR_INVALID_ARG_TYPE", (e8, t2, r2) => {
      h6("string" == typeof e8, "'name' must be a string"), Array.isArray(t2) || (t2 = [t2]);
      let n5 = "The ";
      e8.endsWith(" argument") ? n5 += `${e8} ` : n5 += `"${e8}" ${e8.includes(".") ? "property" : "argument"} `, n5 += "must be ";
      const o5 = [], a5 = [], s4 = [];
      for (const e9 of t2)
        h6("string" == typeof e9, "All expected entries have to be of type string"), l6.includes(e9) ? o5.push(e9.toLowerCase()) : u4.test(e9) ? a5.push(e9) : (h6("object" !== e9, 'The value "object" should be written as "Object"'), s4.push(e9));
      if (a5.length > 0) {
        const e9 = o5.indexOf("object");
        -1 !== e9 && (o5.splice(o5, e9, 1), a5.push("Object"));
      }
      if (o5.length > 0) {
        switch (o5.length) {
          case 1:
            n5 += `of type ${o5[0]}`;
            break;
          case 2:
            n5 += `one of type ${o5[0]} or ${o5[1]}`;
            break;
          default: {
            const e9 = o5.pop();
            n5 += `one of type ${o5.join(", ")}, or ${e9}`;
          }
        }
        (a5.length > 0 || s4.length > 0) && (n5 += " or ");
      }
      if (a5.length > 0) {
        switch (a5.length) {
          case 1:
            n5 += `an instance of ${a5[0]}`;
            break;
          case 2:
            n5 += `an instance of ${a5[0]} or ${a5[1]}`;
            break;
          default: {
            const e9 = a5.pop();
            n5 += `an instance of ${a5.join(", ")}, or ${e9}`;
          }
        }
        s4.length > 0 && (n5 += " or ");
      }
      switch (s4.length) {
        case 0:
          break;
        case 1:
          s4[0].toLowerCase() !== s4[0] && (n5 += "an "), n5 += `${s4[0]}`;
          break;
        case 2:
          n5 += `one of ${s4[0]} or ${s4[1]}`;
          break;
        default: {
          const e9 = s4.pop();
          n5 += `one of ${s4.join(", ")}, or ${e9}`;
        }
      }
      if (null == r2)
        n5 += `. Received ${r2}`;
      else if ("function" == typeof r2 && r2.name)
        n5 += `. Received function ${r2.name}`;
      else if ("object" == typeof r2) {
        var c4;
        null !== (c4 = r2.constructor) && void 0 !== c4 && c4.name ? n5 += `. Received an instance of ${r2.constructor.name}` : n5 += `. Received ${i4(r2, { depth: -1 })}`;
      } else {
        let e9 = i4(r2, { colors: false });
        e9.length > 25 && (e9 = `${e9.slice(0, 25)}...`), n5 += `. Received type ${typeof r2} (${e9})`;
      }
      return n5;
    }, TypeError), m5("ERR_INVALID_ARG_VALUE", (e8, t2, r2 = "is invalid") => {
      let n5 = i4(t2);
      return n5.length > 128 && (n5 = n5.slice(0, 128) + "..."), `The ${e8.includes(".") ? "property" : "argument"} '${e8}' ${r2}. Received ${n5}`;
    }, TypeError), m5("ERR_INVALID_RETURN_VALUE", (e8, t2, r2) => {
      var n5;
      return `Expected ${e8} to be returned from the "${t2}" function but got ${null != r2 && null !== (n5 = r2.constructor) && void 0 !== n5 && n5.name ? `instance of ${r2.constructor.name}` : "type " + typeof r2}.`;
    }, TypeError), m5("ERR_MISSING_ARGS", (...e8) => {
      let t2;
      h6(e8.length > 0, "At least one arg needs to be specified");
      const r2 = e8.length;
      switch (e8 = (Array.isArray(e8) ? e8 : [e8]).map((e9) => `"${e9}"`).join(" or "), r2) {
        case 1:
          t2 += `The ${e8[0]} argument`;
          break;
        case 2:
          t2 += `The ${e8[0]} and ${e8[1]} arguments`;
          break;
        default: {
          const r3 = e8.pop();
          t2 += `The ${e8.join(", ")}, and ${r3} arguments`;
        }
      }
      return `${t2} must be specified`;
    }, TypeError), m5("ERR_OUT_OF_RANGE", (e8, t2, r2) => {
      let n5;
      return h6(t2, 'Missing "range" argument'), Number.isInteger(r2) && Math.abs(r2) > 2 ** 32 ? n5 = f5(String(r2)) : "bigint" == typeof r2 ? (n5 = String(r2), (r2 > 2n ** 32n || r2 < -(2n ** 32n)) && (n5 = f5(n5)), n5 += "n") : n5 = i4(r2), `The value of "${e8}" is out of range. It must be ${t2}. Received ${n5}`;
    }, RangeError), m5("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), m5("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), m5("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), m5("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), m5("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), m5("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), m5("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), m5("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), m5("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), m5("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), m5("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), t.exports = { AbortError: v6, aggregateTwoErrors: y5(g5), hideStackFrames: y5, codes: d5 };
  }, { "./util": 41 }], 40: [function(e7, t, r) {
    t.exports = { ArrayIsArray: (e8) => Array.isArray(e8), ArrayPrototypeIncludes: (e8, t2) => e8.includes(t2), ArrayPrototypeIndexOf: (e8, t2) => e8.indexOf(t2), ArrayPrototypeJoin: (e8, t2) => e8.join(t2), ArrayPrototypeMap: (e8, t2) => e8.map(t2), ArrayPrototypePop: (e8, t2) => e8.pop(t2), ArrayPrototypePush: (e8, t2) => e8.push(t2), ArrayPrototypeSlice: (e8, t2, r2) => e8.slice(t2, r2), Error, FunctionPrototypeCall: (e8, t2, ...r2) => e8.call(t2, ...r2), FunctionPrototypeSymbolHasInstance: (e8, t2) => Function.prototype[Symbol.hasInstance].call(e8, t2), MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties: (e8, t2) => Object.defineProperties(e8, t2), ObjectDefineProperty: (e8, t2, r2) => Object.defineProperty(e8, t2, r2), ObjectGetOwnPropertyDescriptor: (e8, t2) => Object.getOwnPropertyDescriptor(e8, t2), ObjectKeys: (e8) => Object.keys(e8), ObjectSetPrototypeOf: (e8, t2) => Object.setPrototypeOf(e8, t2), Promise, PromisePrototypeCatch: (e8, t2) => e8.catch(t2), PromisePrototypeThen: (e8, t2, r2) => e8.then(t2, r2), PromiseReject: (e8) => Promise.reject(e8), ReflectApply: Reflect.apply, RegExpPrototypeTest: (e8, t2) => e8.test(t2), SafeSet: Set, String, StringPrototypeSlice: (e8, t2, r2) => e8.slice(t2, r2), StringPrototypeToLowerCase: (e8) => e8.toLowerCase(), StringPrototypeToUpperCase: (e8) => e8.toUpperCase(), StringPrototypeTrim: (e8) => e8.trim(), Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet: (e8, t2, r2) => e8.set(t2, r2), Uint8Array };
  }, {}], 41: [function(e7, t, r) {
    const n4 = e7("buffer"), i4 = Object.getPrototypeOf(async function() {
    }).constructor, o4 = globalThis.Blob || n4.Blob, a4 = void 0 !== o4 ? function(e8) {
      return e8 instanceof o4;
    } : function(e8) {
      return false;
    };
    class s3 extends Error {
      constructor(e8) {
        if (!Array.isArray(e8))
          throw new TypeError("Expected input to be an Array, got " + typeof e8);
        let t2 = "";
        for (let r2 = 0; r2 < e8.length; r2++)
          t2 += `    ${e8[r2].stack}
`;
        super(t2), this.name = "AggregateError", this.errors = e8;
      }
    }
    t.exports = { AggregateError: s3, kEmptyObject: Object.freeze({}), once(e8) {
      let t2 = false;
      return function(...r2) {
        t2 || (t2 = true, e8.apply(this, r2));
      };
    }, createDeferredPromise: function() {
      let e8, t2;
      return { promise: new Promise((r2, n5) => {
        e8 = r2, t2 = n5;
      }), resolve: e8, reject: t2 };
    }, promisify: (e8) => new Promise((t2, r2) => {
      e8((e9, ...n5) => e9 ? r2(e9) : t2(...n5));
    }), debuglog: () => function() {
    }, format: (e8, ...t2) => e8.replace(/%([sdifj])/g, function(...[e9, r2]) {
      const n5 = t2.shift();
      return "f" === r2 ? n5.toFixed(6) : "j" === r2 ? JSON.stringify(n5) : "s" === r2 && "object" == typeof n5 ? `${n5.constructor !== Object ? n5.constructor.name : ""} {}`.trim() : n5.toString();
    }), inspect(e8) {
      switch (typeof e8) {
        case "string":
          if (e8.includes("'")) {
            if (!e8.includes('"'))
              return `"${e8}"`;
            if (!e8.includes("`") && !e8.includes("${"))
              return `\`${e8}\``;
          }
          return `'${e8}'`;
        case "number":
          return isNaN(e8) ? "NaN" : Object.is(e8, -0) ? String(e8) : e8;
        case "bigint":
          return `${String(e8)}n`;
        case "boolean":
        case "undefined":
          return String(e8);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction: (e8) => e8 instanceof i4, isArrayBufferView: (e8) => ArrayBuffer.isView(e8) }, isBlob: a4 }, t.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }, { buffer: 15 }], 42: [function(e7, t, r) {
    const { Buffer: n4 } = e7("buffer"), { ObjectDefineProperty: i4, ObjectKeys: o4, ReflectApply: a4 } = e7("./ours/primordials"), { promisify: { custom: s3 } } = e7("./ours/util"), { streamReturningOperators: l6, promiseReturningOperators: u4 } = e7("./internal/streams/operators"), { codes: { ERR_ILLEGAL_CONSTRUCTOR: c3 } } = e7("./ours/errors"), d5 = e7("./internal/streams/compose"), { pipeline: h6 } = e7("./internal/streams/pipeline"), { destroyer: f5 } = e7("./internal/streams/destroy"), p6 = e7("./internal/streams/end-of-stream"), m5 = e7("./stream/promises"), y5 = e7("./internal/streams/utils"), g5 = t.exports = e7("./internal/streams/legacy").Stream;
    g5.isDisturbed = y5.isDisturbed, g5.isErrored = y5.isErrored, g5.isReadable = y5.isReadable, g5.Readable = e7("./internal/streams/readable");
    for (const w5 of o4(l6)) {
      let _5 = function(...e8) {
        if (new.target)
          throw c3();
        return g5.Readable.from(a4(b7, this, e8));
      };
      const b7 = l6[w5];
      i4(_5, "name", { __proto__: null, value: b7.name }), i4(_5, "length", { __proto__: null, value: b7.length }), i4(g5.Readable.prototype, w5, { __proto__: null, value: _5, enumerable: false, configurable: true, writable: true });
    }
    for (const E4 of o4(u4)) {
      let x6 = function(...e8) {
        if (new.target)
          throw c3();
        return a4(T6, this, e8);
      };
      const T6 = u4[E4];
      i4(x6, "name", { __proto__: null, value: T6.name }), i4(x6, "length", { __proto__: null, value: T6.length }), i4(g5.Readable.prototype, E4, { __proto__: null, value: x6, enumerable: false, configurable: true, writable: true });
    }
    g5.Writable = e7("./internal/streams/writable"), g5.Duplex = e7("./internal/streams/duplex"), g5.Transform = e7("./internal/streams/transform"), g5.PassThrough = e7("./internal/streams/passthrough"), g5.pipeline = h6;
    const { addAbortSignal: v6 } = e7("./internal/streams/add-abort-signal");
    g5.addAbortSignal = v6, g5.finished = p6, g5.destroy = f5, g5.compose = d5, i4(g5, "promises", { __proto__: null, configurable: true, enumerable: true, get: () => m5 }), i4(h6, s3, { __proto__: null, enumerable: true, get: () => m5.pipeline }), i4(p6, s3, { __proto__: null, enumerable: true, get: () => m5.finished }), g5.Stream = g5, g5._isUint8Array = function(e8) {
      return e8 instanceof Uint8Array;
    }, g5._uint8ArrayToBuffer = function(e8) {
      return n4.from(e8.buffer, e8.byteOffset, e8.byteLength);
    };
  }, { "./internal/streams/add-abort-signal": 20, "./internal/streams/compose": 22, "./internal/streams/destroy": 23, "./internal/streams/duplex": 24, "./internal/streams/end-of-stream": 26, "./internal/streams/legacy": 28, "./internal/streams/operators": 29, "./internal/streams/passthrough": 30, "./internal/streams/pipeline": 31, "./internal/streams/readable": 32, "./internal/streams/transform": 34, "./internal/streams/utils": 35, "./internal/streams/writable": 36, "./ours/errors": 39, "./ours/primordials": 40, "./ours/util": 41, "./stream/promises": 43, buffer: 15 }], 43: [function(e7, t, r) {
    const { ArrayPrototypePop: n4, Promise: i4 } = e7("../ours/primordials"), { isIterable: o4, isNodeStream: a4, isWebStream: s3 } = e7("../internal/streams/utils"), { pipelineImpl: l6 } = e7("../internal/streams/pipeline"), { finished: u4 } = e7("../internal/streams/end-of-stream");
    function c3(...e8) {
      return new i4((t2, r2) => {
        let i5, u5;
        const c4 = e8[e8.length - 1];
        if (c4 && "object" == typeof c4 && !a4(c4) && !o4(c4) && !s3(c4)) {
          const t3 = n4(e8);
          i5 = t3.signal, u5 = t3.end;
        }
        l6(e8, (e9, n5) => {
          e9 ? r2(e9) : t2(n5);
        }, { signal: i5, end: u5 });
      });
    }
    e7("../../lib/stream.js"), t.exports = { finished: u4, pipeline: c3 };
  }, { "../../lib/stream.js": 42, "../internal/streams/end-of-stream": 26, "../internal/streams/pipeline": 31, "../internal/streams/utils": 35, "../ours/primordials": 40 }] }, {}, [10])(10);
  var Qh = Vh.exports;
  var Zh = class {
    constructor(e7, t) {
      this.graphName = e7, this.idx = t;
    }
    toString() {
      return `${this.graphName}:${this.idx}`;
    }
  };
  var Kh = class {
    constructor(e7, t) {
      this.tp = e7, this.val = t;
    }
    toString() {
      return JSON.stringify(this);
    }
    static getRefFromQuad(e7) {
      return e7.termType === rs.IRI ? new Kh(rs.IRI, e7.value) : e7.termType === rs.BlankNode ? new Kh(rs.BlankNode, e7.value) : new Kh(rs.Undefined, "");
    }
  };
  var Xh = class {
    async loadDocument(e7, t = []) {
      const r = e7.startsWith("http:"), n4 = e7.startsWith("https:");
      if (!r && !n4)
        throw new rl('URL could not be dereferenced; only "http" and "https" URLs are supported.', "jsonld.InvalidUrl", { code: "loading document failed", url: e7 });
      let i4 = null;
      const { res: o4, body: a4 } = await rf({ url: e7 }), s3 = { contextUrl: null, documentUrl: e7, document: a4 || null };
      if (o4.status >= 400)
        throw new rl(`URL "${e7}" could not be dereferenced: ${o4.statusText}`, "jsonld.InvalidUrl", { code: "loading document failed", url: e7, httpStatusCode: o4.status });
      const l6 = o4.headers.get("link");
      let u4 = o4.headers.get("location");
      const c3 = o4.headers.get("content-type");
      if (l6 && "application/ld+json" !== c3 && "application/json" !== c3) {
        const t2 = hl.parseLinkHeader(l6), r2 = t2[vl.LINK_HEADER_CONTEXT];
        if (Array.isArray(r2))
          throw new rl("URL could not be dereferenced, it has more than one associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url: e7 });
        r2 && (s3.contextUrl = r2.target), i4 = t2.alternate, i4 && "application/ld+json" == i4.type && !(c3 || "").match(/^application\/(\w*\+)?json$/) && (u4 = El.prependBase(e7, i4.target));
      }
      if ((i4 || o4.status >= 300 && o4.status < 400) && u4) {
        if (-1 === t.length)
          throw new rl("URL could not be dereferenced; there were too many redirects.", "jsonld.TooManyRedirects", { code: "loading document failed", url: e7, httpStatusCode: o4.status, redirects: t });
        if (-1 !== t.indexOf(e7))
          throw new rl("URL could not be dereferenced; infinite redirection was detected.", "jsonld.InfiniteRedirectDetected", { code: "recursive context inclusion", url: e7, httpStatusCode: o4.status, redirects: t });
        t.push(e7);
        const r2 = new URL(u4, e7).href;
        return this.loadDocument(r2, t);
      }
      return t.push(e7), s3;
    }
  };
  var ef = "cat";
  async function tf(e7, t, r) {
    if (!t && !r)
      throw new rl("IPFS is not configured", "jsonld.IPFSNotConfigured", { code: "loading document failed", url: nf + e7 });
    return null !== t ? await async function(e8, t2) {
      const r2 = new URL(function(e9, t3) {
        const r3 = "/api/v0";
        for (; e9.endsWith("/"); )
          e9 = e9.slice(0, -1);
        return e9.endsWith(r3) || (e9 += r3), e9 + "/" + t3;
      }(t2, ef));
      r2.searchParams.append("arg", e8);
      const { res: n4, body: i4 } = await rf({ url: r2, method: "POST" });
      if (200 != n4.status)
        throw new Error(`Error calling IPFS node: [${n4.status}] ${n4.statusText}
${i4}`);
      return { contextUrl: null, document: i4 || null, documentUrl: nf + e8 };
    }(e7, t) : await async function(e8, t2) {
      const r2 = new Xh(), n4 = await r2.loadDocument(function(e9, t3) {
        return function(e10) {
          for (; e10.endsWith("/"); )
            e10 = e10.slice(0, -1);
          return e10;
        }(e9) + "/ipfs/" + function(e10) {
          for (; e10.startsWith("/"); )
            e10 = e10.slice(1);
          return e10;
        }(t3);
      }(t2, e8), []);
      return n4.contextUrl = null, n4.documentUrl = nf + e8, n4;
    }(e7, r);
  }
  async function rf({ url: e7, method: t }) {
    const r = {};
    void 0 !== t && (r.method = t);
    try {
      (e7 = new URL(e7)).username && e7.password && (r.headers = { ...r.headers ?? {}, authorization: `Basic ${btoa(e7.username + ":" + e7.password)}` }, e7 = function(e8) {
        const t3 = new URL(e8);
        return t3.username = "", t3.password = "", t3.href;
      }(e7));
      const t2 = await fetch(e7, r);
      if (t2.status >= 300 && t2.status < 400)
        return { res: t2, body: null };
      const n4 = await t2.text();
      return n4 && n4.length > 0 && n4.startsWith("{") ? { res: t2, body: JSON.parse(n4) } : { res: t2, body: n4 };
    } catch (t2) {
      if (t2.response)
        return { res: t2.response, body: null };
      throw new rl("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url: e7, cause: t2 });
    }
  }
  var nf = "ipfs://";
  function of(e7) {
    return e7?.hasher ?? a3;
  }
  function af(e7) {
    const t = e7?.ipfsNodeURL ?? null, r = e7?.ipfsGatewayURL ?? null;
    return e7?.documentLoader ?? ((e8 = null, t2 = null) => async (r2) => {
      if (r2.startsWith(nf)) {
        const n4 = r2.slice(nf.length);
        return await tf(n4, e8, t2);
      }
      return new Xh().loadDocument(r2, []);
    })(t, r);
  }
  var sf = class {
    constructor(e7 = /* @__PURE__ */ new Map()) {
      this.graphs = e7;
    }
    static async fromDocument(e7, t = af()) {
      const r = await Hh.canonize(e7, { format: i3.QUADS_FORMAT, documentLoader: t }), n4 = new Qh.Parser({ format: i3.QUADS_FORMAT }).parse(r), o4 = new sf();
      for (const e8 of n4) {
        const t2 = e8.graph.termType === i3.DEFAULT_GRAPH_TERM_TYPE ? i3.DEFAULT_GRAPH_NODE_NAME : e8.graph.value, r2 = o4.graphs.get(t2) ?? [];
        r2.push(e8), o4.graphs.set(t2, r2);
      }
      return o4;
    }
    static getQuad(e7, t) {
      const r = e7.graphs.get(t.graphName);
      if (!r)
        throw i3.ERRORS.GRAPH_NOT_FOUND;
      if (t.idx >= r.length)
        throw i3.ERRORS.QUAD_NOT_FOUND;
      return r[t.idx];
    }
    static iterGraphsOrdered(e7, t) {
      const r = [];
      for (const t2 of e7.graphs.keys())
        r.push(t2);
      r.sort((e8, t2) => e8.localeCompare(t2));
      for (const n4 of r) {
        t(n4, e7.graphs.get(n4));
      }
    }
    static findParent(e7, t) {
      const r = sf.findParentInsideGraph(e7, t);
      return r || sf.findGraphParent(e7, t);
    }
    static findParentInsideGraph(e7, t) {
      const r = os(t);
      let n4;
      const o4 = e7.graphs.get(r);
      if (!o4)
        return;
      const a4 = Kh.getRefFromQuad(t.subject);
      if (a4.tp === rs.Undefined)
        return;
      let s3 = false;
      for (let e8 = 0; e8 < o4.length; e8++) {
        const l6 = o4[e8];
        if (l6.equals(t))
          continue;
        const u4 = Kh.getRefFromQuad(l6.object);
        if (u4.tp !== rs.Undefined && (a4?.tp === u4?.tp && a4?.val === u4?.val)) {
          if (s3)
            throw i3.ERRORS.MULTIPLE_PARENTS_FOUND;
          s3 = true, n4 = new Zh(r, e8);
        }
      }
      return n4;
    }
    static findGraphParent(e7, t) {
      if (!t.graph)
        return;
      const r = Kh.getRefFromQuad(t.graph);
      if (r.tp === rs.Undefined)
        return;
      if (r.tp !== rs.BlankNode)
        throw new Error("graph parent can only be a blank node");
      let n4, o4 = false;
      for (const [a4, s3] of e7.graphs)
        for (let e8 = 0; e8 < s3.length; e8++) {
          const l6 = s3[e8];
          if (l6.equals(t))
            continue;
          const u4 = Kh.getRefFromQuad(l6.object);
          if (u4.tp !== rs.Undefined && r.toString() == u4.toString()) {
            if (o4)
              throw i3.ERRORS.MULTIPLE_PARENTS_FOUND;
            o4 = true, n4 = new Zh(a4, e8);
          }
        }
      if (o4)
        return n4;
      throw i3.ERRORS.PARENT_NOT_FOUND;
    }
  };
  sf.assertDatasetConsistency = (e7) => {
    for (const [t, r] of e7.graphs)
      for (const e8 of r) {
        if (!t)
          throw new Error("empty graph name");
        if (t === i3.DEFAULT_GRAPH_NODE_NAME && e8.graph.id)
          throw new Error("graph should be nil for @default graph");
        if (!e8.graph.id && t !== i3.DEFAULT_GRAPH_NODE_NAME)
          throw new Error("graph should not be nil for non-@default graph");
      }
  };
  var lf = class {
    constructor(e7 = [], t = a3) {
      this.parts = e7, this.hasher = t;
    }
    reverse() {
      return this.parts.reverse();
    }
    append(e7) {
      this.parts = [...this.parts, ...e7];
    }
    prepend(e7) {
      this.parts = [...e7, ...this.parts];
    }
    async mtEntry() {
      const e7 = this.hasher ?? a3, t = new Array(this.parts.length).fill(BigInt(0));
      for (let r = 0; r < this.parts.length; r += 1) {
        const n4 = this.parts[r];
        if ("string" == typeof n4) {
          const i4 = ss.encode(n4);
          t[r] = await e7.hashBytes(i4);
        } else {
          if ("number" != typeof n4)
            throw new Error("error: unexpected type " + typeof n4);
          t[r] = BigInt(n4);
        }
      }
      return e7.hash(t);
    }
    async pathFromContext(e7, t, r) {
      const n4 = JSON.parse(e7);
      if (!n4["@context"])
        throw i3.ERRORS.CONTEXT_NOT_DEFINED;
      const o4 = { documentLoader: af(r) }, a4 = await Hh.processContext(null, null, o4);
      let s3 = await Hh.processContext(a4, n4, o4);
      const l6 = t.split(".");
      for (const e8 in l6) {
        const t2 = l6[e8];
        if (i3.DIGITS_ONLY_REGEX.test(t2))
          this.parts.push(parseInt(t2));
        else {
          const e9 = s3.mappings.get(t2);
          if ("object" != typeof e9)
            throw i3.ERRORS.TERM_IS_NOT_DEFINED;
          const r2 = e9["@id"];
          if (!r2)
            throw i3.ERRORS.NO_ID_ATTR;
          e9["@context"] && (s3 = await Hh.processContext(s3, e9, o4)), this.parts.push(r2);
        }
      }
    }
    async typeFromContext(e7, t, r) {
      const n4 = JSON.parse(e7);
      if (!("@context" in n4))
        throw i3.ERRORS.PARSED_CONTEXT_IS_NULL;
      const o4 = { documentLoader: af(r) }, a4 = await Hh.processContext(null, null, o4);
      let s3 = await Hh.processContext(a4, n4, o4);
      const l6 = t.split(".");
      for (const e8 in l6) {
        const t2 = uf(s3, l6[e8]);
        t2.hasContext && (s3 = await Hh.processContext(s3, t2.typeDef, o4)), this.parts.push(t2["@id"]);
      }
      return lf.getTypeMapping(s3, l6[l6.length - 1]);
    }
    static getTypeMapping(e7, t) {
      let r = "";
      const n4 = e7.mappings.get("@type");
      n4 && (r = n4);
      const i4 = e7.mappings.get(t);
      return i4 && i4["@type"] && (r = i4["@type"]), r;
    }
    static async pathFromDocument(e7, t, r, n4, o4) {
      if (0 === r.length)
        return [];
      const a4 = r[0], s3 = r.slice(1), l6 = { documentLoader: af(o4) };
      if (i3.DIGITS_ONLY_REGEX.test(a4)) {
        return [parseInt(a4), ...await lf.pathFromDocument(e7, t, s3, true, o4)];
      }
      if ("object" != typeof t)
        throw new Error("error: expected type object got " + typeof t);
      if (Array.isArray(t)) {
        if (!t.length)
          throw new Error("error: can't generate path on zero-sized array");
        if (!n4)
          throw i3.ERRORS.UNEXPECTED_ARR_ELEMENT;
        return lf.pathFromDocument(e7, t[0], r, false, o4);
      }
      if ("@context" in t)
        if (e7)
          e7 = await Hh.processContext(e7, t, l6);
        else {
          const r2 = await Hh.processContext(null, null, l6);
          e7 = await Hh.processContext(r2, t, l6);
        }
      const u4 = as(Object.keys(t)), c3 = e7;
      for (const r2 in u4) {
        const n5 = u4[r2];
        if ("@type" !== n5) {
          const t2 = e7.mappings.get(n5);
          if ("object" != typeof t2)
            continue;
          if ("@type" !== t2["@id"])
            continue;
        }
        let i4 = [];
        if (Array.isArray(t[n5]))
          t[n5].forEach((e8) => {
            if ("string" != typeof e8)
              throw new Error("error: @type value must be an array of strings: " + typeof e8);
            i4.push(e8), i4 = as(i4);
          });
        else {
          if ("string" != typeof t[n5])
            throw new Error("error: unexpected @type field type: " + typeof t[n5]);
          i4.push(t[n5]);
        }
        for (const t2 of i4) {
          const r3 = c3.mappings.get(t2);
          "object" == typeof r3 && "@context" in r3 && (e7 = await Hh.processContext(e7, r3, l6));
        }
        break;
      }
      const d5 = uf(e7, a4);
      if (d5.hasContext)
        if (e7)
          e7 = await Hh.processContext(e7, d5.typeDef, l6);
        else {
          const t2 = await Hh.processContext(null, null, l6);
          e7 = await Hh.processContext(t2, d5.typeDef, l6);
        }
      const h6 = await lf.pathFromDocument(e7, t[a4], s3, true, o4);
      return [d5["@id"], ...h6];
    }
    static async newPathFromCtx(e7, t, r) {
      const n4 = new lf([], of(r));
      return await n4.pathFromContext(e7, t, r), n4;
    }
    static async fromDocument(e7, t, r, n4) {
      const o4 = JSON.parse(t), a4 = r.split(".");
      if (0 === a4.length)
        throw i3.ERRORS.FIELD_PATH_IS_EMPTY;
      const s3 = await lf.pathFromDocument(e7, o4, a4, false, n4);
      return new lf(s3, of(n4));
    }
    static async newTypeFromContext(e7, t, r) {
      const n4 = new lf([], of(r));
      return await n4.typeFromContext(e7, t, r);
    }
    static async getTypeIDFromContext(e7, t, r) {
      const n4 = JSON.parse(e7), i4 = { documentLoader: af(r) }, o4 = await Hh.processContext(null, null, i4), a4 = (await Hh.processContext(o4, n4, i4)).mappings.get(t);
      if (!a4)
        throw new Error(`looks like ${t} is not a type`);
      const s3 = a4["@id"];
      if (!s3)
        throw new Error(`@id attribute is not found for type ${t}`);
      if ("string" != typeof s3)
        throw new Error(`@id attribute is not a string for type ${t}`);
      return s3;
    }
  };
  function uf(e7, t) {
    const r = e7.mappings.get(t);
    if ("object" != typeof r)
      throw i3.ERRORS.TERM_IS_NOT_DEFINED;
    const n4 = r["@id"];
    if (!n4)
      throw i3.ERRORS.NO_ID_ATTR;
    if ("string" != typeof n4)
      throw new Error("error: @id attr is not of type string: " + typeof n4);
    return { "@id": n4, hasContext: "@context" in r, typeDef: r };
  }
  lf.newPath = (e7) => {
    const t = new lf();
    return t.append(e7), t;
  }, lf.getContextPathKey = async (e7, t, r, n4) => {
    if ("" === t)
      throw i3.ERRORS.CTX_TYP_IS_EMPTY;
    if ("" === r)
      throw i3.ERRORS.FIELD_PATH_IS_EMPTY;
    const o4 = await lf.newPathFromCtx(e7, `${t}.${r}`, n4), a4 = await lf.newPathFromCtx(e7, t, n4);
    return new lf(o4.parts.slice(a4.parts.length));
  };
  var cf = class {
    constructor(e7) {
      this.graph = os(e7);
      const t = e7.subject;
      switch (t.termType) {
        case rs.IRI:
          this.subject = { tp: rs.IRI, val: t.value };
          break;
        case rs.BlankNode:
          this.subject = { tp: rs.BlankNode, val: t.value };
          break;
        default:
          throw new Error("invalid subject type");
      }
      if (e7.predicate.termType !== rs.IRI)
        throw new Error("invalid predicate type");
      this.predicate = e7.predicate.value;
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  cf.countEntries = (e7) => {
    const t = /* @__PURE__ */ new Map();
    for (const r of e7) {
      const e8 = new cf(r);
      let n4 = t.get(e8.toString()) ?? 0;
      t.set(e8.toString(), ++n4);
    }
    return t;
  };
  var df = class {
    constructor(e7 = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), r = a3) {
      this.parents = e7, this.children = t, this.hasher = r;
    }
    static getIriValue(e7) {
      if (e7.predicate.termType === rs.IRI)
        return e7.predicate.value;
      throw new Error("type is not IRI");
    }
    path(e7, t, r) {
      const n4 = new lf([], this.hasher);
      "number" == typeof r && n4.append([r]);
      const i4 = sf.getQuad(t, e7), o4 = df.getIriValue(i4);
      n4.append([o4]);
      let a4 = e7;
      for (; ; ) {
        const e8 = this.parents.get(a4.toString());
        if (!e8)
          break;
        const r2 = sf.getQuad(t, e8), i5 = new cf(r2), o5 = this.children.get(i5.toString());
        if (!o5)
          throw new Error("parent mapping not found");
        const s3 = sf.getQuad(t, a4), l6 = Kh.getRefFromQuad(s3.subject), u4 = o5.get(l6.toString());
        if ("number" != typeof u4)
          throw new Error("child not found in parents mapping");
        const c3 = df.getIriValue(r2);
        1 === o5.size ? n4.append([c3]) : n4.append([u4, c3]), a4 = e8;
      }
      return n4.reverse(), n4;
    }
    static async newRelationship(e7, t) {
      const r = new df(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), t);
      return sf.iterGraphsOrdered(e7, (t2, n4) => {
        for (let i4 = 0; i4 < n4.length; i4++) {
          const o4 = n4[i4], a4 = sf.findParent(e7, o4);
          if (!a4)
            continue;
          const s3 = new Zh(t2, i4);
          r.parents.set(s3.toString(), a4);
          const l6 = sf.getQuad(e7, a4), u4 = new cf(l6);
          let c3 = r.children.get(u4.toString());
          c3 || (c3 = /* @__PURE__ */ new Map(), r.children.set(u4.toString(), c3));
          const d5 = Kh.getRefFromQuad(o4.subject);
          if ("number" != typeof c3.get(d5.toString())) {
            const e8 = c3.size;
            c3.set(d5.toString(), e8);
          }
        }
      }), r;
    }
  };
  var hf = class {
    constructor(e7, t, r = "", n4 = a3) {
      if (this.key = e7, this.value = t, this.dataType = r, this.hasher = n4, !e7.parts.length)
        throw new Error("key length is zero");
      ((e8) => {
        switch (typeof e8) {
          case "boolean":
          case "string":
          case "bigint":
          case "number":
            return;
          case "object":
            if (e8 instanceof es.Instant)
              return;
        }
        throw new Error(`unexpected value type ${typeof e8}, expected boolean | number | Temporal.Instant | string`);
      })(t);
    }
    getHasher() {
      return this.hasher;
    }
    getKeyMtEntry() {
      return this.key.mtEntry();
    }
    getValueMtEntry() {
      return hs.mkValueMtEntry(this.getHasher(), this.value);
    }
    async getKeyValueMTEntry() {
      return { k: await this.getKeyMtEntry(), v: await this.getValueMtEntry() };
    }
    static async fromDataSet(e7, t = a3) {
      sf.assertDatasetConsistency(e7);
      if (!e7.graphs.get(i3.DEFAULT_GRAPH_NODE_NAME).length)
        throw new Error("@default graph not found in dataset");
      const r = await df.newRelationship(e7, t), n4 = [];
      return sf.iterGraphsOrdered(e7, (i4, o4) => {
        const a4 = cf.countEntries(o4), s3 = /* @__PURE__ */ new Map();
        for (let l6 = 0; l6 < o4.length; l6++) {
          let u4 = "";
          const c3 = o4[l6], d5 = new Zh(i4, l6), h6 = new cf(c3);
          let f5;
          const p6 = c3.object.termType, m5 = c3.object.value;
          switch (p6) {
            case rs.Literal:
              u4 = c3?.object?.datatype?.value, f5 = us(u4, m5, t.prime());
              break;
            case rs.IRI:
              if (!p6)
                throw new Error("object IRI is nil");
              f5 = m5;
              break;
            case rs.BlankNode:
              if (r.children.get(h6.toString()))
                continue;
              throw new Error("BlankNode is not supported yet");
            case "Variable":
              f5 = m5;
              break;
            default:
              throw new Error("unexpected Quad's Object type");
          }
          let y5;
          switch (a4.get(h6.toString())) {
            case 0:
              throw new Error("[assertion] key not found in counts");
            case 1:
              break;
            default:
              const e8 = h6.toString();
              y5 = s3.get(e8) ?? 0, s3.set(e8, y5 + 1);
          }
          const g5 = r.path(d5, e7, y5), v6 = new hf(g5, f5, u4, t);
          n4.push(v6);
        }
      }), n4;
    }
  };
  hf.newRDFEntry = (e7, t) => {
    const r = new hf(e7, t);
    switch (typeof t) {
      case "number":
      case "string":
      case "boolean":
        r.value = t;
        break;
      default:
        if (!(t instanceof es.Instant))
          throw new Error("error: incorrect value type " + typeof t);
        r.value = t;
    }
    return r;
  };
  var ff = class {
    constructor(e7 = null, i4 = null, o4 = a3, s3 = /* @__PURE__ */ new Map(), l6 = null, u4 = af()) {
      if (this.srcDoc = e7, this.mt = i4, this.hasher = o4, this.entries = s3, this.compacted = l6, this.documentLoader = u4, !i4) {
        const { db: e8, writable: i5, maxLevels: o5 } = ((e9 = "", n4 = true, i6 = 40) => ({ db: new j3(B3(e9)), writable: n4, maxLevels: i6 }))();
        this.mt = new Jt(e8, i5, o5);
      }
    }
    async proof(e7) {
      const t = await e7.mtEntry(), { proof: r } = await this.mt.generateProof(t);
      if (r.existence) {
        if (!this.entries.has(t.toString()))
          throw new Error("error: [assertion] no entry found while existence is true");
        const e8 = this.entries.get(t.toString());
        return { proof: r, value: new hs(e8.value, this.hasher) };
      }
      return { proof: r };
    }
    mkValue(e7) {
      return new hs(e7, this.hasher);
    }
    async resolveDocPath(e7, t) {
      const r = await lf.fromDocument(null, this.srcDoc, e7, t);
      return r.hasher = this.hasher, r;
    }
    async entry(e7) {
      const t = await e7.mtEntry(), r = this.entries.get(t.toString());
      if (!r)
        throw new Error("entry not found");
      return r;
    }
    async jsonLDType(e7) {
      return (await this.entry(e7)).dataType;
    }
    async root() {
      return this.mt.root();
    }
    rawValue(e7) {
      let t = e7.parts, r = this.compacted;
      const n4 = [];
      for (; t.length > 0; ) {
        const e8 = t[0];
        if ("string" == typeof e8) {
          if (n4.push(e8), r = r[e8] ?? r["@graph"][e8], !r)
            throw new Error("value not found");
        } else {
          if ("number" != typeof e8)
            throw new Error(`unexpected type of path ${n4.join(" / ")}`);
          n4.push(e8.toString()), r = this.rvExtractArrayIdx(r, e8);
        }
        t = t.slice(1);
      }
      return void 0 !== r["@value"] ? r["@value"] : r;
    }
    rvExtractArrayIdx(e7, t) {
      if (!Array.isArray(e7))
        throw new Error("expected array");
      if (t < 0 || t >= e7.length)
        throw new Error("index is out of range");
      return e7[t];
    }
    static async merklizeJSONLD(e7, t) {
      const r = of(t), n4 = af(t), i4 = new ff(e7, null, r, /* @__PURE__ */ new Map(), null, n4), o4 = JSON.parse(i4.srcDoc), a4 = await sf.fromDocument(o4, n4), s3 = await hf.fromDataSet(a4, r);
      for (const e8 of s3) {
        const t2 = await e8.getKeyMtEntry();
        i4.entries.set(t2.toString(), e8);
      }
      return await (async (e8, t2) => {
        for (const r2 of t2) {
          const { k: t3, v: n5 } = await r2.getKeyValueMTEntry();
          await e8.add(t3, n5);
        }
      })(i4.mt, s3), i4.compacted = await Hh.compact(o4, {}, { documentLoader: n4, base: null, compactArrays: true, compactToRelative: true }), i4;
    }
    static async hashValue(e7, t) {
      return this.hashValueWithHasher(a3, e7, t);
    }
    static async hashValueWithHasher(e7, t, r) {
      const n4 = ((e8, t2) => {
        const r2 = t2 === ns.Double;
        switch (typeof e8) {
          case "string":
            return r2 ? is(parseFloat(e8)) : e8;
          case "boolean":
            return `${e8}`;
          case "number":
            return r2 ? is(e8) : `${e8}`;
          default:
            throw new Error("unsupported type");
        }
      })(r, t), i4 = us(t, n4, e7.prime());
      return await hs.mkValueMtEntry(e7, i4);
    }
    get options() {
      return { hasher: this.hasher, documentLoader: this.documentLoader };
    }
  };

  // node_modules/ffjavascript/build/browser.esm.js
  var hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
  function fromString(s3, radix) {
    if (!radix || radix == 10) {
      return BigInt(s3);
    } else if (radix == 16) {
      if (s3.slice(0, 2) == "0x") {
        return BigInt(s3);
      } else {
        return BigInt("0x" + s3);
      }
    }
  }
  var e6 = fromString;
  function fromArray(a4, radix) {
    let acc = BigInt(0);
    radix = BigInt(radix);
    for (let i4 = 0; i4 < a4.length; i4++) {
      acc = acc * radix + BigInt(a4[i4]);
    }
    return acc;
  }
  function bitLength$6(a4) {
    const aS = a4.toString(16);
    return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
  }
  function isNegative$4(a4) {
    return BigInt(a4) < BigInt(0);
  }
  function isZero$1(a4) {
    return !a4;
  }
  function shiftLeft(a4, n4) {
    return BigInt(a4) << BigInt(n4);
  }
  function shiftRight(a4, n4) {
    return BigInt(a4) >> BigInt(n4);
  }
  var shl = shiftLeft;
  var shr = shiftRight;
  function isOdd$5(a4) {
    return (BigInt(a4) & BigInt(1)) == BigInt(1);
  }
  function naf(n4) {
    let E4 = BigInt(n4);
    const res = [];
    while (E4) {
      if (E4 & BigInt(1)) {
        const z6 = 2 - Number(E4 % BigInt(4));
        res.push(z6);
        E4 = E4 - BigInt(z6);
      } else {
        res.push(0);
      }
      E4 = E4 >> BigInt(1);
    }
    return res;
  }
  function bits(n4) {
    let E4 = BigInt(n4);
    const res = [];
    while (E4) {
      if (E4 & BigInt(1)) {
        res.push(1);
      } else {
        res.push(0);
      }
      E4 = E4 >> BigInt(1);
    }
    return res;
  }
  function toNumber$1(s3) {
    if (s3 > BigInt(Number.MAX_SAFE_INTEGER)) {
      throw new Error("Number too big");
    }
    return Number(s3);
  }
  function toArray(s3, radix) {
    const res = [];
    let rem = BigInt(s3);
    radix = BigInt(radix);
    while (rem) {
      res.unshift(Number(rem % radix));
      rem = rem / radix;
    }
    return res;
  }
  function add(a4, b7) {
    return BigInt(a4) + BigInt(b7);
  }
  function sub(a4, b7) {
    return BigInt(a4) - BigInt(b7);
  }
  function neg(a4) {
    return -BigInt(a4);
  }
  function mul(a4, b7) {
    return BigInt(a4) * BigInt(b7);
  }
  function square$2(a4) {
    return BigInt(a4) * BigInt(a4);
  }
  function pow(a4, b7) {
    return BigInt(a4) ** BigInt(b7);
  }
  function exp$1(a4, b7) {
    return BigInt(a4) ** BigInt(b7);
  }
  function abs$1(a4) {
    return BigInt(a4) >= 0 ? BigInt(a4) : -BigInt(a4);
  }
  function div(a4, b7) {
    return BigInt(a4) / BigInt(b7);
  }
  function mod(a4, b7) {
    return BigInt(a4) % BigInt(b7);
  }
  function eq(a4, b7) {
    return BigInt(a4) == BigInt(b7);
  }
  function neq(a4, b7) {
    return BigInt(a4) != BigInt(b7);
  }
  function lt3(a4, b7) {
    return BigInt(a4) < BigInt(b7);
  }
  function gt2(a4, b7) {
    return BigInt(a4) > BigInt(b7);
  }
  function leq(a4, b7) {
    return BigInt(a4) <= BigInt(b7);
  }
  function geq(a4, b7) {
    return BigInt(a4) >= BigInt(b7);
  }
  function band(a4, b7) {
    return BigInt(a4) & BigInt(b7);
  }
  function bor(a4, b7) {
    return BigInt(a4) | BigInt(b7);
  }
  function bxor(a4, b7) {
    return BigInt(a4) ^ BigInt(b7);
  }
  function land(a4, b7) {
    return BigInt(a4) && BigInt(b7);
  }
  function lor(a4, b7) {
    return BigInt(a4) || BigInt(b7);
  }
  function lnot(a4) {
    return !BigInt(a4);
  }
  function toRprLE(buff, o4, e7, n8) {
    const s3 = "0000000" + e7.toString(16);
    const v6 = new Uint32Array(buff.buffer, buff.byteOffset + o4, n8 / 4);
    const l6 = ((s3.length - 7) * 4 - 1 >> 5) + 1;
    for (let i4 = 0; i4 < l6; i4++)
      v6[i4] = parseInt(s3.substring(s3.length - 8 * i4 - 8, s3.length - 8 * i4), 16);
    for (let i4 = l6; i4 < v6.length; i4++)
      v6[i4] = 0;
    for (let i4 = v6.length * 4; i4 < n8; i4++)
      buff[i4] = toNumber$1(band(shiftRight(e7, i4 * 8), 255));
  }
  function toRprBE(buff, o4, e7, n8) {
    const s3 = "0000000" + e7.toString(16);
    const v6 = new DataView(buff.buffer, buff.byteOffset + o4, n8);
    const l6 = ((s3.length - 7) * 4 - 1 >> 5) + 1;
    for (let i4 = 0; i4 < l6; i4++)
      v6.setUint32(n8 - i4 * 4 - 4, parseInt(s3.substring(s3.length - 8 * i4 - 8, s3.length - 8 * i4), 16), false);
    for (let i4 = 0; i4 < n8 / 4 - l6; i4++)
      v6[i4] = 0;
  }
  function fromRprLE(buff, o4, n8) {
    n8 = n8 || buff.byteLength;
    o4 = o4 || 0;
    const v6 = new Uint32Array(buff.buffer, buff.byteOffset + o4, n8 / 4);
    const a4 = new Array(n8 / 4);
    v6.forEach((ch2, i4) => a4[a4.length - i4 - 1] = ch2.toString(16).padStart(8, "0"));
    return fromString(a4.join(""), 16);
  }
  function fromRprBE(buff, o4, n8) {
    n8 = n8 || buff.byteLength;
    o4 = o4 || 0;
    const v6 = new DataView(buff.buffer, buff.byteOffset + o4, n8);
    const a4 = new Array(n8 / 4);
    for (let i4 = 0; i4 < n8 / 4; i4++) {
      a4[i4] = v6.getUint32(i4 * 4, false).toString(16).padStart(8, "0");
    }
    return fromString(a4.join(""), 16);
  }
  function toString(a4, radix) {
    return a4.toString(radix);
  }
  function toLEBuff(a4) {
    const buff = new Uint8Array(Math.floor((bitLength$6(a4) - 1) / 8) + 1);
    toRprLE(buff, 0, a4, buff.byteLength);
    return buff;
  }
  var zero = e6(0);
  var one = e6(1);
  var _Scalar = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    abs: abs$1,
    add,
    band,
    bitLength: bitLength$6,
    bits,
    bor,
    bxor,
    div,
    e: e6,
    eq,
    exp: exp$1,
    fromArray,
    fromRprBE,
    fromRprLE,
    fromString,
    geq,
    gt: gt2,
    isNegative: isNegative$4,
    isOdd: isOdd$5,
    isZero: isZero$1,
    land,
    leq,
    lnot,
    lor,
    lt: lt3,
    mod,
    mul,
    naf,
    neg,
    neq,
    one,
    pow,
    shiftLeft,
    shiftRight,
    shl,
    shr,
    square: square$2,
    sub,
    toArray,
    toLEBuff,
    toNumber: toNumber$1,
    toRprBE,
    toRprLE,
    toString,
    zero
  });
  var _revTable$1 = [];
  for (let i4 = 0; i4 < 256; i4++) {
    _revTable$1[i4] = _revSlow$1(i4, 8);
  }
  function _revSlow$1(idx, bits2) {
    let res = 0;
    let a4 = idx;
    for (let i4 = 0; i4 < bits2; i4++) {
      res <<= 1;
      res = res | a4 & 1;
      a4 >>= 1;
    }
    return res;
  }
  function exp(F4, base3, e7) {
    if (isZero$1(e7))
      return F4.one;
    const n4 = bits(e7);
    if (n4.length == 0)
      return F4.one;
    let res = base3;
    for (let i4 = n4.length - 2; i4 >= 0; i4--) {
      res = F4.square(res);
      if (n4[i4]) {
        res = F4.mul(res, base3);
      }
    }
    return res;
  }
  function buildSqrt(F4) {
    if (F4.m % 2 == 1) {
      if (eq(mod(F4.p, 4), 1)) {
        if (eq(mod(F4.p, 8), 1)) {
          if (eq(mod(F4.p, 16), 1)) {
            alg5_tonelliShanks(F4);
          } else if (eq(mod(F4.p, 16), 9)) {
            alg4_kong(F4);
          } else {
            throw new Error("Field withot sqrt");
          }
        } else if (eq(mod(F4.p, 8), 5)) {
          alg3_atkin(F4);
        } else {
          throw new Error("Field withot sqrt");
        }
      } else if (eq(mod(F4.p, 4), 3)) {
        alg2_shanks(F4);
      }
    } else {
      const pm2mod4 = mod(pow(F4.p, F4.m / 2), 4);
      if (pm2mod4 == 1) {
        alg10_adj(F4);
      } else if (pm2mod4 == 3) {
        alg9_adj(F4);
      } else {
        alg8_complex(F4);
      }
    }
  }
  function alg5_tonelliShanks(F4) {
    F4.sqrt_q = pow(F4.p, F4.m);
    F4.sqrt_s = 0;
    F4.sqrt_t = sub(F4.sqrt_q, 1);
    while (!isOdd$5(F4.sqrt_t)) {
      F4.sqrt_s = F4.sqrt_s + 1;
      F4.sqrt_t = div(F4.sqrt_t, 2);
    }
    let c0 = F4.one;
    while (F4.eq(c0, F4.one)) {
      const c3 = F4.random();
      F4.sqrt_z = F4.pow(c3, F4.sqrt_t);
      c0 = F4.pow(F4.sqrt_z, 2 ** (F4.sqrt_s - 1));
    }
    F4.sqrt_tm1d2 = div(sub(F4.sqrt_t, 1), 2);
    F4.sqrt = function(a4) {
      const F5 = this;
      if (F5.isZero(a4))
        return F5.zero;
      let w5 = F5.pow(a4, F5.sqrt_tm1d2);
      const a0 = F5.pow(F5.mul(F5.square(w5), a4), 2 ** (F5.sqrt_s - 1));
      if (F5.eq(a0, F5.negone))
        return null;
      let v6 = F5.sqrt_s;
      let x6 = F5.mul(a4, w5);
      let b7 = F5.mul(x6, w5);
      let z6 = F5.sqrt_z;
      while (!F5.eq(b7, F5.one)) {
        let b2k = F5.square(b7);
        let k5 = 1;
        while (!F5.eq(b2k, F5.one)) {
          b2k = F5.square(b2k);
          k5++;
        }
        w5 = z6;
        for (let i4 = 0; i4 < v6 - k5 - 1; i4++) {
          w5 = F5.square(w5);
        }
        z6 = F5.square(w5);
        b7 = F5.mul(b7, z6);
        x6 = F5.mul(x6, w5);
        v6 = k5;
      }
      return F5.geq(x6, F5.zero) ? x6 : F5.neg(x6);
    };
  }
  function alg4_kong(F4) {
    F4.sqrt = function() {
      throw new Error("Sqrt alg 4 not implemented");
    };
  }
  function alg3_atkin(F4) {
    F4.sqrt = function() {
      throw new Error("Sqrt alg 3 not implemented");
    };
  }
  function alg2_shanks(F4) {
    F4.sqrt_q = pow(F4.p, F4.m);
    F4.sqrt_e1 = div(sub(F4.sqrt_q, 3), 4);
    F4.sqrt = function(a4) {
      if (this.isZero(a4))
        return this.zero;
      const a1 = this.pow(a4, this.sqrt_e1);
      const a0 = this.mul(this.square(a1), a4);
      if (this.eq(a0, this.negone))
        return null;
      const x6 = this.mul(a1, a4);
      return F4.geq(x6, F4.zero) ? x6 : F4.neg(x6);
    };
  }
  function alg10_adj(F4) {
    F4.sqrt = function() {
      throw new Error("Sqrt alg 10 not implemented");
    };
  }
  function alg9_adj(F4) {
    F4.sqrt_q = pow(F4.p, F4.m / 2);
    F4.sqrt_e34 = div(sub(F4.sqrt_q, 3), 4);
    F4.sqrt_e12 = div(sub(F4.sqrt_q, 1), 2);
    F4.frobenius = function(n4, x6) {
      if (n4 % 2 == 1) {
        return F4.conjugate(x6);
      } else {
        return x6;
      }
    };
    F4.sqrt = function(a4) {
      const F5 = this;
      const a1 = F5.pow(a4, F5.sqrt_e34);
      const alfa = F5.mul(F5.square(a1), a4);
      const a0 = F5.mul(F5.frobenius(1, alfa), alfa);
      if (F5.eq(a0, F5.negone))
        return null;
      const x0 = F5.mul(a1, a4);
      let x6;
      if (F5.eq(alfa, F5.negone)) {
        x6 = F5.mul(x0, [F5.F.zero, F5.F.one]);
      } else {
        const b7 = F5.pow(F5.add(F5.one, alfa), F5.sqrt_e12);
        x6 = F5.mul(b7, x0);
      }
      return F5.geq(x6, F5.zero) ? x6 : F5.neg(x6);
    };
  }
  function alg8_complex(F4) {
    F4.sqrt = function() {
      throw new Error("Sqrt alg 8 not implemented");
    };
  }
  function quarterRound(st3, a4, b7, c3, d5) {
    st3[a4] = st3[a4] + st3[b7] >>> 0;
    st3[d5] = (st3[d5] ^ st3[a4]) >>> 0;
    st3[d5] = (st3[d5] << 16 | st3[d5] >>> 16 & 65535) >>> 0;
    st3[c3] = st3[c3] + st3[d5] >>> 0;
    st3[b7] = (st3[b7] ^ st3[c3]) >>> 0;
    st3[b7] = (st3[b7] << 12 | st3[b7] >>> 20 & 4095) >>> 0;
    st3[a4] = st3[a4] + st3[b7] >>> 0;
    st3[d5] = (st3[d5] ^ st3[a4]) >>> 0;
    st3[d5] = (st3[d5] << 8 | st3[d5] >>> 24 & 255) >>> 0;
    st3[c3] = st3[c3] + st3[d5] >>> 0;
    st3[b7] = (st3[b7] ^ st3[c3]) >>> 0;
    st3[b7] = (st3[b7] << 7 | st3[b7] >>> 25 & 127) >>> 0;
  }
  function doubleRound(st3) {
    quarterRound(st3, 0, 4, 8, 12);
    quarterRound(st3, 1, 5, 9, 13);
    quarterRound(st3, 2, 6, 10, 14);
    quarterRound(st3, 3, 7, 11, 15);
    quarterRound(st3, 0, 5, 10, 15);
    quarterRound(st3, 1, 6, 11, 12);
    quarterRound(st3, 2, 7, 8, 13);
    quarterRound(st3, 3, 4, 9, 14);
  }
  var ChaCha = class {
    constructor(seed) {
      seed = seed || [0, 0, 0, 0, 0, 0, 0, 0];
      this.state = [
        1634760805,
        857760878,
        2036477234,
        1797285236,
        seed[0],
        seed[1],
        seed[2],
        seed[3],
        seed[4],
        seed[5],
        seed[6],
        seed[7],
        0,
        0,
        0,
        0
      ];
      this.idx = 16;
      this.buff = new Array(16);
    }
    nextU32() {
      if (this.idx == 16)
        this.update();
      return this.buff[this.idx++];
    }
    nextU64() {
      return add(mul(this.nextU32(), 4294967296), this.nextU32());
    }
    nextBool() {
      return (this.nextU32() & 1) == 1;
    }
    update() {
      for (let i4 = 0; i4 < 16; i4++)
        this.buff[i4] = this.state[i4];
      for (let i4 = 0; i4 < 10; i4++)
        doubleRound(this.buff);
      for (let i4 = 0; i4 < 16; i4++)
        this.buff[i4] = this.buff[i4] + this.state[i4] >>> 0;
      this.idx = 0;
      this.state[12] = this.state[12] + 1 >>> 0;
      if (this.state[12] != 0)
        return;
      this.state[13] = this.state[13] + 1 >>> 0;
      if (this.state[13] != 0)
        return;
      this.state[14] = this.state[14] + 1 >>> 0;
      if (this.state[14] != 0)
        return;
      this.state[15] = this.state[15] + 1 >>> 0;
    }
  };
  function getRandomBytes(n4) {
    let array = new Uint8Array(n4);
    {
      if (typeof globalThis.crypto !== "undefined") {
        globalThis.crypto.getRandomValues(array);
      } else {
        for (let i4 = 0; i4 < n4; i4++) {
          array[i4] = Math.random() * 4294967296 >>> 0;
        }
      }
    }
    return array;
  }
  function getRandomSeed() {
    const arr = getRandomBytes(32);
    const arrV = new Uint32Array(arr.buffer);
    const seed = [];
    for (let i4 = 0; i4 < 8; i4++) {
      seed.push(arrV[i4]);
    }
    return seed;
  }
  var threadRng = null;
  function getThreadRng() {
    if (threadRng)
      return threadRng;
    threadRng = new ChaCha(getRandomSeed());
    return threadRng;
  }
  var FFT = class {
    constructor(G7, F4, opMulGF) {
      this.F = F4;
      this.G = G7;
      this.opMulGF = opMulGF;
      let rem = F4.sqrt_t || F4.t;
      let s3 = F4.sqrt_s || F4.s;
      let nqr = F4.one;
      while (F4.eq(F4.pow(nqr, F4.half), F4.one))
        nqr = F4.add(nqr, F4.one);
      this.w = new Array(s3 + 1);
      this.wi = new Array(s3 + 1);
      this.w[s3] = this.F.pow(nqr, rem);
      this.wi[s3] = this.F.inv(this.w[s3]);
      let n4 = s3 - 1;
      while (n4 >= 0) {
        this.w[n4] = this.F.square(this.w[n4 + 1]);
        this.wi[n4] = this.F.square(this.wi[n4 + 1]);
        n4--;
      }
      this.roots = [];
      this._setRoots(Math.min(s3, 15));
    }
    _setRoots(n4) {
      for (let i4 = n4; i4 >= 0 && !this.roots[i4]; i4--) {
        let r = this.F.one;
        const nroots = 1 << i4;
        const rootsi = new Array(nroots);
        for (let j5 = 0; j5 < nroots; j5++) {
          rootsi[j5] = r;
          r = this.F.mul(r, this.w[i4]);
        }
        this.roots[i4] = rootsi;
      }
    }
    fft(p6) {
      if (p6.length <= 1)
        return p6;
      const bits2 = log2$1(p6.length - 1) + 1;
      this._setRoots(bits2);
      const m5 = 1 << bits2;
      if (p6.length != m5) {
        throw new Error("Size must be multiple of 2");
      }
      const res = __fft(this, p6, bits2, 0, 1);
      return res;
    }
    ifft(p6) {
      if (p6.length <= 1)
        return p6;
      const bits2 = log2$1(p6.length - 1) + 1;
      this._setRoots(bits2);
      const m5 = 1 << bits2;
      if (p6.length != m5) {
        throw new Error("Size must be multiple of 2");
      }
      const res = __fft(this, p6, bits2, 0, 1);
      const twoinvm = this.F.inv(this.F.mulScalar(this.F.one, m5));
      const resn = new Array(m5);
      for (let i4 = 0; i4 < m5; i4++) {
        resn[i4] = this.opMulGF(res[(m5 - i4) % m5], twoinvm);
      }
      return resn;
    }
  };
  function log2$1(V5) {
    return ((V5 & 4294901760) !== 0 ? (V5 &= 4294901760, 16) : 0) | ((V5 & 4278255360) !== 0 ? (V5 &= 4278255360, 8) : 0) | ((V5 & 4042322160) !== 0 ? (V5 &= 4042322160, 4) : 0) | ((V5 & 3435973836) !== 0 ? (V5 &= 3435973836, 2) : 0) | (V5 & 2863311530) !== 0;
  }
  function __fft(PF, pall, bits2, offset, step) {
    const n4 = 1 << bits2;
    if (n4 == 1) {
      return [pall[offset]];
    } else if (n4 == 2) {
      return [
        PF.G.add(pall[offset], pall[offset + step]),
        PF.G.sub(pall[offset], pall[offset + step])
      ];
    }
    const ndiv2 = n4 >> 1;
    const p1 = __fft(PF, pall, bits2 - 1, offset, step * 2);
    const p22 = __fft(PF, pall, bits2 - 1, offset + step, step * 2);
    const out = new Array(n4);
    for (let i4 = 0; i4 < ndiv2; i4++) {
      out[i4] = PF.G.add(p1[i4], PF.opMulGF(p22[i4], PF.roots[bits2][i4]));
      out[i4 + ndiv2] = PF.G.sub(p1[i4], PF.opMulGF(p22[i4], PF.roots[bits2][i4]));
    }
    return out;
  }
  var ZqField = class {
    constructor(p6) {
      this.type = "F1";
      this.one = BigInt(1);
      this.zero = BigInt(0);
      this.p = BigInt(p6);
      this.m = 1;
      this.negone = this.p - this.one;
      this.two = BigInt(2);
      this.half = this.p >> this.one;
      this.bitLength = bitLength$6(this.p);
      this.mask = (this.one << BigInt(this.bitLength)) - this.one;
      this.n64 = Math.floor((this.bitLength - 1) / 64) + 1;
      this.n32 = this.n64 * 2;
      this.n8 = this.n64 * 8;
      this.R = this.e(this.one << BigInt(this.n64 * 64));
      this.Ri = this.inv(this.R);
      const e7 = this.negone >> this.one;
      this.nqr = this.two;
      let r = this.pow(this.nqr, e7);
      while (!this.eq(r, this.negone)) {
        this.nqr = this.nqr + this.one;
        r = this.pow(this.nqr, e7);
      }
      this.s = 0;
      this.t = this.negone;
      while ((this.t & this.one) == this.zero) {
        this.s = this.s + 1;
        this.t = this.t >> this.one;
      }
      this.nqr_to_t = this.pow(this.nqr, this.t);
      buildSqrt(this);
      this.FFT = new FFT(this, this, this.mul.bind(this));
      this.fft = this.FFT.fft.bind(this.FFT);
      this.ifft = this.FFT.ifft.bind(this.FFT);
      this.w = this.FFT.w;
      this.wi = this.FFT.wi;
      this.shift = this.square(this.nqr);
      this.k = this.exp(this.nqr, 2 ** this.s);
    }
    e(a4, b7) {
      let res;
      if (!b7) {
        res = BigInt(a4);
      } else if (b7 == 16) {
        res = BigInt("0x" + a4);
      }
      if (res < 0) {
        let nres = -res;
        if (nres >= this.p)
          nres = nres % this.p;
        return this.p - nres;
      } else {
        return res >= this.p ? res % this.p : res;
      }
    }
    add(a4, b7) {
      const res = a4 + b7;
      return res >= this.p ? res - this.p : res;
    }
    sub(a4, b7) {
      return a4 >= b7 ? a4 - b7 : this.p - b7 + a4;
    }
    neg(a4) {
      return a4 ? this.p - a4 : a4;
    }
    mul(a4, b7) {
      return a4 * b7 % this.p;
    }
    mulScalar(base3, s3) {
      return base3 * this.e(s3) % this.p;
    }
    square(a4) {
      return a4 * a4 % this.p;
    }
    eq(a4, b7) {
      return a4 == b7;
    }
    neq(a4, b7) {
      return a4 != b7;
    }
    lt(a4, b7) {
      const aa2 = a4 > this.half ? a4 - this.p : a4;
      const bb = b7 > this.half ? b7 - this.p : b7;
      return aa2 < bb;
    }
    gt(a4, b7) {
      const aa2 = a4 > this.half ? a4 - this.p : a4;
      const bb = b7 > this.half ? b7 - this.p : b7;
      return aa2 > bb;
    }
    leq(a4, b7) {
      const aa2 = a4 > this.half ? a4 - this.p : a4;
      const bb = b7 > this.half ? b7 - this.p : b7;
      return aa2 <= bb;
    }
    geq(a4, b7) {
      const aa2 = a4 > this.half ? a4 - this.p : a4;
      const bb = b7 > this.half ? b7 - this.p : b7;
      return aa2 >= bb;
    }
    div(a4, b7) {
      return this.mul(a4, this.inv(b7));
    }
    idiv(a4, b7) {
      if (!b7)
        throw new Error("Division by zero");
      return a4 / b7;
    }
    inv(a4) {
      if (!a4)
        throw new Error("Division by zero");
      let t = this.zero;
      let r = this.p;
      let newt = this.one;
      let newr = a4 % this.p;
      while (newr) {
        let q5 = r / newr;
        [t, newt] = [newt, t - q5 * newt];
        [r, newr] = [newr, r - q5 * newr];
      }
      if (t < this.zero)
        t += this.p;
      return t;
    }
    mod(a4, b7) {
      return a4 % b7;
    }
    pow(b7, e7) {
      return exp(this, b7, e7);
    }
    exp(b7, e7) {
      return exp(this, b7, e7);
    }
    band(a4, b7) {
      const res = a4 & b7 & this.mask;
      return res >= this.p ? res - this.p : res;
    }
    bor(a4, b7) {
      const res = (a4 | b7) & this.mask;
      return res >= this.p ? res - this.p : res;
    }
    bxor(a4, b7) {
      const res = (a4 ^ b7) & this.mask;
      return res >= this.p ? res - this.p : res;
    }
    bnot(a4) {
      const res = a4 ^ this.mask;
      return res >= this.p ? res - this.p : res;
    }
    shl(a4, b7) {
      if (Number(b7) < this.bitLength) {
        const res = a4 << b7 & this.mask;
        return res >= this.p ? res - this.p : res;
      } else {
        const nb = this.p - b7;
        if (Number(nb) < this.bitLength) {
          return a4 >> nb;
        } else {
          return this.zero;
        }
      }
    }
    shr(a4, b7) {
      if (Number(b7) < this.bitLength) {
        return a4 >> b7;
      } else {
        const nb = this.p - b7;
        if (Number(nb) < this.bitLength) {
          const res = a4 << nb & this.mask;
          return res >= this.p ? res - this.p : res;
        } else {
          return 0;
        }
      }
    }
    land(a4, b7) {
      return a4 && b7 ? this.one : this.zero;
    }
    lor(a4, b7) {
      return a4 || b7 ? this.one : this.zero;
    }
    lnot(a4) {
      return a4 ? this.zero : this.one;
    }
    sqrt_old(n4) {
      if (n4 == this.zero)
        return this.zero;
      const res = this.pow(n4, this.negone >> this.one);
      if (res != this.one)
        return null;
      let m5 = this.s;
      let c3 = this.nqr_to_t;
      let t = this.pow(n4, this.t);
      let r = this.pow(n4, this.add(this.t, this.one) >> this.one);
      while (t != this.one) {
        let sq = this.square(t);
        let i4 = 1;
        while (sq != this.one) {
          i4++;
          sq = this.square(sq);
        }
        let b7 = c3;
        for (let j5 = 0; j5 < m5 - i4 - 1; j5++)
          b7 = this.square(b7);
        m5 = i4;
        c3 = this.square(b7);
        t = this.mul(t, c3);
        r = this.mul(r, b7);
      }
      if (r > this.p >> this.one) {
        r = this.neg(r);
      }
      return r;
    }
    normalize(a4, b7) {
      a4 = BigInt(a4, b7);
      if (a4 < 0) {
        let na2 = -a4;
        if (na2 >= this.p)
          na2 = na2 % this.p;
        return this.p - na2;
      } else {
        return a4 >= this.p ? a4 % this.p : a4;
      }
    }
    random() {
      const nBytes = this.bitLength * 2 / 8;
      let res = this.zero;
      for (let i4 = 0; i4 < nBytes; i4++) {
        res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);
      }
      return res % this.p;
    }
    toString(a4, base3) {
      base3 = base3 || 10;
      let vs2;
      if (a4 > this.half && base3 == 10) {
        const v6 = this.p - a4;
        vs2 = "-" + v6.toString(base3);
      } else {
        vs2 = a4.toString(base3);
      }
      return vs2;
    }
    isZero(a4) {
      return a4 == this.zero;
    }
    fromRng(rng2) {
      let v6;
      do {
        v6 = this.zero;
        for (let i4 = 0; i4 < this.n64; i4++) {
          v6 += rng2.nextU64() << BigInt(64 * i4);
        }
        v6 &= this.mask;
      } while (v6 >= this.p);
      v6 = v6 * this.Ri % this.p;
      return v6;
    }
    fft(a4) {
      return this.FFT.fft(a4);
    }
    ifft(a4) {
      return this.FFT.ifft(a4);
    }
    toRprLE(buff, o4, e7) {
      toRprLE(buff, o4, e7, this.n64 * 8);
    }
    toRprBE(buff, o4, e7) {
      toRprBE(buff, o4, e7, this.n64 * 8);
    }
    toRprBEM(buff, o4, e7) {
      return this.toRprBE(buff, o4, this.mul(this.R, e7));
    }
    toRprLEM(buff, o4, e7) {
      return this.toRprLE(buff, o4, this.mul(this.R, e7));
    }
    fromRprLE(buff, o4) {
      return fromRprLE(buff, o4, this.n8);
    }
    fromRprBE(buff, o4) {
      return fromRprBE(buff, o4, this.n8);
    }
    fromRprLEM(buff, o4) {
      return this.mul(this.fromRprLE(buff, o4), this.Ri);
    }
    fromRprBEM(buff, o4) {
      return this.mul(this.fromRprBE(buff, o4), this.Ri);
    }
    toObject(a4) {
      return a4;
    }
  };
  var utils$6 = {};
  utils$6.bigInt2BytesLE = function bigInt2BytesLE(_a2, len) {
    const b7 = Array(len);
    let v6 = BigInt(_a2);
    for (let i4 = 0; i4 < len; i4++) {
      b7[i4] = Number(v6 & 0xFFn);
      v6 = v6 >> 8n;
    }
    return b7;
  };
  utils$6.bigInt2U32LE = function bigInt2BytesLE2(_a2, len) {
    const b7 = Array(len);
    let v6 = BigInt(_a2);
    for (let i4 = 0; i4 < len; i4++) {
      b7[i4] = Number(v6 & 0xFFFFFFFFn);
      v6 = v6 >> 32n;
    }
    return b7;
  };
  utils$6.isOcamNum = function(a4) {
    if (!Array.isArray(a4))
      return false;
    if (a4.length != 3)
      return false;
    if (typeof a4[0] !== "number")
      return false;
    if (typeof a4[1] !== "number")
      return false;
    if (!Array.isArray(a4[2]))
      return false;
    return true;
  };
  var build_int = function buildInt(module, n64, _prefix) {
    const prefix = _prefix || "int";
    if (module.modules[prefix])
      return prefix;
    module.modules[prefix] = {};
    const n32 = n64 * 2;
    const n8 = n64 * 8;
    function buildCopy() {
      const f5 = module.addFunction(prefix + "_copy");
      f5.addParam("px", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < n64; i4++) {
        f5.addCode(
          c3.i64_store(
            c3.getLocal("pr"),
            i4 * 8,
            c3.i64_load(
              c3.getLocal("px"),
              i4 * 8
            )
          )
        );
      }
    }
    function buildZero() {
      const f5 = module.addFunction(prefix + "_zero");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < n64; i4++) {
        f5.addCode(
          c3.i64_store(
            c3.getLocal("pr"),
            i4 * 8,
            c3.i64_const(0)
          )
        );
      }
    }
    function buildOne() {
      const f5 = module.addFunction(prefix + "_one");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.i64_store(
          c3.getLocal("pr"),
          0,
          c3.i64_const(1)
        )
      );
      for (let i4 = 1; i4 < n64; i4++) {
        f5.addCode(
          c3.i64_store(
            c3.getLocal("pr"),
            i4 * 8,
            c3.i64_const(0)
          )
        );
      }
    }
    function buildIsZero() {
      const f5 = module.addFunction(prefix + "_isZero");
      f5.addParam("px", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      function getCompCode(n4) {
        if (n4 == 0) {
          return c3.ret(c3.i64_eqz(
            c3.i64_load(c3.getLocal("px"))
          ));
        }
        return c3.if(
          c3.i64_eqz(
            c3.i64_load(c3.getLocal("px"), n4 * 8)
          ),
          getCompCode(n4 - 1),
          c3.ret(c3.i32_const(0))
        );
      }
      f5.addCode(getCompCode(n64 - 1));
      f5.addCode(c3.ret(c3.i32_const(0)));
    }
    function buildEq() {
      const f5 = module.addFunction(prefix + "_eq");
      f5.addParam("px", "i32");
      f5.addParam("py", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      function getCompCode(n4) {
        if (n4 == 0) {
          return c3.ret(c3.i64_eq(
            c3.i64_load(c3.getLocal("px")),
            c3.i64_load(c3.getLocal("py"))
          ));
        }
        return c3.if(
          c3.i64_eq(
            c3.i64_load(c3.getLocal("px"), n4 * 8),
            c3.i64_load(c3.getLocal("py"), n4 * 8)
          ),
          getCompCode(n4 - 1),
          c3.ret(c3.i32_const(0))
        );
      }
      f5.addCode(getCompCode(n64 - 1));
      f5.addCode(c3.ret(c3.i32_const(0)));
    }
    function buildGte() {
      const f5 = module.addFunction(prefix + "_gte");
      f5.addParam("px", "i32");
      f5.addParam("py", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      function getCompCode(n4) {
        if (n4 == 0) {
          return c3.ret(c3.i64_ge_u(
            c3.i64_load(c3.getLocal("px")),
            c3.i64_load(c3.getLocal("py"))
          ));
        }
        return c3.if(
          c3.i64_lt_u(
            c3.i64_load(c3.getLocal("px"), n4 * 8),
            c3.i64_load(c3.getLocal("py"), n4 * 8)
          ),
          c3.ret(c3.i32_const(0)),
          c3.if(
            c3.i64_gt_u(
              c3.i64_load(c3.getLocal("px"), n4 * 8),
              c3.i64_load(c3.getLocal("py"), n4 * 8)
            ),
            c3.ret(c3.i32_const(1)),
            getCompCode(n4 - 1)
          )
        );
      }
      f5.addCode(getCompCode(n64 - 1));
      f5.addCode(c3.ret(c3.i32_const(0)));
    }
    function buildAdd() {
      const f5 = module.addFunction(prefix + "_add");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      f5.setReturnType("i32");
      f5.addLocal("c", "i64");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.setLocal(
        "c",
        c3.i64_add(
          c3.i64_load32_u(c3.getLocal("x")),
          c3.i64_load32_u(c3.getLocal("y"))
        )
      ));
      f5.addCode(c3.i64_store32(
        c3.getLocal("r"),
        c3.getLocal("c")
      ));
      for (let i4 = 1; i4 < n32; i4++) {
        f5.addCode(c3.setLocal(
          "c",
          c3.i64_add(
            c3.i64_add(
              c3.i64_load32_u(c3.getLocal("x"), 4 * i4),
              c3.i64_load32_u(c3.getLocal("y"), 4 * i4)
            ),
            c3.i64_shr_u(c3.getLocal("c"), c3.i64_const(32))
          )
        ));
        f5.addCode(c3.i64_store32(
          c3.getLocal("r"),
          i4 * 4,
          c3.getLocal("c")
        ));
      }
      f5.addCode(c3.i32_wrap_i64(c3.i64_shr_u(c3.getLocal("c"), c3.i64_const(32))));
    }
    function buildSub() {
      const f5 = module.addFunction(prefix + "_sub");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      f5.setReturnType("i32");
      f5.addLocal("c", "i64");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.setLocal(
        "c",
        c3.i64_sub(
          c3.i64_load32_u(c3.getLocal("x")),
          c3.i64_load32_u(c3.getLocal("y"))
        )
      ));
      f5.addCode(c3.i64_store32(
        c3.getLocal("r"),
        c3.i64_and(
          c3.getLocal("c"),
          c3.i64_const("0xFFFFFFFF")
        )
      ));
      for (let i4 = 1; i4 < n32; i4++) {
        f5.addCode(c3.setLocal(
          "c",
          c3.i64_add(
            c3.i64_sub(
              c3.i64_load32_u(c3.getLocal("x"), 4 * i4),
              c3.i64_load32_u(c3.getLocal("y"), 4 * i4)
            ),
            c3.i64_shr_s(c3.getLocal("c"), c3.i64_const(32))
          )
        ));
        f5.addCode(c3.i64_store32(
          c3.getLocal("r"),
          i4 * 4,
          c3.i64_and(c3.getLocal("c"), c3.i64_const("0xFFFFFFFF"))
        ));
      }
      f5.addCode(c3.i32_wrap_i64(c3.i64_shr_s(c3.getLocal("c"), c3.i64_const(32))));
    }
    function buildMul() {
      const f5 = module.addFunction(prefix + "_mul");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("c0", "i64");
      f5.addLocal("c1", "i64");
      for (let i4 = 0; i4 < n32; i4++) {
        f5.addLocal("x" + i4, "i64");
        f5.addLocal("y" + i4, "i64");
      }
      const c3 = f5.getCodeBuilder();
      const loadX = [];
      const loadY = [];
      function mulij(i4, j5) {
        let X5, Y5;
        if (!loadX[i4]) {
          X5 = c3.teeLocal("x" + i4, c3.i64_load32_u(c3.getLocal("x"), i4 * 4));
          loadX[i4] = true;
        } else {
          X5 = c3.getLocal("x" + i4);
        }
        if (!loadY[j5]) {
          Y5 = c3.teeLocal("y" + j5, c3.i64_load32_u(c3.getLocal("y"), j5 * 4));
          loadY[j5] = true;
        } else {
          Y5 = c3.getLocal("y" + j5);
        }
        return c3.i64_mul(X5, Y5);
      }
      let c0 = "c0";
      let c1 = "c1";
      for (let k5 = 0; k5 < n32 * 2 - 1; k5++) {
        for (let i4 = Math.max(0, k5 - n32 + 1); i4 <= k5 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        f5.addCode(
          c3.i64_store32(
            c3.getLocal("r"),
            k5 * 4,
            c3.getLocal(c0)
          )
        );
        [c0, c1] = [c1, c0];
        f5.addCode(
          c3.setLocal(
            c1,
            c3.i64_shr_u(
              c3.getLocal(c0),
              c3.i64_const(32)
            )
          )
        );
      }
      f5.addCode(
        c3.i64_store32(
          c3.getLocal("r"),
          n32 * 4 * 2 - 4,
          c3.getLocal(c0)
        )
      );
    }
    function buildSquare() {
      const f5 = module.addFunction(prefix + "_square");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("c0", "i64");
      f5.addLocal("c1", "i64");
      f5.addLocal("c0_old", "i64");
      f5.addLocal("c1_old", "i64");
      for (let i4 = 0; i4 < n32; i4++) {
        f5.addLocal("x" + i4, "i64");
      }
      const c3 = f5.getCodeBuilder();
      const loadX = [];
      function mulij(i4, j5) {
        let X5, Y5;
        if (!loadX[i4]) {
          X5 = c3.teeLocal("x" + i4, c3.i64_load32_u(c3.getLocal("x"), i4 * 4));
          loadX[i4] = true;
        } else {
          X5 = c3.getLocal("x" + i4);
        }
        if (!loadX[j5]) {
          Y5 = c3.teeLocal("x" + j5, c3.i64_load32_u(c3.getLocal("x"), j5 * 4));
          loadX[j5] = true;
        } else {
          Y5 = c3.getLocal("x" + j5);
        }
        return c3.i64_mul(X5, Y5);
      }
      let c0 = "c0";
      let c1 = "c1";
      let c0_old = "c0_old";
      let c1_old = "c1_old";
      for (let k5 = 0; k5 < n32 * 2 - 1; k5++) {
        f5.addCode(
          c3.setLocal(c0, c3.i64_const(0)),
          c3.setLocal(c1, c3.i64_const(0))
        );
        for (let i4 = Math.max(0, k5 - n32 + 1); i4 < k5 + 1 >> 1 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        f5.addCode(
          c3.setLocal(
            c0,
            c3.i64_shl(
              c3.i64_and(
                c3.getLocal(c0),
                c3.i64_const(4294967295)
              ),
              c3.i64_const(1)
            )
          )
        );
        f5.addCode(
          c3.setLocal(
            c1,
            c3.i64_add(
              c3.i64_shl(
                c3.getLocal(c1),
                c3.i64_const(1)
              ),
              c3.i64_shr_u(
                c3.getLocal(c0),
                c3.i64_const(32)
              )
            )
          )
        );
        if (k5 % 2 == 0) {
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(k5 >> 1, k5 >> 1)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 > 0) {
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                c3.i64_and(
                  c3.getLocal(c0_old),
                  c3.i64_const(4294967295)
                )
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.i64_add(
                  c3.getLocal(c1),
                  c3.i64_shr_u(
                    c3.getLocal(c0),
                    c3.i64_const(32)
                  )
                ),
                c3.getLocal(c1_old)
              )
            )
          );
        }
        f5.addCode(
          c3.i64_store32(
            c3.getLocal("r"),
            k5 * 4,
            c3.getLocal(c0)
          )
        );
        f5.addCode(
          c3.setLocal(
            c0_old,
            c3.getLocal(c1)
          ),
          c3.setLocal(
            c1_old,
            c3.i64_shr_u(
              c3.getLocal(c0_old),
              c3.i64_const(32)
            )
          )
        );
      }
      f5.addCode(
        c3.i64_store32(
          c3.getLocal("r"),
          n32 * 4 * 2 - 4,
          c3.getLocal(c0_old)
        )
      );
    }
    function buildSquareOld() {
      const f5 = module.addFunction(prefix + "_squareOld");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(prefix + "_mul", c3.getLocal("x"), c3.getLocal("x"), c3.getLocal("r")));
    }
    function _buildMul1() {
      const f5 = module.addFunction(prefix + "__mul1");
      f5.addParam("px", "i32");
      f5.addParam("y", "i64");
      f5.addParam("pr", "i32");
      f5.addLocal("c", "i64");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.setLocal(
        "c",
        c3.i64_mul(
          c3.i64_load32_u(c3.getLocal("px"), 0, 0),
          c3.getLocal("y")
        )
      ));
      f5.addCode(c3.i64_store32(
        c3.getLocal("pr"),
        0,
        0,
        c3.getLocal("c")
      ));
      for (let i4 = 1; i4 < n32; i4++) {
        f5.addCode(c3.setLocal(
          "c",
          c3.i64_add(
            c3.i64_mul(
              c3.i64_load32_u(c3.getLocal("px"), 4 * i4, 0),
              c3.getLocal("y")
            ),
            c3.i64_shr_u(c3.getLocal("c"), c3.i64_const(32))
          )
        ));
        f5.addCode(c3.i64_store32(
          c3.getLocal("pr"),
          i4 * 4,
          0,
          c3.getLocal("c")
        ));
      }
    }
    function _buildAdd1() {
      const f5 = module.addFunction(prefix + "__add1");
      f5.addParam("x", "i32");
      f5.addParam("y", "i64");
      f5.addLocal("c", "i64");
      f5.addLocal("px", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.setLocal("px", c3.getLocal("x")));
      f5.addCode(c3.setLocal(
        "c",
        c3.i64_add(
          c3.i64_load32_u(c3.getLocal("px"), 0, 0),
          c3.getLocal("y")
        )
      ));
      f5.addCode(c3.i64_store32(
        c3.getLocal("px"),
        0,
        0,
        c3.getLocal("c")
      ));
      f5.addCode(c3.setLocal(
        "c",
        c3.i64_shr_u(
          c3.getLocal("c"),
          c3.i64_const(32)
        )
      ));
      f5.addCode(c3.block(c3.loop(
        c3.br_if(
          1,
          c3.i64_eqz(c3.getLocal("c"))
        ),
        c3.setLocal(
          "px",
          c3.i32_add(
            c3.getLocal("px"),
            c3.i32_const(4)
          )
        ),
        c3.setLocal(
          "c",
          c3.i64_add(
            c3.i64_load32_u(c3.getLocal("px"), 0, 0),
            c3.getLocal("c")
          )
        ),
        c3.i64_store32(
          c3.getLocal("px"),
          0,
          0,
          c3.getLocal("c")
        ),
        c3.setLocal(
          "c",
          c3.i64_shr_u(
            c3.getLocal("c"),
            c3.i64_const(32)
          )
        ),
        c3.br(0)
      )));
    }
    function buildDiv() {
      _buildMul1();
      _buildAdd1();
      const f5 = module.addFunction(prefix + "_div");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("c", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("rr", "i32");
      f5.addLocal("cc", "i32");
      f5.addLocal("eX", "i32");
      f5.addLocal("eY", "i32");
      f5.addLocal("sy", "i64");
      f5.addLocal("sx", "i64");
      f5.addLocal("ec", "i32");
      const c3 = f5.getCodeBuilder();
      const Y5 = c3.i32_const(module.alloc(n8));
      const Caux = c3.i32_const(module.alloc(n8));
      const Raux = c3.i32_const(module.alloc(n8));
      const C5 = c3.getLocal("cc");
      const R5 = c3.getLocal("rr");
      const pr1 = module.alloc(n8 * 2);
      const R1 = c3.i32_const(pr1);
      const R22 = c3.i32_const(pr1 + n8);
      f5.addCode(c3.if(
        c3.getLocal("c"),
        c3.setLocal("cc", c3.getLocal("c")),
        c3.setLocal("cc", Caux)
      ));
      f5.addCode(c3.if(
        c3.getLocal("r"),
        c3.setLocal("rr", c3.getLocal("r")),
        c3.setLocal("rr", Raux)
      ));
      f5.addCode(c3.call(prefix + "_copy", c3.getLocal("x"), R5));
      f5.addCode(c3.call(prefix + "_copy", c3.getLocal("y"), Y5));
      f5.addCode(c3.call(prefix + "_zero", C5));
      f5.addCode(c3.call(prefix + "_zero", R1));
      f5.addCode(c3.setLocal("eX", c3.i32_const(n8 - 1)));
      f5.addCode(c3.setLocal("eY", c3.i32_const(n8 - 1)));
      f5.addCode(c3.block(c3.loop(
        c3.br_if(
          1,
          c3.i32_or(
            c3.i32_load8_u(
              c3.i32_add(Y5, c3.getLocal("eY")),
              0,
              0
            ),
            c3.i32_eq(
              c3.getLocal("eY"),
              c3.i32_const(3)
            )
          )
        ),
        c3.setLocal("eY", c3.i32_sub(c3.getLocal("eY"), c3.i32_const(1))),
        c3.br(0)
      )));
      f5.addCode(
        c3.setLocal(
          "sy",
          c3.i64_add(
            c3.i64_load32_u(
              c3.i32_sub(
                c3.i32_add(Y5, c3.getLocal("eY")),
                c3.i32_const(3)
              ),
              0,
              0
            ),
            c3.i64_const(1)
          )
        )
      );
      f5.addCode(
        c3.if(
          c3.i64_eq(
            c3.getLocal("sy"),
            c3.i64_const(1)
          ),
          c3.drop(c3.i64_div_u(c3.i64_const(0), c3.i64_const(0)))
        )
      );
      f5.addCode(c3.block(c3.loop(
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_or(
              c3.i32_load8_u(
                c3.i32_add(R5, c3.getLocal("eX")),
                0,
                0
              ),
              c3.i32_eq(
                c3.getLocal("eX"),
                c3.i32_const(7)
              )
            )
          ),
          c3.setLocal("eX", c3.i32_sub(c3.getLocal("eX"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.setLocal(
          "sx",
          c3.i64_load(
            c3.i32_sub(
              c3.i32_add(R5, c3.getLocal("eX")),
              c3.i32_const(7)
            ),
            0,
            0
          )
        ),
        c3.setLocal(
          "sx",
          c3.i64_div_u(
            c3.getLocal("sx"),
            c3.getLocal("sy")
          )
        ),
        c3.setLocal(
          "ec",
          c3.i32_sub(
            c3.i32_sub(
              c3.getLocal("eX"),
              c3.getLocal("eY")
            ),
            c3.i32_const(4)
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_and(
              c3.i64_eqz(
                c3.i64_and(
                  c3.getLocal("sx"),
                  c3.i64_const("0xFFFFFFFF00000000")
                )
              ),
              c3.i32_ge_s(
                c3.getLocal("ec"),
                c3.i32_const(0)
              )
            )
          ),
          c3.setLocal(
            "sx",
            c3.i64_shr_u(
              c3.getLocal("sx"),
              c3.i64_const(8)
            )
          ),
          c3.setLocal(
            "ec",
            c3.i32_add(
              c3.getLocal("ec"),
              c3.i32_const(1)
            )
          ),
          c3.br(0)
        )),
        c3.if(
          c3.i64_eqz(c3.getLocal("sx")),
          [
            ...c3.br_if(
              2,
              c3.i32_eqz(c3.call(prefix + "_gte", R5, Y5))
            ),
            ...c3.setLocal("sx", c3.i64_const(1)),
            ...c3.setLocal("ec", c3.i32_const(0))
          ]
        ),
        c3.call(prefix + "__mul1", Y5, c3.getLocal("sx"), R22),
        c3.drop(c3.call(
          prefix + "_sub",
          R5,
          c3.i32_sub(R22, c3.getLocal("ec")),
          R5
        )),
        c3.call(
          prefix + "__add1",
          c3.i32_add(C5, c3.getLocal("ec")),
          c3.getLocal("sx")
        ),
        c3.br(0)
      )));
    }
    function buildInverseMod() {
      const f5 = module.addFunction(prefix + "_inverseMod");
      f5.addParam("px", "i32");
      f5.addParam("pm", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("t", "i32");
      f5.addLocal("newt", "i32");
      f5.addLocal("r", "i32");
      f5.addLocal("qq", "i32");
      f5.addLocal("qr", "i32");
      f5.addLocal("newr", "i32");
      f5.addLocal("swp", "i32");
      f5.addLocal("x", "i32");
      f5.addLocal("signt", "i32");
      f5.addLocal("signnewt", "i32");
      f5.addLocal("signx", "i32");
      const c3 = f5.getCodeBuilder();
      const aux1 = c3.i32_const(module.alloc(n8));
      const aux2 = c3.i32_const(module.alloc(n8));
      const aux3 = c3.i32_const(module.alloc(n8));
      const aux4 = c3.i32_const(module.alloc(n8));
      const aux5 = c3.i32_const(module.alloc(n8));
      const aux6 = c3.i32_const(module.alloc(n8));
      const mulBuff = c3.i32_const(module.alloc(n8 * 2));
      const aux7 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.setLocal("t", aux1),
        c3.call(prefix + "_zero", aux1),
        c3.setLocal("signt", c3.i32_const(0))
      );
      f5.addCode(
        c3.setLocal("r", aux2),
        c3.call(prefix + "_copy", c3.getLocal("pm"), aux2)
      );
      f5.addCode(
        c3.setLocal("newt", aux3),
        c3.call(prefix + "_one", aux3),
        c3.setLocal("signnewt", c3.i32_const(0))
      );
      f5.addCode(
        c3.setLocal("newr", aux4),
        c3.call(prefix + "_copy", c3.getLocal("px"), aux4)
      );
      f5.addCode(c3.setLocal("qq", aux5));
      f5.addCode(c3.setLocal("qr", aux6));
      f5.addCode(c3.setLocal("x", aux7));
      f5.addCode(c3.block(c3.loop(
        c3.br_if(
          1,
          c3.call(prefix + "_isZero", c3.getLocal("newr"))
        ),
        c3.call(prefix + "_div", c3.getLocal("r"), c3.getLocal("newr"), c3.getLocal("qq"), c3.getLocal("qr")),
        c3.call(prefix + "_mul", c3.getLocal("qq"), c3.getLocal("newt"), mulBuff),
        c3.if(
          c3.getLocal("signt"),
          c3.if(
            c3.getLocal("signnewt"),
            c3.if(
              c3.call(prefix + "_gte", mulBuff, c3.getLocal("t")),
              [
                ...c3.drop(c3.call(prefix + "_sub", mulBuff, c3.getLocal("t"), c3.getLocal("x"))),
                ...c3.setLocal("signx", c3.i32_const(0))
              ],
              [
                ...c3.drop(c3.call(prefix + "_sub", c3.getLocal("t"), mulBuff, c3.getLocal("x"))),
                ...c3.setLocal("signx", c3.i32_const(1))
              ]
            ),
            [
              ...c3.drop(c3.call(prefix + "_add", mulBuff, c3.getLocal("t"), c3.getLocal("x"))),
              ...c3.setLocal("signx", c3.i32_const(1))
            ]
          ),
          c3.if(
            c3.getLocal("signnewt"),
            [
              ...c3.drop(c3.call(prefix + "_add", mulBuff, c3.getLocal("t"), c3.getLocal("x"))),
              ...c3.setLocal("signx", c3.i32_const(0))
            ],
            c3.if(
              c3.call(prefix + "_gte", c3.getLocal("t"), mulBuff),
              [
                ...c3.drop(c3.call(prefix + "_sub", c3.getLocal("t"), mulBuff, c3.getLocal("x"))),
                ...c3.setLocal("signx", c3.i32_const(0))
              ],
              [
                ...c3.drop(c3.call(prefix + "_sub", mulBuff, c3.getLocal("t"), c3.getLocal("x"))),
                ...c3.setLocal("signx", c3.i32_const(1))
              ]
            )
          )
        ),
        c3.setLocal("swp", c3.getLocal("t")),
        c3.setLocal("t", c3.getLocal("newt")),
        c3.setLocal("newt", c3.getLocal("x")),
        c3.setLocal("x", c3.getLocal("swp")),
        c3.setLocal("signt", c3.getLocal("signnewt")),
        c3.setLocal("signnewt", c3.getLocal("signx")),
        c3.setLocal("swp", c3.getLocal("r")),
        c3.setLocal("r", c3.getLocal("newr")),
        c3.setLocal("newr", c3.getLocal("qr")),
        c3.setLocal("qr", c3.getLocal("swp")),
        c3.br(0)
      )));
      f5.addCode(c3.if(
        c3.getLocal("signt"),
        c3.drop(c3.call(prefix + "_sub", c3.getLocal("pm"), c3.getLocal("t"), c3.getLocal("pr"))),
        c3.call(prefix + "_copy", c3.getLocal("t"), c3.getLocal("pr"))
      ));
    }
    buildCopy();
    buildZero();
    buildIsZero();
    buildOne();
    buildEq();
    buildGte();
    buildAdd();
    buildSub();
    buildMul();
    buildSquare();
    buildSquareOld();
    buildDiv();
    buildInverseMod();
    module.exportFunction(prefix + "_copy");
    module.exportFunction(prefix + "_zero");
    module.exportFunction(prefix + "_one");
    module.exportFunction(prefix + "_isZero");
    module.exportFunction(prefix + "_eq");
    module.exportFunction(prefix + "_gte");
    module.exportFunction(prefix + "_add");
    module.exportFunction(prefix + "_sub");
    module.exportFunction(prefix + "_mul");
    module.exportFunction(prefix + "_square");
    module.exportFunction(prefix + "_squareOld");
    module.exportFunction(prefix + "_div");
    module.exportFunction(prefix + "_inverseMod");
    return prefix;
  };
  var build_timesscalar = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {
    const f5 = module.addFunction(fnName);
    f5.addParam("base", "i32");
    f5.addParam("scalar", "i32");
    f5.addParam("scalarLength", "i32");
    f5.addParam("r", "i32");
    f5.addLocal("i", "i32");
    f5.addLocal("b", "i32");
    const c3 = f5.getCodeBuilder();
    const aux = c3.i32_const(module.alloc(elementLen));
    f5.addCode(
      c3.if(
        c3.i32_eqz(c3.getLocal("scalarLength")),
        [
          ...c3.call(opInit, c3.getLocal("r")),
          ...c3.ret([])
        ]
      )
    );
    f5.addCode(c3.call(opCopy, c3.getLocal("base"), aux));
    f5.addCode(c3.call(opInit, c3.getLocal("r")));
    f5.addCode(c3.setLocal("i", c3.getLocal("scalarLength")));
    f5.addCode(c3.block(c3.loop(
      c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
      c3.setLocal(
        "b",
        c3.i32_load8_u(
          c3.i32_add(
            c3.getLocal("scalar"),
            c3.getLocal("i")
          )
        )
      ),
      ...innerLoop(),
      c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
      c3.br(0)
    )));
    function innerLoop() {
      const code2 = [];
      for (let i4 = 0; i4 < 8; i4++) {
        code2.push(
          ...c3.call(opAA, c3.getLocal("r"), c3.getLocal("r")),
          ...c3.if(
            c3.i32_ge_u(c3.getLocal("b"), c3.i32_const(128 >> i4)),
            [
              ...c3.setLocal(
                "b",
                c3.i32_sub(
                  c3.getLocal("b"),
                  c3.i32_const(128 >> i4)
                )
              ),
              ...c3.call(opAB, c3.getLocal("r"), aux, c3.getLocal("r"))
            ]
          )
        );
      }
      return code2;
    }
  };
  var build_batchinverse = buildBatchInverse$3;
  function buildBatchInverse$3(module, prefix) {
    const n8 = module.modules[prefix].n64 * 8;
    const f5 = module.addFunction(prefix + "_batchInverse");
    f5.addParam("pIn", "i32");
    f5.addParam("inStep", "i32");
    f5.addParam("n", "i32");
    f5.addParam("pOut", "i32");
    f5.addParam("outStep", "i32");
    f5.addLocal("itAux", "i32");
    f5.addLocal("itIn", "i32");
    f5.addLocal("itOut", "i32");
    f5.addLocal("i", "i32");
    const c3 = f5.getCodeBuilder();
    const AUX = c3.i32_const(module.alloc(n8));
    f5.addCode(
      c3.setLocal("itAux", c3.i32_load(c3.i32_const(0))),
      c3.i32_store(
        c3.i32_const(0),
        c3.i32_add(
          c3.getLocal("itAux"),
          c3.i32_mul(
            c3.i32_add(
              c3.getLocal("n"),
              c3.i32_const(1)
            ),
            c3.i32_const(n8)
          )
        )
      )
    );
    f5.addCode(
      c3.call(prefix + "_one", c3.getLocal("itAux")),
      c3.setLocal("itIn", c3.getLocal("pIn")),
      c3.setLocal("itAux", c3.i32_add(c3.getLocal("itAux"), c3.i32_const(n8))),
      c3.setLocal("i", c3.i32_const(0)),
      c3.block(c3.loop(
        c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("itIn")),
          c3.call(
            prefix + "_copy",
            c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8)),
            c3.getLocal("itAux")
          ),
          c3.call(
            prefix + "_mul",
            c3.getLocal("itIn"),
            c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8)),
            c3.getLocal("itAux")
          )
        ),
        c3.setLocal("itIn", c3.i32_add(c3.getLocal("itIn"), c3.getLocal("inStep"))),
        c3.setLocal("itAux", c3.i32_add(c3.getLocal("itAux"), c3.i32_const(n8))),
        c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
        c3.br(0)
      )),
      c3.setLocal("itIn", c3.i32_sub(c3.getLocal("itIn"), c3.getLocal("inStep"))),
      c3.setLocal("itAux", c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8))),
      c3.setLocal(
        "itOut",
        c3.i32_add(
          c3.getLocal("pOut"),
          c3.i32_mul(
            c3.i32_sub(c3.getLocal("n"), c3.i32_const(1)),
            c3.getLocal("outStep")
          )
        )
      ),
      c3.call(prefix + "_inverse", c3.getLocal("itAux"), c3.getLocal("itAux")),
      c3.block(c3.loop(
        c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("itIn")),
          [
            ...c3.call(
              prefix + "_copy",
              c3.getLocal("itAux"),
              c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8))
            ),
            ...c3.call(
              prefix + "_zero",
              c3.getLocal("itOut")
            )
          ],
          [
            ...c3.call(prefix + "_copy", c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8)), AUX),
            ...c3.call(
              prefix + "_mul",
              c3.getLocal("itAux"),
              c3.getLocal("itIn"),
              c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8))
            ),
            ...c3.call(
              prefix + "_mul",
              c3.getLocal("itAux"),
              AUX,
              c3.getLocal("itOut")
            )
          ]
        ),
        c3.setLocal("itIn", c3.i32_sub(c3.getLocal("itIn"), c3.getLocal("inStep"))),
        c3.setLocal("itOut", c3.i32_sub(c3.getLocal("itOut"), c3.getLocal("outStep"))),
        c3.setLocal("itAux", c3.i32_sub(c3.getLocal("itAux"), c3.i32_const(n8))),
        c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
        c3.br(0)
      ))
    );
    f5.addCode(
      c3.i32_store(
        c3.i32_const(0),
        c3.getLocal("itAux")
      )
    );
  }
  var build_batchconvertion = buildBatchConvertion$3;
  function buildBatchConvertion$3(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
    if (typeof reverse === "undefined") {
      if (sizeIn < sizeOut) {
        reverse = true;
      } else {
        reverse = false;
      }
    }
    const f5 = module.addFunction(fnName);
    f5.addParam("pIn", "i32");
    f5.addParam("n", "i32");
    f5.addParam("pOut", "i32");
    f5.addLocal("i", "i32");
    f5.addLocal("itIn", "i32");
    f5.addLocal("itOut", "i32");
    const c3 = f5.getCodeBuilder();
    if (reverse) {
      f5.addCode(
        c3.setLocal(
          "itIn",
          c3.i32_add(
            c3.getLocal("pIn"),
            c3.i32_mul(
              c3.i32_sub(
                c3.getLocal("n"),
                c3.i32_const(1)
              ),
              c3.i32_const(sizeIn)
            )
          )
        ),
        c3.setLocal(
          "itOut",
          c3.i32_add(
            c3.getLocal("pOut"),
            c3.i32_mul(
              c3.i32_sub(
                c3.getLocal("n"),
                c3.i32_const(1)
              ),
              c3.i32_const(sizeOut)
            )
          )
        ),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
          c3.call(internalFnName, c3.getLocal("itIn"), c3.getLocal("itOut")),
          c3.setLocal("itIn", c3.i32_sub(c3.getLocal("itIn"), c3.i32_const(sizeIn))),
          c3.setLocal("itOut", c3.i32_sub(c3.getLocal("itOut"), c3.i32_const(sizeOut))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    } else {
      f5.addCode(
        c3.setLocal("itIn", c3.getLocal("pIn")),
        c3.setLocal("itOut", c3.getLocal("pOut")),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
          c3.call(internalFnName, c3.getLocal("itIn"), c3.getLocal("itOut")),
          c3.setLocal("itIn", c3.i32_add(c3.getLocal("itIn"), c3.i32_const(sizeIn))),
          c3.setLocal("itOut", c3.i32_add(c3.getLocal("itOut"), c3.i32_const(sizeOut))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
  }
  var build_batchop = buildBatchConvertion$2;
  function buildBatchConvertion$2(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
    if (typeof reverse === "undefined") {
      if (sizeIn < sizeOut) {
        reverse = true;
      } else {
        reverse = false;
      }
    }
    const f5 = module.addFunction(fnName);
    f5.addParam("pIn1", "i32");
    f5.addParam("pIn2", "i32");
    f5.addParam("n", "i32");
    f5.addParam("pOut", "i32");
    f5.addLocal("i", "i32");
    f5.addLocal("itIn1", "i32");
    f5.addLocal("itIn2", "i32");
    f5.addLocal("itOut", "i32");
    const c3 = f5.getCodeBuilder();
    if (reverse) {
      f5.addCode(
        c3.setLocal(
          "itIn1",
          c3.i32_add(
            c3.getLocal("pIn1"),
            c3.i32_mul(
              c3.i32_sub(
                c3.getLocal("n"),
                c3.i32_const(1)
              ),
              c3.i32_const(sizeIn)
            )
          )
        ),
        c3.setLocal(
          "itIn2",
          c3.i32_add(
            c3.getLocal("pIn2"),
            c3.i32_mul(
              c3.i32_sub(
                c3.getLocal("n"),
                c3.i32_const(1)
              ),
              c3.i32_const(sizeIn)
            )
          )
        ),
        c3.setLocal(
          "itOut",
          c3.i32_add(
            c3.getLocal("pOut"),
            c3.i32_mul(
              c3.i32_sub(
                c3.getLocal("n"),
                c3.i32_const(1)
              ),
              c3.i32_const(sizeOut)
            )
          )
        ),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
          c3.call(internalFnName, c3.getLocal("itIn1"), c3.getLocal("itIn2"), c3.getLocal("itOut")),
          c3.setLocal("itIn1", c3.i32_sub(c3.getLocal("itIn1"), c3.i32_const(sizeIn))),
          c3.setLocal("itIn2", c3.i32_sub(c3.getLocal("itIn2"), c3.i32_const(sizeIn))),
          c3.setLocal("itOut", c3.i32_sub(c3.getLocal("itOut"), c3.i32_const(sizeOut))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    } else {
      f5.addCode(
        c3.setLocal("itIn1", c3.getLocal("pIn1")),
        c3.setLocal("itIn2", c3.getLocal("pIn2")),
        c3.setLocal("itOut", c3.getLocal("pOut")),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
          c3.call(internalFnName, c3.getLocal("itIn1"), c3.getLocal("itIn2"), c3.getLocal("itOut")),
          c3.setLocal("itIn1", c3.i32_add(c3.getLocal("itIn1"), c3.i32_const(sizeIn))),
          c3.setLocal("itIn2", c3.i32_add(c3.getLocal("itIn2"), c3.i32_const(sizeIn))),
          c3.setLocal("itOut", c3.i32_add(c3.getLocal("itOut"), c3.i32_const(sizeOut))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
  }
  var bigint = {};
  function compare(a4, b7) {
    return a4 === b7 ? 0 : a4 > b7 ? 1 : -1;
  }
  function square$1(n4) {
    return n4 * n4;
  }
  function isOdd$4(n4) {
    return n4 % 2n !== 0n;
  }
  function isEven(n4) {
    return n4 % 2n === 0n;
  }
  function isNegative$3(n4) {
    return n4 < 0n;
  }
  function isPositive(n4) {
    return n4 > 0n;
  }
  function bitLength$5(n4) {
    if (isNegative$3(n4)) {
      return n4.toString(2).length - 1;
    } else {
      return n4.toString(2).length;
    }
  }
  function abs(n4) {
    return n4 < 0n ? -n4 : n4;
  }
  function isUnit(n4) {
    return abs(n4) === 1n;
  }
  function modInv$3(a4, n4) {
    var t = 0n, newT = 1n, r = n4, newR = abs(a4), q5, lastT, lastR;
    while (newR !== 0n) {
      q5 = r / newR;
      lastT = t;
      lastR = r;
      t = newT;
      r = newR;
      newT = lastT - q5 * newT;
      newR = lastR - q5 * newR;
    }
    if (!isUnit(r))
      throw new Error(a4.toString() + " and " + n4.toString() + " are not co-prime");
    if (compare(t, 0n) === -1) {
      t = t + n4;
    }
    if (isNegative$3(a4)) {
      return -t;
    }
    return t;
  }
  function modPow$2(n4, exp2, mod3) {
    if (mod3 === 0n)
      throw new Error("Cannot take modPow with modulus 0");
    var r = 1n, base3 = n4 % mod3;
    if (isNegative$3(exp2)) {
      exp2 = exp2 * -1n;
      base3 = modInv$3(base3, mod3);
    }
    while (isPositive(exp2)) {
      if (base3 === 0n)
        return 0n;
      if (isOdd$4(exp2))
        r = r * base3 % mod3;
      exp2 = exp2 / 2n;
      base3 = square$1(base3) % mod3;
    }
    return r;
  }
  function compareAbs(a4, b7) {
    a4 = a4 >= 0n ? a4 : -a4;
    b7 = b7 >= 0n ? b7 : -b7;
    return a4 === b7 ? 0 : a4 > b7 ? 1 : -1;
  }
  function isDivisibleBy(a4, n4) {
    if (n4 === 0n)
      return false;
    if (isUnit(n4))
      return true;
    if (compareAbs(n4, 2n) === 0)
      return isEven(a4);
    return a4 % n4 === 0n;
  }
  function isBasicPrime(v6) {
    var n4 = abs(v6);
    if (isUnit(n4))
      return false;
    if (n4 === 2n || n4 === 3n || n4 === 5n)
      return true;
    if (isEven(n4) || isDivisibleBy(n4, 3n) || isDivisibleBy(n4, 5n))
      return false;
    if (n4 < 49n)
      return true;
  }
  function prev(n4) {
    return n4 - 1n;
  }
  function millerRabinTest(n4, a4) {
    var nPrev = prev(n4), b7 = nPrev, r = 0, d5, i4, x6;
    while (isEven(b7))
      b7 = b7 / 2n, r++;
    next:
      for (i4 = 0; i4 < a4.length; i4++) {
        if (n4 < a4[i4])
          continue;
        x6 = modPow$2(BigInt(a4[i4]), b7, n4);
        if (isUnit(x6) || x6 === nPrev)
          continue;
        for (d5 = r - 1; d5 != 0; d5--) {
          x6 = square$1(x6) % n4;
          if (isUnit(x6))
            return false;
          if (x6 === nPrev)
            continue next;
        }
        return false;
      }
    return true;
  }
  function isPrime$1(p6) {
    var isPrime2 = isBasicPrime(p6);
    if (isPrime2 !== void 0)
      return isPrime2;
    var n4 = abs(p6);
    var bits2 = bitLength$5(n4);
    if (bits2 <= 64)
      return millerRabinTest(n4, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
    var logN = Math.log(2) * Number(bits2);
    var t = Math.ceil(logN);
    for (var a4 = [], i4 = 0; i4 < t; i4++) {
      a4.push(BigInt(i4 + 2));
    }
    return millerRabinTest(n4, a4);
  }
  bigint.bitLength = bitLength$5;
  bigint.isOdd = isOdd$4;
  bigint.isNegative = isNegative$3;
  bigint.abs = abs;
  bigint.isUnit = isUnit;
  bigint.compare = compare;
  bigint.modInv = modInv$3;
  bigint.modPow = modPow$2;
  bigint.isPrime = isPrime$1;
  bigint.square = square$1;
  var buildInt2 = build_int;
  var utils$5 = utils$6;
  var buildExp$2 = build_timesscalar;
  var buildBatchInverse$2 = build_batchinverse;
  var buildBatchConvertion$1 = build_batchconvertion;
  var buildBatchOp = build_batchop;
  var { bitLength: bitLength$4, modInv: modInv$2, modPow: modPow$1, isPrime, isOdd: isOdd$3, square } = bigint;
  var build_f1m = function buildF1m(module, _q, _prefix, _intPrefix) {
    const q5 = BigInt(_q);
    const n64 = Math.floor((bitLength$4(q5 - 1n) - 1) / 64) + 1;
    const n32 = n64 * 2;
    const n8 = n64 * 8;
    const prefix = _prefix || "f1m";
    if (module.modules[prefix])
      return prefix;
    const intPrefix = buildInt2(module, n64, _intPrefix);
    const pq = module.alloc(n8, utils$5.bigInt2BytesLE(q5, n8));
    const pR2 = module.alloc(utils$5.bigInt2BytesLE(square(1n << BigInt(n64 * 64)) % q5, n8));
    const pOne = module.alloc(utils$5.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q5, n8));
    const pZero = module.alloc(utils$5.bigInt2BytesLE(0n, n8));
    const _minusOne = q5 - 1n;
    const _e2 = _minusOne >> 1n;
    const pe2 = module.alloc(n8, utils$5.bigInt2BytesLE(_e2, n8));
    const _ePlusOne = _e2 + 1n;
    const pePlusOne = module.alloc(n8, utils$5.bigInt2BytesLE(_ePlusOne, n8));
    module.modules[prefix] = {
      pq,
      pR2,
      n64,
      q: q5,
      pOne,
      pZero,
      pePlusOne
    };
    function buildOne() {
      const f5 = module.addFunction(prefix + "_one");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(intPrefix + "_copy", c3.i32_const(pOne), c3.getLocal("pr")));
    }
    function buildAdd() {
      const f5 = module.addFunction(prefix + "_add");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.if(
          c3.call(intPrefix + "_add", c3.getLocal("x"), c3.getLocal("y"), c3.getLocal("r")),
          c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r"))),
          c3.if(
            c3.call(intPrefix + "_gte", c3.getLocal("r"), c3.i32_const(pq)),
            c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r")))
          )
        )
      );
    }
    function buildSub() {
      const f5 = module.addFunction(prefix + "_sub");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.if(
          c3.call(intPrefix + "_sub", c3.getLocal("x"), c3.getLocal("y"), c3.getLocal("r")),
          c3.drop(c3.call(intPrefix + "_add", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r")))
        )
      );
    }
    function buildNeg() {
      const f5 = module.addFunction(prefix + "_neg");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(prefix + "_sub", c3.i32_const(pZero), c3.getLocal("x"), c3.getLocal("r"))
      );
    }
    function buildIsNegative() {
      const f5 = module.addFunction(prefix + "_isNegative");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.call(prefix + "_fromMontgomery", c3.getLocal("x"), AUX),
        c3.call(intPrefix + "_gte", AUX, c3.i32_const(pePlusOne))
      );
    }
    function buildSign() {
      const f5 = module.addFunction(prefix + "_sign");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(intPrefix + "_isZero", c3.getLocal("x")),
          c3.ret(c3.i32_const(0))
        ),
        c3.call(prefix + "_fromMontgomery", c3.getLocal("x"), AUX),
        c3.if(
          c3.call(intPrefix + "_gte", AUX, c3.i32_const(pePlusOne)),
          c3.ret(c3.i32_const(-1))
        ),
        c3.ret(c3.i32_const(1))
      );
    }
    function buildMReduct() {
      const carries = module.alloc(n32 * n32 * 8);
      const f5 = module.addFunction(prefix + "_mReduct");
      f5.addParam("t", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("np32", "i64");
      f5.addLocal("c", "i64");
      f5.addLocal("m", "i64");
      const c3 = f5.getCodeBuilder();
      const np32 = Number(0x100000000n - modInv$2(q5, 0x100000000n));
      f5.addCode(c3.setLocal("np32", c3.i64_const(np32)));
      for (let i4 = 0; i4 < n32; i4++) {
        f5.addCode(c3.setLocal("c", c3.i64_const(0)));
        f5.addCode(
          c3.setLocal(
            "m",
            c3.i64_and(
              c3.i64_mul(
                c3.i64_load32_u(c3.getLocal("t"), i4 * 4),
                c3.getLocal("np32")
              ),
              c3.i64_const("0xFFFFFFFF")
            )
          )
        );
        for (let j5 = 0; j5 < n32; j5++) {
          f5.addCode(
            c3.setLocal(
              "c",
              c3.i64_add(
                c3.i64_add(
                  c3.i64_load32_u(c3.getLocal("t"), (i4 + j5) * 4),
                  c3.i64_shr_u(c3.getLocal("c"), c3.i64_const(32))
                ),
                c3.i64_mul(
                  c3.i64_load32_u(c3.i32_const(pq), j5 * 4),
                  c3.getLocal("m")
                )
              )
            )
          );
          f5.addCode(
            c3.i64_store32(
              c3.getLocal("t"),
              (i4 + j5) * 4,
              c3.getLocal("c")
            )
          );
        }
        f5.addCode(
          c3.i64_store32(
            c3.i32_const(carries),
            i4 * 4,
            c3.i64_shr_u(c3.getLocal("c"), c3.i64_const(32))
          )
        );
      }
      f5.addCode(
        c3.call(
          prefix + "_add",
          c3.i32_const(carries),
          c3.i32_add(
            c3.getLocal("t"),
            c3.i32_const(n32 * 4)
          ),
          c3.getLocal("r")
        )
      );
    }
    function buildMul() {
      const f5 = module.addFunction(prefix + "_mul");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("c0", "i64");
      f5.addLocal("c1", "i64");
      f5.addLocal("np32", "i64");
      for (let i4 = 0; i4 < n32; i4++) {
        f5.addLocal("x" + i4, "i64");
        f5.addLocal("y" + i4, "i64");
        f5.addLocal("m" + i4, "i64");
        f5.addLocal("q" + i4, "i64");
      }
      const c3 = f5.getCodeBuilder();
      const np32 = Number(0x100000000n - modInv$2(q5, 0x100000000n));
      f5.addCode(c3.setLocal("np32", c3.i64_const(np32)));
      const loadX = [];
      const loadY = [];
      const loadQ = [];
      function mulij(i4, j5) {
        let X5, Y5;
        if (!loadX[i4]) {
          X5 = c3.teeLocal("x" + i4, c3.i64_load32_u(c3.getLocal("x"), i4 * 4));
          loadX[i4] = true;
        } else {
          X5 = c3.getLocal("x" + i4);
        }
        if (!loadY[j5]) {
          Y5 = c3.teeLocal("y" + j5, c3.i64_load32_u(c3.getLocal("y"), j5 * 4));
          loadY[j5] = true;
        } else {
          Y5 = c3.getLocal("y" + j5);
        }
        return c3.i64_mul(X5, Y5);
      }
      function mulqm(i4, j5) {
        let Q5, M6;
        if (!loadQ[i4]) {
          Q5 = c3.teeLocal("q" + i4, c3.i64_load32_u(c3.i32_const(0), pq + i4 * 4));
          loadQ[i4] = true;
        } else {
          Q5 = c3.getLocal("q" + i4);
        }
        M6 = c3.getLocal("m" + j5);
        return c3.i64_mul(Q5, M6);
      }
      let c0 = "c0";
      let c1 = "c1";
      for (let k5 = 0; k5 < n32 * 2 - 1; k5++) {
        for (let i4 = Math.max(0, k5 - n32 + 1); i4 <= k5 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        for (let i4 = Math.max(1, k5 - n32 + 1); i4 <= k5 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulqm(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 < n32) {
          f5.addCode(
            c3.setLocal(
              "m" + k5,
              c3.i64_and(
                c3.i64_mul(
                  c3.i64_and(
                    c3.getLocal(c0),
                    c3.i64_const(4294967295)
                  ),
                  c3.getLocal("np32")
                ),
                c3.i64_const("0xFFFFFFFF")
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulqm(0, k5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 >= n32) {
          f5.addCode(
            c3.i64_store32(
              c3.getLocal("r"),
              (k5 - n32) * 4,
              c3.getLocal(c0)
            )
          );
        }
        [c0, c1] = [c1, c0];
        f5.addCode(
          c3.setLocal(
            c1,
            c3.i64_shr_u(
              c3.getLocal(c0),
              c3.i64_const(32)
            )
          )
        );
      }
      f5.addCode(
        c3.i64_store32(
          c3.getLocal("r"),
          n32 * 4 - 4,
          c3.getLocal(c0)
        )
      );
      f5.addCode(
        c3.if(
          c3.i32_wrap_i64(c3.getLocal(c1)),
          c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r"))),
          c3.if(
            c3.call(intPrefix + "_gte", c3.getLocal("r"), c3.i32_const(pq)),
            c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r")))
          )
        )
      );
    }
    function buildSquare() {
      const f5 = module.addFunction(prefix + "_square");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("c0", "i64");
      f5.addLocal("c1", "i64");
      f5.addLocal("c0_old", "i64");
      f5.addLocal("c1_old", "i64");
      f5.addLocal("np32", "i64");
      for (let i4 = 0; i4 < n32; i4++) {
        f5.addLocal("x" + i4, "i64");
        f5.addLocal("m" + i4, "i64");
        f5.addLocal("q" + i4, "i64");
      }
      const c3 = f5.getCodeBuilder();
      const np32 = Number(0x100000000n - modInv$2(q5, 0x100000000n));
      f5.addCode(c3.setLocal("np32", c3.i64_const(np32)));
      const loadX = [];
      const loadQ = [];
      function mulij(i4, j5) {
        let X5, Y5;
        if (!loadX[i4]) {
          X5 = c3.teeLocal("x" + i4, c3.i64_load32_u(c3.getLocal("x"), i4 * 4));
          loadX[i4] = true;
        } else {
          X5 = c3.getLocal("x" + i4);
        }
        if (!loadX[j5]) {
          Y5 = c3.teeLocal("x" + j5, c3.i64_load32_u(c3.getLocal("x"), j5 * 4));
          loadX[j5] = true;
        } else {
          Y5 = c3.getLocal("x" + j5);
        }
        return c3.i64_mul(X5, Y5);
      }
      function mulqm(i4, j5) {
        let Q5, M6;
        if (!loadQ[i4]) {
          Q5 = c3.teeLocal("q" + i4, c3.i64_load32_u(c3.i32_const(0), pq + i4 * 4));
          loadQ[i4] = true;
        } else {
          Q5 = c3.getLocal("q" + i4);
        }
        M6 = c3.getLocal("m" + j5);
        return c3.i64_mul(Q5, M6);
      }
      let c0 = "c0";
      let c1 = "c1";
      let c0_old = "c0_old";
      let c1_old = "c1_old";
      for (let k5 = 0; k5 < n32 * 2 - 1; k5++) {
        f5.addCode(
          c3.setLocal(c0, c3.i64_const(0)),
          c3.setLocal(c1, c3.i64_const(0))
        );
        for (let i4 = Math.max(0, k5 - n32 + 1); i4 < k5 + 1 >> 1 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        f5.addCode(
          c3.setLocal(
            c0,
            c3.i64_shl(
              c3.i64_and(
                c3.getLocal(c0),
                c3.i64_const(4294967295)
              ),
              c3.i64_const(1)
            )
          )
        );
        f5.addCode(
          c3.setLocal(
            c1,
            c3.i64_add(
              c3.i64_shl(
                c3.getLocal(c1),
                c3.i64_const(1)
              ),
              c3.i64_shr_u(
                c3.getLocal(c0),
                c3.i64_const(32)
              )
            )
          )
        );
        if (k5 % 2 == 0) {
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulij(k5 >> 1, k5 >> 1)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 > 0) {
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                c3.i64_and(
                  c3.getLocal(c0_old),
                  c3.i64_const(4294967295)
                )
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.i64_add(
                  c3.getLocal(c1),
                  c3.i64_shr_u(
                    c3.getLocal(c0),
                    c3.i64_const(32)
                  )
                ),
                c3.getLocal(c1_old)
              )
            )
          );
        }
        for (let i4 = Math.max(1, k5 - n32 + 1); i4 <= k5 && i4 < n32; i4++) {
          const j5 = k5 - i4;
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulqm(i4, j5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 < n32) {
          f5.addCode(
            c3.setLocal(
              "m" + k5,
              c3.i64_and(
                c3.i64_mul(
                  c3.i64_and(
                    c3.getLocal(c0),
                    c3.i64_const(4294967295)
                  ),
                  c3.getLocal("np32")
                ),
                c3.i64_const("0xFFFFFFFF")
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c0,
              c3.i64_add(
                c3.i64_and(
                  c3.getLocal(c0),
                  c3.i64_const(4294967295)
                ),
                mulqm(0, k5)
              )
            )
          );
          f5.addCode(
            c3.setLocal(
              c1,
              c3.i64_add(
                c3.getLocal(c1),
                c3.i64_shr_u(
                  c3.getLocal(c0),
                  c3.i64_const(32)
                )
              )
            )
          );
        }
        if (k5 >= n32) {
          f5.addCode(
            c3.i64_store32(
              c3.getLocal("r"),
              (k5 - n32) * 4,
              c3.getLocal(c0)
            )
          );
        }
        f5.addCode(
          c3.setLocal(
            c0_old,
            c3.getLocal(c1)
          ),
          c3.setLocal(
            c1_old,
            c3.i64_shr_u(
              c3.getLocal(c0_old),
              c3.i64_const(32)
            )
          )
        );
      }
      f5.addCode(
        c3.i64_store32(
          c3.getLocal("r"),
          n32 * 4 - 4,
          c3.getLocal(c0_old)
        )
      );
      f5.addCode(
        c3.if(
          c3.i32_wrap_i64(c3.getLocal(c1_old)),
          c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r"))),
          c3.if(
            c3.call(intPrefix + "_gte", c3.getLocal("r"), c3.i32_const(pq)),
            c3.drop(c3.call(intPrefix + "_sub", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r")))
          )
        )
      );
    }
    function buildSquareOld() {
      const f5 = module.addFunction(prefix + "_squareOld");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(prefix + "_mul", c3.getLocal("x"), c3.getLocal("x"), c3.getLocal("r")));
    }
    function buildToMontgomery() {
      const f5 = module.addFunction(prefix + "_toMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(prefix + "_mul", c3.getLocal("x"), c3.i32_const(pR2), c3.getLocal("r")));
    }
    function buildFromMontgomery() {
      const pAux2 = module.alloc(n8 * 2);
      const f5 = module.addFunction(prefix + "_fromMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(intPrefix + "_copy", c3.getLocal("x"), c3.i32_const(pAux2)));
      f5.addCode(c3.call(intPrefix + "_zero", c3.i32_const(pAux2 + n8)));
      f5.addCode(c3.call(prefix + "_mReduct", c3.i32_const(pAux2), c3.getLocal("r")));
    }
    function buildInverse() {
      const f5 = module.addFunction(prefix + "_inverse");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(prefix + "_fromMontgomery", c3.getLocal("x"), c3.getLocal("r")));
      f5.addCode(c3.call(intPrefix + "_inverseMod", c3.getLocal("r"), c3.i32_const(pq), c3.getLocal("r")));
      f5.addCode(c3.call(prefix + "_toMontgomery", c3.getLocal("r"), c3.getLocal("r")));
    }
    let _nqr = 2n;
    if (isPrime(q5)) {
      while (modPow$1(_nqr, _e2, q5) !== _minusOne)
        _nqr = _nqr + 1n;
    }
    let s22 = 0;
    let _t3 = _minusOne;
    while (!isOdd$3(_t3) && _t3 !== 0n) {
      s22++;
      _t3 = _t3 >> 1n;
    }
    const pt3 = module.alloc(n8, utils$5.bigInt2BytesLE(_t3, n8));
    const _nqrToT = modPow$1(_nqr, _t3, q5);
    const pNqrToT = module.alloc(utils$5.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q5, n8));
    const _tPlusOneOver2 = _t3 + 1n >> 1n;
    const ptPlusOneOver2 = module.alloc(n8, utils$5.bigInt2BytesLE(_tPlusOneOver2, n8));
    function buildSqrt2() {
      const f5 = module.addFunction(prefix + "_sqrt");
      f5.addParam("n", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("m", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      const c3 = f5.getCodeBuilder();
      const ONE = c3.i32_const(pOne);
      const C5 = c3.i32_const(module.alloc(n8));
      const T6 = c3.i32_const(module.alloc(n8));
      const R5 = c3.i32_const(module.alloc(n8));
      const SQ = c3.i32_const(module.alloc(n8));
      const B6 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("n")),
          c3.ret(
            c3.call(prefix + "_zero", c3.getLocal("r"))
          )
        ),
        c3.setLocal("m", c3.i32_const(s22)),
        c3.call(prefix + "_copy", c3.i32_const(pNqrToT), C5),
        c3.call(prefix + "_exp", c3.getLocal("n"), c3.i32_const(pt3), c3.i32_const(n8), T6),
        c3.call(prefix + "_exp", c3.getLocal("n"), c3.i32_const(ptPlusOneOver2), c3.i32_const(n8), R5),
        c3.block(c3.loop(
          c3.br_if(1, c3.call(prefix + "_eq", T6, ONE)),
          c3.call(prefix + "_square", T6, SQ),
          c3.setLocal("i", c3.i32_const(1)),
          c3.block(c3.loop(
            c3.br_if(1, c3.call(prefix + "_eq", SQ, ONE)),
            c3.call(prefix + "_square", SQ, SQ),
            c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
            c3.br(0)
          )),
          c3.call(prefix + "_copy", C5, B6),
          c3.setLocal("j", c3.i32_sub(c3.i32_sub(c3.getLocal("m"), c3.getLocal("i")), c3.i32_const(1))),
          c3.block(c3.loop(
            c3.br_if(1, c3.i32_eqz(c3.getLocal("j"))),
            c3.call(prefix + "_square", B6, B6),
            c3.setLocal("j", c3.i32_sub(c3.getLocal("j"), c3.i32_const(1))),
            c3.br(0)
          )),
          c3.setLocal("m", c3.getLocal("i")),
          c3.call(prefix + "_square", B6, C5),
          c3.call(prefix + "_mul", T6, C5, T6),
          c3.call(prefix + "_mul", R5, B6, R5),
          c3.br(0)
        )),
        c3.if(
          c3.call(prefix + "_isNegative", R5),
          c3.call(prefix + "_neg", R5, c3.getLocal("r")),
          c3.call(prefix + "_copy", R5, c3.getLocal("r"))
        )
      );
    }
    function buildIsSquare() {
      const f5 = module.addFunction(prefix + "_isSquare");
      f5.addParam("n", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const ONE = c3.i32_const(pOne);
      const AUX = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("n")),
          c3.ret(c3.i32_const(1))
        ),
        c3.call(prefix + "_exp", c3.getLocal("n"), c3.i32_const(pe2), c3.i32_const(n8), AUX),
        c3.call(prefix + "_eq", AUX, ONE)
      );
    }
    function buildLoad() {
      const f5 = module.addFunction(prefix + "_load");
      f5.addParam("scalar", "i32");
      f5.addParam("scalarLen", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("p", "i32");
      f5.addLocal("l", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      const c3 = f5.getCodeBuilder();
      const R5 = c3.i32_const(module.alloc(n8));
      const pAux = module.alloc(n8);
      const AUX = c3.i32_const(pAux);
      f5.addCode(
        c3.call(intPrefix + "_zero", c3.getLocal("r")),
        c3.setLocal("i", c3.i32_const(n8)),
        c3.setLocal("p", c3.getLocal("scalar")),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_gt_u(c3.getLocal("i"), c3.getLocal("scalarLen"))),
          c3.if(
            c3.i32_eq(c3.getLocal("i"), c3.i32_const(n8)),
            c3.call(prefix + "_one", R5),
            c3.call(prefix + "_mul", R5, c3.i32_const(pR2), R5)
          ),
          c3.call(prefix + "_mul", c3.getLocal("p"), R5, AUX),
          c3.call(prefix + "_add", c3.getLocal("r"), AUX, c3.getLocal("r")),
          c3.setLocal("p", c3.i32_add(c3.getLocal("p"), c3.i32_const(n8))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(n8))),
          c3.br(0)
        )),
        c3.setLocal("l", c3.i32_rem_u(c3.getLocal("scalarLen"), c3.i32_const(n8))),
        c3.if(c3.i32_eqz(c3.getLocal("l")), c3.ret([])),
        c3.call(intPrefix + "_zero", AUX),
        c3.setLocal("j", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("j"), c3.getLocal("l"))),
          c3.i32_store8(
            c3.getLocal("j"),
            pAux,
            c3.i32_load8_u(c3.getLocal("p"))
          ),
          c3.setLocal("p", c3.i32_add(c3.getLocal("p"), c3.i32_const(1))),
          c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.if(
          c3.i32_eq(c3.getLocal("i"), c3.i32_const(n8)),
          c3.call(prefix + "_one", R5),
          c3.call(prefix + "_mul", R5, c3.i32_const(pR2), R5)
        ),
        c3.call(prefix + "_mul", AUX, R5, AUX),
        c3.call(prefix + "_add", c3.getLocal("r"), AUX, c3.getLocal("r"))
      );
    }
    function buildTimesScalar2() {
      const f5 = module.addFunction(prefix + "_timesScalar");
      f5.addParam("x", "i32");
      f5.addParam("scalar", "i32");
      f5.addParam("scalarLen", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.call(prefix + "_load", c3.getLocal("scalar"), c3.getLocal("scalarLen"), AUX),
        c3.call(prefix + "_toMontgomery", AUX, AUX),
        c3.call(prefix + "_mul", c3.getLocal("x"), AUX, c3.getLocal("r"))
      );
    }
    function buildIsOne() {
      const f5 = module.addFunction(prefix + "_isOne");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.ret(c3.call(intPrefix + "_eq", c3.getLocal("x"), c3.i32_const(pOne)))
      );
    }
    module.exportFunction(intPrefix + "_copy", prefix + "_copy");
    module.exportFunction(intPrefix + "_zero", prefix + "_zero");
    module.exportFunction(intPrefix + "_isZero", prefix + "_isZero");
    module.exportFunction(intPrefix + "_eq", prefix + "_eq");
    buildIsOne();
    buildAdd();
    buildSub();
    buildNeg();
    buildMReduct();
    buildMul();
    buildSquare();
    buildSquareOld();
    buildToMontgomery();
    buildFromMontgomery();
    buildIsNegative();
    buildSign();
    buildInverse();
    buildOne();
    buildLoad();
    buildTimesScalar2();
    buildBatchInverse$2(module, prefix);
    buildBatchConvertion$1(module, prefix + "_batchToMontgomery", prefix + "_toMontgomery", n8, n8);
    buildBatchConvertion$1(module, prefix + "_batchFromMontgomery", prefix + "_fromMontgomery", n8, n8);
    buildBatchConvertion$1(module, prefix + "_batchNeg", prefix + "_neg", n8, n8);
    buildBatchOp(module, prefix + "_batchAdd", prefix + "_add", n8, n8);
    buildBatchOp(module, prefix + "_batchSub", prefix + "_sub", n8, n8);
    buildBatchOp(module, prefix + "_batchMul", prefix + "_mul", n8, n8);
    module.exportFunction(prefix + "_add");
    module.exportFunction(prefix + "_sub");
    module.exportFunction(prefix + "_neg");
    module.exportFunction(prefix + "_isNegative");
    module.exportFunction(prefix + "_isOne");
    module.exportFunction(prefix + "_sign");
    module.exportFunction(prefix + "_mReduct");
    module.exportFunction(prefix + "_mul");
    module.exportFunction(prefix + "_square");
    module.exportFunction(prefix + "_squareOld");
    module.exportFunction(prefix + "_fromMontgomery");
    module.exportFunction(prefix + "_toMontgomery");
    module.exportFunction(prefix + "_inverse");
    module.exportFunction(prefix + "_one");
    module.exportFunction(prefix + "_load");
    module.exportFunction(prefix + "_timesScalar");
    buildExp$2(
      module,
      prefix + "_exp",
      n8,
      prefix + "_mul",
      prefix + "_square",
      intPrefix + "_copy",
      prefix + "_one"
    );
    module.exportFunction(prefix + "_exp");
    module.exportFunction(prefix + "_batchInverse");
    if (isPrime(q5)) {
      buildSqrt2();
      buildIsSquare();
      module.exportFunction(prefix + "_sqrt");
      module.exportFunction(prefix + "_isSquare");
    }
    module.exportFunction(prefix + "_batchToMontgomery");
    module.exportFunction(prefix + "_batchFromMontgomery");
    return prefix;
  };
  var buildF1m$2 = build_f1m;
  var { bitLength: bitLength$3 } = bigint;
  var build_f1 = function buildF1(module, _q, _prefix, _f1mPrefix, _intPrefix) {
    const q5 = BigInt(_q);
    const n64 = Math.floor((bitLength$3(q5 - 1n) - 1) / 64) + 1;
    const n8 = n64 * 8;
    const prefix = _prefix || "f1";
    if (module.modules[prefix])
      return prefix;
    module.modules[prefix] = {
      n64
    };
    const intPrefix = _intPrefix || "int";
    const f1mPrefix = buildF1m$2(module, q5, _f1mPrefix, intPrefix);
    const pR2 = module.modules[f1mPrefix].pR2;
    const pq = module.modules[f1mPrefix].pq;
    const pePlusOne = module.modules[f1mPrefix].pePlusOne;
    function buildMul() {
      const pAux1 = module.alloc(n8);
      const f5 = module.addFunction(prefix + "_mul");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(f1mPrefix + "_mul", c3.getLocal("x"), c3.getLocal("y"), c3.i32_const(pAux1)));
      f5.addCode(c3.call(f1mPrefix + "_mul", c3.i32_const(pAux1), c3.i32_const(pR2), c3.getLocal("r")));
    }
    function buildSquare() {
      const f5 = module.addFunction(prefix + "_square");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(prefix + "_mul", c3.getLocal("x"), c3.getLocal("x"), c3.getLocal("r")));
    }
    function buildInverse() {
      const f5 = module.addFunction(prefix + "_inverse");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(intPrefix + "_inverseMod", c3.getLocal("x"), c3.i32_const(pq), c3.getLocal("r")));
    }
    function buildIsNegative() {
      const f5 = module.addFunction(prefix + "_isNegative");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(intPrefix + "_gte", c3.getLocal("x"), c3.i32_const(pePlusOne))
      );
    }
    buildMul();
    buildSquare();
    buildInverse();
    buildIsNegative();
    module.exportFunction(f1mPrefix + "_add", prefix + "_add");
    module.exportFunction(f1mPrefix + "_sub", prefix + "_sub");
    module.exportFunction(f1mPrefix + "_neg", prefix + "_neg");
    module.exportFunction(prefix + "_mul");
    module.exportFunction(prefix + "_square");
    module.exportFunction(prefix + "_inverse");
    module.exportFunction(prefix + "_isNegative");
    module.exportFunction(f1mPrefix + "_copy", prefix + "_copy");
    module.exportFunction(f1mPrefix + "_zero", prefix + "_zero");
    module.exportFunction(f1mPrefix + "_one", prefix + "_one");
    module.exportFunction(f1mPrefix + "_isZero", prefix + "_isZero");
    module.exportFunction(f1mPrefix + "_eq", prefix + "_eq");
    return prefix;
  };
  var buildExp$1 = build_timesscalar;
  var buildBatchInverse$1 = build_batchinverse;
  var utils$4 = utils$6;
  var build_f2m = function buildF2m(module, mulNonResidueFn, prefix, f1mPrefix) {
    if (module.modules[prefix])
      return prefix;
    const f1n8 = module.modules[f1mPrefix].n64 * 8;
    const q5 = module.modules[f1mPrefix].q;
    module.modules[prefix] = {
      n64: module.modules[f1mPrefix].n64 * 2
    };
    function buildAdd() {
      const f5 = module.addFunction(prefix + "_add");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_add", x0, y0, r0),
        c3.call(f1mPrefix + "_add", x1, y1, r1)
      );
    }
    function buildTimesScalar2() {
      const f5 = module.addFunction(prefix + "_timesScalar");
      f5.addParam("x", "i32");
      f5.addParam("scalar", "i32");
      f5.addParam("scalarLen", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_timesScalar", x0, c3.getLocal("scalar"), c3.getLocal("scalarLen"), r0),
        c3.call(f1mPrefix + "_timesScalar", x1, c3.getLocal("scalar"), c3.getLocal("scalarLen"), r1)
      );
    }
    function buildSub() {
      const f5 = module.addFunction(prefix + "_sub");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_sub", x0, y0, r0),
        c3.call(f1mPrefix + "_sub", x1, y1, r1)
      );
    }
    function buildNeg() {
      const f5 = module.addFunction(prefix + "_neg");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_neg", x0, r0),
        c3.call(f1mPrefix + "_neg", x1, r1)
      );
    }
    function buildConjugate() {
      const f5 = module.addFunction(prefix + "_conjugate");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_copy", x0, r0),
        c3.call(f1mPrefix + "_neg", x1, r1)
      );
    }
    function buildIsNegative() {
      const f5 = module.addFunction(prefix + "_isNegative");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.if(
          c3.call(f1mPrefix + "_isZero", x1),
          c3.ret(c3.call(f1mPrefix + "_isNegative", x0))
        ),
        c3.ret(c3.call(f1mPrefix + "_isNegative", x1))
      );
    }
    function buildMul() {
      const f5 = module.addFunction(prefix + "_mul");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const A5 = c3.i32_const(module.alloc(f1n8));
      const B6 = c3.i32_const(module.alloc(f1n8));
      const C5 = c3.i32_const(module.alloc(f1n8));
      const D4 = c3.i32_const(module.alloc(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_mul", x0, y0, A5),
        c3.call(f1mPrefix + "_mul", x1, y1, B6),
        c3.call(f1mPrefix + "_add", x0, x1, C5),
        c3.call(f1mPrefix + "_add", y0, y1, D4),
        c3.call(f1mPrefix + "_mul", C5, D4, C5),
        c3.call(mulNonResidueFn, B6, r0),
        c3.call(f1mPrefix + "_add", A5, r0, r0),
        c3.call(f1mPrefix + "_add", A5, B6, r1),
        c3.call(f1mPrefix + "_sub", C5, r1, r1)
      );
    }
    function buildMul1() {
      const f5 = module.addFunction(prefix + "_mul1");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const y5 = c3.getLocal("y");
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_mul", x0, y5, r0),
        c3.call(f1mPrefix + "_mul", x1, y5, r1)
      );
    }
    function buildSquare() {
      const f5 = module.addFunction(prefix + "_square");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const AB = c3.i32_const(module.alloc(f1n8));
      const APB = c3.i32_const(module.alloc(f1n8));
      const APNB = c3.i32_const(module.alloc(f1n8));
      const ABPNAB = c3.i32_const(module.alloc(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_mul", x0, x1, AB),
        c3.call(f1mPrefix + "_add", x0, x1, APB),
        c3.call(mulNonResidueFn, x1, APNB),
        c3.call(f1mPrefix + "_add", x0, APNB, APNB),
        c3.call(mulNonResidueFn, AB, ABPNAB),
        c3.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
        c3.call(f1mPrefix + "_mul", APB, APNB, r0),
        c3.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
        c3.call(f1mPrefix + "_add", AB, AB, r1)
      );
    }
    function buildToMontgomery() {
      const f5 = module.addFunction(prefix + "_toMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_toMontgomery", x0, r0),
        c3.call(f1mPrefix + "_toMontgomery", x1, r1)
      );
    }
    function buildFromMontgomery() {
      const f5 = module.addFunction(prefix + "_fromMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_fromMontgomery", x0, r0),
        c3.call(f1mPrefix + "_fromMontgomery", x1, r1)
      );
    }
    function buildCopy() {
      const f5 = module.addFunction(prefix + "_copy");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_copy", x0, r0),
        c3.call(f1mPrefix + "_copy", x1, r1)
      );
    }
    function buildZero() {
      const f5 = module.addFunction(prefix + "_zero");
      f5.addParam("x", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_zero", x0),
        c3.call(f1mPrefix + "_zero", x1)
      );
    }
    function buildOne() {
      const f5 = module.addFunction(prefix + "_one");
      f5.addParam("x", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_one", x0),
        c3.call(f1mPrefix + "_zero", x1)
      );
    }
    function buildEq() {
      const f5 = module.addFunction(prefix + "_eq");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      f5.addCode(
        c3.i32_and(
          c3.call(f1mPrefix + "_eq", x0, y0),
          c3.call(f1mPrefix + "_eq", x1, y1)
        )
      );
    }
    function buildIsZero() {
      const f5 = module.addFunction(prefix + "_isZero");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.i32_and(
          c3.call(f1mPrefix + "_isZero", x0),
          c3.call(f1mPrefix + "_isZero", x1)
        )
      );
    }
    function buildInverse() {
      const f5 = module.addFunction(prefix + "_inverse");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const t0 = c3.i32_const(module.alloc(f1n8));
      const t1 = c3.i32_const(module.alloc(f1n8));
      const t2 = c3.i32_const(module.alloc(f1n8));
      const t3 = c3.i32_const(module.alloc(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_square", x0, t0),
        c3.call(f1mPrefix + "_square", x1, t1),
        c3.call(mulNonResidueFn, t1, t2),
        c3.call(f1mPrefix + "_sub", t0, t2, t2),
        c3.call(f1mPrefix + "_inverse", t2, t3),
        c3.call(f1mPrefix + "_mul", x0, t3, r0),
        c3.call(f1mPrefix + "_mul", x1, t3, r1),
        c3.call(f1mPrefix + "_neg", r1, r1)
      );
    }
    function buildSign() {
      const f5 = module.addFunction(prefix + "_sign");
      f5.addParam("x", "i32");
      f5.addLocal("s", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.setLocal("s", c3.call(f1mPrefix + "_sign", x1)),
        c3.if(
          c3.getLocal("s"),
          c3.ret(c3.getLocal("s"))
        ),
        c3.ret(c3.call(f1mPrefix + "_sign", x0))
      );
    }
    function buildIsOne() {
      const f5 = module.addFunction(prefix + "_isOne");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      f5.addCode(
        c3.ret(c3.i32_and(
          c3.call(f1mPrefix + "_isOne", x0),
          c3.call(f1mPrefix + "_isZero", x1)
        ))
      );
    }
    function buildSqrt2() {
      const f5 = module.addFunction(prefix + "_sqrt");
      f5.addParam("a", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const e34 = c3.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q5 || 0) - 3n) / 4n, f1n8)));
      const e12 = c3.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q5 || 0) - 1n) / 2n, f1n8)));
      const a4 = c3.getLocal("a");
      const a1 = c3.i32_const(module.alloc(f1n8 * 2));
      const alpha = c3.i32_const(module.alloc(f1n8 * 2));
      const a0 = c3.i32_const(module.alloc(f1n8 * 2));
      const pn1 = module.alloc(f1n8 * 2);
      const n1 = c3.i32_const(pn1);
      const n1a = c3.i32_const(pn1);
      const n1b = c3.i32_const(pn1 + f1n8);
      const x0 = c3.i32_const(module.alloc(f1n8 * 2));
      const b7 = c3.i32_const(module.alloc(f1n8 * 2));
      f5.addCode(
        c3.call(prefix + "_one", n1),
        c3.call(prefix + "_neg", n1, n1),
        c3.call(prefix + "_exp", a4, e34, c3.i32_const(f1n8), a1),
        c3.call(prefix + "_square", a1, alpha),
        c3.call(prefix + "_mul", a4, alpha, alpha),
        c3.call(prefix + "_conjugate", alpha, a0),
        c3.call(prefix + "_mul", a0, alpha, a0),
        c3.if(c3.call(prefix + "_eq", a0, n1), c3.unreachable()),
        c3.call(prefix + "_mul", a1, a4, x0),
        c3.if(
          c3.call(prefix + "_eq", alpha, n1),
          [
            ...c3.call(f1mPrefix + "_zero", n1a),
            ...c3.call(f1mPrefix + "_one", n1b),
            ...c3.call(prefix + "_mul", n1, x0, c3.getLocal("pr"))
          ],
          [
            ...c3.call(prefix + "_one", b7),
            ...c3.call(prefix + "_add", b7, alpha, b7),
            ...c3.call(prefix + "_exp", b7, e12, c3.i32_const(f1n8), b7),
            ...c3.call(prefix + "_mul", b7, x0, c3.getLocal("pr"))
          ]
        )
      );
    }
    function buildIsSquare() {
      const f5 = module.addFunction(prefix + "_isSquare");
      f5.addParam("a", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const e34 = c3.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q5 || 0) - 3n) / 4n, f1n8)));
      const a4 = c3.getLocal("a");
      const a1 = c3.i32_const(module.alloc(f1n8 * 2));
      const alpha = c3.i32_const(module.alloc(f1n8 * 2));
      const a0 = c3.i32_const(module.alloc(f1n8 * 2));
      const pn1 = module.alloc(f1n8 * 2);
      const n1 = c3.i32_const(pn1);
      f5.addCode(
        c3.call(prefix + "_one", n1),
        c3.call(prefix + "_neg", n1, n1),
        c3.call(prefix + "_exp", a4, e34, c3.i32_const(f1n8), a1),
        c3.call(prefix + "_square", a1, alpha),
        c3.call(prefix + "_mul", a4, alpha, alpha),
        c3.call(prefix + "_conjugate", alpha, a0),
        c3.call(prefix + "_mul", a0, alpha, a0),
        c3.if(
          c3.call(
            prefix + "_eq",
            a0,
            n1
          ),
          c3.ret(c3.i32_const(0))
        ),
        c3.ret(c3.i32_const(1))
      );
    }
    buildIsZero();
    buildIsOne();
    buildZero();
    buildOne();
    buildCopy();
    buildMul();
    buildMul1();
    buildSquare();
    buildAdd();
    buildSub();
    buildNeg();
    buildConjugate();
    buildToMontgomery();
    buildFromMontgomery();
    buildEq();
    buildInverse();
    buildTimesScalar2();
    buildSign();
    buildIsNegative();
    module.exportFunction(prefix + "_isZero");
    module.exportFunction(prefix + "_isOne");
    module.exportFunction(prefix + "_zero");
    module.exportFunction(prefix + "_one");
    module.exportFunction(prefix + "_copy");
    module.exportFunction(prefix + "_mul");
    module.exportFunction(prefix + "_mul1");
    module.exportFunction(prefix + "_square");
    module.exportFunction(prefix + "_add");
    module.exportFunction(prefix + "_sub");
    module.exportFunction(prefix + "_neg");
    module.exportFunction(prefix + "_sign");
    module.exportFunction(prefix + "_conjugate");
    module.exportFunction(prefix + "_fromMontgomery");
    module.exportFunction(prefix + "_toMontgomery");
    module.exportFunction(prefix + "_eq");
    module.exportFunction(prefix + "_inverse");
    buildBatchInverse$1(module, prefix);
    buildExp$1(
      module,
      prefix + "_exp",
      f1n8 * 2,
      prefix + "_mul",
      prefix + "_square",
      prefix + "_copy",
      prefix + "_one"
    );
    buildSqrt2();
    buildIsSquare();
    module.exportFunction(prefix + "_exp");
    module.exportFunction(prefix + "_timesScalar");
    module.exportFunction(prefix + "_batchInverse");
    module.exportFunction(prefix + "_sqrt");
    module.exportFunction(prefix + "_isSquare");
    module.exportFunction(prefix + "_isNegative");
    return prefix;
  };
  var buildExp = build_timesscalar;
  var buildBatchInverse = build_batchinverse;
  var build_f3m = function buildF3m(module, mulNonResidueFn, prefix, f1mPrefix) {
    if (module.modules[prefix])
      return prefix;
    const f1n8 = module.modules[f1mPrefix].n64 * 8;
    module.modules[prefix] = {
      n64: module.modules[f1mPrefix].n64 * 3
    };
    function buildAdd() {
      const f5 = module.addFunction(prefix + "_add");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const y22 = c3.i32_add(c3.getLocal("y"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_add", x0, y0, r0),
        c3.call(f1mPrefix + "_add", x1, y1, r1),
        c3.call(f1mPrefix + "_add", x22, y22, r2)
      );
    }
    function buildTimesScalar2() {
      const f5 = module.addFunction(prefix + "_timesScalar");
      f5.addParam("x", "i32");
      f5.addParam("scalar", "i32");
      f5.addParam("scalarLen", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_timesScalar", x0, c3.getLocal("scalar"), c3.getLocal("scalarLen"), r0),
        c3.call(f1mPrefix + "_timesScalar", x1, c3.getLocal("scalar"), c3.getLocal("scalarLen"), r1),
        c3.call(f1mPrefix + "_timesScalar", x22, c3.getLocal("scalar"), c3.getLocal("scalarLen"), r2)
      );
    }
    function buildSub() {
      const f5 = module.addFunction(prefix + "_sub");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const y22 = c3.i32_add(c3.getLocal("y"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_sub", x0, y0, r0),
        c3.call(f1mPrefix + "_sub", x1, y1, r1),
        c3.call(f1mPrefix + "_sub", x22, y22, r2)
      );
    }
    function buildNeg() {
      const f5 = module.addFunction(prefix + "_neg");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_neg", x0, r0),
        c3.call(f1mPrefix + "_neg", x1, r1),
        c3.call(f1mPrefix + "_neg", x22, r2)
      );
    }
    function buildIsNegative() {
      const f5 = module.addFunction(prefix + "_isNegative");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.if(
          c3.call(f1mPrefix + "_isZero", x22),
          c3.if(
            c3.call(f1mPrefix + "_isZero", x1),
            c3.ret(c3.call(f1mPrefix + "_isNegative", x0)),
            c3.ret(c3.call(f1mPrefix + "_isNegative", x1))
          )
        ),
        c3.ret(c3.call(f1mPrefix + "_isNegative", x22))
      );
    }
    function buildMul() {
      const f5 = module.addFunction(prefix + "_mul");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.addParam("r", "i32");
      const cd2 = f5.getCodeBuilder();
      const a4 = cd2.getLocal("x");
      const b7 = cd2.i32_add(cd2.getLocal("x"), cd2.i32_const(f1n8));
      const c3 = cd2.i32_add(cd2.getLocal("x"), cd2.i32_const(2 * f1n8));
      const A5 = cd2.getLocal("y");
      const B6 = cd2.i32_add(cd2.getLocal("y"), cd2.i32_const(f1n8));
      const C5 = cd2.i32_add(cd2.getLocal("y"), cd2.i32_const(2 * f1n8));
      const r0 = cd2.getLocal("r");
      const r1 = cd2.i32_add(cd2.getLocal("r"), cd2.i32_const(f1n8));
      const r2 = cd2.i32_add(cd2.getLocal("r"), cd2.i32_const(2 * f1n8));
      const aA = cd2.i32_const(module.alloc(f1n8));
      const bB = cd2.i32_const(module.alloc(f1n8));
      const cC = cd2.i32_const(module.alloc(f1n8));
      const a_b = cd2.i32_const(module.alloc(f1n8));
      const A_B = cd2.i32_const(module.alloc(f1n8));
      const a_c = cd2.i32_const(module.alloc(f1n8));
      const A_C = cd2.i32_const(module.alloc(f1n8));
      const b_c = cd2.i32_const(module.alloc(f1n8));
      const B_C = cd2.i32_const(module.alloc(f1n8));
      const aA_bB = cd2.i32_const(module.alloc(f1n8));
      const aA_cC = cd2.i32_const(module.alloc(f1n8));
      const bB_cC = cd2.i32_const(module.alloc(f1n8));
      const AUX = cd2.i32_const(module.alloc(f1n8));
      f5.addCode(
        cd2.call(f1mPrefix + "_mul", a4, A5, aA),
        cd2.call(f1mPrefix + "_mul", b7, B6, bB),
        cd2.call(f1mPrefix + "_mul", c3, C5, cC),
        cd2.call(f1mPrefix + "_add", a4, b7, a_b),
        cd2.call(f1mPrefix + "_add", A5, B6, A_B),
        cd2.call(f1mPrefix + "_add", a4, c3, a_c),
        cd2.call(f1mPrefix + "_add", A5, C5, A_C),
        cd2.call(f1mPrefix + "_add", b7, c3, b_c),
        cd2.call(f1mPrefix + "_add", B6, C5, B_C),
        cd2.call(f1mPrefix + "_add", aA, bB, aA_bB),
        cd2.call(f1mPrefix + "_add", aA, cC, aA_cC),
        cd2.call(f1mPrefix + "_add", bB, cC, bB_cC),
        cd2.call(f1mPrefix + "_mul", b_c, B_C, r0),
        cd2.call(f1mPrefix + "_sub", r0, bB_cC, r0),
        cd2.call(mulNonResidueFn, r0, r0),
        cd2.call(f1mPrefix + "_add", aA, r0, r0),
        cd2.call(f1mPrefix + "_mul", a_b, A_B, r1),
        cd2.call(f1mPrefix + "_sub", r1, aA_bB, r1),
        cd2.call(mulNonResidueFn, cC, AUX),
        cd2.call(f1mPrefix + "_add", r1, AUX, r1),
        cd2.call(f1mPrefix + "_mul", a_c, A_C, r2),
        cd2.call(f1mPrefix + "_sub", r2, aA_cC, r2),
        cd2.call(f1mPrefix + "_add", r2, bB, r2)
      );
    }
    function buildSquare() {
      const f5 = module.addFunction(prefix + "_square");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const A5 = c3.getLocal("x");
      const B6 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const C5 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      const s0 = c3.i32_const(module.alloc(f1n8));
      const ab = c3.i32_const(module.alloc(f1n8));
      const s1 = c3.i32_const(module.alloc(f1n8));
      const s22 = c3.i32_const(module.alloc(f1n8));
      const bc2 = c3.i32_const(module.alloc(f1n8));
      const s3 = c3.i32_const(module.alloc(f1n8));
      const s4 = c3.i32_const(module.alloc(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_square", A5, s0),
        c3.call(f1mPrefix + "_mul", A5, B6, ab),
        c3.call(f1mPrefix + "_add", ab, ab, s1),
        c3.call(f1mPrefix + "_sub", A5, B6, s22),
        c3.call(f1mPrefix + "_add", s22, C5, s22),
        c3.call(f1mPrefix + "_square", s22, s22),
        c3.call(f1mPrefix + "_mul", B6, C5, bc2),
        c3.call(f1mPrefix + "_add", bc2, bc2, s3),
        c3.call(f1mPrefix + "_square", C5, s4),
        c3.call(mulNonResidueFn, s3, r0),
        c3.call(f1mPrefix + "_add", s0, r0, r0),
        c3.call(mulNonResidueFn, s4, r1),
        c3.call(f1mPrefix + "_add", s1, r1, r1),
        c3.call(f1mPrefix + "_add", s0, s4, r2),
        c3.call(f1mPrefix + "_sub", s3, r2, r2),
        c3.call(f1mPrefix + "_add", s22, r2, r2),
        c3.call(f1mPrefix + "_add", s1, r2, r2)
      );
    }
    function buildToMontgomery() {
      const f5 = module.addFunction(prefix + "_toMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_toMontgomery", x0, r0),
        c3.call(f1mPrefix + "_toMontgomery", x1, r1),
        c3.call(f1mPrefix + "_toMontgomery", x22, r2)
      );
    }
    function buildFromMontgomery() {
      const f5 = module.addFunction(prefix + "_fromMontgomery");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_fromMontgomery", x0, r0),
        c3.call(f1mPrefix + "_fromMontgomery", x1, r1),
        c3.call(f1mPrefix + "_fromMontgomery", x22, r2)
      );
    }
    function buildCopy() {
      const f5 = module.addFunction(prefix + "_copy");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_copy", x0, r0),
        c3.call(f1mPrefix + "_copy", x1, r1),
        c3.call(f1mPrefix + "_copy", x22, r2)
      );
    }
    function buildZero() {
      const f5 = module.addFunction(prefix + "_zero");
      f5.addParam("x", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_zero", x0),
        c3.call(f1mPrefix + "_zero", x1),
        c3.call(f1mPrefix + "_zero", x22)
      );
    }
    function buildOne() {
      const f5 = module.addFunction(prefix + "_one");
      f5.addParam("x", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_one", x0),
        c3.call(f1mPrefix + "_zero", x1),
        c3.call(f1mPrefix + "_zero", x22)
      );
    }
    function buildEq() {
      const f5 = module.addFunction(prefix + "_eq");
      f5.addParam("x", "i32");
      f5.addParam("y", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const y0 = c3.getLocal("y");
      const y1 = c3.i32_add(c3.getLocal("y"), c3.i32_const(f1n8));
      const y22 = c3.i32_add(c3.getLocal("y"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.i32_and(
          c3.i32_and(
            c3.call(f1mPrefix + "_eq", x0, y0),
            c3.call(f1mPrefix + "_eq", x1, y1)
          ),
          c3.call(f1mPrefix + "_eq", x22, y22)
        )
      );
    }
    function buildIsZero() {
      const f5 = module.addFunction(prefix + "_isZero");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.i32_and(
          c3.i32_and(
            c3.call(f1mPrefix + "_isZero", x0),
            c3.call(f1mPrefix + "_isZero", x1)
          ),
          c3.call(f1mPrefix + "_isZero", x22)
        )
      );
    }
    function buildInverse() {
      const f5 = module.addFunction(prefix + "_inverse");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      const r0 = c3.getLocal("r");
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f1n8));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f1n8));
      const t0 = c3.i32_const(module.alloc(f1n8));
      const t1 = c3.i32_const(module.alloc(f1n8));
      const t2 = c3.i32_const(module.alloc(f1n8));
      const t3 = c3.i32_const(module.alloc(f1n8));
      const t4 = c3.i32_const(module.alloc(f1n8));
      const t5 = c3.i32_const(module.alloc(f1n8));
      const c0 = c3.i32_const(module.alloc(f1n8));
      const c1 = c3.i32_const(module.alloc(f1n8));
      const c22 = c3.i32_const(module.alloc(f1n8));
      const t6 = c3.i32_const(module.alloc(f1n8));
      const AUX = c3.i32_const(module.alloc(f1n8));
      f5.addCode(
        c3.call(f1mPrefix + "_square", x0, t0),
        c3.call(f1mPrefix + "_square", x1, t1),
        c3.call(f1mPrefix + "_square", x22, t2),
        c3.call(f1mPrefix + "_mul", x0, x1, t3),
        c3.call(f1mPrefix + "_mul", x0, x22, t4),
        c3.call(f1mPrefix + "_mul", x1, x22, t5),
        c3.call(mulNonResidueFn, t5, c0),
        c3.call(f1mPrefix + "_sub", t0, c0, c0),
        c3.call(mulNonResidueFn, t2, c1),
        c3.call(f1mPrefix + "_sub", c1, t3, c1),
        c3.call(f1mPrefix + "_sub", t1, t4, c22),
        c3.call(f1mPrefix + "_mul", x22, c1, t6),
        c3.call(f1mPrefix + "_mul", x1, c22, AUX),
        c3.call(f1mPrefix + "_add", t6, AUX, t6),
        c3.call(mulNonResidueFn, t6, t6),
        c3.call(f1mPrefix + "_mul", x0, c0, AUX),
        c3.call(f1mPrefix + "_add", AUX, t6, t6),
        c3.call(f1mPrefix + "_inverse", t6, t6),
        c3.call(f1mPrefix + "_mul", t6, c0, r0),
        c3.call(f1mPrefix + "_mul", t6, c1, r1),
        c3.call(f1mPrefix + "_mul", t6, c22, r2)
      );
    }
    function buildSign() {
      const f5 = module.addFunction(prefix + "_sign");
      f5.addParam("x", "i32");
      f5.addLocal("s", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f1n8));
      f5.addCode(
        c3.setLocal("s", c3.call(f1mPrefix + "_sign", x22)),
        c3.if(
          c3.getLocal("s"),
          c3.ret(c3.getLocal("s"))
        ),
        c3.setLocal("s", c3.call(f1mPrefix + "_sign", x1)),
        c3.if(
          c3.getLocal("s"),
          c3.ret(c3.getLocal("s"))
        ),
        c3.ret(c3.call(f1mPrefix + "_sign", x0))
      );
    }
    function buildIsOne() {
      const f5 = module.addFunction(prefix + "_isOne");
      f5.addParam("x", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1n8 * 2));
      f5.addCode(
        c3.ret(
          c3.i32_and(
            c3.i32_and(
              c3.call(f1mPrefix + "_isOne", x0),
              c3.call(f1mPrefix + "_isZero", x1)
            ),
            c3.call(f1mPrefix + "_isZero", x22)
          )
        )
      );
    }
    buildIsZero();
    buildIsOne();
    buildZero();
    buildOne();
    buildCopy();
    buildMul();
    buildSquare();
    buildAdd();
    buildSub();
    buildNeg();
    buildSign();
    buildToMontgomery();
    buildFromMontgomery();
    buildEq();
    buildInverse();
    buildTimesScalar2();
    buildIsNegative();
    module.exportFunction(prefix + "_isZero");
    module.exportFunction(prefix + "_isOne");
    module.exportFunction(prefix + "_zero");
    module.exportFunction(prefix + "_one");
    module.exportFunction(prefix + "_copy");
    module.exportFunction(prefix + "_mul");
    module.exportFunction(prefix + "_square");
    module.exportFunction(prefix + "_add");
    module.exportFunction(prefix + "_sub");
    module.exportFunction(prefix + "_neg");
    module.exportFunction(prefix + "_sign");
    module.exportFunction(prefix + "_fromMontgomery");
    module.exportFunction(prefix + "_toMontgomery");
    module.exportFunction(prefix + "_eq");
    module.exportFunction(prefix + "_inverse");
    buildBatchInverse(module, prefix);
    buildExp(
      module,
      prefix + "_exp",
      f1n8 * 3,
      prefix + "_mul",
      prefix + "_square",
      prefix + "_copy",
      prefix + "_one"
    );
    module.exportFunction(prefix + "_exp");
    module.exportFunction(prefix + "_timesScalar");
    module.exportFunction(prefix + "_batchInverse");
    module.exportFunction(prefix + "_isNegative");
    return prefix;
  };
  var build_timesscalarnaf = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
    const f5 = module.addFunction(fnName);
    f5.addParam("base", "i32");
    f5.addParam("scalar", "i32");
    f5.addParam("scalarLength", "i32");
    f5.addParam("r", "i32");
    f5.addLocal("old0", "i32");
    f5.addLocal("nbits", "i32");
    f5.addLocal("i", "i32");
    f5.addLocal("last", "i32");
    f5.addLocal("cur", "i32");
    f5.addLocal("carry", "i32");
    f5.addLocal("p", "i32");
    const c3 = f5.getCodeBuilder();
    const aux = c3.i32_const(module.alloc(elementLen));
    function getBit(IDX) {
      return c3.i32_and(
        c3.i32_shr_u(
          c3.i32_load(
            c3.i32_add(
              c3.getLocal("scalar"),
              c3.i32_and(
                c3.i32_shr_u(
                  IDX,
                  c3.i32_const(3)
                ),
                c3.i32_const(4294967292)
              )
            )
          ),
          c3.i32_and(
            IDX,
            c3.i32_const(31)
          )
        ),
        c3.i32_const(1)
      );
    }
    function pushBit(b7) {
      return [
        ...c3.i32_store8(
          c3.getLocal("p"),
          c3.i32_const(b7)
        ),
        ...c3.setLocal(
          "p",
          c3.i32_add(
            c3.getLocal("p"),
            c3.i32_const(1)
          )
        )
      ];
    }
    f5.addCode(
      c3.if(
        c3.i32_eqz(c3.getLocal("scalarLength")),
        [
          ...c3.call(opInit, c3.getLocal("r")),
          ...c3.ret([])
        ]
      ),
      c3.setLocal("nbits", c3.i32_shl(c3.getLocal("scalarLength"), c3.i32_const(3))),
      c3.setLocal("old0", c3.i32_load(c3.i32_const(0))),
      c3.setLocal("p", c3.getLocal("old0")),
      c3.i32_store(
        c3.i32_const(0),
        c3.i32_and(
          c3.i32_add(
            c3.i32_add(
              c3.getLocal("old0"),
              c3.i32_const(32)
            ),
            c3.getLocal("nbits")
          ),
          c3.i32_const(4294967288)
        )
      ),
      c3.setLocal("i", c3.i32_const(1)),
      c3.setLocal("last", getBit(c3.i32_const(0))),
      c3.setLocal("carry", c3.i32_const(0)),
      c3.block(c3.loop(
        c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("nbits"))),
        c3.setLocal("cur", getBit(c3.getLocal("i"))),
        c3.if(
          c3.getLocal("last"),
          c3.if(
            c3.getLocal("cur"),
            c3.if(
              c3.getLocal("carry"),
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(1)),
                ...pushBit(1)
              ],
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(1)),
                ...pushBit(255)
              ]
            ),
            c3.if(
              c3.getLocal("carry"),
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(1)),
                ...pushBit(255)
              ],
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(0)),
                ...pushBit(1)
              ]
            )
          ),
          c3.if(
            c3.getLocal("cur"),
            c3.if(
              c3.getLocal("carry"),
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(1)),
                ...pushBit(0)
              ],
              [
                ...c3.setLocal("last", c3.i32_const(1)),
                ...c3.setLocal("carry", c3.i32_const(0)),
                ...pushBit(0)
              ]
            ),
            c3.if(
              c3.getLocal("carry"),
              [
                ...c3.setLocal("last", c3.i32_const(1)),
                ...c3.setLocal("carry", c3.i32_const(0)),
                ...pushBit(0)
              ],
              [
                ...c3.setLocal("last", c3.i32_const(0)),
                ...c3.setLocal("carry", c3.i32_const(0)),
                ...pushBit(0)
              ]
            )
          )
        ),
        c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
        c3.br(0)
      )),
      c3.if(
        c3.getLocal("last"),
        c3.if(
          c3.getLocal("carry"),
          [
            ...pushBit(255),
            ...pushBit(0),
            ...pushBit(1)
          ],
          [
            ...pushBit(1)
          ]
        ),
        c3.if(
          c3.getLocal("carry"),
          [
            ...pushBit(0),
            ...pushBit(1)
          ]
        )
      ),
      c3.setLocal("p", c3.i32_sub(c3.getLocal("p"), c3.i32_const(1))),
      c3.call(opCopy, c3.getLocal("base"), aux),
      c3.call(opInit, c3.getLocal("r")),
      c3.block(c3.loop(
        c3.call(opAA, c3.getLocal("r"), c3.getLocal("r")),
        c3.setLocal(
          "cur",
          c3.i32_load8_u(
            c3.getLocal("p")
          )
        ),
        c3.if(
          c3.getLocal("cur"),
          c3.if(
            c3.i32_eq(c3.getLocal("cur"), c3.i32_const(1)),
            c3.call(opAB, c3.getLocal("r"), aux, c3.getLocal("r")),
            c3.call(opAmB, c3.getLocal("r"), aux, c3.getLocal("r"))
          )
        ),
        c3.br_if(1, c3.i32_eq(c3.getLocal("old0"), c3.getLocal("p"))),
        c3.setLocal("p", c3.i32_sub(c3.getLocal("p"), c3.i32_const(1))),
        c3.br(0)
      )),
      c3.i32_store(c3.i32_const(0), c3.getLocal("old0"))
    );
  };
  var build_multiexp = function buildMultiexp(module, prefix, fnName, opAdd, n8b) {
    const n64g = module.modules[prefix].n64;
    const n8g = n64g * 8;
    function buildGetChunk() {
      const f5 = module.addFunction(fnName + "_getChunk");
      f5.addParam("pScalar", "i32");
      f5.addParam("scalarSize", "i32");
      f5.addParam("startBit", "i32");
      f5.addParam("chunkSize", "i32");
      f5.addLocal("bitsToEnd", "i32");
      f5.addLocal("mask", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal(
          "bitsToEnd",
          c3.i32_sub(
            c3.i32_mul(
              c3.getLocal("scalarSize"),
              c3.i32_const(8)
            ),
            c3.getLocal("startBit")
          )
        ),
        c3.if(
          c3.i32_gt_s(
            c3.getLocal("chunkSize"),
            c3.getLocal("bitsToEnd")
          ),
          c3.setLocal(
            "mask",
            c3.i32_sub(
              c3.i32_shl(
                c3.i32_const(1),
                c3.getLocal("bitsToEnd")
              ),
              c3.i32_const(1)
            )
          ),
          c3.setLocal(
            "mask",
            c3.i32_sub(
              c3.i32_shl(
                c3.i32_const(1),
                c3.getLocal("chunkSize")
              ),
              c3.i32_const(1)
            )
          )
        ),
        c3.i32_and(
          c3.i32_shr_u(
            c3.i32_load(
              c3.i32_add(
                c3.getLocal("pScalar"),
                c3.i32_shr_u(
                  c3.getLocal("startBit"),
                  c3.i32_const(3)
                )
              ),
              0,
              0
            ),
            c3.i32_and(
              c3.getLocal("startBit"),
              c3.i32_const(7)
            )
          ),
          c3.getLocal("mask")
        )
      );
    }
    function buildMutiexpChunk() {
      const f5 = module.addFunction(fnName + "_chunk");
      f5.addParam("pBases", "i32");
      f5.addParam("pScalars", "i32");
      f5.addParam("scalarSize", "i32");
      f5.addParam("n", "i32");
      f5.addParam("startBit", "i32");
      f5.addParam("chunkSize", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("nChunks", "i32");
      f5.addLocal("itScalar", "i32");
      f5.addLocal("endScalar", "i32");
      f5.addLocal("itBase", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      f5.addLocal("nTable", "i32");
      f5.addLocal("pTable", "i32");
      f5.addLocal("idx", "i32");
      f5.addLocal("pIdxTable", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.if(
          c3.i32_eqz(c3.getLocal("n")),
          [
            ...c3.call(prefix + "_zero", c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.setLocal(
          "nTable",
          c3.i32_shl(
            c3.i32_const(1),
            c3.getLocal("chunkSize")
          )
        ),
        c3.setLocal("pTable", c3.i32_load(c3.i32_const(0))),
        c3.i32_store(
          c3.i32_const(0),
          c3.i32_add(
            c3.getLocal("pTable"),
            c3.i32_mul(
              c3.getLocal("nTable"),
              c3.i32_const(n8g)
            )
          )
        ),
        c3.setLocal("j", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("j"),
              c3.getLocal("nTable")
            )
          ),
          c3.call(
            prefix + "_zero",
            c3.i32_add(
              c3.getLocal("pTable"),
              c3.i32_mul(
                c3.getLocal("j"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.setLocal("itBase", c3.getLocal("pBases")),
        c3.setLocal("itScalar", c3.getLocal("pScalars")),
        c3.setLocal(
          "endScalar",
          c3.i32_add(
            c3.getLocal("pScalars"),
            c3.i32_mul(
              c3.getLocal("n"),
              c3.getLocal("scalarSize")
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("itScalar"),
              c3.getLocal("endScalar")
            )
          ),
          c3.setLocal(
            "idx",
            c3.call(
              fnName + "_getChunk",
              c3.getLocal("itScalar"),
              c3.getLocal("scalarSize"),
              c3.getLocal("startBit"),
              c3.getLocal("chunkSize")
            )
          ),
          c3.if(
            c3.getLocal("idx"),
            [
              ...c3.setLocal(
                "pIdxTable",
                c3.i32_add(
                  c3.getLocal("pTable"),
                  c3.i32_mul(
                    c3.i32_sub(
                      c3.getLocal("idx"),
                      c3.i32_const(1)
                    ),
                    c3.i32_const(n8g)
                  )
                )
              ),
              ...c3.call(
                opAdd,
                c3.getLocal("pIdxTable"),
                c3.getLocal("itBase"),
                c3.getLocal("pIdxTable")
              )
            ]
          ),
          c3.setLocal("itScalar", c3.i32_add(c3.getLocal("itScalar"), c3.getLocal("scalarSize"))),
          c3.setLocal("itBase", c3.i32_add(c3.getLocal("itBase"), c3.i32_const(n8b))),
          c3.br(0)
        )),
        c3.call(fnName + "_reduceTable", c3.getLocal("pTable"), c3.getLocal("chunkSize")),
        c3.call(
          prefix + "_copy",
          c3.getLocal("pTable"),
          c3.getLocal("pr")
        ),
        c3.i32_store(
          c3.i32_const(0),
          c3.getLocal("pTable")
        )
      );
    }
    function buildMultiexp3() {
      const f5 = module.addFunction(fnName);
      f5.addParam("pBases", "i32");
      f5.addParam("pScalars", "i32");
      f5.addParam("scalarSize", "i32");
      f5.addParam("n", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("chunkSize", "i32");
      f5.addLocal("nChunks", "i32");
      f5.addLocal("itScalar", "i32");
      f5.addLocal("endScalar", "i32");
      f5.addLocal("itBase", "i32");
      f5.addLocal("itBit", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      f5.addLocal("nTable", "i32");
      f5.addLocal("pTable", "i32");
      f5.addLocal("idx", "i32");
      f5.addLocal("pIdxTable", "i32");
      const c3 = f5.getCodeBuilder();
      const aux = c3.i32_const(module.alloc(n8g));
      const pTSizes2 = module.alloc([
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        16,
        16,
        15,
        14,
        13,
        13,
        12,
        11,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        4,
        3,
        2,
        1,
        1,
        1,
        1
      ]);
      f5.addCode(
        c3.call(prefix + "_zero", c3.getLocal("pr")),
        c3.if(
          c3.i32_eqz(c3.getLocal("n")),
          c3.ret([])
        ),
        c3.setLocal("chunkSize", c3.i32_load8_u(c3.i32_clz(c3.getLocal("n")), pTSizes2)),
        c3.setLocal(
          "nChunks",
          c3.i32_add(
            c3.i32_div_u(
              c3.i32_sub(
                c3.i32_shl(
                  c3.getLocal("scalarSize"),
                  c3.i32_const(3)
                ),
                c3.i32_const(1)
              ),
              c3.getLocal("chunkSize")
            ),
            c3.i32_const(1)
          )
        ),
        c3.setLocal(
          "itBit",
          c3.i32_mul(
            c3.i32_sub(
              c3.getLocal("nChunks"),
              c3.i32_const(1)
            ),
            c3.getLocal("chunkSize")
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_lt_s(
              c3.getLocal("itBit"),
              c3.i32_const(0)
            )
          ),
          c3.if(
            c3.i32_eqz(c3.call(prefix + "_isZero", c3.getLocal("pr"))),
            [
              ...c3.setLocal("j", c3.i32_const(0)),
              ...c3.block(c3.loop(
                c3.br_if(
                  1,
                  c3.i32_eq(
                    c3.getLocal("j"),
                    c3.getLocal("chunkSize")
                  )
                ),
                c3.call(prefix + "_double", c3.getLocal("pr"), c3.getLocal("pr")),
                c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
                c3.br(0)
              ))
            ]
          ),
          c3.call(
            fnName + "_chunk",
            c3.getLocal("pBases"),
            c3.getLocal("pScalars"),
            c3.getLocal("scalarSize"),
            c3.getLocal("n"),
            c3.getLocal("itBit"),
            c3.getLocal("chunkSize"),
            aux
          ),
          c3.call(
            prefix + "_add",
            c3.getLocal("pr"),
            aux,
            c3.getLocal("pr")
          ),
          c3.setLocal("itBit", c3.i32_sub(c3.getLocal("itBit"), c3.getLocal("chunkSize"))),
          c3.br(0)
        ))
      );
    }
    function buildReduceTable() {
      const f5 = module.addFunction(fnName + "_reduceTable");
      f5.addParam("pTable", "i32");
      f5.addParam("p", "i32");
      f5.addLocal("half", "i32");
      f5.addLocal("it1", "i32");
      f5.addLocal("it2", "i32");
      f5.addLocal("pAcc", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.if(
          c3.i32_eq(c3.getLocal("p"), c3.i32_const(1)),
          c3.ret([])
        ),
        c3.setLocal(
          "half",
          c3.i32_shl(
            c3.i32_const(1),
            c3.i32_sub(
              c3.getLocal("p"),
              c3.i32_const(1)
            )
          )
        ),
        c3.setLocal("it1", c3.getLocal("pTable")),
        c3.setLocal(
          "it2",
          c3.i32_add(
            c3.getLocal("pTable"),
            c3.i32_mul(
              c3.getLocal("half"),
              c3.i32_const(n8g)
            )
          )
        ),
        c3.setLocal(
          "pAcc",
          c3.i32_sub(
            c3.getLocal("it2"),
            c3.i32_const(n8g)
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("it1"),
              c3.getLocal("pAcc")
            )
          ),
          c3.call(
            prefix + "_add",
            c3.getLocal("it1"),
            c3.getLocal("it2"),
            c3.getLocal("it1")
          ),
          c3.call(
            prefix + "_add",
            c3.getLocal("pAcc"),
            c3.getLocal("it2"),
            c3.getLocal("pAcc")
          ),
          c3.setLocal("it1", c3.i32_add(c3.getLocal("it1"), c3.i32_const(n8g))),
          c3.setLocal("it2", c3.i32_add(c3.getLocal("it2"), c3.i32_const(n8g))),
          c3.br(0)
        )),
        c3.call(
          fnName + "_reduceTable",
          c3.getLocal("pTable"),
          c3.i32_sub(
            c3.getLocal("p"),
            c3.i32_const(1)
          )
        ),
        c3.setLocal("p", c3.i32_sub(c3.getLocal("p"), c3.i32_const(1))),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eqz(c3.getLocal("p"))),
          c3.call(prefix + "_double", c3.getLocal("pAcc"), c3.getLocal("pAcc")),
          c3.setLocal("p", c3.i32_sub(c3.getLocal("p"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.call(prefix + "_add", c3.getLocal("pTable"), c3.getLocal("pAcc"), c3.getLocal("pTable"))
      );
    }
    buildGetChunk();
    buildReduceTable();
    buildMutiexpChunk();
    buildMultiexp3();
    module.exportFunction(fnName);
    module.exportFunction(fnName + "_chunk");
  };
  var buildTimesScalarNAF2 = build_timesscalarnaf;
  var buildBatchConvertion = build_batchconvertion;
  var buildMultiexp$1 = build_multiexp;
  var build_curve_jacobian_a0 = function buildCurve(module, prefix, prefixField, pB) {
    const n64 = module.modules[prefixField].n64;
    const n8 = n64 * 8;
    if (module.modules[prefix])
      return prefix;
    module.modules[prefix] = {
      n64: n64 * 3
    };
    function buildIsZero() {
      const f5 = module.addFunction(prefix + "_isZero");
      f5.addParam("p1", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_isZero",
        c3.i32_add(
          c3.getLocal("p1"),
          c3.i32_const(n8 * 2)
        )
      ));
    }
    function buildIsZeroAffine() {
      const f5 = module.addFunction(prefix + "_isZeroAffine");
      f5.addParam("p1", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.i32_and(
          c3.call(
            prefixField + "_isZero",
            c3.getLocal("p1")
          ),
          c3.call(
            prefixField + "_isZero",
            c3.i32_add(
              c3.getLocal("p1"),
              c3.i32_const(n8)
            )
          )
        )
      );
    }
    function buildCopy() {
      const f5 = module.addFunction(prefix + "_copy");
      f5.addParam("ps", "i32");
      f5.addParam("pd", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < n64 * 3; i4++) {
        f5.addCode(
          c3.i64_store(
            c3.getLocal("pd"),
            i4 * 8,
            c3.i64_load(
              c3.getLocal("ps"),
              i4 * 8
            )
          )
        );
      }
    }
    function buildCopyAffine() {
      const f5 = module.addFunction(prefix + "_copyAffine");
      f5.addParam("ps", "i32");
      f5.addParam("pd", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < n64 * 2; i4++) {
        f5.addCode(
          c3.i64_store(
            c3.getLocal("pd"),
            i4 * 8,
            c3.i64_load(
              c3.getLocal("ps"),
              i4 * 8
            )
          )
        );
      }
    }
    function buildZero() {
      const f5 = module.addFunction(prefix + "_zero");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_zero",
        c3.getLocal("pr")
      ));
      f5.addCode(c3.call(
        prefixField + "_one",
        c3.i32_add(
          c3.getLocal("pr"),
          c3.i32_const(n8)
        )
      ));
      f5.addCode(c3.call(
        prefixField + "_zero",
        c3.i32_add(
          c3.getLocal("pr"),
          c3.i32_const(n8 * 2)
        )
      ));
    }
    function buildZeroAffine() {
      const f5 = module.addFunction(prefix + "_zeroAffine");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_zero",
        c3.getLocal("pr")
      ));
      f5.addCode(c3.call(
        prefixField + "_zero",
        c3.i32_add(
          c3.getLocal("pr"),
          c3.i32_const(n8)
        )
      ));
    }
    function buildEq() {
      const f5 = module.addFunction(prefix + "_eq");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.setReturnType("i32");
      f5.addLocal("z1", "i32");
      f5.addLocal("z2", "i32");
      const c3 = f5.getCodeBuilder();
      const x1 = c3.getLocal("p1");
      const y1 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z1", c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2))));
      const z1 = c3.getLocal("z1");
      const x22 = c3.getLocal("p2");
      const y22 = c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z2", c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8 * 2))));
      const z22 = c3.getLocal("z2");
      const Z1Z1 = c3.i32_const(module.alloc(n8));
      const Z2Z2 = c3.i32_const(module.alloc(n8));
      const U1 = c3.i32_const(module.alloc(n8));
      const U22 = c3.i32_const(module.alloc(n8));
      const Z1_cubed = c3.i32_const(module.alloc(n8));
      const Z2_cubed = c3.i32_const(module.alloc(n8));
      const S12 = c3.i32_const(module.alloc(n8));
      const S22 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          c3.ret(c3.call(prefix + "_isZero", c3.getLocal("p2")))
        ),
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p2")),
          c3.ret(c3.i32_const(0))
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z1),
          c3.ret(c3.call(prefix + "_eqMixed", c3.getLocal("p2"), c3.getLocal("p1")))
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z22),
          c3.ret(c3.call(prefix + "_eqMixed", c3.getLocal("p1"), c3.getLocal("p2")))
        ),
        c3.call(prefixField + "_square", z1, Z1Z1),
        c3.call(prefixField + "_square", z22, Z2Z2),
        c3.call(prefixField + "_mul", x1, Z2Z2, U1),
        c3.call(prefixField + "_mul", x22, Z1Z1, U22),
        c3.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
        c3.call(prefixField + "_mul", z22, Z2Z2, Z2_cubed),
        c3.call(prefixField + "_mul", y1, Z2_cubed, S12),
        c3.call(prefixField + "_mul", y22, Z1_cubed, S22),
        c3.if(
          c3.call(prefixField + "_eq", U1, U22),
          c3.if(
            c3.call(prefixField + "_eq", S12, S22),
            c3.ret(c3.i32_const(1))
          )
        ),
        c3.ret(c3.i32_const(0))
      );
    }
    function buildEqMixed() {
      const f5 = module.addFunction(prefix + "_eqMixed");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.setReturnType("i32");
      f5.addLocal("z1", "i32");
      const c3 = f5.getCodeBuilder();
      const x1 = c3.getLocal("p1");
      const y1 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z1", c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2))));
      const z1 = c3.getLocal("z1");
      const x22 = c3.getLocal("p2");
      const y22 = c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8));
      const Z1Z1 = c3.i32_const(module.alloc(n8));
      const U22 = c3.i32_const(module.alloc(n8));
      const Z1_cubed = c3.i32_const(module.alloc(n8));
      const S22 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          c3.ret(c3.call(prefix + "_isZeroAffine", c3.getLocal("p2")))
        ),
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p2")),
          c3.ret(c3.i32_const(0))
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z1),
          c3.ret(c3.call(prefix + "_eqAffine", c3.getLocal("p1"), c3.getLocal("p2")))
        ),
        c3.call(prefixField + "_square", z1, Z1Z1),
        c3.call(prefixField + "_mul", x22, Z1Z1, U22),
        c3.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
        c3.call(prefixField + "_mul", y22, Z1_cubed, S22),
        c3.if(
          c3.call(prefixField + "_eq", x1, U22),
          c3.if(
            c3.call(prefixField + "_eq", y1, S22),
            c3.ret(c3.i32_const(1))
          )
        ),
        c3.ret(c3.i32_const(0))
      );
    }
    function buildDouble() {
      const f5 = module.addFunction(prefix + "_double");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const z6 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const A5 = c3.i32_const(module.alloc(n8));
      const B6 = c3.i32_const(module.alloc(n8));
      const C5 = c3.i32_const(module.alloc(n8));
      const D4 = c3.i32_const(module.alloc(n8));
      const E4 = c3.i32_const(module.alloc(n8));
      const F4 = c3.i32_const(module.alloc(n8));
      const G7 = c3.i32_const(module.alloc(n8));
      const eightC = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          [
            ...c3.call(prefix + "_copy", c3.getLocal("p1"), c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z6),
          [
            ...c3.ret(c3.call(prefix + "_doubleAffine", c3.getLocal("p1"), c3.getLocal("pr"))),
            ...c3.ret([])
          ]
        ),
        c3.call(prefixField + "_square", x6, A5),
        c3.call(prefixField + "_square", y5, B6),
        c3.call(prefixField + "_square", B6, C5),
        c3.call(prefixField + "_add", x6, B6, D4),
        c3.call(prefixField + "_square", D4, D4),
        c3.call(prefixField + "_sub", D4, A5, D4),
        c3.call(prefixField + "_sub", D4, C5, D4),
        c3.call(prefixField + "_add", D4, D4, D4),
        c3.call(prefixField + "_add", A5, A5, E4),
        c3.call(prefixField + "_add", E4, A5, E4),
        c3.call(prefixField + "_square", E4, F4),
        c3.call(prefixField + "_mul", y5, z6, G7),
        c3.call(prefixField + "_add", D4, D4, x32),
        c3.call(prefixField + "_sub", F4, x32, x32),
        c3.call(prefixField + "_add", C5, C5, eightC),
        c3.call(prefixField + "_add", eightC, eightC, eightC),
        c3.call(prefixField + "_add", eightC, eightC, eightC),
        c3.call(prefixField + "_sub", D4, x32, y32),
        c3.call(prefixField + "_mul", y32, E4, y32),
        c3.call(prefixField + "_sub", y32, eightC, y32),
        c3.call(prefixField + "_add", G7, G7, z32)
      );
    }
    function buildDoubleAffine() {
      const f5 = module.addFunction(prefix + "_doubleAffine");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const XX = c3.i32_const(module.alloc(n8));
      const YY = c3.i32_const(module.alloc(n8));
      const YYYY = c3.i32_const(module.alloc(n8));
      const S6 = c3.i32_const(module.alloc(n8));
      const M6 = c3.i32_const(module.alloc(n8));
      const eightYYYY = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p1")),
          [
            ...c3.call(prefix + "_toJacobian", c3.getLocal("p1"), c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.call(prefixField + "_square", x6, XX),
        c3.call(prefixField + "_square", y5, YY),
        c3.call(prefixField + "_square", YY, YYYY),
        c3.call(prefixField + "_add", x6, YY, S6),
        c3.call(prefixField + "_square", S6, S6),
        c3.call(prefixField + "_sub", S6, XX, S6),
        c3.call(prefixField + "_sub", S6, YYYY, S6),
        c3.call(prefixField + "_add", S6, S6, S6),
        c3.call(prefixField + "_add", XX, XX, M6),
        c3.call(prefixField + "_add", M6, XX, M6),
        c3.call(prefixField + "_add", y5, y5, z32),
        c3.call(prefixField + "_square", M6, x32),
        c3.call(prefixField + "_sub", x32, S6, x32),
        c3.call(prefixField + "_sub", x32, S6, x32),
        c3.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
        c3.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
        c3.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
        c3.call(prefixField + "_sub", S6, x32, y32),
        c3.call(prefixField + "_mul", y32, M6, y32),
        c3.call(prefixField + "_sub", y32, eightYYYY, y32)
      );
    }
    function buildEqAffine() {
      const f5 = module.addFunction(prefix + "_eqAffine");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.setReturnType("i32");
      f5.addLocal("z1", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.ret(c3.i32_and(
          c3.call(
            prefixField + "_eq",
            c3.getLocal("p1"),
            c3.getLocal("p2")
          ),
          c3.call(
            prefixField + "_eq",
            c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8)),
            c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8))
          )
        ))
      );
    }
    function buildToMontgomery() {
      const f5 = module.addFunction(prefix + "_toMontgomery");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_toMontgomery",
        c3.getLocal("p1"),
        c3.getLocal("pr")
      ));
      for (let i4 = 1; i4 < 3; i4++) {
        f5.addCode(c3.call(
          prefixField + "_toMontgomery",
          c3.i32_add(c3.getLocal("p1"), c3.i32_const(i4 * n8)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(i4 * n8))
        ));
      }
    }
    function buildToMontgomeryAffine() {
      const f5 = module.addFunction(prefix + "_toMontgomeryAffine");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_toMontgomery",
        c3.getLocal("p1"),
        c3.getLocal("pr")
      ));
      for (let i4 = 1; i4 < 2; i4++) {
        f5.addCode(c3.call(
          prefixField + "_toMontgomery",
          c3.i32_add(c3.getLocal("p1"), c3.i32_const(i4 * n8)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(i4 * n8))
        ));
      }
    }
    function buildFromMontgomery() {
      const f5 = module.addFunction(prefix + "_fromMontgomery");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_fromMontgomery",
        c3.getLocal("p1"),
        c3.getLocal("pr")
      ));
      for (let i4 = 1; i4 < 3; i4++) {
        f5.addCode(c3.call(
          prefixField + "_fromMontgomery",
          c3.i32_add(c3.getLocal("p1"), c3.i32_const(i4 * n8)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(i4 * n8))
        ));
      }
    }
    function buildFromMontgomeryAffine() {
      const f5 = module.addFunction(prefix + "_fromMontgomeryAffine");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(c3.call(
        prefixField + "_fromMontgomery",
        c3.getLocal("p1"),
        c3.getLocal("pr")
      ));
      for (let i4 = 1; i4 < 2; i4++) {
        f5.addCode(c3.call(
          prefixField + "_fromMontgomery",
          c3.i32_add(c3.getLocal("p1"), c3.i32_const(i4 * n8)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(i4 * n8))
        ));
      }
    }
    function buildAdd() {
      const f5 = module.addFunction(prefix + "_add");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("z1", "i32");
      f5.addLocal("z2", "i32");
      const c3 = f5.getCodeBuilder();
      const x1 = c3.getLocal("p1");
      const y1 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z1", c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2))));
      const z1 = c3.getLocal("z1");
      const x22 = c3.getLocal("p2");
      const y22 = c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z2", c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8 * 2))));
      const z22 = c3.getLocal("z2");
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const Z1Z1 = c3.i32_const(module.alloc(n8));
      const Z2Z2 = c3.i32_const(module.alloc(n8));
      const U1 = c3.i32_const(module.alloc(n8));
      const U22 = c3.i32_const(module.alloc(n8));
      const Z1_cubed = c3.i32_const(module.alloc(n8));
      const Z2_cubed = c3.i32_const(module.alloc(n8));
      const S12 = c3.i32_const(module.alloc(n8));
      const S22 = c3.i32_const(module.alloc(n8));
      const H4 = c3.i32_const(module.alloc(n8));
      const S2_minus_S1 = c3.i32_const(module.alloc(n8));
      const I5 = c3.i32_const(module.alloc(n8));
      const J4 = c3.i32_const(module.alloc(n8));
      const r = c3.i32_const(module.alloc(n8));
      const r2 = c3.i32_const(module.alloc(n8));
      const V5 = c3.i32_const(module.alloc(n8));
      const V22 = c3.i32_const(module.alloc(n8));
      const S1_J2 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          [
            ...c3.call(prefix + "_copy", c3.getLocal("p2"), c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p2")),
          [
            ...c3.call(prefix + "_copy", c3.getLocal("p1"), c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z1),
          [
            ...c3.call(prefix + "_addMixed", x22, x1, x32),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z22),
          [
            ...c3.call(prefix + "_addMixed", x1, x22, x32),
            ...c3.ret([])
          ]
        ),
        c3.call(prefixField + "_square", z1, Z1Z1),
        c3.call(prefixField + "_square", z22, Z2Z2),
        c3.call(prefixField + "_mul", x1, Z2Z2, U1),
        c3.call(prefixField + "_mul", x22, Z1Z1, U22),
        c3.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
        c3.call(prefixField + "_mul", z22, Z2Z2, Z2_cubed),
        c3.call(prefixField + "_mul", y1, Z2_cubed, S12),
        c3.call(prefixField + "_mul", y22, Z1_cubed, S22),
        c3.if(
          c3.call(prefixField + "_eq", U1, U22),
          c3.if(
            c3.call(prefixField + "_eq", S12, S22),
            [
              ...c3.call(prefix + "_double", c3.getLocal("p1"), c3.getLocal("pr")),
              ...c3.ret([])
            ]
          )
        ),
        c3.call(prefixField + "_sub", U22, U1, H4),
        c3.call(prefixField + "_sub", S22, S12, S2_minus_S1),
        c3.call(prefixField + "_add", H4, H4, I5),
        c3.call(prefixField + "_square", I5, I5),
        c3.call(prefixField + "_mul", H4, I5, J4),
        c3.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r),
        c3.call(prefixField + "_mul", U1, I5, V5),
        c3.call(prefixField + "_square", r, r2),
        c3.call(prefixField + "_add", V5, V5, V22),
        c3.call(prefixField + "_sub", r2, J4, x32),
        c3.call(prefixField + "_sub", x32, V22, x32),
        c3.call(prefixField + "_mul", S12, J4, S1_J2),
        c3.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
        c3.call(prefixField + "_sub", V5, x32, y32),
        c3.call(prefixField + "_mul", y32, r, y32),
        c3.call(prefixField + "_sub", y32, S1_J2, y32),
        c3.call(prefixField + "_add", z1, z22, z32),
        c3.call(prefixField + "_square", z32, z32),
        c3.call(prefixField + "_sub", z32, Z1Z1, z32),
        c3.call(prefixField + "_sub", z32, Z2Z2, z32),
        c3.call(prefixField + "_mul", z32, H4, z32)
      );
    }
    function buildAddMixed() {
      const f5 = module.addFunction(prefix + "_addMixed");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("z1", "i32");
      const c3 = f5.getCodeBuilder();
      const x1 = c3.getLocal("p1");
      const y1 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z1", c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2))));
      const z1 = c3.getLocal("z1");
      const x22 = c3.getLocal("p2");
      const y22 = c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const Z1Z1 = c3.i32_const(module.alloc(n8));
      const U22 = c3.i32_const(module.alloc(n8));
      const Z1_cubed = c3.i32_const(module.alloc(n8));
      const S22 = c3.i32_const(module.alloc(n8));
      const H4 = c3.i32_const(module.alloc(n8));
      const HH = c3.i32_const(module.alloc(n8));
      const S2_minus_y1 = c3.i32_const(module.alloc(n8));
      const I5 = c3.i32_const(module.alloc(n8));
      const J4 = c3.i32_const(module.alloc(n8));
      const r = c3.i32_const(module.alloc(n8));
      const r2 = c3.i32_const(module.alloc(n8));
      const V5 = c3.i32_const(module.alloc(n8));
      const V22 = c3.i32_const(module.alloc(n8));
      const y1_J2 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          [
            ...c3.call(prefix + "_copyAffine", c3.getLocal("p2"), c3.getLocal("pr")),
            ...c3.call(prefixField + "_one", c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2))),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p2")),
          [
            ...c3.call(prefix + "_copy", c3.getLocal("p1"), c3.getLocal("pr")),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefixField + "_isOne", z1),
          [
            ...c3.call(prefix + "_addAffine", x1, x22, x32),
            ...c3.ret([])
          ]
        ),
        c3.call(prefixField + "_square", z1, Z1Z1),
        c3.call(prefixField + "_mul", x22, Z1Z1, U22),
        c3.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
        c3.call(prefixField + "_mul", y22, Z1_cubed, S22),
        c3.if(
          c3.call(prefixField + "_eq", x1, U22),
          c3.if(
            c3.call(prefixField + "_eq", y1, S22),
            [
              ...c3.call(prefix + "_doubleAffine", c3.getLocal("p2"), c3.getLocal("pr")),
              ...c3.ret([])
            ]
          )
        ),
        c3.call(prefixField + "_sub", U22, x1, H4),
        c3.call(prefixField + "_sub", S22, y1, S2_minus_y1),
        c3.call(prefixField + "_square", H4, HH),
        c3.call(prefixField + "_add", HH, HH, I5),
        c3.call(prefixField + "_add", I5, I5, I5),
        c3.call(prefixField + "_mul", H4, I5, J4),
        c3.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r),
        c3.call(prefixField + "_mul", x1, I5, V5),
        c3.call(prefixField + "_square", r, r2),
        c3.call(prefixField + "_add", V5, V5, V22),
        c3.call(prefixField + "_sub", r2, J4, x32),
        c3.call(prefixField + "_sub", x32, V22, x32),
        c3.call(prefixField + "_mul", y1, J4, y1_J2),
        c3.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
        c3.call(prefixField + "_sub", V5, x32, y32),
        c3.call(prefixField + "_mul", y32, r, y32),
        c3.call(prefixField + "_sub", y32, y1_J2, y32),
        c3.call(prefixField + "_add", z1, H4, z32),
        c3.call(prefixField + "_square", z32, z32),
        c3.call(prefixField + "_sub", z32, Z1Z1, z32),
        c3.call(prefixField + "_sub", z32, HH, z32)
      );
    }
    function buildAddAffine() {
      const f5 = module.addFunction(prefix + "_addAffine");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("z1", "i32");
      const c3 = f5.getCodeBuilder();
      const x1 = c3.getLocal("p1");
      const y1 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      f5.addCode(c3.setLocal("z1", c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2))));
      const x22 = c3.getLocal("p2");
      const y22 = c3.i32_add(c3.getLocal("p2"), c3.i32_const(n8));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const H4 = c3.i32_const(module.alloc(n8));
      const HH = c3.i32_const(module.alloc(n8));
      const y2_minus_y1 = c3.i32_const(module.alloc(n8));
      const I5 = c3.i32_const(module.alloc(n8));
      const J4 = c3.i32_const(module.alloc(n8));
      const r = c3.i32_const(module.alloc(n8));
      const r2 = c3.i32_const(module.alloc(n8));
      const V5 = c3.i32_const(module.alloc(n8));
      const V22 = c3.i32_const(module.alloc(n8));
      const y1_J2 = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p1")),
          [
            ...c3.call(prefix + "_copyAffine", c3.getLocal("p2"), c3.getLocal("pr")),
            ...c3.call(prefixField + "_one", c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2))),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p2")),
          [
            ...c3.call(prefix + "_copyAffine", c3.getLocal("p1"), c3.getLocal("pr")),
            ...c3.call(prefixField + "_one", c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2))),
            ...c3.ret([])
          ]
        ),
        c3.if(
          c3.call(prefixField + "_eq", x1, x22),
          c3.if(
            c3.call(prefixField + "_eq", y1, y22),
            [
              ...c3.call(prefix + "_doubleAffine", c3.getLocal("p2"), c3.getLocal("pr")),
              ...c3.ret([])
            ]
          )
        ),
        c3.call(prefixField + "_sub", x22, x1, H4),
        c3.call(prefixField + "_sub", y22, y1, y2_minus_y1),
        c3.call(prefixField + "_square", H4, HH),
        c3.call(prefixField + "_add", HH, HH, I5),
        c3.call(prefixField + "_add", I5, I5, I5),
        c3.call(prefixField + "_mul", H4, I5, J4),
        c3.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r),
        c3.call(prefixField + "_mul", x1, I5, V5),
        c3.call(prefixField + "_square", r, r2),
        c3.call(prefixField + "_add", V5, V5, V22),
        c3.call(prefixField + "_sub", r2, J4, x32),
        c3.call(prefixField + "_sub", x32, V22, x32),
        c3.call(prefixField + "_mul", y1, J4, y1_J2),
        c3.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
        c3.call(prefixField + "_sub", V5, x32, y32),
        c3.call(prefixField + "_mul", y32, r, y32),
        c3.call(prefixField + "_sub", y32, y1_J2, y32),
        c3.call(prefixField + "_add", H4, H4, z32)
      );
    }
    function buildNeg() {
      const f5 = module.addFunction(prefix + "_neg");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const z6 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      f5.addCode(
        c3.call(prefixField + "_copy", x6, x32),
        c3.call(prefixField + "_neg", y5, y32),
        c3.call(prefixField + "_copy", z6, z32)
      );
    }
    function buildNegAffine() {
      const f5 = module.addFunction(prefix + "_negAffine");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      f5.addCode(
        c3.call(prefixField + "_copy", x6, x32),
        c3.call(prefixField + "_neg", y5, y32)
      );
    }
    function buildSub() {
      const f5 = module.addFunction(prefix + "_sub");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8 * 3));
      f5.addCode(
        c3.call(prefix + "_neg", c3.getLocal("p2"), AUX),
        c3.call(prefix + "_add", c3.getLocal("p1"), AUX, c3.getLocal("pr"))
      );
    }
    function buildSubMixed() {
      const f5 = module.addFunction(prefix + "_subMixed");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8 * 3));
      f5.addCode(
        c3.call(prefix + "_negAffine", c3.getLocal("p2"), AUX),
        c3.call(prefix + "_addMixed", c3.getLocal("p1"), AUX, c3.getLocal("pr"))
      );
    }
    function buildSubAffine() {
      const f5 = module.addFunction(prefix + "_subAffine");
      f5.addParam("p1", "i32");
      f5.addParam("p2", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8 * 3));
      f5.addCode(
        c3.call(prefix + "_negAffine", c3.getLocal("p2"), AUX),
        c3.call(prefix + "_addAffine", c3.getLocal("p1"), AUX, c3.getLocal("pr"))
      );
    }
    function buildNormalize() {
      const f5 = module.addFunction(prefix + "_normalize");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const z6 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      const Z_inv = c3.i32_const(module.alloc(n8));
      const Z2_inv = c3.i32_const(module.alloc(n8));
      const Z3_inv = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          c3.call(prefix + "_zero", c3.getLocal("pr")),
          [
            ...c3.call(prefixField + "_inverse", z6, Z_inv),
            ...c3.call(prefixField + "_square", Z_inv, Z2_inv),
            ...c3.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
            ...c3.call(prefixField + "_mul", x6, Z2_inv, x32),
            ...c3.call(prefixField + "_mul", y5, Z3_inv, y32),
            ...c3.call(prefixField + "_one", z32)
          ]
        )
      );
    }
    function buildToAffine() {
      const f5 = module.addFunction(prefix + "_toAffine");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const z6 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8 * 2));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const Z_inv = c3.i32_const(module.alloc(n8));
      const Z2_inv = c3.i32_const(module.alloc(n8));
      const Z3_inv = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZero", c3.getLocal("p1")),
          [
            ...c3.call(prefixField + "_zero", x32),
            ...c3.call(prefixField + "_zero", y32)
          ],
          [
            ...c3.call(prefixField + "_inverse", z6, Z_inv),
            ...c3.call(prefixField + "_square", Z_inv, Z2_inv),
            ...c3.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
            ...c3.call(prefixField + "_mul", x6, Z2_inv, x32),
            ...c3.call(prefixField + "_mul", y5, Z3_inv, y32)
          ]
        )
      );
    }
    function buildToJacobian() {
      const f5 = module.addFunction(prefix + "_toJacobian");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(n8));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("p1")),
          c3.call(prefix + "_zero", c3.getLocal("pr")),
          [
            ...c3.call(prefixField + "_one", z32),
            ...c3.call(prefixField + "_copy", y5, y32),
            ...c3.call(prefixField + "_copy", x6, x32)
          ]
        )
      );
    }
    function buildBatchToAffine() {
      const f5 = module.addFunction(prefix + "_batchToAffine");
      f5.addParam("pIn", "i32");
      f5.addParam("n", "i32");
      f5.addParam("pOut", "i32");
      f5.addLocal("pAux", "i32");
      f5.addLocal("itIn", "i32");
      f5.addLocal("itAux", "i32");
      f5.addLocal("itOut", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const tmp = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.setLocal("pAux", c3.i32_load(c3.i32_const(0))),
        c3.i32_store(
          c3.i32_const(0),
          c3.i32_add(
            c3.getLocal("pAux"),
            c3.i32_mul(c3.getLocal("n"), c3.i32_const(n8))
          )
        ),
        c3.call(
          prefixField + "_batchInverse",
          c3.i32_add(c3.getLocal("pIn"), c3.i32_const(n8 * 2)),
          c3.i32_const(n8 * 3),
          c3.getLocal("n"),
          c3.getLocal("pAux"),
          c3.i32_const(n8)
        ),
        c3.setLocal("itIn", c3.getLocal("pIn")),
        c3.setLocal("itAux", c3.getLocal("pAux")),
        c3.setLocal("itOut", c3.getLocal("pOut")),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
          c3.if(
            c3.call(prefixField + "_isZero", c3.getLocal("itAux")),
            [
              ...c3.call(prefixField + "_zero", c3.getLocal("itOut")),
              ...c3.call(prefixField + "_zero", c3.i32_add(c3.getLocal("itOut"), c3.i32_const(n8)))
            ],
            [
              ...c3.call(
                prefixField + "_mul",
                c3.getLocal("itAux"),
                c3.i32_add(c3.getLocal("itIn"), c3.i32_const(n8)),
                tmp
              ),
              ...c3.call(
                prefixField + "_square",
                c3.getLocal("itAux"),
                c3.getLocal("itAux")
              ),
              ...c3.call(
                prefixField + "_mul",
                c3.getLocal("itAux"),
                c3.getLocal("itIn"),
                c3.getLocal("itOut")
              ),
              ...c3.call(
                prefixField + "_mul",
                c3.getLocal("itAux"),
                tmp,
                c3.i32_add(c3.getLocal("itOut"), c3.i32_const(n8))
              )
            ]
          ),
          c3.setLocal("itIn", c3.i32_add(c3.getLocal("itIn"), c3.i32_const(n8 * 3))),
          c3.setLocal("itOut", c3.i32_add(c3.getLocal("itOut"), c3.i32_const(n8 * 2))),
          c3.setLocal("itAux", c3.i32_add(c3.getLocal("itAux"), c3.i32_const(n8))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.i32_store(
          c3.i32_const(0),
          c3.getLocal("pAux")
        )
      );
    }
    function buildReverseBytes() {
      const f5 = module.addFunction(prefix + "__reverseBytes");
      f5.addParam("pIn", "i32");
      f5.addParam("n", "i32");
      f5.addParam("pOut", "i32");
      f5.addLocal("itOut", "i32");
      f5.addLocal("itIn", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal(
          "itOut",
          c3.i32_sub(
            c3.i32_add(
              c3.getLocal("pOut"),
              c3.getLocal("n")
            ),
            c3.i32_const(1)
          )
        ),
        c3.setLocal(
          "itIn",
          c3.getLocal("pIn")
        ),
        c3.block(c3.loop(
          c3.br_if(1, c3.i32_lt_s(c3.getLocal("itOut"), c3.getLocal("pOut"))),
          c3.i32_store8(
            c3.getLocal("itOut"),
            c3.i32_load8_u(c3.getLocal("itIn"))
          ),
          c3.setLocal("itOut", c3.i32_sub(c3.getLocal("itOut"), c3.i32_const(1))),
          c3.setLocal("itIn", c3.i32_add(c3.getLocal("itIn"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildLEMtoC() {
      const f5 = module.addFunction(prefix + "_LEMtoC");
      f5.addParam("pIn", "i32");
      f5.addParam("pOut", "i32");
      const c3 = f5.getCodeBuilder();
      const tmp = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("pIn")),
          [
            ...c3.call(prefixField + "_zero", c3.getLocal("pOut")),
            ...c3.i32_store8(
              c3.getLocal("pOut"),
              c3.i32_const(64)
            ),
            ...c3.ret([])
          ]
        ),
        c3.call(prefixField + "_fromMontgomery", c3.getLocal("pIn"), tmp),
        c3.call(prefix + "__reverseBytes", tmp, c3.i32_const(n8), c3.getLocal("pOut")),
        c3.if(
          c3.i32_eq(
            c3.call(prefixField + "_sign", c3.i32_add(c3.getLocal("pIn"), c3.i32_const(n8))),
            c3.i32_const(-1)
          ),
          c3.i32_store8(
            c3.getLocal("pOut"),
            c3.i32_or(
              c3.i32_load8_u(c3.getLocal("pOut")),
              c3.i32_const(128)
            )
          )
        )
      );
    }
    function buildLEMtoU() {
      const f5 = module.addFunction(prefix + "_LEMtoU");
      f5.addParam("pIn", "i32");
      f5.addParam("pOut", "i32");
      const c3 = f5.getCodeBuilder();
      const pTmp = module.alloc(n8 * 2);
      const tmp = c3.i32_const(pTmp);
      const tmpX = c3.i32_const(pTmp);
      const tmpY = c3.i32_const(pTmp + n8);
      f5.addCode(
        c3.if(
          c3.call(prefix + "_isZeroAffine", c3.getLocal("pIn")),
          [
            ...c3.call(prefix + "_zeroAffine", c3.getLocal("pOut")),
            ...c3.ret([])
          ]
        ),
        c3.call(prefix + "_fromMontgomeryAffine", c3.getLocal("pIn"), tmp),
        c3.call(prefix + "__reverseBytes", tmpX, c3.i32_const(n8), c3.getLocal("pOut")),
        c3.call(prefix + "__reverseBytes", tmpY, c3.i32_const(n8), c3.i32_add(c3.getLocal("pOut"), c3.i32_const(n8)))
      );
    }
    function buildUtoLEM() {
      const f5 = module.addFunction(prefix + "_UtoLEM");
      f5.addParam("pIn", "i32");
      f5.addParam("pOut", "i32");
      const c3 = f5.getCodeBuilder();
      const pTmp = module.alloc(n8 * 2);
      const tmp = c3.i32_const(pTmp);
      const tmpX = c3.i32_const(pTmp);
      const tmpY = c3.i32_const(pTmp + n8);
      f5.addCode(
        c3.if(
          c3.i32_and(c3.i32_load8_u(c3.getLocal("pIn")), c3.i32_const(64)),
          [
            ...c3.call(prefix + "_zeroAffine", c3.getLocal("pOut")),
            ...c3.ret([])
          ]
        ),
        c3.call(prefix + "__reverseBytes", c3.getLocal("pIn"), c3.i32_const(n8), tmpX),
        c3.call(prefix + "__reverseBytes", c3.i32_add(c3.getLocal("pIn"), c3.i32_const(n8)), c3.i32_const(n8), tmpY),
        c3.call(prefix + "_toMontgomeryAffine", tmp, c3.getLocal("pOut"))
      );
    }
    function buildCtoLEM() {
      const f5 = module.addFunction(prefix + "_CtoLEM");
      f5.addParam("pIn", "i32");
      f5.addParam("pOut", "i32");
      f5.addLocal("firstByte", "i32");
      f5.addLocal("greatest", "i32");
      const c3 = f5.getCodeBuilder();
      const pTmp = module.alloc(n8 * 2);
      const tmpX = c3.i32_const(pTmp);
      const tmpY = c3.i32_const(pTmp + n8);
      f5.addCode(
        c3.setLocal("firstByte", c3.i32_load8_u(c3.getLocal("pIn"))),
        c3.if(
          c3.i32_and(
            c3.getLocal("firstByte"),
            c3.i32_const(64)
          ),
          [
            ...c3.call(prefix + "_zeroAffine", c3.getLocal("pOut")),
            ...c3.ret([])
          ]
        ),
        c3.setLocal(
          "greatest",
          c3.i32_and(
            c3.getLocal("firstByte"),
            c3.i32_const(128)
          )
        ),
        c3.call(prefixField + "_copy", c3.getLocal("pIn"), tmpY),
        c3.i32_store8(tmpY, c3.i32_and(c3.getLocal("firstByte"), c3.i32_const(63))),
        c3.call(prefix + "__reverseBytes", tmpY, c3.i32_const(n8), tmpX),
        c3.call(prefixField + "_toMontgomery", tmpX, c3.getLocal("pOut")),
        c3.call(prefixField + "_square", c3.getLocal("pOut"), tmpY),
        c3.call(prefixField + "_mul", c3.getLocal("pOut"), tmpY, tmpY),
        c3.call(prefixField + "_add", tmpY, c3.i32_const(pB), tmpY),
        c3.call(prefixField + "_sqrt", tmpY, tmpY),
        c3.call(prefixField + "_neg", tmpY, tmpX),
        c3.if(
          c3.i32_eq(
            c3.call(prefixField + "_sign", tmpY),
            c3.i32_const(-1)
          ),
          c3.if(
            c3.getLocal("greatest"),
            c3.call(prefixField + "_copy", tmpY, c3.i32_add(c3.getLocal("pOut"), c3.i32_const(n8))),
            c3.call(prefixField + "_neg", tmpY, c3.i32_add(c3.getLocal("pOut"), c3.i32_const(n8)))
          ),
          c3.if(
            c3.getLocal("greatest"),
            c3.call(prefixField + "_neg", tmpY, c3.i32_add(c3.getLocal("pOut"), c3.i32_const(n8))),
            c3.call(prefixField + "_copy", tmpY, c3.i32_add(c3.getLocal("pOut"), c3.i32_const(n8)))
          )
        )
      );
    }
    function buildInCurveAffine() {
      const f5 = module.addFunction(prefix + "_inCurveAffine");
      f5.addParam("pIn", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("pIn");
      const y5 = c3.i32_add(c3.getLocal("pIn"), c3.i32_const(n8));
      const y22 = c3.i32_const(module.alloc(n8));
      const x3b = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.call(prefixField + "_square", y5, y22),
        c3.call(prefixField + "_square", x6, x3b),
        c3.call(prefixField + "_mul", x6, x3b, x3b),
        c3.call(prefixField + "_add", x3b, c3.i32_const(pB), x3b),
        c3.ret(
          c3.call(prefixField + "_eq", y22, x3b)
        )
      );
    }
    function buildInCurve() {
      const f5 = module.addFunction(prefix + "_inCurve");
      f5.addParam("pIn", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const aux = c3.i32_const(module.alloc(n8 * 2));
      f5.addCode(
        c3.call(prefix + "_toAffine", c3.getLocal("pIn"), aux),
        c3.ret(
          c3.call(prefix + "_inCurveAffine", aux)
        )
      );
    }
    buildIsZeroAffine();
    buildIsZero();
    buildZeroAffine();
    buildZero();
    buildCopyAffine();
    buildCopy();
    buildToJacobian();
    buildEqAffine();
    buildEqMixed();
    buildEq();
    buildDoubleAffine();
    buildDouble();
    buildAddAffine();
    buildAddMixed();
    buildAdd();
    buildNegAffine();
    buildNeg();
    buildSubAffine();
    buildSubMixed();
    buildSub();
    buildFromMontgomeryAffine();
    buildFromMontgomery();
    buildToMontgomeryAffine();
    buildToMontgomery();
    buildToAffine();
    buildInCurveAffine();
    buildInCurve();
    buildBatchToAffine();
    buildNormalize();
    buildReverseBytes();
    buildLEMtoU();
    buildLEMtoC();
    buildUtoLEM();
    buildCtoLEM();
    buildBatchConvertion(module, prefix + "_batchLEMtoU", prefix + "_LEMtoU", n8 * 2, n8 * 2);
    buildBatchConvertion(module, prefix + "_batchLEMtoC", prefix + "_LEMtoC", n8 * 2, n8);
    buildBatchConvertion(module, prefix + "_batchUtoLEM", prefix + "_UtoLEM", n8 * 2, n8 * 2);
    buildBatchConvertion(module, prefix + "_batchCtoLEM", prefix + "_CtoLEM", n8, n8 * 2, true);
    buildBatchConvertion(module, prefix + "_batchToJacobian", prefix + "_toJacobian", n8 * 2, n8 * 3, true);
    buildMultiexp$1(module, prefix, prefix + "_multiexp", prefix + "_add", n8 * 3);
    buildMultiexp$1(module, prefix, prefix + "_multiexpAffine", prefix + "_addMixed", n8 * 2);
    buildTimesScalarNAF2(
      module,
      prefix + "_timesScalar",
      n8 * 3,
      prefix + "_add",
      prefix + "_double",
      prefix + "_sub",
      prefix + "_copy",
      prefix + "_zero"
    );
    buildTimesScalarNAF2(
      module,
      prefix + "_timesScalarAffine",
      n8 * 2,
      prefix + "_addMixed",
      prefix + "_double",
      prefix + "_subMixed",
      prefix + "_copyAffine",
      prefix + "_zero"
    );
    module.exportFunction(prefix + "_isZero");
    module.exportFunction(prefix + "_isZeroAffine");
    module.exportFunction(prefix + "_eq");
    module.exportFunction(prefix + "_eqMixed");
    module.exportFunction(prefix + "_eqAffine");
    module.exportFunction(prefix + "_copy");
    module.exportFunction(prefix + "_copyAffine");
    module.exportFunction(prefix + "_zero");
    module.exportFunction(prefix + "_zeroAffine");
    module.exportFunction(prefix + "_double");
    module.exportFunction(prefix + "_doubleAffine");
    module.exportFunction(prefix + "_add");
    module.exportFunction(prefix + "_addMixed");
    module.exportFunction(prefix + "_addAffine");
    module.exportFunction(prefix + "_neg");
    module.exportFunction(prefix + "_negAffine");
    module.exportFunction(prefix + "_sub");
    module.exportFunction(prefix + "_subMixed");
    module.exportFunction(prefix + "_subAffine");
    module.exportFunction(prefix + "_fromMontgomery");
    module.exportFunction(prefix + "_fromMontgomeryAffine");
    module.exportFunction(prefix + "_toMontgomery");
    module.exportFunction(prefix + "_toMontgomeryAffine");
    module.exportFunction(prefix + "_timesScalar");
    module.exportFunction(prefix + "_timesScalarAffine");
    module.exportFunction(prefix + "_normalize");
    module.exportFunction(prefix + "_LEMtoU");
    module.exportFunction(prefix + "_LEMtoC");
    module.exportFunction(prefix + "_UtoLEM");
    module.exportFunction(prefix + "_CtoLEM");
    module.exportFunction(prefix + "_batchLEMtoU");
    module.exportFunction(prefix + "_batchLEMtoC");
    module.exportFunction(prefix + "_batchUtoLEM");
    module.exportFunction(prefix + "_batchCtoLEM");
    module.exportFunction(prefix + "_toAffine");
    module.exportFunction(prefix + "_toJacobian");
    module.exportFunction(prefix + "_batchToAffine");
    module.exportFunction(prefix + "_batchToJacobian");
    module.exportFunction(prefix + "_inCurve");
    module.exportFunction(prefix + "_inCurveAffine");
    return prefix;
  };
  var { isOdd: isOdd$2, modInv: modInv$1, modPow } = bigint;
  var utils$3 = utils$6;
  var build_fft = function buildFFT(module, prefix, gPrefix, fPrefix, opGtimesF) {
    const n64f = module.modules[fPrefix].n64;
    const n8f = n64f * 8;
    const n64g = module.modules[gPrefix].n64;
    const n8g = n64g * 8;
    const q5 = module.modules[fPrefix].q;
    let rem = q5 - 1n;
    let maxBits = 0;
    while (!isOdd$2(rem)) {
      maxBits++;
      rem = rem >> 1n;
    }
    let nr2 = 2n;
    while (modPow(nr2, q5 >> 1n, q5) === 1n)
      nr2 = nr2 + 1n;
    const w5 = new Array(maxBits + 1);
    w5[maxBits] = modPow(nr2, rem, q5);
    let n4 = maxBits - 1;
    while (n4 >= 0) {
      w5[n4] = modPow(w5[n4 + 1], 2n, q5);
      n4--;
    }
    const bytes2 = [];
    const R5 = (1n << BigInt(n8f * 8)) % q5;
    for (let i4 = 0; i4 < w5.length; i4++) {
      const m5 = w5[i4] * R5 % q5;
      bytes2.push(...utils$3.bigInt2BytesLE(m5, n8f));
    }
    const ROOTs = module.alloc(bytes2);
    const i22 = new Array(maxBits + 1);
    i22[0] = 1n;
    for (let i4 = 1; i4 <= maxBits; i4++) {
      i22[i4] = i22[i4 - 1] * 2n;
    }
    const bytesi2 = [];
    for (let i4 = 0; i4 <= maxBits; i4++) {
      const m5 = modInv$1(i22[i4], q5) * R5 % q5;
      bytesi2.push(...utils$3.bigInt2BytesLE(m5, n8f));
    }
    const INV2 = module.alloc(bytesi2);
    const shift = modPow(nr2, 2n, q5);
    const bytesShiftToSmallM = [];
    const bytesSConst = [];
    for (let i4 = 0; i4 <= maxBits; i4++) {
      const shiftToSmallM = modPow(shift, 2n ** BigInt(i4), q5);
      const sConst = modInv$1(q5 + 1n - shiftToSmallM, q5);
      bytesShiftToSmallM.push(...utils$3.bigInt2BytesLE(shiftToSmallM * R5 % q5, n8f));
      bytesSConst.push(...utils$3.bigInt2BytesLE(sConst * R5 % q5, n8f));
    }
    const SHIFT_TO_M = module.alloc(bytesShiftToSmallM);
    const SCONST = module.alloc(bytesSConst);
    function rev(x6) {
      let r = 0;
      for (let i4 = 0; i4 < 8; i4++) {
        if (x6 & 1 << i4) {
          r = r | 128 >> i4;
        }
      }
      return r;
    }
    const rtable = Array(256);
    for (let i4 = 0; i4 < 256; i4++) {
      rtable[i4] = rev(i4);
    }
    const REVTABLE = module.alloc(rtable);
    function buildLog2() {
      const f5 = module.addFunction(prefix + "__log2");
      f5.addParam("n", "i32");
      f5.setReturnType("i32");
      f5.addLocal("bits", "i32");
      f5.addLocal("aux", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal(
          "aux",
          c3.i32_shr_u(
            c3.getLocal("n"),
            c3.i32_const(1)
          )
        )
      );
      f5.addCode(c3.setLocal("bits", c3.i32_const(0)));
      f5.addCode(c3.block(c3.loop(
        c3.br_if(
          1,
          c3.i32_eqz(c3.getLocal("aux"))
        ),
        c3.setLocal(
          "aux",
          c3.i32_shr_u(
            c3.getLocal("aux"),
            c3.i32_const(1)
          )
        ),
        c3.setLocal(
          "bits",
          c3.i32_add(
            c3.getLocal("bits"),
            c3.i32_const(1)
          )
        ),
        c3.br(0)
      )));
      f5.addCode(c3.if(
        c3.i32_ne(
          c3.getLocal("n"),
          c3.i32_shl(
            c3.i32_const(1),
            c3.getLocal("bits")
          )
        ),
        c3.unreachable()
      ));
      f5.addCode(c3.if(
        c3.i32_gt_u(
          c3.getLocal("bits"),
          c3.i32_const(maxBits)
        ),
        c3.unreachable()
      ));
      f5.addCode(c3.getLocal("bits"));
    }
    function buildFFT3() {
      const f5 = module.addFunction(prefix + "_fft");
      f5.addParam("px", "i32");
      f5.addParam("n", "i32");
      f5.addLocal("bits", "i32");
      const c3 = f5.getCodeBuilder();
      const One = c3.i32_const(module.alloc(n8f));
      f5.addCode(
        c3.setLocal(
          "bits",
          c3.call(
            prefix + "__log2",
            c3.getLocal("n")
          )
        ),
        c3.call(fPrefix + "_one", One),
        c3.call(
          prefix + "_rawfft",
          c3.getLocal("px"),
          c3.getLocal("bits"),
          c3.i32_const(0),
          One
        )
      );
    }
    function buildIFFT() {
      const f5 = module.addFunction(prefix + "_ifft");
      f5.addParam("px", "i32");
      f5.addParam("n", "i32");
      f5.addLocal("bits", "i32");
      f5.addLocal("pInv2", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal(
          "bits",
          c3.call(
            prefix + "__log2",
            c3.getLocal("n")
          )
        ),
        c3.setLocal(
          "pInv2",
          c3.i32_add(
            c3.i32_const(INV2),
            c3.i32_mul(
              c3.getLocal("bits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.call(
          prefix + "_rawfft",
          c3.getLocal("px"),
          c3.getLocal("bits"),
          c3.i32_const(1),
          c3.getLocal("pInv2")
        )
      );
    }
    function buildRawFFT() {
      const f5 = module.addFunction(prefix + "_rawfft");
      f5.addParam("px", "i32");
      f5.addParam("bits", "i32");
      f5.addParam("reverse", "i32");
      f5.addParam("mulFactor", "i32");
      f5.addLocal("s", "i32");
      f5.addLocal("k", "i32");
      f5.addLocal("j", "i32");
      f5.addLocal("m", "i32");
      f5.addLocal("mdiv2", "i32");
      f5.addLocal("n", "i32");
      f5.addLocal("pwm", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const T6 = c3.i32_const(module.alloc(n8g));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.call(prefix + "__reversePermutation", c3.getLocal("px"), c3.getLocal("bits")),
        c3.setLocal("n", c3.i32_shl(c3.i32_const(1), c3.getLocal("bits"))),
        c3.setLocal("s", c3.i32_const(1)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_gt_u(
              c3.getLocal("s"),
              c3.getLocal("bits")
            )
          ),
          c3.setLocal("m", c3.i32_shl(c3.i32_const(1), c3.getLocal("s"))),
          c3.setLocal(
            "pwm",
            c3.i32_add(
              c3.i32_const(ROOTs),
              c3.i32_mul(
                c3.getLocal("s"),
                c3.i32_const(n8f)
              )
            )
          ),
          c3.setLocal("k", c3.i32_const(0)),
          c3.block(c3.loop(
            c3.br_if(
              1,
              c3.i32_ge_u(
                c3.getLocal("k"),
                c3.getLocal("n")
              )
            ),
            c3.call(fPrefix + "_one", W5),
            c3.setLocal("mdiv2", c3.i32_shr_u(c3.getLocal("m"), c3.i32_const(1))),
            c3.setLocal("j", c3.i32_const(0)),
            c3.block(c3.loop(
              c3.br_if(
                1,
                c3.i32_ge_u(
                  c3.getLocal("j"),
                  c3.getLocal("mdiv2")
                )
              ),
              c3.setLocal(
                "idx1",
                c3.i32_add(
                  c3.getLocal("px"),
                  c3.i32_mul(
                    c3.i32_add(
                      c3.getLocal("k"),
                      c3.getLocal("j")
                    ),
                    c3.i32_const(n8g)
                  )
                )
              ),
              c3.setLocal(
                "idx2",
                c3.i32_add(
                  c3.getLocal("idx1"),
                  c3.i32_mul(
                    c3.getLocal("mdiv2"),
                    c3.i32_const(n8g)
                  )
                )
              ),
              c3.call(
                opGtimesF,
                c3.getLocal("idx2"),
                W5,
                T6
              ),
              c3.call(
                gPrefix + "_copy",
                c3.getLocal("idx1"),
                U6
              ),
              c3.call(
                gPrefix + "_add",
                U6,
                T6,
                c3.getLocal("idx1")
              ),
              c3.call(
                gPrefix + "_sub",
                U6,
                T6,
                c3.getLocal("idx2")
              ),
              c3.call(
                fPrefix + "_mul",
                W5,
                c3.getLocal("pwm"),
                W5
              ),
              c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
              c3.br(0)
            )),
            c3.setLocal("k", c3.i32_add(c3.getLocal("k"), c3.getLocal("m"))),
            c3.br(0)
          )),
          c3.setLocal("s", c3.i32_add(c3.getLocal("s"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.call(
          prefix + "__fftFinal",
          c3.getLocal("px"),
          c3.getLocal("bits"),
          c3.getLocal("reverse"),
          c3.getLocal("mulFactor")
        )
      );
    }
    function buildFinalInverse() {
      const f5 = module.addFunction(prefix + "__fftFinal");
      f5.addParam("px", "i32");
      f5.addParam("bits", "i32");
      f5.addParam("reverse", "i32");
      f5.addParam("mulFactor", "i32");
      f5.addLocal("n", "i32");
      f5.addLocal("ndiv2", "i32");
      f5.addLocal("pInv2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("mask", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      const c3 = f5.getCodeBuilder();
      const T6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.if(
          c3.i32_and(
            c3.i32_eqz(c3.getLocal("reverse")),
            c3.call(fPrefix + "_isOne", c3.getLocal("mulFactor"))
          ),
          c3.ret([])
        ),
        c3.setLocal("n", c3.i32_shl(c3.i32_const(1), c3.getLocal("bits"))),
        c3.setLocal("mask", c3.i32_sub(c3.getLocal("n"), c3.i32_const(1))),
        c3.setLocal("i", c3.i32_const(1)),
        c3.setLocal(
          "ndiv2",
          c3.i32_shr_u(
            c3.getLocal("n"),
            c3.i32_const(1)
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_ge_u(
              c3.getLocal("i"),
              c3.getLocal("ndiv2")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("px"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("px"),
              c3.i32_mul(
                c3.i32_sub(
                  c3.getLocal("n"),
                  c3.getLocal("i")
                ),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.if(
            c3.getLocal("reverse"),
            c3.if(
              c3.call(fPrefix + "_isOne", c3.getLocal("mulFactor")),
              [
                ...c3.call(gPrefix + "_copy", c3.getLocal("idx1"), T6),
                ...c3.call(gPrefix + "_copy", c3.getLocal("idx2"), c3.getLocal("idx1")),
                ...c3.call(gPrefix + "_copy", T6, c3.getLocal("idx2"))
              ],
              [
                ...c3.call(gPrefix + "_copy", c3.getLocal("idx1"), T6),
                ...c3.call(opGtimesF, c3.getLocal("idx2"), c3.getLocal("mulFactor"), c3.getLocal("idx1")),
                ...c3.call(opGtimesF, T6, c3.getLocal("mulFactor"), c3.getLocal("idx2"))
              ]
            ),
            c3.if(
              c3.call(fPrefix + "_isOne", c3.getLocal("mulFactor")),
              [],
              [
                ...c3.call(opGtimesF, c3.getLocal("idx1"), c3.getLocal("mulFactor"), c3.getLocal("idx1")),
                ...c3.call(opGtimesF, c3.getLocal("idx2"), c3.getLocal("mulFactor"), c3.getLocal("idx2"))
              ]
            )
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.if(
          c3.call(fPrefix + "_isOne", c3.getLocal("mulFactor")),
          [],
          [
            ...c3.call(opGtimesF, c3.getLocal("px"), c3.getLocal("mulFactor"), c3.getLocal("px")),
            ...c3.setLocal(
              "idx2",
              c3.i32_add(
                c3.getLocal("px"),
                c3.i32_mul(
                  c3.getLocal("ndiv2"),
                  c3.i32_const(n8g)
                )
              )
            ),
            ...c3.call(opGtimesF, c3.getLocal("idx2"), c3.getLocal("mulFactor"), c3.getLocal("idx2"))
          ]
        )
      );
    }
    function buildReversePermutation() {
      const f5 = module.addFunction(prefix + "__reversePermutation");
      f5.addParam("px", "i32");
      f5.addParam("bits", "i32");
      f5.addLocal("n", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("ri", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      const c3 = f5.getCodeBuilder();
      const T6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal("n", c3.i32_shl(c3.i32_const(1), c3.getLocal("bits"))),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("n")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("px"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal("ri", c3.call(prefix + "__rev", c3.getLocal("i"), c3.getLocal("bits"))),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("px"),
              c3.i32_mul(
                c3.getLocal("ri"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.if(
            c3.i32_lt_u(
              c3.getLocal("i"),
              c3.getLocal("ri")
            ),
            [
              ...c3.call(gPrefix + "_copy", c3.getLocal("idx1"), T6),
              ...c3.call(gPrefix + "_copy", c3.getLocal("idx2"), c3.getLocal("idx1")),
              ...c3.call(gPrefix + "_copy", T6, c3.getLocal("idx2"))
            ]
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildRev() {
      const f5 = module.addFunction(prefix + "__rev");
      f5.addParam("x", "i32");
      f5.addParam("bits", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.i32_rotl(
          c3.i32_add(
            c3.i32_add(
              c3.i32_shl(
                c3.i32_load8_u(
                  c3.i32_and(
                    c3.getLocal("x"),
                    c3.i32_const(255)
                  ),
                  REVTABLE,
                  0
                ),
                c3.i32_const(24)
              ),
              c3.i32_shl(
                c3.i32_load8_u(
                  c3.i32_and(
                    c3.i32_shr_u(
                      c3.getLocal("x"),
                      c3.i32_const(8)
                    ),
                    c3.i32_const(255)
                  ),
                  REVTABLE,
                  0
                ),
                c3.i32_const(16)
              )
            ),
            c3.i32_add(
              c3.i32_shl(
                c3.i32_load8_u(
                  c3.i32_and(
                    c3.i32_shr_u(
                      c3.getLocal("x"),
                      c3.i32_const(16)
                    ),
                    c3.i32_const(255)
                  ),
                  REVTABLE,
                  0
                ),
                c3.i32_const(8)
              ),
              c3.i32_load8_u(
                c3.i32_and(
                  c3.i32_shr_u(
                    c3.getLocal("x"),
                    c3.i32_const(24)
                  ),
                  c3.i32_const(255)
                ),
                REVTABLE,
                0
              )
            )
          ),
          c3.getLocal("bits")
        )
      );
    }
    function buildFFTJoin() {
      const f5 = module.addFunction(prefix + "_fftJoin");
      f5.addParam("pBuff1", "i32");
      f5.addParam("pBuff2", "i32");
      f5.addParam("n", "i32");
      f5.addParam("first", "i32");
      f5.addParam("inc", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const T6 = c3.i32_const(module.alloc(n8g));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.call(fPrefix + "_copy", c3.getLocal("first"), W5),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("n")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("pBuff1"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("pBuff2"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            W5,
            T6
          ),
          c3.call(
            gPrefix + "_copy",
            c3.getLocal("idx1"),
            U6
          ),
          c3.call(
            gPrefix + "_add",
            U6,
            T6,
            c3.getLocal("idx1")
          ),
          c3.call(
            gPrefix + "_sub",
            U6,
            T6,
            c3.getLocal("idx2")
          ),
          c3.call(
            fPrefix + "_mul",
            W5,
            c3.getLocal("inc"),
            W5
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildFFTJoinExt() {
      const f5 = module.addFunction(prefix + "_fftJoinExt");
      f5.addParam("pBuff1", "i32");
      f5.addParam("pBuff2", "i32");
      f5.addParam("n", "i32");
      f5.addParam("first", "i32");
      f5.addParam("inc", "i32");
      f5.addParam("totalBits", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("pShiftToM", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal(
          "pShiftToM",
          c3.i32_add(
            c3.i32_const(SHIFT_TO_M),
            c3.i32_mul(
              c3.getLocal("totalBits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.call(fPrefix + "_copy", c3.getLocal("first"), W5),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("n")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("pBuff1"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("pBuff2"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.call(
            gPrefix + "_add",
            c3.getLocal("idx1"),
            c3.getLocal("idx2"),
            U6
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            c3.getLocal("pShiftToM"),
            c3.getLocal("idx2")
          ),
          c3.call(
            gPrefix + "_add",
            c3.getLocal("idx1"),
            c3.getLocal("idx2"),
            c3.getLocal("idx2")
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            W5,
            c3.getLocal("idx2")
          ),
          c3.call(
            gPrefix + "_copy",
            U6,
            c3.getLocal("idx1")
          ),
          c3.call(
            fPrefix + "_mul",
            W5,
            c3.getLocal("inc"),
            W5
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildFFTJoinExtInv() {
      const f5 = module.addFunction(prefix + "_fftJoinExtInv");
      f5.addParam("pBuff1", "i32");
      f5.addParam("pBuff2", "i32");
      f5.addParam("n", "i32");
      f5.addParam("first", "i32");
      f5.addParam("inc", "i32");
      f5.addParam("totalBits", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("pShiftToM", "i32");
      f5.addLocal("pSConst", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal(
          "pShiftToM",
          c3.i32_add(
            c3.i32_const(SHIFT_TO_M),
            c3.i32_mul(
              c3.getLocal("totalBits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.setLocal(
          "pSConst",
          c3.i32_add(
            c3.i32_const(SCONST),
            c3.i32_mul(
              c3.getLocal("totalBits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.call(fPrefix + "_copy", c3.getLocal("first"), W5),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("n")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("pBuff1"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("pBuff2"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            W5,
            U6
          ),
          c3.call(
            gPrefix + "_sub",
            c3.getLocal("idx1"),
            U6,
            c3.getLocal("idx2")
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            c3.getLocal("pSConst"),
            c3.getLocal("idx2")
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx1"),
            c3.getLocal("pShiftToM"),
            c3.getLocal("idx1")
          ),
          c3.call(
            gPrefix + "_sub",
            U6,
            c3.getLocal("idx1"),
            c3.getLocal("idx1")
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx1"),
            c3.getLocal("pSConst"),
            c3.getLocal("idx1")
          ),
          c3.call(
            fPrefix + "_mul",
            W5,
            c3.getLocal("inc"),
            W5
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildPrepareLagrangeEvaluation() {
      const f5 = module.addFunction(prefix + "_prepareLagrangeEvaluation");
      f5.addParam("pBuff1", "i32");
      f5.addParam("pBuff2", "i32");
      f5.addParam("n", "i32");
      f5.addParam("first", "i32");
      f5.addParam("inc", "i32");
      f5.addParam("totalBits", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("pShiftToM", "i32");
      f5.addLocal("pSConst", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal(
          "pShiftToM",
          c3.i32_add(
            c3.i32_const(SHIFT_TO_M),
            c3.i32_mul(
              c3.getLocal("totalBits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.setLocal(
          "pSConst",
          c3.i32_add(
            c3.i32_const(SCONST),
            c3.i32_mul(
              c3.getLocal("totalBits"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.call(fPrefix + "_copy", c3.getLocal("first"), W5),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("n")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("pBuff1"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("pBuff2"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx1"),
            c3.getLocal("pShiftToM"),
            U6
          ),
          c3.call(
            gPrefix + "_sub",
            c3.getLocal("idx2"),
            U6,
            U6
          ),
          c3.call(
            gPrefix + "_sub",
            c3.getLocal("idx1"),
            c3.getLocal("idx2"),
            c3.getLocal("idx2")
          ),
          c3.call(
            opGtimesF,
            U6,
            c3.getLocal("pSConst"),
            c3.getLocal("idx1")
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            W5,
            c3.getLocal("idx2")
          ),
          c3.call(
            fPrefix + "_mul",
            W5,
            c3.getLocal("inc"),
            W5
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildFFTMix() {
      const f5 = module.addFunction(prefix + "_fftMix");
      f5.addParam("pBuff", "i32");
      f5.addParam("n", "i32");
      f5.addParam("exp", "i32");
      f5.addLocal("nGroups", "i32");
      f5.addLocal("nPerGroup", "i32");
      f5.addLocal("nPerGroupDiv2", "i32");
      f5.addLocal("pairOffset", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      f5.addLocal("pwm", "i32");
      const c3 = f5.getCodeBuilder();
      const W5 = c3.i32_const(module.alloc(n8f));
      const T6 = c3.i32_const(module.alloc(n8g));
      const U6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal("nPerGroup", c3.i32_shl(c3.i32_const(1), c3.getLocal("exp"))),
        c3.setLocal("nPerGroupDiv2", c3.i32_shr_u(c3.getLocal("nPerGroup"), c3.i32_const(1))),
        c3.setLocal("nGroups", c3.i32_shr_u(c3.getLocal("n"), c3.getLocal("exp"))),
        c3.setLocal("pairOffset", c3.i32_mul(c3.getLocal("nPerGroupDiv2"), c3.i32_const(n8g))),
        c3.setLocal(
          "pwm",
          c3.i32_add(
            c3.i32_const(ROOTs),
            c3.i32_mul(
              c3.getLocal("exp"),
              c3.i32_const(n8f)
            )
          )
        ),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("nGroups")
            )
          ),
          c3.call(fPrefix + "_one", W5),
          c3.setLocal("j", c3.i32_const(0)),
          c3.block(c3.loop(
            c3.br_if(
              1,
              c3.i32_eq(
                c3.getLocal("j"),
                c3.getLocal("nPerGroupDiv2")
              )
            ),
            c3.setLocal(
              "idx1",
              c3.i32_add(
                c3.getLocal("pBuff"),
                c3.i32_mul(
                  c3.i32_add(
                    c3.i32_mul(
                      c3.getLocal("i"),
                      c3.getLocal("nPerGroup")
                    ),
                    c3.getLocal("j")
                  ),
                  c3.i32_const(n8g)
                )
              )
            ),
            c3.setLocal(
              "idx2",
              c3.i32_add(
                c3.getLocal("idx1"),
                c3.getLocal("pairOffset")
              )
            ),
            c3.call(
              opGtimesF,
              c3.getLocal("idx2"),
              W5,
              T6
            ),
            c3.call(
              gPrefix + "_copy",
              c3.getLocal("idx1"),
              U6
            ),
            c3.call(
              gPrefix + "_add",
              U6,
              T6,
              c3.getLocal("idx1")
            ),
            c3.call(
              gPrefix + "_sub",
              U6,
              T6,
              c3.getLocal("idx2")
            ),
            c3.call(
              fPrefix + "_mul",
              W5,
              c3.getLocal("pwm"),
              W5
            ),
            c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
            c3.br(0)
          )),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildFFTFinal() {
      const f5 = module.addFunction(prefix + "_fftFinal");
      f5.addParam("pBuff", "i32");
      f5.addParam("n", "i32");
      f5.addParam("factor", "i32");
      f5.addLocal("idx1", "i32");
      f5.addLocal("idx2", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("ndiv2", "i32");
      const c3 = f5.getCodeBuilder();
      const T6 = c3.i32_const(module.alloc(n8g));
      f5.addCode(
        c3.setLocal("ndiv2", c3.i32_shr_u(c3.getLocal("n"), c3.i32_const(1))),
        c3.if(
          c3.i32_and(
            c3.getLocal("n"),
            c3.i32_const(1)
          ),
          c3.call(
            opGtimesF,
            c3.i32_add(
              c3.getLocal("pBuff"),
              c3.i32_mul(
                c3.getLocal("ndiv2"),
                c3.i32_const(n8g)
              )
            ),
            c3.getLocal("factor"),
            c3.i32_add(
              c3.getLocal("pBuff"),
              c3.i32_mul(
                c3.getLocal("ndiv2"),
                c3.i32_const(n8g)
              )
            )
          )
        ),
        c3.setLocal("i", c3.i32_const(0)),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_ge_u(
              c3.getLocal("i"),
              c3.getLocal("ndiv2")
            )
          ),
          c3.setLocal(
            "idx1",
            c3.i32_add(
              c3.getLocal("pBuff"),
              c3.i32_mul(
                c3.getLocal("i"),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.setLocal(
            "idx2",
            c3.i32_add(
              c3.getLocal("pBuff"),
              c3.i32_mul(
                c3.i32_sub(
                  c3.i32_sub(
                    c3.getLocal("n"),
                    c3.i32_const(1)
                  ),
                  c3.getLocal("i")
                ),
                c3.i32_const(n8g)
              )
            )
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx2"),
            c3.getLocal("factor"),
            T6
          ),
          c3.call(
            opGtimesF,
            c3.getLocal("idx1"),
            c3.getLocal("factor"),
            c3.getLocal("idx2")
          ),
          c3.call(
            gPrefix + "_copy",
            T6,
            c3.getLocal("idx1")
          ),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    buildRev();
    buildReversePermutation();
    buildFinalInverse();
    buildRawFFT();
    buildLog2();
    buildFFT3();
    buildIFFT();
    buildFFTJoin();
    buildFFTJoinExt();
    buildFFTJoinExtInv();
    buildFFTMix();
    buildFFTFinal();
    buildPrepareLagrangeEvaluation();
    module.exportFunction(prefix + "_fft");
    module.exportFunction(prefix + "_ifft");
    module.exportFunction(prefix + "_rawfft");
    module.exportFunction(prefix + "_fftJoin");
    module.exportFunction(prefix + "_fftJoinExt");
    module.exportFunction(prefix + "_fftJoinExtInv");
    module.exportFunction(prefix + "_fftMix");
    module.exportFunction(prefix + "_fftFinal");
    module.exportFunction(prefix + "_prepareLagrangeEvaluation");
  };
  var build_pol = function buildPol(module, prefix, prefixField) {
    const n64 = module.modules[prefixField].n64;
    const n8 = n64 * 8;
    function buildZero() {
      const f5 = module.addFunction(prefix + "_zero");
      f5.addParam("px", "i32");
      f5.addParam("n", "i32");
      f5.addLocal("lastp", "i32");
      f5.addLocal("p", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal("p", c3.getLocal("px")),
        c3.setLocal(
          "lastp",
          c3.i32_add(
            c3.getLocal("px"),
            c3.i32_mul(
              c3.getLocal("n"),
              c3.i32_const(n8)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("p"),
              c3.getLocal("lastp")
            )
          ),
          c3.call(prefixField + "_zero", c3.getLocal("p")),
          c3.setLocal("p", c3.i32_add(c3.getLocal("p"), c3.i32_const(n8))),
          c3.br(0)
        ))
      );
    }
    function buildConstructLC() {
      const f5 = module.addFunction(prefix + "_constructLC");
      f5.addParam("ppolynomials", "i32");
      f5.addParam("psignals", "i32");
      f5.addParam("nSignals", "i32");
      f5.addParam("pres", "i32");
      f5.addLocal("i", "i32");
      f5.addLocal("j", "i32");
      f5.addLocal("pp", "i32");
      f5.addLocal("ps", "i32");
      f5.addLocal("pd", "i32");
      f5.addLocal("ncoefs", "i32");
      const c3 = f5.getCodeBuilder();
      const aux = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.setLocal("i", c3.i32_const(0)),
        c3.setLocal("pp", c3.getLocal("ppolynomials")),
        c3.setLocal("ps", c3.getLocal("psignals")),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("i"),
              c3.getLocal("nSignals")
            )
          ),
          c3.setLocal("ncoefs", c3.i32_load(c3.getLocal("pp"))),
          c3.setLocal("pp", c3.i32_add(c3.getLocal("pp"), c3.i32_const(4))),
          c3.setLocal("j", c3.i32_const(0)),
          c3.block(c3.loop(
            c3.br_if(
              1,
              c3.i32_eq(
                c3.getLocal("j"),
                c3.getLocal("ncoefs")
              )
            ),
            c3.setLocal(
              "pd",
              c3.i32_add(
                c3.getLocal("pres"),
                c3.i32_mul(
                  c3.i32_load(c3.getLocal("pp")),
                  c3.i32_const(n8)
                )
              )
            ),
            c3.setLocal("pp", c3.i32_add(c3.getLocal("pp"), c3.i32_const(4))),
            c3.call(
              prefixField + "_mul",
              c3.getLocal("ps"),
              c3.getLocal("pp"),
              aux
            ),
            c3.call(
              prefixField + "_add",
              aux,
              c3.getLocal("pd"),
              c3.getLocal("pd")
            ),
            c3.setLocal("pp", c3.i32_add(c3.getLocal("pp"), c3.i32_const(n8))),
            c3.setLocal("j", c3.i32_add(c3.getLocal("j"), c3.i32_const(1))),
            c3.br(0)
          )),
          c3.setLocal("ps", c3.i32_add(c3.getLocal("ps"), c3.i32_const(n8))),
          c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    buildZero();
    buildConstructLC();
    module.exportFunction(prefix + "_zero");
    module.exportFunction(prefix + "_constructLC");
    return prefix;
  };
  var build_qap = function buildQAP(module, prefix, prefixField) {
    const n64 = module.modules[prefixField].n64;
    const n8 = n64 * 8;
    function buildBuildABC() {
      const f5 = module.addFunction(prefix + "_buildABC");
      f5.addParam("pCoefs", "i32");
      f5.addParam("nCoefs", "i32");
      f5.addParam("pWitness", "i32");
      f5.addParam("pA", "i32");
      f5.addParam("pB", "i32");
      f5.addParam("pC", "i32");
      f5.addParam("offsetOut", "i32");
      f5.addParam("nOut", "i32");
      f5.addParam("offsetWitness", "i32");
      f5.addParam("nWitness", "i32");
      f5.addLocal("it", "i32");
      f5.addLocal("ita", "i32");
      f5.addLocal("itb", "i32");
      f5.addLocal("last", "i32");
      f5.addLocal("m", "i32");
      f5.addLocal("c", "i32");
      f5.addLocal("s", "i32");
      f5.addLocal("pOut", "i32");
      const c3 = f5.getCodeBuilder();
      const aux = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.setLocal("ita", c3.getLocal("pA")),
        c3.setLocal("itb", c3.getLocal("pB")),
        c3.setLocal(
          "last",
          c3.i32_add(
            c3.getLocal("pA"),
            c3.i32_mul(
              c3.getLocal("nOut"),
              c3.i32_const(n8)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("ita"),
              c3.getLocal("last")
            )
          ),
          c3.call(prefixField + "_zero", c3.getLocal("ita")),
          c3.call(prefixField + "_zero", c3.getLocal("itb")),
          c3.setLocal("ita", c3.i32_add(c3.getLocal("ita"), c3.i32_const(n8))),
          c3.setLocal("itb", c3.i32_add(c3.getLocal("itb"), c3.i32_const(n8))),
          c3.br(0)
        )),
        c3.setLocal("it", c3.getLocal("pCoefs")),
        c3.setLocal(
          "last",
          c3.i32_add(
            c3.getLocal("pCoefs"),
            c3.i32_mul(
              c3.getLocal("nCoefs"),
              c3.i32_const(n8 + 12)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("it"),
              c3.getLocal("last")
            )
          ),
          c3.setLocal(
            "s",
            c3.i32_load(c3.getLocal("it"), 8)
          ),
          c3.if(
            c3.i32_or(
              c3.i32_lt_u(
                c3.getLocal("s"),
                c3.getLocal("offsetWitness")
              ),
              c3.i32_ge_u(
                c3.getLocal("s"),
                c3.i32_add(
                  c3.getLocal("offsetWitness"),
                  c3.getLocal("nWitness")
                )
              )
            ),
            [
              ...c3.setLocal("it", c3.i32_add(c3.getLocal("it"), c3.i32_const(n8 + 12))),
              ...c3.br(1)
            ]
          ),
          c3.setLocal(
            "m",
            c3.i32_load(c3.getLocal("it"))
          ),
          c3.if(
            c3.i32_eq(c3.getLocal("m"), c3.i32_const(0)),
            c3.setLocal("pOut", c3.getLocal("pA")),
            c3.if(
              c3.i32_eq(c3.getLocal("m"), c3.i32_const(1)),
              c3.setLocal("pOut", c3.getLocal("pB")),
              [
                ...c3.setLocal("it", c3.i32_add(c3.getLocal("it"), c3.i32_const(n8 + 12))),
                ...c3.br(1)
              ]
            )
          ),
          c3.setLocal(
            "c",
            c3.i32_load(c3.getLocal("it"), 4)
          ),
          c3.if(
            c3.i32_or(
              c3.i32_lt_u(
                c3.getLocal("c"),
                c3.getLocal("offsetOut")
              ),
              c3.i32_ge_u(
                c3.getLocal("c"),
                c3.i32_add(
                  c3.getLocal("offsetOut"),
                  c3.getLocal("nOut")
                )
              )
            ),
            [
              ...c3.setLocal("it", c3.i32_add(c3.getLocal("it"), c3.i32_const(n8 + 12))),
              ...c3.br(1)
            ]
          ),
          c3.setLocal(
            "pOut",
            c3.i32_add(
              c3.getLocal("pOut"),
              c3.i32_mul(
                c3.i32_sub(
                  c3.getLocal("c"),
                  c3.getLocal("offsetOut")
                ),
                c3.i32_const(n8)
              )
            )
          ),
          c3.call(
            prefixField + "_mul",
            c3.i32_add(
              c3.getLocal("pWitness"),
              c3.i32_mul(
                c3.i32_sub(c3.getLocal("s"), c3.getLocal("offsetWitness")),
                c3.i32_const(n8)
              )
            ),
            c3.i32_add(c3.getLocal("it"), c3.i32_const(12)),
            aux
          ),
          c3.call(
            prefixField + "_add",
            c3.getLocal("pOut"),
            aux,
            c3.getLocal("pOut")
          ),
          c3.setLocal("it", c3.i32_add(c3.getLocal("it"), c3.i32_const(n8 + 12))),
          c3.br(0)
        )),
        c3.setLocal("ita", c3.getLocal("pA")),
        c3.setLocal("itb", c3.getLocal("pB")),
        c3.setLocal("it", c3.getLocal("pC")),
        c3.setLocal(
          "last",
          c3.i32_add(
            c3.getLocal("pA"),
            c3.i32_mul(
              c3.getLocal("nOut"),
              c3.i32_const(n8)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("ita"),
              c3.getLocal("last")
            )
          ),
          c3.call(
            prefixField + "_mul",
            c3.getLocal("ita"),
            c3.getLocal("itb"),
            c3.getLocal("it")
          ),
          c3.setLocal("ita", c3.i32_add(c3.getLocal("ita"), c3.i32_const(n8))),
          c3.setLocal("itb", c3.i32_add(c3.getLocal("itb"), c3.i32_const(n8))),
          c3.setLocal("it", c3.i32_add(c3.getLocal("it"), c3.i32_const(n8))),
          c3.br(0)
        ))
      );
    }
    function buildJoinABC() {
      const f5 = module.addFunction(prefix + "_joinABC");
      f5.addParam("pA", "i32");
      f5.addParam("pB", "i32");
      f5.addParam("pC", "i32");
      f5.addParam("n", "i32");
      f5.addParam("pP", "i32");
      f5.addLocal("ita", "i32");
      f5.addLocal("itb", "i32");
      f5.addLocal("itc", "i32");
      f5.addLocal("itp", "i32");
      f5.addLocal("last", "i32");
      const c3 = f5.getCodeBuilder();
      const aux = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.setLocal("ita", c3.getLocal("pA")),
        c3.setLocal("itb", c3.getLocal("pB")),
        c3.setLocal("itc", c3.getLocal("pC")),
        c3.setLocal("itp", c3.getLocal("pP")),
        c3.setLocal(
          "last",
          c3.i32_add(
            c3.getLocal("pA"),
            c3.i32_mul(
              c3.getLocal("n"),
              c3.i32_const(n8)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("ita"),
              c3.getLocal("last")
            )
          ),
          c3.call(
            prefixField + "_mul",
            c3.getLocal("ita"),
            c3.getLocal("itb"),
            aux
          ),
          c3.call(
            prefixField + "_sub",
            aux,
            c3.getLocal("itc"),
            c3.getLocal("itp")
          ),
          c3.setLocal("ita", c3.i32_add(c3.getLocal("ita"), c3.i32_const(n8))),
          c3.setLocal("itb", c3.i32_add(c3.getLocal("itb"), c3.i32_const(n8))),
          c3.setLocal("itc", c3.i32_add(c3.getLocal("itc"), c3.i32_const(n8))),
          c3.setLocal("itp", c3.i32_add(c3.getLocal("itp"), c3.i32_const(n8))),
          c3.br(0)
        ))
      );
    }
    function buildBatchAdd() {
      const f5 = module.addFunction(prefix + "_batchAdd");
      f5.addParam("pa", "i32");
      f5.addParam("pb", "i32");
      f5.addParam("n", "i32");
      f5.addParam("pr", "i32");
      f5.addLocal("ita", "i32");
      f5.addLocal("itb", "i32");
      f5.addLocal("itr", "i32");
      f5.addLocal("last", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.setLocal("ita", c3.getLocal("pa")),
        c3.setLocal("itb", c3.getLocal("pb")),
        c3.setLocal("itr", c3.getLocal("pr")),
        c3.setLocal(
          "last",
          c3.i32_add(
            c3.getLocal("pa"),
            c3.i32_mul(
              c3.getLocal("n"),
              c3.i32_const(n8)
            )
          )
        ),
        c3.block(c3.loop(
          c3.br_if(
            1,
            c3.i32_eq(
              c3.getLocal("ita"),
              c3.getLocal("last")
            )
          ),
          c3.call(
            prefixField + "_add",
            c3.getLocal("ita"),
            c3.getLocal("itb"),
            c3.getLocal("itr")
          ),
          c3.setLocal("ita", c3.i32_add(c3.getLocal("ita"), c3.i32_const(n8))),
          c3.setLocal("itb", c3.i32_add(c3.getLocal("itb"), c3.i32_const(n8))),
          c3.setLocal("itr", c3.i32_add(c3.getLocal("itr"), c3.i32_const(n8))),
          c3.br(0)
        ))
      );
    }
    buildBuildABC();
    buildJoinABC();
    buildBatchAdd();
    module.exportFunction(prefix + "_buildABC");
    module.exportFunction(prefix + "_joinABC");
    module.exportFunction(prefix + "_batchAdd");
    return prefix;
  };
  var build_applykey = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
    const f5 = module.addFunction(fnName);
    f5.addParam("pIn", "i32");
    f5.addParam("n", "i32");
    f5.addParam("pFirst", "i32");
    f5.addParam("pInc", "i32");
    f5.addParam("pOut", "i32");
    f5.addLocal("pOldFree", "i32");
    f5.addLocal("i", "i32");
    f5.addLocal("pFrom", "i32");
    f5.addLocal("pTo", "i32");
    const c3 = f5.getCodeBuilder();
    const t = c3.i32_const(module.alloc(sizeF));
    f5.addCode(
      c3.setLocal("pFrom", c3.getLocal("pIn")),
      c3.setLocal("pTo", c3.getLocal("pOut"))
    );
    f5.addCode(
      c3.call(
        frPrefix + "_copy",
        c3.getLocal("pFirst"),
        t
      )
    );
    f5.addCode(
      c3.setLocal("i", c3.i32_const(0)),
      c3.block(c3.loop(
        c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.getLocal("n"))),
        c3.call(
          opGtimesF,
          c3.getLocal("pFrom"),
          t,
          c3.getLocal("pTo")
        ),
        c3.setLocal("pFrom", c3.i32_add(c3.getLocal("pFrom"), c3.i32_const(sizeGIn))),
        c3.setLocal("pTo", c3.i32_add(c3.getLocal("pTo"), c3.i32_const(sizeGOut))),
        c3.call(
          frPrefix + "_mul",
          t,
          c3.getLocal("pInc"),
          t
        ),
        c3.setLocal("i", c3.i32_add(c3.getLocal("i"), c3.i32_const(1))),
        c3.br(0)
      ))
    );
    module.exportFunction(fnName);
  };
  var utils$2 = utils$6;
  var buildF1m$1 = build_f1m;
  var buildF1$1 = build_f1;
  var buildF2m$1 = build_f2m;
  var buildF3m$1 = build_f3m;
  var buildCurve$1 = build_curve_jacobian_a0;
  var buildFFT$2 = build_fft;
  var buildPol$1 = build_pol;
  var buildQAP$1 = build_qap;
  var buildApplyKey$1 = build_applykey;
  var { bitLength: bitLength$2, modInv, isOdd: isOdd$1, isNegative: isNegative$2 } = bigint;
  var build_bn128 = function buildBN128(module, _prefix) {
    const prefix = _prefix || "bn128";
    if (module.modules[prefix])
      return prefix;
    const q5 = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
    const r = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
    const n64 = Math.floor((bitLength$2(q5 - 1n) - 1) / 64) + 1;
    const n8 = n64 * 8;
    const frsize = n8;
    const f1size = n8;
    const f2size = f1size * 2;
    const ftsize = f1size * 12;
    const pr2 = module.alloc(utils$2.bigInt2BytesLE(r, frsize));
    const f1mPrefix = buildF1m$1(module, q5, "f1m");
    buildF1$1(module, r, "fr", "frm");
    const pG1b = module.alloc(utils$2.bigInt2BytesLE(toMontgomery(3n), f1size));
    const g1mPrefix = buildCurve$1(module, "g1m", "f1m", pG1b);
    buildFFT$2(module, "frm", "frm", "frm", "frm_mul");
    buildPol$1(module, "pol", "frm");
    buildQAP$1(module, "qap", "frm");
    const f2mPrefix = buildF2m$1(module, "f1m_neg", "f2m", "f1m");
    const pG2b = module.alloc([
      ...utils$2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
    ]);
    const g2mPrefix = buildCurve$1(module, "g2m", "f2m", pG2b);
    function buildGTimesFr(fnName, opMul) {
      const f5 = module.addFunction(fnName);
      f5.addParam("pG", "i32");
      f5.addParam("pFr", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8));
      f5.addCode(
        c3.call("frm_fromMontgomery", c3.getLocal("pFr"), AUX),
        c3.call(
          opMul,
          c3.getLocal("pG"),
          AUX,
          c3.i32_const(n8),
          c3.getLocal("pr")
        )
      );
      module.exportFunction(fnName);
    }
    buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
    buildFFT$2(module, "g1m", "g1m", "frm", "g1m_timesFr");
    buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
    buildFFT$2(module, "g2m", "g2m", "frm", "g2m_timesFr");
    buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
    buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
    buildApplyKey$1(module, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
    buildApplyKey$1(module, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
    buildApplyKey$1(module, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
    buildApplyKey$1(module, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
    buildApplyKey$1(module, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
    function toMontgomery(a4) {
      return BigInt(a4) * (1n << BigInt(f1size * 8)) % q5;
    }
    const G1gen = [
      1n,
      2n,
      1n
    ];
    const pG1gen = module.alloc(
      [
        ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
      ]
    );
    const G1zero = [
      0n,
      1n,
      0n
    ];
    const pG1zero = module.alloc(
      [
        ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
      ]
    );
    const G2gen = [
      [
        10857046999023057135944570762232829481370756359578518086990519993285655852781n,
        11559732032986387107991004021392285783925812861821192530917403151452391805634n
      ],
      [
        8495653923123431417604973247489272438418190587263600148770280649306958101930n,
        4082367875863433681332203403145435568316851327593401208105741076214120093531n
      ],
      [
        1n,
        0n
      ]
    ];
    const pG2gen = module.alloc(
      [
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
      ]
    );
    const G2zero = [
      [
        0n,
        0n
      ],
      [
        1n,
        0n
      ],
      [
        0n,
        0n
      ]
    ];
    const pG2zero = module.alloc(
      [
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
      ]
    );
    const pOneT = module.alloc([
      ...utils$2.bigInt2BytesLE(toMontgomery(1), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size)
    ]);
    const pNonResidueF6 = module.alloc([
      ...utils$2.bigInt2BytesLE(toMontgomery(9), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(1), f1size)
    ]);
    const pTwoInv = module.alloc([
      ...utils$2.bigInt2BytesLE(toMontgomery(modInv(2n, q5)), f1size),
      ...utils$2.bigInt2BytesLE(0n, f1size)
    ]);
    const pAltBn128Twist = pNonResidueF6;
    const pTwistCoefB = module.alloc([
      ...utils$2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
      ...utils$2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
    ]);
    function build_mulNR6() {
      const f5 = module.addFunction(prefix + "_mulNR6");
      f5.addParam("x", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(
          f2mPrefix + "_mul",
          c3.i32_const(pNonResidueF6),
          c3.getLocal("x"),
          c3.getLocal("pr")
        )
      );
    }
    build_mulNR6();
    const f6mPrefix = buildF3m$1(module, prefix + "_mulNR6", "f6m", "f2m");
    function build_mulNR12() {
      const f5 = module.addFunction(prefix + "_mulNR12");
      f5.addParam("x", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(
          f2mPrefix + "_mul",
          c3.i32_const(pNonResidueF6),
          c3.i32_add(c3.getLocal("x"), c3.i32_const(n8 * 4)),
          c3.getLocal("pr")
        ),
        c3.call(
          f2mPrefix + "_copy",
          c3.getLocal("x"),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 2))
        ),
        c3.call(
          f2mPrefix + "_copy",
          c3.i32_add(c3.getLocal("x"), c3.i32_const(n8 * 2)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8 * 4))
        )
      );
    }
    build_mulNR12();
    const ftmPrefix = buildF2m$1(module, prefix + "_mulNR12", "ftm", f6mPrefix);
    const ateLoopCount = 29793968203157093288n;
    const ateLoopBitBytes = bits2(ateLoopCount);
    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);
    const ateCoefSize = 3 * f2size;
    const ateNDblCoefs = ateLoopBitBytes.length - 1;
    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b7) => acc + (b7 != 0 ? 1 : 0), 0);
    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
    const prePSize = 3 * 2 * n8;
    const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
    module.modules[prefix] = {
      n64,
      pG1gen,
      pG1zero,
      pG1b,
      pG2gen,
      pG2zero,
      pG2b,
      pq: module.modules["f1m"].pq,
      pr: pr2,
      pOneT,
      prePSize,
      preQSize,
      r: r.toString(),
      q: q5.toString()
    };
    const finalExpZ = 4965661367192848881n;
    function naf2(n4) {
      let E4 = n4;
      const res = [];
      while (E4 > 0n) {
        if (isOdd$1(E4)) {
          const z6 = 2 - Number(E4 % 4n);
          res.push(z6);
          E4 = E4 - BigInt(z6);
        } else {
          res.push(0);
        }
        E4 = E4 >> 1n;
      }
      return res;
    }
    function bits2(n4) {
      let E4 = n4;
      const res = [];
      while (E4 > 0n) {
        if (isOdd$1(E4)) {
          res.push(1);
        } else {
          res.push(0);
        }
        E4 = E4 >> 1n;
      }
      return res;
    }
    function buildPrepareG1() {
      const f5 = module.addFunction(prefix + "_prepareG1");
      f5.addParam("pP", "i32");
      f5.addParam("ppreP", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(g1mPrefix + "_normalize", c3.getLocal("pP"), c3.getLocal("ppreP"))
      );
    }
    function buildPrepAddStep() {
      const f5 = module.addFunction(prefix + "_prepAddStep");
      f5.addParam("pQ", "i32");
      f5.addParam("pR", "i32");
      f5.addParam("pCoef", "i32");
      const c3 = f5.getCodeBuilder();
      const X22 = c3.getLocal("pQ");
      const Y22 = c3.i32_add(c3.getLocal("pQ"), c3.i32_const(f2size));
      const X1 = c3.getLocal("pR");
      const Y1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f2size));
      const Z1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(2 * f2size));
      const ELL_0 = c3.getLocal("pCoef");
      const ELL_VW = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(f2size));
      const ELL_VV = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(2 * f2size));
      const D4 = ELL_VW;
      const E4 = c3.i32_const(module.alloc(f2size));
      const F4 = c3.i32_const(module.alloc(f2size));
      const G7 = c3.i32_const(module.alloc(f2size));
      const H4 = c3.i32_const(module.alloc(f2size));
      const I5 = c3.i32_const(module.alloc(f2size));
      const J4 = c3.i32_const(module.alloc(f2size));
      const AUX = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", X22, Z1, D4),
        c3.call(f2mPrefix + "_sub", X1, D4, D4),
        c3.call(f2mPrefix + "_mul", Y22, Z1, E4),
        c3.call(f2mPrefix + "_sub", Y1, E4, E4),
        c3.call(f2mPrefix + "_square", D4, F4),
        c3.call(f2mPrefix + "_square", E4, G7),
        c3.call(f2mPrefix + "_mul", D4, F4, H4),
        c3.call(f2mPrefix + "_mul", X1, F4, I5),
        c3.call(f2mPrefix + "_add", I5, I5, AUX),
        c3.call(f2mPrefix + "_mul", Z1, G7, J4),
        c3.call(f2mPrefix + "_add", H4, J4, J4),
        c3.call(f2mPrefix + "_sub", J4, AUX, J4),
        c3.call(f2mPrefix + "_mul", D4, J4, X1),
        c3.call(f2mPrefix + "_mul", H4, Y1, Y1),
        c3.call(f2mPrefix + "_sub", I5, J4, AUX),
        c3.call(f2mPrefix + "_mul", E4, AUX, AUX),
        c3.call(f2mPrefix + "_sub", AUX, Y1, Y1),
        c3.call(f2mPrefix + "_mul", Z1, H4, Z1),
        c3.call(f2mPrefix + "_mul", D4, Y22, AUX),
        c3.call(f2mPrefix + "_mul", E4, X22, ELL_0),
        c3.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
        c3.call(f2mPrefix + "_mul", ELL_0, c3.i32_const(pAltBn128Twist), ELL_0),
        c3.call(f2mPrefix + "_neg", E4, ELL_VV)
      );
    }
    function buildPrepDoubleStep() {
      const f5 = module.addFunction(prefix + "_prepDblStep");
      f5.addParam("pR", "i32");
      f5.addParam("pCoef", "i32");
      const c3 = f5.getCodeBuilder();
      const X1 = c3.getLocal("pR");
      const Y1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f2size));
      const Z1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(2 * f2size));
      const ELL_0 = c3.getLocal("pCoef");
      const ELL_VW = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(f2size));
      const ELL_VV = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(2 * f2size));
      const A5 = c3.i32_const(module.alloc(f2size));
      const B6 = c3.i32_const(module.alloc(f2size));
      const C5 = c3.i32_const(module.alloc(f2size));
      const D4 = c3.i32_const(module.alloc(f2size));
      const E4 = c3.i32_const(module.alloc(f2size));
      const F4 = c3.i32_const(module.alloc(f2size));
      const G7 = c3.i32_const(module.alloc(f2size));
      const H4 = c3.i32_const(module.alloc(f2size));
      const I5 = c3.i32_const(module.alloc(f2size));
      const J4 = c3.i32_const(module.alloc(f2size));
      const E22 = c3.i32_const(module.alloc(f2size));
      const AUX = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", Y1, c3.i32_const(pTwoInv), A5),
        c3.call(f2mPrefix + "_mul", X1, A5, A5),
        c3.call(f2mPrefix + "_square", Y1, B6),
        c3.call(f2mPrefix + "_square", Z1, C5),
        c3.call(f2mPrefix + "_add", C5, C5, D4),
        c3.call(f2mPrefix + "_add", D4, C5, D4),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pTwistCoefB), D4, E4),
        c3.call(f2mPrefix + "_add", E4, E4, F4),
        c3.call(f2mPrefix + "_add", E4, F4, F4),
        c3.call(f2mPrefix + "_add", B6, F4, G7),
        c3.call(f2mPrefix + "_mul", G7, c3.i32_const(pTwoInv), G7),
        c3.call(f2mPrefix + "_add", B6, C5, AUX),
        c3.call(f2mPrefix + "_add", Y1, Z1, H4),
        c3.call(f2mPrefix + "_square", H4, H4),
        c3.call(f2mPrefix + "_sub", H4, AUX, H4),
        c3.call(f2mPrefix + "_sub", E4, B6, I5),
        c3.call(f2mPrefix + "_square", X1, J4),
        c3.call(f2mPrefix + "_square", E4, E22),
        c3.call(f2mPrefix + "_sub", B6, F4, AUX),
        c3.call(f2mPrefix + "_mul", A5, AUX, X1),
        c3.call(f2mPrefix + "_add", E22, E22, AUX),
        c3.call(f2mPrefix + "_add", E22, AUX, AUX),
        c3.call(f2mPrefix + "_square", G7, Y1),
        c3.call(f2mPrefix + "_sub", Y1, AUX, Y1),
        c3.call(f2mPrefix + "_mul", B6, H4, Z1),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pAltBn128Twist), I5, ELL_0),
        c3.call(f2mPrefix + "_neg", H4, ELL_VW),
        c3.call(f2mPrefix + "_add", J4, J4, ELL_VV),
        c3.call(f2mPrefix + "_add", J4, ELL_VV, ELL_VV)
      );
    }
    function buildMulByQ() {
      const f5 = module.addFunction(prefix + "_mulByQ");
      f5.addParam("p1", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("p1");
      const y5 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(f2size));
      const z6 = c3.i32_add(c3.getLocal("p1"), c3.i32_const(f2size * 2));
      const x32 = c3.getLocal("pr");
      const y32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(f2size));
      const z32 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(f2size * 2));
      const MulByQX = c3.i32_const(module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
      ]));
      const MulByQY = c3.i32_const(module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
      ]));
      f5.addCode(
        c3.call(f2mPrefix + "_conjugate", x6, x32),
        c3.call(f2mPrefix + "_mul", MulByQX, x32, x32),
        c3.call(f2mPrefix + "_conjugate", y5, y32),
        c3.call(f2mPrefix + "_mul", MulByQY, y32, y32),
        c3.call(f2mPrefix + "_conjugate", z6, z32)
      );
    }
    function buildPrepareG2() {
      buildMulByQ();
      const f5 = module.addFunction(prefix + "_prepareG2");
      f5.addParam("pQ", "i32");
      f5.addParam("ppreQ", "i32");
      f5.addLocal("pCoef", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const QX = c3.getLocal("pQ");
      const pR = module.alloc(f2size * 3);
      const R5 = c3.i32_const(pR);
      const RX = c3.i32_const(pR);
      const RY = c3.i32_const(pR + f2size);
      const RZ = c3.i32_const(pR + 2 * f2size);
      const cQX = c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(0));
      const cQY = c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(f2size));
      const pQ1 = module.alloc(f2size * 3);
      const Q1 = c3.i32_const(pQ1);
      const pQ2 = module.alloc(f2size * 3);
      const Q22 = c3.i32_const(pQ2);
      const Q2Y = c3.i32_const(pQ2 + f2size);
      f5.addCode(
        c3.call(g2mPrefix + "_normalize", QX, cQX),
        c3.call(f2mPrefix + "_copy", cQX, RX),
        c3.call(f2mPrefix + "_copy", cQY, RY),
        c3.call(f2mPrefix + "_one", RZ)
      );
      f5.addCode(
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(f2size * 3))),
        c3.setLocal("i", c3.i32_const(ateLoopBitBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(prefix + "_prepDblStep", R5, c3.getLocal("pCoef")),
          c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
          c3.if(
            c3.i32_load8_s(c3.getLocal("i"), pAteLoopBitBytes),
            [
              ...c3.call(prefix + "_prepAddStep", cQX, R5, c3.getLocal("pCoef")),
              ...c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
            ]
          ),
          c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
      f5.addCode(
        c3.call(prefix + "_mulByQ", cQX, Q1),
        c3.call(prefix + "_mulByQ", Q1, Q22)
      );
      f5.addCode(
        c3.call(f2mPrefix + "_neg", Q2Y, Q2Y),
        c3.call(prefix + "_prepAddStep", Q1, R5, c3.getLocal("pCoef")),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
        c3.call(prefix + "_prepAddStep", Q22, R5, c3.getLocal("pCoef")),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
      );
    }
    function buildMulBy024Old() {
      const f5 = module.addFunction(prefix + "__mulBy024Old");
      f5.addParam("pEll0", "i32");
      f5.addParam("pEllVW", "i32");
      f5.addParam("pEllVV", "i32");
      f5.addParam("pR", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("pEll0");
      const x22 = c3.getLocal("pEllVV");
      const x42 = c3.getLocal("pEllVW");
      const z0 = c3.getLocal("pR");
      const pAUX12 = module.alloc(ftsize);
      const AUX12 = c3.i32_const(pAUX12);
      const AUX12_0 = c3.i32_const(pAUX12);
      const AUX12_2 = c3.i32_const(pAUX12 + f2size);
      const AUX12_4 = c3.i32_const(pAUX12 + f2size * 2);
      const AUX12_6 = c3.i32_const(pAUX12 + f2size * 3);
      const AUX12_8 = c3.i32_const(pAUX12 + f2size * 4);
      const AUX12_10 = c3.i32_const(pAUX12 + f2size * 5);
      f5.addCode(
        c3.call(f2mPrefix + "_copy", x0, AUX12_0),
        c3.call(f2mPrefix + "_zero", AUX12_2),
        c3.call(f2mPrefix + "_copy", x22, AUX12_4),
        c3.call(f2mPrefix + "_zero", AUX12_6),
        c3.call(f2mPrefix + "_copy", x42, AUX12_8),
        c3.call(f2mPrefix + "_zero", AUX12_10),
        c3.call(ftmPrefix + "_mul", AUX12, z0, z0)
      );
    }
    function buildMulBy024() {
      const f5 = module.addFunction(prefix + "__mulBy024");
      f5.addParam("pEll0", "i32");
      f5.addParam("pEllVW", "i32");
      f5.addParam("pEllVV", "i32");
      f5.addParam("pR", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("pEll0");
      const x22 = c3.getLocal("pEllVV");
      const x42 = c3.getLocal("pEllVW");
      const z0 = c3.getLocal("pR");
      const z1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(2 * n8));
      const z22 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(4 * n8));
      const z32 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(6 * n8));
      const z42 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(8 * n8));
      const z52 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(10 * n8));
      const t0 = c3.i32_const(module.alloc(f2size));
      const t1 = c3.i32_const(module.alloc(f2size));
      const t2 = c3.i32_const(module.alloc(f2size));
      const s0 = c3.i32_const(module.alloc(f2size));
      const T32 = c3.i32_const(module.alloc(f2size));
      const T42 = c3.i32_const(module.alloc(f2size));
      const D0 = c3.i32_const(module.alloc(f2size));
      const D22 = c3.i32_const(module.alloc(f2size));
      const D4 = c3.i32_const(module.alloc(f2size));
      const S12 = c3.i32_const(module.alloc(f2size));
      const AUX = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", z0, x0, D0),
        c3.call(f2mPrefix + "_mul", z22, x22, D22),
        c3.call(f2mPrefix + "_mul", z42, x42, D4),
        c3.call(f2mPrefix + "_add", z0, z42, t2),
        c3.call(f2mPrefix + "_add", z0, z22, t1),
        c3.call(f2mPrefix + "_add", z1, z32, s0),
        c3.call(f2mPrefix + "_add", s0, z52, s0),
        c3.call(f2mPrefix + "_mul", z1, x22, S12),
        c3.call(f2mPrefix + "_add", S12, D4, T32),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), T32, T42),
        c3.call(f2mPrefix + "_add", T42, D0, z0),
        c3.call(f2mPrefix + "_mul", z52, x42, T32),
        c3.call(f2mPrefix + "_add", S12, T32, S12),
        c3.call(f2mPrefix + "_add", T32, D22, T32),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), T32, T42),
        c3.call(f2mPrefix + "_mul", z1, x0, T32),
        c3.call(f2mPrefix + "_add", S12, T32, S12),
        c3.call(f2mPrefix + "_add", T42, T32, z1),
        c3.call(f2mPrefix + "_add", x0, x22, t0),
        c3.call(f2mPrefix + "_mul", t1, t0, T32),
        c3.call(f2mPrefix + "_add", D0, D22, AUX),
        c3.call(f2mPrefix + "_sub", T32, AUX, T32),
        c3.call(f2mPrefix + "_mul", z32, x42, T42),
        c3.call(f2mPrefix + "_add", S12, T42, S12),
        c3.call(f2mPrefix + "_add", z22, z42, t0),
        c3.call(f2mPrefix + "_add", T32, T42, z22),
        c3.call(f2mPrefix + "_add", x22, x42, t1),
        c3.call(f2mPrefix + "_mul", t1, t0, T32),
        c3.call(f2mPrefix + "_add", D22, D4, AUX),
        c3.call(f2mPrefix + "_sub", T32, AUX, T32),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), T32, T42),
        c3.call(f2mPrefix + "_mul", z32, x0, T32),
        c3.call(f2mPrefix + "_add", S12, T32, S12),
        c3.call(f2mPrefix + "_add", T42, T32, z32),
        c3.call(f2mPrefix + "_mul", z52, x22, T32),
        c3.call(f2mPrefix + "_add", S12, T32, S12),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), T32, T42),
        c3.call(f2mPrefix + "_add", x0, x42, t0),
        c3.call(f2mPrefix + "_mul", t2, t0, T32),
        c3.call(f2mPrefix + "_add", D0, D4, AUX),
        c3.call(f2mPrefix + "_sub", T32, AUX, T32),
        c3.call(f2mPrefix + "_add", T42, T32, z42),
        c3.call(f2mPrefix + "_add", x0, x22, t0),
        c3.call(f2mPrefix + "_add", t0, x42, t0),
        c3.call(f2mPrefix + "_mul", s0, t0, T32),
        c3.call(f2mPrefix + "_sub", T32, S12, z52)
      );
    }
    function buildMillerLoop() {
      const f5 = module.addFunction(prefix + "_millerLoop");
      f5.addParam("ppreP", "i32");
      f5.addParam("ppreQ", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("pCoef", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const preP_PX = c3.getLocal("ppreP");
      const preP_PY = c3.i32_add(c3.getLocal("ppreP"), c3.i32_const(f1size));
      const ELL_0 = c3.getLocal("pCoef");
      const ELL_VW = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(f2size));
      const ELL_VV = c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(2 * f2size));
      const pVW = module.alloc(f2size);
      const VW = c3.i32_const(pVW);
      const pVV = module.alloc(f2size);
      const VV = c3.i32_const(pVV);
      const F4 = c3.getLocal("r");
      f5.addCode(
        c3.call(ftmPrefix + "_one", F4),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(f2size * 3))),
        c3.setLocal("i", c3.i32_const(ateLoopBitBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(ftmPrefix + "_square", F4, F4),
          c3.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c3.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c3.call(prefix + "__mulBy024", ELL_0, VW, VV, F4),
          c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
          c3.if(
            c3.i32_load8_s(c3.getLocal("i"), pAteLoopBitBytes),
            [
              ...c3.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
              ...c3.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
              ...c3.call(prefix + "__mulBy024", ELL_0, VW, VV, F4),
              ...c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
            ]
          ),
          c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
      f5.addCode(
        c3.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
        c3.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
        c3.call(prefix + "__mulBy024", ELL_0, VW, VV, F4),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
        c3.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
        c3.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
        c3.call(prefix + "__mulBy024", ELL_0, VW, VV, F4),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
      );
    }
    function buildFrobeniusMap(n4) {
      const F12 = [
        [
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n]
        ],
        [
          [1n, 0n],
          [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
          [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
          [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
          [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
          [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
          [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
          [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
          [2203960485148121921418603742825762020974279258880205651966n, 0n],
          [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
          [2203960485148121921418603742825762020974279258880205651967n, 0n],
          [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
        ]
      ];
      const F6 = [
        [
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n]
        ],
        [
          [1n, 0n],
          [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
          [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
          [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
          [2203960485148121921418603742825762020974279258880205651966n, 0n],
          [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
        ],
        [
          [1n, 0n],
          [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
          [2203960485148121921418603742825762020974279258880205651966n, 0n],
          [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
          [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
          [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
        ]
      ];
      const f5 = module.addFunction(prefix + "__frobeniusMap" + n4);
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < 6; i4++) {
        const X5 = i4 == 0 ? c3.getLocal("x") : c3.i32_add(c3.getLocal("x"), c3.i32_const(i4 * f2size));
        const Xc0 = X5;
        const Xc1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(i4 * f2size + f1size));
        const R5 = i4 == 0 ? c3.getLocal("r") : c3.i32_add(c3.getLocal("r"), c3.i32_const(i4 * f2size));
        const Rc0 = R5;
        const Rc1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(i4 * f2size + f1size));
        const coef = mul2(F12[Math.floor(i4 / 3)][n4 % 12], F6[i4 % 3][n4 % 6]);
        const pCoef = module.alloc([
          ...utils$2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
          ...utils$2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
        ]);
        if (n4 % 2 == 1) {
          f5.addCode(
            c3.call(f1mPrefix + "_copy", Xc0, Rc0),
            c3.call(f1mPrefix + "_neg", Xc1, Rc1),
            c3.call(f2mPrefix + "_mul", R5, c3.i32_const(pCoef), R5)
          );
        } else {
          f5.addCode(c3.call(f2mPrefix + "_mul", X5, c3.i32_const(pCoef), R5));
        }
      }
      function mul2(a4, b7) {
        const ac0 = BigInt(a4[0]);
        const ac1 = BigInt(a4[1]);
        const bc0 = BigInt(b7[0]);
        const bc1 = BigInt(b7[1]);
        const res = [
          (ac0 * bc0 - ac1 * bc1) % q5,
          (ac0 * bc1 + ac1 * bc0) % q5
        ];
        if (isNegative$2(res[0]))
          res[0] = res[0] + q5;
        return res;
      }
    }
    function buildFinalExponentiationFirstChunk() {
      const f5 = module.addFunction(prefix + "__finalExponentiationFirstChunk");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const elt = c3.getLocal("x");
      const eltC0 = elt;
      const eltC1 = c3.i32_add(elt, c3.i32_const(n8 * 6));
      const r2 = c3.getLocal("r");
      const pA = module.alloc(ftsize);
      const A5 = c3.i32_const(pA);
      const Ac0 = A5;
      const Ac1 = c3.i32_const(pA + n8 * 6);
      const B6 = c3.i32_const(module.alloc(ftsize));
      const C5 = c3.i32_const(module.alloc(ftsize));
      const D4 = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(f6mPrefix + "_copy", eltC0, Ac0),
        c3.call(f6mPrefix + "_neg", eltC1, Ac1),
        c3.call(ftmPrefix + "_inverse", elt, B6),
        c3.call(ftmPrefix + "_mul", A5, B6, C5),
        c3.call(prefix + "__frobeniusMap2", C5, D4),
        c3.call(ftmPrefix + "_mul", C5, D4, r2)
      );
    }
    function buildCyclotomicSquare() {
      const f5 = module.addFunction(prefix + "__cyclotomicSquare");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x42 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f2size));
      const x32 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f2size));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(3 * f2size));
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(4 * f2size));
      const x52 = c3.i32_add(c3.getLocal("x"), c3.i32_const(5 * f2size));
      const r0 = c3.getLocal("r");
      const r4 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f2size));
      const r3 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f2size));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(3 * f2size));
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(4 * f2size));
      const r5 = c3.i32_add(c3.getLocal("r"), c3.i32_const(5 * f2size));
      const t0 = c3.i32_const(module.alloc(f2size));
      const t1 = c3.i32_const(module.alloc(f2size));
      const t2 = c3.i32_const(module.alloc(f2size));
      const t3 = c3.i32_const(module.alloc(f2size));
      const t4 = c3.i32_const(module.alloc(f2size));
      const t5 = c3.i32_const(module.alloc(f2size));
      const tmp = c3.i32_const(module.alloc(f2size));
      const AUX = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", x0, x1, tmp),
        c3.call(f2mPrefix + "_mul", x1, c3.i32_const(pNonResidueF6), t0),
        c3.call(f2mPrefix + "_add", x0, t0, t0),
        c3.call(f2mPrefix + "_add", x0, x1, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t0, t0),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t0, AUX, t0),
        c3.call(f2mPrefix + "_add", tmp, tmp, t1),
        c3.call(f2mPrefix + "_mul", x22, x32, tmp),
        c3.call(f2mPrefix + "_mul", x32, c3.i32_const(pNonResidueF6), t2),
        c3.call(f2mPrefix + "_add", x22, t2, t2),
        c3.call(f2mPrefix + "_add", x22, x32, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t2, t2),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t2, AUX, t2),
        c3.call(f2mPrefix + "_add", tmp, tmp, t3),
        c3.call(f2mPrefix + "_mul", x42, x52, tmp),
        c3.call(f2mPrefix + "_mul", x52, c3.i32_const(pNonResidueF6), t4),
        c3.call(f2mPrefix + "_add", x42, t4, t4),
        c3.call(f2mPrefix + "_add", x42, x52, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t4, t4),
        c3.call(f2mPrefix + "_mul", c3.i32_const(pNonResidueF6), tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t4, AUX, t4),
        c3.call(f2mPrefix + "_add", tmp, tmp, t5),
        c3.call(f2mPrefix + "_sub", t0, x0, r0),
        c3.call(f2mPrefix + "_add", r0, r0, r0),
        c3.call(f2mPrefix + "_add", t0, r0, r0),
        c3.call(f2mPrefix + "_add", t1, x1, r1),
        c3.call(f2mPrefix + "_add", r1, r1, r1),
        c3.call(f2mPrefix + "_add", t1, r1, r1),
        c3.call(f2mPrefix + "_mul", t5, c3.i32_const(pAltBn128Twist), AUX),
        c3.call(f2mPrefix + "_add", AUX, x22, r2),
        c3.call(f2mPrefix + "_add", r2, r2, r2),
        c3.call(f2mPrefix + "_add", AUX, r2, r2),
        c3.call(f2mPrefix + "_sub", t4, x32, r3),
        c3.call(f2mPrefix + "_add", r3, r3, r3),
        c3.call(f2mPrefix + "_add", t4, r3, r3),
        c3.call(f2mPrefix + "_sub", t2, x42, r4),
        c3.call(f2mPrefix + "_add", r4, r4, r4),
        c3.call(f2mPrefix + "_add", t2, r4, r4),
        c3.call(f2mPrefix + "_add", t3, x52, r5),
        c3.call(f2mPrefix + "_add", r5, r5, r5),
        c3.call(f2mPrefix + "_add", t3, r5, r5)
      );
    }
    function buildCyclotomicExp(exponent, fnName) {
      const exponentNafBytes = naf2(exponent).map((b7) => b7 == -1 ? 255 : b7);
      const pExponentNafBytes = module.alloc(exponentNafBytes);
      const f5 = module.addFunction(prefix + "__cyclotomicExp_" + fnName);
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("bit", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("x");
      const res = c3.getLocal("r");
      const inverse = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(ftmPrefix + "_conjugate", x6, inverse),
        c3.call(ftmPrefix + "_one", res),
        c3.if(
          c3.teeLocal("bit", c3.i32_load8_s(c3.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
          c3.if(
            c3.i32_eq(
              c3.getLocal("bit"),
              c3.i32_const(1)
            ),
            c3.call(ftmPrefix + "_mul", res, x6, res),
            c3.call(ftmPrefix + "_mul", res, inverse, res)
          )
        ),
        c3.setLocal("i", c3.i32_const(exponentNafBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(prefix + "__cyclotomicSquare", res, res),
          c3.if(
            c3.teeLocal("bit", c3.i32_load8_s(c3.getLocal("i"), pExponentNafBytes)),
            c3.if(
              c3.i32_eq(
                c3.getLocal("bit"),
                c3.i32_const(1)
              ),
              c3.call(ftmPrefix + "_mul", res, x6, res),
              c3.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildFinalExponentiationLastChunk() {
      buildCyclotomicSquare();
      buildCyclotomicExp(finalExpZ, "w0");
      const f5 = module.addFunction(prefix + "__finalExponentiationLastChunk");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const elt = c3.getLocal("x");
      const result = c3.getLocal("r");
      const A5 = c3.i32_const(module.alloc(ftsize));
      const B6 = c3.i32_const(module.alloc(ftsize));
      const C5 = c3.i32_const(module.alloc(ftsize));
      const D4 = c3.i32_const(module.alloc(ftsize));
      const E4 = c3.i32_const(module.alloc(ftsize));
      const F4 = c3.i32_const(module.alloc(ftsize));
      const G7 = c3.i32_const(module.alloc(ftsize));
      const H4 = c3.i32_const(module.alloc(ftsize));
      const I5 = c3.i32_const(module.alloc(ftsize));
      const J4 = c3.i32_const(module.alloc(ftsize));
      const K4 = c3.i32_const(module.alloc(ftsize));
      const L4 = c3.i32_const(module.alloc(ftsize));
      const M6 = c3.i32_const(module.alloc(ftsize));
      const N10 = c3.i32_const(module.alloc(ftsize));
      const O3 = c3.i32_const(module.alloc(ftsize));
      const P5 = c3.i32_const(module.alloc(ftsize));
      const Q5 = c3.i32_const(module.alloc(ftsize));
      const R5 = c3.i32_const(module.alloc(ftsize));
      const S6 = c3.i32_const(module.alloc(ftsize));
      const T6 = c3.i32_const(module.alloc(ftsize));
      const U6 = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(prefix + "__cyclotomicExp_w0", elt, A5),
        c3.call(ftmPrefix + "_conjugate", A5, A5),
        c3.call(prefix + "__cyclotomicSquare", A5, B6),
        c3.call(prefix + "__cyclotomicSquare", B6, C5),
        c3.call(ftmPrefix + "_mul", C5, B6, D4),
        c3.call(prefix + "__cyclotomicExp_w0", D4, E4),
        c3.call(ftmPrefix + "_conjugate", E4, E4),
        c3.call(prefix + "__cyclotomicSquare", E4, F4),
        c3.call(prefix + "__cyclotomicExp_w0", F4, G7),
        c3.call(ftmPrefix + "_conjugate", G7, G7),
        c3.call(ftmPrefix + "_conjugate", D4, H4),
        c3.call(ftmPrefix + "_conjugate", G7, I5),
        c3.call(ftmPrefix + "_mul", I5, E4, J4),
        c3.call(ftmPrefix + "_mul", J4, H4, K4),
        c3.call(ftmPrefix + "_mul", K4, B6, L4),
        c3.call(ftmPrefix + "_mul", K4, E4, M6),
        c3.call(ftmPrefix + "_mul", M6, elt, N10),
        c3.call(prefix + "__frobeniusMap1", L4, O3),
        c3.call(ftmPrefix + "_mul", O3, N10, P5),
        c3.call(prefix + "__frobeniusMap2", K4, Q5),
        c3.call(ftmPrefix + "_mul", Q5, P5, R5),
        c3.call(ftmPrefix + "_conjugate", elt, S6),
        c3.call(ftmPrefix + "_mul", S6, L4, T6),
        c3.call(prefix + "__frobeniusMap3", T6, U6),
        c3.call(ftmPrefix + "_mul", U6, R5, result)
      );
    }
    function buildFinalExponentiation() {
      buildFinalExponentiationFirstChunk();
      buildFinalExponentiationLastChunk();
      const f5 = module.addFunction(prefix + "_finalExponentiation");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const elt = c3.getLocal("x");
      const result = c3.getLocal("r");
      const eltToFirstChunk = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(prefix + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
        c3.call(prefix + "__finalExponentiationLastChunk", eltToFirstChunk, result)
      );
    }
    function buildFinalExponentiationOld() {
      const f5 = module.addFunction(prefix + "_finalExponentiationOld");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
      const pExponent = module.alloc(utils$2.bigInt2BytesLE(exponent, 352));
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(ftmPrefix + "_exp", c3.getLocal("x"), c3.i32_const(pExponent), c3.i32_const(352), c3.getLocal("r"))
      );
    }
    const pPreP = module.alloc(prePSize);
    const pPreQ = module.alloc(preQSize);
    function buildPairingEquation(nPairings) {
      const f5 = module.addFunction(prefix + "_pairingEq" + nPairings);
      for (let i4 = 0; i4 < nPairings; i4++) {
        f5.addParam("p_" + i4, "i32");
        f5.addParam("q_" + i4, "i32");
      }
      f5.addParam("c", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const resT = c3.i32_const(module.alloc(ftsize));
      const auxT = c3.i32_const(module.alloc(ftsize));
      f5.addCode(c3.call(ftmPrefix + "_one", resT));
      for (let i4 = 0; i4 < nPairings; i4++) {
        f5.addCode(c3.call(prefix + "_prepareG1", c3.getLocal("p_" + i4), c3.i32_const(pPreP)));
        f5.addCode(c3.call(prefix + "_prepareG2", c3.getLocal("q_" + i4), c3.i32_const(pPreQ)));
        f5.addCode(c3.call(prefix + "_millerLoop", c3.i32_const(pPreP), c3.i32_const(pPreQ), auxT));
        f5.addCode(c3.call(ftmPrefix + "_mul", resT, auxT, resT));
      }
      f5.addCode(c3.call(prefix + "_finalExponentiation", resT, resT));
      f5.addCode(c3.call(ftmPrefix + "_eq", resT, c3.getLocal("c")));
    }
    function buildPairing2() {
      const f5 = module.addFunction(prefix + "_pairing");
      f5.addParam("p", "i32");
      f5.addParam("q", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const resT = c3.i32_const(module.alloc(ftsize));
      f5.addCode(c3.call(prefix + "_prepareG1", c3.getLocal("p"), c3.i32_const(pPreP)));
      f5.addCode(c3.call(prefix + "_prepareG2", c3.getLocal("q"), c3.i32_const(pPreQ)));
      f5.addCode(c3.call(prefix + "_millerLoop", c3.i32_const(pPreP), c3.i32_const(pPreQ), resT));
      f5.addCode(c3.call(prefix + "_finalExponentiation", resT, c3.getLocal("r")));
    }
    buildPrepAddStep();
    buildPrepDoubleStep();
    buildPrepareG1();
    buildPrepareG2();
    buildMulBy024();
    buildMulBy024Old();
    buildMillerLoop();
    for (let i4 = 0; i4 < 10; i4++) {
      buildFrobeniusMap(i4);
      module.exportFunction(prefix + "__frobeniusMap" + i4);
    }
    buildFinalExponentiationOld();
    buildFinalExponentiation();
    for (let i4 = 1; i4 <= 5; i4++) {
      buildPairingEquation(i4);
      module.exportFunction(prefix + "_pairingEq" + i4);
    }
    buildPairing2();
    module.exportFunction(prefix + "_pairing");
    module.exportFunction(prefix + "_prepareG1");
    module.exportFunction(prefix + "_prepareG2");
    module.exportFunction(prefix + "_millerLoop");
    module.exportFunction(prefix + "_finalExponentiation");
    module.exportFunction(prefix + "_finalExponentiationOld");
    module.exportFunction(prefix + "__mulBy024");
    module.exportFunction(prefix + "__mulBy024Old");
    module.exportFunction(prefix + "__cyclotomicSquare");
    module.exportFunction(prefix + "__cyclotomicExp_w0");
  };
  var utils$1 = utils$6;
  var buildF1m2 = build_f1m;
  var buildF12 = build_f1;
  var buildF2m2 = build_f2m;
  var buildF3m2 = build_f3m;
  var buildCurve2 = build_curve_jacobian_a0;
  var buildFFT$1 = build_fft;
  var buildPol2 = build_pol;
  var buildQAP2 = build_qap;
  var buildApplyKey2 = build_applykey;
  var { bitLength: bitLength$1, isOdd, isNegative: isNegative$1 } = bigint;
  var build_bls12381 = function buildBLS12381(module, _prefix) {
    const prefix = _prefix || "bls12381";
    if (module.modules[prefix])
      return prefix;
    const q5 = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
    const r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
    const n64q = Math.floor((bitLength$1(q5 - 1n) - 1) / 64) + 1;
    const n8q = n64q * 8;
    const f1size = n8q;
    const f2size = f1size * 2;
    const ftsize = f1size * 12;
    const n64r = Math.floor((bitLength$1(r - 1n) - 1) / 64) + 1;
    const n8r = n64r * 8;
    const frsize = n8r;
    const pr2 = module.alloc(utils$1.bigInt2BytesLE(r, frsize));
    const f1mPrefix = buildF1m2(module, q5, "f1m", "intq");
    buildF12(module, r, "fr", "frm", "intr");
    const pG1b = module.alloc(utils$1.bigInt2BytesLE(toMontgomery(4n), f1size));
    const g1mPrefix = buildCurve2(module, "g1m", "f1m", pG1b);
    buildFFT$1(module, "frm", "frm", "frm", "frm_mul");
    buildPol2(module, "pol", "frm");
    buildQAP2(module, "qap", "frm");
    const f2mPrefix = buildF2m2(module, "f1m_neg", "f2m", "f1m");
    const pG2b = module.alloc([
      ...utils$1.bigInt2BytesLE(toMontgomery(4n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(4n), f1size)
    ]);
    const g2mPrefix = buildCurve2(module, "g2m", "f2m", pG2b);
    function buildGTimesFr(fnName, opMul) {
      const f5 = module.addFunction(fnName);
      f5.addParam("pG", "i32");
      f5.addParam("pFr", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const AUX = c3.i32_const(module.alloc(n8r));
      f5.addCode(
        c3.call("frm_fromMontgomery", c3.getLocal("pFr"), AUX),
        c3.call(
          opMul,
          c3.getLocal("pG"),
          AUX,
          c3.i32_const(n8r),
          c3.getLocal("pr")
        )
      );
      module.exportFunction(fnName);
    }
    buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
    buildFFT$1(module, "g1m", "g1m", "frm", "g1m_timesFr");
    buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
    buildFFT$1(module, "g2m", "g2m", "frm", "g2m_timesFr");
    buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
    buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
    buildApplyKey2(module, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
    buildApplyKey2(module, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
    buildApplyKey2(module, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
    buildApplyKey2(module, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
    buildApplyKey2(module, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
    function toMontgomery(a4) {
      return BigInt(a4) * (1n << BigInt(f1size * 8)) % q5;
    }
    const G1gen = [
      3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
      1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
      1n
    ];
    const pG1gen = module.alloc(
      [
        ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
      ]
    );
    const G1zero = [
      0n,
      1n,
      0n
    ];
    const pG1zero = module.alloc(
      [
        ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
      ]
    );
    const G2gen = [
      [
        352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
        3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
      ],
      [
        1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
        927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
      ],
      [
        1n,
        0n
      ]
    ];
    const pG2gen = module.alloc(
      [
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
      ]
    );
    const G2zero = [
      [
        0n,
        0n
      ],
      [
        1n,
        0n
      ],
      [
        0n,
        0n
      ]
    ];
    const pG2zero = module.alloc(
      [
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
      ]
    );
    const pOneT = module.alloc([
      ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size)
    ]);
    const pBls12381Twist = module.alloc([
      ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size),
      ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size)
    ]);
    function build_mulNR2() {
      const f5 = module.addFunction(f2mPrefix + "_mulNR");
      f5.addParam("x", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const x0c = c3.i32_const(module.alloc(f1size));
      const x0 = c3.getLocal("x");
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f1size));
      const r0 = c3.getLocal("pr");
      const r1 = c3.i32_add(c3.getLocal("pr"), c3.i32_const(f1size));
      f5.addCode(
        c3.call(f1mPrefix + "_copy", x0, x0c),
        c3.call(f1mPrefix + "_sub", x0, x1, r0),
        c3.call(f1mPrefix + "_add", x0c, x1, r1)
      );
    }
    build_mulNR2();
    const f6mPrefix = buildF3m2(module, f2mPrefix + "_mulNR", "f6m", "f2m");
    function build_mulNR6() {
      const f5 = module.addFunction(f6mPrefix + "_mulNR");
      f5.addParam("x", "i32");
      f5.addParam("pr", "i32");
      const c3 = f5.getCodeBuilder();
      const c0copy = c3.i32_const(module.alloc(f1size * 2));
      f5.addCode(
        c3.call(
          f2mPrefix + "_copy",
          c3.getLocal("x"),
          c0copy
        ),
        c3.call(
          f2mPrefix + "_mulNR",
          c3.i32_add(c3.getLocal("x"), c3.i32_const(n8q * 4)),
          c3.getLocal("pr")
        ),
        c3.call(
          f2mPrefix + "_copy",
          c3.i32_add(c3.getLocal("x"), c3.i32_const(n8q * 2)),
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8q * 4))
        ),
        c3.call(
          f2mPrefix + "_copy",
          c0copy,
          c3.i32_add(c3.getLocal("pr"), c3.i32_const(n8q * 2))
        )
      );
    }
    build_mulNR6();
    const ftmPrefix = buildF2m2(module, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
    const ateLoopCount = 0xd201000000010000n;
    const ateLoopBitBytes = bits2(ateLoopCount);
    const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);
    const ateCoefSize = 3 * f2size;
    const ateNDblCoefs = ateLoopBitBytes.length - 1;
    const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b7) => acc + (b7 != 0 ? 1 : 0), 0);
    const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
    const prePSize = 3 * 2 * n8q;
    const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
    const finalExpIsNegative = true;
    const finalExpZ = 15132376222941642752n;
    module.modules[prefix] = {
      n64q,
      n64r,
      n8q,
      n8r,
      pG1gen,
      pG1zero,
      pG1b,
      pG2gen,
      pG2zero,
      pG2b,
      pq: module.modules["f1m"].pq,
      pr: pr2,
      pOneT,
      r,
      q: q5,
      prePSize,
      preQSize
    };
    function naf2(n4) {
      let E4 = n4;
      const res = [];
      while (E4 > 0n) {
        if (isOdd(E4)) {
          const z6 = 2 - Number(E4 % 4n);
          res.push(z6);
          E4 = E4 - BigInt(z6);
        } else {
          res.push(0);
        }
        E4 = E4 >> 1n;
      }
      return res;
    }
    function bits2(n4) {
      let E4 = n4;
      const res = [];
      while (E4 > 0n) {
        if (isOdd(E4)) {
          res.push(1);
        } else {
          res.push(0);
        }
        E4 = E4 >> 1n;
      }
      return res;
    }
    function buildPrepareG1() {
      const f5 = module.addFunction(prefix + "_prepareG1");
      f5.addParam("pP", "i32");
      f5.addParam("ppreP", "i32");
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(g1mPrefix + "_normalize", c3.getLocal("pP"), c3.getLocal("ppreP"))
      );
    }
    function buildPrepDoubleStep() {
      const f5 = module.addFunction(prefix + "_prepDblStep");
      f5.addParam("R", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const Rx = c3.getLocal("R");
      const Ry = c3.i32_add(c3.getLocal("R"), c3.i32_const(2 * n8q));
      const Rz = c3.i32_add(c3.getLocal("R"), c3.i32_const(4 * n8q));
      const t0 = c3.getLocal("r");
      const t3 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * n8q));
      const t6 = c3.i32_add(c3.getLocal("r"), c3.i32_const(4 * n8q));
      const zsquared = c3.i32_const(module.alloc(f2size));
      const t1 = c3.i32_const(module.alloc(f2size));
      const t2 = c3.i32_const(module.alloc(f2size));
      const t4 = c3.i32_const(module.alloc(f2size));
      const t5 = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_square", Rx, t0),
        c3.call(f2mPrefix + "_square", Ry, t1),
        c3.call(f2mPrefix + "_square", t1, t2),
        c3.call(f2mPrefix + "_add", t1, Rx, t3),
        c3.call(f2mPrefix + "_square", t3, t3),
        c3.call(f2mPrefix + "_sub", t3, t0, t3),
        c3.call(f2mPrefix + "_sub", t3, t2, t3),
        c3.call(f2mPrefix + "_add", t3, t3, t3),
        c3.call(f2mPrefix + "_add", t0, t0, t4),
        c3.call(f2mPrefix + "_add", t4, t0, t4),
        c3.call(f2mPrefix + "_add", Rx, t4, t6),
        c3.call(f2mPrefix + "_square", t4, t5),
        c3.call(f2mPrefix + "_square", Rz, zsquared),
        c3.call(f2mPrefix + "_sub", t5, t3, Rx),
        c3.call(f2mPrefix + "_sub", Rx, t3, Rx),
        c3.call(f2mPrefix + "_add", Rz, Ry, Rz),
        c3.call(f2mPrefix + "_square", Rz, Rz),
        c3.call(f2mPrefix + "_sub", Rz, t1, Rz),
        c3.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
        c3.call(f2mPrefix + "_sub", t3, Rx, Ry),
        c3.call(f2mPrefix + "_mul", Ry, t4, Ry),
        c3.call(f2mPrefix + "_add", t2, t2, t2),
        c3.call(f2mPrefix + "_add", t2, t2, t2),
        c3.call(f2mPrefix + "_add", t2, t2, t2),
        c3.call(f2mPrefix + "_sub", Ry, t2, Ry),
        c3.call(f2mPrefix + "_mul", t4, zsquared, t3),
        c3.call(f2mPrefix + "_add", t3, t3, t3),
        c3.call(f2mPrefix + "_neg", t3, t3),
        c3.call(f2mPrefix + "_square", t6, t6),
        c3.call(f2mPrefix + "_sub", t6, t0, t6),
        c3.call(f2mPrefix + "_sub", t6, t5, t6),
        c3.call(f2mPrefix + "_add", t1, t1, t1),
        c3.call(f2mPrefix + "_add", t1, t1, t1),
        c3.call(f2mPrefix + "_sub", t6, t1, t6),
        c3.call(f2mPrefix + "_mul", Rz, zsquared, t0),
        c3.call(f2mPrefix + "_add", t0, t0, t0)
      );
    }
    function buildPrepAddStep() {
      const f5 = module.addFunction(prefix + "_prepAddStep");
      f5.addParam("R", "i32");
      f5.addParam("Q", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const Rx = c3.getLocal("R");
      const Ry = c3.i32_add(c3.getLocal("R"), c3.i32_const(2 * n8q));
      const Rz = c3.i32_add(c3.getLocal("R"), c3.i32_const(4 * n8q));
      const Qx = c3.getLocal("Q");
      const Qy = c3.i32_add(c3.getLocal("Q"), c3.i32_const(2 * n8q));
      const t10 = c3.getLocal("r");
      const t1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * n8q));
      const t9 = c3.i32_add(c3.getLocal("r"), c3.i32_const(4 * n8q));
      const zsquared = c3.i32_const(module.alloc(f2size));
      const ysquared = c3.i32_const(module.alloc(f2size));
      const ztsquared = c3.i32_const(module.alloc(f2size));
      const t0 = c3.i32_const(module.alloc(f2size));
      const t2 = c3.i32_const(module.alloc(f2size));
      const t3 = c3.i32_const(module.alloc(f2size));
      const t4 = c3.i32_const(module.alloc(f2size));
      const t5 = c3.i32_const(module.alloc(f2size));
      const t6 = c3.i32_const(module.alloc(f2size));
      const t7 = c3.i32_const(module.alloc(f2size));
      const t8 = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_square", Rz, zsquared),
        c3.call(f2mPrefix + "_square", Qy, ysquared),
        c3.call(f2mPrefix + "_mul", zsquared, Qx, t0),
        c3.call(f2mPrefix + "_add", Qy, Rz, t1),
        c3.call(f2mPrefix + "_square", t1, t1),
        c3.call(f2mPrefix + "_sub", t1, ysquared, t1),
        c3.call(f2mPrefix + "_sub", t1, zsquared, t1),
        c3.call(f2mPrefix + "_mul", t1, zsquared, t1),
        c3.call(f2mPrefix + "_sub", t0, Rx, t2),
        c3.call(f2mPrefix + "_square", t2, t3),
        c3.call(f2mPrefix + "_add", t3, t3, t4),
        c3.call(f2mPrefix + "_add", t4, t4, t4),
        c3.call(f2mPrefix + "_mul", t4, t2, t5),
        c3.call(f2mPrefix + "_sub", t1, Ry, t6),
        c3.call(f2mPrefix + "_sub", t6, Ry, t6),
        c3.call(f2mPrefix + "_mul", t6, Qx, t9),
        c3.call(f2mPrefix + "_mul", t4, Rx, t7),
        c3.call(f2mPrefix + "_square", t6, Rx),
        c3.call(f2mPrefix + "_sub", Rx, t5, Rx),
        c3.call(f2mPrefix + "_sub", Rx, t7, Rx),
        c3.call(f2mPrefix + "_sub", Rx, t7, Rx),
        c3.call(f2mPrefix + "_add", Rz, t2, Rz),
        c3.call(f2mPrefix + "_square", Rz, Rz),
        c3.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
        c3.call(f2mPrefix + "_sub", Rz, t3, Rz),
        c3.call(f2mPrefix + "_add", Qy, Rz, t10),
        c3.call(f2mPrefix + "_sub", t7, Rx, t8),
        c3.call(f2mPrefix + "_mul", t8, t6, t8),
        c3.call(f2mPrefix + "_mul", Ry, t5, t0),
        c3.call(f2mPrefix + "_add", t0, t0, t0),
        c3.call(f2mPrefix + "_sub", t8, t0, Ry),
        c3.call(f2mPrefix + "_square", t10, t10),
        c3.call(f2mPrefix + "_sub", t10, ysquared, t10),
        c3.call(f2mPrefix + "_square", Rz, ztsquared),
        c3.call(f2mPrefix + "_sub", t10, ztsquared, t10),
        c3.call(f2mPrefix + "_add", t9, t9, t9),
        c3.call(f2mPrefix + "_sub", t9, t10, t9),
        c3.call(f2mPrefix + "_add", Rz, Rz, t10),
        c3.call(f2mPrefix + "_neg", t6, t6),
        c3.call(f2mPrefix + "_add", t6, t6, t1)
      );
    }
    function buildPrepareG2() {
      const f5 = module.addFunction(prefix + "_prepareG2");
      f5.addParam("pQ", "i32");
      f5.addParam("ppreQ", "i32");
      f5.addLocal("pCoef", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const Q5 = c3.getLocal("pQ");
      const pR = module.alloc(f2size * 3);
      const R5 = c3.i32_const(pR);
      const base3 = c3.getLocal("ppreQ");
      f5.addCode(
        c3.call(g2mPrefix + "_normalize", Q5, base3),
        c3.if(
          c3.call(g2mPrefix + "_isZero", base3),
          c3.ret([])
        ),
        c3.call(g2mPrefix + "_copy", base3, R5),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(f2size * 3)))
      );
      f5.addCode(
        c3.setLocal("i", c3.i32_const(ateLoopBitBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(prefix + "_prepDblStep", R5, c3.getLocal("pCoef")),
          c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
          c3.if(
            c3.i32_load8_s(c3.getLocal("i"), pAteLoopBitBytes),
            [
              ...c3.call(prefix + "_prepAddStep", R5, base3, c3.getLocal("pCoef")),
              ...c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
            ]
          ),
          c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
    }
    function buildF6Mul1() {
      const f5 = module.addFunction(f6mPrefix + "_mul1");
      f5.addParam("pA", "i32");
      f5.addParam("pC1", "i32");
      f5.addParam("pR", "i32");
      const c3 = f5.getCodeBuilder();
      const A_c0 = c3.getLocal("pA");
      const A_c1 = c3.i32_add(c3.getLocal("pA"), c3.i32_const(f1size * 2));
      const A_c2 = c3.i32_add(c3.getLocal("pA"), c3.i32_const(f1size * 4));
      const c1 = c3.getLocal("pC1");
      const t1 = c3.getLocal("pR");
      const t2 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f1size * 2));
      const b_b = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f1size * 4));
      const Ac0_Ac1 = c3.i32_const(module.alloc(f1size * 2));
      const Ac1_Ac2 = c3.i32_const(module.alloc(f1size * 2));
      f5.addCode(
        c3.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
        c3.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
        c3.call(f2mPrefix + "_mul", A_c1, c1, b_b),
        c3.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
        c3.call(f2mPrefix + "_sub", t1, b_b, t1),
        c3.call(f2mPrefix + "_mulNR", t1, t1),
        c3.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
        c3.call(f2mPrefix + "_sub", t2, b_b, t2)
      );
    }
    buildF6Mul1();
    function buildF6Mul01() {
      const f5 = module.addFunction(f6mPrefix + "_mul01");
      f5.addParam("pA", "i32");
      f5.addParam("pC0", "i32");
      f5.addParam("pC1", "i32");
      f5.addParam("pR", "i32");
      const c3 = f5.getCodeBuilder();
      const A_c0 = c3.getLocal("pA");
      const A_c1 = c3.i32_add(c3.getLocal("pA"), c3.i32_const(f1size * 2));
      const A_c2 = c3.i32_add(c3.getLocal("pA"), c3.i32_const(f1size * 4));
      const c0 = c3.getLocal("pC0");
      const c1 = c3.getLocal("pC1");
      const t1 = c3.getLocal("pR");
      const t2 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f1size * 2));
      const t3 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f1size * 4));
      const a_a = c3.i32_const(module.alloc(f1size * 2));
      const b_b = c3.i32_const(module.alloc(f1size * 2));
      const Ac0_Ac1 = c3.i32_const(module.alloc(f1size * 2));
      const Ac0_Ac2 = c3.i32_const(module.alloc(f1size * 2));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", A_c0, c0, a_a),
        c3.call(f2mPrefix + "_mul", A_c1, c1, b_b),
        c3.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
        c3.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
        c3.call(f2mPrefix + "_add", A_c1, A_c2, t1),
        c3.call(f2mPrefix + "_mul", t1, c1, t1),
        c3.call(f2mPrefix + "_sub", t1, b_b, t1),
        c3.call(f2mPrefix + "_mulNR", t1, t1),
        c3.call(f2mPrefix + "_add", t1, a_a, t1),
        c3.call(f2mPrefix + "_add", c0, c1, t2),
        c3.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
        c3.call(f2mPrefix + "_sub", t2, a_a, t2),
        c3.call(f2mPrefix + "_sub", t2, b_b, t2),
        c3.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
        c3.call(f2mPrefix + "_sub", t3, a_a, t3),
        c3.call(f2mPrefix + "_add", t3, b_b, t3)
      );
    }
    buildF6Mul01();
    function buildF12Mul014() {
      const f5 = module.addFunction(ftmPrefix + "_mul014");
      f5.addParam("pA", "i32");
      f5.addParam("pC0", "i32");
      f5.addParam("pC1", "i32");
      f5.addParam("pC4", "i32");
      f5.addParam("pR", "i32");
      const c3 = f5.getCodeBuilder();
      const A_c0 = c3.getLocal("pA");
      const A_c1 = c3.i32_add(c3.getLocal("pA"), c3.i32_const(f1size * 6));
      const c0 = c3.getLocal("pC0");
      const c1 = c3.getLocal("pC1");
      const c4 = c3.getLocal("pC4");
      const aa2 = c3.i32_const(module.alloc(f1size * 6));
      const bb = c3.i32_const(module.alloc(f1size * 6));
      const o4 = c3.i32_const(module.alloc(f1size * 2));
      const R_c0 = c3.getLocal("pR");
      const R_c1 = c3.i32_add(c3.getLocal("pR"), c3.i32_const(f1size * 6));
      f5.addCode(
        c3.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa2),
        c3.call(f6mPrefix + "_mul1", A_c1, c4, bb),
        c3.call(f2mPrefix + "_add", c1, c4, o4),
        c3.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
        c3.call(f6mPrefix + "_mul01", R_c1, c0, o4, R_c1),
        c3.call(f6mPrefix + "_sub", R_c1, aa2, R_c1),
        c3.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
        c3.call(f6mPrefix + "_copy", bb, R_c0),
        c3.call(f6mPrefix + "_mulNR", R_c0, R_c0),
        c3.call(f6mPrefix + "_add", R_c0, aa2, R_c0)
      );
    }
    buildF12Mul014();
    function buildELL() {
      const f5 = module.addFunction(prefix + "_ell");
      f5.addParam("pP", "i32");
      f5.addParam("pCoefs", "i32");
      f5.addParam("pF", "i32");
      const c3 = f5.getCodeBuilder();
      const Px = c3.getLocal("pP");
      const Py = c3.i32_add(c3.getLocal("pP"), c3.i32_const(n8q));
      const F4 = c3.getLocal("pF");
      const coef0_0 = c3.getLocal("pCoefs");
      const coef0_1 = c3.i32_add(c3.getLocal("pCoefs"), c3.i32_const(f1size));
      const coef1_0 = c3.i32_add(c3.getLocal("pCoefs"), c3.i32_const(f1size * 2));
      const coef1_1 = c3.i32_add(c3.getLocal("pCoefs"), c3.i32_const(f1size * 3));
      const coef2 = c3.i32_add(c3.getLocal("pCoefs"), c3.i32_const(f1size * 4));
      const pc0 = module.alloc(f1size * 2);
      const c0 = c3.i32_const(pc0);
      const c0_c0 = c3.i32_const(pc0);
      const c0_c1 = c3.i32_const(pc0 + f1size);
      const pc1 = module.alloc(f1size * 2);
      const c1 = c3.i32_const(pc1);
      const c1_c0 = c3.i32_const(pc1);
      const c1_c1 = c3.i32_const(pc1 + f1size);
      f5.addCode(
        c3.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
        c3.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
        c3.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
        c3.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
        c3.call(ftmPrefix + "_mul014", F4, coef2, c1, c0, F4)
      );
    }
    buildELL();
    function buildMillerLoop() {
      const f5 = module.addFunction(prefix + "_millerLoop");
      f5.addParam("ppreP", "i32");
      f5.addParam("ppreQ", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("pCoef", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const preP = c3.getLocal("ppreP");
      const coefs = c3.getLocal("pCoef");
      const F4 = c3.getLocal("r");
      f5.addCode(
        c3.call(ftmPrefix + "_one", F4),
        c3.if(
          c3.call(g1mPrefix + "_isZero", preP),
          c3.ret([])
        ),
        c3.if(
          c3.call(g1mPrefix + "_isZero", c3.getLocal("ppreQ")),
          c3.ret([])
        ),
        c3.setLocal("pCoef", c3.i32_add(c3.getLocal("ppreQ"), c3.i32_const(f2size * 3))),
        c3.setLocal("i", c3.i32_const(ateLoopBitBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(prefix + "_ell", preP, coefs, F4),
          c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize))),
          c3.if(
            c3.i32_load8_s(c3.getLocal("i"), pAteLoopBitBytes),
            [
              ...c3.call(prefix + "_ell", preP, coefs, F4),
              ...c3.setLocal("pCoef", c3.i32_add(c3.getLocal("pCoef"), c3.i32_const(ateCoefSize)))
            ]
          ),
          c3.call(ftmPrefix + "_square", F4, F4),
          c3.br_if(1, c3.i32_eq(c3.getLocal("i"), c3.i32_const(1))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        )),
        c3.call(prefix + "_ell", preP, coefs, F4)
      );
      {
        f5.addCode(
          c3.call(ftmPrefix + "_conjugate", F4, F4)
        );
      }
    }
    function buildFrobeniusMap(n4) {
      const F12 = [
        [
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n]
        ],
        [
          [1n, 0n],
          [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
          [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
          [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
          [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
          [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
          [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
          [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
          [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
          [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
          [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
          [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
        ]
      ];
      const F6 = [
        [
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n],
          [1n, 0n]
        ],
        [
          [1n, 0n],
          [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
          [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
          [0n, 1n],
          [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
          [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
        ],
        [
          [1n, 0n],
          [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
          [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
          [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
          [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
          [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
        ]
      ];
      const f5 = module.addFunction(ftmPrefix + "_frobeniusMap" + n4);
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      for (let i4 = 0; i4 < 6; i4++) {
        const X5 = i4 == 0 ? c3.getLocal("x") : c3.i32_add(c3.getLocal("x"), c3.i32_const(i4 * f2size));
        const Xc0 = X5;
        const Xc1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(i4 * f2size + f1size));
        const R5 = i4 == 0 ? c3.getLocal("r") : c3.i32_add(c3.getLocal("r"), c3.i32_const(i4 * f2size));
        const Rc0 = R5;
        const Rc1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(i4 * f2size + f1size));
        const coef = mul2(F12[Math.floor(i4 / 3)][n4 % 12], F6[i4 % 3][n4 % 6]);
        const pCoef = module.alloc([
          ...utils$1.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
          ...utils$1.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
        ]);
        if (n4 % 2 == 1) {
          f5.addCode(
            c3.call(f1mPrefix + "_copy", Xc0, Rc0),
            c3.call(f1mPrefix + "_neg", Xc1, Rc1),
            c3.call(f2mPrefix + "_mul", R5, c3.i32_const(pCoef), R5)
          );
        } else {
          f5.addCode(c3.call(f2mPrefix + "_mul", X5, c3.i32_const(pCoef), R5));
        }
      }
      function mul2(a4, b7) {
        const ac0 = a4[0];
        const ac1 = a4[1];
        const bc0 = b7[0];
        const bc1 = b7[1];
        const res = [
          (ac0 * bc0 - ac1 * bc1) % q5,
          (ac0 * bc1 + ac1 * bc0) % q5
        ];
        if (isNegative$1(res[0]))
          res[0] = res[0] + q5;
        return res;
      }
    }
    function buildCyclotomicSquare() {
      const f5 = module.addFunction(prefix + "__cyclotomicSquare");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const x0 = c3.getLocal("x");
      const x42 = c3.i32_add(c3.getLocal("x"), c3.i32_const(f2size));
      const x32 = c3.i32_add(c3.getLocal("x"), c3.i32_const(2 * f2size));
      const x22 = c3.i32_add(c3.getLocal("x"), c3.i32_const(3 * f2size));
      const x1 = c3.i32_add(c3.getLocal("x"), c3.i32_const(4 * f2size));
      const x52 = c3.i32_add(c3.getLocal("x"), c3.i32_const(5 * f2size));
      const r0 = c3.getLocal("r");
      const r4 = c3.i32_add(c3.getLocal("r"), c3.i32_const(f2size));
      const r3 = c3.i32_add(c3.getLocal("r"), c3.i32_const(2 * f2size));
      const r2 = c3.i32_add(c3.getLocal("r"), c3.i32_const(3 * f2size));
      const r1 = c3.i32_add(c3.getLocal("r"), c3.i32_const(4 * f2size));
      const r5 = c3.i32_add(c3.getLocal("r"), c3.i32_const(5 * f2size));
      const t0 = c3.i32_const(module.alloc(f2size));
      const t1 = c3.i32_const(module.alloc(f2size));
      const t2 = c3.i32_const(module.alloc(f2size));
      const t3 = c3.i32_const(module.alloc(f2size));
      const t4 = c3.i32_const(module.alloc(f2size));
      const t5 = c3.i32_const(module.alloc(f2size));
      const tmp = c3.i32_const(module.alloc(f2size));
      const AUX = c3.i32_const(module.alloc(f2size));
      f5.addCode(
        c3.call(f2mPrefix + "_mul", x0, x1, tmp),
        c3.call(f2mPrefix + "_mulNR", x1, t0),
        c3.call(f2mPrefix + "_add", x0, t0, t0),
        c3.call(f2mPrefix + "_add", x0, x1, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t0, t0),
        c3.call(f2mPrefix + "_mulNR", tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t0, AUX, t0),
        c3.call(f2mPrefix + "_add", tmp, tmp, t1),
        c3.call(f2mPrefix + "_mul", x22, x32, tmp),
        c3.call(f2mPrefix + "_mulNR", x32, t2),
        c3.call(f2mPrefix + "_add", x22, t2, t2),
        c3.call(f2mPrefix + "_add", x22, x32, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t2, t2),
        c3.call(f2mPrefix + "_mulNR", tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t2, AUX, t2),
        c3.call(f2mPrefix + "_add", tmp, tmp, t3),
        c3.call(f2mPrefix + "_mul", x42, x52, tmp),
        c3.call(f2mPrefix + "_mulNR", x52, t4),
        c3.call(f2mPrefix + "_add", x42, t4, t4),
        c3.call(f2mPrefix + "_add", x42, x52, AUX),
        c3.call(f2mPrefix + "_mul", AUX, t4, t4),
        c3.call(f2mPrefix + "_mulNR", tmp, AUX),
        c3.call(f2mPrefix + "_add", tmp, AUX, AUX),
        c3.call(f2mPrefix + "_sub", t4, AUX, t4),
        c3.call(f2mPrefix + "_add", tmp, tmp, t5),
        c3.call(f2mPrefix + "_sub", t0, x0, r0),
        c3.call(f2mPrefix + "_add", r0, r0, r0),
        c3.call(f2mPrefix + "_add", t0, r0, r0),
        c3.call(f2mPrefix + "_add", t1, x1, r1),
        c3.call(f2mPrefix + "_add", r1, r1, r1),
        c3.call(f2mPrefix + "_add", t1, r1, r1),
        c3.call(f2mPrefix + "_mul", t5, c3.i32_const(pBls12381Twist), AUX),
        c3.call(f2mPrefix + "_add", AUX, x22, r2),
        c3.call(f2mPrefix + "_add", r2, r2, r2),
        c3.call(f2mPrefix + "_add", AUX, r2, r2),
        c3.call(f2mPrefix + "_sub", t4, x32, r3),
        c3.call(f2mPrefix + "_add", r3, r3, r3),
        c3.call(f2mPrefix + "_add", t4, r3, r3),
        c3.call(f2mPrefix + "_sub", t2, x42, r4),
        c3.call(f2mPrefix + "_add", r4, r4, r4),
        c3.call(f2mPrefix + "_add", t2, r4, r4),
        c3.call(f2mPrefix + "_add", t3, x52, r5),
        c3.call(f2mPrefix + "_add", r5, r5, r5),
        c3.call(f2mPrefix + "_add", t3, r5, r5)
      );
    }
    function buildCyclotomicExp(exponent, isExpNegative, fnName) {
      const exponentNafBytes = naf2(exponent).map((b7) => b7 == -1 ? 255 : b7);
      const pExponentNafBytes = module.alloc(exponentNafBytes);
      const f5 = module.addFunction(prefix + "__cyclotomicExp_" + fnName);
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      f5.addLocal("bit", "i32");
      f5.addLocal("i", "i32");
      const c3 = f5.getCodeBuilder();
      const x6 = c3.getLocal("x");
      const res = c3.getLocal("r");
      const inverse = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(ftmPrefix + "_conjugate", x6, inverse),
        c3.call(ftmPrefix + "_one", res),
        c3.if(
          c3.teeLocal("bit", c3.i32_load8_s(c3.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
          c3.if(
            c3.i32_eq(
              c3.getLocal("bit"),
              c3.i32_const(1)
            ),
            c3.call(ftmPrefix + "_mul", res, x6, res),
            c3.call(ftmPrefix + "_mul", res, inverse, res)
          )
        ),
        c3.setLocal("i", c3.i32_const(exponentNafBytes.length - 2)),
        c3.block(c3.loop(
          c3.call(prefix + "__cyclotomicSquare", res, res),
          c3.if(
            c3.teeLocal("bit", c3.i32_load8_s(c3.getLocal("i"), pExponentNafBytes)),
            c3.if(
              c3.i32_eq(
                c3.getLocal("bit"),
                c3.i32_const(1)
              ),
              c3.call(ftmPrefix + "_mul", res, x6, res),
              c3.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c3.br_if(1, c3.i32_eqz(c3.getLocal("i"))),
          c3.setLocal("i", c3.i32_sub(c3.getLocal("i"), c3.i32_const(1))),
          c3.br(0)
        ))
      );
      if (isExpNegative) {
        f5.addCode(
          c3.call(ftmPrefix + "_conjugate", res, res)
        );
      }
    }
    function buildFinalExponentiation() {
      buildCyclotomicSquare();
      buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
      const f5 = module.addFunction(prefix + "_finalExponentiation");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const elt = c3.getLocal("x");
      const res = c3.getLocal("r");
      const t0 = c3.i32_const(module.alloc(ftsize));
      const t1 = c3.i32_const(module.alloc(ftsize));
      const t2 = c3.i32_const(module.alloc(ftsize));
      const t3 = c3.i32_const(module.alloc(ftsize));
      const t4 = c3.i32_const(module.alloc(ftsize));
      const t5 = c3.i32_const(module.alloc(ftsize));
      const t6 = c3.i32_const(module.alloc(ftsize));
      f5.addCode(
        c3.call(ftmPrefix + "_frobeniusMap6", elt, t0),
        c3.call(ftmPrefix + "_inverse", elt, t1),
        c3.call(ftmPrefix + "_mul", t0, t1, t2),
        c3.call(ftmPrefix + "_copy", t2, t1),
        c3.call(ftmPrefix + "_frobeniusMap2", t2, t2),
        c3.call(ftmPrefix + "_mul", t2, t1, t2),
        c3.call(prefix + "__cyclotomicSquare", t2, t1),
        c3.call(ftmPrefix + "_conjugate", t1, t1),
        c3.call(prefix + "__cyclotomicExp_w0", t2, t3),
        c3.call(prefix + "__cyclotomicSquare", t3, t4),
        c3.call(ftmPrefix + "_mul", t1, t3, t5),
        c3.call(prefix + "__cyclotomicExp_w0", t5, t1),
        c3.call(prefix + "__cyclotomicExp_w0", t1, t0),
        c3.call(prefix + "__cyclotomicExp_w0", t0, t6),
        c3.call(ftmPrefix + "_mul", t6, t4, t6),
        c3.call(prefix + "__cyclotomicExp_w0", t6, t4),
        c3.call(ftmPrefix + "_conjugate", t5, t5),
        c3.call(ftmPrefix + "_mul", t4, t5, t4),
        c3.call(ftmPrefix + "_mul", t4, t2, t4),
        c3.call(ftmPrefix + "_conjugate", t2, t5),
        c3.call(ftmPrefix + "_mul", t1, t2, t1),
        c3.call(ftmPrefix + "_frobeniusMap3", t1, t1),
        c3.call(ftmPrefix + "_mul", t6, t5, t6),
        c3.call(ftmPrefix + "_frobeniusMap1", t6, t6),
        c3.call(ftmPrefix + "_mul", t3, t0, t3),
        c3.call(ftmPrefix + "_frobeniusMap2", t3, t3),
        c3.call(ftmPrefix + "_mul", t3, t1, t3),
        c3.call(ftmPrefix + "_mul", t3, t6, t3),
        c3.call(ftmPrefix + "_mul", t3, t4, res)
      );
    }
    function buildFinalExponentiationOld() {
      const f5 = module.addFunction(prefix + "_finalExponentiationOld");
      f5.addParam("x", "i32");
      f5.addParam("r", "i32");
      const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
      const pExponent = module.alloc(utils$1.bigInt2BytesLE(exponent, 544));
      const c3 = f5.getCodeBuilder();
      f5.addCode(
        c3.call(ftmPrefix + "_exp", c3.getLocal("x"), c3.i32_const(pExponent), c3.i32_const(544), c3.getLocal("r"))
      );
    }
    const pPreP = module.alloc(prePSize);
    const pPreQ = module.alloc(preQSize);
    function buildPairingEquation(nPairings) {
      const f5 = module.addFunction(prefix + "_pairingEq" + nPairings);
      for (let i4 = 0; i4 < nPairings; i4++) {
        f5.addParam("p_" + i4, "i32");
        f5.addParam("q_" + i4, "i32");
      }
      f5.addParam("c", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const resT = c3.i32_const(module.alloc(ftsize));
      const auxT = c3.i32_const(module.alloc(ftsize));
      f5.addCode(c3.call(ftmPrefix + "_one", resT));
      for (let i4 = 0; i4 < nPairings; i4++) {
        f5.addCode(c3.call(prefix + "_prepareG1", c3.getLocal("p_" + i4), c3.i32_const(pPreP)));
        f5.addCode(c3.call(prefix + "_prepareG2", c3.getLocal("q_" + i4), c3.i32_const(pPreQ)));
        f5.addCode(
          c3.if(
            c3.i32_eqz(c3.call(g1mPrefix + "_inGroupAffine", c3.i32_const(pPreP))),
            c3.ret(c3.i32_const(0))
          ),
          c3.if(
            c3.i32_eqz(c3.call(g2mPrefix + "_inGroupAffine", c3.i32_const(pPreQ))),
            c3.ret(c3.i32_const(0))
          )
        );
        f5.addCode(c3.call(prefix + "_millerLoop", c3.i32_const(pPreP), c3.i32_const(pPreQ), auxT));
        f5.addCode(c3.call(ftmPrefix + "_mul", resT, auxT, resT));
      }
      f5.addCode(c3.call(prefix + "_finalExponentiation", resT, resT));
      f5.addCode(c3.call(ftmPrefix + "_eq", resT, c3.getLocal("c")));
    }
    function buildPairing2() {
      const f5 = module.addFunction(prefix + "_pairing");
      f5.addParam("p", "i32");
      f5.addParam("q", "i32");
      f5.addParam("r", "i32");
      const c3 = f5.getCodeBuilder();
      const resT = c3.i32_const(module.alloc(ftsize));
      f5.addCode(c3.call(prefix + "_prepareG1", c3.getLocal("p"), c3.i32_const(pPreP)));
      f5.addCode(c3.call(prefix + "_prepareG2", c3.getLocal("q"), c3.i32_const(pPreQ)));
      f5.addCode(c3.call(prefix + "_millerLoop", c3.i32_const(pPreP), c3.i32_const(pPreQ), resT));
      f5.addCode(c3.call(prefix + "_finalExponentiation", resT, c3.getLocal("r")));
    }
    function buildInGroupG2() {
      const f5 = module.addFunction(g2mPrefix + "_inGroupAffine");
      f5.addParam("p", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const WINV = [
        2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
        2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
      ];
      const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
      const FROB3Y = [
        2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
        2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
      ];
      const wInv = c3.i32_const(module.alloc([
        ...utils$1.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
        ...utils$1.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
      ]));
      const frob2X = c3.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
      const frob3Y = c3.i32_const(module.alloc([
        ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
        ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
      ]));
      const z6 = c3.i32_const(module.alloc(utils$1.bigInt2BytesLE(finalExpZ, 8)));
      const px = c3.getLocal("p");
      const py = c3.i32_add(c3.getLocal("p"), c3.i32_const(f2size));
      const aux = c3.i32_const(module.alloc(f1size));
      const x_winv = c3.i32_const(module.alloc(f2size));
      const y_winv = c3.i32_const(module.alloc(f2size));
      const pf2 = module.alloc(f2size * 2);
      const f22 = c3.i32_const(pf2);
      const f2x = c3.i32_const(pf2);
      const f2x_c1 = c3.i32_const(pf2);
      const f2x_c2 = c3.i32_const(pf2 + f1size);
      const f2y = c3.i32_const(pf2 + f2size);
      const f2y_c1 = c3.i32_const(pf2 + f2size);
      const f2y_c2 = c3.i32_const(pf2 + f2size + f1size);
      const pf3 = module.alloc(f2size * 3);
      const f32 = c3.i32_const(pf3);
      const f3x = c3.i32_const(pf3);
      const f3x_c1 = c3.i32_const(pf3);
      const f3x_c2 = c3.i32_const(pf3 + f1size);
      const f3y = c3.i32_const(pf3 + f2size);
      const f3y_c1 = c3.i32_const(pf3 + f2size);
      const f3y_c2 = c3.i32_const(pf3 + f2size + f1size);
      const f3z = c3.i32_const(pf3 + f2size * 2);
      f5.addCode(
        c3.if(
          c3.call(g2mPrefix + "_isZeroAffine", c3.getLocal("p")),
          c3.ret(c3.i32_const(1))
        ),
        c3.if(
          c3.i32_eqz(c3.call(g2mPrefix + "_inCurveAffine", c3.getLocal("p"))),
          c3.ret(c3.i32_const(0))
        ),
        c3.call(f2mPrefix + "_mul", px, wInv, x_winv),
        c3.call(f2mPrefix + "_mul", py, wInv, y_winv),
        c3.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
        c3.call(f2mPrefix + "_neg", y_winv, f2y),
        c3.call(f2mPrefix + "_neg", x_winv, f3x),
        c3.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
        c3.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
        c3.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
        c3.call(f1mPrefix + "_copy", aux, f2x_c1),
        c3.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
        c3.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
        c3.call(f1mPrefix + "_copy", aux, f2y_c1),
        c3.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
        c3.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
        c3.call(f1mPrefix + "_copy", aux, f3x_c1),
        c3.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
        c3.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
        c3.call(f1mPrefix + "_copy", aux, f3y_c1),
        c3.call(f2mPrefix + "_one", f3z),
        c3.call(g2mPrefix + "_timesScalar", f32, z6, c3.i32_const(8), f32),
        c3.call(g2mPrefix + "_addMixed", f32, f22, f32),
        c3.ret(
          c3.call(g2mPrefix + "_eqMixed", f32, c3.getLocal("p"))
        )
      );
      const fInGroup = module.addFunction(g2mPrefix + "_inGroup");
      fInGroup.addParam("pIn", "i32");
      fInGroup.setReturnType("i32");
      const c22 = fInGroup.getCodeBuilder();
      const aux2 = c22.i32_const(module.alloc(f2size * 2));
      fInGroup.addCode(
        c22.call(g2mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
        c22.ret(
          c22.call(g2mPrefix + "_inGroupAffine", aux2)
        )
      );
    }
    function buildInGroupG1() {
      const f5 = module.addFunction(g1mPrefix + "_inGroupAffine");
      f5.addParam("p", "i32");
      f5.setReturnType("i32");
      const c3 = f5.getCodeBuilder();
      const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
      const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
      const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
      const beta = c3.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA), n8q)));
      const beta2 = c3.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
      const z2m1d3 = c3.i32_const(module.alloc(utils$1.bigInt2BytesLE(Z2M1D3, 16)));
      const px = c3.getLocal("p");
      const py = c3.i32_add(c3.getLocal("p"), c3.i32_const(f1size));
      const psp = module.alloc(f1size * 3);
      const sp = c3.i32_const(psp);
      const spx = c3.i32_const(psp);
      const spy = c3.i32_const(psp + f1size);
      const ps2p = module.alloc(f1size * 2);
      const s2p = c3.i32_const(ps2p);
      const s2px = c3.i32_const(ps2p);
      const s2py = c3.i32_const(ps2p + f1size);
      f5.addCode(
        c3.if(
          c3.call(g1mPrefix + "_isZeroAffine", c3.getLocal("p")),
          c3.ret(c3.i32_const(1))
        ),
        c3.if(
          c3.i32_eqz(c3.call(g1mPrefix + "_inCurveAffine", c3.getLocal("p"))),
          c3.ret(c3.i32_const(0))
        ),
        c3.call(f1mPrefix + "_mul", px, beta, spx),
        c3.call(f1mPrefix + "_copy", py, spy),
        c3.call(f1mPrefix + "_mul", px, beta2, s2px),
        c3.call(f1mPrefix + "_copy", py, s2py),
        c3.call(g1mPrefix + "_doubleAffine", sp, sp),
        c3.call(g1mPrefix + "_subMixed", sp, c3.getLocal("p"), sp),
        c3.call(g1mPrefix + "_subMixed", sp, s2p, sp),
        c3.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c3.i32_const(16), sp),
        c3.ret(
          c3.call(g1mPrefix + "_eqMixed", sp, s2p)
        )
      );
      const fInGroup = module.addFunction(g1mPrefix + "_inGroup");
      fInGroup.addParam("pIn", "i32");
      fInGroup.setReturnType("i32");
      const c22 = fInGroup.getCodeBuilder();
      const aux2 = c22.i32_const(module.alloc(f1size * 2));
      fInGroup.addCode(
        c22.call(g1mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
        c22.ret(
          c22.call(g1mPrefix + "_inGroupAffine", aux2)
        )
      );
    }
    for (let i4 = 0; i4 < 10; i4++) {
      buildFrobeniusMap(i4);
      module.exportFunction(ftmPrefix + "_frobeniusMap" + i4);
    }
    buildInGroupG1();
    buildInGroupG2();
    buildPrepAddStep();
    buildPrepDoubleStep();
    buildPrepareG1();
    buildPrepareG2();
    buildMillerLoop();
    buildFinalExponentiationOld();
    buildFinalExponentiation();
    for (let i4 = 1; i4 <= 5; i4++) {
      buildPairingEquation(i4);
      module.exportFunction(prefix + "_pairingEq" + i4);
    }
    buildPairing2();
    module.exportFunction(prefix + "_pairing");
    module.exportFunction(prefix + "_prepareG1");
    module.exportFunction(prefix + "_prepareG2");
    module.exportFunction(prefix + "_millerLoop");
    module.exportFunction(prefix + "_finalExponentiation");
    module.exportFunction(prefix + "_finalExponentiationOld");
    module.exportFunction(prefix + "__cyclotomicSquare");
    module.exportFunction(prefix + "__cyclotomicExp_w0");
    module.exportFunction(f6mPrefix + "_mul1");
    module.exportFunction(f6mPrefix + "_mul01");
    module.exportFunction(ftmPrefix + "_mul014");
    module.exportFunction(g1mPrefix + "_inGroupAffine");
    module.exportFunction(g1mPrefix + "_inGroup");
    module.exportFunction(g2mPrefix + "_inGroupAffine");
    module.exportFunction(g2mPrefix + "_inGroup");
  };
  var buildBn128$1 = build_bn128;
  var buildBls12381$1 = build_bls12381;
  function stringifyBigInts(o4) {
    if (typeof o4 == "bigint" || o4.eq !== void 0) {
      return o4.toString(10);
    } else if (o4 instanceof Uint8Array) {
      return fromRprLE(o4, 0);
    } else if (Array.isArray(o4)) {
      return o4.map(stringifyBigInts);
    } else if (typeof o4 == "object") {
      const res = {};
      const keys = Object.keys(o4);
      keys.forEach((k5) => {
        res[k5] = stringifyBigInts(o4[k5]);
      });
      return res;
    } else {
      return o4;
    }
  }
  function unstringifyBigInts(o4) {
    if (typeof o4 == "string" && /^[0-9]+$/.test(o4)) {
      return BigInt(o4);
    } else if (typeof o4 == "string" && /^0x[0-9a-fA-F]+$/.test(o4)) {
      return BigInt(o4);
    } else if (Array.isArray(o4)) {
      return o4.map(unstringifyBigInts);
    } else if (typeof o4 == "object") {
      if (o4 === null)
        return null;
      const res = {};
      const keys = Object.keys(o4);
      keys.forEach((k5) => {
        res[k5] = unstringifyBigInts(o4[k5]);
      });
      return res;
    } else {
      return o4;
    }
  }
  function beBuff2int(buff) {
    let res = BigInt(0);
    let i4 = buff.length;
    let offset = 0;
    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
    while (i4 > 0) {
      if (i4 >= 4) {
        i4 -= 4;
        res += BigInt(buffV.getUint32(i4)) << BigInt(offset * 8);
        offset += 4;
      } else if (i4 >= 2) {
        i4 -= 2;
        res += BigInt(buffV.getUint16(i4)) << BigInt(offset * 8);
        offset += 2;
      } else {
        i4 -= 1;
        res += BigInt(buffV.getUint8(i4)) << BigInt(offset * 8);
        offset += 1;
      }
    }
    return res;
  }
  function beInt2Buff(n4, len) {
    let r = n4;
    const buff = new Uint8Array(len);
    const buffV = new DataView(buff.buffer);
    let o4 = len;
    while (o4 > 0) {
      if (o4 - 4 >= 0) {
        o4 -= 4;
        buffV.setUint32(o4, Number(r & BigInt(4294967295)));
        r = r >> BigInt(32);
      } else if (o4 - 2 >= 0) {
        o4 -= 2;
        buffV.setUint16(o4, Number(r & BigInt(65535)));
        r = r >> BigInt(16);
      } else {
        o4 -= 1;
        buffV.setUint8(o4, Number(r & BigInt(255)));
        r = r >> BigInt(8);
      }
    }
    if (r) {
      throw new Error("Number does not fit in this length");
    }
    return buff;
  }
  function leBuff2int(buff) {
    let res = BigInt(0);
    let i4 = 0;
    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
    while (i4 < buff.length) {
      if (i4 + 4 <= buff.length) {
        res += BigInt(buffV.getUint32(i4, true)) << BigInt(i4 * 8);
        i4 += 4;
      } else if (i4 + 2 <= buff.length) {
        res += BigInt(buffV.getUint16(i4, true)) << BigInt(i4 * 8);
        i4 += 2;
      } else {
        res += BigInt(buffV.getUint8(i4, true)) << BigInt(i4 * 8);
        i4 += 1;
      }
    }
    return res;
  }
  function leInt2Buff(n4, len) {
    let r = n4;
    if (typeof len === "undefined") {
      len = Math.floor((bitLength$6(n4) - 1) / 8) + 1;
      if (len == 0)
        len = 1;
    }
    const buff = new Uint8Array(len);
    const buffV = new DataView(buff.buffer);
    let o4 = 0;
    while (o4 < len) {
      if (o4 + 4 <= len) {
        buffV.setUint32(o4, Number(r & BigInt(4294967295)), true);
        o4 += 4;
        r = r >> BigInt(32);
      } else if (o4 + 2 <= len) {
        buffV.setUint16(o4, Number(r & BigInt(65535)), true);
        o4 += 2;
        r = r >> BigInt(16);
      } else {
        buffV.setUint8(o4, Number(r & BigInt(255)), true);
        o4 += 1;
        r = r >> BigInt(8);
      }
    }
    if (r) {
      throw new Error("Number does not fit in this length");
    }
    return buff;
  }
  function stringifyFElements(F4, o4) {
    if (typeof o4 == "bigint" || o4.eq !== void 0) {
      return o4.toString(10);
    } else if (o4 instanceof Uint8Array) {
      return F4.toString(F4.e(o4));
    } else if (Array.isArray(o4)) {
      return o4.map(stringifyFElements.bind(this, F4));
    } else if (typeof o4 == "object") {
      const res = {};
      const keys = Object.keys(o4);
      keys.forEach((k5) => {
        res[k5] = stringifyFElements(F4, o4[k5]);
      });
      return res;
    } else {
      return o4;
    }
  }
  function unstringifyFElements(F4, o4) {
    if (typeof o4 == "string" && /^[0-9]+$/.test(o4)) {
      return F4.e(o4);
    } else if (typeof o4 == "string" && /^0x[0-9a-fA-F]+$/.test(o4)) {
      return F4.e(o4);
    } else if (Array.isArray(o4)) {
      return o4.map(unstringifyFElements.bind(this, F4));
    } else if (typeof o4 == "object") {
      if (o4 === null)
        return null;
      const res = {};
      const keys = Object.keys(o4);
      keys.forEach((k5) => {
        res[k5] = unstringifyFElements(F4, o4[k5]);
      });
      return res;
    } else {
      return o4;
    }
  }
  var _revTable = [];
  for (let i4 = 0; i4 < 256; i4++) {
    _revTable[i4] = _revSlow(i4, 8);
  }
  function _revSlow(idx, bits2) {
    let res = 0;
    let a4 = idx;
    for (let i4 = 0; i4 < bits2; i4++) {
      res <<= 1;
      res = res | a4 & 1;
      a4 >>= 1;
    }
    return res;
  }
  function bitReverse(idx, bits2) {
    return (_revTable[idx >>> 24] | _revTable[idx >>> 16 & 255] << 8 | _revTable[idx >>> 8 & 255] << 16 | _revTable[idx & 255] << 24) >>> 32 - bits2;
  }
  function log2(V5) {
    return ((V5 & 4294901760) !== 0 ? (V5 &= 4294901760, 16) : 0) | ((V5 & 4278255360) !== 0 ? (V5 &= 4278255360, 8) : 0) | ((V5 & 4042322160) !== 0 ? (V5 &= 4042322160, 4) : 0) | ((V5 & 3435973836) !== 0 ? (V5 &= 3435973836, 2) : 0) | (V5 & 2863311530) !== 0;
  }
  function buffReverseBits(buff, eSize) {
    const n4 = buff.byteLength / eSize;
    const bits2 = log2(n4);
    if (n4 != 1 << bits2) {
      throw new Error("Invalid number of pointers");
    }
    for (let i4 = 0; i4 < n4; i4++) {
      const r = bitReverse(i4, bits2);
      if (i4 > r) {
        const tmp = buff.slice(i4 * eSize, (i4 + 1) * eSize);
        buff.set(buff.slice(r * eSize, (r + 1) * eSize), i4 * eSize);
        buff.set(tmp, r * eSize);
      }
    }
  }
  function array2buffer(arr, sG) {
    const buff = new Uint8Array(sG * arr.length);
    for (let i4 = 0; i4 < arr.length; i4++) {
      buff.set(arr[i4], i4 * sG);
    }
    return buff;
  }
  function buffer2array(buff, sG) {
    const n4 = buff.byteLength / sG;
    const arr = new Array(n4);
    for (let i4 = 0; i4 < n4; i4++) {
      arr[i4] = buff.slice(i4 * sG, i4 * sG + sG);
    }
    return arr;
  }
  var _utils = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    array2buffer,
    beBuff2int,
    beInt2Buff,
    bitReverse,
    buffReverseBits,
    buffer2array,
    leBuff2int,
    leInt2Buff,
    log2,
    stringifyBigInts,
    stringifyFElements,
    unstringifyBigInts,
    unstringifyFElements
  });
  var PAGE_SIZE = 1 << 30;
  var BigBuffer = class {
    constructor(size) {
      this.buffers = [];
      this.byteLength = size;
      for (let i4 = 0; i4 < size; i4 += PAGE_SIZE) {
        const n4 = Math.min(size - i4, PAGE_SIZE);
        this.buffers.push(new Uint8Array(n4));
      }
    }
    slice(fr2, to2) {
      if (to2 === void 0)
        to2 = this.byteLength;
      if (fr2 === void 0)
        fr2 = 0;
      const len = to2 - fr2;
      const firstPage = Math.floor(fr2 / PAGE_SIZE);
      const lastPage = Math.floor((fr2 + len - 1) / PAGE_SIZE);
      if (firstPage == lastPage || len == 0)
        return this.buffers[firstPage].slice(fr2 % PAGE_SIZE, fr2 % PAGE_SIZE + len);
      let buff;
      let p6 = firstPage;
      let o4 = fr2 % PAGE_SIZE;
      let r = len;
      while (r > 0) {
        const l6 = o4 + r > PAGE_SIZE ? PAGE_SIZE - o4 : r;
        const srcView = new Uint8Array(this.buffers[p6].buffer, this.buffers[p6].byteOffset + o4, l6);
        if (l6 == len)
          return srcView.slice();
        if (!buff) {
          if (len <= PAGE_SIZE) {
            buff = new Uint8Array(len);
          } else {
            buff = new BigBuffer(len);
          }
        }
        buff.set(srcView, len - r);
        r = r - l6;
        p6++;
        o4 = 0;
      }
      return buff;
    }
    set(buff, offset) {
      if (offset === void 0)
        offset = 0;
      const len = buff.byteLength;
      if (len == 0)
        return;
      const firstPage = Math.floor(offset / PAGE_SIZE);
      const lastPage = Math.floor((offset + len - 1) / PAGE_SIZE);
      if (firstPage == lastPage) {
        if (buff instanceof BigBuffer && buff.buffers.length == 1) {
          return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);
        } else {
          return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);
        }
      }
      let p6 = firstPage;
      let o4 = offset % PAGE_SIZE;
      let r = len;
      while (r > 0) {
        const l6 = o4 + r > PAGE_SIZE ? PAGE_SIZE - o4 : r;
        const srcView = buff.slice(len - r, len - r + l6);
        const dstView = new Uint8Array(this.buffers[p6].buffer, this.buffers[p6].byteOffset + o4, l6);
        dstView.set(srcView);
        r = r - l6;
        p6++;
        o4 = 0;
      }
    }
  };
  function buildBatchConvert(tm, fnName, sIn, sOut) {
    return async function batchConvert(buffIn) {
      const nPoints = Math.floor(buffIn.byteLength / sIn);
      if (nPoints * sIn !== buffIn.byteLength) {
        throw new Error("Invalid buffer size");
      }
      const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
      const opPromises = [];
      for (let i4 = 0; i4 < tm.concurrency; i4++) {
        let n4;
        if (i4 < tm.concurrency - 1) {
          n4 = pointsPerChunk;
        } else {
          n4 = nPoints - i4 * pointsPerChunk;
        }
        if (n4 == 0)
          continue;
        const buffChunk = buffIn.slice(i4 * pointsPerChunk * sIn, i4 * pointsPerChunk * sIn + n4 * sIn);
        const task = [
          { cmd: "ALLOCSET", var: 0, buff: buffChunk },
          { cmd: "ALLOC", var: 1, len: sOut * n4 },
          { cmd: "CALL", fnName, params: [
            { var: 0 },
            { val: n4 },
            { var: 1 }
          ] },
          { cmd: "GET", out: 0, var: 1, len: sOut * n4 }
        ];
        opPromises.push(
          tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      let fullBuffOut;
      if (buffIn instanceof BigBuffer) {
        fullBuffOut = new BigBuffer(nPoints * sOut);
      } else {
        fullBuffOut = new Uint8Array(nPoints * sOut);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        fullBuffOut.set(result[i4][0], p6);
        p6 += result[i4][0].byteLength;
      }
      return fullBuffOut;
    };
  }
  var WasmField1 = class {
    constructor(tm, prefix, n8, p6) {
      this.tm = tm;
      this.prefix = prefix;
      this.p = p6;
      this.n8 = n8;
      this.type = "F1";
      this.m = 1;
      this.half = shiftRight(p6, one);
      this.bitLength = bitLength$6(p6);
      this.mask = sub(shiftLeft(one, this.bitLength), one);
      this.pOp1 = tm.alloc(n8);
      this.pOp2 = tm.alloc(n8);
      this.pOp3 = tm.alloc(n8);
      this.tm.instance.exports[prefix + "_zero"](this.pOp1);
      this.zero = this.tm.getBuff(this.pOp1, this.n8);
      this.tm.instance.exports[prefix + "_one"](this.pOp1);
      this.one = this.tm.getBuff(this.pOp1, this.n8);
      this.negone = this.neg(this.one);
      this.two = this.add(this.one, this.one);
      this.n64 = Math.floor(n8 / 8);
      this.n32 = Math.floor(n8 / 4);
      if (this.n64 * 8 != this.n8) {
        throw new Error("n8 must be a multiple of 8");
      }
      this.half = shiftRight(this.p, one);
      this.nqr = this.two;
      let r = this.exp(this.nqr, this.half);
      while (!this.eq(r, this.negone)) {
        this.nqr = this.add(this.nqr, this.one);
        r = this.exp(this.nqr, this.half);
      }
      this.shift = this.mul(this.nqr, this.nqr);
      this.shiftInv = this.inv(this.shift);
      this.s = 0;
      let t = sub(this.p, one);
      while (!isOdd$5(t)) {
        this.s = this.s + 1;
        t = shiftRight(t, one);
      }
      this.w = [];
      this.w[this.s] = this.exp(this.nqr, t);
      for (let i4 = this.s - 1; i4 >= 0; i4--) {
        this.w[i4] = this.square(this.w[i4 + 1]);
      }
      if (!this.eq(this.w[0], this.one)) {
        throw new Error("Error calculating roots of unity");
      }
      this.batchToMontgomery = buildBatchConvert(tm, prefix + "_batchToMontgomery", this.n8, this.n8);
      this.batchFromMontgomery = buildBatchConvert(tm, prefix + "_batchFromMontgomery", this.n8, this.n8);
    }
    op2(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op2Bool(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }
    op1(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op1Bool(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }
    add(a4, b7) {
      return this.op2("_add", a4, b7);
    }
    eq(a4, b7) {
      return this.op2Bool("_eq", a4, b7);
    }
    isZero(a4) {
      return this.op1Bool("_isZero", a4);
    }
    sub(a4, b7) {
      return this.op2("_sub", a4, b7);
    }
    neg(a4) {
      return this.op1("_neg", a4);
    }
    inv(a4) {
      return this.op1("_inverse", a4);
    }
    toMontgomery(a4) {
      return this.op1("_toMontgomery", a4);
    }
    fromMontgomery(a4) {
      return this.op1("_fromMontgomery", a4);
    }
    mul(a4, b7) {
      return this.op2("_mul", a4, b7);
    }
    div(a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
      this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    square(a4) {
      return this.op1("_square", a4);
    }
    isSquare(a4) {
      return this.op1Bool("_isSquare", a4);
    }
    sqrt(a4) {
      return this.op1("_sqrt", a4);
    }
    exp(a4, b7) {
      if (!(b7 instanceof Uint8Array)) {
        b7 = toLEBuff(e6(b7));
      }
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b7.byteLength, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    isNegative(a4) {
      return this.op1Bool("_isNegative", a4);
    }
    e(a4, b7) {
      if (a4 instanceof Uint8Array)
        return a4;
      let ra2 = e6(a4, b7);
      if (isNegative$4(ra2)) {
        ra2 = neg(ra2);
        if (gt2(ra2, this.p)) {
          ra2 = mod(ra2, this.p);
        }
        ra2 = sub(this.p, ra2);
      } else {
        if (gt2(ra2, this.p)) {
          ra2 = mod(ra2, this.p);
        }
      }
      const buff = leInt2Buff(ra2, this.n8);
      return this.toMontgomery(buff);
    }
    toString(a4, radix) {
      const an2 = this.fromMontgomery(a4);
      const s3 = fromRprLE(an2, 0);
      return toString(s3, radix);
    }
    fromRng(rng2) {
      let v6;
      const buff = new Uint8Array(this.n8);
      do {
        v6 = zero;
        for (let i4 = 0; i4 < this.n64; i4++) {
          v6 = add(v6, shiftLeft(rng2.nextU64(), 64 * i4));
        }
        v6 = band(v6, this.mask);
      } while (geq(v6, this.p));
      toRprLE(buff, 0, v6, this.n8);
      return buff;
    }
    random() {
      return this.fromRng(getThreadRng());
    }
    toObject(a4) {
      const an2 = this.fromMontgomery(a4);
      return fromRprLE(an2, 0);
    }
    fromObject(a4) {
      const buff = new Uint8Array(this.n8);
      toRprLE(buff, 0, a4, this.n8);
      return this.toMontgomery(buff);
    }
    toRprLE(buff, offset, a4) {
      buff.set(this.fromMontgomery(a4), offset);
    }
    toRprBE(buff, offset, a4) {
      const buff2 = this.fromMontgomery(a4);
      for (let i4 = 0; i4 < this.n8 / 2; i4++) {
        const aux = buff2[i4];
        buff2[i4] = buff2[this.n8 - 1 - i4];
        buff2[this.n8 - 1 - i4] = aux;
      }
      buff.set(buff2, offset);
    }
    fromRprLE(buff, offset) {
      offset = offset || 0;
      const res = buff.slice(offset, offset + this.n8);
      return this.toMontgomery(res);
    }
    async batchInverse(buffIn) {
      let returnArray = false;
      const sIn = this.n8;
      const sOut = this.n8;
      if (Array.isArray(buffIn)) {
        buffIn = array2buffer(buffIn, sIn);
        returnArray = true;
      } else {
        buffIn = buffIn.slice(0, buffIn.byteLength);
      }
      const nPoints = Math.floor(buffIn.byteLength / sIn);
      if (nPoints * sIn !== buffIn.byteLength) {
        throw new Error("Invalid buffer size");
      }
      const pointsPerChunk = Math.floor(nPoints / this.tm.concurrency);
      const opPromises = [];
      for (let i4 = 0; i4 < this.tm.concurrency; i4++) {
        let n4;
        if (i4 < this.tm.concurrency - 1) {
          n4 = pointsPerChunk;
        } else {
          n4 = nPoints - i4 * pointsPerChunk;
        }
        if (n4 == 0)
          continue;
        const buffChunk = buffIn.slice(i4 * pointsPerChunk * sIn, i4 * pointsPerChunk * sIn + n4 * sIn);
        const task = [
          { cmd: "ALLOCSET", var: 0, buff: buffChunk },
          { cmd: "ALLOC", var: 1, len: sOut * n4 },
          { cmd: "CALL", fnName: this.prefix + "_batchInverse", params: [
            { var: 0 },
            { val: sIn },
            { val: n4 },
            { var: 1 },
            { val: sOut }
          ] },
          { cmd: "GET", out: 0, var: 1, len: sOut * n4 }
        ];
        opPromises.push(
          this.tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      let fullBuffOut;
      if (buffIn instanceof BigBuffer) {
        fullBuffOut = new BigBuffer(nPoints * sOut);
      } else {
        fullBuffOut = new Uint8Array(nPoints * sOut);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        fullBuffOut.set(result[i4][0], p6);
        p6 += result[i4][0].byteLength;
      }
      if (returnArray) {
        return buffer2array(fullBuffOut, sOut);
      } else {
        return fullBuffOut;
      }
    }
  };
  var WasmField2 = class {
    constructor(tm, prefix, F4) {
      this.tm = tm;
      this.prefix = prefix;
      this.F = F4;
      this.type = "F2";
      this.m = F4.m * 2;
      this.n8 = this.F.n8 * 2;
      this.n32 = this.F.n32 * 2;
      this.n64 = this.F.n64 * 2;
      this.pOp1 = tm.alloc(F4.n8 * 2);
      this.pOp2 = tm.alloc(F4.n8 * 2);
      this.pOp3 = tm.alloc(F4.n8 * 2);
      this.tm.instance.exports[prefix + "_zero"](this.pOp1);
      this.zero = tm.getBuff(this.pOp1, this.n8);
      this.tm.instance.exports[prefix + "_one"](this.pOp1);
      this.one = tm.getBuff(this.pOp1, this.n8);
      this.negone = this.neg(this.one);
      this.two = this.add(this.one, this.one);
    }
    op2(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op2Bool(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }
    op1(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op1Bool(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }
    add(a4, b7) {
      return this.op2("_add", a4, b7);
    }
    eq(a4, b7) {
      return this.op2Bool("_eq", a4, b7);
    }
    isZero(a4) {
      return this.op1Bool("_isZero", a4);
    }
    sub(a4, b7) {
      return this.op2("_sub", a4, b7);
    }
    neg(a4) {
      return this.op1("_neg", a4);
    }
    inv(a4) {
      return this.op1("_inverse", a4);
    }
    isNegative(a4) {
      return this.op1Bool("_isNegative", a4);
    }
    toMontgomery(a4) {
      return this.op1("_toMontgomery", a4);
    }
    fromMontgomery(a4) {
      return this.op1("_fromMontgomery", a4);
    }
    mul(a4, b7) {
      return this.op2("_mul", a4, b7);
    }
    mul1(a4, b7) {
      return this.op2("_mul1", a4, b7);
    }
    div(a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
      this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    square(a4) {
      return this.op1("_square", a4);
    }
    isSquare(a4) {
      return this.op1Bool("_isSquare", a4);
    }
    sqrt(a4) {
      return this.op1("_sqrt", a4);
    }
    exp(a4, b7) {
      if (!(b7 instanceof Uint8Array)) {
        b7 = toLEBuff(e6(b7));
      }
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b7.byteLength, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    e(a4, b7) {
      if (a4 instanceof Uint8Array)
        return a4;
      if (Array.isArray(a4) && a4.length == 2) {
        const c1 = this.F.e(a4[0], b7);
        const c22 = this.F.e(a4[1], b7);
        const res = new Uint8Array(this.F.n8 * 2);
        res.set(c1);
        res.set(c22, this.F.n8 * 2);
        return res;
      } else {
        throw new Error("invalid F2");
      }
    }
    toString(a4, radix) {
      const s1 = this.F.toString(a4.slice(0, this.F.n8), radix);
      const s22 = this.F.toString(a4.slice(this.F.n8), radix);
      return `[${s1}, ${s22}]`;
    }
    fromRng(rng2) {
      const c1 = this.F.fromRng(rng2);
      const c22 = this.F.fromRng(rng2);
      const res = new Uint8Array(this.F.n8 * 2);
      res.set(c1);
      res.set(c22, this.F.n8);
      return res;
    }
    random() {
      return this.fromRng(getThreadRng());
    }
    toObject(a4) {
      const c1 = this.F.toObject(a4.slice(0, this.F.n8));
      const c22 = this.F.toObject(a4.slice(this.F.n8, this.F.n8 * 2));
      return [c1, c22];
    }
    fromObject(a4) {
      const buff = new Uint8Array(this.F.n8 * 2);
      const b1 = this.F.fromObject(a4[0]);
      const b22 = this.F.fromObject(a4[1]);
      buff.set(b1);
      buff.set(b22, this.F.n8);
      return buff;
    }
    c1(a4) {
      return a4.slice(0, this.F.n8);
    }
    c2(a4) {
      return a4.slice(this.F.n8);
    }
  };
  var WasmField3 = class {
    constructor(tm, prefix, F4) {
      this.tm = tm;
      this.prefix = prefix;
      this.F = F4;
      this.type = "F3";
      this.m = F4.m * 3;
      this.n8 = this.F.n8 * 3;
      this.n32 = this.F.n32 * 3;
      this.n64 = this.F.n64 * 3;
      this.pOp1 = tm.alloc(F4.n8 * 3);
      this.pOp2 = tm.alloc(F4.n8 * 3);
      this.pOp3 = tm.alloc(F4.n8 * 3);
      this.tm.instance.exports[prefix + "_zero"](this.pOp1);
      this.zero = tm.getBuff(this.pOp1, this.n8);
      this.tm.instance.exports[prefix + "_one"](this.pOp1);
      this.one = tm.getBuff(this.pOp1, this.n8);
      this.negone = this.neg(this.one);
      this.two = this.add(this.one, this.one);
    }
    op2(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op2Bool(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
    }
    op1(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    op1Bool(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }
    eq(a4, b7) {
      return this.op2Bool("_eq", a4, b7);
    }
    isZero(a4) {
      return this.op1Bool("_isZero", a4);
    }
    add(a4, b7) {
      return this.op2("_add", a4, b7);
    }
    sub(a4, b7) {
      return this.op2("_sub", a4, b7);
    }
    neg(a4) {
      return this.op1("_neg", a4);
    }
    inv(a4) {
      return this.op1("_inverse", a4);
    }
    isNegative(a4) {
      return this.op1Bool("_isNegative", a4);
    }
    toMontgomery(a4) {
      return this.op1("_toMontgomery", a4);
    }
    fromMontgomery(a4) {
      return this.op1("_fromMontgomery", a4);
    }
    mul(a4, b7) {
      return this.op2("_mul", a4, b7);
    }
    div(a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
      this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.n8);
    }
    square(a4) {
      return this.op1("_square", a4);
    }
    isSquare(a4) {
      return this.op1Bool("_isSquare", a4);
    }
    sqrt(a4) {
      return this.op1("_sqrt", a4);
    }
    exp(a4, b7) {
      if (!(b7 instanceof Uint8Array)) {
        b7 = toLEBuff(e6(b7));
      }
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b7.byteLength, this.pOp3);
      return this.getBuff(this.pOp3, this.n8);
    }
    e(a4, b7) {
      if (a4 instanceof Uint8Array)
        return a4;
      if (Array.isArray(a4) && a4.length == 3) {
        const c1 = this.F.e(a4[0], b7);
        const c22 = this.F.e(a4[1], b7);
        const c3 = this.F.e(a4[2], b7);
        const res = new Uint8Array(this.F.n8 * 3);
        res.set(c1);
        res.set(c22, this.F.n8);
        res.set(c3, this.F.n8 * 2);
        return res;
      } else {
        throw new Error("invalid F3");
      }
    }
    toString(a4, radix) {
      const s1 = this.F.toString(a4.slice(0, this.F.n8), radix);
      const s22 = this.F.toString(a4.slice(this.F.n8, this.F.n8 * 2), radix);
      const s3 = this.F.toString(a4.slice(this.F.n8 * 2), radix);
      return `[${s1}, ${s22}, ${s3}]`;
    }
    fromRng(rng2) {
      const c1 = this.F.fromRng(rng2);
      const c22 = this.F.fromRng(rng2);
      const c3 = this.F.fromRng(rng2);
      const res = new Uint8Array(this.F.n8 * 3);
      res.set(c1);
      res.set(c22, this.F.n8);
      res.set(c3, this.F.n8 * 2);
      return res;
    }
    random() {
      return this.fromRng(getThreadRng());
    }
    toObject(a4) {
      const c1 = this.F.toObject(a4.slice(0, this.F.n8));
      const c22 = this.F.toObject(a4.slice(this.F.n8, this.F.n8 * 2));
      const c3 = this.F.toObject(a4.slice(this.F.n8 * 2, this.F.n8 * 3));
      return [c1, c22, c3];
    }
    fromObject(a4) {
      const buff = new Uint8Array(this.F.n8 * 3);
      const b1 = this.F.fromObject(a4[0]);
      const b22 = this.F.fromObject(a4[1]);
      const b32 = this.F.fromObject(a4[2]);
      buff.set(b1);
      buff.set(b22, this.F.n8);
      buff.set(b32, this.F.n8 * 2);
      return buff;
    }
    c1(a4) {
      return a4.slice(0, this.F.n8);
    }
    c2(a4) {
      return a4.slice(this.F.n8, this.F.n8 * 2);
    }
    c3(a4) {
      return a4.slice(this.F.n8 * 2);
    }
  };
  var WasmCurve = class {
    constructor(tm, prefix, F4, pGen, pGb, cofactor) {
      this.tm = tm;
      this.prefix = prefix;
      this.F = F4;
      this.pOp1 = tm.alloc(F4.n8 * 3);
      this.pOp2 = tm.alloc(F4.n8 * 3);
      this.pOp3 = tm.alloc(F4.n8 * 3);
      this.tm.instance.exports[prefix + "_zero"](this.pOp1);
      this.zero = this.tm.getBuff(this.pOp1, F4.n8 * 3);
      this.tm.instance.exports[prefix + "_zeroAffine"](this.pOp1);
      this.zeroAffine = this.tm.getBuff(this.pOp1, F4.n8 * 2);
      this.one = this.tm.getBuff(pGen, F4.n8 * 3);
      this.g = this.one;
      this.oneAffine = this.tm.getBuff(pGen, F4.n8 * 2);
      this.gAffine = this.oneAffine;
      this.b = this.tm.getBuff(pGb, F4.n8);
      if (cofactor) {
        this.cofactor = toLEBuff(cofactor);
      }
      this.negone = this.neg(this.one);
      this.two = this.add(this.one, this.one);
      this.batchLEMtoC = buildBatchConvert(tm, prefix + "_batchLEMtoC", F4.n8 * 2, F4.n8);
      this.batchLEMtoU = buildBatchConvert(tm, prefix + "_batchLEMtoU", F4.n8 * 2, F4.n8 * 2);
      this.batchCtoLEM = buildBatchConvert(tm, prefix + "_batchCtoLEM", F4.n8, F4.n8 * 2);
      this.batchUtoLEM = buildBatchConvert(tm, prefix + "_batchUtoLEM", F4.n8 * 2, F4.n8 * 2);
      this.batchToJacobian = buildBatchConvert(tm, prefix + "_batchToJacobian", F4.n8 * 2, F4.n8 * 3);
      this.batchToAffine = buildBatchConvert(tm, prefix + "_batchToAffine", F4.n8 * 3, F4.n8 * 2);
    }
    op2(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
    }
    op2bool(opName, a4, b7) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, b7);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
    }
    op1(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
    }
    op1Affine(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.F.n8 * 2);
    }
    op1Bool(opName, a4) {
      this.tm.setBuff(this.pOp1, a4);
      return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
    }
    add(a4, b7) {
      if (a4.byteLength == this.F.n8 * 3) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2("_add", a4, b7);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2("_addMixed", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else if (a4.byteLength == this.F.n8 * 2) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2("_addMixed", b7, a4);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2("_addAffine", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else {
        throw new Error("invalid point size");
      }
    }
    sub(a4, b7) {
      if (a4.byteLength == this.F.n8 * 3) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2("_sub", a4, b7);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2("_subMixed", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else if (a4.byteLength == this.F.n8 * 2) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2("_subMixed", b7, a4);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2("_subAffine", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else {
        throw new Error("invalid point size");
      }
    }
    neg(a4) {
      if (a4.byteLength == this.F.n8 * 3) {
        return this.op1("_neg", a4);
      } else if (a4.byteLength == this.F.n8 * 2) {
        return this.op1Affine("_negAffine", a4);
      } else {
        throw new Error("invalid point size");
      }
    }
    double(a4) {
      if (a4.byteLength == this.F.n8 * 3) {
        return this.op1("_double", a4);
      } else if (a4.byteLength == this.F.n8 * 2) {
        return this.op1("_doubleAffine", a4);
      } else {
        throw new Error("invalid point size");
      }
    }
    isZero(a4) {
      if (a4.byteLength == this.F.n8 * 3) {
        return this.op1Bool("_isZero", a4);
      } else if (a4.byteLength == this.F.n8 * 2) {
        return this.op1Bool("_isZeroAffine", a4);
      } else {
        throw new Error("invalid point size");
      }
    }
    timesScalar(a4, s3) {
      if (!(s3 instanceof Uint8Array)) {
        s3 = toLEBuff(e6(s3));
      }
      let fnName;
      if (a4.byteLength == this.F.n8 * 3) {
        fnName = this.prefix + "_timesScalar";
      } else if (a4.byteLength == this.F.n8 * 2) {
        fnName = this.prefix + "_timesScalarAffine";
      } else {
        throw new Error("invalid point size");
      }
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, s3);
      this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s3.byteLength, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
    }
    timesFr(a4, s3) {
      let fnName;
      if (a4.byteLength == this.F.n8 * 3) {
        fnName = this.prefix + "_timesFr";
      } else if (a4.byteLength == this.F.n8 * 2) {
        fnName = this.prefix + "_timesFrAffine";
      } else {
        throw new Error("invalid point size");
      }
      this.tm.setBuff(this.pOp1, a4);
      this.tm.setBuff(this.pOp2, s3);
      this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);
      return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
    }
    eq(a4, b7) {
      if (a4.byteLength == this.F.n8 * 3) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2bool("_eq", a4, b7);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2bool("_eqMixed", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else if (a4.byteLength == this.F.n8 * 2) {
        if (b7.byteLength == this.F.n8 * 3) {
          return this.op2bool("_eqMixed", b7, a4);
        } else if (b7.byteLength == this.F.n8 * 2) {
          return this.op2bool("_eqAffine", a4, b7);
        } else {
          throw new Error("invalid point size");
        }
      } else {
        throw new Error("invalid point size");
      }
    }
    toAffine(a4) {
      if (a4.byteLength == this.F.n8 * 3) {
        return this.op1Affine("_toAffine", a4);
      } else if (a4.byteLength == this.F.n8 * 2) {
        return a4;
      } else {
        throw new Error("invalid point size");
      }
    }
    toJacobian(a4) {
      if (a4.byteLength == this.F.n8 * 3) {
        return a4;
      } else if (a4.byteLength == this.F.n8 * 2) {
        return this.op1("_toJacobian", a4);
      } else {
        throw new Error("invalid point size");
      }
    }
    toRprUncompressed(arr, offset, a4) {
      this.tm.setBuff(this.pOp1, a4);
      if (a4.byteLength == this.F.n8 * 3) {
        this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
      } else if (a4.byteLength != this.F.n8 * 2) {
        throw new Error("invalid point size");
      }
      this.tm.instance.exports[this.prefix + "_LEMtoU"](this.pOp1, this.pOp1);
      const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
      arr.set(res, offset);
    }
    fromRprUncompressed(arr, offset) {
      const buff = arr.slice(offset, offset + this.F.n8 * 2);
      this.tm.setBuff(this.pOp1, buff);
      this.tm.instance.exports[this.prefix + "_UtoLEM"](this.pOp1, this.pOp1);
      return this.tm.getBuff(this.pOp1, this.F.n8 * 2);
    }
    toRprCompressed(arr, offset, a4) {
      this.tm.setBuff(this.pOp1, a4);
      if (a4.byteLength == this.F.n8 * 3) {
        this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
      } else if (a4.byteLength != this.F.n8 * 2) {
        throw new Error("invalid point size");
      }
      this.tm.instance.exports[this.prefix + "_LEMtoC"](this.pOp1, this.pOp1);
      const res = this.tm.getBuff(this.pOp1, this.F.n8);
      arr.set(res, offset);
    }
    fromRprCompressed(arr, offset) {
      const buff = arr.slice(offset, offset + this.F.n8);
      this.tm.setBuff(this.pOp1, buff);
      this.tm.instance.exports[this.prefix + "_CtoLEM"](this.pOp1, this.pOp2);
      return this.tm.getBuff(this.pOp2, this.F.n8 * 2);
    }
    toUncompressed(a4) {
      const buff = new Uint8Array(this.F.n8 * 2);
      this.toRprUncompressed(buff, 0, a4);
      return buff;
    }
    toRprLEM(arr, offset, a4) {
      if (a4.byteLength == this.F.n8 * 2) {
        arr.set(a4, offset);
        return;
      } else if (a4.byteLength == this.F.n8 * 3) {
        this.tm.setBuff(this.pOp1, a4);
        this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
        const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
        arr.set(res, offset);
      } else {
        throw new Error("invalid point size");
      }
    }
    fromRprLEM(arr, offset) {
      offset = offset || 0;
      return arr.slice(offset, offset + this.F.n8 * 2);
    }
    toString(a4, radix) {
      if (a4.byteLength == this.F.n8 * 3) {
        const x6 = this.F.toString(a4.slice(0, this.F.n8), radix);
        const y5 = this.F.toString(a4.slice(this.F.n8, this.F.n8 * 2), radix);
        const z6 = this.F.toString(a4.slice(this.F.n8 * 2), radix);
        return `[ ${x6}, ${y5}, ${z6} ]`;
      } else if (a4.byteLength == this.F.n8 * 2) {
        const x6 = this.F.toString(a4.slice(0, this.F.n8), radix);
        const y5 = this.F.toString(a4.slice(this.F.n8), radix);
        return `[ ${x6}, ${y5} ]`;
      } else {
        throw new Error("invalid point size");
      }
    }
    isValid(a4) {
      if (this.isZero(a4))
        return true;
      const F4 = this.F;
      const aa2 = this.toAffine(a4);
      const x6 = aa2.slice(0, this.F.n8);
      const y5 = aa2.slice(this.F.n8, this.F.n8 * 2);
      const x3b = F4.add(F4.mul(F4.square(x6), x6), this.b);
      const y22 = F4.square(y5);
      return F4.eq(x3b, y22);
    }
    fromRng(rng2) {
      const F4 = this.F;
      let P5 = [];
      let greatest;
      let x3b;
      do {
        P5[0] = F4.fromRng(rng2);
        greatest = rng2.nextBool();
        x3b = F4.add(F4.mul(F4.square(P5[0]), P5[0]), this.b);
      } while (!F4.isSquare(x3b));
      P5[1] = F4.sqrt(x3b);
      const s3 = F4.isNegative(P5[1]);
      if (greatest ^ s3)
        P5[1] = F4.neg(P5[1]);
      let Pbuff = new Uint8Array(this.F.n8 * 2);
      Pbuff.set(P5[0]);
      Pbuff.set(P5[1], this.F.n8);
      if (this.cofactor) {
        Pbuff = this.timesScalar(Pbuff, this.cofactor);
      }
      return Pbuff;
    }
    toObject(a4) {
      if (this.isZero(a4)) {
        return [
          this.F.toObject(this.F.zero),
          this.F.toObject(this.F.one),
          this.F.toObject(this.F.zero)
        ];
      }
      const x6 = this.F.toObject(a4.slice(0, this.F.n8));
      const y5 = this.F.toObject(a4.slice(this.F.n8, this.F.n8 * 2));
      let z6;
      if (a4.byteLength == this.F.n8 * 3) {
        z6 = this.F.toObject(a4.slice(this.F.n8 * 2, this.F.n8 * 3));
      } else {
        z6 = this.F.toObject(this.F.one);
      }
      return [x6, y5, z6];
    }
    fromObject(a4) {
      const x6 = this.F.fromObject(a4[0]);
      const y5 = this.F.fromObject(a4[1]);
      let z6;
      if (a4.length == 3) {
        z6 = this.F.fromObject(a4[2]);
      } else {
        z6 = this.F.one;
      }
      if (this.F.isZero(z6, this.F.one)) {
        return this.zeroAffine;
      } else if (this.F.eq(z6, this.F.one)) {
        const buff = new Uint8Array(this.F.n8 * 2);
        buff.set(x6);
        buff.set(y5, this.F.n8);
        return buff;
      } else {
        const buff = new Uint8Array(this.F.n8 * 3);
        buff.set(x6);
        buff.set(y5, this.F.n8);
        buff.set(z6, this.F.n8 * 2);
        return buff;
      }
    }
    e(a4) {
      if (a4 instanceof Uint8Array)
        return a4;
      return this.fromObject(a4);
    }
    x(a4) {
      const tmp = this.toAffine(a4);
      return tmp.slice(0, this.F.n8);
    }
    y(a4) {
      const tmp = this.toAffine(a4);
      return tmp.slice(this.F.n8);
    }
  };
  function thread(self2) {
    const MAXMEM = 32767;
    let instance;
    let memory;
    if (self2) {
      self2.onmessage = function(e7) {
        let data;
        if (e7.data) {
          data = e7.data;
        } else {
          data = e7;
        }
        if (data[0].cmd == "INIT") {
          init2(data[0]).then(function() {
            self2.postMessage(data.result);
          });
        } else if (data[0].cmd == "TERMINATE") {
          self2.close();
        } else {
          const res = runTask(data);
          self2.postMessage(res);
        }
      };
    }
    async function init2(data) {
      const code2 = new Uint8Array(data.code);
      const wasmModule = await WebAssembly.compile(code2);
      memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM });
      instance = await WebAssembly.instantiate(wasmModule, {
        env: {
          "memory": memory
        }
      });
    }
    function alloc(length2) {
      const u323 = new Uint32Array(memory.buffer, 0, 1);
      while (u323[0] & 3)
        u323[0]++;
      const res = u323[0];
      u323[0] += length2;
      if (u323[0] + length2 > memory.buffer.byteLength) {
        const currentPages = memory.buffer.byteLength / 65536;
        let requiredPages = Math.floor((u323[0] + length2) / 65536) + 1;
        if (requiredPages > MAXMEM)
          requiredPages = MAXMEM;
        memory.grow(requiredPages - currentPages);
      }
      return res;
    }
    function allocBuffer(buffer) {
      const p6 = alloc(buffer.byteLength);
      setBuffer(p6, buffer);
      return p6;
    }
    function getBuffer(pointer, length2) {
      const u8 = new Uint8Array(memory.buffer);
      return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length2);
    }
    function setBuffer(pointer, buffer) {
      const u8 = new Uint8Array(memory.buffer);
      u8.set(new Uint8Array(buffer), pointer);
    }
    function runTask(task) {
      if (task[0].cmd == "INIT") {
        return init2(task[0]);
      }
      const ctx = {
        vars: [],
        out: []
      };
      const u32a = new Uint32Array(memory.buffer, 0, 1);
      const oldAlloc = u32a[0];
      for (let i4 = 0; i4 < task.length; i4++) {
        switch (task[i4].cmd) {
          case "ALLOCSET":
            ctx.vars[task[i4].var] = allocBuffer(task[i4].buff);
            break;
          case "ALLOC":
            ctx.vars[task[i4].var] = alloc(task[i4].len);
            break;
          case "SET":
            setBuffer(ctx.vars[task[i4].var], task[i4].buff);
            break;
          case "CALL": {
            const params = [];
            for (let j5 = 0; j5 < task[i4].params.length; j5++) {
              const p6 = task[i4].params[j5];
              if (typeof p6.var !== "undefined") {
                params.push(ctx.vars[p6.var] + (p6.offset || 0));
              } else if (typeof p6.val != "undefined") {
                params.push(p6.val);
              }
            }
            instance.exports[task[i4].fnName](...params);
            break;
          }
          case "GET":
            ctx.out[task[i4].out] = getBuffer(ctx.vars[task[i4].var], task[i4].len).slice();
            break;
          default:
            throw new Error("Invalid cmd");
        }
      }
      const u32b = new Uint32Array(memory.buffer, 0, 1);
      u32b[0] = oldAlloc;
      return ctx.out;
    }
    return runTask;
  }
  var MEM_SIZE = 25;
  var Deferred = class {
    constructor() {
      this.promise = new Promise((resolve2, reject) => {
        this.reject = reject;
        this.resolve = resolve2;
      });
    }
  };
  function sleep(ms2) {
    return new Promise((resolve2) => setTimeout(resolve2, ms2));
  }
  var workerSource;
  var threadStr = `(${'function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == "INIT") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == "TERMINATE") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                "memory": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == "INIT") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case "ALLOCSET":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case "ALLOC":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case "SET":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case "CALL": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== "undefined") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != "undefined") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case "GET":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error("Invalid cmd");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}'})(self)`;
  {
    if (globalThis?.Blob) {
      const threadBytes = new TextEncoder().encode(threadStr);
      const workerBlob = new Blob([threadBytes], { type: "application/javascript" });
      workerSource = URL.createObjectURL(workerBlob);
    } else {
      workerSource = "data:application/javascript;base64," + globalThis.btoa(threadStr);
    }
  }
  async function buildThreadManager(wasm2, singleThread) {
    const tm = new ThreadManager();
    tm.memory = new WebAssembly.Memory({ initial: MEM_SIZE });
    tm.u8 = new Uint8Array(tm.memory.buffer);
    tm.u32 = new Uint32Array(tm.memory.buffer);
    const wasmModule = await WebAssembly.compile(wasm2.code);
    tm.instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": tm.memory
      }
    });
    if (!globalThis?.Worker) {
      singleThread = true;
    }
    tm.singleThread = singleThread;
    tm.initalPFree = tm.u32[0];
    tm.pq = wasm2.pq;
    tm.pr = wasm2.pr;
    tm.pG1gen = wasm2.pG1gen;
    tm.pG1zero = wasm2.pG1zero;
    tm.pG2gen = wasm2.pG2gen;
    tm.pG2zero = wasm2.pG2zero;
    tm.pOneT = wasm2.pOneT;
    if (singleThread) {
      tm.code = wasm2.code;
      tm.taskManager = thread();
      await tm.taskManager([{
        cmd: "INIT",
        init: MEM_SIZE,
        code: tm.code.slice()
      }]);
      tm.concurrency = 1;
    } else {
      tm.workers = [];
      tm.pendingDeferreds = [];
      tm.working = [];
      let concurrency = 2;
      {
        if (typeof navigator === "object" && navigator.hardwareConcurrency) {
          concurrency = navigator.hardwareConcurrency;
        }
      }
      if (concurrency == 0) {
        concurrency = 2;
      }
      if (concurrency > 64)
        concurrency = 64;
      tm.concurrency = concurrency;
      for (let i4 = 0; i4 < concurrency; i4++) {
        tm.workers[i4] = new Worker(workerSource);
        tm.workers[i4].addEventListener("message", getOnMsg(i4));
        tm.working[i4] = false;
      }
      const initPromises = [];
      for (let i4 = 0; i4 < tm.workers.length; i4++) {
        const copyCode = wasm2.code.slice();
        initPromises.push(tm.postAction(i4, [{
          cmd: "INIT",
          init: MEM_SIZE,
          code: copyCode
        }], [copyCode.buffer]));
      }
      await Promise.all(initPromises);
    }
    return tm;
    function getOnMsg(i4) {
      return function(e7) {
        let data;
        if (e7 && e7.data) {
          data = e7.data;
        } else {
          data = e7;
        }
        tm.working[i4] = false;
        tm.pendingDeferreds[i4].resolve(data);
        tm.processWorks();
      };
    }
  }
  var ThreadManager = class {
    constructor() {
      this.actionQueue = [];
      this.oldPFree = 0;
    }
    startSyncOp() {
      if (this.oldPFree != 0)
        throw new Error("Sync operation in progress");
      this.oldPFree = this.u32[0];
    }
    endSyncOp() {
      if (this.oldPFree == 0)
        throw new Error("No sync operation in progress");
      this.u32[0] = this.oldPFree;
      this.oldPFree = 0;
    }
    postAction(workerId, e7, transfers, _deferred) {
      if (this.working[workerId]) {
        throw new Error("Posting a job t a working worker");
      }
      this.working[workerId] = true;
      this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();
      this.workers[workerId].postMessage(e7, transfers);
      return this.pendingDeferreds[workerId].promise;
    }
    processWorks() {
      for (let i4 = 0; i4 < this.workers.length && this.actionQueue.length > 0; i4++) {
        if (this.working[i4] == false) {
          const work = this.actionQueue.shift();
          this.postAction(i4, work.data, work.transfers, work.deferred);
        }
      }
    }
    queueAction(actionData, transfers) {
      const d5 = new Deferred();
      if (this.singleThread) {
        const res = this.taskManager(actionData);
        d5.resolve(res);
      } else {
        this.actionQueue.push({
          data: actionData,
          transfers,
          deferred: d5
        });
        this.processWorks();
      }
      return d5.promise;
    }
    resetMemory() {
      this.u32[0] = this.initalPFree;
    }
    allocBuff(buff) {
      const pointer = this.alloc(buff.byteLength);
      this.setBuff(pointer, buff);
      return pointer;
    }
    getBuff(pointer, length2) {
      return this.u8.slice(pointer, pointer + length2);
    }
    setBuff(pointer, buffer) {
      this.u8.set(new Uint8Array(buffer), pointer);
    }
    alloc(length2) {
      while (this.u32[0] & 3)
        this.u32[0]++;
      const res = this.u32[0];
      this.u32[0] += length2;
      return res;
    }
    async terminate() {
      for (let i4 = 0; i4 < this.workers.length; i4++) {
        this.workers[i4].postMessage([{ cmd: "TERMINATE" }]);
      }
      await sleep(200);
    }
  };
  function buildBatchApplyKey(curve2, groupName) {
    const G7 = curve2[groupName];
    const Fr2 = curve2.Fr;
    const tm = curve2.tm;
    curve2[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {
      inType = inType || "affine";
      outType = outType || "affine";
      let fnName, fnAffine;
      let sGin, sGmid, sGout;
      if (groupName == "G1") {
        if (inType == "jacobian") {
          sGin = G7.F.n8 * 3;
          fnName = "g1m_batchApplyKey";
        } else {
          sGin = G7.F.n8 * 2;
          fnName = "g1m_batchApplyKeyMixed";
        }
        sGmid = G7.F.n8 * 3;
        if (outType == "jacobian") {
          sGout = G7.F.n8 * 3;
        } else {
          fnAffine = "g1m_batchToAffine";
          sGout = G7.F.n8 * 2;
        }
      } else if (groupName == "G2") {
        if (inType == "jacobian") {
          sGin = G7.F.n8 * 3;
          fnName = "g2m_batchApplyKey";
        } else {
          sGin = G7.F.n8 * 2;
          fnName = "g2m_batchApplyKeyMixed";
        }
        sGmid = G7.F.n8 * 3;
        if (outType == "jacobian") {
          sGout = G7.F.n8 * 3;
        } else {
          fnAffine = "g2m_batchToAffine";
          sGout = G7.F.n8 * 2;
        }
      } else if (groupName == "Fr") {
        fnName = "frm_batchApplyKey";
        sGin = G7.n8;
        sGmid = G7.n8;
        sGout = G7.n8;
      } else {
        throw new Error("Invalid group: " + groupName);
      }
      const nPoints = Math.floor(buff.byteLength / sGin);
      const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
      const opPromises = [];
      inc = Fr2.e(inc);
      let t = Fr2.e(first);
      for (let i4 = 0; i4 < tm.concurrency; i4++) {
        let n4;
        if (i4 < tm.concurrency - 1) {
          n4 = pointsPerChunk;
        } else {
          n4 = nPoints - i4 * pointsPerChunk;
        }
        if (n4 == 0)
          continue;
        const task = [];
        task.push({
          cmd: "ALLOCSET",
          var: 0,
          buff: buff.slice(i4 * pointsPerChunk * sGin, i4 * pointsPerChunk * sGin + n4 * sGin)
        });
        task.push({ cmd: "ALLOCSET", var: 1, buff: t });
        task.push({ cmd: "ALLOCSET", var: 2, buff: inc });
        task.push({ cmd: "ALLOC", var: 3, len: n4 * Math.max(sGmid, sGout) });
        task.push({
          cmd: "CALL",
          fnName,
          params: [
            { var: 0 },
            { val: n4 },
            { var: 1 },
            { var: 2 },
            { var: 3 }
          ]
        });
        if (fnAffine) {
          task.push({
            cmd: "CALL",
            fnName: fnAffine,
            params: [
              { var: 3 },
              { val: n4 },
              { var: 3 }
            ]
          });
        }
        task.push({ cmd: "GET", out: 0, var: 3, len: n4 * sGout });
        opPromises.push(tm.queueAction(task));
        t = Fr2.mul(t, Fr2.exp(inc, n4));
      }
      const result = await Promise.all(opPromises);
      let outBuff;
      if (buff instanceof BigBuffer) {
        outBuff = new BigBuffer(nPoints * sGout);
      } else {
        outBuff = new Uint8Array(nPoints * sGout);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        outBuff.set(result[i4][0], p6);
        p6 += result[i4][0].byteLength;
      }
      return outBuff;
    };
  }
  function buildPairing(curve2) {
    const tm = curve2.tm;
    curve2.pairing = function pairing(a4, b7) {
      tm.startSyncOp();
      const pA = tm.allocBuff(curve2.G1.toJacobian(a4));
      const pB = tm.allocBuff(curve2.G2.toJacobian(b7));
      const pRes = tm.alloc(curve2.Gt.n8);
      tm.instance.exports[curve2.name + "_pairing"](pA, pB, pRes);
      const res = tm.getBuff(pRes, curve2.Gt.n8);
      tm.endSyncOp();
      return res;
    };
    curve2.pairingEq = async function pairingEq() {
      let buffCt;
      let nEqs;
      if (arguments.length % 2 == 1) {
        buffCt = arguments[arguments.length - 1];
        nEqs = (arguments.length - 1) / 2;
      } else {
        buffCt = curve2.Gt.one;
        nEqs = arguments.length / 2;
      }
      const opPromises = [];
      for (let i4 = 0; i4 < nEqs; i4++) {
        const task = [];
        const g1Buff = curve2.G1.toJacobian(arguments[i4 * 2]);
        task.push({ cmd: "ALLOCSET", var: 0, buff: g1Buff });
        task.push({ cmd: "ALLOC", var: 1, len: curve2.prePSize });
        const g2Buff = curve2.G2.toJacobian(arguments[i4 * 2 + 1]);
        task.push({ cmd: "ALLOCSET", var: 2, buff: g2Buff });
        task.push({ cmd: "ALLOC", var: 3, len: curve2.preQSize });
        task.push({ cmd: "ALLOC", var: 4, len: curve2.Gt.n8 });
        task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG1", params: [
          { var: 0 },
          { var: 1 }
        ] });
        task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG2", params: [
          { var: 2 },
          { var: 3 }
        ] });
        task.push({ cmd: "CALL", fnName: curve2.name + "_millerLoop", params: [
          { var: 1 },
          { var: 3 },
          { var: 4 }
        ] });
        task.push({ cmd: "GET", out: 0, var: 4, len: curve2.Gt.n8 });
        opPromises.push(
          tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      tm.startSyncOp();
      const pRes = tm.alloc(curve2.Gt.n8);
      tm.instance.exports.ftm_one(pRes);
      for (let i4 = 0; i4 < result.length; i4++) {
        const pMR = tm.allocBuff(result[i4][0]);
        tm.instance.exports.ftm_mul(pRes, pMR, pRes);
      }
      tm.instance.exports[curve2.name + "_finalExponentiation"](pRes, pRes);
      const pCt = tm.allocBuff(buffCt);
      const r = !!tm.instance.exports.ftm_eq(pRes, pCt);
      tm.endSyncOp();
      return r;
    };
    curve2.prepareG1 = function(p6) {
      this.tm.startSyncOp();
      const pP = this.tm.allocBuff(p6);
      const pPrepP = this.tm.alloc(this.prePSize);
      this.tm.instance.exports[this.name + "_prepareG1"](pP, pPrepP);
      const res = this.tm.getBuff(pPrepP, this.prePSize);
      this.tm.endSyncOp();
      return res;
    };
    curve2.prepareG2 = function(q5) {
      this.tm.startSyncOp();
      const pQ = this.tm.allocBuff(q5);
      const pPrepQ = this.tm.alloc(this.preQSize);
      this.tm.instance.exports[this.name + "_prepareG2"](pQ, pPrepQ);
      const res = this.tm.getBuff(pPrepQ, this.preQSize);
      this.tm.endSyncOp();
      return res;
    };
    curve2.millerLoop = function(preP, preQ) {
      this.tm.startSyncOp();
      const pPreP = this.tm.allocBuff(preP);
      const pPreQ = this.tm.allocBuff(preQ);
      const pRes = this.tm.alloc(this.Gt.n8);
      this.tm.instance.exports[this.name + "_millerLoop"](pPreP, pPreQ, pRes);
      const res = this.tm.getBuff(pRes, this.Gt.n8);
      this.tm.endSyncOp();
      return res;
    };
    curve2.finalExponentiation = function(a4) {
      this.tm.startSyncOp();
      const pA = this.tm.allocBuff(a4);
      const pRes = this.tm.alloc(this.Gt.n8);
      this.tm.instance.exports[this.name + "_finalExponentiation"](pA, pRes);
      const res = this.tm.getBuff(pRes, this.Gt.n8);
      this.tm.endSyncOp();
      return res;
    };
  }
  var pTSizes = [
    1,
    1,
    1,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    13,
    14,
    15,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    17
  ];
  function buildMultiexp2(curve2, groupName) {
    const G7 = curve2[groupName];
    const tm = G7.tm;
    async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {
      if (!(buffBases instanceof Uint8Array)) {
        if (logger)
          logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
        throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
      }
      if (!(buffScalars instanceof Uint8Array)) {
        if (logger)
          logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
        throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
      }
      inType = inType || "affine";
      let sGIn;
      let fnName;
      if (groupName == "G1") {
        if (inType == "affine") {
          fnName = "g1m_multiexpAffine_chunk";
          sGIn = G7.F.n8 * 2;
        } else {
          fnName = "g1m_multiexp_chunk";
          sGIn = G7.F.n8 * 3;
        }
      } else if (groupName == "G2") {
        if (inType == "affine") {
          fnName = "g2m_multiexpAffine_chunk";
          sGIn = G7.F.n8 * 2;
        } else {
          fnName = "g2m_multiexp_chunk";
          sGIn = G7.F.n8 * 3;
        }
      } else {
        throw new Error("Invalid group");
      }
      const nPoints = Math.floor(buffBases.byteLength / sGIn);
      if (nPoints == 0)
        return G7.zero;
      const sScalar = Math.floor(buffScalars.byteLength / nPoints);
      if (sScalar * nPoints != buffScalars.byteLength) {
        throw new Error("Scalar size does not match");
      }
      const bitChunkSize = pTSizes[log2(nPoints)];
      const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
      const opPromises = [];
      for (let i4 = 0; i4 < nChunks; i4++) {
        const task = [
          { cmd: "ALLOCSET", var: 0, buff: buffBases },
          { cmd: "ALLOCSET", var: 1, buff: buffScalars },
          { cmd: "ALLOC", var: 2, len: G7.F.n8 * 3 },
          { cmd: "CALL", fnName, params: [
            { var: 0 },
            { var: 1 },
            { val: sScalar },
            { val: nPoints },
            { val: i4 * bitChunkSize },
            { val: Math.min(sScalar * 8 - i4 * bitChunkSize, bitChunkSize) },
            { var: 2 }
          ] },
          { cmd: "GET", out: 0, var: 2, len: G7.F.n8 * 3 }
        ];
        opPromises.push(
          G7.tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      let res = G7.zero;
      for (let i4 = result.length - 1; i4 >= 0; i4--) {
        if (!G7.isZero(res)) {
          for (let j5 = 0; j5 < bitChunkSize; j5++)
            res = G7.double(res);
        }
        res = G7.add(res, result[i4][0]);
      }
      return res;
    }
    async function _multiExp(buffBases, buffScalars, inType, logger, logText) {
      const MAX_CHUNK_SIZE = 1 << 22;
      const MIN_CHUNK_SIZE = 1 << 10;
      let sGIn;
      if (groupName == "G1") {
        if (inType == "affine") {
          sGIn = G7.F.n8 * 2;
        } else {
          sGIn = G7.F.n8 * 3;
        }
      } else if (groupName == "G2") {
        if (inType == "affine") {
          sGIn = G7.F.n8 * 2;
        } else {
          sGIn = G7.F.n8 * 3;
        }
      } else {
        throw new Error("Invalid group");
      }
      const nPoints = Math.floor(buffBases.byteLength / sGIn);
      const sScalar = Math.floor(buffScalars.byteLength / nPoints);
      if (sScalar * nPoints != buffScalars.byteLength) {
        throw new Error("Scalar size does not match");
      }
      const bitChunkSize = pTSizes[log2(nPoints)];
      const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
      let chunkSize;
      chunkSize = Math.floor(nPoints / (tm.concurrency / nChunks));
      if (chunkSize > MAX_CHUNK_SIZE)
        chunkSize = MAX_CHUNK_SIZE;
      if (chunkSize < MIN_CHUNK_SIZE)
        chunkSize = MIN_CHUNK_SIZE;
      const opPromises = [];
      for (let i4 = 0; i4 < nPoints; i4 += chunkSize) {
        if (logger)
          logger.debug(`Multiexp start: ${logText}: ${i4}/${nPoints}`);
        const n4 = Math.min(nPoints - i4, chunkSize);
        const buffBasesChunk = buffBases.slice(i4 * sGIn, (i4 + n4) * sGIn);
        const buffScalarsChunk = buffScalars.slice(i4 * sScalar, (i4 + n4) * sScalar);
        opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then((r) => {
          if (logger)
            logger.debug(`Multiexp end: ${logText}: ${i4}/${nPoints}`);
          return r;
        }));
      }
      const result = await Promise.all(opPromises);
      let res = G7.zero;
      for (let i4 = result.length - 1; i4 >= 0; i4--) {
        res = G7.add(res, result[i4]);
      }
      return res;
    }
    G7.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
      return await _multiExp(buffBases, buffScalars, "jacobian", logger, logText);
    };
    G7.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
      return await _multiExp(buffBases, buffScalars, "affine", logger, logText);
    };
  }
  function buildFFT2(curve2, groupName) {
    const G7 = curve2[groupName];
    const Fr2 = curve2.Fr;
    const tm = G7.tm;
    async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {
      inType = inType || "affine";
      outType = outType || "affine";
      const MAX_BITS_THREAD = 14;
      let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;
      if (groupName == "G1") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
          fnIn2Mid = "g1m_batchToJacobian";
        } else {
          sIn = G7.F.n8 * 3;
        }
        sMid = G7.F.n8 * 3;
        if (inverse) {
          fnFFTFinal = "g1m_fftFinal";
        }
        fnFFTJoin = "g1m_fftJoin";
        fnFFTMix = "g1m_fftMix";
        if (outType == "affine") {
          sOut = G7.F.n8 * 2;
          fnMid2Out = "g1m_batchToAffine";
        } else {
          sOut = G7.F.n8 * 3;
        }
      } else if (groupName == "G2") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
          fnIn2Mid = "g2m_batchToJacobian";
        } else {
          sIn = G7.F.n8 * 3;
        }
        sMid = G7.F.n8 * 3;
        if (inverse) {
          fnFFTFinal = "g2m_fftFinal";
        }
        fnFFTJoin = "g2m_fftJoin";
        fnFFTMix = "g2m_fftMix";
        if (outType == "affine") {
          sOut = G7.F.n8 * 2;
          fnMid2Out = "g2m_batchToAffine";
        } else {
          sOut = G7.F.n8 * 3;
        }
      } else if (groupName == "Fr") {
        sIn = G7.n8;
        sMid = G7.n8;
        sOut = G7.n8;
        if (inverse) {
          fnFFTFinal = "frm_fftFinal";
        }
        fnFFTMix = "frm_fftMix";
        fnFFTJoin = "frm_fftJoin";
      }
      let returnArray = false;
      if (Array.isArray(buff)) {
        buff = array2buffer(buff, sIn);
        returnArray = true;
      } else {
        buff = buff.slice(0, buff.byteLength);
      }
      const nPoints = buff.byteLength / sIn;
      const bits2 = log2(nPoints);
      if (1 << bits2 != nPoints) {
        throw new Error("fft must be multiple of 2");
      }
      if (bits2 == Fr2.s + 1) {
        let buffOut2;
        if (inverse) {
          buffOut2 = await _fftExtInv(buff, inType, outType, logger, loggerTxt);
        } else {
          buffOut2 = await _fftExt(buff, inType, outType, logger, loggerTxt);
        }
        if (returnArray) {
          return buffer2array(buffOut2, sOut);
        } else {
          return buffOut2;
        }
      }
      let inv;
      if (inverse) {
        inv = Fr2.inv(Fr2.e(nPoints));
      }
      let buffOut;
      buffReverseBits(buff, sIn);
      let chunks;
      let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);
      let nChunks = nPoints / pointsInChunk;
      while (nChunks < tm.concurrency && pointsInChunk >= 16) {
        nChunks *= 2;
        pointsInChunk /= 2;
      }
      const l2Chunk = log2(pointsInChunk);
      const promises = [];
      for (let i4 = 0; i4 < nChunks; i4++) {
        if (logger)
          logger.debug(`${loggerTxt}: fft ${bits2} mix start: ${i4}/${nChunks}`);
        const task = [];
        task.push({ cmd: "ALLOC", var: 0, len: sMid * pointsInChunk });
        const buffChunk = buff.slice(pointsInChunk * i4 * sIn, pointsInChunk * (i4 + 1) * sIn);
        task.push({ cmd: "SET", var: 0, buff: buffChunk });
        if (fnIn2Mid) {
          task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
        }
        for (let j5 = 1; j5 <= l2Chunk; j5++) {
          task.push({ cmd: "CALL", fnName: fnFFTMix, params: [{ var: 0 }, { val: pointsInChunk }, { val: j5 }] });
        }
        if (l2Chunk == bits2) {
          if (fnFFTFinal) {
            task.push({ cmd: "ALLOCSET", var: 1, buff: inv });
            task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
              { var: 0 },
              { val: pointsInChunk },
              { var: 1 }
            ] });
          }
          if (fnMid2Out) {
            task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
          }
          task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
        } else {
          task.push({ cmd: "GET", out: 0, var: 0, len: sMid * pointsInChunk });
        }
        promises.push(tm.queueAction(task).then((r) => {
          if (logger)
            logger.debug(`${loggerTxt}: fft ${bits2} mix end: ${i4}/${nChunks}`);
          return r;
        }));
      }
      chunks = await Promise.all(promises);
      for (let i4 = 0; i4 < nChunks; i4++)
        chunks[i4] = chunks[i4][0];
      for (let i4 = l2Chunk + 1; i4 <= bits2; i4++) {
        if (logger)
          logger.debug(`${loggerTxt}: fft  ${bits2}  join: ${i4}/${bits2}`);
        const nGroups = 1 << bits2 - i4;
        const nChunksPerGroup = nChunks / nGroups;
        const opPromises = [];
        for (let j5 = 0; j5 < nGroups; j5++) {
          for (let k5 = 0; k5 < nChunksPerGroup / 2; k5++) {
            const first = Fr2.exp(Fr2.w[i4], k5 * pointsInChunk);
            const inc = Fr2.w[i4];
            const o1 = j5 * nChunksPerGroup + k5;
            const o22 = j5 * nChunksPerGroup + k5 + nChunksPerGroup / 2;
            const task = [];
            task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
            task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o22] });
            task.push({ cmd: "ALLOCSET", var: 2, buff: first });
            task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
            task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
              { var: 0 },
              { var: 1 },
              { val: pointsInChunk },
              { var: 2 },
              { var: 3 }
            ] });
            if (i4 == bits2) {
              if (fnFFTFinal) {
                task.push({ cmd: "ALLOCSET", var: 4, buff: inv });
                task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                  { var: 0 },
                  { val: pointsInChunk },
                  { var: 4 }
                ] });
                task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                  { var: 1 },
                  { val: pointsInChunk },
                  { var: 4 }
                ] });
              }
              if (fnMid2Out) {
                task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
                task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: pointsInChunk }, { var: 1 }] });
              }
              task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
              task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sOut });
            } else {
              task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sMid });
              task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sMid });
            }
            opPromises.push(tm.queueAction(task).then((r) => {
              if (logger)
                logger.debug(`${loggerTxt}: fft ${bits2} join  ${i4}/${bits2}  ${j5 + 1}/${nGroups} ${k5}/${nChunksPerGroup / 2}`);
              return r;
            }));
          }
        }
        const res = await Promise.all(opPromises);
        for (let j5 = 0; j5 < nGroups; j5++) {
          for (let k5 = 0; k5 < nChunksPerGroup / 2; k5++) {
            const o1 = j5 * nChunksPerGroup + k5;
            const o22 = j5 * nChunksPerGroup + k5 + nChunksPerGroup / 2;
            const resChunk = res.shift();
            chunks[o1] = resChunk[0];
            chunks[o22] = resChunk[1];
          }
        }
      }
      if (buff instanceof BigBuffer) {
        buffOut = new BigBuffer(nPoints * sOut);
      } else {
        buffOut = new Uint8Array(nPoints * sOut);
      }
      if (inverse) {
        buffOut.set(chunks[0].slice((pointsInChunk - 1) * sOut));
        let p6 = sOut;
        for (let i4 = nChunks - 1; i4 > 0; i4--) {
          buffOut.set(chunks[i4], p6);
          p6 += pointsInChunk * sOut;
          delete chunks[i4];
        }
        buffOut.set(chunks[0].slice(0, (pointsInChunk - 1) * sOut), p6);
        delete chunks[0];
      } else {
        for (let i4 = 0; i4 < nChunks; i4++) {
          buffOut.set(chunks[i4], pointsInChunk * sOut * i4);
          delete chunks[i4];
        }
      }
      if (returnArray) {
        return buffer2array(buffOut, sOut);
      } else {
        return buffOut;
      }
    }
    async function _fftExt(buff, inType, outType, logger, loggerTxt) {
      let b1, b22;
      b1 = buff.slice(0, buff.byteLength / 2);
      b22 = buff.slice(buff.byteLength / 2, buff.byteLength);
      const promises = [];
      [b1, b22] = await _fftJoinExt(b1, b22, "fftJoinExt", Fr2.one, Fr2.shift, inType, "jacobian", logger, loggerTxt);
      promises.push(_fft(b1, false, "jacobian", outType, logger, loggerTxt));
      promises.push(_fft(b22, false, "jacobian", outType, logger, loggerTxt));
      const res1 = await Promise.all(promises);
      let buffOut;
      if (res1[0].byteLength > 1 << 28) {
        buffOut = new BigBuffer(res1[0].byteLength * 2);
      } else {
        buffOut = new Uint8Array(res1[0].byteLength * 2);
      }
      buffOut.set(res1[0]);
      buffOut.set(res1[1], res1[0].byteLength);
      return buffOut;
    }
    async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {
      let b1, b22;
      b1 = buff.slice(0, buff.byteLength / 2);
      b22 = buff.slice(buff.byteLength / 2, buff.byteLength);
      const promises = [];
      promises.push(_fft(b1, true, inType, "jacobian", logger, loggerTxt));
      promises.push(_fft(b22, true, inType, "jacobian", logger, loggerTxt));
      [b1, b22] = await Promise.all(promises);
      const res1 = await _fftJoinExt(b1, b22, "fftJoinExtInv", Fr2.one, Fr2.shiftInv, "jacobian", outType, logger, loggerTxt);
      let buffOut;
      if (res1[0].byteLength > 1 << 28) {
        buffOut = new BigBuffer(res1[0].byteLength * 2);
      } else {
        buffOut = new Uint8Array(res1[0].byteLength * 2);
      }
      buffOut.set(res1[0]);
      buffOut.set(res1[1], res1[0].byteLength);
      return buffOut;
    }
    async function _fftJoinExt(buff1, buff2, fn2, first, inc, inType, outType, logger, loggerTxt) {
      const MAX_CHUNK_SIZE = 1 << 16;
      const MIN_CHUNK_SIZE = 1 << 4;
      let fnName;
      let fnIn2Mid, fnMid2Out;
      let sOut, sIn, sMid;
      if (groupName == "G1") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
          fnIn2Mid = "g1m_batchToJacobian";
        } else {
          sIn = G7.F.n8 * 3;
        }
        sMid = G7.F.n8 * 3;
        fnName = "g1m_" + fn2;
        if (outType == "affine") {
          fnMid2Out = "g1m_batchToAffine";
          sOut = G7.F.n8 * 2;
        } else {
          sOut = G7.F.n8 * 3;
        }
      } else if (groupName == "G2") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
          fnIn2Mid = "g2m_batchToJacobian";
        } else {
          sIn = G7.F.n8 * 3;
        }
        fnName = "g2m_" + fn2;
        sMid = G7.F.n8 * 3;
        if (outType == "affine") {
          fnMid2Out = "g2m_batchToAffine";
          sOut = G7.F.n8 * 2;
        } else {
          sOut = G7.F.n8 * 3;
        }
      } else if (groupName == "Fr") {
        sIn = Fr2.n8;
        sOut = Fr2.n8;
        sMid = Fr2.n8;
        fnName = "frm_" + fn2;
      } else {
        throw new Error("Invalid group");
      }
      if (buff1.byteLength != buff2.byteLength) {
        throw new Error("Invalid buffer size");
      }
      const nPoints = Math.floor(buff1.byteLength / sIn);
      if (nPoints != 1 << log2(nPoints)) {
        throw new Error("Invalid number of points");
      }
      let chunkSize = Math.floor(nPoints / tm.concurrency);
      if (chunkSize < MIN_CHUNK_SIZE)
        chunkSize = MIN_CHUNK_SIZE;
      if (chunkSize > MAX_CHUNK_SIZE)
        chunkSize = MAX_CHUNK_SIZE;
      const opPromises = [];
      for (let i4 = 0; i4 < nPoints; i4 += chunkSize) {
        if (logger)
          logger.debug(`${loggerTxt}: fftJoinExt Start: ${i4}/${nPoints}`);
        const n4 = Math.min(nPoints - i4, chunkSize);
        const firstChunk = Fr2.mul(first, Fr2.exp(inc, i4));
        const task = [];
        const b1 = buff1.slice(i4 * sIn, (i4 + n4) * sIn);
        const b22 = buff2.slice(i4 * sIn, (i4 + n4) * sIn);
        task.push({ cmd: "ALLOC", var: 0, len: sMid * n4 });
        task.push({ cmd: "SET", var: 0, buff: b1 });
        task.push({ cmd: "ALLOC", var: 1, len: sMid * n4 });
        task.push({ cmd: "SET", var: 1, buff: b22 });
        task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
        task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
        if (fnIn2Mid) {
          task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: n4 }, { var: 0 }] });
          task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 1 }, { val: n4 }, { var: 1 }] });
        }
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { var: 1 },
          { val: n4 },
          { var: 2 },
          { var: 3 },
          { val: Fr2.s }
        ] });
        if (fnMid2Out) {
          task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: n4 }, { var: 0 }] });
          task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: n4 }, { var: 1 }] });
        }
        task.push({ cmd: "GET", out: 0, var: 0, len: n4 * sOut });
        task.push({ cmd: "GET", out: 1, var: 1, len: n4 * sOut });
        opPromises.push(
          tm.queueAction(task).then((r) => {
            if (logger)
              logger.debug(`${loggerTxt}: fftJoinExt End: ${i4}/${nPoints}`);
            return r;
          })
        );
      }
      const result = await Promise.all(opPromises);
      let fullBuffOut1;
      let fullBuffOut2;
      if (nPoints * sOut > 1 << 28) {
        fullBuffOut1 = new BigBuffer(nPoints * sOut);
        fullBuffOut2 = new BigBuffer(nPoints * sOut);
      } else {
        fullBuffOut1 = new Uint8Array(nPoints * sOut);
        fullBuffOut2 = new Uint8Array(nPoints * sOut);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        fullBuffOut1.set(result[i4][0], p6);
        fullBuffOut2.set(result[i4][1], p6);
        p6 += result[i4][0].byteLength;
      }
      return [fullBuffOut1, fullBuffOut2];
    }
    G7.fft = async function(buff, inType, outType, logger, loggerTxt) {
      return await _fft(buff, false, inType, outType, logger, loggerTxt);
    };
    G7.ifft = async function(buff, inType, outType, logger, loggerTxt) {
      return await _fft(buff, true, inType, outType, logger, loggerTxt);
    };
    G7.lagrangeEvaluations = async function(buff, inType, outType, logger, loggerTxt) {
      inType = inType || "affine";
      outType = outType || "affine";
      let sIn;
      if (groupName == "G1") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
        } else {
          sIn = G7.F.n8 * 3;
        }
      } else if (groupName == "G2") {
        if (inType == "affine") {
          sIn = G7.F.n8 * 2;
        } else {
          sIn = G7.F.n8 * 3;
        }
      } else if (groupName == "Fr") {
        sIn = Fr2.n8;
      } else {
        throw new Error("Invalid group");
      }
      const nPoints = buff.byteLength / sIn;
      const bits2 = log2(nPoints);
      if (2 ** bits2 * sIn != buff.byteLength) {
        if (logger)
          logger.error("lagrangeEvaluations iinvalid input size");
        throw new Error("lagrangeEvaluations invalid Input size");
      }
      if (bits2 <= Fr2.s) {
        return await G7.ifft(buff, inType, outType, logger, loggerTxt);
      }
      if (bits2 > Fr2.s + 1) {
        if (logger)
          logger.error("lagrangeEvaluations input too big");
        throw new Error("lagrangeEvaluations input too big");
      }
      let t0 = buff.slice(0, buff.byteLength / 2);
      let t1 = buff.slice(buff.byteLength / 2, buff.byteLength);
      const shiftToSmallM = Fr2.exp(Fr2.shift, nPoints / 2);
      const sConst = Fr2.inv(Fr2.sub(Fr2.one, shiftToSmallM));
      [t0, t1] = await _fftJoinExt(t0, t1, "prepareLagrangeEvaluation", sConst, Fr2.shiftInv, inType, "jacobian", logger, loggerTxt + " prep");
      const promises = [];
      promises.push(_fft(t0, true, "jacobian", outType, logger, loggerTxt + " t0"));
      promises.push(_fft(t1, true, "jacobian", outType, logger, loggerTxt + " t1"));
      [t0, t1] = await Promise.all(promises);
      let buffOut;
      if (t0.byteLength > 1 << 28) {
        buffOut = new BigBuffer(t0.byteLength * 2);
      } else {
        buffOut = new Uint8Array(t0.byteLength * 2);
      }
      buffOut.set(t0);
      buffOut.set(t1, t0.byteLength);
      return buffOut;
    };
    G7.fftMix = async function fftMix(buff) {
      const sG = G7.F.n8 * 3;
      let fnName, fnFFTJoin;
      if (groupName == "G1") {
        fnName = "g1m_fftMix";
        fnFFTJoin = "g1m_fftJoin";
      } else if (groupName == "G2") {
        fnName = "g2m_fftMix";
        fnFFTJoin = "g2m_fftJoin";
      } else if (groupName == "Fr") {
        fnName = "frm_fftMix";
        fnFFTJoin = "frm_fftJoin";
      } else {
        throw new Error("Invalid group");
      }
      const nPoints = Math.floor(buff.byteLength / sG);
      const power = log2(nPoints);
      let nChunks = 1 << log2(tm.concurrency);
      if (nPoints <= nChunks * 2)
        nChunks = 1;
      const pointsPerChunk = nPoints / nChunks;
      const powerChunk = log2(pointsPerChunk);
      const opPromises = [];
      for (let i4 = 0; i4 < nChunks; i4++) {
        const task = [];
        const b7 = buff.slice(i4 * pointsPerChunk * sG, (i4 + 1) * pointsPerChunk * sG);
        task.push({ cmd: "ALLOCSET", var: 0, buff: b7 });
        for (let j5 = 1; j5 <= powerChunk; j5++) {
          task.push({ cmd: "CALL", fnName, params: [
            { var: 0 },
            { val: pointsPerChunk },
            { val: j5 }
          ] });
        }
        task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
        opPromises.push(
          tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      const chunks = [];
      for (let i4 = 0; i4 < result.length; i4++)
        chunks[i4] = result[i4][0];
      for (let i4 = powerChunk + 1; i4 <= power; i4++) {
        const nGroups = 1 << power - i4;
        const nChunksPerGroup = nChunks / nGroups;
        const opPromises2 = [];
        for (let j5 = 0; j5 < nGroups; j5++) {
          for (let k5 = 0; k5 < nChunksPerGroup / 2; k5++) {
            const first = Fr2.exp(Fr2.w[i4], k5 * pointsPerChunk);
            const inc = Fr2.w[i4];
            const o1 = j5 * nChunksPerGroup + k5;
            const o22 = j5 * nChunksPerGroup + k5 + nChunksPerGroup / 2;
            const task = [];
            task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
            task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o22] });
            task.push({ cmd: "ALLOCSET", var: 2, buff: first });
            task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
            task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
              { var: 0 },
              { var: 1 },
              { val: pointsPerChunk },
              { var: 2 },
              { var: 3 }
            ] });
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
            opPromises2.push(tm.queueAction(task));
          }
        }
        const res = await Promise.all(opPromises2);
        for (let j5 = 0; j5 < nGroups; j5++) {
          for (let k5 = 0; k5 < nChunksPerGroup / 2; k5++) {
            const o1 = j5 * nChunksPerGroup + k5;
            const o22 = j5 * nChunksPerGroup + k5 + nChunksPerGroup / 2;
            const resChunk = res.shift();
            chunks[o1] = resChunk[0];
            chunks[o22] = resChunk[1];
          }
        }
      }
      let fullBuffOut;
      if (buff instanceof BigBuffer) {
        fullBuffOut = new BigBuffer(nPoints * sG);
      } else {
        fullBuffOut = new Uint8Array(nPoints * sG);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < nChunks; i4++) {
        fullBuffOut.set(chunks[i4], p6);
        p6 += chunks[i4].byteLength;
      }
      return fullBuffOut;
    };
    G7.fftJoin = async function fftJoin(buff1, buff2, first, inc) {
      const sG = G7.F.n8 * 3;
      let fnName;
      if (groupName == "G1") {
        fnName = "g1m_fftJoin";
      } else if (groupName == "G2") {
        fnName = "g2m_fftJoin";
      } else if (groupName == "Fr") {
        fnName = "frm_fftJoin";
      } else {
        throw new Error("Invalid group");
      }
      if (buff1.byteLength != buff2.byteLength) {
        throw new Error("Invalid buffer size");
      }
      const nPoints = Math.floor(buff1.byteLength / sG);
      if (nPoints != 1 << log2(nPoints)) {
        throw new Error("Invalid number of points");
      }
      let nChunks = 1 << log2(tm.concurrency);
      if (nPoints <= nChunks * 2)
        nChunks = 1;
      const pointsPerChunk = nPoints / nChunks;
      const opPromises = [];
      for (let i4 = 0; i4 < nChunks; i4++) {
        const task = [];
        const firstChunk = Fr2.mul(first, Fr2.exp(inc, i4 * pointsPerChunk));
        const b1 = buff1.slice(i4 * pointsPerChunk * sG, (i4 + 1) * pointsPerChunk * sG);
        const b22 = buff2.slice(i4 * pointsPerChunk * sG, (i4 + 1) * pointsPerChunk * sG);
        task.push({ cmd: "ALLOCSET", var: 0, buff: b1 });
        task.push({ cmd: "ALLOCSET", var: 1, buff: b22 });
        task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
        task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { var: 1 },
          { val: pointsPerChunk },
          { var: 2 },
          { var: 3 }
        ] });
        task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
        task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
        opPromises.push(
          tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      let fullBuffOut1;
      let fullBuffOut2;
      if (buff1 instanceof BigBuffer) {
        fullBuffOut1 = new BigBuffer(nPoints * sG);
        fullBuffOut2 = new BigBuffer(nPoints * sG);
      } else {
        fullBuffOut1 = new Uint8Array(nPoints * sG);
        fullBuffOut2 = new Uint8Array(nPoints * sG);
      }
      let p6 = 0;
      for (let i4 = 0; i4 < result.length; i4++) {
        fullBuffOut1.set(result[i4][0], p6);
        fullBuffOut2.set(result[i4][1], p6);
        p6 += result[i4][0].byteLength;
      }
      return [fullBuffOut1, fullBuffOut2];
    };
    G7.fftFinal = async function fftFinal(buff, factor) {
      const sG = G7.F.n8 * 3;
      const sGout = G7.F.n8 * 2;
      let fnName, fnToAffine;
      if (groupName == "G1") {
        fnName = "g1m_fftFinal";
        fnToAffine = "g1m_batchToAffine";
      } else if (groupName == "G2") {
        fnName = "g2m_fftFinal";
        fnToAffine = "g2m_batchToAffine";
      } else {
        throw new Error("Invalid group");
      }
      const nPoints = Math.floor(buff.byteLength / sG);
      if (nPoints != 1 << log2(nPoints)) {
        throw new Error("Invalid number of points");
      }
      const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
      const opPromises = [];
      for (let i4 = 0; i4 < tm.concurrency; i4++) {
        let n4;
        if (i4 < tm.concurrency - 1) {
          n4 = pointsPerChunk;
        } else {
          n4 = nPoints - i4 * pointsPerChunk;
        }
        if (n4 == 0)
          continue;
        const task = [];
        const b7 = buff.slice(i4 * pointsPerChunk * sG, (i4 * pointsPerChunk + n4) * sG);
        task.push({ cmd: "ALLOCSET", var: 0, buff: b7 });
        task.push({ cmd: "ALLOCSET", var: 1, buff: factor });
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: n4 },
          { var: 1 }
        ] });
        task.push({ cmd: "CALL", fnName: fnToAffine, params: [
          { var: 0 },
          { val: n4 },
          { var: 0 }
        ] });
        task.push({ cmd: "GET", out: 0, var: 0, len: n4 * sGout });
        opPromises.push(
          tm.queueAction(task)
        );
      }
      const result = await Promise.all(opPromises);
      let fullBuffOut;
      if (buff instanceof BigBuffer) {
        fullBuffOut = new BigBuffer(nPoints * sGout);
      } else {
        fullBuffOut = new Uint8Array(nPoints * sGout);
      }
      let p6 = 0;
      for (let i4 = result.length - 1; i4 >= 0; i4--) {
        fullBuffOut.set(result[i4][0], p6);
        p6 += result[i4][0].byteLength;
      }
      return fullBuffOut;
    };
  }
  async function buildEngine(params) {
    const tm = await buildThreadManager(params.wasm, params.singleThread);
    const curve2 = {};
    curve2.q = e6(params.wasm.q.toString());
    curve2.r = e6(params.wasm.r.toString());
    curve2.name = params.name;
    curve2.tm = tm;
    curve2.prePSize = params.wasm.prePSize;
    curve2.preQSize = params.wasm.preQSize;
    curve2.Fr = new WasmField1(tm, "frm", params.n8r, params.r);
    curve2.F1 = new WasmField1(tm, "f1m", params.n8q, params.q);
    curve2.F2 = new WasmField2(tm, "f2m", curve2.F1);
    curve2.G1 = new WasmCurve(tm, "g1m", curve2.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);
    curve2.G2 = new WasmCurve(tm, "g2m", curve2.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);
    curve2.F6 = new WasmField3(tm, "f6m", curve2.F2);
    curve2.F12 = new WasmField2(tm, "ftm", curve2.F6);
    curve2.Gt = curve2.F12;
    buildBatchApplyKey(curve2, "G1");
    buildBatchApplyKey(curve2, "G2");
    buildBatchApplyKey(curve2, "Fr");
    buildMultiexp2(curve2, "G1");
    buildMultiexp2(curve2, "G2");
    buildFFT2(curve2, "G1");
    buildFFT2(curve2, "G2");
    buildFFT2(curve2, "Fr");
    buildPairing(curve2);
    curve2.array2buffer = function(arr, sG) {
      const buff = new Uint8Array(sG * arr.length);
      for (let i4 = 0; i4 < arr.length; i4++) {
        buff.set(arr[i4], i4 * sG);
      }
      return buff;
    };
    curve2.buffer2array = function(buff, sG) {
      const n4 = buff.byteLength / sG;
      const arr = new Array(n4);
      for (let i4 = 0; i4 < n4; i4++) {
        arr[i4] = buff.slice(i4 * sG, i4 * sG + sG);
      }
      return arr;
    };
    return curve2;
  }
  function toNumber(n4) {
    return BigInt(n4);
  }
  function isNegative(n4) {
    return n4 < 0n;
  }
  function isZero(n4) {
    return n4 === 0n;
  }
  function bitLength(n4) {
    if (isNegative(n4)) {
      return n4.toString(2).length - 1;
    } else {
      return n4.toString(2).length;
    }
  }
  function u32(n4) {
    const b7 = [];
    const v6 = toNumber(n4);
    b7.push(Number(v6 & 0xFFn));
    b7.push(Number(v6 >> 8n & 0xFFn));
    b7.push(Number(v6 >> 16n & 0xFFn));
    b7.push(Number(v6 >> 24n & 0xFFn));
    return b7;
  }
  function toUTF8Array(str) {
    var utf82 = [];
    for (var i4 = 0; i4 < str.length; i4++) {
      var charcode = str.charCodeAt(i4);
      if (charcode < 128)
        utf82.push(charcode);
      else if (charcode < 2048) {
        utf82.push(
          192 | charcode >> 6,
          128 | charcode & 63
        );
      } else if (charcode < 55296 || charcode >= 57344) {
        utf82.push(
          224 | charcode >> 12,
          128 | charcode >> 6 & 63,
          128 | charcode & 63
        );
      } else {
        i4++;
        charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i4) & 1023);
        utf82.push(
          240 | charcode >> 18,
          128 | charcode >> 12 & 63,
          128 | charcode >> 6 & 63,
          128 | charcode & 63
        );
      }
    }
    return utf82;
  }
  function string(str) {
    const bytes2 = toUTF8Array(str);
    return [...varuint32(bytes2.length), ...bytes2];
  }
  function varuint(n4) {
    const code2 = [];
    let v6 = toNumber(n4);
    if (isNegative(v6))
      throw new Error("Number cannot be negative");
    while (!isZero(v6)) {
      code2.push(Number(v6 & 0x7Fn));
      v6 = v6 >> 7n;
    }
    if (code2.length == 0)
      code2.push(0);
    for (let i4 = 0; i4 < code2.length - 1; i4++) {
      code2[i4] = code2[i4] | 128;
    }
    return code2;
  }
  function varint(_n2) {
    let n4, sign;
    const bits2 = bitLength(_n2);
    if (_n2 < 0) {
      sign = true;
      n4 = (1n << BigInt(bits2)) + _n2;
    } else {
      sign = false;
      n4 = toNumber(_n2);
    }
    const paddingBits = 7 - bits2 % 7;
    const padding2 = (1n << BigInt(paddingBits)) - 1n << BigInt(bits2);
    const paddingMask = (1 << 7 - paddingBits) - 1 | 128;
    const code2 = varuint(n4 + padding2);
    if (!sign) {
      code2[code2.length - 1] = code2[code2.length - 1] & paddingMask;
    }
    return code2;
  }
  function varint32(n4) {
    let v6 = toNumber(n4);
    if (v6 > 0xFFFFFFFFn)
      throw new Error("Number too big");
    if (v6 > 0x7FFFFFFFn)
      v6 = v6 - 0x100000000n;
    if (v6 < -2147483648n)
      throw new Error("Number too small");
    return varint(v6);
  }
  function varint64(n4) {
    let v6 = toNumber(n4);
    if (v6 > 0xFFFFFFFFFFFFFFFFn)
      throw new Error("Number too big");
    if (v6 > 0x7FFFFFFFFFFFFFFFn)
      v6 = v6 - 0x10000000000000000n;
    if (v6 < -9223372036854775808n)
      throw new Error("Number too small");
    return varint(v6);
  }
  function varuint32(n4) {
    let v6 = toNumber(n4);
    if (v6 > 0xFFFFFFFFn)
      throw new Error("Number too big");
    return varuint(v6);
  }
  function toHexString(byteArray) {
    return Array.from(byteArray, function(byte) {
      return ("0" + (byte & 255).toString(16)).slice(-2);
    }).join("");
  }
  var CodeBuilder = class {
    constructor(func) {
      this.func = func;
      this.functionName = func.functionName;
      this.module = func.module;
    }
    setLocal(localName, valCode) {
      const idx = this.func.localIdxByName[localName];
      if (idx === void 0)
        throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
      return [...valCode, 33, ...varuint32(idx)];
    }
    teeLocal(localName, valCode) {
      const idx = this.func.localIdxByName[localName];
      if (idx === void 0)
        throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
      return [...valCode, 34, ...varuint32(idx)];
    }
    getLocal(localName) {
      const idx = this.func.localIdxByName[localName];
      if (idx === void 0)
        throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
      return [32, ...varuint32(idx)];
    }
    i64_load8_s(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 0 : _align;
      return [...idxCode, 48, align, ...varuint32(offset)];
    }
    i64_load8_u(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 0 : _align;
      return [...idxCode, 49, align, ...varuint32(offset)];
    }
    i64_load16_s(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 1 : _align;
      return [...idxCode, 50, align, ...varuint32(offset)];
    }
    i64_load16_u(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 1 : _align;
      return [...idxCode, 51, align, ...varuint32(offset)];
    }
    i64_load32_s(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 2 : _align;
      return [...idxCode, 52, align, ...varuint32(offset)];
    }
    i64_load32_u(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 2 : _align;
      return [...idxCode, 53, align, ...varuint32(offset)];
    }
    i64_load(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 3 : _align;
      return [...idxCode, 41, align, ...varuint32(offset)];
    }
    i64_store(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 3;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 3;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 55, align, ...varuint32(offset)];
    }
    i64_store32(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 2;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 2;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 62, align, ...varuint32(offset)];
    }
    i64_store16(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 1;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 1;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 61, align, ...varuint32(offset)];
    }
    i64_store8(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 0;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 0;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 60, align, ...varuint32(offset)];
    }
    i32_load8_s(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 0 : _align;
      return [...idxCode, 44, align, ...varuint32(offset)];
    }
    i32_load8_u(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 0 : _align;
      return [...idxCode, 45, align, ...varuint32(offset)];
    }
    i32_load16_s(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 1 : _align;
      return [...idxCode, 46, align, ...varuint32(offset)];
    }
    i32_load16_u(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 1 : _align;
      return [...idxCode, 47, align, ...varuint32(offset)];
    }
    i32_load(idxCode, _offset, _align) {
      const offset = _offset || 0;
      const align = _align === void 0 ? 2 : _align;
      return [...idxCode, 40, align, ...varuint32(offset)];
    }
    i32_store(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 2;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 2;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 54, align, ...varuint32(offset)];
    }
    i32_store16(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 1;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 1;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 59, align, ...varuint32(offset)];
    }
    i32_store8(idxCode, _offset, _align, _codeVal) {
      let offset, align, codeVal;
      if (Array.isArray(_offset)) {
        offset = 0;
        align = 0;
        codeVal = _offset;
      } else if (Array.isArray(_align)) {
        offset = _offset;
        align = 0;
        codeVal = _align;
      } else if (Array.isArray(_codeVal)) {
        offset = _offset;
        align = _align;
        codeVal = _codeVal;
      }
      return [...idxCode, ...codeVal, 58, align, ...varuint32(offset)];
    }
    call(fnName, ...args) {
      const idx = this.module.functionIdxByName[fnName];
      if (idx === void 0)
        throw new Error(`Function not defined: Function: ${fnName}`);
      return [...[].concat(...args), 16, ...varuint32(idx)];
    }
    call_indirect(fnIdx, ...args) {
      return [...[].concat(...args), ...fnIdx, 17, 0, 0];
    }
    if(condCode, thenCode, elseCode) {
      if (elseCode) {
        return [...condCode, 4, 64, ...thenCode, 5, ...elseCode, 11];
      } else {
        return [...condCode, 4, 64, ...thenCode, 11];
      }
    }
    block(bCode) {
      return [2, 64, ...bCode, 11];
    }
    loop(...args) {
      return [3, 64, ...[].concat(...[...args]), 11];
    }
    br_if(relPath, condCode) {
      return [...condCode, 13, ...varuint32(relPath)];
    }
    br(relPath) {
      return [12, ...varuint32(relPath)];
    }
    ret(rCode) {
      return [...rCode, 15];
    }
    drop(dCode) {
      return [...dCode, 26];
    }
    i64_const(num) {
      return [66, ...varint64(num)];
    }
    i32_const(num) {
      return [65, ...varint32(num)];
    }
    i64_eqz(opcode) {
      return [...opcode, 80];
    }
    i64_eq(op1code, op2code) {
      return [...op1code, ...op2code, 81];
    }
    i64_ne(op1code, op2code) {
      return [...op1code, ...op2code, 82];
    }
    i64_lt_s(op1code, op2code) {
      return [...op1code, ...op2code, 83];
    }
    i64_lt_u(op1code, op2code) {
      return [...op1code, ...op2code, 84];
    }
    i64_gt_s(op1code, op2code) {
      return [...op1code, ...op2code, 85];
    }
    i64_gt_u(op1code, op2code) {
      return [...op1code, ...op2code, 86];
    }
    i64_le_s(op1code, op2code) {
      return [...op1code, ...op2code, 87];
    }
    i64_le_u(op1code, op2code) {
      return [...op1code, ...op2code, 88];
    }
    i64_ge_s(op1code, op2code) {
      return [...op1code, ...op2code, 89];
    }
    i64_ge_u(op1code, op2code) {
      return [...op1code, ...op2code, 90];
    }
    i64_add(op1code, op2code) {
      return [...op1code, ...op2code, 124];
    }
    i64_sub(op1code, op2code) {
      return [...op1code, ...op2code, 125];
    }
    i64_mul(op1code, op2code) {
      return [...op1code, ...op2code, 126];
    }
    i64_div_s(op1code, op2code) {
      return [...op1code, ...op2code, 127];
    }
    i64_div_u(op1code, op2code) {
      return [...op1code, ...op2code, 128];
    }
    i64_rem_s(op1code, op2code) {
      return [...op1code, ...op2code, 129];
    }
    i64_rem_u(op1code, op2code) {
      return [...op1code, ...op2code, 130];
    }
    i64_and(op1code, op2code) {
      return [...op1code, ...op2code, 131];
    }
    i64_or(op1code, op2code) {
      return [...op1code, ...op2code, 132];
    }
    i64_xor(op1code, op2code) {
      return [...op1code, ...op2code, 133];
    }
    i64_shl(op1code, op2code) {
      return [...op1code, ...op2code, 134];
    }
    i64_shr_s(op1code, op2code) {
      return [...op1code, ...op2code, 135];
    }
    i64_shr_u(op1code, op2code) {
      return [...op1code, ...op2code, 136];
    }
    i64_extend_i32_s(op1code) {
      return [...op1code, 172];
    }
    i64_extend_i32_u(op1code) {
      return [...op1code, 173];
    }
    i64_clz(op1code) {
      return [...op1code, 121];
    }
    i64_ctz(op1code) {
      return [...op1code, 122];
    }
    i32_eqz(op1code) {
      return [...op1code, 69];
    }
    i32_eq(op1code, op2code) {
      return [...op1code, ...op2code, 70];
    }
    i32_ne(op1code, op2code) {
      return [...op1code, ...op2code, 71];
    }
    i32_lt_s(op1code, op2code) {
      return [...op1code, ...op2code, 72];
    }
    i32_lt_u(op1code, op2code) {
      return [...op1code, ...op2code, 73];
    }
    i32_gt_s(op1code, op2code) {
      return [...op1code, ...op2code, 74];
    }
    i32_gt_u(op1code, op2code) {
      return [...op1code, ...op2code, 75];
    }
    i32_le_s(op1code, op2code) {
      return [...op1code, ...op2code, 76];
    }
    i32_le_u(op1code, op2code) {
      return [...op1code, ...op2code, 77];
    }
    i32_ge_s(op1code, op2code) {
      return [...op1code, ...op2code, 78];
    }
    i32_ge_u(op1code, op2code) {
      return [...op1code, ...op2code, 79];
    }
    i32_add(op1code, op2code) {
      return [...op1code, ...op2code, 106];
    }
    i32_sub(op1code, op2code) {
      return [...op1code, ...op2code, 107];
    }
    i32_mul(op1code, op2code) {
      return [...op1code, ...op2code, 108];
    }
    i32_div_s(op1code, op2code) {
      return [...op1code, ...op2code, 109];
    }
    i32_div_u(op1code, op2code) {
      return [...op1code, ...op2code, 110];
    }
    i32_rem_s(op1code, op2code) {
      return [...op1code, ...op2code, 111];
    }
    i32_rem_u(op1code, op2code) {
      return [...op1code, ...op2code, 112];
    }
    i32_and(op1code, op2code) {
      return [...op1code, ...op2code, 113];
    }
    i32_or(op1code, op2code) {
      return [...op1code, ...op2code, 114];
    }
    i32_xor(op1code, op2code) {
      return [...op1code, ...op2code, 115];
    }
    i32_shl(op1code, op2code) {
      return [...op1code, ...op2code, 116];
    }
    i32_shr_s(op1code, op2code) {
      return [...op1code, ...op2code, 117];
    }
    i32_shr_u(op1code, op2code) {
      return [...op1code, ...op2code, 118];
    }
    i32_rotl(op1code, op2code) {
      return [...op1code, ...op2code, 119];
    }
    i32_rotr(op1code, op2code) {
      return [...op1code, ...op2code, 120];
    }
    i32_wrap_i64(op1code) {
      return [...op1code, 167];
    }
    i32_clz(op1code) {
      return [...op1code, 103];
    }
    i32_ctz(op1code) {
      return [...op1code, 104];
    }
    unreachable() {
      return [0];
    }
    current_memory() {
      return [63, 0];
    }
    comment() {
      return [];
    }
  };
  var typeCodes = {
    "i32": 127,
    "i64": 126,
    "f32": 125,
    "f64": 124,
    "anyfunc": 112,
    "func": 96,
    "emptyblock": 64
  };
  var FunctionBuilder = class {
    constructor(module, fnName, fnType, moduleName, fieldName) {
      if (fnType == "import") {
        this.fnType = "import";
        this.moduleName = moduleName;
        this.fieldName = fieldName;
      } else if (fnType == "internal") {
        this.fnType = "internal";
      } else {
        throw new Error("Invalid function fnType: " + fnType);
      }
      this.module = module;
      this.fnName = fnName;
      this.params = [];
      this.locals = [];
      this.localIdxByName = {};
      this.code = [];
      this.returnType = null;
      this.nextLocal = 0;
    }
    addParam(paramName, paramType) {
      if (this.localIdxByName[paramName])
        throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);
      const idx = this.nextLocal++;
      this.localIdxByName[paramName] = idx;
      this.params.push({
        type: paramType
      });
    }
    addLocal(localName, localType, _length) {
      const length2 = _length || 1;
      if (this.localIdxByName[localName])
        throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);
      const idx = this.nextLocal++;
      this.localIdxByName[localName] = idx;
      this.locals.push({
        type: localType,
        length: length2
      });
    }
    setReturnType(returnType) {
      if (this.returnType)
        throw new Error(`returnType already defined. Function: ${this.fnName}`);
      this.returnType = returnType;
    }
    getSignature() {
      const params = [...varuint32(this.params.length), ...this.params.map((p6) => typeCodes[p6.type])];
      const returns = this.returnType ? [1, typeCodes[this.returnType]] : [0];
      return [96, ...params, ...returns];
    }
    getBody() {
      const locals = this.locals.map((l6) => [
        ...varuint32(l6.length),
        typeCodes[l6.type]
      ]);
      const body = [
        ...varuint32(this.locals.length),
        ...[].concat(...locals),
        ...this.code,
        11
      ];
      return [
        ...varuint32(body.length),
        ...body
      ];
    }
    addCode(...code2) {
      this.code.push(...[].concat(...[...code2]));
    }
    getCodeBuilder() {
      return new CodeBuilder(this);
    }
  };
  var ModuleBuilder = class {
    constructor() {
      this.functions = [];
      this.functionIdxByName = {};
      this.nImportFunctions = 0;
      this.nInternalFunctions = 0;
      this.memory = {
        pagesSize: 1,
        moduleName: "env",
        fieldName: "memory"
      };
      this.free = 8;
      this.datas = [];
      this.modules = {};
      this.exports = [];
      this.functionsTable = [];
    }
    build() {
      this._setSignatures();
      return new Uint8Array([
        ...u32(1836278016),
        ...u32(1),
        ...this._buildType(),
        ...this._buildImport(),
        ...this._buildFunctionDeclarations(),
        ...this._buildFunctionsTable(),
        ...this._buildExports(),
        ...this._buildElements(),
        ...this._buildCode(),
        ...this._buildData()
      ]);
    }
    addFunction(fnName) {
      if (typeof this.functionIdxByName[fnName] !== "undefined")
        throw new Error(`Function already defined: ${fnName}`);
      const idx = this.functions.length;
      this.functionIdxByName[fnName] = idx;
      this.functions.push(new FunctionBuilder(this, fnName, "internal"));
      this.nInternalFunctions++;
      return this.functions[idx];
    }
    addIimportFunction(fnName, moduleName, _fieldName) {
      if (typeof this.functionIdxByName[fnName] !== "undefined")
        throw new Error(`Function already defined: ${fnName}`);
      if (this.functions.length > 0 && this.functions[this.functions.length - 1].type == "internal")
        throw new Error(`Import functions must be declared before internal: ${fnName}`);
      let fieldName = _fieldName || fnName;
      const idx = this.functions.length;
      this.functionIdxByName[fnName] = idx;
      this.functions.push(new FunctionBuilder(this, fnName, "import", moduleName, fieldName));
      this.nImportFunctions++;
      return this.functions[idx];
    }
    setMemory(pagesSize, moduleName, fieldName) {
      this.memory = {
        pagesSize,
        moduleName: moduleName || "env",
        fieldName: fieldName || "memory"
      };
    }
    exportFunction(fnName, _exportName) {
      const exportName = _exportName || fnName;
      if (typeof this.functionIdxByName[fnName] === "undefined")
        throw new Error(`Function not defined: ${fnName}`);
      const idx = this.functionIdxByName[fnName];
      if (exportName != fnName) {
        this.functionIdxByName[exportName] = idx;
      }
      this.exports.push({
        exportName,
        idx
      });
    }
    addFunctionToTable(fnName) {
      const idx = this.functionIdxByName[fnName];
      this.functionsTable.push(idx);
    }
    addData(offset, bytes2) {
      this.datas.push({
        offset,
        bytes: bytes2
      });
    }
    alloc(a4, b7) {
      let size;
      let bytes2;
      if ((Array.isArray(a4) || ArrayBuffer.isView(a4)) && typeof b7 === "undefined") {
        size = a4.length;
        bytes2 = a4;
      } else {
        size = a4;
        bytes2 = b7;
      }
      size = (size - 1 >> 3) + 1 << 3;
      const p6 = this.free;
      this.free += size;
      if (bytes2) {
        this.addData(p6, bytes2);
      }
      return p6;
    }
    allocString(s3) {
      const encoder = new globalThis.TextEncoder();
      const uint8array = encoder.encode(s3);
      return this.alloc([...uint8array, 0]);
    }
    _setSignatures() {
      this.signatures = [];
      const signatureIdxByName = {};
      if (this.functionsTable.length > 0) {
        const signature = this.functions[this.functionsTable[0]].getSignature();
        const signatureName = "s_" + toHexString(signature);
        signatureIdxByName[signatureName] = 0;
        this.signatures.push(signature);
      }
      for (let i4 = 0; i4 < this.functions.length; i4++) {
        const signature = this.functions[i4].getSignature();
        const signatureName = "s_" + toHexString(signature);
        if (typeof signatureIdxByName[signatureName] === "undefined") {
          signatureIdxByName[signatureName] = this.signatures.length;
          this.signatures.push(signature);
        }
        this.functions[i4].signatureIdx = signatureIdxByName[signatureName];
      }
    }
    _buildSection(sectionType, section) {
      return [sectionType, ...varuint32(section.length), ...section];
    }
    _buildType() {
      return this._buildSection(
        1,
        [
          ...varuint32(this.signatures.length),
          ...[].concat(...this.signatures)
        ]
      );
    }
    _buildImport() {
      const entries2 = [];
      entries2.push([
        ...string(this.memory.moduleName),
        ...string(this.memory.fieldName),
        2,
        0,
        ...varuint32(this.memory.pagesSize)
      ]);
      for (let i4 = 0; i4 < this.nImportFunctions; i4++) {
        entries2.push([
          ...string(this.functions[i4].moduleName),
          ...string(this.functions[i4].fieldName),
          0,
          ...varuint32(this.functions[i4].signatureIdx)
        ]);
      }
      return this._buildSection(
        2,
        varuint32(entries2.length).concat(...entries2)
      );
    }
    _buildFunctionDeclarations() {
      const entries2 = [];
      for (let i4 = this.nImportFunctions; i4 < this.nImportFunctions + this.nInternalFunctions; i4++) {
        entries2.push(...varuint32(this.functions[i4].signatureIdx));
      }
      return this._buildSection(
        3,
        [
          ...varuint32(entries2.length),
          ...[...entries2]
        ]
      );
    }
    _buildFunctionsTable() {
      if (this.functionsTable.length == 0)
        return [];
      return this._buildSection(
        4,
        [
          ...varuint32(1),
          112,
          0,
          ...varuint32(this.functionsTable.length)
        ]
      );
    }
    _buildElements() {
      if (this.functionsTable.length == 0)
        return [];
      const entries2 = [];
      for (let i4 = 0; i4 < this.functionsTable.length; i4++) {
        entries2.push(...varuint32(this.functionsTable[i4]));
      }
      return this._buildSection(
        9,
        [
          ...varuint32(1),
          ...varuint32(0),
          65,
          ...varint32(0),
          11,
          ...varuint32(this.functionsTable.length),
          ...[...entries2]
        ]
      );
    }
    _buildExports() {
      const entries2 = [];
      for (let i4 = 0; i4 < this.exports.length; i4++) {
        entries2.push([
          ...string(this.exports[i4].exportName),
          0,
          ...varuint32(this.exports[i4].idx)
        ]);
      }
      return this._buildSection(
        7,
        varuint32(entries2.length).concat(...entries2)
      );
    }
    _buildCode() {
      const entries2 = [];
      for (let i4 = this.nImportFunctions; i4 < this.nImportFunctions + this.nInternalFunctions; i4++) {
        entries2.push(this.functions[i4].getBody());
      }
      return this._buildSection(
        10,
        varuint32(entries2.length).concat(...entries2)
      );
    }
    _buildData() {
      const entries2 = [];
      entries2.push([
        0,
        65,
        0,
        11,
        4,
        ...u32(this.free)
      ]);
      for (let i4 = 0; i4 < this.datas.length; i4++) {
        entries2.push([
          0,
          65,
          ...varint32(this.datas[i4].offset),
          11,
          ...varuint32(this.datas[i4].bytes.length),
          ...this.datas[i4].bytes
        ]);
      }
      return this._buildSection(
        11,
        varuint32(entries2.length).concat(...entries2)
      );
    }
  };
  globalThis.curve_bn128 = null;
  async function buildBn128(singleThread, plugins) {
    if (!singleThread && globalThis.curve_bn128)
      return globalThis.curve_bn128;
    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBn128$1(moduleBuilder);
    if (plugins)
      plugins(moduleBuilder);
    const bn128wasm = {};
    bn128wasm.code = moduleBuilder.build();
    bn128wasm.pq = moduleBuilder.modules.f1m.pq;
    bn128wasm.pr = moduleBuilder.modules.frm.pq;
    bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;
    bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;
    bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;
    bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;
    bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;
    bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;
    bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;
    bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;
    bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;
    bn128wasm.n8q = 32;
    bn128wasm.n8r = 32;
    bn128wasm.q = moduleBuilder.modules.bn128.q;
    bn128wasm.r = moduleBuilder.modules.bn128.r;
    const params = {
      name: "bn128",
      wasm: bn128wasm,
      q: e6("21888242871839275222246405745257275088696311157297823662689037894645226208583"),
      r: e6("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
      n8q: 32,
      n8r: 32,
      cofactorG2: e6("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d", 16),
      singleThread: singleThread ? true : false
    };
    const curve2 = await buildEngine(params);
    curve2.terminate = async function() {
      if (!params.singleThread) {
        globalThis.curve_bn128 = null;
        await this.tm.terminate();
      }
    };
    if (!singleThread) {
      globalThis.curve_bn128 = curve2;
    }
    return curve2;
  }
  globalThis.curve_bls12381 = null;
  async function buildBls12381(singleThread, plugins) {
    if (!singleThread && globalThis.curve_bls12381)
      return globalThis.curve_bls12381;
    const moduleBuilder = new ModuleBuilder();
    moduleBuilder.setMemory(25);
    buildBls12381$1(moduleBuilder);
    if (plugins)
      plugins(moduleBuilder);
    const bls12381wasm = {};
    bls12381wasm.code = moduleBuilder.build();
    bls12381wasm.pq = moduleBuilder.modules.f1m.pq;
    bls12381wasm.pr = moduleBuilder.modules.frm.pq;
    bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;
    bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;
    bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;
    bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;
    bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;
    bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;
    bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;
    bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;
    bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;
    bls12381wasm.n8q = 48;
    bls12381wasm.n8r = 32;
    bls12381wasm.q = moduleBuilder.modules.bls12381.q;
    bls12381wasm.r = moduleBuilder.modules.bls12381.r;
    const params = {
      name: "bls12381",
      wasm: bls12381wasm,
      q: e6("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16),
      r: e6("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16),
      n8q: 48,
      n8r: 32,
      cofactorG1: e6("0x396c8c005555e1568c00aaab0000aaab", 16),
      cofactorG2: e6("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5", 16),
      singleThread: singleThread ? true : false
    };
    const curve2 = await buildEngine(params);
    curve2.terminate = async function() {
      if (!params.singleThread) {
        globalThis.curve_bls12381 = null;
        await this.tm.terminate();
      }
    };
    if (!singleThread) {
      globalThis.curve_bls12381 = curve2;
    }
    return curve2;
  }
  var bls12381r = e6("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
  var bn128r = e6("21888242871839275222246405745257275088548364400416034343698204186575808495617");
  var bls12381q = e6("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
  var bn128q = e6("21888242871839275222246405745257275088696311157297823662689037894645226208583");
  async function getCurveFromName(name, singleThread, plugins) {
    let curve2;
    const normName = normalizeName(name);
    if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
      curve2 = await buildBn128(singleThread, plugins);
    } else if (["BLS12381"].indexOf(normName) >= 0) {
      curve2 = await buildBls12381(singleThread, plugins);
    } else {
      throw new Error(`Curve not supported: ${name}`);
    }
    return curve2;
    function normalizeName(n4) {
      return n4.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
    }
  }
  var Scalar = _Scalar;
  var utils = _utils;

  // node_modules/snarkjs/build/browser.esm.js
  var fs2 = {};
  async function open(fileName, openFlags, cacheSize, pageSize) {
    cacheSize = cacheSize || 4096 * 64;
    if (typeof openFlags !== "number" && ["w+", "wx+", "r", "ax+", "a+"].indexOf(openFlags) < 0)
      throw new Error("Invalid open option");
    const fd2 = await fs2.promises.open(fileName, openFlags);
    const stats = await fd2.stat();
    return new FastFile(fd2, stats, cacheSize, pageSize, fileName);
  }
  var FastFile = class {
    constructor(fd2, stats, cacheSize, pageSize, fileName) {
      this.fileName = fileName;
      this.fd = fd2;
      this.pos = 0;
      this.pageSize = pageSize || 1 << 8;
      while (this.pageSize < stats.blksize) {
        this.pageSize *= 2;
      }
      this.totalSize = stats.size;
      this.totalPages = Math.floor((stats.size - 1) / this.pageSize) + 1;
      this.maxPagesLoaded = Math.floor(cacheSize / this.pageSize) + 1;
      this.pages = {};
      this.pendingLoads = [];
      this.writing = false;
      this.reading = false;
      this.avBuffs = [];
      this.history = {};
    }
    _loadPage(p6) {
      const self2 = this;
      const P5 = new Promise((resolve2, reject) => {
        self2.pendingLoads.push({
          page: p6,
          resolve: resolve2,
          reject
        });
      });
      self2.__statusPage("After Load request: ", p6);
      return P5;
    }
    __statusPage(s3, p6) {
      const logEntry = [];
      const self2 = this;
      if (!self2.logHistory)
        return;
      logEntry.push("==" + s3 + " " + p6);
      let S6 = "";
      for (let i4 = 0; i4 < self2.pendingLoads.length; i4++) {
        if (self2.pendingLoads[i4].page == p6)
          S6 = S6 + " " + i4;
      }
      if (S6)
        logEntry.push("Pending loads:" + S6);
      if (typeof self2.pages[p6] != "undefined") {
        const page = self2.pages[p6];
        logEntry.push("Loaded");
        logEntry.push("pendingOps: " + page.pendingOps);
        if (page.loading)
          logEntry.push("loading: " + page.loading);
        if (page.writing)
          logEntry.push("writing");
        if (page.dirty)
          logEntry.push("dirty");
      }
      logEntry.push("==");
      if (!self2.history[p6])
        self2.history[p6] = [];
      self2.history[p6].push(logEntry);
    }
    __printHistory(p6) {
      const self2 = this;
      if (!self2.history[p6])
        console.log("Empty History ", p6);
      console.log("History " + p6);
      for (let i4 = 0; i4 < self2.history[p6].length; i4++) {
        for (let j5 = 0; j5 < self2.history[p6][i4].length; j5++) {
          console.log("-> " + self2.history[p6][i4][j5]);
        }
      }
    }
    _triggerLoad() {
      const self2 = this;
      if (self2.reading)
        return;
      if (self2.pendingLoads.length == 0)
        return;
      const pageIdxs = Object.keys(self2.pages);
      const deletablePages = [];
      for (let i4 = 0; i4 < pageIdxs.length; i4++) {
        const page = self2.pages[parseInt(pageIdxs[i4])];
        if (page.dirty == false && page.pendingOps == 0 && !page.writing && !page.loading)
          deletablePages.push(parseInt(pageIdxs[i4]));
      }
      let freePages = self2.maxPagesLoaded - pageIdxs.length;
      const ops2 = [];
      while (self2.pendingLoads.length > 0 && (typeof self2.pages[self2.pendingLoads[0].page] != "undefined" || (freePages > 0 || deletablePages.length > 0))) {
        const load = self2.pendingLoads.shift();
        if (typeof self2.pages[load.page] != "undefined") {
          self2.pages[load.page].pendingOps++;
          const idx = deletablePages.indexOf(load.page);
          if (idx >= 0)
            deletablePages.splice(idx, 1);
          if (self2.pages[load.page].loading) {
            self2.pages[load.page].loading.push(load);
          } else {
            load.resolve();
          }
          self2.__statusPage("After Load (cached): ", load.page);
        } else {
          if (freePages) {
            freePages--;
          } else {
            const fp = deletablePages.shift();
            self2.__statusPage("Before Unload: ", fp);
            self2.avBuffs.unshift(self2.pages[fp]);
            delete self2.pages[fp];
            self2.__statusPage("After Unload: ", fp);
          }
          if (load.page >= self2.totalPages) {
            self2.pages[load.page] = getNewPage();
            load.resolve();
            self2.__statusPage("After Load (new): ", load.page);
          } else {
            self2.reading = true;
            self2.pages[load.page] = getNewPage();
            self2.pages[load.page].loading = [load];
            ops2.push(self2.fd.read(self2.pages[load.page].buff, 0, self2.pageSize, load.page * self2.pageSize).then((res) => {
              self2.pages[load.page].size = res.bytesRead;
              const loading = self2.pages[load.page].loading;
              delete self2.pages[load.page].loading;
              for (let i4 = 0; i4 < loading.length; i4++) {
                loading[i4].resolve();
              }
              self2.__statusPage("After Load (loaded): ", load.page);
              return res;
            }, (err) => {
              load.reject(err);
            }));
            self2.__statusPage("After Load (loading): ", load.page);
          }
        }
      }
      Promise.all(ops2).then(() => {
        self2.reading = false;
        if (self2.pendingLoads.length > 0)
          setImmediate(self2._triggerLoad.bind(self2));
        self2._tryClose();
      });
      function getNewPage() {
        if (self2.avBuffs.length > 0) {
          const p6 = self2.avBuffs.shift();
          p6.dirty = false;
          p6.pendingOps = 1;
          p6.size = 0;
          return p6;
        } else {
          return {
            dirty: false,
            buff: new Uint8Array(self2.pageSize),
            pendingOps: 1,
            size: 0
          };
        }
      }
    }
    _triggerWrite() {
      const self2 = this;
      if (self2.writing)
        return;
      const pageIdxs = Object.keys(self2.pages);
      const ops2 = [];
      for (let i4 = 0; i4 < pageIdxs.length; i4++) {
        const page = self2.pages[parseInt(pageIdxs[i4])];
        if (page.dirty) {
          page.dirty = false;
          page.writing = true;
          self2.writing = true;
          ops2.push(self2.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i4]) * self2.pageSize).then(() => {
            page.writing = false;
            return;
          }, (err) => {
            console.log("ERROR Writing: " + err);
            self2.error = err;
            self2._tryClose();
          }));
        }
      }
      if (self2.writing) {
        Promise.all(ops2).then(() => {
          self2.writing = false;
          setImmediate(self2._triggerWrite.bind(self2));
          self2._tryClose();
          if (self2.pendingLoads.length > 0)
            setImmediate(self2._triggerLoad.bind(self2));
        });
      }
    }
    _getDirtyPage() {
      for (let p6 in this.pages) {
        if (this.pages[p6].dirty)
          return p6;
      }
      return -1;
    }
    async write(buff, pos) {
      if (buff.byteLength == 0)
        return;
      const self2 = this;
      if (typeof pos == "undefined")
        pos = self2.pos;
      self2.pos = pos + buff.byteLength;
      if (self2.totalSize < pos + buff.byteLength)
        self2.totalSize = pos + buff.byteLength;
      if (self2.pendingClose)
        throw new Error("Writing a closing file");
      const firstPage = Math.floor(pos / self2.pageSize);
      const lastPage = Math.floor((pos + buff.byteLength - 1) / self2.pageSize);
      const pagePromises = [];
      for (let i4 = firstPage; i4 <= lastPage; i4++)
        pagePromises.push(self2._loadPage(i4));
      self2._triggerLoad();
      let p6 = firstPage;
      let o4 = pos % self2.pageSize;
      let r = buff.byteLength;
      while (r > 0) {
        await pagePromises[p6 - firstPage];
        const l6 = o4 + r > self2.pageSize ? self2.pageSize - o4 : r;
        const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l6);
        const dstView = new Uint8Array(self2.pages[p6].buff.buffer, o4, l6);
        dstView.set(srcView);
        self2.pages[p6].dirty = true;
        self2.pages[p6].pendingOps--;
        self2.pages[p6].size = Math.max(o4 + l6, self2.pages[p6].size);
        if (p6 >= self2.totalPages) {
          self2.totalPages = p6 + 1;
        }
        r = r - l6;
        p6++;
        o4 = 0;
        if (!self2.writing)
          setImmediate(self2._triggerWrite.bind(self2));
      }
    }
    async read(len, pos) {
      const self2 = this;
      let buff = new Uint8Array(len);
      await self2.readToBuffer(buff, 0, len, pos);
      return buff;
    }
    async readToBuffer(buffDst, offset, len, pos) {
      if (len == 0) {
        return;
      }
      const self2 = this;
      if (len > self2.pageSize * self2.maxPagesLoaded * 0.8) {
        const cacheSize = Math.floor(len * 1.1);
        this.maxPagesLoaded = Math.floor(cacheSize / self2.pageSize) + 1;
      }
      if (typeof pos == "undefined")
        pos = self2.pos;
      self2.pos = pos + len;
      if (self2.pendingClose)
        throw new Error("Reading a closing file");
      const firstPage = Math.floor(pos / self2.pageSize);
      const lastPage = Math.floor((pos + len - 1) / self2.pageSize);
      const pagePromises = [];
      for (let i4 = firstPage; i4 <= lastPage; i4++)
        pagePromises.push(self2._loadPage(i4));
      self2._triggerLoad();
      let p6 = firstPage;
      let o4 = pos % self2.pageSize;
      let r = pos + len > self2.totalSize ? len - (pos + len - self2.totalSize) : len;
      while (r > 0) {
        await pagePromises[p6 - firstPage];
        self2.__statusPage("After Await (read): ", p6);
        const l6 = o4 + r > self2.pageSize ? self2.pageSize - o4 : r;
        const srcView = new Uint8Array(self2.pages[p6].buff.buffer, self2.pages[p6].buff.byteOffset + o4, l6);
        buffDst.set(srcView, offset + len - r);
        self2.pages[p6].pendingOps--;
        self2.__statusPage("After Op done: ", p6);
        r = r - l6;
        p6++;
        o4 = 0;
        if (self2.pendingLoads.length > 0)
          setImmediate(self2._triggerLoad.bind(self2));
      }
      this.pos = pos + len;
    }
    _tryClose() {
      const self2 = this;
      if (!self2.pendingClose)
        return;
      if (self2.error) {
        self2.pendingCloseReject(self2.error);
      }
      const p6 = self2._getDirtyPage();
      if (p6 >= 0 || self2.writing || self2.reading || self2.pendingLoads.length > 0)
        return;
      self2.pendingClose();
    }
    close() {
      const self2 = this;
      if (self2.pendingClose)
        throw new Error("Closing the file twice");
      return new Promise((resolve2, reject) => {
        self2.pendingClose = resolve2;
        self2.pendingCloseReject = reject;
        self2._tryClose();
      }).then(() => {
        self2.fd.close();
      }, (err) => {
        self2.fd.close();
        throw err;
      });
    }
    async discard() {
      const self2 = this;
      await self2.close();
      await fs2.promises.unlink(this.fileName);
    }
    async writeULE32(v6, pos) {
      const self2 = this;
      const tmpBuff322 = new Uint8Array(4);
      const tmpBuff32v2 = new DataView(tmpBuff322.buffer);
      tmpBuff32v2.setUint32(0, v6, true);
      await self2.write(tmpBuff322, pos);
    }
    async writeUBE32(v6, pos) {
      const self2 = this;
      const tmpBuff322 = new Uint8Array(4);
      const tmpBuff32v2 = new DataView(tmpBuff322.buffer);
      tmpBuff32v2.setUint32(0, v6, false);
      await self2.write(tmpBuff322, pos);
    }
    async writeULE64(v6, pos) {
      const self2 = this;
      const tmpBuff642 = new Uint8Array(8);
      const tmpBuff64v2 = new DataView(tmpBuff642.buffer);
      tmpBuff64v2.setUint32(0, v6 & 4294967295, true);
      tmpBuff64v2.setUint32(4, Math.floor(v6 / 4294967296), true);
      await self2.write(tmpBuff642, pos);
    }
    async readULE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new Uint32Array(b7.buffer);
      return view[0];
    }
    async readUBE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new DataView(b7.buffer);
      return view.getUint32(0, false);
    }
    async readULE64(pos) {
      const self2 = this;
      const b7 = await self2.read(8, pos);
      const view = new Uint32Array(b7.buffer);
      return view[1] * 4294967296 + view[0];
    }
    async readString(pos) {
      const self2 = this;
      if (self2.pendingClose) {
        throw new Error("Reading a closing file");
      }
      let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
      let currentPage = Math.floor(currentPosition / self2.pageSize);
      let endOfStringFound = false;
      let str = "";
      while (!endOfStringFound) {
        let pagePromise = self2._loadPage(currentPage);
        self2._triggerLoad();
        await pagePromise;
        self2.__statusPage("After Await (read): ", currentPage);
        let offsetOnPage = currentPosition % self2.pageSize;
        const dataArray = new Uint8Array(
          self2.pages[currentPage].buff.buffer,
          self2.pages[currentPage].buff.byteOffset + offsetOnPage,
          self2.pageSize - offsetOnPage
        );
        let indexEndOfString = dataArray.findIndex((element) => element === 0);
        endOfStringFound = indexEndOfString !== -1;
        if (endOfStringFound) {
          str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
          self2.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;
        } else {
          str += new TextDecoder().decode(dataArray);
          self2.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;
        }
        self2.pages[currentPage].pendingOps--;
        self2.__statusPage("After Op done: ", currentPage);
        currentPosition = self2.pos;
        currentPage++;
        if (self2.pendingLoads.length > 0)
          setImmediate(self2._triggerLoad.bind(self2));
      }
      return str;
    }
  };
  function createNew$1(o4) {
    const initialSize = o4.initialSize || 1 << 20;
    const fd2 = new MemFile();
    fd2.o = o4;
    fd2.o.data = new Uint8Array(initialSize);
    fd2.allocSize = initialSize;
    fd2.totalSize = 0;
    fd2.readOnly = false;
    fd2.pos = 0;
    return fd2;
  }
  function readExisting$2(o4) {
    const fd2 = new MemFile();
    fd2.o = o4;
    fd2.allocSize = o4.data.byteLength;
    fd2.totalSize = o4.data.byteLength;
    fd2.readOnly = true;
    fd2.pos = 0;
    return fd2;
  }
  var tmpBuff32$1 = new Uint8Array(4);
  var tmpBuff32v$1 = new DataView(tmpBuff32$1.buffer);
  var tmpBuff64$1 = new Uint8Array(8);
  var tmpBuff64v$1 = new DataView(tmpBuff64$1.buffer);
  var MemFile = class {
    constructor() {
      this.pageSize = 1 << 14;
    }
    _resizeIfNeeded(newLen) {
      if (newLen > this.allocSize) {
        const newAllocSize = Math.max(
          this.allocSize + (1 << 20),
          Math.floor(this.allocSize * 1.1),
          newLen
        );
        const newData = new Uint8Array(newAllocSize);
        newData.set(this.o.data);
        this.o.data = newData;
        this.allocSize = newAllocSize;
      }
    }
    async write(buff, pos) {
      const self2 = this;
      if (typeof pos == "undefined")
        pos = self2.pos;
      if (this.readOnly)
        throw new Error("Writing a read only file");
      this._resizeIfNeeded(pos + buff.byteLength);
      this.o.data.set(buff.slice(), pos);
      if (pos + buff.byteLength > this.totalSize)
        this.totalSize = pos + buff.byteLength;
      this.pos = pos + buff.byteLength;
    }
    async readToBuffer(buffDest, offset, len, pos) {
      const self2 = this;
      if (typeof pos == "undefined")
        pos = self2.pos;
      if (this.readOnly) {
        if (pos + len > this.totalSize)
          throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos + len);
      const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);
      buffDest.set(buffSrc, offset);
      this.pos = pos + len;
    }
    async read(len, pos) {
      const self2 = this;
      const buff = new Uint8Array(len);
      await self2.readToBuffer(buff, 0, len, pos);
      return buff;
    }
    close() {
      if (this.o.data.byteLength != this.totalSize) {
        this.o.data = this.o.data.slice(0, this.totalSize);
      }
    }
    async discard() {
    }
    async writeULE32(v6, pos) {
      const self2 = this;
      tmpBuff32v$1.setUint32(0, v6, true);
      await self2.write(tmpBuff32$1, pos);
    }
    async writeUBE32(v6, pos) {
      const self2 = this;
      tmpBuff32v$1.setUint32(0, v6, false);
      await self2.write(tmpBuff32$1, pos);
    }
    async writeULE64(v6, pos) {
      const self2 = this;
      tmpBuff64v$1.setUint32(0, v6 & 4294967295, true);
      tmpBuff64v$1.setUint32(4, Math.floor(v6 / 4294967296), true);
      await self2.write(tmpBuff64$1, pos);
    }
    async readULE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new Uint32Array(b7.buffer);
      return view[0];
    }
    async readUBE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new DataView(b7.buffer);
      return view.getUint32(0, false);
    }
    async readULE64(pos) {
      const self2 = this;
      const b7 = await self2.read(8, pos);
      const view = new Uint32Array(b7.buffer);
      return view[1] * 4294967296 + view[0];
    }
    async readString(pos) {
      const self2 = this;
      let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
      if (currentPosition > this.totalSize) {
        if (this.readOnly) {
          throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos);
      }
      const dataArray = new Uint8Array(
        self2.o.data.buffer,
        currentPosition,
        this.totalSize - currentPosition
      );
      let indexEndOfString = dataArray.findIndex((element) => element === 0);
      let endOfStringFound = indexEndOfString !== -1;
      let str = "";
      if (endOfStringFound) {
        str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
        self2.pos = currentPosition + indexEndOfString + 1;
      } else {
        self2.pos = currentPosition;
      }
      return str;
    }
  };
  var PAGE_SIZE2 = 1 << 22;
  function createNew(o4) {
    const initialSize = o4.initialSize || 0;
    const fd2 = new BigMemFile();
    fd2.o = o4;
    const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE2) + 1 : 0;
    fd2.o.data = [];
    for (let i4 = 0; i4 < nPages - 1; i4++) {
      fd2.o.data.push(new Uint8Array(PAGE_SIZE2));
    }
    if (nPages)
      fd2.o.data.push(new Uint8Array(initialSize - PAGE_SIZE2 * (nPages - 1)));
    fd2.totalSize = 0;
    fd2.readOnly = false;
    fd2.pos = 0;
    return fd2;
  }
  function readExisting$1(o4) {
    const fd2 = new BigMemFile();
    fd2.o = o4;
    fd2.totalSize = (o4.data.length - 1) * PAGE_SIZE2 + o4.data[o4.data.length - 1].byteLength;
    fd2.readOnly = true;
    fd2.pos = 0;
    return fd2;
  }
  var tmpBuff32 = new Uint8Array(4);
  var tmpBuff32v = new DataView(tmpBuff32.buffer);
  var tmpBuff64 = new Uint8Array(8);
  var tmpBuff64v = new DataView(tmpBuff64.buffer);
  var BigMemFile = class {
    constructor() {
      this.pageSize = 1 << 14;
    }
    _resizeIfNeeded(newLen) {
      if (newLen <= this.totalSize)
        return;
      if (this.readOnly)
        throw new Error("Reading out of file bounds");
      const nPages = Math.floor((newLen - 1) / PAGE_SIZE2) + 1;
      for (let i4 = Math.max(this.o.data.length - 1, 0); i4 < nPages; i4++) {
        const newSize = i4 < nPages - 1 ? PAGE_SIZE2 : newLen - (nPages - 1) * PAGE_SIZE2;
        const p6 = new Uint8Array(newSize);
        if (i4 == this.o.data.length - 1)
          p6.set(this.o.data[i4]);
        this.o.data[i4] = p6;
      }
      this.totalSize = newLen;
    }
    async write(buff, pos) {
      const self2 = this;
      if (typeof pos == "undefined")
        pos = self2.pos;
      if (this.readOnly)
        throw new Error("Writing a read only file");
      this._resizeIfNeeded(pos + buff.byteLength);
      const firstPage = Math.floor(pos / PAGE_SIZE2);
      let p6 = firstPage;
      let o4 = pos % PAGE_SIZE2;
      let r = buff.byteLength;
      while (r > 0) {
        const l6 = o4 + r > PAGE_SIZE2 ? PAGE_SIZE2 - o4 : r;
        const srcView = buff.slice(buff.byteLength - r, buff.byteLength - r + l6);
        const dstView = new Uint8Array(self2.o.data[p6].buffer, o4, l6);
        dstView.set(srcView);
        r = r - l6;
        p6++;
        o4 = 0;
      }
      this.pos = pos + buff.byteLength;
    }
    async readToBuffer(buffDst, offset, len, pos) {
      const self2 = this;
      if (typeof pos == "undefined")
        pos = self2.pos;
      if (this.readOnly) {
        if (pos + len > this.totalSize)
          throw new Error("Reading out of bounds");
      }
      this._resizeIfNeeded(pos + len);
      const firstPage = Math.floor(pos / PAGE_SIZE2);
      let p6 = firstPage;
      let o4 = pos % PAGE_SIZE2;
      let r = len;
      while (r > 0) {
        const l6 = o4 + r > PAGE_SIZE2 ? PAGE_SIZE2 - o4 : r;
        const srcView = new Uint8Array(self2.o.data[p6].buffer, o4, l6);
        buffDst.set(srcView, offset + len - r);
        r = r - l6;
        p6++;
        o4 = 0;
      }
      this.pos = pos + len;
    }
    async read(len, pos) {
      const self2 = this;
      const buff = new Uint8Array(len);
      await self2.readToBuffer(buff, 0, len, pos);
      return buff;
    }
    close() {
    }
    async discard() {
    }
    async writeULE32(v6, pos) {
      const self2 = this;
      tmpBuff32v.setUint32(0, v6, true);
      await self2.write(tmpBuff32, pos);
    }
    async writeUBE32(v6, pos) {
      const self2 = this;
      tmpBuff32v.setUint32(0, v6, false);
      await self2.write(tmpBuff32, pos);
    }
    async writeULE64(v6, pos) {
      const self2 = this;
      tmpBuff64v.setUint32(0, v6 & 4294967295, true);
      tmpBuff64v.setUint32(4, Math.floor(v6 / 4294967296), true);
      await self2.write(tmpBuff64, pos);
    }
    async readULE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new Uint32Array(b7.buffer);
      return view[0];
    }
    async readUBE32(pos) {
      const self2 = this;
      const b7 = await self2.read(4, pos);
      const view = new DataView(b7.buffer);
      return view.getUint32(0, false);
    }
    async readULE64(pos) {
      const self2 = this;
      const b7 = await self2.read(8, pos);
      const view = new Uint32Array(b7.buffer);
      return view[1] * 4294967296 + view[0];
    }
    async readString(pos) {
      const self2 = this;
      const fixedSize = 2048;
      let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
      if (currentPosition > this.totalSize) {
        if (this.readOnly) {
          throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos);
      }
      let endOfStringFound = false;
      let str = "";
      while (!endOfStringFound) {
        let currentPage = Math.floor(currentPosition / PAGE_SIZE2);
        let offsetOnPage = currentPosition % PAGE_SIZE2;
        if (self2.o.data[currentPage] === void 0) {
          throw new Error("ERROR");
        }
        let readLength = Math.min(fixedSize, self2.o.data[currentPage].length - offsetOnPage);
        const dataArray = new Uint8Array(self2.o.data[currentPage].buffer, offsetOnPage, readLength);
        let indexEndOfString = dataArray.findIndex((element) => element === 0);
        endOfStringFound = indexEndOfString !== -1;
        if (endOfStringFound) {
          str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
          self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + indexEndOfString + 1;
        } else {
          str += new TextDecoder().decode(dataArray);
          self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + dataArray.length;
        }
        currentPosition = self2.pos;
      }
      return str;
    }
  };
  var O_TRUNC = 1024;
  var O_CREAT = 512;
  var O_RDWR = 2;
  var O_RDONLY = 0;
  var DEFAULT_CACHE_SIZE = 1 << 16;
  var DEFAULT_PAGE_SIZE = 1 << 13;
  async function createOverride(o4, b7, c3) {
    if (typeof o4 === "string") {
      o4 = {
        type: "file",
        fileName: o4,
        cacheSize: b7 || DEFAULT_CACHE_SIZE,
        pageSize: c3 || DEFAULT_PAGE_SIZE
      };
    }
    if (o4.type == "file") {
      return await open(o4.fileName, O_TRUNC | O_CREAT | O_RDWR, o4.cacheSize, o4.pageSize);
    } else if (o4.type == "mem") {
      return createNew$1(o4);
    } else if (o4.type == "bigMem") {
      return createNew(o4);
    } else {
      throw new Error("Invalid FastFile type: " + o4.type);
    }
  }
  async function readExisting(o4, b7, c3) {
    if (o4 instanceof Uint8Array) {
      o4 = {
        type: "mem",
        data: o4
      };
    }
    {
      if (typeof o4 === "string") {
        const buff = await fetch(o4).then(function(res) {
          return res.arrayBuffer();
        }).then(function(ab) {
          return new Uint8Array(ab);
        });
        o4 = {
          type: "mem",
          data: buff
        };
      }
    }
    if (o4.type == "file") {
      return await open(o4.fileName, O_RDONLY, o4.cacheSize, o4.pageSize);
    } else if (o4.type == "mem") {
      return await readExisting$2(o4);
    } else if (o4.type == "bigMem") {
      return await readExisting$1(o4);
    } else {
      throw new Error("Invalid FastFile type: " + o4.type);
    }
  }
  async function readBinFile(fileName, type2, maxVersion, cacheSize, pageSize) {
    const fd2 = await readExisting(fileName);
    const b7 = await fd2.read(4);
    let readedType = "";
    for (let i4 = 0; i4 < 4; i4++)
      readedType += String.fromCharCode(b7[i4]);
    if (readedType != type2)
      throw new Error(fileName + ": Invalid File format");
    let v6 = await fd2.readULE32();
    if (v6 > maxVersion)
      throw new Error("Version not supported");
    const nSections = await fd2.readULE32();
    let sections = [];
    for (let i4 = 0; i4 < nSections; i4++) {
      let ht3 = await fd2.readULE32();
      let hl2 = await fd2.readULE64();
      if (typeof sections[ht3] == "undefined")
        sections[ht3] = [];
      sections[ht3].push({
        p: fd2.pos,
        size: hl2
      });
      fd2.pos += hl2;
    }
    return { fd: fd2, sections };
  }
  async function createBinFile(fileName, type2, version2, nSections, cacheSize, pageSize) {
    const fd2 = await createOverride(fileName, cacheSize, pageSize);
    const buff = new Uint8Array(4);
    for (let i4 = 0; i4 < 4; i4++)
      buff[i4] = type2.charCodeAt(i4);
    await fd2.write(buff, 0);
    await fd2.writeULE32(version2);
    await fd2.writeULE32(nSections);
    return fd2;
  }
  async function startWriteSection(fd2, idSection) {
    if (typeof fd2.writingSection !== "undefined")
      throw new Error("Already writing a section");
    await fd2.writeULE32(idSection);
    fd2.writingSection = {
      pSectionSize: fd2.pos
    };
    await fd2.writeULE64(0);
  }
  async function endWriteSection(fd2) {
    if (typeof fd2.writingSection === "undefined")
      throw new Error("Not writing a section");
    const sectionSize = fd2.pos - fd2.writingSection.pSectionSize - 8;
    const oldPos = fd2.pos;
    fd2.pos = fd2.writingSection.pSectionSize;
    await fd2.writeULE64(sectionSize);
    fd2.pos = oldPos;
    delete fd2.writingSection;
  }
  async function startReadUniqueSection(fd2, sections, idSection) {
    if (typeof fd2.readingSection !== "undefined")
      throw new Error("Already reading a section");
    if (!sections[idSection])
      throw new Error(fd2.fileName + ": Missing section " + idSection);
    if (sections[idSection].length > 1)
      throw new Error(fd2.fileName + ": Section Duplicated " + idSection);
    fd2.pos = sections[idSection][0].p;
    fd2.readingSection = sections[idSection][0];
  }
  async function endReadSection(fd2, noCheck) {
    if (typeof fd2.readingSection === "undefined")
      throw new Error("Not reading a section");
    if (!noCheck) {
      if (fd2.pos - fd2.readingSection.p != fd2.readingSection.size)
        throw new Error("Invalid section size reading");
    }
    delete fd2.readingSection;
  }
  async function writeBigInt(fd2, n4, n8, pos) {
    const buff = new Uint8Array(n8);
    Scalar.toRprLE(buff, 0, n4, n8);
    await fd2.write(buff, pos);
  }
  async function readBigInt(fd2, n8, pos) {
    const buff = await fd2.read(n8, pos);
    return Scalar.fromRprLE(buff, 0, n8);
  }
  async function readSection(fd2, sections, idSection, offset, length2) {
    offset = typeof offset === "undefined" ? 0 : offset;
    length2 = typeof length2 === "undefined" ? sections[idSection][0].size - offset : length2;
    if (offset + length2 > sections[idSection][0].size) {
      throw new Error("Reading out of the range of the section");
    }
    let buff;
    if (length2 < 1 << 30) {
      buff = new Uint8Array(length2);
    } else {
      buff = new BigBuffer(length2);
    }
    await fd2.readToBuffer(buff, 0, length2, sections[idSection][0].p + offset);
    return buff;
  }
  var bls12381r$1 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
  var bn128r$1 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
  var bls12381q2 = Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
  var bn128q2 = Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");
  async function getCurveFromQ(q5) {
    let curve2;
    if (Scalar.eq(q5, bn128q2)) {
      curve2 = await buildBn128();
    } else if (Scalar.eq(q5, bls12381q2)) {
      curve2 = await buildBls12381();
    } else {
      throw new Error(`Curve not supported: ${Scalar.toString(q5)}`);
    }
    return curve2;
  }
  async function getCurveFromName2(name) {
    let curve2;
    const normName = normalizeName(name);
    if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
      curve2 = await buildBn128();
    } else if (["BLS12381"].indexOf(normName) >= 0) {
      curve2 = await buildBls12381();
    } else {
      throw new Error(`Curve not supported: ${name}`);
    }
    return curve2;
    function normalizeName(n4) {
      return n4.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
    }
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var blake2bWasm = { exports: {} };
  var nanoassert = assert$1;
  var AssertionError = class extends Error {
  };
  AssertionError.prototype.name = "AssertionError";
  function assert$1(t, m5) {
    if (!t) {
      var err = new AssertionError(m5);
      if (Error.captureStackTrace)
        Error.captureStackTrace(err, assert$1);
      throw err;
    }
  }
  var browser = { exports: {} };
  function byteLength$4(string3) {
    return string3.length;
  }
  function toString$4(buffer) {
    const len = buffer.byteLength;
    let result = "";
    for (let i4 = 0; i4 < len; i4++) {
      result += String.fromCharCode(buffer[i4]);
    }
    return result;
  }
  function write$5(buffer, string3, offset = 0, length2 = byteLength$4(string3)) {
    const len = Math.min(length2, buffer.byteLength - offset);
    for (let i4 = 0; i4 < len; i4++) {
      buffer[offset + i4] = string3.charCodeAt(i4);
    }
    return len;
  }
  var ascii = {
    byteLength: byteLength$4,
    toString: toString$4,
    write: write$5
  };
  var alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var codes = new Uint8Array(256);
  for (let i4 = 0; i4 < alphabet.length; i4++) {
    codes[alphabet.charCodeAt(i4)] = i4;
  }
  codes[45] = 62;
  codes[95] = 63;
  function byteLength$3(string3) {
    let len = string3.length;
    if (string3.charCodeAt(len - 1) === 61)
      len--;
    if (len > 1 && string3.charCodeAt(len - 1) === 61)
      len--;
    return len * 3 >>> 2;
  }
  function toString$3(buffer) {
    const len = buffer.byteLength;
    let result = "";
    for (let i4 = 0; i4 < len; i4 += 3) {
      result += alphabet[buffer[i4] >> 2] + alphabet[(buffer[i4] & 3) << 4 | buffer[i4 + 1] >> 4] + alphabet[(buffer[i4 + 1] & 15) << 2 | buffer[i4 + 2] >> 6] + alphabet[buffer[i4 + 2] & 63];
    }
    if (len % 3 === 2) {
      result = result.substring(0, result.length - 1) + "=";
    } else if (len % 3 === 1) {
      result = result.substring(0, result.length - 2) + "==";
    }
    return result;
  }
  function write$4(buffer, string3, offset = 0, length2 = byteLength$3(string3)) {
    const len = Math.min(length2, buffer.byteLength - offset);
    for (let i4 = 0, j5 = 0; j5 < len; i4 += 4) {
      const a4 = codes[string3.charCodeAt(i4)];
      const b7 = codes[string3.charCodeAt(i4 + 1)];
      const c3 = codes[string3.charCodeAt(i4 + 2)];
      const d5 = codes[string3.charCodeAt(i4 + 3)];
      buffer[j5++] = a4 << 2 | b7 >> 4;
      buffer[j5++] = (b7 & 15) << 4 | c3 >> 2;
      buffer[j5++] = (c3 & 3) << 6 | d5 & 63;
    }
    return len;
  }
  var base64 = {
    byteLength: byteLength$3,
    toString: toString$3,
    write: write$4
  };
  function byteLength$2(string3) {
    return string3.length >>> 1;
  }
  function toString$2(buffer) {
    const len = buffer.byteLength;
    buffer = new DataView(buffer.buffer, buffer.byteOffset, len);
    let result = "";
    let i4 = 0;
    for (let n4 = len - len % 4; i4 < n4; i4 += 4) {
      result += buffer.getUint32(i4).toString(16).padStart(8, "0");
    }
    for (; i4 < len; i4++) {
      result += buffer.getUint8(i4).toString(16).padStart(2, "0");
    }
    return result;
  }
  function write$3(buffer, string3, offset = 0, length2 = byteLength$2(string3)) {
    const len = Math.min(length2, buffer.byteLength - offset);
    for (let i4 = 0; i4 < len; i4++) {
      const a4 = hexValue(string3.charCodeAt(i4 * 2));
      const b7 = hexValue(string3.charCodeAt(i4 * 2 + 1));
      if (a4 === void 0 || b7 === void 0) {
        return buffer.subarray(0, i4);
      }
      buffer[offset + i4] = a4 << 4 | b7;
    }
    return len;
  }
  var hex = {
    byteLength: byteLength$2,
    toString: toString$2,
    write: write$3
  };
  function hexValue(char) {
    if (char >= 48 && char <= 57)
      return char - 48;
    if (char >= 65 && char <= 70)
      return char - 65 + 10;
    if (char >= 97 && char <= 102)
      return char - 97 + 10;
  }
  function byteLength$1(string3) {
    let length2 = 0;
    for (let i4 = 0, n4 = string3.length; i4 < n4; i4++) {
      const code2 = string3.charCodeAt(i4);
      if (code2 >= 55296 && code2 <= 56319 && i4 + 1 < n4) {
        const code3 = string3.charCodeAt(i4 + 1);
        if (code3 >= 56320 && code3 <= 57343) {
          length2 += 4;
          i4++;
          continue;
        }
      }
      if (code2 <= 127)
        length2 += 1;
      else if (code2 <= 2047)
        length2 += 2;
      else
        length2 += 3;
    }
    return length2;
  }
  var toString$1;
  if (typeof TextDecoder !== "undefined") {
    const decoder = new TextDecoder();
    toString$1 = function toString3(buffer) {
      return decoder.decode(buffer);
    };
  } else {
    toString$1 = function toString3(buffer) {
      const len = buffer.byteLength;
      let output2 = "";
      let i4 = 0;
      while (i4 < len) {
        let byte = buffer[i4];
        if (byte <= 127) {
          output2 += String.fromCharCode(byte);
          i4++;
          continue;
        }
        let bytesNeeded = 0;
        let codePoint = 0;
        if (byte <= 223) {
          bytesNeeded = 1;
          codePoint = byte & 31;
        } else if (byte <= 239) {
          bytesNeeded = 2;
          codePoint = byte & 15;
        } else if (byte <= 244) {
          bytesNeeded = 3;
          codePoint = byte & 7;
        }
        if (len - i4 - bytesNeeded > 0) {
          let k5 = 0;
          while (k5 < bytesNeeded) {
            byte = buffer[i4 + k5 + 1];
            codePoint = codePoint << 6 | byte & 63;
            k5 += 1;
          }
        } else {
          codePoint = 65533;
          bytesNeeded = len - i4;
        }
        output2 += String.fromCodePoint(codePoint);
        i4 += bytesNeeded + 1;
      }
      return output2;
    };
  }
  var write$2;
  if (typeof TextEncoder !== "undefined") {
    const encoder = new TextEncoder();
    write$2 = function write(buffer, string3, offset = 0, length2 = byteLength$1(string3)) {
      const len = Math.min(length2, buffer.byteLength - offset);
      encoder.encodeInto(string3, buffer.subarray(offset, offset + len));
      return len;
    };
  } else {
    write$2 = function write(buffer, string3, offset = 0, length2 = byteLength$1(string3)) {
      const len = Math.min(length2, buffer.byteLength - offset);
      buffer = buffer.subarray(offset, offset + len);
      let i4 = 0;
      let j5 = 0;
      while (i4 < string3.length) {
        const code2 = string3.codePointAt(i4);
        if (code2 <= 127) {
          buffer[j5++] = code2;
          i4++;
          continue;
        }
        let count = 0;
        let bits2 = 0;
        if (code2 <= 2047) {
          count = 6;
          bits2 = 192;
        } else if (code2 <= 65535) {
          count = 12;
          bits2 = 224;
        } else if (code2 <= 2097151) {
          count = 18;
          bits2 = 240;
        }
        buffer[j5++] = bits2 | code2 >> count;
        count -= 6;
        while (count >= 0) {
          buffer[j5++] = 128 | code2 >> count & 63;
          count -= 6;
        }
        i4 += code2 >= 65536 ? 2 : 1;
      }
      return len;
    };
  }
  var utf8 = {
    byteLength: byteLength$1,
    toString: toString$1,
    write: write$2
  };
  function byteLength(string3) {
    return string3.length * 2;
  }
  function toString2(buffer) {
    const len = buffer.byteLength;
    let result = "";
    for (let i4 = 0; i4 < len - 1; i4 += 2) {
      result += String.fromCharCode(buffer[i4] + buffer[i4 + 1] * 256);
    }
    return result;
  }
  function write$1(buffer, string3, offset = 0, length2 = byteLength(string3)) {
    const len = Math.min(length2, buffer.byteLength - offset);
    let units = len;
    for (let i4 = 0; i4 < string3.length; ++i4) {
      if ((units -= 2) < 0)
        break;
      const c3 = string3.charCodeAt(i4);
      const hi2 = c3 >> 8;
      const lo2 = c3 % 256;
      buffer[offset + i4 * 2] = lo2;
      buffer[offset + i4 * 2 + 1] = hi2;
    }
    return len;
  }
  var utf16le = {
    byteLength,
    toString: toString2,
    write: write$1
  };
  (function(module, exports) {
    const ascii$1 = ascii;
    const base64$12 = base64;
    const hex$1 = hex;
    const utf8$1 = utf8;
    const utf16le$1 = utf16le;
    const LE = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
    function codecFor(encoding) {
      switch (encoding) {
        case "ascii":
          return ascii$1;
        case "base64":
          return base64$12;
        case "hex":
          return hex$1;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8$1;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16le$1;
        default:
          throw new Error(`Unknown encoding: ${encoding}`);
      }
    }
    function isBuffer(value) {
      return value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      try {
        codecFor(encoding);
        return true;
      } catch {
        return false;
      }
    }
    function alloc(size, fill2, encoding) {
      const buffer = new Uint8Array(size);
      if (fill2 !== void 0)
        exports.fill(buffer, fill2, 0, buffer.byteLength, encoding);
      return buffer;
    }
    function allocUnsafe2(size) {
      return new Uint8Array(size);
    }
    function allocUnsafeSlow(size) {
      return new Uint8Array(size);
    }
    function byteLength2(string3, encoding) {
      return codecFor(encoding).byteLength(string3);
    }
    function compare2(a4, b7) {
      if (a4 === b7)
        return 0;
      const len = Math.min(a4.byteLength, b7.byteLength);
      a4 = new DataView(a4.buffer, a4.byteOffset, a4.byteLength);
      b7 = new DataView(b7.buffer, b7.byteOffset, b7.byteLength);
      let i4 = 0;
      for (let n4 = len - len % 4; i4 < n4; i4 += 4) {
        const x6 = a4.getUint32(i4, LE);
        const y5 = b7.getUint32(i4, LE);
        if (x6 !== y5)
          break;
      }
      for (; i4 < len; i4++) {
        const x6 = a4.getUint8(i4);
        const y5 = b7.getUint8(i4);
        if (x6 < y5)
          return -1;
        if (x6 > y5)
          return 1;
      }
      return a4.byteLength > b7.byteLength ? 1 : a4.byteLength < b7.byteLength ? -1 : 0;
    }
    function concat2(buffers, totalLength) {
      if (totalLength === void 0) {
        totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);
      }
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const buffer of buffers) {
        if (offset + buffer.byteLength > result.byteLength) {
          const sub2 = buffer.subarray(0, result.byteLength - offset);
          result.set(sub2, offset);
          return result;
        }
        result.set(buffer, offset);
        offset += buffer.byteLength;
      }
      return result;
    }
    function copy2(source, target, targetStart = 0, start = 0, end = source.byteLength) {
      if (end > 0 && end < start)
        return 0;
      if (end === start)
        return 0;
      if (source.byteLength === 0 || target.byteLength === 0)
        return 0;
      if (targetStart < 0)
        throw new RangeError("targetStart is out of range");
      if (start < 0 || start >= source.byteLength)
        throw new RangeError("sourceStart is out of range");
      if (end < 0)
        throw new RangeError("sourceEnd is out of range");
      if (targetStart >= target.byteLength)
        targetStart = target.byteLength;
      if (end > source.byteLength)
        end = source.byteLength;
      if (target.byteLength - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (source === target) {
        target.copyWithin(targetStart, start, end);
      } else {
        target.set(source.subarray(start, end), targetStart);
      }
      return len;
    }
    function equals(a4, b7) {
      if (a4 === b7)
        return true;
      if (a4.byteLength !== b7.byteLength)
        return false;
      const len = a4.byteLength;
      a4 = new DataView(a4.buffer, a4.byteOffset, a4.byteLength);
      b7 = new DataView(b7.buffer, b7.byteOffset, b7.byteLength);
      let i4 = 0;
      for (let n4 = len - len % 4; i4 < n4; i4 += 4) {
        if (a4.getUint32(i4, LE) !== b7.getUint32(i4, LE))
          return false;
      }
      for (; i4 < len; i4++) {
        if (a4.getUint8(i4) !== b7.getUint8(i4))
          return false;
      }
      return true;
    }
    function fill(buffer, value, offset, end, encoding) {
      if (typeof value === "string") {
        if (typeof offset === "string") {
          encoding = offset;
          offset = 0;
          end = buffer.byteLength;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.byteLength;
        }
      } else if (typeof value === "number") {
        value = value & 255;
      } else if (typeof value === "boolean") {
        value = +value;
      }
      if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {
        throw new RangeError("Out of range index");
      }
      if (offset === void 0)
        offset = 0;
      if (end === void 0)
        end = buffer.byteLength;
      if (end <= offset)
        return buffer;
      if (!value)
        value = 0;
      if (typeof value === "number") {
        for (let i4 = offset; i4 < end; ++i4) {
          buffer[i4] = value;
        }
      } else {
        value = isBuffer(value) ? value : from2(value, encoding);
        const len = value.byteLength;
        for (let i4 = 0; i4 < end - offset; ++i4) {
          buffer[i4 + offset] = value[i4 % len];
        }
      }
      return buffer;
    }
    function from2(value, encodingOrOffset, length2) {
      if (typeof value === "string")
        return fromString3(value, encodingOrOffset);
      if (Array.isArray(value))
        return fromArray2(value);
      if (ArrayBuffer.isView(value))
        return fromBuffer(value);
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    function fromString3(string3, encoding) {
      const codec = codecFor(encoding);
      const buffer = new Uint8Array(codec.byteLength(string3));
      codec.write(buffer, string3, 0, buffer.byteLength);
      return buffer;
    }
    function fromArray2(array) {
      const buffer = new Uint8Array(array.length);
      buffer.set(array);
      return buffer;
    }
    function fromBuffer(buffer) {
      const copy3 = new Uint8Array(buffer.byteLength);
      copy3.set(buffer);
      return copy3;
    }
    function fromArrayBuffer(arrayBuffer, byteOffset, length2) {
      return new Uint8Array(arrayBuffer, byteOffset, length2);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return indexOf(buffer, value, byteOffset, encoding) !== -1;
    }
    function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {
      if (buffer.byteLength === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset === void 0) {
        byteOffset = first ? 0 : buffer.length - 1;
      } else if (byteOffset < 0) {
        byteOffset += buffer.byteLength;
      }
      if (byteOffset >= buffer.byteLength) {
        if (first)
          return -1;
        else
          byteOffset = buffer.byteLength - 1;
      } else if (byteOffset < 0) {
        if (first)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof value === "string") {
        value = from2(value, encoding);
      } else if (typeof value === "number") {
        value = value & 255;
        if (first) {
          return buffer.indexOf(value, byteOffset);
        } else {
          return buffer.lastIndexOf(value, byteOffset);
        }
      }
      if (value.byteLength === 0)
        return -1;
      if (first) {
        let foundIndex = -1;
        for (let i4 = byteOffset; i4 < buffer.byteLength; i4++) {
          if (buffer[i4] === value[foundIndex === -1 ? 0 : i4 - foundIndex]) {
            if (foundIndex === -1)
              foundIndex = i4;
            if (i4 - foundIndex + 1 === value.byteLength)
              return foundIndex;
          } else {
            if (foundIndex !== -1)
              i4 -= i4 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + value.byteLength > buffer.byteLength) {
          byteOffset = buffer.byteLength - value.byteLength;
        }
        for (let i4 = byteOffset; i4 >= 0; i4--) {
          let found = true;
          for (let j5 = 0; j5 < value.byteLength; j5++) {
            if (buffer[i4 + j5] !== value[j5]) {
              found = false;
              break;
            }
          }
          if (found)
            return i4;
        }
      }
      return -1;
    }
    function indexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false);
    }
    function swap(buffer, n4, m5) {
      const i4 = buffer[n4];
      buffer[n4] = buffer[m5];
      buffer[m5] = i4;
    }
    function swap16(buffer) {
      const len = buffer.byteLength;
      if (len % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let i4 = 0; i4 < len; i4 += 2)
        swap(buffer, i4, i4 + 1);
      return buffer;
    }
    function swap32(buffer) {
      const len = buffer.byteLength;
      if (len % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let i4 = 0; i4 < len; i4 += 4) {
        swap(buffer, i4, i4 + 3);
        swap(buffer, i4 + 1, i4 + 2);
      }
      return buffer;
    }
    function swap64(buffer) {
      const len = buffer.byteLength;
      if (len % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let i4 = 0; i4 < len; i4 += 8) {
        swap(buffer, i4, i4 + 7);
        swap(buffer, i4 + 1, i4 + 6);
        swap(buffer, i4 + 2, i4 + 5);
        swap(buffer, i4 + 3, i4 + 4);
      }
      return buffer;
    }
    function toBuffer(buffer) {
      return buffer;
    }
    function toString3(buffer, encoding, start = 0, end = buffer.byteLength) {
      const len = buffer.byteLength;
      if (start >= len)
        return "";
      if (end <= start)
        return "";
      if (start < 0)
        start = 0;
      if (end > len)
        end = len;
      if (start !== 0 || end < len)
        buffer = buffer.subarray(start, end);
      return codecFor(encoding).toString(buffer);
    }
    function write(buffer, string3, offset, length2, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
      } else if (length2 === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      } else if (encoding === void 0 && typeof length2 === "string") {
        encoding = length2;
        length2 = void 0;
      }
      return codecFor(encoding).write(buffer, string3, offset, length2);
    }
    function writeDoubleLE(buffer, value, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat64(offset, value, true);
      return offset + 8;
    }
    function writeFloatLE(buffer, value, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setFloat32(offset, value, true);
      return offset + 4;
    }
    function writeUInt32LE(buffer, value, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setUint32(offset, value, true);
      return offset + 4;
    }
    function writeInt32LE(buffer, value, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      view.setInt32(offset, value, true);
      return offset + 4;
    }
    function readDoubleLE(buffer, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat64(offset, true);
    }
    function readFloatLE(buffer, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getFloat32(offset, true);
    }
    function readUInt32LE(buffer, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getUint32(offset, true);
    }
    function readInt32LE(buffer, offset) {
      if (offset === void 0)
        offset = 0;
      const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
      return view.getInt32(offset, true);
    }
    module.exports = exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe: allocUnsafe2,
      allocUnsafeSlow,
      byteLength: byteLength2,
      compare: compare2,
      concat: concat2,
      copy: copy2,
      equals,
      fill,
      from: from2,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer,
      toString: toString3,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE
    };
  })(browser, browser.exports);
  var blake2b;
  var hasRequiredBlake2b;
  function requireBlake2b() {
    if (hasRequiredBlake2b)
      return blake2b;
    hasRequiredBlake2b = 1;
    var __commonJS = (cb, mod3) => function __require() {
      return mod3 || (0, cb[Object.keys(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
    };
    var __toBinary = /* @__PURE__ */ (() => {
      var table = new Uint8Array(128);
      for (var i4 = 0; i4 < 64; i4++)
        table[i4 < 26 ? i4 + 65 : i4 < 52 ? i4 + 71 : i4 < 62 ? i4 - 4 : i4 * 4 - 205] = i4;
      return (base643) => {
        var n4 = base643.length, bytes22 = new Uint8Array((n4 - (base643[n4 - 1] == "=") - (base643[n4 - 2] == "=")) * 3 / 4 | 0);
        for (var i22 = 0, j5 = 0; i22 < n4; ) {
          var c0 = table[base643.charCodeAt(i22++)], c1 = table[base643.charCodeAt(i22++)];
          var c22 = table[base643.charCodeAt(i22++)], c3 = table[base643.charCodeAt(i22++)];
          bytes22[j5++] = c0 << 2 | c1 >> 4;
          bytes22[j5++] = c1 << 4 | c22 >> 2;
          bytes22[j5++] = c22 << 6 | c3;
        }
        return bytes22;
      };
    })();
    var require_blake2b = __commonJS({
      "wasm-binary:./blake2b.wat"(exports2, module2) {
        module2.exports = __toBinary("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=");
      }
    });
    var bytes2 = require_blake2b();
    var compiled = WebAssembly.compile(bytes2);
    blake2b = async (imports) => {
      const instance = await WebAssembly.instantiate(await compiled, imports);
      return instance.exports;
    };
    return blake2b;
  }
  var assert = nanoassert;
  var b4a = browser.exports;
  var wasm = null;
  var wasmPromise = typeof WebAssembly !== "undefined" && requireBlake2b()().then((mod3) => {
    wasm = mod3;
  });
  var head = 64;
  var freeList = [];
  blake2bWasm.exports = Blake2b;
  var BYTES_MIN = blake2bWasm.exports.BYTES_MIN = 16;
  var BYTES_MAX = blake2bWasm.exports.BYTES_MAX = 64;
  blake2bWasm.exports.BYTES = 32;
  var KEYBYTES_MIN = blake2bWasm.exports.KEYBYTES_MIN = 16;
  var KEYBYTES_MAX = blake2bWasm.exports.KEYBYTES_MAX = 64;
  blake2bWasm.exports.KEYBYTES = 32;
  var SALTBYTES = blake2bWasm.exports.SALTBYTES = 16;
  var PERSONALBYTES = blake2bWasm.exports.PERSONALBYTES = 16;
  function Blake2b(digestLength, key, salt, personal, noAssert) {
    if (!(this instanceof Blake2b))
      return new Blake2b(digestLength, key, salt, personal, noAssert);
    if (!wasm)
      throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
    if (!digestLength)
      digestLength = 32;
    if (noAssert !== true) {
      assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
      assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
      if (key != null) {
        assert(key instanceof Uint8Array, "key must be Uint8Array or Buffer");
        assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
        assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
      }
      if (salt != null) {
        assert(salt instanceof Uint8Array, "salt must be Uint8Array or Buffer");
        assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
      }
      if (personal != null) {
        assert(personal instanceof Uint8Array, "personal must be Uint8Array or Buffer");
        assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
      }
    }
    if (!freeList.length) {
      freeList.push(head);
      head += 216;
    }
    this.digestLength = digestLength;
    this.finalized = false;
    this.pointer = freeList.pop();
    this._memory = new Uint8Array(wasm.memory.buffer);
    this._memory.fill(0, 0, 64);
    this._memory[0] = this.digestLength;
    this._memory[1] = key ? key.length : 0;
    this._memory[2] = 1;
    this._memory[3] = 1;
    if (salt)
      this._memory.set(salt, 32);
    if (personal)
      this._memory.set(personal, 48);
    if (this.pointer + 216 > this._memory.length)
      this._realloc(this.pointer + 216);
    wasm.blake2b_init(this.pointer, this.digestLength);
    if (key) {
      this.update(key);
      this._memory.fill(0, head, head + key.length);
      this._memory[this.pointer + 200] = 128;
    }
  }
  Blake2b.prototype._realloc = function(size) {
    wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)));
    this._memory = new Uint8Array(wasm.memory.buffer);
  };
  Blake2b.prototype.update = function(input) {
    assert(this.finalized === false, "Hash instance finalized");
    assert(input instanceof Uint8Array, "input must be Uint8Array or Buffer");
    if (head + input.length > this._memory.length)
      this._realloc(head + input.length);
    this._memory.set(input, head);
    wasm.blake2b_update(this.pointer, head, head + input.length);
    return this;
  };
  Blake2b.prototype.digest = function(enc) {
    assert(this.finalized === false, "Hash instance finalized");
    this.finalized = true;
    freeList.push(this.pointer);
    wasm.blake2b_final(this.pointer);
    if (!enc || enc === "binary") {
      return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
    }
    if (typeof enc === "string") {
      return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength);
    }
    assert(enc instanceof Uint8Array && enc.length >= this.digestLength, "input must be Uint8Array or Buffer");
    for (var i4 = 0; i4 < this.digestLength; i4++) {
      enc[i4] = this._memory[this.pointer + 128 + i4];
    }
    return enc;
  };
  Blake2b.prototype.final = Blake2b.prototype.digest;
  Blake2b.WASM = wasm;
  Blake2b.SUPPORTED = typeof WebAssembly !== "undefined";
  Blake2b.ready = function(cb) {
    if (!cb)
      cb = noop;
    if (!wasmPromise)
      return cb(new Error("WebAssembly not supported"));
    return wasmPromise.then(() => cb(), cb);
  };
  Blake2b.prototype.ready = Blake2b.ready;
  Blake2b.prototype.getPartialHash = function() {
    return this._memory.slice(this.pointer, this.pointer + 216);
  };
  Blake2b.prototype.setPartialHash = function(ph2) {
    this._memory.set(ph2, this.pointer);
  };
  function noop() {
  }
  function log22(V5) {
    return ((V5 & 4294901760) !== 0 ? (V5 &= 4294901760, 16) : 0) | ((V5 & 4278255360) !== 0 ? (V5 &= 4278255360, 8) : 0) | ((V5 & 4042322160) !== 0 ? (V5 &= 4042322160, 4) : 0) | ((V5 & 3435973836) !== 0 ? (V5 &= 3435973836, 2) : 0) | (V5 & 2863311530) !== 0;
  }
  var GROTH16_PROTOCOL_ID = 1;
  var PLONK_PROTOCOL_ID = 2;
  var FFLONK_PROTOCOL_ID = 10;
  var ZKEY_FF_HEADER_SECTION = 2;
  async function readG1(fd2, curve2, toObject2) {
    const buff = await fd2.read(curve2.G1.F.n8 * 2);
    const res = curve2.G1.fromRprLEM(buff, 0);
    return toObject2 ? curve2.G1.toObject(res) : res;
  }
  async function readG2(fd2, curve2, toObject2) {
    const buff = await fd2.read(curve2.G2.F.n8 * 2);
    const res = curve2.G2.fromRprLEM(buff, 0);
    return toObject2 ? curve2.G2.toObject(res) : res;
  }
  async function readHeader$1(fd2, sections, toObject2) {
    await startReadUniqueSection(fd2, sections, 1);
    const protocolId = await fd2.readULE32();
    await endReadSection(fd2);
    if (protocolId === GROTH16_PROTOCOL_ID) {
      return await readHeaderGroth16(fd2, sections, toObject2);
    } else if (protocolId === PLONK_PROTOCOL_ID) {
      return await readHeaderPlonk(fd2, sections, toObject2);
    } else if (protocolId === FFLONK_PROTOCOL_ID) {
      return await readHeaderFFlonk(fd2, sections, toObject2);
    } else {
      throw new Error("Protocol not supported: ");
    }
  }
  async function readHeaderGroth16(fd2, sections, toObject2) {
    const zkey = {};
    zkey.protocol = "groth16";
    await startReadUniqueSection(fd2, sections, 2);
    const n8q = await fd2.readULE32();
    zkey.n8q = n8q;
    zkey.q = await readBigInt(fd2, n8q);
    const n8r = await fd2.readULE32();
    zkey.n8r = n8r;
    zkey.r = await readBigInt(fd2, n8r);
    zkey.curve = await getCurveFromQ(zkey.q);
    zkey.nVars = await fd2.readULE32();
    zkey.nPublic = await fd2.readULE32();
    zkey.domainSize = await fd2.readULE32();
    zkey.power = log22(zkey.domainSize);
    zkey.vk_alpha_1 = await readG1(fd2, zkey.curve, toObject2);
    zkey.vk_beta_1 = await readG1(fd2, zkey.curve, toObject2);
    zkey.vk_beta_2 = await readG2(fd2, zkey.curve, toObject2);
    zkey.vk_gamma_2 = await readG2(fd2, zkey.curve, toObject2);
    zkey.vk_delta_1 = await readG1(fd2, zkey.curve, toObject2);
    zkey.vk_delta_2 = await readG2(fd2, zkey.curve, toObject2);
    await endReadSection(fd2);
    return zkey;
  }
  async function readHeaderPlonk(fd2, sections, toObject2) {
    const zkey = {};
    zkey.protocol = "plonk";
    await startReadUniqueSection(fd2, sections, 2);
    const n8q = await fd2.readULE32();
    zkey.n8q = n8q;
    zkey.q = await readBigInt(fd2, n8q);
    const n8r = await fd2.readULE32();
    zkey.n8r = n8r;
    zkey.r = await readBigInt(fd2, n8r);
    zkey.curve = await getCurveFromQ(zkey.q);
    zkey.nVars = await fd2.readULE32();
    zkey.nPublic = await fd2.readULE32();
    zkey.domainSize = await fd2.readULE32();
    zkey.power = log22(zkey.domainSize);
    zkey.nAdditions = await fd2.readULE32();
    zkey.nConstraints = await fd2.readULE32();
    zkey.k1 = await fd2.read(n8r);
    zkey.k2 = await fd2.read(n8r);
    zkey.Qm = await readG1(fd2, zkey.curve, toObject2);
    zkey.Ql = await readG1(fd2, zkey.curve, toObject2);
    zkey.Qr = await readG1(fd2, zkey.curve, toObject2);
    zkey.Qo = await readG1(fd2, zkey.curve, toObject2);
    zkey.Qc = await readG1(fd2, zkey.curve, toObject2);
    zkey.S1 = await readG1(fd2, zkey.curve, toObject2);
    zkey.S2 = await readG1(fd2, zkey.curve, toObject2);
    zkey.S3 = await readG1(fd2, zkey.curve, toObject2);
    zkey.X_2 = await readG2(fd2, zkey.curve, toObject2);
    await endReadSection(fd2);
    return zkey;
  }
  async function readHeaderFFlonk(fd2, sections, toObject2) {
    const zkey = {};
    zkey.protocol = "fflonk";
    zkey.protocolId = FFLONK_PROTOCOL_ID;
    await startReadUniqueSection(fd2, sections, ZKEY_FF_HEADER_SECTION);
    const n8q = await fd2.readULE32();
    zkey.n8q = n8q;
    zkey.q = await readBigInt(fd2, n8q);
    zkey.curve = await getCurveFromQ(zkey.q);
    const n8r = await fd2.readULE32();
    zkey.n8r = n8r;
    zkey.r = await readBigInt(fd2, n8r);
    zkey.nVars = await fd2.readULE32();
    zkey.nPublic = await fd2.readULE32();
    zkey.domainSize = await fd2.readULE32();
    zkey.power = log22(zkey.domainSize);
    zkey.nAdditions = await fd2.readULE32();
    zkey.nConstraints = await fd2.readULE32();
    zkey.k1 = await fd2.read(n8r);
    zkey.k2 = await fd2.read(n8r);
    zkey.w3 = await fd2.read(n8r);
    zkey.w4 = await fd2.read(n8r);
    zkey.w8 = await fd2.read(n8r);
    zkey.wr = await fd2.read(n8r);
    zkey.X_2 = await readG2(fd2, zkey.curve, toObject2);
    zkey.C0 = await readG1(fd2, zkey.curve, toObject2);
    await endReadSection(fd2);
    return zkey;
  }
  async function writeBin(fd2, witnessBin, prime) {
    await startWriteSection(fd2, 1);
    const n8 = (Math.floor((Scalar.bitLength(prime) - 1) / 64) + 1) * 8;
    await fd2.writeULE32(n8);
    await writeBigInt(fd2, prime, n8);
    if (witnessBin.byteLength % n8 != 0) {
      throw new Error("Invalid witness length");
    }
    await fd2.writeULE32(witnessBin.byteLength / n8);
    await endWriteSection(fd2);
    await startWriteSection(fd2, 2);
    await fd2.write(witnessBin);
    await endWriteSection(fd2);
  }
  async function readHeader(fd2, sections) {
    await startReadUniqueSection(fd2, sections, 1);
    const n8 = await fd2.readULE32();
    const q5 = await readBigInt(fd2, n8);
    const nWitness = await fd2.readULE32();
    await endReadSection(fd2);
    return { n8, q: q5, nWitness };
  }
  var { stringifyBigInts: stringifyBigInts$4 } = utils;
  async function groth16Prove(zkeyFileName, witnessFileName, logger) {
    const { fd: fdWtns, sections: sectionsWtns } = await readBinFile(witnessFileName, "wtns", 2);
    const wtns = await readHeader(fdWtns, sectionsWtns);
    const { fd: fdZKey, sections: sectionsZKey } = await readBinFile(zkeyFileName, "zkey", 2);
    const zkey = await readHeader$1(fdZKey, sectionsZKey);
    if (zkey.protocol != "groth16") {
      throw new Error("zkey file is not groth16");
    }
    if (!Scalar.eq(zkey.r, wtns.q)) {
      throw new Error("Curve of the witness does not match the curve of the proving key");
    }
    if (wtns.nWitness != zkey.nVars) {
      throw new Error(`Invalid witness length. Circuit: ${zkey.nVars}, witness: ${wtns.nWitness}`);
    }
    const curve2 = zkey.curve;
    const Fr2 = curve2.Fr;
    const G1 = curve2.G1;
    const G22 = curve2.G2;
    const power = log22(zkey.domainSize);
    if (logger)
      logger.debug("Reading Wtns");
    const buffWitness = await readSection(fdWtns, sectionsWtns, 2);
    if (logger)
      logger.debug("Reading Coeffs");
    const buffCoeffs = await readSection(fdZKey, sectionsZKey, 4);
    if (logger)
      logger.debug("Building ABC");
    const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve2, zkey, buffWitness, buffCoeffs, logger);
    const inc = power == Fr2.s ? curve2.Fr.shift : curve2.Fr.w[power + 1];
    const buffA = await Fr2.ifft(buffA_T, "", "", logger, "IFFT_A");
    const buffAodd = await Fr2.batchApplyKey(buffA, Fr2.e(1), inc);
    const buffAodd_T = await Fr2.fft(buffAodd, "", "", logger, "FFT_A");
    const buffB = await Fr2.ifft(buffB_T, "", "", logger, "IFFT_B");
    const buffBodd = await Fr2.batchApplyKey(buffB, Fr2.e(1), inc);
    const buffBodd_T = await Fr2.fft(buffBodd, "", "", logger, "FFT_B");
    const buffC = await Fr2.ifft(buffC_T, "", "", logger, "IFFT_C");
    const buffCodd = await Fr2.batchApplyKey(buffC, Fr2.e(1), inc);
    const buffCodd_T = await Fr2.fft(buffCodd, "", "", logger, "FFT_C");
    if (logger)
      logger.debug("Join ABC");
    const buffPodd_T = await joinABC(curve2, zkey, buffAodd_T, buffBodd_T, buffCodd_T, logger);
    let proof = {};
    if (logger)
      logger.debug("Reading A Points");
    const buffBasesA = await readSection(fdZKey, sectionsZKey, 5);
    proof.pi_a = await curve2.G1.multiExpAffine(buffBasesA, buffWitness, logger, "multiexp A");
    if (logger)
      logger.debug("Reading B1 Points");
    const buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);
    let pib1 = await curve2.G1.multiExpAffine(buffBasesB1, buffWitness, logger, "multiexp B1");
    if (logger)
      logger.debug("Reading B2 Points");
    const buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);
    proof.pi_b = await curve2.G2.multiExpAffine(buffBasesB2, buffWitness, logger, "multiexp B2");
    if (logger)
      logger.debug("Reading C Points");
    const buffBasesC = await readSection(fdZKey, sectionsZKey, 8);
    proof.pi_c = await curve2.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey.nPublic + 1) * curve2.Fr.n8), logger, "multiexp C");
    if (logger)
      logger.debug("Reading H Points");
    const buffBasesH = await readSection(fdZKey, sectionsZKey, 9);
    const resH = await curve2.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, "multiexp H");
    const r = curve2.Fr.random();
    const s3 = curve2.Fr.random();
    proof.pi_a = G1.add(proof.pi_a, zkey.vk_alpha_1);
    proof.pi_a = G1.add(proof.pi_a, G1.timesFr(zkey.vk_delta_1, r));
    proof.pi_b = G22.add(proof.pi_b, zkey.vk_beta_2);
    proof.pi_b = G22.add(proof.pi_b, G22.timesFr(zkey.vk_delta_2, s3));
    pib1 = G1.add(pib1, zkey.vk_beta_1);
    pib1 = G1.add(pib1, G1.timesFr(zkey.vk_delta_1, s3));
    proof.pi_c = G1.add(proof.pi_c, resH);
    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(proof.pi_a, s3));
    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(pib1, r));
    proof.pi_c = G1.add(proof.pi_c, G1.timesFr(zkey.vk_delta_1, Fr2.neg(Fr2.mul(r, s3))));
    let publicSignals = [];
    for (let i4 = 1; i4 <= zkey.nPublic; i4++) {
      const b7 = buffWitness.slice(i4 * Fr2.n8, i4 * Fr2.n8 + Fr2.n8);
      publicSignals.push(Scalar.fromRprLE(b7));
    }
    proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
    proof.pi_b = G22.toObject(G22.toAffine(proof.pi_b));
    proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));
    proof.protocol = "groth16";
    proof.curve = curve2.name;
    await fdZKey.close();
    await fdWtns.close();
    proof = stringifyBigInts$4(proof);
    publicSignals = stringifyBigInts$4(publicSignals);
    return { proof, publicSignals };
  }
  async function buildABC1(curve2, zkey, witness, coeffs, logger) {
    const n8 = curve2.Fr.n8;
    const sCoef = 4 * 3 + zkey.n8r;
    const nCoef = (coeffs.byteLength - 4) / sCoef;
    const outBuffA = new BigBuffer(zkey.domainSize * n8);
    const outBuffB = new BigBuffer(zkey.domainSize * n8);
    const outBuffC = new BigBuffer(zkey.domainSize * n8);
    const outBuf = [outBuffA, outBuffB];
    for (let i4 = 0; i4 < nCoef; i4++) {
      if (logger && i4 % 1e6 == 0)
        logger.debug(`QAP AB: ${i4}/${nCoef}`);
      const buffCoef = coeffs.slice(4 + i4 * sCoef, 4 + i4 * sCoef + sCoef);
      const buffCoefV = new DataView(buffCoef.buffer);
      const m5 = buffCoefV.getUint32(0, true);
      const c3 = buffCoefV.getUint32(4, true);
      const s3 = buffCoefV.getUint32(8, true);
      const coef = buffCoef.slice(12, 12 + n8);
      outBuf[m5].set(
        curve2.Fr.add(
          outBuf[m5].slice(c3 * n8, c3 * n8 + n8),
          curve2.Fr.mul(coef, witness.slice(s3 * n8, s3 * n8 + n8))
        ),
        c3 * n8
      );
    }
    for (let i4 = 0; i4 < zkey.domainSize; i4++) {
      if (logger && i4 % 1e6 == 0)
        logger.debug(`QAP C: ${i4}/${zkey.domainSize}`);
      outBuffC.set(
        curve2.Fr.mul(
          outBuffA.slice(i4 * n8, i4 * n8 + n8),
          outBuffB.slice(i4 * n8, i4 * n8 + n8)
        ),
        i4 * n8
      );
    }
    return [outBuffA, outBuffB, outBuffC];
  }
  async function joinABC(curve2, zkey, a4, b7, c3, logger) {
    const MAX_CHUNK_SIZE = 1 << 22;
    const n8 = curve2.Fr.n8;
    const nElements = Math.floor(a4.byteLength / curve2.Fr.n8);
    const promises = [];
    for (let i4 = 0; i4 < nElements; i4 += MAX_CHUNK_SIZE) {
      if (logger)
        logger.debug(`JoinABC: ${i4}/${nElements}`);
      const n4 = Math.min(nElements - i4, MAX_CHUNK_SIZE);
      const task = [];
      const aChunk = a4.slice(i4 * n8, (i4 + n4) * n8);
      const bChunk = b7.slice(i4 * n8, (i4 + n4) * n8);
      const cChunk = c3.slice(i4 * n8, (i4 + n4) * n8);
      task.push({ cmd: "ALLOCSET", var: 0, buff: aChunk });
      task.push({ cmd: "ALLOCSET", var: 1, buff: bChunk });
      task.push({ cmd: "ALLOCSET", var: 2, buff: cChunk });
      task.push({ cmd: "ALLOC", var: 3, len: n4 * n8 });
      task.push({ cmd: "CALL", fnName: "qap_joinABC", params: [
        { var: 0 },
        { var: 1 },
        { var: 2 },
        { val: n4 },
        { var: 3 }
      ] });
      task.push({ cmd: "CALL", fnName: "frm_batchFromMontgomery", params: [
        { var: 3 },
        { val: n4 },
        { var: 3 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 3, len: n4 * n8 });
      promises.push(curve2.tm.queueAction(task));
    }
    const result = await Promise.all(promises);
    let outBuff;
    if (a4 instanceof BigBuffer) {
      outBuff = new BigBuffer(a4.byteLength);
    } else {
      outBuff = new Uint8Array(a4.byteLength);
    }
    let p6 = 0;
    for (let i4 = 0; i4 < result.length; i4++) {
      outBuff.set(result[i4][0], p6);
      p6 += result[i4][0].byteLength;
    }
    return outBuff;
  }
  function flatArray(a4) {
    var res = [];
    fillArray(res, a4);
    return res;
    function fillArray(res2, a5) {
      if (Array.isArray(a5)) {
        for (let i4 = 0; i4 < a5.length; i4++) {
          fillArray(res2, a5[i4]);
        }
      } else {
        res2.push(a5);
      }
    }
  }
  function normalize(n4, prime) {
    let res = BigInt(n4) % prime;
    if (res < 0)
      res += prime;
    return res;
  }
  function fnvHash(str) {
    const uint64_max = BigInt(2) ** BigInt(64);
    let hash2 = BigInt("0xCBF29CE484222325");
    for (var i4 = 0; i4 < str.length; i4++) {
      hash2 ^= BigInt(str[i4].charCodeAt());
      hash2 *= BigInt(1099511628211);
      hash2 %= uint64_max;
    }
    let shash = hash2.toString(16);
    let n4 = 16 - shash.length;
    shash = "0".repeat(n4).concat(shash);
    return shash;
  }
  function toArray32(s3, size) {
    const res = [];
    let rem = BigInt(s3);
    const radix = BigInt(4294967296);
    while (rem) {
      res.unshift(Number(rem % radix));
      rem = rem / radix;
    }
    if (size) {
      var i4 = size - res.length;
      while (i4 > 0) {
        res.unshift(0);
        i4--;
      }
    }
    return res;
  }
  async function builder(code2, options) {
    options = options || {};
    let memorySize = 32767;
    let memory;
    let memoryAllocated = false;
    while (!memoryAllocated) {
      try {
        memory = new WebAssembly.Memory({ initial: memorySize });
        memoryAllocated = true;
      } catch (err) {
        if (memorySize === 1) {
          throw err;
        }
        console.warn("Could not allocate " + memorySize * 1024 * 64 + " bytes. This may cause severe instability. Trying with " + memorySize * 1024 * 64 / 2 + " bytes");
        memorySize = Math.floor(memorySize / 2);
      }
    }
    const wasmModule = await WebAssembly.compile(code2);
    let wc2;
    let errStr = "";
    let msgStr = "";
    let majorVersion = 1;
    let minorVersion = 0;
    let patchVersion = 0;
    const instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      },
      runtime: {
        exceptionHandler: function(code3) {
          let err;
          if (code3 == 1) {
            err = "Signal not found. ";
          } else if (code3 == 2) {
            err = "Too many signals set. ";
          } else if (code3 == 3) {
            err = "Signal already set. ";
          } else if (code3 == 4) {
            err = "Assert Failed. ";
          } else if (code3 == 5) {
            err = "Not enough memory. ";
          } else if (code3 == 6) {
            err = "Input signal array access exceeds the size. ";
          } else {
            err = "Unknown error. ";
          }
          console.error("ERROR: ", code3, errStr);
          throw new Error(err + errStr);
        },
        printErrorMessage: function() {
          errStr += getMessage() + "\n";
        },
        writeBufferMessage: function() {
          const msg = getMessage();
          if (msg === "\n") {
            console.log(msgStr);
            msgStr = "";
          } else {
            if (msgStr !== "") {
              msgStr += " ";
            }
            msgStr += msg;
          }
        },
        showSharedRWMemory: function() {
          const shared_rw_memory_size = instance.exports.getFieldNumLen32();
          const arr = new Uint32Array(shared_rw_memory_size);
          for (let j5 = 0; j5 < shared_rw_memory_size; j5++) {
            arr[shared_rw_memory_size - 1 - j5] = instance.exports.readSharedRWMemory(j5);
          }
          if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {
            if (msgStr !== "") {
              msgStr += " ";
            }
            const msg = Scalar.fromArray(arr, 4294967296).toString();
            msgStr += msg;
          } else {
            console.log(Scalar.fromArray(arr, 4294967296));
          }
        },
        error: function(code3, pstr, a4, b7, c3, d5) {
          let errStr2;
          if (code3 == 7) {
            errStr2 = p2str(pstr) + " " + wc2.getFr(b7).toString() + " != " + wc2.getFr(c3).toString() + " " + p2str(d5);
          } else if (code3 == 9) {
            errStr2 = p2str(pstr) + " " + wc2.getFr(b7).toString() + " " + p2str(c3);
          } else if (code3 == 5 && options.sym) {
            errStr2 = p2str(pstr) + " " + options.sym.labelIdx2Name[c3];
          } else {
            errStr2 = p2str(pstr) + " " + a4 + " " + b7 + " " + c3 + " " + d5;
          }
          console.log("ERROR: ", code3, errStr2);
          throw new Error(errStr2);
        },
        log: function(a4) {
          console.log(wc2.getFr(a4).toString());
        },
        logGetSignal: function(signal, pVal) {
          if (options.logGetSignal) {
            options.logGetSignal(signal, wc2.getFr(pVal));
          }
        },
        logSetSignal: function(signal, pVal) {
          if (options.logSetSignal) {
            options.logSetSignal(signal, wc2.getFr(pVal));
          }
        },
        logStartComponent: function(cIdx) {
          if (options.logStartComponent) {
            options.logStartComponent(cIdx);
          }
        },
        logFinishComponent: function(cIdx) {
          if (options.logFinishComponent) {
            options.logFinishComponent(cIdx);
          }
        }
      }
    });
    if (typeof instance.exports.getVersion == "function") {
      majorVersion = instance.exports.getVersion();
    }
    if (typeof instance.exports.getMinorVersion == "function") {
      minorVersion = instance.exports.getMinorVersion();
    }
    if (typeof instance.exports.getPatchVersion == "function") {
      patchVersion = instance.exports.getPatchVersion();
    }
    const sanityCheck = options && (options.sanityCheck || options.logGetSignal || options.logSetSignal || options.logStartComponent || options.logFinishComponent);
    if (majorVersion === 2) {
      wc2 = new WitnessCalculatorCircom2(instance, sanityCheck);
    } else {
      wc2 = new WitnessCalculatorCircom1(memory, instance, sanityCheck);
    }
    return wc2;
    function getMessage() {
      var message = "";
      var c3 = instance.exports.getMessageChar();
      while (c3 != 0) {
        message += String.fromCharCode(c3);
        c3 = instance.exports.getMessageChar();
      }
      return message;
    }
    function p2str(p6) {
      const i8 = new Uint8Array(memory.buffer);
      const bytes2 = [];
      for (let i4 = 0; i8[p6 + i4] > 0; i4++)
        bytes2.push(i8[p6 + i4]);
      return String.fromCharCode.apply(null, bytes2);
    }
  }
  var WitnessCalculatorCircom1 = class {
    constructor(memory, instance, sanityCheck) {
      this.memory = memory;
      this.i32 = new Uint32Array(memory.buffer);
      this.instance = instance;
      this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;
      const pRawPrime = this.instance.exports.getPRawPrime();
      const arr = new Array(this.n32);
      for (let i4 = 0; i4 < this.n32; i4++) {
        arr[this.n32 - 1 - i4] = this.i32[(pRawPrime >> 2) + i4];
      }
      this.prime = Scalar.fromArray(arr, 4294967296);
      this.Fr = new ZqField(this.prime);
      this.mask32 = Scalar.fromString("FFFFFFFF", 16);
      this.NVars = this.instance.exports.getNVars();
      this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;
      this.R = this.Fr.e(Scalar.shiftLeft(1, this.n64 * 64));
      this.RInv = this.Fr.inv(this.R);
      this.sanityCheck = sanityCheck;
    }
    circom_version() {
      return 1;
    }
    async _doCalculateWitness(input, sanityCheck) {
      this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
      const pSigOffset = this.allocInt();
      const pFr = this.allocFr();
      const keys = Object.keys(input);
      keys.forEach((k5) => {
        const h6 = fnvHash(k5);
        const hMSB = parseInt(h6.slice(0, 8), 16);
        const hLSB = parseInt(h6.slice(8, 16), 16);
        try {
          this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);
        } catch (err) {
          throw new Error(`Signal ${k5} is not an input of the circuit.`);
        }
        const sigOffset = this.getInt(pSigOffset);
        const fArr = flatArray(input[k5]);
        for (let i4 = 0; i4 < fArr.length; i4++) {
          this.setFr(pFr, fArr[i4]);
          this.instance.exports.setSignal(0, 0, sigOffset + i4, pFr);
        }
      });
    }
    async calculateWitness(input, sanityCheck) {
      const self2 = this;
      const old0 = self2.i32[0];
      const w5 = [];
      await self2._doCalculateWitness(input, sanityCheck);
      for (let i4 = 0; i4 < self2.NVars; i4++) {
        const pWitness = self2.instance.exports.getPWitness(i4);
        w5.push(self2.getFr(pWitness));
      }
      self2.i32[0] = old0;
      return w5;
    }
    async calculateBinWitness(input, sanityCheck) {
      const self2 = this;
      const old0 = self2.i32[0];
      await self2._doCalculateWitness(input, sanityCheck);
      const pWitnessBuffer = self2.instance.exports.getWitnessBuffer();
      self2.i32[0] = old0;
      const buff = self2.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + self2.NVars * self2.n64 * 8);
      return new Uint8Array(buff);
    }
    allocInt() {
      const p6 = this.i32[0];
      this.i32[0] = p6 + 8;
      return p6;
    }
    allocFr() {
      const p6 = this.i32[0];
      this.i32[0] = p6 + this.n32 * 4 + 8;
      return p6;
    }
    getInt(p6) {
      return this.i32[p6 >> 2];
    }
    setInt(p6, v6) {
      this.i32[p6 >> 2] = v6;
    }
    getFr(p6) {
      const self2 = this;
      const idx = p6 >> 2;
      if (self2.i32[idx + 1] & 2147483648) {
        const arr = new Array(self2.n32);
        for (let i4 = 0; i4 < self2.n32; i4++) {
          arr[self2.n32 - 1 - i4] = self2.i32[idx + 2 + i4];
        }
        const res = self2.Fr.e(Scalar.fromArray(arr, 4294967296));
        if (self2.i32[idx + 1] & 1073741824) {
          return fromMontgomery(res);
        } else {
          return res;
        }
      } else {
        if (self2.i32[idx] & 2147483648) {
          return self2.Fr.e(self2.i32[idx] - 4294967296);
        } else {
          return self2.Fr.e(self2.i32[idx]);
        }
      }
      function fromMontgomery(n4) {
        return self2.Fr.mul(self2.RInv, n4);
      }
    }
    setFr(p6, v6) {
      const self2 = this;
      v6 = self2.Fr.e(v6);
      const minShort = self2.Fr.neg(self2.Fr.e("80000000", 16));
      const maxShort = self2.Fr.e("7FFFFFFF", 16);
      if (self2.Fr.geq(v6, minShort) && self2.Fr.leq(v6, maxShort)) {
        let a4;
        if (self2.Fr.geq(v6, self2.Fr.zero)) {
          a4 = Scalar.toNumber(v6);
        } else {
          a4 = Scalar.toNumber(self2.Fr.sub(v6, minShort));
          a4 = a4 - 2147483648;
          a4 = 4294967296 + a4;
        }
        self2.i32[p6 >> 2] = a4;
        self2.i32[(p6 >> 2) + 1] = 0;
        return;
      }
      self2.i32[p6 >> 2] = 0;
      self2.i32[(p6 >> 2) + 1] = 2147483648;
      const arr = Scalar.toArray(v6, 4294967296);
      for (let i4 = 0; i4 < self2.n32; i4++) {
        const idx = arr.length - 1 - i4;
        if (idx >= 0) {
          self2.i32[(p6 >> 2) + 2 + i4] = arr[idx];
        } else {
          self2.i32[(p6 >> 2) + 2 + i4] = 0;
        }
      }
    }
  };
  var WitnessCalculatorCircom2 = class {
    constructor(instance, sanityCheck) {
      this.instance = instance;
      this.version = this.instance.exports.getVersion();
      this.n32 = this.instance.exports.getFieldNumLen32();
      this.instance.exports.getRawPrime();
      const arr = new Uint32Array(this.n32);
      for (let i4 = 0; i4 < this.n32; i4++) {
        arr[this.n32 - 1 - i4] = this.instance.exports.readSharedRWMemory(i4);
      }
      this.prime = Scalar.fromArray(arr, 4294967296);
      this.witnessSize = this.instance.exports.getWitnessSize();
      this.sanityCheck = sanityCheck;
    }
    circom_version() {
      return this.instance.exports.getVersion();
    }
    async _doCalculateWitness(input, sanityCheck) {
      this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
      const keys = Object.keys(input);
      var input_counter = 0;
      keys.forEach((k5) => {
        const h6 = fnvHash(k5);
        const hMSB = parseInt(h6.slice(0, 8), 16);
        const hLSB = parseInt(h6.slice(8, 16), 16);
        const fArr = flatArray(input[k5]);
        if (typeof this.instance.exports.getInputSignalSize === "function") {
          let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);
          if (signalSize < 0) {
            throw new Error(`Signal ${k5} not found
`);
          }
          if (fArr.length < signalSize) {
            throw new Error(`Not enough values for input signal ${k5}
`);
          }
          if (fArr.length > signalSize) {
            throw new Error(`Too many values for input signal ${k5}
`);
          }
        }
        for (let i4 = 0; i4 < fArr.length; i4++) {
          const arrFr = toArray32(normalize(fArr[i4], this.prime), this.n32);
          for (let j5 = 0; j5 < this.n32; j5++) {
            this.instance.exports.writeSharedRWMemory(j5, arrFr[this.n32 - 1 - j5]);
          }
          try {
            this.instance.exports.setInputSignal(hMSB, hLSB, i4);
            input_counter++;
          } catch (err) {
            throw new Error(err);
          }
        }
      });
      if (input_counter < this.instance.exports.getInputSize()) {
        throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
      }
    }
    async calculateWitness(input, sanityCheck) {
      const w5 = [];
      await this._doCalculateWitness(input, sanityCheck);
      for (let i4 = 0; i4 < this.witnessSize; i4++) {
        this.instance.exports.getWitness(i4);
        const arr = new Uint32Array(this.n32);
        for (let j5 = 0; j5 < this.n32; j5++) {
          arr[this.n32 - 1 - j5] = this.instance.exports.readSharedRWMemory(j5);
        }
        w5.push(Scalar.fromArray(arr, 4294967296));
      }
      return w5;
    }
    async calculateWTNSBin(input, sanityCheck) {
      const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
      const buff = new Uint8Array(buff32.buffer);
      await this._doCalculateWitness(input, sanityCheck);
      buff[0] = "w".charCodeAt(0);
      buff[1] = "t".charCodeAt(0);
      buff[2] = "n".charCodeAt(0);
      buff[3] = "s".charCodeAt(0);
      buff32[1] = 2;
      buff32[2] = 2;
      buff32[3] = 1;
      const n8 = this.n32 * 4;
      const idSection1length = 8 + n8;
      const idSection1lengthHex = idSection1length.toString(16);
      buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
      buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
      buff32[6] = n8;
      this.instance.exports.getRawPrime();
      var pos = 7;
      for (let j5 = 0; j5 < this.n32; j5++) {
        buff32[pos + j5] = this.instance.exports.readSharedRWMemory(j5);
      }
      pos += this.n32;
      buff32[pos] = this.witnessSize;
      pos++;
      buff32[pos] = 2;
      pos++;
      const idSection2length = n8 * this.witnessSize;
      const idSection2lengthHex = idSection2length.toString(16);
      buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
      buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
      pos += 2;
      for (let i4 = 0; i4 < this.witnessSize; i4++) {
        this.instance.exports.getWitness(i4);
        for (let j5 = 0; j5 < this.n32; j5++) {
          buff32[pos + j5] = this.instance.exports.readSharedRWMemory(j5);
        }
        pos += this.n32;
      }
      return buff;
    }
  };
  var { unstringifyBigInts: unstringifyBigInts$b } = utils;
  async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {
    const input = unstringifyBigInts$b(_input);
    const fdWasm = await readExisting(wasmFileName);
    const wasm2 = await fdWasm.read(fdWasm.totalSize);
    await fdWasm.close();
    const wc2 = await builder(wasm2);
    if (wc2.circom_version() == 1) {
      const w5 = await wc2.calculateBinWitness(input);
      const fdWtns = await createBinFile(wtnsFileName, "wtns", 2, 2);
      await writeBin(fdWtns, w5, wc2.prime);
      await fdWtns.close();
    } else {
      const fdWtns = await createOverride(wtnsFileName);
      const w5 = await wc2.calculateWTNSBin(input);
      await fdWtns.write(w5);
      await fdWtns.close();
    }
  }
  var { unstringifyBigInts: unstringifyBigInts$a } = utils;
  async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {
    const input = unstringifyBigInts$a(_input);
    const wtns = {
      type: "mem"
    };
    await wtnsCalculate(input, wasmFile, wtns);
    return await groth16Prove(zkeyFileName, wtns, logger);
  }
  var { unstringifyBigInts: unstringifyBigInts$9 } = utils;
  async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {
    const vk_verifier = unstringifyBigInts$9(_vk_verifier);
    const proof = unstringifyBigInts$9(_proof);
    const publicSignals = unstringifyBigInts$9(_publicSignals);
    const curve2 = await getCurveFromName2(vk_verifier.curve);
    const IC0 = curve2.G1.fromObject(vk_verifier.IC[0]);
    const IC = new Uint8Array(curve2.G1.F.n8 * 2 * publicSignals.length);
    const w5 = new Uint8Array(curve2.Fr.n8 * publicSignals.length);
    if (!publicInputsAreValid$1(curve2, publicSignals)) {
      if (logger)
        logger.error("Public inputs are not valid.");
      return false;
    }
    for (let i4 = 0; i4 < publicSignals.length; i4++) {
      const buffP = curve2.G1.fromObject(vk_verifier.IC[i4 + 1]);
      IC.set(buffP, i4 * curve2.G1.F.n8 * 2);
      Scalar.toRprLE(w5, curve2.Fr.n8 * i4, publicSignals[i4], curve2.Fr.n8);
    }
    let cpub = await curve2.G1.multiExpAffine(IC, w5);
    cpub = curve2.G1.add(cpub, IC0);
    const pi_a = curve2.G1.fromObject(proof.pi_a);
    const pi_b = curve2.G2.fromObject(proof.pi_b);
    const pi_c = curve2.G1.fromObject(proof.pi_c);
    if (!isWellConstructed$1(curve2, { pi_a, pi_b, pi_c })) {
      if (logger)
        logger.error("Proof commitments are not valid.");
      return false;
    }
    const vk_gamma_2 = curve2.G2.fromObject(vk_verifier.vk_gamma_2);
    const vk_delta_2 = curve2.G2.fromObject(vk_verifier.vk_delta_2);
    const vk_alpha_1 = curve2.G1.fromObject(vk_verifier.vk_alpha_1);
    const vk_beta_2 = curve2.G2.fromObject(vk_verifier.vk_beta_2);
    const res = await curve2.pairingEq(
      curve2.G1.neg(pi_a),
      pi_b,
      cpub,
      vk_gamma_2,
      pi_c,
      vk_delta_2,
      vk_alpha_1,
      vk_beta_2
    );
    if (!res) {
      if (logger)
        logger.error("Invalid proof");
      return false;
    }
    if (logger)
      logger.info("OK!");
    return true;
  }
  function isWellConstructed$1(curve2, proof) {
    const G1 = curve2.G1;
    const G22 = curve2.G2;
    return G1.isValid(proof.pi_a) && G22.isValid(proof.pi_b) && G1.isValid(proof.pi_c);
  }
  function publicInputsAreValid$1(curve2, publicInputs) {
    for (let i4 = 0; i4 < publicInputs.length; i4++) {
      if (!Scalar.lt(publicInputs[i4], curve2.r)) {
        return false;
      }
    }
    return true;
  }
  var { unstringifyBigInts: unstringifyBigInts$8 } = utils;
  function p256$2(n4) {
    let nstr = n4.toString(16);
    while (nstr.length < 64)
      nstr = "0" + nstr;
    nstr = `"0x${nstr}"`;
    return nstr;
  }
  async function groth16ExportSolidityCallData(_proof, _pub) {
    const proof = unstringifyBigInts$8(_proof);
    const pub = unstringifyBigInts$8(_pub);
    let inputs = "";
    for (let i4 = 0; i4 < pub.length; i4++) {
      if (inputs != "")
        inputs = inputs + ",";
      inputs = inputs + p256$2(pub[i4]);
    }
    let S6;
    S6 = `[${p256$2(proof.pi_a[0])}, ${p256$2(proof.pi_a[1])}],[[${p256$2(proof.pi_b[0][1])}, ${p256$2(proof.pi_b[0][0])}],[${p256$2(proof.pi_b[1][1])}, ${p256$2(proof.pi_b[1][0])}]],[${p256$2(proof.pi_c[0])}, ${p256$2(proof.pi_c[1])}],[${inputs}]`;
    return S6;
  }
  var groth16 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    fullProve: groth16FullProve,
    prove: groth16Prove,
    verify: groth16Verify,
    exportSolidityCallData: groth16ExportSolidityCallData
  });
  var bls12381r2 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
  var bn128r2 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
  var { unstringifyBigInts: unstringifyBigInts$7 } = utils;
  var { stringifyBigInts: stringifyBigInts$3 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$6, stringifyBigInts: stringifyBigInts$2 } = utils;
  var sha3 = { exports: {} };
  (function(module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits3, padding2, outputType) {
        return function(message) {
          return new Keccak3(bits3, padding2, bits3).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits3, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak3(bits3, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits3, padding2, outputType) {
        return function(message, outputBits, n4, s3) {
          return methods["cshake" + bits3].update(message, outputBits, n4, s3)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits3, padding2, outputType) {
        return function(key, message, outputBits, s3) {
          return methods["kmac" + bits3].update(key, message, outputBits, s3)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits3, padding2) {
        for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
          var type2 = OUTPUT_TYPES[i5];
          method[type2] = createMethod2(bits3, padding2, type2);
        }
        return method;
      };
      var createMethod = function(bits3, padding2) {
        var method = createOutputMethod(bits3, padding2, "hex");
        method.create = function() {
          return new Keccak3(bits3, padding2, bits3);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits3, padding2);
      };
      var createShakeMethod = function(bits3, padding2) {
        var method = createShakeOutputMethod(bits3, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak3(bits3, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits3, padding2);
      };
      var createCshakeMethod = function(bits3, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits3];
        var method = createCshakeOutputMethod(bits3, padding2, "hex");
        method.create = function(outputBits, n4, s3) {
          if (!n4 && !s3) {
            return methods["shake" + bits3].create(outputBits);
          } else {
            return new Keccak3(bits3, padding2, outputBits).bytepad([n4, s3], w5);
          }
        };
        method.update = function(message, outputBits, n4, s3) {
          return method.create(outputBits, n4, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits3, padding2);
      };
      var createKmacMethod = function(bits3, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits3];
        var method = createKmacOutputMethod(bits3, padding2, "hex");
        method.create = function(key, outputBits, s3) {
          return new Kmac(bits3, padding2, outputBits).bytepad(["KMAC", s3], w5).bytepad([key], w5);
        };
        method.update = function(key, message, outputBits, s3) {
          return method.create(key, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits3, padding2);
      };
      var algorithms2 = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i4 = 0; i4 < algorithms2.length; ++i4) {
        var algorithm = algorithms2[i4];
        var bits2 = algorithm.bits;
        for (var j5 = 0; j5 < bits2.length; ++j5) {
          var methodName = algorithm.name + "_" + bits2[j5];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits2[j5], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits2[j5];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak3(bits3, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits3 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i5 = 0; i5 < 50; ++i5) {
          this.s[i5] = 0;
        }
      }
      Keccak3.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type2 = typeof message;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i5, code2;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          if (notString) {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              blocks[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
            }
          } else {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              code2 = message.charCodeAt(index);
              if (code2 < 128) {
                blocks[i5 >> 2] |= code2 << SHIFT[i5++ & 3];
              } else if (code2 < 2048) {
                blocks[i5 >> 2] |= (192 | code2 >> 6) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i5 >> 2] |= (224 | code2 >> 12) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i5 >> 2] |= (240 | code2 >> 18) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              }
            }
          }
          this.lastByteIndex = i5;
          if (i5 >= byteCount) {
            this.start = i5 - byteCount;
            this.block = blocks[blockCount];
            for (i5 = 0; i5 < blockCount; ++i5) {
              s3[i5] ^= blocks[i5];
            }
            f5(s3);
            this.reset = true;
          } else {
            this.start = i5;
          }
        }
        return this;
      };
      Keccak3.prototype.encode = function(x6, right) {
        var o4 = x6 & 255, n4 = 1;
        var bytes2 = [o4];
        x6 = x6 >> 8;
        o4 = x6 & 255;
        while (o4 > 0) {
          bytes2.unshift(o4);
          x6 = x6 >> 8;
          o4 = x6 & 255;
          ++n4;
        }
        if (right) {
          bytes2.push(n4);
        } else {
          bytes2.unshift(n4);
        }
        this.update(bytes2);
        return bytes2.length;
      };
      Keccak3.prototype.encodeString = function(str) {
        var notString, type2 = typeof str;
        if (type2 !== "string") {
          if (type2 === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes2 = 0, length2 = str.length;
        if (notString) {
          bytes2 = length2;
        } else {
          for (var i5 = 0; i5 < str.length; ++i5) {
            var code2 = str.charCodeAt(i5);
            if (code2 < 128) {
              bytes2 += 1;
            } else if (code2 < 2048) {
              bytes2 += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes2 += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i5) & 1023);
              bytes2 += 4;
            }
          }
        }
        bytes2 += this.encode(bytes2 * 8);
        this.update(str);
        return bytes2;
      };
      Keccak3.prototype.bytepad = function(strs, w5) {
        var bytes2 = this.encode(w5);
        for (var i5 = 0; i5 < strs.length; ++i5) {
          bytes2 += this.encodeString(strs[i5]);
        }
        var paddingBytes = w5 - bytes2 % w5;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak3.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i5 >> 2] |= this.padding[i5 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i5 = 1; i5 < blockCount + 1; ++i5) {
            blocks[i5] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i5 = 0; i5 < blockCount; ++i5) {
          s3[i5] ^= blocks[i5];
        }
        f5(s3);
      };
      Keccak3.prototype.toString = Keccak3.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var hex2 = "", block;
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            block = s3[i5];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j6 % blockCount === 0) {
            f5(s3);
            i5 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i5];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex2;
      };
      Keccak3.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var bytes2 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes2);
        }
        var array = new Uint32Array(buffer);
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            array[j6] = s3[i5];
          }
          if (j6 % blockCount === 0) {
            f5(s3);
          }
        }
        if (extraBytes) {
          array[i5] = s3[i5];
          buffer = buffer.slice(0, bytes2);
        }
        return buffer;
      };
      Keccak3.prototype.buffer = Keccak3.prototype.arrayBuffer;
      Keccak3.prototype.digest = Keccak3.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var array = [], offset, block;
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            offset = j6 << 2;
            block = s3[i5];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j6 % blockCount === 0) {
            f5(s3);
          }
        }
        if (extraBytes) {
          offset = j6 << 2;
          block = s3[i5];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits3, padding2, outputBits) {
        Keccak3.call(this, bits3, padding2, outputBits);
      }
      Kmac.prototype = new Keccak3();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak3.prototype.finalize.call(this);
      };
      var f5 = function(s3) {
        var h6, l6, n4, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b32, b42, b52, b62, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
        for (n4 = 0; n4 < 48; n4 += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h6 = c8 ^ (c22 << 1 | c3 >>> 31);
          l6 = c9 ^ (c3 << 1 | c22 >>> 31);
          s3[0] ^= h6;
          s3[1] ^= l6;
          s3[10] ^= h6;
          s3[11] ^= l6;
          s3[20] ^= h6;
          s3[21] ^= l6;
          s3[30] ^= h6;
          s3[31] ^= l6;
          s3[40] ^= h6;
          s3[41] ^= l6;
          h6 = c0 ^ (c4 << 1 | c5 >>> 31);
          l6 = c1 ^ (c5 << 1 | c4 >>> 31);
          s3[2] ^= h6;
          s3[3] ^= l6;
          s3[12] ^= h6;
          s3[13] ^= l6;
          s3[22] ^= h6;
          s3[23] ^= l6;
          s3[32] ^= h6;
          s3[33] ^= l6;
          s3[42] ^= h6;
          s3[43] ^= l6;
          h6 = c22 ^ (c6 << 1 | c7 >>> 31);
          l6 = c3 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h6;
          s3[5] ^= l6;
          s3[14] ^= h6;
          s3[15] ^= l6;
          s3[24] ^= h6;
          s3[25] ^= l6;
          s3[34] ^= h6;
          s3[35] ^= l6;
          s3[44] ^= h6;
          s3[45] ^= l6;
          h6 = c4 ^ (c8 << 1 | c9 >>> 31);
          l6 = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h6;
          s3[7] ^= l6;
          s3[16] ^= h6;
          s3[17] ^= l6;
          s3[26] ^= h6;
          s3[27] ^= l6;
          s3[36] ^= h6;
          s3[37] ^= l6;
          s3[46] ^= h6;
          s3[47] ^= l6;
          h6 = c6 ^ (c0 << 1 | c1 >>> 31);
          l6 = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h6;
          s3[9] ^= l6;
          s3[18] ^= h6;
          s3[19] ^= l6;
          s3[28] ^= h6;
          s3[29] ^= l6;
          s3[38] ^= h6;
          s3[39] ^= l6;
          s3[48] ^= h6;
          s3[49] ^= l6;
          b0 = s3[0];
          b1 = s3[1];
          b322 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b22 = s3[13] << 12 | s3[12] >>> 20;
          b32 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b222 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b42 = s3[25] << 11 | s3[24] >>> 21;
          b52 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b422 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b62 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b22 & b42;
          s3[1] = b1 ^ ~b32 & b52;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b222 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b322 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b422 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b22 ^ ~b42 & b62;
          s3[3] = b32 ^ ~b52 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b222 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b322 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b422 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b42 ^ ~b62 & b8;
          s3[5] = b52 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b62 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b22;
          s3[9] = b9 ^ ~b1 & b32;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b222;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b322;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b422;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n4];
          s3[1] ^= RC[n4 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i4 = 0; i4 < methodNames.length; ++i4) {
          root[methodNames[i4]] = methods[methodNames[i4]];
        }
      }
    })();
  })(sha3);
  var jsSha3 = sha3.exports;
  var { keccak256 } = jsSha3;
  var { stringifyBigInts: stringifyBigInts$1 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$5 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$4 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$3 } = utils;
  var { stringifyBigInts: stringifyBigInts2 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$2 } = utils;
  var { unstringifyBigInts: unstringifyBigInts$1 } = utils;
  var { unstringifyBigInts: unstringifyBigInts2 } = utils;

  // node_modules/@iden3/js-jwz/dist/browser/esm/index.js
  var l5 = class {
    constructor(t, e7) {
      this.alg = t, this.circuitId = e7;
    }
    toString() {
      return `${this.alg}:${this.circuitId}`;
    }
  };
  var d4 = /* @__PURE__ */ new Map();
  function u3(t, e7) {
    return new Promise((r) => {
      d4.set(t.toString(), e7), r();
    });
  }
  function g4(t) {
    return new Promise((e7, r) => {
      const n4 = d4.get(t.toString());
      if (n4) {
        e7(n4());
      } else
        r("unknown alg");
    });
  }
  var p5;
  !function(t) {
    t.Type = "typ", t.Alg = "alg", t.CircuitId = "circuitId", t.Critical = "crit";
  }(p5 || (p5 = {}));
  async function S5(t, e7) {
    let r;
    e7 = e7 || {};
    try {
      r = await WebAssembly.compile(t);
    } catch (t2) {
      throw console.log(t2), console.log("\nTry to run circom --c in order to generate c++ code instead\n"), new Error(t2);
    }
    let n4 = "", i4 = "";
    const s3 = await WebAssembly.instantiate(r, { runtime: { exceptionHandler: function(t2) {
      let e8;
      throw e8 = 1 == t2 ? "Signal not found.\n" : 2 == t2 ? "Too many signals set.\n" : 3 == t2 ? "Signal already set.\n" : 4 == t2 ? "Assert Failed.\n" : 5 == t2 ? "Not enough memory.\n" : 6 == t2 ? "Input signal array access exceeds the size.\n" : "Unknown error.\n", new Error(e8 + n4);
    }, printErrorMessage: function() {
      n4 += o4() + "\n";
    }, writeBufferMessage: function() {
      const t2 = o4();
      "\n" === t2 ? (console.log(i4), i4 = "") : ("" !== i4 && (i4 += " "), i4 += t2);
    }, showSharedRWMemory: function() {
      !function() {
        const t2 = s3.exports.getFieldNumLen32(), e8 = new Uint32Array(t2);
        for (let r2 = 0; r2 < t2; r2++)
          e8[t2 - 1 - r2] = s3.exports.readSharedRWMemory(r2);
        "" !== i4 && (i4 += " ");
        i4 += z5(e8).toString();
      }();
    } } });
    return new x5(s3, e7);
    function o4() {
      let t2 = "", e8 = s3.exports.getMessageChar();
      for (; 0 != e8; )
        t2 += String.fromCharCode(e8), e8 = s3.exports.getMessageChar();
      return t2;
    }
  }
  var x5 = class {
    constructor(t, e7) {
      this.instance = t, this.instance = t, this.version = this.instance.exports.getVersion(), this.n32 = this.instance.exports.getFieldNumLen32(), this.instance.exports.getRawPrime();
      const r = new Uint32Array(this.n32);
      for (let t2 = 0; t2 < this.n32; t2++)
        r[this.n32 - 1 - t2] = this.instance.exports.readSharedRWMemory(t2);
      this.prime = z5(r), this.witnessSize = this.instance.exports.getWitnessSize(), this.sanityCheck = e7;
    }
    circom_version() {
      return this.instance.exports.getVersion();
    }
    async _doCalculateWitness(t, e7) {
      this.instance.exports.init(this.sanityCheck || e7 ? 1 : 0);
      const r = Object.keys(t);
      let n4 = 0;
      if (r.forEach((e8) => {
        const r2 = function(t2) {
          const e9 = BigInt(2) ** BigInt(64);
          let r3 = BigInt("0xCBF29CE484222325");
          for (let n6 = 0; n6 < t2.length; n6++)
            r3 ^= BigInt(t2[n6].charCodeAt()), r3 *= BigInt(1099511628211), r3 %= e9;
          let n5 = r3.toString(16);
          const i5 = 16 - n5.length;
          return n5 = "0".repeat(i5).concat(n5), n5;
        }(e8), i4 = parseInt(r2.slice(0, 8), 16), s3 = parseInt(r2.slice(8, 16), 16), o4 = function(t2) {
          const e9 = [];
          return r3(e9, t2), e9;
          function r3(t3, e10) {
            if (Array.isArray(e10))
              for (let n5 = 0; n5 < e10.length; n5++)
                r3(t3, e10[n5]);
            else
              t3.push(e10);
          }
        }(t[e8]), a4 = this.instance.exports.getInputSignalSize(i4, s3);
        if (a4 < 0)
          throw new Error(`Signal ${e8} not found
`);
        if (o4.length < a4)
          throw new Error(`Not enough values for input signal ${e8}
`);
        if (o4.length > a4)
          throw new Error(`Too many values for input signal ${e8}
`);
        for (let t2 = 0; t2 < o4.length; t2++) {
          const e9 = v5(BigInt(o4[t2]) % this.prime, this.n32);
          for (let t3 = 0; t3 < this.n32; t3++)
            this.instance.exports.writeSharedRWMemory(t3, e9[this.n32 - 1 - t3]);
          try {
            this.instance.exports.setInputSignal(i4, s3, t2), n4++;
          } catch (t3) {
            throw new Error(t3);
          }
        }
      }), n4 < this.instance.exports.getInputSize())
        throw new Error(`Not all inputs have been set. Only ${n4} out of ${this.instance.exports.getInputSize()}`);
    }
    async calculateWitness(t, e7) {
      const r = [];
      await this._doCalculateWitness(t, e7);
      for (let t2 = 0; t2 < this.witnessSize; t2++) {
        this.instance.exports.getWitness(t2);
        const e8 = new Uint32Array(this.n32);
        for (let t3 = 0; t3 < this.n32; t3++)
          e8[this.n32 - 1 - t3] = this.instance.exports.readSharedRWMemory(t3);
        r.push(z5(e8));
      }
      return r;
    }
    async calculateBinWitness(t, e7) {
      const r = new Uint32Array(this.witnessSize * this.n32), n4 = new Uint8Array(r.buffer);
      await this._doCalculateWitness(t, e7);
      for (let t2 = 0; t2 < this.witnessSize; t2++) {
        this.instance.exports.getWitness(t2);
        const e8 = t2 * this.n32;
        for (let t3 = 0; t3 < this.n32; t3++)
          r[e8 + t3] = this.instance.exports.readSharedRWMemory(t3);
      }
      return n4;
    }
    async calculateWTNSBin(t, e7) {
      const r = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11), n4 = new Uint8Array(r.buffer);
      await this._doCalculateWitness(t, e7), n4[0] = "w".charCodeAt(0), n4[1] = "t".charCodeAt(0), n4[2] = "n".charCodeAt(0), n4[3] = "s".charCodeAt(0), r[1] = 2, r[2] = 2, r[3] = 1;
      const i4 = 4 * this.n32, s3 = (8 + i4).toString(16);
      r[4] = parseInt(s3.slice(0, 8), 16), r[5] = parseInt(s3.slice(8, 16), 16), r[6] = i4, this.instance.exports.getRawPrime();
      let o4 = 7;
      for (let t2 = 0; t2 < this.n32; t2++)
        r[o4 + t2] = this.instance.exports.readSharedRWMemory(t2);
      o4 += this.n32, r[o4] = this.witnessSize, o4++, r[o4] = 2, o4++;
      const a4 = (i4 * this.witnessSize).toString(16);
      r[o4] = parseInt(a4.slice(0, 8), 16), r[o4 + 1] = parseInt(a4.slice(8, 16), 16), o4 += 2;
      for (let t2 = 0; t2 < this.witnessSize; t2++) {
        this.instance.exports.getWitness(t2);
        for (let t3 = 0; t3 < this.n32; t3++)
          r[o4 + t3] = this.instance.exports.readSharedRWMemory(t3);
        o4 += this.n32;
      }
      return n4;
    }
  };
  function v5(t, e7) {
    const r = [], n4 = BigInt(4294967296);
    for (; t; )
      r.unshift(Number(t % n4)), t /= n4;
    if (e7) {
      let t2 = e7 - r.length;
      for (; t2 > 0; )
        r.unshift(0), t2--;
    }
    return r;
  }
  function z5(t) {
    let e7 = BigInt(0);
    const r = BigInt(4294967296);
    for (let n4 = 0; n4 < t.length; n4++)
      e7 = e7 * r + BigInt(t[n4]);
    return e7;
  }
  var b5 = "groth16";
  var A4 = new TextDecoder();
  async function C4(t, e7, r) {
    const n4 = await S5(r), i4 = new TextDecoder().decode(t), o4 = JSON.parse(i4), a4 = await n4.calculateWTNSBin(o4, 0), { proof: c3, publicSignals: h6 } = await groth16.prove(e7, a4);
    return { proof: c3, pub_signals: h6 };
  }
  async function E3(e7, r, n4, i4) {
    if (i4(r.pub_signals).challenge !== E(e7))
      throw new Error("challenge is not equal to message hash");
    return await groth16.verify(JSON.parse(A4.decode(n4)), r.pub_signals, r.proof);
  }
  var W4 = new class {
    constructor(t) {
      this.methodAlg = t;
    }
    get alg() {
      return this.methodAlg.alg;
    }
    get circuitId() {
      return this.methodAlg.circuitId;
    }
    unmarshall(t) {
      const e7 = {};
      if (3 != t.length)
        throw new Error(`invalid number of Output values expected 3 got ${t.length}`);
      return e7.challenge = BigInt(t[0]), e7.userState = BigInt(t[1]), e7.userId = $2.fromBigInt(BigInt(t[2])), e7;
    }
    async verify(t, e7, r) {
      return E3(t, e7, r, this.unmarshall);
    }
    prove(t, e7, r) {
      return C4(t, e7, r);
    }
  }(new l5(b5, "auth"));
  var B5 = class {
    constructor(t) {
      this.methodAlg = t;
    }
    get alg() {
      return this.methodAlg.alg;
    }
    get circuitId() {
      return this.methodAlg.circuitId;
    }
    async verify(t, e7, r) {
      const n4 = await E3(t, e7, r, this.unmarshall);
      return await this.terminateCurve(), n4;
    }
    async prove(t, e7, r) {
      const n4 = await C4(t, e7, r);
      return await this.terminateCurve(), n4;
    }
    async terminateCurve() {
      (await getCurveFromName(B5.curveName)).terminate();
    }
    unmarshall(t) {
      if (3 !== t.length)
        throw new Error(`invalid number of Output values expected 3 got ${t.length}`);
      return { userID: $2.fromBigInt(BigInt(t[0])), challenge: BigInt(t[1]), GISTRoot: V3.fromString(t[2]) };
    }
  };
  B5.curveName = "bn128";
  var M5 = new B5(new l5(b5, "authV2"));
  u3(W4.methodAlg, () => W4), u3(M5.methodAlg, () => M5);
  var T5 = { registerProvingMethod: u3, getProvingMethod: g4, provingMethodGroth16AuthInstance: W4, provingMethodGroth16AuthV2Instance: M5 };

  // node_modules/@0xpolygonid/js-sdk/dist/browser/esm/index.js
  var KmsKeyType;
  (function(KmsKeyType2) {
    KmsKeyType2["BabyJubJub"] = "BJJ";
    KmsKeyType2["Secp256k1"] = "Secp256k1";
    KmsKeyType2["Ed25519"] = "Ed25519";
  })(KmsKeyType || (KmsKeyType = {}));
  var LocalStoragePrivateKeyStore = class {
    list() {
      const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);
      if (!dataStr) {
        throw new Error("no key under given alias");
      }
      const data = JSON.parse(dataStr);
      return data.map((i4) => ({ alias: i4.id, key: i4.value }));
    }
    async get(args) {
      const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);
      if (!dataStr) {
        throw new Error("no key under given alias");
      }
      const data = JSON.parse(dataStr);
      const privateKey = data.find((d5) => d5.id === args.alias);
      if (!privateKey) {
        throw new Error("no key under given alias");
      }
      return privateKey.value;
    }
    async importKey(args) {
      const dataStr = localStorage.getItem(LocalStoragePrivateKeyStore.storageKey);
      let data = [];
      if (dataStr) {
        data = JSON.parse(dataStr);
      }
      const index = data.findIndex((d5) => d5.id === args.alias);
      if (index > -1) {
        data[index].value = args.key;
      } else {
        data.push({ id: args.alias, value: args.key });
      }
      localStorage.setItem(LocalStoragePrivateKeyStore.storageKey, JSON.stringify(data));
    }
  };
  LocalStoragePrivateKeyStore.storageKey = "keystore";
  function promisifyRequest(request) {
    return new Promise((resolve2, reject) => {
      request.oncomplete = request.onsuccess = () => resolve2(request.result);
      request.onabort = request.onerror = () => reject(request.error);
    });
  }
  function createStore(dbName, storeName) {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    const dbp = promisifyRequest(request);
    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
  }
  var defaultGetStoreFunc;
  function defaultGetStore() {
    if (!defaultGetStoreFunc) {
      defaultGetStoreFunc = createStore("keyval-store", "keyval");
    }
    return defaultGetStoreFunc;
  }
  function get$1(key, customStore = defaultGetStore()) {
    return customStore("readonly", (store) => promisifyRequest(store.get(key)));
  }
  function set(key, value, customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.put(value, key);
      return promisifyRequest(store.transaction);
    });
  }
  function del$1(key, customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.delete(key);
      return promisifyRequest(store.transaction);
    });
  }
  function eachCursor(store, callback) {
    store.openCursor().onsuccess = function() {
      if (!this.result)
        return;
      callback(this.result);
      this.result.continue();
    };
    return promisifyRequest(store.transaction);
  }
  function entries(customStore = defaultGetStore()) {
    return customStore("readonly", (store) => {
      if (store.getAll && store.getAllKeys) {
        return Promise.all([
          promisifyRequest(store.getAllKeys()),
          promisifyRequest(store.getAll())
        ]).then(([keys, values]) => keys.map((key, i4) => [key, values[i4]]));
      }
      const items2 = [];
      return customStore("readonly", (store2) => eachCursor(store2, (cursor) => items2.push([cursor.key, cursor.value])).then(() => items2));
    });
  }
  var IndexedDBPrivateKeyStore = class {
    constructor() {
      this._store = createStore(`${IndexedDBPrivateKeyStore.storageKey}-db`, IndexedDBPrivateKeyStore.storageKey);
    }
    async list() {
      const allEntries = await entries(this._store);
      return allEntries.map(([alias, key]) => ({ alias, key: key.value }));
    }
    async get(args) {
      const key = await get$1(args.alias, this._store);
      if (!key) {
        throw new Error("no key under given alias");
      }
      return key.value;
    }
    async importKey(args) {
      await set(args.alias, { value: args.key }, this._store);
    }
  };
  IndexedDBPrivateKeyStore.storageKey = "keystore";
  var byteEncoder = new TextEncoder();
  var byteDecoder = new TextDecoder();
  function hexToBytes$3(s3) {
    const input = s3.startsWith("0x") ? s3.substring(2) : s3;
    return b.decodeString(input.toLowerCase());
  }
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x6) {
    return x6 && x6.__esModule && Object.prototype.hasOwnProperty.call(x6, "default") ? x6["default"] : x6;
  }
  function getAugmentedNamespace(n4) {
    if (n4.__esModule)
      return n4;
    var f5 = n4.default;
    if (typeof f5 == "function") {
      var a4 = function a5() {
        if (this instanceof a5) {
          return Reflect.construct(f5, arguments, this.constructor);
        }
        return f5.apply(this, arguments);
      };
      a4.prototype = f5.prototype;
    } else
      a4 = {};
    Object.defineProperty(a4, "__esModule", { value: true });
    Object.keys(n4).forEach(function(k5) {
      var d5 = Object.getOwnPropertyDescriptor(n4, k5);
      Object.defineProperty(a4, k5, d5.get ? d5 : {
        enumerable: true,
        get: function() {
          return n4[k5];
        }
      });
    });
    return a4;
  }
  var sha32 = { exports: {} };
  (function(module) {
    (function() {
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = commonjsGlobal2;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      var isArray = root.JS_SHA3_NO_NODE_JS || !Array.isArray ? function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      } : Array.isArray;
      var isView = ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) ? function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      } : ArrayBuffer.isView;
      var formatMessage = function(message) {
        var type2 = typeof message;
        if (type2 === "string") {
          return [message, true];
        }
        if (type2 !== "object" || message === null) {
          throw new Error(INPUT_ERROR);
        }
        if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          return [new Uint8Array(message), false];
        }
        if (!isArray(message) && !isView(message)) {
          throw new Error(INPUT_ERROR);
        }
        return [message, false];
      };
      var empty2 = function(message) {
        return formatMessage(message)[0].length === 0;
      };
      var cloneArray = function(array) {
        var newArray = [];
        for (var i5 = 0; i5 < array.length; ++i5) {
          newArray[i5] = array[i5];
        }
        return newArray;
      };
      var createOutputMethod = function(bits3, padding2, outputType) {
        return function(message) {
          return new Keccak3(bits3, padding2, bits3).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits3, padding2, outputType) {
        return function(message, outputBits) {
          return new Keccak3(bits3, padding2, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits3, padding2, outputType) {
        return function(message, outputBits, n4, s3) {
          return methods["cshake" + bits3].update(message, outputBits, n4, s3)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits3, padding2, outputType) {
        return function(key, message, outputBits, s3) {
          return methods["kmac" + bits3].update(key, message, outputBits, s3)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits3, padding2) {
        for (var i5 = 0; i5 < OUTPUT_TYPES.length; ++i5) {
          var type2 = OUTPUT_TYPES[i5];
          method[type2] = createMethod2(bits3, padding2, type2);
        }
        return method;
      };
      var createMethod = function(bits3, padding2) {
        var method = createOutputMethod(bits3, padding2, "hex");
        method.create = function() {
          return new Keccak3(bits3, padding2, bits3);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits3, padding2);
      };
      var createShakeMethod = function(bits3, padding2) {
        var method = createShakeOutputMethod(bits3, padding2, "hex");
        method.create = function(outputBits) {
          return new Keccak3(bits3, padding2, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits3, padding2);
      };
      var createCshakeMethod = function(bits3, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits3];
        var method = createCshakeOutputMethod(bits3, padding2, "hex");
        method.create = function(outputBits, n4, s3) {
          if (empty2(n4) && empty2(s3)) {
            return methods["shake" + bits3].create(outputBits);
          } else {
            return new Keccak3(bits3, padding2, outputBits).bytepad([n4, s3], w5);
          }
        };
        method.update = function(message, outputBits, n4, s3) {
          return method.create(outputBits, n4, s3).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits3, padding2);
      };
      var createKmacMethod = function(bits3, padding2) {
        var w5 = CSHAKE_BYTEPAD[bits3];
        var method = createKmacOutputMethod(bits3, padding2, "hex");
        method.create = function(key, outputBits, s3) {
          return new Kmac(bits3, padding2, outputBits).bytepad(["KMAC", s3], w5).bytepad([key], w5);
        };
        method.update = function(key, message, outputBits, s3) {
          return method.create(key, outputBits, s3).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits3, padding2);
      };
      var algorithms2 = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i4 = 0; i4 < algorithms2.length; ++i4) {
        var algorithm = algorithms2[i4];
        var bits2 = algorithm.bits;
        for (var j5 = 0; j5 < bits2.length; ++j5) {
          var methodName = algorithm.name + "_" + bits2[j5];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits2[j5], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits2[j5];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak3(bits3, padding2, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding2;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits3 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i5 = 0; i5 < 50; ++i5) {
          this.s[i5] = 0;
        }
      }
      Keccak3.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var result = formatMessage(message);
        message = result[0];
        var isString = result[1];
        var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s3 = this.s, i5, code2;
        while (index < length2) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i5 = 1; i5 < blockCount + 1; ++i5) {
              blocks[i5] = 0;
            }
          }
          if (isString) {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              code2 = message.charCodeAt(index);
              if (code2 < 128) {
                blocks[i5 >> 2] |= code2 << SHIFT[i5++ & 3];
              } else if (code2 < 2048) {
                blocks[i5 >> 2] |= (192 | code2 >> 6) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else if (code2 < 55296 || code2 >= 57344) {
                blocks[i5 >> 2] |= (224 | code2 >> 12) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i5 >> 2] |= (240 | code2 >> 18) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i5++ & 3];
                blocks[i5 >> 2] |= (128 | code2 & 63) << SHIFT[i5++ & 3];
              }
            }
          } else {
            for (i5 = this.start; index < length2 && i5 < byteCount; ++index) {
              blocks[i5 >> 2] |= message[index] << SHIFT[i5++ & 3];
            }
          }
          this.lastByteIndex = i5;
          if (i5 >= byteCount) {
            this.start = i5 - byteCount;
            this.block = blocks[blockCount];
            for (i5 = 0; i5 < blockCount; ++i5) {
              s3[i5] ^= blocks[i5];
            }
            f5(s3);
            this.reset = true;
          } else {
            this.start = i5;
          }
        }
        return this;
      };
      Keccak3.prototype.encode = function(x6, right) {
        var o4 = x6 & 255, n4 = 1;
        var bytes2 = [o4];
        x6 = x6 >> 8;
        o4 = x6 & 255;
        while (o4 > 0) {
          bytes2.unshift(o4);
          x6 = x6 >> 8;
          o4 = x6 & 255;
          ++n4;
        }
        if (right) {
          bytes2.push(n4);
        } else {
          bytes2.unshift(n4);
        }
        this.update(bytes2);
        return bytes2.length;
      };
      Keccak3.prototype.encodeString = function(str) {
        var result = formatMessage(str);
        str = result[0];
        var isString = result[1];
        var bytes2 = 0, length2 = str.length;
        if (isString) {
          for (var i5 = 0; i5 < str.length; ++i5) {
            var code2 = str.charCodeAt(i5);
            if (code2 < 128) {
              bytes2 += 1;
            } else if (code2 < 2048) {
              bytes2 += 2;
            } else if (code2 < 55296 || code2 >= 57344) {
              bytes2 += 3;
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i5) & 1023);
              bytes2 += 4;
            }
          }
        } else {
          bytes2 = length2;
        }
        bytes2 += this.encode(bytes2 * 8);
        this.update(str);
        return bytes2;
      };
      Keccak3.prototype.bytepad = function(strs, w5) {
        var bytes2 = this.encode(w5);
        for (var i5 = 0; i5 < strs.length; ++i5) {
          bytes2 += this.encodeString(strs[i5]);
        }
        var paddingBytes = (w5 - bytes2 % w5) % w5;
        var zeros2 = [];
        zeros2.length = paddingBytes;
        this.update(zeros2);
        return this;
      };
      Keccak3.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i5 = this.lastByteIndex, blockCount = this.blockCount, s3 = this.s;
        blocks[i5 >> 2] |= this.padding[i5 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i5 = 1; i5 < blockCount + 1; ++i5) {
            blocks[i5] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i5 = 0; i5 < blockCount; ++i5) {
          s3[i5] ^= blocks[i5];
        }
        f5(s3);
      };
      Keccak3.prototype.toString = Keccak3.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var hex2 = "", block;
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            block = s3[i5];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j6 % blockCount === 0) {
            s3 = cloneArray(s3);
            f5(s3);
            i5 = 0;
          }
        }
        if (extraBytes) {
          block = s3[i5];
          hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex2;
      };
      Keccak3.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var bytes2 = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes2);
        }
        var array = new Uint32Array(buffer);
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            array[j6] = s3[i5];
          }
          if (j6 % blockCount === 0) {
            s3 = cloneArray(s3);
            f5(s3);
          }
        }
        if (extraBytes) {
          array[j6] = s3[i5];
          buffer = buffer.slice(0, bytes2);
        }
        return buffer;
      };
      Keccak3.prototype.buffer = Keccak3.prototype.arrayBuffer;
      Keccak3.prototype.digest = Keccak3.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s3 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i5 = 0, j6 = 0;
        var array = [], offset, block;
        while (j6 < outputBlocks) {
          for (i5 = 0; i5 < blockCount && j6 < outputBlocks; ++i5, ++j6) {
            offset = j6 << 2;
            block = s3[i5];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j6 % blockCount === 0) {
            s3 = cloneArray(s3);
            f5(s3);
          }
        }
        if (extraBytes) {
          offset = j6 << 2;
          block = s3[i5];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits3, padding2, outputBits) {
        Keccak3.call(this, bits3, padding2, outputBits);
      }
      Kmac.prototype = new Keccak3();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak3.prototype.finalize.call(this);
      };
      var f5 = function(s3) {
        var h6, l6, n4, c0, c1, c22, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b32, b42, b52, b62, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
        for (n4 = 0; n4 < 48; n4 += 2) {
          c0 = s3[0] ^ s3[10] ^ s3[20] ^ s3[30] ^ s3[40];
          c1 = s3[1] ^ s3[11] ^ s3[21] ^ s3[31] ^ s3[41];
          c22 = s3[2] ^ s3[12] ^ s3[22] ^ s3[32] ^ s3[42];
          c3 = s3[3] ^ s3[13] ^ s3[23] ^ s3[33] ^ s3[43];
          c4 = s3[4] ^ s3[14] ^ s3[24] ^ s3[34] ^ s3[44];
          c5 = s3[5] ^ s3[15] ^ s3[25] ^ s3[35] ^ s3[45];
          c6 = s3[6] ^ s3[16] ^ s3[26] ^ s3[36] ^ s3[46];
          c7 = s3[7] ^ s3[17] ^ s3[27] ^ s3[37] ^ s3[47];
          c8 = s3[8] ^ s3[18] ^ s3[28] ^ s3[38] ^ s3[48];
          c9 = s3[9] ^ s3[19] ^ s3[29] ^ s3[39] ^ s3[49];
          h6 = c8 ^ (c22 << 1 | c3 >>> 31);
          l6 = c9 ^ (c3 << 1 | c22 >>> 31);
          s3[0] ^= h6;
          s3[1] ^= l6;
          s3[10] ^= h6;
          s3[11] ^= l6;
          s3[20] ^= h6;
          s3[21] ^= l6;
          s3[30] ^= h6;
          s3[31] ^= l6;
          s3[40] ^= h6;
          s3[41] ^= l6;
          h6 = c0 ^ (c4 << 1 | c5 >>> 31);
          l6 = c1 ^ (c5 << 1 | c4 >>> 31);
          s3[2] ^= h6;
          s3[3] ^= l6;
          s3[12] ^= h6;
          s3[13] ^= l6;
          s3[22] ^= h6;
          s3[23] ^= l6;
          s3[32] ^= h6;
          s3[33] ^= l6;
          s3[42] ^= h6;
          s3[43] ^= l6;
          h6 = c22 ^ (c6 << 1 | c7 >>> 31);
          l6 = c3 ^ (c7 << 1 | c6 >>> 31);
          s3[4] ^= h6;
          s3[5] ^= l6;
          s3[14] ^= h6;
          s3[15] ^= l6;
          s3[24] ^= h6;
          s3[25] ^= l6;
          s3[34] ^= h6;
          s3[35] ^= l6;
          s3[44] ^= h6;
          s3[45] ^= l6;
          h6 = c4 ^ (c8 << 1 | c9 >>> 31);
          l6 = c5 ^ (c9 << 1 | c8 >>> 31);
          s3[6] ^= h6;
          s3[7] ^= l6;
          s3[16] ^= h6;
          s3[17] ^= l6;
          s3[26] ^= h6;
          s3[27] ^= l6;
          s3[36] ^= h6;
          s3[37] ^= l6;
          s3[46] ^= h6;
          s3[47] ^= l6;
          h6 = c6 ^ (c0 << 1 | c1 >>> 31);
          l6 = c7 ^ (c1 << 1 | c0 >>> 31);
          s3[8] ^= h6;
          s3[9] ^= l6;
          s3[18] ^= h6;
          s3[19] ^= l6;
          s3[28] ^= h6;
          s3[29] ^= l6;
          s3[38] ^= h6;
          s3[39] ^= l6;
          s3[48] ^= h6;
          s3[49] ^= l6;
          b0 = s3[0];
          b1 = s3[1];
          b322 = s3[11] << 4 | s3[10] >>> 28;
          b33 = s3[10] << 4 | s3[11] >>> 28;
          b14 = s3[20] << 3 | s3[21] >>> 29;
          b15 = s3[21] << 3 | s3[20] >>> 29;
          b46 = s3[31] << 9 | s3[30] >>> 23;
          b47 = s3[30] << 9 | s3[31] >>> 23;
          b28 = s3[40] << 18 | s3[41] >>> 14;
          b29 = s3[41] << 18 | s3[40] >>> 14;
          b20 = s3[2] << 1 | s3[3] >>> 31;
          b21 = s3[3] << 1 | s3[2] >>> 31;
          b22 = s3[13] << 12 | s3[12] >>> 20;
          b32 = s3[12] << 12 | s3[13] >>> 20;
          b34 = s3[22] << 10 | s3[23] >>> 22;
          b35 = s3[23] << 10 | s3[22] >>> 22;
          b16 = s3[33] << 13 | s3[32] >>> 19;
          b17 = s3[32] << 13 | s3[33] >>> 19;
          b48 = s3[42] << 2 | s3[43] >>> 30;
          b49 = s3[43] << 2 | s3[42] >>> 30;
          b40 = s3[5] << 30 | s3[4] >>> 2;
          b41 = s3[4] << 30 | s3[5] >>> 2;
          b222 = s3[14] << 6 | s3[15] >>> 26;
          b23 = s3[15] << 6 | s3[14] >>> 26;
          b42 = s3[25] << 11 | s3[24] >>> 21;
          b52 = s3[24] << 11 | s3[25] >>> 21;
          b36 = s3[34] << 15 | s3[35] >>> 17;
          b37 = s3[35] << 15 | s3[34] >>> 17;
          b18 = s3[45] << 29 | s3[44] >>> 3;
          b19 = s3[44] << 29 | s3[45] >>> 3;
          b10 = s3[6] << 28 | s3[7] >>> 4;
          b11 = s3[7] << 28 | s3[6] >>> 4;
          b422 = s3[17] << 23 | s3[16] >>> 9;
          b43 = s3[16] << 23 | s3[17] >>> 9;
          b24 = s3[26] << 25 | s3[27] >>> 7;
          b25 = s3[27] << 25 | s3[26] >>> 7;
          b62 = s3[36] << 21 | s3[37] >>> 11;
          b7 = s3[37] << 21 | s3[36] >>> 11;
          b38 = s3[47] << 24 | s3[46] >>> 8;
          b39 = s3[46] << 24 | s3[47] >>> 8;
          b30 = s3[8] << 27 | s3[9] >>> 5;
          b31 = s3[9] << 27 | s3[8] >>> 5;
          b12 = s3[18] << 20 | s3[19] >>> 12;
          b13 = s3[19] << 20 | s3[18] >>> 12;
          b44 = s3[29] << 7 | s3[28] >>> 25;
          b45 = s3[28] << 7 | s3[29] >>> 25;
          b26 = s3[38] << 8 | s3[39] >>> 24;
          b27 = s3[39] << 8 | s3[38] >>> 24;
          b8 = s3[48] << 14 | s3[49] >>> 18;
          b9 = s3[49] << 14 | s3[48] >>> 18;
          s3[0] = b0 ^ ~b22 & b42;
          s3[1] = b1 ^ ~b32 & b52;
          s3[10] = b10 ^ ~b12 & b14;
          s3[11] = b11 ^ ~b13 & b15;
          s3[20] = b20 ^ ~b222 & b24;
          s3[21] = b21 ^ ~b23 & b25;
          s3[30] = b30 ^ ~b322 & b34;
          s3[31] = b31 ^ ~b33 & b35;
          s3[40] = b40 ^ ~b422 & b44;
          s3[41] = b41 ^ ~b43 & b45;
          s3[2] = b22 ^ ~b42 & b62;
          s3[3] = b32 ^ ~b52 & b7;
          s3[12] = b12 ^ ~b14 & b16;
          s3[13] = b13 ^ ~b15 & b17;
          s3[22] = b222 ^ ~b24 & b26;
          s3[23] = b23 ^ ~b25 & b27;
          s3[32] = b322 ^ ~b34 & b36;
          s3[33] = b33 ^ ~b35 & b37;
          s3[42] = b422 ^ ~b44 & b46;
          s3[43] = b43 ^ ~b45 & b47;
          s3[4] = b42 ^ ~b62 & b8;
          s3[5] = b52 ^ ~b7 & b9;
          s3[14] = b14 ^ ~b16 & b18;
          s3[15] = b15 ^ ~b17 & b19;
          s3[24] = b24 ^ ~b26 & b28;
          s3[25] = b25 ^ ~b27 & b29;
          s3[34] = b34 ^ ~b36 & b38;
          s3[35] = b35 ^ ~b37 & b39;
          s3[44] = b44 ^ ~b46 & b48;
          s3[45] = b45 ^ ~b47 & b49;
          s3[6] = b62 ^ ~b8 & b0;
          s3[7] = b7 ^ ~b9 & b1;
          s3[16] = b16 ^ ~b18 & b10;
          s3[17] = b17 ^ ~b19 & b11;
          s3[26] = b26 ^ ~b28 & b20;
          s3[27] = b27 ^ ~b29 & b21;
          s3[36] = b36 ^ ~b38 & b30;
          s3[37] = b37 ^ ~b39 & b31;
          s3[46] = b46 ^ ~b48 & b40;
          s3[47] = b47 ^ ~b49 & b41;
          s3[8] = b8 ^ ~b0 & b22;
          s3[9] = b9 ^ ~b1 & b32;
          s3[18] = b18 ^ ~b10 & b12;
          s3[19] = b19 ^ ~b11 & b13;
          s3[28] = b28 ^ ~b20 & b222;
          s3[29] = b29 ^ ~b21 & b23;
          s3[38] = b38 ^ ~b30 & b322;
          s3[39] = b39 ^ ~b31 & b33;
          s3[48] = b48 ^ ~b40 & b422;
          s3[49] = b49 ^ ~b41 & b43;
          s3[0] ^= RC[n4];
          s3[1] ^= RC[n4 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i4 = 0; i4 < methodNames.length; ++i4) {
          root[methodNames[i4]] = methods[methodNames[i4]];
        }
      }
    })();
  })(sha32);
  var sha3Exports = sha32.exports;
  var DIDDocumentSignature;
  (function(DIDDocumentSignature2) {
    DIDDocumentSignature2["EthereumEip712Signature2021"] = "EthereumEip712Signature2021";
  })(DIDDocumentSignature || (DIDDocumentSignature = {}));
  function isGenesisState(did, state) {
    if (typeof state === "string") {
      state = V3.fromHex(state).bigInt();
    }
    const id3 = Q2.idFromDID(did);
    const { method, blockchain, networkId } = Q2.decodePartsFromId(id3);
    const type2 = G4(method, blockchain, networkId);
    const idFromState = $2.idGenesisFromIdenState(type2, state);
    return id3.bigInt().toString() === idFromState.bigInt().toString();
  }
  var validateDIDDocumentAuth = async (did, resolverURL, state) => {
    const vm = await resolveDIDDocumentAuth(did, resolverURL, state);
    if (!vm) {
      throw new Error(`can't resolve DID document`);
    }
    if (!vm.published && !isGenesisState(did, state.bigInt())) {
      throw new Error(`issuer state not published and not genesis`);
    }
  };
  var resolveDIDDocumentAuth = async (did, resolveURL, state) => {
    let url2 = `${resolveURL}/${encodeURIComponent(did.string())}`;
    if (state) {
      url2 += `?state=${state.hex()}`;
    }
    const resp = await fetch(url2);
    const didResolutionRes = await resp.json();
    return didResolutionRes.didDocument?.verificationMethod?.find((i4) => i4.type === "Iden3StateInfo2023");
  };
  function emptyStateDID(did) {
    const id3 = Q2.idFromDID(did);
    const didType = G4(Q2.methodFromId(id3), Q2.blockchainFromId(id3), Q2.networkIdFromId(id3));
    const identifier = $2.idGenesisFromIdenState(didType, 0n);
    const emptyDID = Q2.parseFromId(identifier);
    return emptyDID;
  }
  var resolveDidDocument = async (did, resolverUrl, opts) => {
    let didString = encodeURIComponent(did.string());
    const isGistRequest = opts?.gist && !opts.state;
    if (isGistRequest) {
      didString = encodeURIComponent(emptyStateDID(did).string());
    }
    let url2 = `${resolverUrl}/1.0/identifiers/${didString}`;
    if (opts?.signature) {
      url2 += `?signature=${opts.signature}`;
    }
    if (opts?.state) {
      url2 += `${url2.includes("?") ? "&" : "?"}state=${opts.state.hex()}`;
    }
    if (opts?.gist) {
      url2 += `${url2.includes("?") ? "&" : "?"}gist=${opts.gist.hex()}`;
    }
    const resp = await fetch(url2);
    const data = await resp.json();
    return data;
  };
  var pubsub = { exports: {} };
  (function(module, exports) {
    (function(root, factory2) {
      var PubSub = {};
      if (root.PubSub) {
        PubSub = root.PubSub;
        console.warn("PubSub already loaded, using existing version");
      } else {
        root.PubSub = PubSub;
        factory2(PubSub);
      }
      {
        if (module !== void 0 && module.exports) {
          exports = module.exports = PubSub;
        }
        exports.PubSub = PubSub;
        module.exports = exports = PubSub;
      }
    })(typeof window === "object" && window || commonjsGlobal2, function(PubSub) {
      var messages = {}, lastUid = -1, ALL_SUBSCRIBING_MSG = "*";
      function hasKeys(obj) {
        var key;
        for (key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return true;
          }
        }
        return false;
      }
      function throwException(ex) {
        return function reThrowException() {
          throw ex;
        };
      }
      function callSubscriberWithDelayedExceptions(subscriber, message, data) {
        try {
          subscriber(message, data);
        } catch (ex) {
          setTimeout(throwException(ex), 0);
        }
      }
      function callSubscriberWithImmediateExceptions(subscriber, message, data) {
        subscriber(message, data);
      }
      function deliverMessage(originalMessage, matchedMessage, data, immediateExceptions) {
        var subscribers = messages[matchedMessage], callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions, s3;
        if (!Object.prototype.hasOwnProperty.call(messages, matchedMessage)) {
          return;
        }
        for (s3 in subscribers) {
          if (Object.prototype.hasOwnProperty.call(subscribers, s3)) {
            callSubscriber(subscribers[s3], originalMessage, data);
          }
        }
      }
      function createDeliveryFunction(message, data, immediateExceptions) {
        return function deliverNamespaced() {
          var topic = String(message), position = topic.lastIndexOf(".");
          deliverMessage(message, message, data, immediateExceptions);
          while (position !== -1) {
            topic = topic.substr(0, position);
            position = topic.lastIndexOf(".");
            deliverMessage(message, topic, data, immediateExceptions);
          }
          deliverMessage(message, ALL_SUBSCRIBING_MSG, data, immediateExceptions);
        };
      }
      function hasDirectSubscribersFor(message) {
        var topic = String(message), found = Boolean(Object.prototype.hasOwnProperty.call(messages, topic) && hasKeys(messages[topic]));
        return found;
      }
      function messageHasSubscribers(message) {
        var topic = String(message), found = hasDirectSubscribersFor(topic) || hasDirectSubscribersFor(ALL_SUBSCRIBING_MSG), position = topic.lastIndexOf(".");
        while (!found && position !== -1) {
          topic = topic.substr(0, position);
          position = topic.lastIndexOf(".");
          found = hasDirectSubscribersFor(topic);
        }
        return found;
      }
      function publish(message, data, sync, immediateExceptions) {
        message = typeof message === "symbol" ? message.toString() : message;
        var deliver = createDeliveryFunction(message, data, immediateExceptions), hasSubscribers = messageHasSubscribers(message);
        if (!hasSubscribers) {
          return false;
        }
        if (sync === true) {
          deliver();
        } else {
          setTimeout(deliver, 0);
        }
        return true;
      }
      PubSub.publish = function(message, data) {
        return publish(message, data, false, PubSub.immediateExceptions);
      };
      PubSub.publishSync = function(message, data) {
        return publish(message, data, true, PubSub.immediateExceptions);
      };
      PubSub.subscribe = function(message, func) {
        if (typeof func !== "function") {
          return false;
        }
        message = typeof message === "symbol" ? message.toString() : message;
        if (!Object.prototype.hasOwnProperty.call(messages, message)) {
          messages[message] = {};
        }
        var token = "uid_" + String(++lastUid);
        messages[message][token] = func;
        return token;
      };
      PubSub.subscribeAll = function(func) {
        return PubSub.subscribe(ALL_SUBSCRIBING_MSG, func);
      };
      PubSub.subscribeOnce = function(message, func) {
        var token = PubSub.subscribe(message, function() {
          PubSub.unsubscribe(token);
          func.apply(this, arguments);
        });
        return PubSub;
      };
      PubSub.clearAllSubscriptions = function clearAllSubscriptions() {
        messages = {};
      };
      PubSub.clearSubscriptions = function clearSubscriptions(topic) {
        var m5;
        for (m5 in messages) {
          if (Object.prototype.hasOwnProperty.call(messages, m5) && m5.indexOf(topic) === 0) {
            delete messages[m5];
          }
        }
      };
      PubSub.countSubscriptions = function countSubscriptions(topic) {
        var m5;
        var token;
        var count = 0;
        for (m5 in messages) {
          if (Object.prototype.hasOwnProperty.call(messages, m5) && m5.indexOf(topic) === 0) {
            for (token in messages[m5]) {
              count++;
            }
            break;
          }
        }
        return count;
      };
      PubSub.getSubscriptions = function getSubscriptions(topic) {
        var m5;
        var list = [];
        for (m5 in messages) {
          if (Object.prototype.hasOwnProperty.call(messages, m5) && m5.indexOf(topic) === 0) {
            list.push(m5);
          }
        }
        return list;
      };
      PubSub.unsubscribe = function(value) {
        var descendantTopicExists = function(topic) {
          var m6;
          for (m6 in messages) {
            if (Object.prototype.hasOwnProperty.call(messages, m6) && m6.indexOf(topic) === 0) {
              return true;
            }
          }
          return false;
        }, isTopic = typeof value === "string" && (Object.prototype.hasOwnProperty.call(messages, value) || descendantTopicExists(value)), isToken = !isTopic && typeof value === "string", isFunction = typeof value === "function", result = false, m5, message, t;
        if (isTopic) {
          PubSub.clearSubscriptions(value);
          return;
        }
        for (m5 in messages) {
          if (Object.prototype.hasOwnProperty.call(messages, m5)) {
            message = messages[m5];
            if (isToken && message[value]) {
              delete message[value];
              result = value;
              break;
            }
            if (isFunction) {
              for (t in message) {
                if (Object.prototype.hasOwnProperty.call(message, t) && message[t] === value) {
                  delete message[t];
                  result = true;
                }
              }
            }
          }
        }
        return result;
      };
    });
  })(pubsub, pubsub.exports);
  var pubsubExports = pubsub.exports;
  function number$1(n4) {
    if (!Number.isSafeInteger(n4) || n4 < 0)
      throw new Error(`positive integer expected, not ${n4}`);
  }
  function isBytes$2(a4) {
    return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
  }
  function bytes$1(b7, ...lengths) {
    if (!isBytes$2(b7))
      throw new Error("Uint8Array expected");
    if (lengths.length > 0 && !lengths.includes(b7.length))
      throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b7.length}`);
  }
  function hash$1(h6) {
    if (typeof h6 !== "function" || typeof h6.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number$1(h6.outputLen);
    number$1(h6.blockLen);
  }
  function exists$1(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output$1(out, instance) {
    bytes$1(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var crypto$3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  var u32$1 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView$1 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr$1 = (word, shift) => word << 32 - shift | word >>> shift;
  var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
  var isLE$1 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  function byteSwap32(arr) {
    for (let i4 = 0; i4 < arr.length; i4++) {
      arr[i4] = byteSwap(arr[i4]);
    }
  }
  function utf8ToBytes$3(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes$1(data) {
    if (typeof data === "string")
      data = utf8ToBytes$3(data);
    bytes$1(data);
    return data;
  }
  function concatBytes$3(...arrays) {
    let sum = 0;
    for (let i4 = 0; i4 < arrays.length; i4++) {
      const a4 = arrays[i4];
      bytes$1(a4);
      sum += a4.length;
    }
    const res = new Uint8Array(sum);
    for (let i4 = 0, pad = 0; i4 < arrays.length; i4++) {
      const a4 = arrays[i4];
      res.set(a4, pad);
      pad += a4.length;
    }
    return res;
  }
  var Hash$1 = class Hash {
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor$1(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes$1(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes$1(bytesLength = 32) {
    if (crypto$3 && typeof crypto$3.getRandomValues === "function") {
      return crypto$3.getRandomValues(new Uint8Array(bytesLength));
    }
    if (crypto$3 && typeof crypto$3.randomBytes === "function") {
      return crypto$3.randomBytes(bytesLength);
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  function setBigUint64$1(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh2 = Number(value >> _32n2 & _u32_max);
    const wl2 = Number(value & _u32_max);
    const h6 = isLE2 ? 4 : 0;
    const l6 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h6, wh2, isLE2);
    view.setUint32(byteOffset + l6, wl2, isLE2);
  }
  var Chi$1 = (a4, b7, c3) => a4 & b7 ^ ~a4 & c3;
  var Maj$1 = (a4, b7, c3) => a4 & b7 ^ a4 & c3 ^ b7 & c3;
  var HashMD = class extends Hash$1 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView$1(this.buffer);
    }
    update(data) {
      exists$1(this);
      const { view, buffer, blockLen } = this;
      data = toBytes$1(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView$1(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists$1(this);
      output$1(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i4 = pos; i4 < blockLen; i4++)
        buffer[i4] = 0;
      setBigUint64$1(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView$1(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i4 = 0; i4 < outLen; i4++)
        oview.setUint32(4 * i4, state[i4], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to2) {
      to2 || (to2 = new this.constructor());
      to2.set(...this.get());
      const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
      to2.length = length2;
      to2.pos = pos;
      to2.finished = finished;
      to2.destroyed = destroyed;
      if (length2 % blockLen)
        to2.buffer.set(buffer);
      return to2;
    }
  };
  var U32_MASK64$1 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n$1 = /* @__PURE__ */ BigInt(32);
  function fromBig$1(n4, le2 = false) {
    if (le2)
      return { h: Number(n4 & U32_MASK64$1), l: Number(n4 >> _32n$1 & U32_MASK64$1) };
    return { h: Number(n4 >> _32n$1 & U32_MASK64$1) | 0, l: Number(n4 & U32_MASK64$1) | 0 };
  }
  function split$2(lst, le2 = false) {
    let Ah2 = new Uint32Array(lst.length);
    let Al2 = new Uint32Array(lst.length);
    for (let i4 = 0; i4 < lst.length; i4++) {
      const { h: h6, l: l6 } = fromBig$1(lst[i4], le2);
      [Ah2[i4], Al2[i4]] = [h6, l6];
    }
    return [Ah2, Al2];
  }
  var toBig$1 = (h6, l6) => BigInt(h6 >>> 0) << _32n$1 | BigInt(l6 >>> 0);
  var shrSH$1 = (h6, _l2, s3) => h6 >>> s3;
  var shrSL$1 = (h6, l6, s3) => h6 << 32 - s3 | l6 >>> s3;
  var rotrSH$1 = (h6, l6, s3) => h6 >>> s3 | l6 << 32 - s3;
  var rotrSL$1 = (h6, l6, s3) => h6 << 32 - s3 | l6 >>> s3;
  var rotrBH$1 = (h6, l6, s3) => h6 << 64 - s3 | l6 >>> s3 - 32;
  var rotrBL$1 = (h6, l6, s3) => h6 >>> s3 - 32 | l6 << 64 - s3;
  var rotr32H$1 = (_h2, l6) => l6;
  var rotr32L$1 = (h6, _l2) => h6;
  var rotlSH$1 = (h6, l6, s3) => h6 << s3 | l6 >>> 32 - s3;
  var rotlSL$1 = (h6, l6, s3) => l6 << s3 | h6 >>> 32 - s3;
  var rotlBH$1 = (h6, l6, s3) => l6 << s3 - 32 | h6 >>> 64 - s3;
  var rotlBL$1 = (h6, l6, s3) => h6 << s3 - 32 | l6 >>> 64 - s3;
  function add$1(Ah2, Al2, Bh2, Bl2) {
    const l6 = (Al2 >>> 0) + (Bl2 >>> 0);
    return { h: Ah2 + Bh2 + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
  }
  var add3L$1 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
  var add3H$1 = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
  var add4L$1 = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
  var add4H$1 = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
  var add5L$1 = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
  var add5H$1 = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
  var u64$1 = {
    fromBig: fromBig$1,
    split: split$2,
    toBig: toBig$1,
    shrSH: shrSH$1,
    shrSL: shrSL$1,
    rotrSH: rotrSH$1,
    rotrSL: rotrSL$1,
    rotrBH: rotrBH$1,
    rotrBL: rotrBL$1,
    rotr32H: rotr32H$1,
    rotr32L: rotr32L$1,
    rotlSH: rotlSH$1,
    rotlSL: rotlSL$1,
    rotlBH: rotlBH$1,
    rotlBL: rotlBL$1,
    add: add$1,
    add3L: add3L$1,
    add3H: add3H$1,
    add4L: add4L$1,
    add4H: add4H$1,
    add5H: add5H$1,
    add5L: add5L$1
  };
  var [SHA512_Kh$1, SHA512_Kl$1] = /* @__PURE__ */ (() => u64$1.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n4) => BigInt(n4))))();
  var SHA512_W_H$1 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L$1 = /* @__PURE__ */ new Uint32Array(80);
  var SHA512$1 = class SHA512 extends HashMD {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    get() {
      const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
      return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
    }
    set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
      this.Ah = Ah2 | 0;
      this.Al = Al2 | 0;
      this.Bh = Bh2 | 0;
      this.Bl = Bl2 | 0;
      this.Ch = Ch2 | 0;
      this.Cl = Cl2 | 0;
      this.Dh = Dh2 | 0;
      this.Dl = Dl2 | 0;
      this.Eh = Eh2 | 0;
      this.El = El2 | 0;
      this.Fh = Fh2 | 0;
      this.Fl = Fl2 | 0;
      this.Gh = Gh2 | 0;
      this.Gl = Gl2 | 0;
      this.Hh = Hh2 | 0;
      this.Hl = Hl2 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4) {
        SHA512_W_H$1[i4] = view.getUint32(offset);
        SHA512_W_L$1[i4] = view.getUint32(offset += 4);
      }
      for (let i4 = 16; i4 < 80; i4++) {
        const W15h = SHA512_W_H$1[i4 - 15] | 0;
        const W15l = SHA512_W_L$1[i4 - 15] | 0;
        const s0h = u64$1.rotrSH(W15h, W15l, 1) ^ u64$1.rotrSH(W15h, W15l, 8) ^ u64$1.shrSH(W15h, W15l, 7);
        const s0l = u64$1.rotrSL(W15h, W15l, 1) ^ u64$1.rotrSL(W15h, W15l, 8) ^ u64$1.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H$1[i4 - 2] | 0;
        const W2l = SHA512_W_L$1[i4 - 2] | 0;
        const s1h = u64$1.rotrSH(W2h, W2l, 19) ^ u64$1.rotrBH(W2h, W2l, 61) ^ u64$1.shrSH(W2h, W2l, 6);
        const s1l = u64$1.rotrSL(W2h, W2l, 19) ^ u64$1.rotrBL(W2h, W2l, 61) ^ u64$1.shrSL(W2h, W2l, 6);
        const SUMl = u64$1.add4L(s0l, s1l, SHA512_W_L$1[i4 - 7], SHA512_W_L$1[i4 - 16]);
        const SUMh = u64$1.add4H(SUMl, s0h, s1h, SHA512_W_H$1[i4 - 7], SHA512_W_H$1[i4 - 16]);
        SHA512_W_H$1[i4] = SUMh | 0;
        SHA512_W_L$1[i4] = SUMl | 0;
      }
      let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
      for (let i4 = 0; i4 < 80; i4++) {
        const sigma1h = u64$1.rotrSH(Eh2, El2, 14) ^ u64$1.rotrSH(Eh2, El2, 18) ^ u64$1.rotrBH(Eh2, El2, 41);
        const sigma1l = u64$1.rotrSL(Eh2, El2, 14) ^ u64$1.rotrSL(Eh2, El2, 18) ^ u64$1.rotrBL(Eh2, El2, 41);
        const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
        const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
        const T1ll = u64$1.add5L(Hl2, sigma1l, CHIl, SHA512_Kl$1[i4], SHA512_W_L$1[i4]);
        const T1h = u64$1.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh$1[i4], SHA512_W_H$1[i4]);
        const T1l = T1ll | 0;
        const sigma0h = u64$1.rotrSH(Ah2, Al2, 28) ^ u64$1.rotrBH(Ah2, Al2, 34) ^ u64$1.rotrBH(Ah2, Al2, 39);
        const sigma0l = u64$1.rotrSL(Ah2, Al2, 28) ^ u64$1.rotrBL(Ah2, Al2, 34) ^ u64$1.rotrBL(Ah2, Al2, 39);
        const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
        const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
        Hh2 = Gh2 | 0;
        Hl2 = Gl2 | 0;
        Gh2 = Fh2 | 0;
        Gl2 = Fl2 | 0;
        Fh2 = Eh2 | 0;
        Fl2 = El2 | 0;
        ({ h: Eh2, l: El2 } = u64$1.add(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
        Dh2 = Ch2 | 0;
        Dl2 = Cl2 | 0;
        Ch2 = Bh2 | 0;
        Cl2 = Bl2 | 0;
        Bh2 = Ah2 | 0;
        Bl2 = Al2 | 0;
        const All = u64$1.add3L(T1l, sigma0l, MAJl);
        Ah2 = u64$1.add3H(All, T1h, sigma0h, MAJh);
        Al2 = All | 0;
      }
      ({ h: Ah2, l: Al2 } = u64$1.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
      ({ h: Bh2, l: Bl2 } = u64$1.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
      ({ h: Ch2, l: Cl2 } = u64$1.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
      ({ h: Dh2, l: Dl2 } = u64$1.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
      ({ h: Eh2, l: El2 } = u64$1.add(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
      ({ h: Fh2, l: Fl2 } = u64$1.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
      ({ h: Gh2, l: Gl2 } = u64$1.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
      ({ h: Hh2, l: Hl2 } = u64$1.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
      this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
    }
    roundClean() {
      SHA512_W_H$1.fill(0);
      SHA512_W_L$1.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha512$1 = /* @__PURE__ */ wrapConstructor$1(() => new SHA512$1());
  var _0n$a = /* @__PURE__ */ BigInt(0);
  var _1n$d = /* @__PURE__ */ BigInt(1);
  var _2n$9 = /* @__PURE__ */ BigInt(2);
  function isBytes$1(a4) {
    return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
  }
  function abytes(item) {
    if (!isBytes$1(item))
      throw new Error("Uint8Array expected");
  }
  function abool(title2, value) {
    if (typeof value !== "boolean")
      throw new Error(`${title2} must be valid boolean, got "${value}".`);
  }
  var hexes$1 = /* @__PURE__ */ Array.from({ length: 256 }, (_5, i4) => i4.toString(16).padStart(2, "0"));
  function bytesToHex$2(bytes2) {
    abytes(bytes2);
    let hex2 = "";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      hex2 += hexes$1[bytes2[i4]];
    }
    return hex2;
  }
  function numberToHexUnpadded$1(num) {
    const hex2 = num.toString(16);
    return hex2.length & 1 ? `0${hex2}` : hex2;
  }
  function hexToNumber$1(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
  }
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  }
  function hexToBytes$2(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    const hl2 = hex2.length;
    const al2 = hl2 / 2;
    if (hl2 % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl2);
    const array = new Uint8Array(al2);
    for (let ai2 = 0, hi2 = 0; ai2 < al2; ai2++, hi2 += 2) {
      const n1 = asciiToBase16(hex2.charCodeAt(hi2));
      const n22 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
      if (n1 === void 0 || n22 === void 0) {
        const char = hex2[hi2] + hex2[hi2 + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
      }
      array[ai2] = n1 * 16 + n22;
    }
    return array;
  }
  function bytesToNumberBE$1(bytes2) {
    return hexToNumber$1(bytesToHex$2(bytes2));
  }
  function bytesToNumberLE$1(bytes2) {
    abytes(bytes2);
    return hexToNumber$1(bytesToHex$2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE$1(n4, len) {
    return hexToBytes$2(n4.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE$1(n4, len) {
    return numberToBytesBE$1(n4, len).reverse();
  }
  function numberToVarBytesBE$1(n4) {
    return hexToBytes$2(numberToHexUnpadded$1(n4));
  }
  function ensureBytes$1(title2, hex2, expectedLength) {
    let res;
    if (typeof hex2 === "string") {
      try {
        res = hexToBytes$2(hex2);
      } catch (e7) {
        throw new Error(`${title2} must be valid hex string, got "${hex2}". Cause: ${e7}`);
      }
    } else if (isBytes$1(hex2)) {
      res = Uint8Array.from(hex2);
    } else {
      throw new Error(`${title2} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title2} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes$2(...arrays) {
    let sum = 0;
    for (let i4 = 0; i4 < arrays.length; i4++) {
      const a4 = arrays[i4];
      abytes(a4);
      sum += a4.length;
    }
    const res = new Uint8Array(sum);
    for (let i4 = 0, pad = 0; i4 < arrays.length; i4++) {
      const a4 = arrays[i4];
      res.set(a4, pad);
      pad += a4.length;
    }
    return res;
  }
  function equalBytes$1(a4, b7) {
    if (a4.length !== b7.length)
      return false;
    let diff = 0;
    for (let i4 = 0; i4 < a4.length; i4++)
      diff |= a4[i4] ^ b7[i4];
    return diff === 0;
  }
  function utf8ToBytes$2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  var isPosBig = (n4) => typeof n4 === "bigint" && _0n$a <= n4;
  function inRange(n4, min, max) {
    return isPosBig(n4) && isPosBig(min) && isPosBig(max) && min <= n4 && n4 < max;
  }
  function aInRange(title2, n4, min, max) {
    if (!inRange(n4, min, max))
      throw new Error(`expected valid ${title2}: ${min} <= n < ${max}, got ${typeof n4} ${n4}`);
  }
  function bitLen$1(n4) {
    let len;
    for (len = 0; n4 > _0n$a; n4 >>= _1n$d, len += 1)
      ;
    return len;
  }
  function bitGet$1(n4, pos) {
    return n4 >> BigInt(pos) & _1n$d;
  }
  function bitSet$1(n4, pos, value) {
    return n4 | (value ? _1n$d : _0n$a) << BigInt(pos);
  }
  var bitMask$1 = (n4) => (_2n$9 << BigInt(n4 - 1)) - _1n$d;
  var u8n$1 = (data) => new Uint8Array(data);
  var u8fr$1 = (arr) => Uint8Array.from(arr);
  function createHmacDrbg$1(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v6 = u8n$1(hashLen);
    let k5 = u8n$1(hashLen);
    let i4 = 0;
    const reset = () => {
      v6.fill(1);
      k5.fill(0);
      i4 = 0;
    };
    const h6 = (...b7) => hmacFn(k5, v6, ...b7);
    const reseed = (seed = u8n$1()) => {
      k5 = h6(u8fr$1([0]), seed);
      v6 = h6();
      if (seed.length === 0)
        return;
      k5 = h6(u8fr$1([1]), seed);
      v6 = h6();
    };
    const gen2 = () => {
      if (i4++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v6 = h6();
        const sl2 = v6.slice();
        out.push(sl2);
        len += v6.length;
      }
      return concatBytes$2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns$1 = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || isBytes$1(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject$1(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns$1[type2];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type2}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
      }
    };
    for (const [fieldName, type2] of Object.entries(validators))
      checkField(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators))
      checkField(fieldName, type2, true);
    return object2;
  }
  var notImplemented = () => {
    throw new Error("not implemented");
  };
  function memoized(fn2) {
    const map = /* @__PURE__ */ new WeakMap();
    return (arg, ...args) => {
      const val = map.get(arg);
      if (val !== void 0)
        return val;
      const computed = fn2(arg, ...args);
      map.set(arg, computed);
      return computed;
    };
  }
  var ut$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    aInRange,
    abool,
    abytes,
    bitGet: bitGet$1,
    bitLen: bitLen$1,
    bitMask: bitMask$1,
    bitSet: bitSet$1,
    bytesToHex: bytesToHex$2,
    bytesToNumberBE: bytesToNumberBE$1,
    bytesToNumberLE: bytesToNumberLE$1,
    concatBytes: concatBytes$2,
    createHmacDrbg: createHmacDrbg$1,
    ensureBytes: ensureBytes$1,
    equalBytes: equalBytes$1,
    hexToBytes: hexToBytes$2,
    hexToNumber: hexToNumber$1,
    inRange,
    isBytes: isBytes$1,
    memoized,
    notImplemented,
    numberToBytesBE: numberToBytesBE$1,
    numberToBytesLE: numberToBytesLE$1,
    numberToHexUnpadded: numberToHexUnpadded$1,
    numberToVarBytesBE: numberToVarBytesBE$1,
    utf8ToBytes: utf8ToBytes$2,
    validateObject: validateObject$1
  });
  var _0n$9 = BigInt(0);
  var _1n$c = BigInt(1);
  var _2n$8 = BigInt(2);
  var _3n$3 = BigInt(3);
  var _4n$1 = BigInt(4);
  var _5n$2 = BigInt(5);
  var _8n$3 = BigInt(8);
  BigInt(9);
  BigInt(16);
  function mod$1(a4, b7) {
    const result = a4 % b7;
    return result >= _0n$9 ? result : b7 + result;
  }
  function pow$1(num, power, modulo) {
    if (modulo <= _0n$9 || power < _0n$9)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n$c)
      return _0n$9;
    let res = _1n$c;
    while (power > _0n$9) {
      if (power & _1n$c)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n$c;
    }
    return res;
  }
  function pow2$1(x6, power, modulo) {
    let res = x6;
    while (power-- > _0n$9) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert$1(number2, modulo) {
    if (number2 === _0n$9 || modulo <= _0n$9) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a4 = mod$1(number2, modulo);
    let b7 = modulo;
    let x6 = _0n$9, u4 = _1n$c;
    while (a4 !== _0n$9) {
      const q5 = b7 / a4;
      const r = b7 % a4;
      const m5 = x6 - u4 * q5;
      b7 = a4, a4 = r, x6 = u4, u4 = m5;
    }
    const gcd2 = b7;
    if (gcd2 !== _1n$c)
      throw new Error("invert: does not exist");
    return mod$1(x6, modulo);
  }
  function tonelliShanks$1(P5) {
    const legendreC = (P5 - _1n$c) / _2n$8;
    let Q5, S6, Z5;
    for (Q5 = P5 - _1n$c, S6 = 0; Q5 % _2n$8 === _0n$9; Q5 /= _2n$8, S6++)
      ;
    for (Z5 = _2n$8; Z5 < P5 && pow$1(Z5, legendreC, P5) !== P5 - _1n$c; Z5++)
      ;
    if (S6 === 1) {
      const p1div4 = (P5 + _1n$c) / _4n$1;
      return function tonelliFast(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q5 + _1n$c) / _2n$8;
    return function tonelliSlow(Fp2, n4) {
      if (Fp2.pow(n4, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S6;
      let g5 = Fp2.pow(Fp2.mul(Fp2.ONE, Z5), Q5);
      let x6 = Fp2.pow(n4, Q1div2);
      let b7 = Fp2.pow(n4, Q5);
      while (!Fp2.eql(b7, Fp2.ONE)) {
        if (Fp2.eql(b7, Fp2.ZERO))
          return Fp2.ZERO;
        let m5 = 1;
        for (let t2 = Fp2.sqr(b7); m5 < r; m5++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge2 = Fp2.pow(g5, _1n$c << BigInt(r - m5 - 1));
        g5 = Fp2.sqr(ge2);
        x6 = Fp2.mul(x6, ge2);
        b7 = Fp2.mul(b7, g5);
        r = m5;
      }
      return x6;
    };
  }
  function FpSqrt$1(P5) {
    if (P5 % _4n$1 === _3n$3) {
      const p1div4 = (P5 + _1n$c) / _4n$1;
      return function sqrt3mod4(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P5 % _8n$3 === _5n$2) {
      const c1 = (P5 - _5n$2) / _8n$3;
      return function sqrt5mod8(Fp2, n4) {
        const n22 = Fp2.mul(n4, _2n$8);
        const v6 = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n4, v6);
        const i4 = Fp2.mul(Fp2.mul(nv, _2n$8), v6);
        const root = Fp2.mul(nv, Fp2.sub(i4, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    return tonelliShanks$1(P5);
  }
  var isNegativeLE = (num, modulo) => (mod$1(num, modulo) & _1n$c) === _1n$c;
  var FIELD_FIELDS$1 = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField$1(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS$1.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject$1(field, opts);
  }
  function FpPow$1(f5, num, power) {
    if (power < _0n$9)
      throw new Error("Expected power > 0");
    if (power === _0n$9)
      return f5.ONE;
    if (power === _1n$c)
      return num;
    let p6 = f5.ONE;
    let d5 = num;
    while (power > _0n$9) {
      if (power & _1n$c)
        p6 = f5.mul(p6, d5);
      d5 = f5.sqr(d5);
      power >>= _1n$c;
    }
    return p6;
  }
  function FpInvertBatch$1(f5, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = acc;
      return f5.mul(acc, num);
    }, f5.ONE);
    const inverted = f5.inv(lastMultiplied);
    nums.reduceRight((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = f5.mul(acc, tmp[i4]);
      return f5.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength$1(n4, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n4.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field$1(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n$9)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength$1(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt$1(ORDER);
    const f5 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask$1(BITS),
      ZERO: _0n$9,
      ONE: _1n$c,
      create: (num) => mod$1(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n$9 <= num && num < ORDER;
      },
      is0: (num) => num === _0n$9,
      isOdd: (num) => (num & _1n$c) === _1n$c,
      neg: (num) => mod$1(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod$1(num * num, ORDER),
      add: (lhs, rhs) => mod$1(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod$1(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod$1(lhs * rhs, ORDER),
      pow: (num, power) => FpPow$1(f5, num, power),
      div: (lhs, rhs) => mod$1(lhs * invert$1(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert$1(num, ORDER),
      sqrt: redef.sqrt || ((n4) => sqrtP(f5, n4)),
      invertBatch: (lst) => FpInvertBatch$1(f5, lst),
      cmov: (a4, b7, c3) => c3 ? b7 : a4,
      toBytes: (num) => isLE2 ? numberToBytesLE$1(num, BYTES) : numberToBytesBE$1(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE$1(bytes2) : bytesToNumberBE$1(bytes2);
      }
    });
    return Object.freeze(f5);
  }
  function getFieldBytesLength$1(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength2 = fieldOrder.toString(2).length;
    return Math.ceil(bitLength2 / 8);
  }
  function getMinHashLength$1(fieldOrder) {
    const length2 = getFieldBytesLength$1(fieldOrder);
    return length2 + Math.ceil(length2 / 2);
  }
  function mapHashToField$1(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength$1(fieldOrder);
    const minLen = getMinHashLength$1(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE2 ? bytesToNumberBE$1(key) : bytesToNumberLE$1(key);
    const reduced = mod$1(num, fieldOrder - _1n$c) + _1n$c;
    return isLE2 ? numberToBytesLE$1(reduced, fieldLen) : numberToBytesBE$1(reduced, fieldLen);
  }
  var _0n$8 = BigInt(0);
  var _1n$b = BigInt(1);
  var pointPrecomputes = /* @__PURE__ */ new WeakMap();
  var pointWindowSizes = /* @__PURE__ */ new WeakMap();
  function wNAF$1(c3, bits2) {
    const constTimeNegate = (condition, item) => {
      const neg2 = item.negate();
      return condition ? neg2 : item;
    };
    const validateW = (W5) => {
      if (!Number.isSafeInteger(W5) || W5 <= 0 || W5 > bits2)
        throw new Error(`Wrong window size=${W5}, should be [1..${bits2}]`);
    };
    const opts = (W5) => {
      validateW(W5);
      const windows = Math.ceil(bits2 / W5) + 1;
      const windowSize = 2 ** (W5 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      unsafeLadder(elm, n4) {
        let p6 = c3.ZERO;
        let d5 = elm;
        while (n4 > _0n$8) {
          if (n4 & _1n$b)
            p6 = p6.add(d5);
          d5 = d5.double();
          n4 >>= _1n$b;
        }
        return p6;
      },
      precomputeWindow(elm, W5) {
        const { windows, windowSize } = opts(W5);
        const points = [];
        let p6 = elm;
        let base3 = p6;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p6;
          points.push(base3);
          for (let i4 = 1; i4 < windowSize; i4++) {
            base3 = base3.add(p6);
            points.push(base3);
          }
          p6 = base3.double();
        }
        return points;
      },
      wNAF(W5, precomputes, n4) {
        const { windows, windowSize } = opts(W5);
        let p6 = c3.ZERO;
        let f5 = c3.BASE;
        const mask2 = BigInt(2 ** W5 - 1);
        const maxNumber = 2 ** W5;
        const shiftBy = BigInt(W5);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n4 & mask2);
          n4 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n4 += _1n$b;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f5 = f5.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p6 = p6.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p6, f: f5 };
      },
      wNAFCached(P5, n4, transform) {
        const W5 = pointWindowSizes.get(P5) || 1;
        let comp = pointPrecomputes.get(P5);
        if (!comp) {
          comp = this.precomputeWindow(P5, W5);
          if (W5 !== 1)
            pointPrecomputes.set(P5, transform(comp));
        }
        return this.wNAF(W5, comp, n4);
      },
      setWindowSize(P5, W5) {
        validateW(W5);
        pointWindowSizes.set(P5, W5);
        pointPrecomputes.delete(P5);
      }
    };
  }
  function pippenger(c3, field, points, scalars) {
    if (!Array.isArray(points) || !Array.isArray(scalars) || scalars.length !== points.length)
      throw new Error("arrays of points and scalars must have equal length");
    scalars.forEach((s3, i4) => {
      if (!field.isValid(s3))
        throw new Error(`wrong scalar at index ${i4}`);
    });
    points.forEach((p6, i4) => {
      if (!(p6 instanceof c3))
        throw new Error(`wrong point at index ${i4}`);
    });
    const wbits = bitLen$1(BigInt(points.length));
    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
    const MASK = (1 << windowSize) - 1;
    const buckets = new Array(MASK + 1).fill(c3.ZERO);
    const lastBits = Math.floor((field.BITS - 1) / windowSize) * windowSize;
    let sum = c3.ZERO;
    for (let i4 = lastBits; i4 >= 0; i4 -= windowSize) {
      buckets.fill(c3.ZERO);
      for (let j5 = 0; j5 < scalars.length; j5++) {
        const scalar = scalars[j5];
        const wbits2 = Number(scalar >> BigInt(i4) & BigInt(MASK));
        buckets[wbits2] = buckets[wbits2].add(points[j5]);
      }
      let resI = c3.ZERO;
      for (let j5 = buckets.length - 1, sumI = c3.ZERO; j5 > 0; j5--) {
        sumI = sumI.add(buckets[j5]);
        resI = resI.add(sumI);
      }
      sum = sum.add(resI);
      if (i4 !== 0)
        for (let j5 = 0; j5 < windowSize; j5++)
          sum = sum.double();
    }
    return sum;
  }
  function validateBasic$1(curve2) {
    validateField$1(curve2.Fp);
    validateObject$1(curve2, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength$1(curve2.n, curve2.nBitLength),
      ...curve2,
      ...{ p: curve2.Fp.ORDER }
    });
  }
  var _0n$7 = BigInt(0);
  var _1n$a = BigInt(1);
  var _2n$7 = BigInt(2);
  var _8n$2 = BigInt(8);
  var VERIFY_DEFAULT = { zip215: true };
  function validateOpts$2(curve2) {
    const opts = validateBasic$1(curve2);
    validateObject$1(curve2, {
      hash: "function",
      a: "bigint",
      d: "bigint",
      randomBytes: "function"
    }, {
      adjustScalarBytes: "function",
      domain: "function",
      uvRatio: "function",
      mapToCurve: "function"
    });
    return Object.freeze({ ...opts });
  }
  function twistedEdwards(curveDef) {
    const CURVE = validateOpts$2(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
    const MASK = _2n$7 << BigInt(nByteLength * 8) - _1n$a;
    const modP = Fp2.create;
    const Fn2 = Field$1(CURVE.n, CURVE.nBitLength);
    const uvRatio2 = CURVE.uvRatio || ((u4, v6) => {
      try {
        return { isValid: true, value: Fp2.sqrt(u4 * Fp2.inv(v6)) };
      } catch (e7) {
        return { isValid: false, value: _0n$7 };
      }
    });
    const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
    const domain = CURVE.domain || ((data, ctx, phflag) => {
      abool("phflag", phflag);
      if (ctx.length || phflag)
        throw new Error("Contexts/pre-hash are not supported");
      return data;
    });
    function aCoordinate(title2, n4) {
      aInRange("coordinate " + title2, n4, _0n$7, MASK);
    }
    function assertPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ExtendedPoint expected");
    }
    const toAffineMemo = memoized((p6, iz) => {
      const { ex: x6, ey: y5, ez: z6 } = p6;
      const is0 = p6.is0();
      if (iz == null)
        iz = is0 ? _8n$2 : Fp2.inv(z6);
      const ax = modP(x6 * iz);
      const ay = modP(y5 * iz);
      const zz = modP(z6 * iz);
      if (is0)
        return { x: _0n$7, y: _1n$a };
      if (zz !== _1n$a)
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p6) => {
      const { a: a4, d: d5 } = CURVE;
      if (p6.is0())
        throw new Error("bad point: ZERO");
      const { ex: X5, ey: Y5, ez: Z5, et: T6 } = p6;
      const X22 = modP(X5 * X5);
      const Y22 = modP(Y5 * Y5);
      const Z22 = modP(Z5 * Z5);
      const Z42 = modP(Z22 * Z22);
      const aX2 = modP(X22 * a4);
      const left = modP(Z22 * modP(aX2 + Y22));
      const right = modP(Z42 + modP(d5 * modP(X22 * Y22)));
      if (left !== right)
        throw new Error("bad point: equation left != right (1)");
      const XY = modP(X5 * Y5);
      const ZT = modP(Z5 * T6);
      if (XY !== ZT)
        throw new Error("bad point: equation left != right (2)");
      return true;
    });
    class Point {
      constructor(ex, ey, ez, et4) {
        this.ex = ex;
        this.ey = ey;
        this.ez = ez;
        this.et = et4;
        aCoordinate("x", ex);
        aCoordinate("y", ey);
        aCoordinate("z", ez);
        aCoordinate("t", et4);
        Object.freeze(this);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static fromAffine(p6) {
        if (p6 instanceof Point)
          throw new Error("extended point not allowed");
        const { x: x6, y: y5 } = p6 || {};
        aCoordinate("x", x6);
        aCoordinate("y", y5);
        return new Point(x6, y5, _1n$a, modP(x6 * y5));
      }
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p6) => p6.ez));
        return points.map((p6, i4) => p6.toAffine(toInv[i4])).map(Point.fromAffine);
      }
      static msm(points, scalars) {
        return pippenger(Point, Fn2, points, scalars);
      }
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      assertValidity() {
        assertValidMemo(this);
      }
      equals(other) {
        assertPoint(other);
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const { ex: X22, ey: Y22, ez: Z22 } = other;
        const X1Z2 = modP(X1 * Z22);
        const X2Z1 = modP(X22 * Z1);
        const Y1Z2 = modP(Y1 * Z22);
        const Y2Z1 = modP(Y22 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      negate() {
        return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
      }
      double() {
        const { a: a4 } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1 } = this;
        const A5 = modP(X1 * X1);
        const B6 = modP(Y1 * Y1);
        const C5 = modP(_2n$7 * modP(Z1 * Z1));
        const D4 = modP(a4 * A5);
        const x1y1 = X1 + Y1;
        const E4 = modP(modP(x1y1 * x1y1) - A5 - B6);
        const G8 = D4 + B6;
        const F4 = G8 - C5;
        const H4 = D4 - B6;
        const X32 = modP(E4 * F4);
        const Y32 = modP(G8 * H4);
        const T32 = modP(E4 * H4);
        const Z32 = modP(F4 * G8);
        return new Point(X32, Y32, Z32, T32);
      }
      add(other) {
        assertPoint(other);
        const { a: a4, d: d5 } = CURVE;
        const { ex: X1, ey: Y1, ez: Z1, et: T12 } = this;
        const { ex: X22, ey: Y22, ez: Z22, et: T22 } = other;
        if (a4 === BigInt(-1)) {
          const A6 = modP((Y1 - X1) * (Y22 + X22));
          const B7 = modP((Y1 + X1) * (Y22 - X22));
          const F5 = modP(B7 - A6);
          if (F5 === _0n$7)
            return this.double();
          const C6 = modP(Z1 * _2n$7 * T22);
          const D5 = modP(T12 * _2n$7 * Z22);
          const E5 = D5 + C6;
          const G9 = B7 + A6;
          const H5 = D5 - C6;
          const X33 = modP(E5 * F5);
          const Y33 = modP(G9 * H5);
          const T33 = modP(E5 * H5);
          const Z33 = modP(F5 * G9);
          return new Point(X33, Y33, Z33, T33);
        }
        const A5 = modP(X1 * X22);
        const B6 = modP(Y1 * Y22);
        const C5 = modP(T12 * d5 * T22);
        const D4 = modP(Z1 * Z22);
        const E4 = modP((X1 + Y1) * (X22 + Y22) - A5 - B6);
        const F4 = D4 - C5;
        const G8 = D4 + C5;
        const H4 = modP(B6 - a4 * A5);
        const X32 = modP(E4 * F4);
        const Y32 = modP(G8 * H4);
        const T32 = modP(E4 * H4);
        const Z32 = modP(F4 * G8);
        return new Point(X32, Y32, Z32, T32);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      wNAF(n4) {
        return wnaf.wNAFCached(this, n4, Point.normalizeZ);
      }
      multiply(scalar) {
        const n4 = scalar;
        aInRange("scalar", n4, _1n$a, CURVE_ORDER);
        const { p: p6, f: f5 } = this.wNAF(n4);
        return Point.normalizeZ([p6, f5])[0];
      }
      multiplyUnsafe(scalar) {
        const n4 = scalar;
        aInRange("scalar", n4, _0n$7, CURVE_ORDER);
        if (n4 === _0n$7)
          return I5;
        if (this.equals(I5) || n4 === _1n$a)
          return this;
        if (this.equals(G7))
          return this.wNAF(n4).p;
        return wnaf.unsafeLadder(this, n4);
      }
      isSmallOrder() {
        return this.multiplyUnsafe(cofactor).is0();
      }
      isTorsionFree() {
        return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
      }
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      clearCofactor() {
        const { h: cofactor2 } = CURVE;
        if (cofactor2 === _1n$a)
          return this;
        return this.multiplyUnsafe(cofactor2);
      }
      static fromHex(hex2, zip215 = false) {
        const { d: d5, a: a4 } = CURVE;
        const len = Fp2.BYTES;
        hex2 = ensureBytes$1("pointHex", hex2, len);
        abool("zip215", zip215);
        const normed = hex2.slice();
        const lastByte = hex2[len - 1];
        normed[len - 1] = lastByte & ~128;
        const y5 = bytesToNumberLE$1(normed);
        const max = zip215 ? MASK : Fp2.ORDER;
        aInRange("pointHex.y", y5, _0n$7, max);
        const y22 = modP(y5 * y5);
        const u4 = modP(y22 - _1n$a);
        const v6 = modP(d5 * y22 - a4);
        let { isValid, value: x6 } = uvRatio2(u4, v6);
        if (!isValid)
          throw new Error("Point.fromHex: invalid y coordinate");
        const isXOdd = (x6 & _1n$a) === _1n$a;
        const isLastByteOdd = (lastByte & 128) !== 0;
        if (!zip215 && x6 === _0n$7 && isLastByteOdd)
          throw new Error("Point.fromHex: x=0 and x_0=1");
        if (isLastByteOdd !== isXOdd)
          x6 = modP(-x6);
        return Point.fromAffine({ x: x6, y: y5 });
      }
      static fromPrivateKey(privKey) {
        return getExtendedPublicKey(privKey).point;
      }
      toRawBytes() {
        const { x: x6, y: y5 } = this.toAffine();
        const bytes2 = numberToBytesLE$1(y5, Fp2.BYTES);
        bytes2[bytes2.length - 1] |= x6 & _1n$a ? 128 : 0;
        return bytes2;
      }
      toHex() {
        return bytesToHex$2(this.toRawBytes());
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n$a, modP(CURVE.Gx * CURVE.Gy));
    Point.ZERO = new Point(_0n$7, _1n$a, _1n$a, _0n$7);
    const { BASE: G7, ZERO: I5 } = Point;
    const wnaf = wNAF$1(Point, nByteLength * 8);
    function modN(a4) {
      return mod$1(a4, CURVE_ORDER);
    }
    function modN_LE(hash2) {
      return modN(bytesToNumberLE$1(hash2));
    }
    function getExtendedPublicKey(key) {
      const len = nByteLength;
      key = ensureBytes$1("private key", key, len);
      const hashed = ensureBytes$1("hashed private key", cHash(key), 2 * len);
      const head2 = adjustScalarBytes2(hashed.slice(0, len));
      const prefix = hashed.slice(len, 2 * len);
      const scalar = modN_LE(head2);
      const point = G7.multiply(scalar);
      const pointBytes = point.toRawBytes();
      return { head: head2, prefix, scalar, point, pointBytes };
    }
    function getPublicKey(privKey) {
      return getExtendedPublicKey(privKey).pointBytes;
    }
    function hashDomainToScalar(context2 = new Uint8Array(), ...msgs) {
      const msg = concatBytes$2(...msgs);
      return modN_LE(cHash(domain(msg, ensureBytes$1("context", context2), !!prehash)));
    }
    function sign(msg, privKey, options = {}) {
      msg = ensureBytes$1("message", msg);
      if (prehash)
        msg = prehash(msg);
      const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
      const r = hashDomainToScalar(options.context, prefix, msg);
      const R5 = G7.multiply(r).toRawBytes();
      const k5 = hashDomainToScalar(options.context, R5, pointBytes, msg);
      const s3 = modN(r + k5 * scalar);
      aInRange("signature.s", s3, _0n$7, CURVE_ORDER);
      const res = concatBytes$2(R5, numberToBytesLE$1(s3, Fp2.BYTES));
      return ensureBytes$1("result", res, nByteLength * 2);
    }
    const verifyOpts = VERIFY_DEFAULT;
    function verify(sig, msg, publicKey2, options = verifyOpts) {
      const { context: context2, zip215 } = options;
      const len = Fp2.BYTES;
      sig = ensureBytes$1("signature", sig, 2 * len);
      msg = ensureBytes$1("message", msg);
      if (zip215 !== void 0)
        abool("zip215", zip215);
      if (prehash)
        msg = prehash(msg);
      const s3 = bytesToNumberLE$1(sig.slice(len, 2 * len));
      let A5, R5, SB;
      try {
        A5 = Point.fromHex(publicKey2, zip215);
        R5 = Point.fromHex(sig.slice(0, len), zip215);
        SB = G7.multiplyUnsafe(s3);
      } catch (error2) {
        return false;
      }
      if (!zip215 && A5.isSmallOrder())
        return false;
      const k5 = hashDomainToScalar(context2, R5.toRawBytes(), A5.toRawBytes(), msg);
      const RkA = R5.add(A5.multiplyUnsafe(k5));
      return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
    }
    G7._setWindowSize(8);
    const utils2 = {
      getExtendedPublicKey,
      randomPrivateKey: () => randomBytes2(Fp2.BYTES),
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    return {
      CURVE,
      getPublicKey,
      sign,
      verify,
      ExtendedPoint: Point,
      utils: utils2
    };
  }
  var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
  BigInt(0);
  var _1n$9 = BigInt(1);
  var _2n$6 = BigInt(2);
  BigInt(3);
  var _5n$1 = BigInt(5);
  var _8n$1 = BigInt(8);
  function ed25519_pow_2_252_3(x6) {
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P5 = ED25519_P;
    const x22 = x6 * x6 % P5;
    const b22 = x22 * x6 % P5;
    const b42 = pow2$1(b22, _2n$6, P5) * b22 % P5;
    const b52 = pow2$1(b42, _1n$9, P5) * x6 % P5;
    const b10 = pow2$1(b52, _5n$1, P5) * b52 % P5;
    const b20 = pow2$1(b10, _10n, P5) * b10 % P5;
    const b40 = pow2$1(b20, _20n, P5) * b20 % P5;
    const b80 = pow2$1(b40, _40n, P5) * b40 % P5;
    const b160 = pow2$1(b80, _80n, P5) * b80 % P5;
    const b240 = pow2$1(b160, _80n, P5) * b80 % P5;
    const b250 = pow2$1(b240, _10n, P5) * b10 % P5;
    const pow_p_5_8 = pow2$1(b250, _2n$6, P5) * x6 % P5;
    return { pow_p_5_8, b2: b22 };
  }
  function adjustScalarBytes(bytes2) {
    bytes2[0] &= 248;
    bytes2[31] &= 127;
    bytes2[31] |= 64;
    return bytes2;
  }
  function uvRatio(u4, v6) {
    const P5 = ED25519_P;
    const v32 = mod$1(v6 * v6 * v6, P5);
    const v7 = mod$1(v32 * v32 * v6, P5);
    const pow3 = ed25519_pow_2_252_3(u4 * v7).pow_p_5_8;
    let x6 = mod$1(u4 * v32 * pow3, P5);
    const vx2 = mod$1(v6 * x6 * x6, P5);
    const root1 = x6;
    const root2 = mod$1(x6 * ED25519_SQRT_M1, P5);
    const useRoot1 = vx2 === u4;
    const useRoot2 = vx2 === mod$1(-u4, P5);
    const noRoot = vx2 === mod$1(-u4 * ED25519_SQRT_M1, P5);
    if (useRoot1)
      x6 = root1;
    if (useRoot2 || noRoot)
      x6 = root2;
    if (isNegativeLE(x6, P5))
      x6 = mod$1(-x6, P5);
    return { isValid: useRoot1 || useRoot2, value: x6 };
  }
  var Fp$3 = /* @__PURE__ */ (() => Field$1(ED25519_P, void 0, true))();
  var ed25519Defaults = /* @__PURE__ */ (() => ({
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp: Fp$3,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: _8n$1,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512$1,
    randomBytes: randomBytes$1,
    adjustScalarBytes,
    uvRatio
  }))();
  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();
  var SHA256_K$1 = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W$1 = /* @__PURE__ */ new Uint32Array(64);
  var SHA256$1 = class SHA256 extends HashMD {
    constructor() {
      super(64, 32, 8, false);
      this.A = SHA256_IV[0] | 0;
      this.B = SHA256_IV[1] | 0;
      this.C = SHA256_IV[2] | 0;
      this.D = SHA256_IV[3] | 0;
      this.E = SHA256_IV[4] | 0;
      this.F = SHA256_IV[5] | 0;
      this.G = SHA256_IV[6] | 0;
      this.H = SHA256_IV[7] | 0;
    }
    get() {
      const { A: A5, B: B6, C: C5, D: D4, E: E4, F: F4, G: G7, H: H4 } = this;
      return [A5, B6, C5, D4, E4, F4, G7, H4];
    }
    set(A5, B6, C5, D4, E4, F4, G7, H4) {
      this.A = A5 | 0;
      this.B = B6 | 0;
      this.C = C5 | 0;
      this.D = D4 | 0;
      this.E = E4 | 0;
      this.F = F4 | 0;
      this.G = G7 | 0;
      this.H = H4 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        SHA256_W$1[i4] = view.getUint32(offset, false);
      for (let i4 = 16; i4 < 64; i4++) {
        const W15 = SHA256_W$1[i4 - 15];
        const W22 = SHA256_W$1[i4 - 2];
        const s0 = rotr$1(W15, 7) ^ rotr$1(W15, 18) ^ W15 >>> 3;
        const s1 = rotr$1(W22, 17) ^ rotr$1(W22, 19) ^ W22 >>> 10;
        SHA256_W$1[i4] = s1 + SHA256_W$1[i4 - 7] + s0 + SHA256_W$1[i4 - 16] | 0;
      }
      let { A: A5, B: B6, C: C5, D: D4, E: E4, F: F4, G: G7, H: H4 } = this;
      for (let i4 = 0; i4 < 64; i4++) {
        const sigma1 = rotr$1(E4, 6) ^ rotr$1(E4, 11) ^ rotr$1(E4, 25);
        const T12 = H4 + sigma1 + Chi$1(E4, F4, G7) + SHA256_K$1[i4] + SHA256_W$1[i4] | 0;
        const sigma0 = rotr$1(A5, 2) ^ rotr$1(A5, 13) ^ rotr$1(A5, 22);
        const T22 = sigma0 + Maj$1(A5, B6, C5) | 0;
        H4 = G7;
        G7 = F4;
        F4 = E4;
        E4 = D4 + T12 | 0;
        D4 = C5;
        C5 = B6;
        B6 = A5;
        A5 = T12 + T22 | 0;
      }
      A5 = A5 + this.A | 0;
      B6 = B6 + this.B | 0;
      C5 = C5 + this.C | 0;
      D4 = D4 + this.D | 0;
      E4 = E4 + this.E | 0;
      F4 = F4 + this.F | 0;
      G7 = G7 + this.G | 0;
      H4 = H4 + this.H | 0;
      this.set(A5, B6, C5, D4, E4, F4, G7, H4);
    }
    roundClean() {
      SHA256_W$1.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256$3 = /* @__PURE__ */ wrapConstructor$1(() => new SHA256$1());
  var HMAC$1 = class HMAC extends Hash$1 {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash$1(hash2);
      const key = toBytes$1(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists$1(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists$1(this);
      bytes$1(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to2) {
      to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to2 = to2;
      to2.finished = finished;
      to2.destroyed = destroyed;
      to2.blockLen = blockLen;
      to2.outputLen = outputLen;
      to2.oHash = oHash._cloneInto(to2.oHash);
      to2.iHash = iHash._cloneInto(to2.iHash);
      return to2;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac$1 = (hash2, key, message) => new HMAC$1(hash2, key).update(message).digest();
  hmac$1.create = (hash2, key) => new HMAC$1(hash2, key);
  function validateSigVerOpts(opts) {
    if (opts.lowS !== void 0)
      abool("lowS", opts.lowS);
    if (opts.prehash !== void 0)
      abool("prehash", opts.prehash);
  }
  function validatePointOpts$1(curve2) {
    const opts = validateBasic$1(curve2);
    validateObject$1(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a: a4 } = opts;
    if (endo) {
      if (!Fp2.eql(a4, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n$1, hexToBytes: h2b$1 } = ut$1;
  var DER$1 = {
    Err: class DERErr extends Error {
      constructor(m5 = "") {
        super(m5);
      }
    },
    _tlv: {
      encode: (tag, data) => {
        const { Err: E4 } = DER$1;
        if (tag < 0 || tag > 256)
          throw new E4("tlv.encode: wrong tag");
        if (data.length & 1)
          throw new E4("tlv.encode: unpadded data");
        const dataLen = data.length / 2;
        const len = numberToHexUnpadded$1(dataLen);
        if (len.length / 2 & 128)
          throw new E4("tlv.encode: long form length too big");
        const lenLen = dataLen > 127 ? numberToHexUnpadded$1(len.length / 2 | 128) : "";
        return `${numberToHexUnpadded$1(tag)}${lenLen}${len}${data}`;
      },
      decode(tag, data) {
        const { Err: E4 } = DER$1;
        let pos = 0;
        if (tag < 0 || tag > 256)
          throw new E4("tlv.encode: wrong tag");
        if (data.length < 2 || data[pos++] !== tag)
          throw new E4("tlv.decode: wrong tlv");
        const first = data[pos++];
        const isLong = !!(first & 128);
        let length2 = 0;
        if (!isLong)
          length2 = first;
        else {
          const lenLen = first & 127;
          if (!lenLen)
            throw new E4("tlv.decode(long): indefinite length not supported");
          if (lenLen > 4)
            throw new E4("tlv.decode(long): byte length is too big");
          const lengthBytes = data.subarray(pos, pos + lenLen);
          if (lengthBytes.length !== lenLen)
            throw new E4("tlv.decode: length bytes not complete");
          if (lengthBytes[0] === 0)
            throw new E4("tlv.decode(long): zero leftmost byte");
          for (const b7 of lengthBytes)
            length2 = length2 << 8 | b7;
          pos += lenLen;
          if (length2 < 128)
            throw new E4("tlv.decode(long): not minimal encoding");
        }
        const v6 = data.subarray(pos, pos + length2);
        if (v6.length !== length2)
          throw new E4("tlv.decode: wrong value length");
        return { v: v6, l: data.subarray(pos + length2) };
      }
    },
    _int: {
      encode(num) {
        const { Err: E4 } = DER$1;
        if (num < _0n$6)
          throw new E4("integer: negative integers are not allowed");
        let hex2 = numberToHexUnpadded$1(num);
        if (Number.parseInt(hex2[0], 16) & 8)
          hex2 = "00" + hex2;
        if (hex2.length & 1)
          throw new E4("unexpected assertion");
        return hex2;
      },
      decode(data) {
        const { Err: E4 } = DER$1;
        if (data[0] & 128)
          throw new E4("Invalid signature integer: negative");
        if (data[0] === 0 && !(data[1] & 128))
          throw new E4("Invalid signature integer: unnecessary leading zero");
        return b2n$1(data);
      }
    },
    toSig(hex2) {
      const { Err: E4, _int: int, _tlv: tlv } = DER$1;
      const data = typeof hex2 === "string" ? h2b$1(hex2) : hex2;
      abytes(data);
      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
      if (seqLeftBytes.length)
        throw new E4("Invalid signature: left bytes after parsing");
      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
      if (sLeftBytes.length)
        throw new E4("Invalid signature: left bytes after parsing");
      return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
      const { _tlv: tlv, _int: int } = DER$1;
      const seq = `${tlv.encode(2, int.encode(sig.r))}${tlv.encode(2, int.encode(sig.s))}`;
      return tlv.encode(48, seq);
    }
  };
  var _0n$6 = BigInt(0);
  var _1n$8 = BigInt(1);
  BigInt(2);
  var _3n$2 = BigInt(3);
  BigInt(4);
  function weierstrassPoints$1(opts) {
    const CURVE = validatePointOpts$1(opts);
    const { Fp: Fp2 } = CURVE;
    const Fn2 = Field$1(CURVE.n, CURVE.nBitLength);
    const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
      const a4 = point.toAffine();
      return concatBytes$2(Uint8Array.from([4]), Fp2.toBytes(a4.x), Fp2.toBytes(a4.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x6 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y5 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x: x6, y: y5 };
    });
    function weierstrassEquation(x6) {
      const { a: a4, b: b7 } = CURVE;
      const x22 = Fp2.sqr(x6);
      const x32 = Fp2.mul(x22, x6);
      return Fp2.add(Fp2.add(x32, Fp2.mul(x6, a4)), b7);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return inRange(num, _1n$8, CURVE.n);
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N10 } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (isBytes$1(key))
          key = bytesToHex$2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE$1(ensureBytes$1("private key", key, nByteLength));
      } catch (error2) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod$1(num, N10);
      aInRange("private key", num, _1n$8, N10);
      return num;
    }
    function assertPrjPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }
    const toAffineMemo = memoized((p6, iz) => {
      const { px: x6, py: y5, pz: z6 } = p6;
      if (Fp2.eql(z6, Fp2.ONE))
        return { x: x6, y: y5 };
      const is0 = p6.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z6);
      const ax = Fp2.mul(x6, iz);
      const ay = Fp2.mul(y5, iz);
      const zz = Fp2.mul(z6, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    });
    const assertValidMemo = memoized((p6) => {
      if (p6.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(p6.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x6, y: y5 } = p6.toAffine();
      if (!Fp2.isValid(x6) || !Fp2.isValid(y5))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y5);
      const right = weierstrassEquation(x6);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!p6.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
      return true;
    });
    class Point {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
        Object.freeze(this);
      }
      static fromAffine(p6) {
        const { x: x6, y: y5 } = p6 || {};
        if (!p6 || !Fp2.isValid(x6) || !Fp2.isValid(y5))
          throw new Error("invalid affine point");
        if (p6 instanceof Point)
          throw new Error("projective point not allowed");
        const is0 = (i4) => Fp2.eql(i4, Fp2.ZERO);
        if (is0(x6) && is0(y5))
          return Point.ZERO;
        return new Point(x6, y5, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p6) => p6.pz));
        return points.map((p6, i4) => p6.toAffine(toInv[i4])).map(Point.fromAffine);
      }
      static fromHex(hex2) {
        const P5 = Point.fromAffine(fromBytes(ensureBytes$1("pointHex", hex2)));
        P5.assertValidity();
        return P5;
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      static msm(points, scalars) {
        return pippenger(Point, Fn2, points, scalars);
      }
      _setWindowSize(windowSize) {
        wnaf.setWindowSize(this, windowSize);
      }
      assertValidity() {
        assertValidMemo(this);
      }
      hasEvenY() {
        const { y: y5 } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y5);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X22, Z1));
        const U22 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
        return U1 && U22;
      }
      negate() {
        return new Point(this.px, Fp2.neg(this.py), this.pz);
      }
      double() {
        const { a: a4, b: b7 } = CURVE;
        const b32 = Fp2.mul(b7, _3n$2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X32 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z32 = Fp2.mul(X1, Z1);
        Z32 = Fp2.add(Z32, Z32);
        X32 = Fp2.mul(a4, Z32);
        Y32 = Fp2.mul(b32, t2);
        Y32 = Fp2.add(X32, Y32);
        X32 = Fp2.sub(t1, Y32);
        Y32 = Fp2.add(t1, Y32);
        Y32 = Fp2.mul(X32, Y32);
        X32 = Fp2.mul(t3, X32);
        Z32 = Fp2.mul(b32, Z32);
        t2 = Fp2.mul(a4, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a4, t3);
        t3 = Fp2.add(t3, Z32);
        Z32 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z32, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y32 = Fp2.add(Y32, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X32 = Fp2.sub(X32, t0);
        Z32 = Fp2.mul(t2, t1);
        Z32 = Fp2.add(Z32, Z32);
        Z32 = Fp2.add(Z32, Z32);
        return new Point(X32, Y32, Z32);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        let X32 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        const a4 = CURVE.a;
        const b32 = Fp2.mul(CURVE.b, _3n$2);
        let t0 = Fp2.mul(X1, X22);
        let t1 = Fp2.mul(Y1, Y22);
        let t2 = Fp2.mul(Z1, Z22);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X22, Y22);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X22, Z22);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X32 = Fp2.add(Y22, Z22);
        t5 = Fp2.mul(t5, X32);
        X32 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X32);
        Z32 = Fp2.mul(a4, t4);
        X32 = Fp2.mul(b32, t2);
        Z32 = Fp2.add(X32, Z32);
        X32 = Fp2.sub(t1, Z32);
        Z32 = Fp2.add(t1, Z32);
        Y32 = Fp2.mul(X32, Z32);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a4, t2);
        t4 = Fp2.mul(b32, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a4, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y32 = Fp2.add(Y32, t0);
        t0 = Fp2.mul(t5, t4);
        X32 = Fp2.mul(t3, X32);
        X32 = Fp2.sub(X32, t0);
        t0 = Fp2.mul(t3, t1);
        Z32 = Fp2.mul(t5, Z32);
        Z32 = Fp2.add(Z32, t0);
        return new Point(X32, Y32, Z32);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      wNAF(n4) {
        return wnaf.wNAFCached(this, n4, Point.normalizeZ);
      }
      multiplyUnsafe(sc2) {
        aInRange("scalar", sc2, _0n$6, CURVE.n);
        const I5 = Point.ZERO;
        if (sc2 === _0n$6)
          return I5;
        if (sc2 === _1n$8)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, sc2);
        let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(sc2);
        let k1p = I5;
        let k2p = I5;
        let d5 = this;
        while (k1 > _0n$6 || k22 > _0n$6) {
          if (k1 & _1n$8)
            k1p = k1p.add(d5);
          if (k22 & _1n$8)
            k2p = k2p.add(d5);
          d5 = d5.double();
          k1 >>= _1n$8;
          k22 >>= _1n$8;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        const { endo, n: N10 } = CURVE;
        aInRange("scalar", scalar, _1n$8, N10);
        let point, fake;
        if (endo) {
          const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(scalar);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k22);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p6, f: f5 } = this.wNAF(scalar);
          point = p6;
          fake = f5;
        }
        return Point.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q5, a4, b7) {
        const G7 = Point.BASE;
        const mul2 = (P5, a5) => a5 === _0n$6 || a5 === _1n$8 || !P5.equals(G7) ? P5.multiplyUnsafe(a5) : P5.multiply(a5);
        const sum = mul2(this, a4).add(mul2(Q5, b7));
        return sum.is0() ? void 0 : sum;
      }
      toAffine(iz) {
        return toAffineMemo(this, iz);
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n$8)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n$8)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        abool("isCompressed", isCompressed);
        this.assertValidity();
        return toBytes2(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        abool("isCompressed", isCompressed);
        return bytesToHex$2(this.toRawBytes(isCompressed));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF$1(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts$1(curve2) {
    const opts = validateBasic$1(curve2);
    validateObject$1(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass$1(curveDef) {
    const CURVE = validateOpts$1(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function modN(a4) {
      return mod$1(a4, CURVE_ORDER);
    }
    function invN(a4) {
      return invert$1(a4, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints$1({
      ...CURVE,
      toBytes(_c2, point, isCompressed) {
        const a4 = point.toAffine();
        const x6 = Fp2.toBytes(a4.x);
        const cat = concatBytes$2;
        abool("isCompressed", isCompressed);
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x6);
        } else {
          return cat(Uint8Array.from([4]), x6, Fp2.toBytes(a4.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head2 = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head2 === 2 || head2 === 3)) {
          const x6 = bytesToNumberBE$1(tail);
          if (!inRange(x6, _1n$8, Fp2.ORDER))
            throw new Error("Point is not on curve");
          const y22 = weierstrassEquation(x6);
          let y5;
          try {
            y5 = Fp2.sqrt(y22);
          } catch (sqrtError) {
            const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("Point is not on curve" + suffix);
          }
          const isYOdd = (y5 & _1n$8) === _1n$8;
          const isHeadOdd = (head2 & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y5 = Fp2.neg(y5);
          return { x: x6, y: y5 };
        } else if (len === uncompressedLen && head2 === 4) {
          const x6 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y5 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x: x6, y: y5 };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex$2(numberToBytesBE$1(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n$8;
      return number2 > HALF;
    }
    function normalizeS(s3) {
      return isBiggerThanHalfOrder(s3) ? modN(-s3) : s3;
    }
    const slcNum = (b7, from2, to2) => bytesToNumberBE$1(b7.slice(from2, to2));
    class Signature2 {
      constructor(r, s3, recovery) {
        this.r = r;
        this.s = s3;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex2) {
        const l6 = CURVE.nByteLength;
        hex2 = ensureBytes$1("compactSignature", hex2, l6 * 2);
        return new Signature2(slcNum(hex2, 0, l6), slcNum(hex2, l6, 2 * l6));
      }
      static fromDER(hex2) {
        const { r, s: s3 } = DER$1.toSig(ensureBytes$1("DER", hex2));
        return new Signature2(r, s3);
      }
      assertValidity() {
        aInRange("r", this.r, _1n$8, CURVE_ORDER);
        aInRange("s", this.s, _1n$8, CURVE_ORDER);
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s: s3, recovery: rec } = this;
        const h6 = bits2int_modN(ensureBytes$1("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R5 = Point.fromHex(prefix + numToNByteStr(radj));
        const ir2 = invN(radj);
        const u1 = modN(-h6 * ir2);
        const u22 = modN(s3 * ir2);
        const Q5 = Point.BASE.multiplyAndAddUnsafe(R5, u1, u22);
        if (!Q5)
          throw new Error("point at infinify");
        Q5.assertValidity();
        return Q5;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return hexToBytes$2(this.toDERHex());
      }
      toDERHex() {
        return DER$1.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return hexToBytes$2(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error2) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const length2 = getMinHashLength$1(CURVE.n);
        return mapHashToField$1(CURVE.randomBytes(length2), CURVE.n);
      },
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = isBytes$1(item);
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b7 = Point.fromHex(publicB);
      return b7.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE$1(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask$1(CURVE.nBitLength);
    function int2octets(num) {
      aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n$6, ORDER_MASK);
      return numberToBytesBE$1(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k5) => k5 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes$1("msgHash", msgHash);
      validateSigVerOpts(opts);
      if (prehash)
        msgHash = ensureBytes$1("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d5 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d5), int2octets(h1int)];
      if (ent != null && ent !== false) {
        const e7 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes$1("extraEntropy", e7));
      }
      const seed = concatBytes$2(...seedArgs);
      const m5 = h1int;
      function k2sig(kBytes) {
        const k5 = bits2int(kBytes);
        if (!isWithinCurveOrder(k5))
          return;
        const ik = invN(k5);
        const q5 = Point.BASE.multiply(k5).toAffine();
        const r = modN(q5.x);
        if (r === _0n$6)
          return;
        const s3 = modN(ik * modN(m5 + r * d5));
        if (s3 === _0n$6)
          return;
        let recovery = (q5.x === r ? 0 : 2) | Number(q5.y & _1n$8);
        let normS = s3;
        if (lowS && isBiggerThanHalfOrder(s3)) {
          normS = normalizeS(s3);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C5 = CURVE;
      const drbg = createHmacDrbg$1(C5.hash.outputLen, C5.nByteLength, C5.hmac);
      return drbg(seed, k2sig);
    }
    Point.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey2, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes$1("msgHash", msgHash);
      publicKey2 = ensureBytes$1("publicKey", publicKey2);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      validateSigVerOpts(opts);
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P5;
      try {
        if (typeof sg === "string" || isBytes$1(sg)) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER$1.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s4 } = sg;
          _sig = new Signature2(r2, s4);
        } else {
          throw new Error("PARSE");
        }
        P5 = Point.fromHex(publicKey2);
      } catch (error2) {
        if (error2.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s: s3 } = _sig;
      const h6 = bits2int_modN(msgHash);
      const is2 = invN(s3);
      const u1 = modN(h6 * is2);
      const u22 = modN(r * is2);
      const R5 = Point.BASE.multiplyAndAddUnsafe(P5, u1, u22)?.toAffine();
      if (!R5)
        return false;
      const v6 = modN(R5.x);
      return v6 === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point,
      Signature: Signature2,
      utils: utils2
    };
  }
  function getHash$1(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac$1(hash2, key, concatBytes$3(...msgs)),
      randomBytes: randomBytes$1
    };
  }
  function createCurve$1(curveDef, defHash) {
    const create = (hash2) => weierstrass$1({ ...curveDef, ...getHash$1(hash2) });
    return Object.freeze({ ...create(defHash), create });
  }
  var secp256k1P$1 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N$1 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n$7 = BigInt(1);
  var _2n$5 = BigInt(2);
  var divNearest$1 = (a4, b7) => (a4 + b7 / _2n$5) / b7;
  function sqrtMod$1(y5) {
    const P5 = secp256k1P$1;
    const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b22 = y5 * y5 * y5 % P5;
    const b32 = b22 * b22 * y5 % P5;
    const b62 = pow2$1(b32, _3n2, P5) * b32 % P5;
    const b9 = pow2$1(b62, _3n2, P5) * b32 % P5;
    const b11 = pow2$1(b9, _2n$5, P5) * b22 % P5;
    const b222 = pow2$1(b11, _11n, P5) * b11 % P5;
    const b44 = pow2$1(b222, _22n, P5) * b222 % P5;
    const b88 = pow2$1(b44, _44n, P5) * b44 % P5;
    const b176 = pow2$1(b88, _88n, P5) * b88 % P5;
    const b220 = pow2$1(b176, _44n, P5) * b44 % P5;
    const b223 = pow2$1(b220, _3n2, P5) * b32 % P5;
    const t1 = pow2$1(b223, _23n, P5) * b222 % P5;
    const t2 = pow2$1(t1, _6n, P5) * b22 % P5;
    const root = pow2$1(t2, _2n$5, P5);
    if (!Fp$2.eql(Fp$2.sqr(root), y5))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp$2 = Field$1(secp256k1P$1, void 0, void 0, { sqrt: sqrtMod$1 });
  var secp256k1$1 = createCurve$1({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fp$2,
    n: secp256k1N$1,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k5) => {
        const n4 = secp256k1N$1;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n$7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b22 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest$1(b22 * k5, n4);
        const c22 = divNearest$1(-b1 * k5, n4);
        let k1 = mod$1(k5 - c1 * a1 - c22 * a22, n4);
        let k22 = mod$1(-c1 * b1 - c22 * b22, n4);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n4 - k1;
        if (k2neg)
          k22 = n4 - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k5);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    }
  }, sha256$3);
  BigInt(0);
  function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
  }
  function allocUnsafe(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return asUint8Array(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
  }
  function concat$2(arrays, length2) {
    if (!length2) {
      length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe(length2);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output2);
  }
  function base$2(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j5 = 0; j5 < BASE_MAP.length; j5++) {
      BASE_MAP[j5] = 255;
    }
    for (var i4 = 0; i4 < ALPHABET.length; i4++) {
      var x6 = ALPHABET.charAt(i4);
      var xc2 = x6.charCodeAt(0);
      if (BASE_MAP[xc2] !== 255) {
        throw new TypeError(x6 + " is ambiguous");
      }
      BASE_MAP[xc2] = i4;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i5 = 0;
        for (var it1 = size - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i5;
        pbegin++;
      }
      var it22 = size - length2;
      while (it22 !== size && b58[it22] === 0) {
        it22++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it22 < size; ++it22) {
        str += ALPHABET.charAt(b58[it22]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i5 = 0;
        for (var it3 = size - 1; (carry !== 0 || i5 < length2) && it3 !== -1; it3--, i5++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i5;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j6 = zeroes;
      while (it4 !== size) {
        vch[j6++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string3) {
      var buffer = decodeUnsafe(string3);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src$2 = base$2;
  var _brrp__multiformats_scope_baseX = src$2;
  var coerce = (o4) => {
    if (o4 instanceof Uint8Array && o4.constructor.name === "Uint8Array")
      return o4;
    if (o4 instanceof ArrayBuffer)
      return new Uint8Array(o4);
    if (ArrayBuffer.isView(o4)) {
      return new Uint8Array(o4.buffer, o4.byteOffset, o4.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
  };
  var fromString$1 = (str) => new TextEncoder().encode(str);
  var toString$22 = (b7) => new TextDecoder().decode(b7);
  var Encoder = class {
    constructor(name, prefix, baseEncode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }
    encode(bytes2) {
      if (bytes2 instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes2)}`;
      } else {
        throw Error("Unknown type, must be binary type");
      }
    }
  };
  var Decoder = class {
    constructor(name, prefix, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      if (prefix.codePointAt(0) === void 0) {
        throw new Error("Invalid prefix character");
      }
      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }
    decode(text) {
      if (typeof text === "string") {
        if (text.codePointAt(0) !== this.prefixCodePoint) {
          throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        }
        return this.baseDecode(text.slice(this.prefix.length));
      } else {
        throw Error("Can only multibase decode strings");
      }
    }
    or(decoder) {
      return or2(this, decoder);
    }
  };
  var ComposedDecoder = class {
    constructor(decoders) {
      this.decoders = decoders;
    }
    or(decoder) {
      return or2(this, decoder);
    }
    decode(input) {
      const prefix = input[0];
      const decoder = this.decoders[prefix];
      if (decoder) {
        return decoder.decode(input);
      } else {
        throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
      }
    }
  };
  var or2 = (left, right) => new ComposedDecoder({
    ...left.decoders || { [left.prefix]: left },
    ...right.decoders || { [right.prefix]: right }
  });
  var Codec = class {
    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name, prefix, baseEncode);
      this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
      return this.encoder.encode(input);
    }
    decode(input) {
      return this.decoder.decode(input);
    }
  };
  var from = ({ name, prefix, encode: encode2, decode: decode2 }) => new Codec(name, prefix, encode2, decode2);
  var baseX$1 = ({ prefix, name, alphabet: alphabet3 }) => {
    const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet3, name);
    return from({
      prefix,
      name,
      encode: encode2,
      decode: (text) => coerce(decode2(text))
    });
  };
  var decode$4 = (string3, alphabet3, bitsPerChar, name) => {
    const codes3 = {};
    for (let i4 = 0; i4 < alphabet3.length; ++i4) {
      codes3[alphabet3[i4]] = i4;
    }
    let end = string3.length;
    while (string3[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i4 = 0; i4 < end; ++i4) {
      const value = codes3[string3[i4]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${name} character`);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode$3 = (data, alphabet3, bitsPerChar) => {
    const pad = alphabet3[alphabet3.length - 1] === "=";
    const mask2 = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i4 = 0; i4 < data.length; ++i4) {
      buffer = buffer << 8 | data[i4];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet3[mask2 & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet3[mask2 & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$2 = ({ name, prefix, bitsPerChar, alphabet: alphabet3 }) => {
    return from({
      prefix,
      name,
      encode(input) {
        return encode$3(input, alphabet3, bitsPerChar);
      },
      decode(input) {
        return decode$4(input, alphabet3, bitsPerChar, name);
      }
    });
  };
  var identity$1 = from({
    prefix: "\0",
    name: "identity",
    encode: (buf) => toString$22(buf),
    decode: (str) => fromString$1(str)
  });
  var identityBase = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    identity: identity$1
  });
  var base2 = rfc4648$2({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var base2$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base2
  });
  var base8 = rfc4648$2({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var base8$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base8
  });
  var base10 = baseX$1({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var base10$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base10
  });
  var base16 = rfc4648$2({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  });
  var base16upper = rfc4648$2({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var base16$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base16,
    base16upper
  });
  var base32 = rfc4648$2({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  });
  var base32upper = rfc4648$2({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  });
  var base32pad = rfc4648$2({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  });
  var base32padupper = rfc4648$2({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  });
  var base32hex = rfc4648$2({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648$2({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648$2({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648$2({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  });
  var base32z = rfc4648$2({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var base32$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base32,
    base32hex,
    base32hexpad,
    base32hexpadupper,
    base32hexupper,
    base32pad,
    base32padupper,
    base32upper,
    base32z
  });
  var base36 = baseX$1({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  });
  var base36upper = baseX$1({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var base36$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base36,
    base36upper
  });
  var base58btc = baseX$1({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  });
  var base58flickr = baseX$1({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var base58 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base58btc,
    base58flickr
  });
  var base642 = rfc4648$2({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  });
  var base64pad = rfc4648$2({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  });
  var base64url = rfc4648$2({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648$2({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });
  var base64$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base64: base642,
    base64pad,
    base64url,
    base64urlpad
  });
  var alphabet$1 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
  var alphabetBytesToChars = alphabet$1.reduce((p6, c3, i4) => {
    p6[i4] = c3;
    return p6;
  }, []);
  var alphabetCharsToBytes = alphabet$1.reduce((p6, c3, i4) => {
    p6[c3.codePointAt(0)] = i4;
    return p6;
  }, []);
  function encode$2(data) {
    return data.reduce((p6, c3) => {
      p6 += alphabetBytesToChars[c3];
      return p6;
    }, "");
  }
  function decode$3(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var base256emoji = from({
    prefix: "\u{1F680}",
    name: "base256emoji",
    encode: encode$2,
    decode: decode$3
  });
  var base256emoji$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    base256emoji
  });
  var encode_1 = encode$1;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode$1(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode$1.bytes = offset - oldOffset + 1;
    return out;
  }
  var decode$2 = read;
  var MSB$1 = 128;
  var REST$1 = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b7, l6 = buf.length;
    do {
      if (counter >= l6) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b7 = buf[counter++];
      res += shift < 28 ? (b7 & REST$1) << shift : (b7 & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b7 >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var N1 = Math.pow(2, 7);
  var N22 = Math.pow(2, 14);
  var N32 = Math.pow(2, 21);
  var N42 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  var length = function(value) {
    return value < N1 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
  var varint2 = {
    encode: encode_1,
    decode: decode$2,
    encodingLength: length
  };
  var _brrp_varint = varint2;
  var decode$1 = (data, offset = 0) => {
    const code2 = _brrp_varint.decode(data, offset);
    return [
      code2,
      _brrp_varint.decode.bytes
    ];
  };
  var bases = {
    ...identityBase,
    ...base2$1,
    ...base8$1,
    ...base10$1,
    ...base16$1,
    ...base32$1,
    ...base36$1,
    ...base58,
    ...base64$1,
    ...base256emoji$1
  };
  function createCodec(name, prefix, encode2, decode2) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode: encode2
      },
      decoder: { decode: decode2 }
    };
  }
  var string2 = createCodec("utf8", "u", (buf) => {
    const decoder = new TextDecoder("utf8");
    return "u" + decoder.decode(buf);
  }, (str) => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  var ascii2 = createCodec("ascii", "a", (buf) => {
    let string3 = "a";
    for (let i4 = 0; i4 < buf.length; i4++) {
      string3 += String.fromCharCode(buf[i4]);
    }
    return string3;
  }, (str) => {
    str = str.substring(1);
    const buf = allocUnsafe(str.length);
    for (let i4 = 0; i4 < str.length; i4++) {
      buf[i4] = str.charCodeAt(i4);
    }
    return buf;
  });
  var BASES = {
    utf8: string2,
    "utf-8": string2,
    hex: bases.base16,
    latin1: ascii2,
    ascii: ascii2,
    binary: ascii2,
    ...bases
  };
  function fromString2(string3, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return asUint8Array(globalThis.Buffer.from(string3, "utf-8"));
    }
    return base3.decoder.decode(`${base3.prefix}${string3}`);
  }
  function toString$12(array, encoding = "utf8") {
    const base3 = BASES[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
    }
    return base3.encoder.encode(array).substring(1);
  }
  var src$1 = { exports: {} };
  function base$1(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j5 = 0; j5 < BASE_MAP.length; j5++) {
      BASE_MAP[j5] = 255;
    }
    for (var i4 = 0; i4 < ALPHABET.length; i4++) {
      var x6 = ALPHABET.charAt(i4);
      var xc2 = x6.charCodeAt(0);
      if (BASE_MAP[xc2] !== 255) {
        throw new TypeError(x6 + " is ambiguous");
      }
      BASE_MAP[xc2] = i4;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode2(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i5 = 0;
        for (var it1 = size - 1; (carry !== 0 || i5 < length2) && it1 !== -1; it1--, i5++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i5;
        pbegin++;
      }
      var it22 = size - length2;
      while (it22 !== size && b58[it22] === 0) {
        it22++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it22 < size; ++it22) {
        str += ALPHABET.charAt(b58[it22]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i5 = 0;
        for (var it3 = size - 1; (carry !== 0 || i5 < length2) && it3 !== -1; it3--, i5++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i5;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j6 = zeroes;
      while (it4 !== size) {
        vch[j6++] = b256[it4++];
      }
      return vch;
    }
    function decode2(string3) {
      var buffer = decodeUnsafe(string3);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode: encode2,
      decodeUnsafe,
      decode: decode2
    };
  }
  var src = base$1;
  var textDecoder = new TextDecoder();
  var decodeText$1 = (bytes2) => textDecoder.decode(bytes2);
  var textEncoder = new TextEncoder();
  var encodeText$2 = (text) => textEncoder.encode(text);
  function concat$1(arrs, length2) {
    const output2 = new Uint8Array(length2);
    let offset = 0;
    for (const arr of arrs) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return output2;
  }
  var util$7 = { decodeText: decodeText$1, encodeText: encodeText$2, concat: concat$1 };
  var { encodeText: encodeText$1 } = util$7;
  var Base$1 = class Base {
    constructor(name, code2, factory2, alphabet3) {
      this.name = name;
      this.code = code2;
      this.codeBuf = encodeText$1(this.code);
      this.alphabet = alphabet3;
      this.codec = factory2(alphabet3);
    }
    encode(buf) {
      return this.codec.encode(buf);
    }
    decode(string3) {
      for (const char of string3) {
        if (this.alphabet && this.alphabet.indexOf(char) < 0) {
          throw new Error(`invalid character '${char}' in '${string3}'`);
        }
      }
      return this.codec.decode(string3);
    }
  };
  var base = Base$1;
  var decode = (string3, alphabet3, bitsPerChar) => {
    const codes3 = {};
    for (let i4 = 0; i4 < alphabet3.length; ++i4) {
      codes3[alphabet3[i4]] = i4;
    }
    let end = string3.length;
    while (string3[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits2 = 0;
    let buffer = 0;
    let written = 0;
    for (let i4 = 0; i4 < end; ++i4) {
      const value = codes3[string3[i4]];
      if (value === void 0) {
        throw new SyntaxError("Invalid character " + string3[i4]);
      }
      buffer = buffer << bitsPerChar | value;
      bits2 += bitsPerChar;
      if (bits2 >= 8) {
        bits2 -= 8;
        out[written++] = 255 & buffer >> bits2;
      }
    }
    if (bits2 >= bitsPerChar || 255 & buffer << 8 - bits2) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode = (data, alphabet3, bitsPerChar) => {
    const pad = alphabet3[alphabet3.length - 1] === "=";
    const mask2 = (1 << bitsPerChar) - 1;
    let out = "";
    let bits2 = 0;
    let buffer = 0;
    for (let i4 = 0; i4 < data.length; ++i4) {
      buffer = buffer << 8 | data[i4];
      bits2 += 8;
      while (bits2 > bitsPerChar) {
        bits2 -= bitsPerChar;
        out += alphabet3[mask2 & buffer >> bits2];
      }
    }
    if (bits2) {
      out += alphabet3[mask2 & buffer << bitsPerChar - bits2];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648$1 = (bitsPerChar) => (alphabet3) => {
    return {
      encode(input) {
        return encode(input, alphabet3, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabet3, bitsPerChar);
      }
    };
  };
  var rfc4648_1 = { rfc4648: rfc4648$1 };
  var baseX = src;
  var Base2 = base;
  var { rfc4648 } = rfc4648_1;
  var { decodeText, encodeText } = util$7;
  var identity = () => {
    return {
      encode: decodeText,
      decode: encodeText
    };
  };
  var constants$2 = [
    ["identity", "\0", identity, ""],
    ["base2", "0", rfc4648(1), "01"],
    ["base8", "7", rfc4648(3), "01234567"],
    ["base10", "9", baseX, "0123456789"],
    ["base16", "f", rfc4648(4), "0123456789abcdef"],
    ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
    ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
    ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
    ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
    ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
    ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
    ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
    ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
    ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
    ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
    ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
    ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
    ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
    ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
    ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
    ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
    ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
    ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
  ];
  var names$2 = constants$2.reduce((prev2, tupple) => {
    prev2[tupple[0]] = new Base2(tupple[0], tupple[1], tupple[2], tupple[3]);
    return prev2;
  }, {});
  var codes2 = constants$2.reduce((prev2, tupple) => {
    prev2[tupple[1]] = names$2[tupple[0]];
    return prev2;
  }, {});
  var constants_1 = {
    names: names$2,
    codes: codes2
  };
  (function(module, exports) {
    const constants = constants_1;
    const { encodeText: encodeText2, decodeText: decodeText2, concat: concat2 } = util$7;
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat2([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode2(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText2(enc.encode(buf));
      return concat2([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode2(data) {
      if (data instanceof Uint8Array) {
        data = decodeText2(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(data[0]);
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText2(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(data[0]);
        return enc.name;
      } catch (err) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText2(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(constants.names, nameOrCode)) {
        return constants.names[nameOrCode];
      } else if (Object.prototype.hasOwnProperty.call(constants.codes, nameOrCode)) {
        return constants.codes[nameOrCode];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText2(data);
      }
      return encoding(data[0]);
    }
    exports = module.exports = multibase;
    exports.encode = encode2;
    exports.decode = decode2;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    const names = Object.freeze(constants.names);
    const codes3 = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes3;
  })(src$1, src$1.exports);
  var srcExports = src$1.exports;
  var Fp$1 = Field$1(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
  var CURVE_A = Fp$1.create(BigInt("-3"));
  var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
  var p256 = createCurve$1({
    a: CURVE_A,
    b: CURVE_B,
    Fp: Fp$1,
    n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
    Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
    Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
    h: BigInt(1),
    lowS: false
  }, sha256$3);
  var Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id2 = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((_5, i4) => i4));
  var Pi2 = /* @__PURE__ */ Id2.map((i4) => (9 * i4 + 5) % 16);
  var idxL = [Id2];
  var idxR = [Pi2];
  for (let i4 = 0; i4 < 4; i4++)
    for (let j5 of [idxL, idxR])
      j5.push(j5[i4].map((k5) => Rho[k5]));
  var shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i4) => new Uint8Array(i4));
  var shiftsL = /* @__PURE__ */ idxL.map((idx, i4) => idx.map((j5) => shifts[i4][j5]));
  var shiftsR = /* @__PURE__ */ idxR.map((idx, i4) => idx.map((j5) => shifts[i4][j5]));
  var Kl2 = /* @__PURE__ */ new Uint32Array([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr2 = /* @__PURE__ */ new Uint32Array([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function f$1(group, x6, y5, z6) {
    if (group === 0)
      return x6 ^ y5 ^ z6;
    else if (group === 1)
      return x6 & y5 | ~x6 & z6;
    else if (group === 2)
      return (x6 | ~y5) ^ z6;
    else if (group === 3)
      return x6 & z6 | y5 & ~z6;
    else
      return x6 ^ (y5 | ~z6);
  }
  var R_BUF = /* @__PURE__ */ new Uint32Array(16);
  var RIPEMD160 = class extends HashMD {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
      return [h0, h1, h22, h32, h42];
    }
    set(h0, h1, h22, h32, h42) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h22 | 0;
      this.h3 = h32 | 0;
      this.h4 = h42 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        R_BUF[i4] = view.getUint32(offset, true);
      let al2 = this.h0 | 0, ar2 = al2, bl2 = this.h1 | 0, br2 = bl2, cl2 = this.h2 | 0, cr2 = cl2, dl2 = this.h3 | 0, dr2 = dl2, el2 = this.h4 | 0, er2 = el2;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl2[group], hbr = Kr2[group];
        const rl2 = idxL[group], rr2 = idxR[group];
        const sl2 = shiftsL[group], sr2 = shiftsR[group];
        for (let i4 = 0; i4 < 16; i4++) {
          const tl2 = rotl(al2 + f$1(group, bl2, cl2, dl2) + R_BUF[rl2[i4]] + hbl, sl2[i4]) + el2 | 0;
          al2 = el2, el2 = dl2, dl2 = rotl(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
        }
        for (let i4 = 0; i4 < 16; i4++) {
          const tr2 = rotl(ar2 + f$1(rGroup, br2, cr2, dr2) + R_BUF[rr2[i4]] + hbr, sr2[i4]) + er2 | 0;
          ar2 = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
        }
      }
      this.set(this.h1 + cl2 + dr2 | 0, this.h2 + dl2 + er2 | 0, this.h3 + el2 + ar2 | 0, this.h4 + al2 + br2 | 0, this.h0 + bl2 + cr2 | 0);
    }
    roundClean() {
      R_BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = /* @__PURE__ */ wrapConstructor$1(() => new RIPEMD160());
  var SHA3_PI$1 = [];
  var SHA3_ROTL$1 = [];
  var _SHA3_IOTA$1 = [];
  var _0n$5 = /* @__PURE__ */ BigInt(0);
  var _1n$6 = /* @__PURE__ */ BigInt(1);
  var _2n$4 = /* @__PURE__ */ BigInt(2);
  var _7n$1 = /* @__PURE__ */ BigInt(7);
  var _256n$1 = /* @__PURE__ */ BigInt(256);
  var _0x71n$1 = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R5 = _1n$6, x6 = 1, y5 = 0; round < 24; round++) {
    [x6, y5] = [y5, (2 * x6 + 3 * y5) % 5];
    SHA3_PI$1.push(2 * (5 * y5 + x6));
    SHA3_ROTL$1.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n$5;
    for (let j5 = 0; j5 < 7; j5++) {
      R5 = (R5 << _1n$6 ^ (R5 >> _7n$1) * _0x71n$1) % _256n$1;
      if (R5 & _2n$4)
        t ^= _1n$6 << (_1n$6 << /* @__PURE__ */ BigInt(j5)) - _1n$6;
    }
    _SHA3_IOTA$1.push(t);
  }
  var [SHA3_IOTA_H$1, SHA3_IOTA_L$1] = /* @__PURE__ */ split$2(_SHA3_IOTA$1, true);
  var rotlH$1 = (h6, l6, s3) => s3 > 32 ? rotlBH$1(h6, l6, s3) : rotlSH$1(h6, l6, s3);
  var rotlL$1 = (h6, l6, s3) => s3 > 32 ? rotlBL$1(h6, l6, s3) : rotlSL$1(h6, l6, s3);
  function keccakP$1(s3, rounds = 24) {
    const B6 = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x6 = 0; x6 < 10; x6++)
        B6[x6] = s3[x6] ^ s3[x6 + 10] ^ s3[x6 + 20] ^ s3[x6 + 30] ^ s3[x6 + 40];
      for (let x6 = 0; x6 < 10; x6 += 2) {
        const idx1 = (x6 + 8) % 10;
        const idx0 = (x6 + 2) % 10;
        const B0 = B6[idx0];
        const B1 = B6[idx0 + 1];
        const Th2 = rotlH$1(B0, B1, 1) ^ B6[idx1];
        const Tl2 = rotlL$1(B0, B1, 1) ^ B6[idx1 + 1];
        for (let y5 = 0; y5 < 50; y5 += 10) {
          s3[x6 + y5] ^= Th2;
          s3[x6 + y5 + 1] ^= Tl2;
        }
      }
      let curH = s3[2];
      let curL = s3[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL$1[t];
        const Th2 = rotlH$1(curH, curL, shift);
        const Tl2 = rotlL$1(curH, curL, shift);
        const PI2 = SHA3_PI$1[t];
        curH = s3[PI2];
        curL = s3[PI2 + 1];
        s3[PI2] = Th2;
        s3[PI2 + 1] = Tl2;
      }
      for (let y5 = 0; y5 < 50; y5 += 10) {
        for (let x6 = 0; x6 < 10; x6++)
          B6[x6] = s3[y5 + x6];
        for (let x6 = 0; x6 < 10; x6++)
          s3[y5 + x6] ^= ~B6[(x6 + 2) % 10] & B6[(x6 + 4) % 10];
      }
      s3[0] ^= SHA3_IOTA_H$1[round];
      s3[1] ^= SHA3_IOTA_L$1[round];
    }
    B6.fill(0);
  }
  var Keccak$1 = class Keccak extends Hash$1 {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number$1(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32$1(this.state);
    }
    keccak() {
      if (!isLE$1)
        byteSwap32(this.state32);
      keccakP$1(this.state32, this.rounds);
      if (!isLE$1)
        byteSwap32(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists$1(this);
      const { blockLen, state } = this;
      data = toBytes$1(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i4 = 0; i4 < take; i4++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists$1(this, false);
      bytes$1(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number$1(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output$1(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to2) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to2 || (to2 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to2.state32.set(this.state32);
      to2.pos = this.pos;
      to2.posOut = this.posOut;
      to2.finished = this.finished;
      to2.rounds = rounds;
      to2.suffix = suffix;
      to2.outputLen = outputLen;
      to2.enableXOF = enableXOF;
      to2.destroyed = this.destroyed;
      return to2;
    }
  };
  var gen$1 = (suffix, blockLen, outputLen) => wrapConstructor$1(() => new Keccak$1(blockLen, suffix, outputLen));
  var keccak_256$1 = /* @__PURE__ */ gen$1(1, 136, 256 / 8);
  var PCT_ENCODED = "(?:%[0-9a-fA-F]{2})";
  var ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`;
  var METHOD = "([a-z0-9]+)";
  var METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`;
  var PARAM_CHAR = "[a-zA-Z0-9_.:%-]";
  var PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`;
  var PARAMS = `((${PARAM})*)`;
  var PATH = `(/[^#?]*)?`;
  var QUERY = `([?][^#]*)?`;
  var FRAGMENT = `(#.*)?`;
  var DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`);
  function isBytes(a4) {
    return a4 instanceof Uint8Array || a4 != null && typeof a4 === "object" && a4.constructor.name === "Uint8Array";
  }
  function chain(...args) {
    const id3 = (a4) => a4;
    const wrap = (a4, b7) => (c3) => a4(b7(c3));
    const encode2 = args.map((x6) => x6.encode).reduceRight(wrap, id3);
    const decode2 = args.map((x6) => x6.decode).reduce(wrap, id3);
    return { encode: encode2, decode: decode2 };
  }
  function alphabet2(alphabet3) {
    return {
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i4) => {
          if (i4 < 0 || i4 >= alphabet3.length)
            throw new Error(`Digit index outside alphabet: ${i4} (alphabet: ${alphabet3.length})`);
          return alphabet3[i4];
        });
      },
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index = alphabet3.indexOf(letter);
          if (index === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
          return index;
        });
      }
    };
  }
  function join(separator = "") {
    if (typeof separator !== "string")
      throw new Error("join separator should be string");
    return {
      encode: (from2) => {
        if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
          throw new Error("join.encode input should be array of strings");
        for (let i4 of from2)
          if (typeof i4 !== "string")
            throw new Error(`join.encode: non-string input=${i4}`);
        return from2.join(separator);
      },
      decode: (to2) => {
        if (typeof to2 !== "string")
          throw new Error("join.decode input should be string");
        return to2.split(separator);
      }
    };
  }
  var gcd = (a4, b7) => !b7 ? a4 : gcd(b7, a4 % b7);
  var radix2carry = (from2, to2) => from2 + (to2 - gcd(from2, to2));
  function convertRadix2(data, from2, to2, padding2) {
    if (!Array.isArray(data))
      throw new Error("convertRadix2: data should be array");
    if (from2 <= 0 || from2 > 32)
      throw new Error(`convertRadix2: wrong from=${from2}`);
    if (to2 <= 0 || to2 > 32)
      throw new Error(`convertRadix2: wrong to=${to2}`);
    if (radix2carry(from2, to2) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from2} to=${to2} carryBits=${radix2carry(from2, to2)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask2 = 2 ** to2 - 1;
    const res = [];
    for (const n4 of data) {
      if (n4 >= 2 ** from2)
        throw new Error(`convertRadix2: invalid data word=${n4} from=${from2}`);
      carry = carry << from2 | n4;
      if (pos + from2 > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
      pos += from2;
      for (; pos >= to2; pos -= to2)
        res.push((carry >> pos - to2 & mask2) >>> 0);
      carry &= 2 ** pos - 1;
    }
    carry = carry << to2 - pos & mask2;
    if (!padding2 && pos >= from2)
      throw new Error("Excess padding");
    if (!padding2 && carry)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  function radix2(bits2, revPadding = false) {
    if (bits2 <= 0 || bits2 > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits2) > 32 || radix2carry(bits2, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!isBytes(bytes2))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits2, !revPadding);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix2.decode input should be array of numbers");
        return Uint8Array.from(convertRadix2(digits, bits2, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn2) {
    if (typeof fn2 !== "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
      try {
        return fn2.apply(null, args);
      } catch (e7) {
      }
    };
  }
  var BECH_ALPHABET = /* @__PURE__ */ chain(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
  var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b7 = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i4 = 0; i4 < POLYMOD_GENERATORS.length; i4++) {
      if ((b7 >> i4 & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i4];
    }
    return chk;
  }
  function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i4 = 0; i4 < len; i4++) {
      const c3 = prefix.charCodeAt(i4);
      if (c3 < 33 || c3 > 126)
        throw new Error(`Invalid prefix (${prefix})`);
      chk = bech32Polymod(chk) ^ c3 >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i4 = 0; i4 < len; i4++)
      chk = bech32Polymod(chk) ^ prefix.charCodeAt(i4) & 31;
    for (let v6 of words)
      chk = bech32Polymod(chk) ^ v6;
    for (let i4 = 0; i4 < 6; i4++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
  }
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode2(prefix, words, limit2 = 90) {
      if (typeof prefix !== "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
      if (words instanceof Uint8Array)
        words = Array.from(words);
      if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
      if (prefix.length === 0)
        throw new TypeError(`Invalid prefix length ${prefix.length}`);
      const actualLength = prefix.length + 7 + words.length;
      if (limit2 !== false && actualLength > limit2)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
      const lowered = prefix.toLowerCase();
      const sum = bechChecksum(lowered, words, ENCODING_CONST);
      return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode2(str, limit2 = 90) {
      if (typeof str !== "string")
        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
      if (str.length < 8 || limit2 !== false && str.length > limit2)
        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      const sepIndex = lowered.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix = lowered.slice(0, sepIndex);
      const data = lowered.slice(sepIndex + 1);
      if (data.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(data).slice(0, -6);
      const sum = bechChecksum(prefix, words, ENCODING_CONST);
      if (!data.endsWith(sum))
        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode2);
    function decodeToBytes(str) {
      const { prefix, words } = decode2(str, false);
      return { prefix, words, bytes: fromWords(words) };
    }
    function encodeFromBytes(prefix, bytes2) {
      return encode2(prefix, toWords(bytes2));
    }
    return {
      encode: encode2,
      decode: decode2,
      encodeFromBytes,
      decodeToBytes,
      decodeUnsafe,
      fromWords,
      fromWordsUnsafe,
      toWords
    };
  }
  var bech32 = /* @__PURE__ */ genBech32("bech32");
  var u8a$2 = {
    toString: toString$12,
    fromString: fromString2,
    concat: concat$2
  };
  function base64ToBytes(s3) {
    const inputBase64Url = s3.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return u8a$2.fromString(inputBase64Url, "base64url");
  }
  function base58ToBytes(s3) {
    return u8a$2.fromString(s3, "base58btc");
  }
  function bytesToBase58(b7) {
    return u8a$2.toString(b7, "base58btc");
  }
  var VM_TO_KEY_TYPE = {
    Secp256k1SignatureVerificationKey2018: "Secp256k1",
    Secp256k1VerificationKey2018: "Secp256k1",
    EcdsaSecp256k1VerificationKey2019: "Secp256k1",
    EcdsaPublicKeySecp256k1: "Secp256k1",
    EcdsaSecp256k1RecoveryMethod2020: "Secp256k1",
    EcdsaSecp256r1VerificationKey2019: "P-256",
    Ed25519VerificationKey2018: "Ed25519",
    Ed25519VerificationKey2020: "Ed25519",
    ED25519SignatureVerification: "Ed25519",
    X25519KeyAgreementKey2019: "X25519",
    X25519KeyAgreementKey2020: "X25519",
    ConditionalProof2022: void 0,
    JsonWebKey2020: void 0,
    Multikey: void 0
  };
  var supportedCodecs = {
    "ed25519-pub": 237,
    "x25519-pub": 236,
    "secp256k1-pub": 231,
    "bls12_381-g1-pub": 234,
    "bls12_381-g2-pub": 235,
    "p256-pub": 4608
  };
  var CODEC_TO_KEY_TYPE = {
    "bls12_381-g1-pub": "Bls12381G1",
    "bls12_381-g2-pub": "Bls12381G2",
    "ed25519-pub": "Ed25519",
    "p256-pub": "P-256",
    "secp256k1-pub": "Secp256k1",
    "x25519-pub": "X25519"
  };
  function extractPublicKeyBytes$1(pk) {
    if (pk.publicKeyBase58) {
      return {
        keyBytes: base58ToBytes(pk.publicKeyBase58),
        keyType: VM_TO_KEY_TYPE[pk.type]
      };
    } else if (pk.publicKeyBase64) {
      return {
        keyBytes: base64ToBytes(pk.publicKeyBase64),
        keyType: VM_TO_KEY_TYPE[pk.type]
      };
    } else if (pk.publicKeyHex) {
      return {
        keyBytes: hexToBytes$1(pk.publicKeyHex),
        keyType: VM_TO_KEY_TYPE[pk.type]
      };
    } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "secp256k1" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
      return {
        keyBytes: secp256k1$1.ProjectivePoint.fromAffine({
          x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
          y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
        }).toRawBytes(false),
        keyType: "Secp256k1"
      };
    } else if (pk.publicKeyJwk && pk.publicKeyJwk.crv === "P-256" && pk.publicKeyJwk.x && pk.publicKeyJwk.y) {
      return {
        keyBytes: p256.ProjectivePoint.fromAffine({
          x: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.x)),
          y: bytesToBigInt(base64ToBytes(pk.publicKeyJwk.y))
        }).toRawBytes(false),
        keyType: "P-256"
      };
    } else if (pk.publicKeyJwk && pk.publicKeyJwk.kty === "OKP" && ["Ed25519", "X25519"].includes(pk.publicKeyJwk.crv ?? "") && pk.publicKeyJwk.x) {
      return {
        keyBytes: base64ToBytes(pk.publicKeyJwk.x),
        keyType: pk.publicKeyJwk.crv
      };
    } else if (pk.publicKeyMultibase) {
      const {
        keyBytes,
        keyType
      } = multibaseToBytes(pk.publicKeyMultibase);
      return {
        keyBytes,
        keyType: keyType ?? VM_TO_KEY_TYPE[pk.type]
      };
    }
    return {
      keyBytes: new Uint8Array()
    };
  }
  function multibaseToBytes(s3) {
    const bytes2 = srcExports.decode(s3);
    if ([32, 33, 48, 64, 65, 96].includes(bytes2.length)) {
      return {
        keyBytes: bytes2
      };
    }
    try {
      const [codec, length2] = decode$1(bytes2);
      const possibleCodec = Object.entries(supportedCodecs).filter(([, code2]) => code2 === codec)?.[0][0] ?? "";
      return {
        keyBytes: bytes2.slice(length2),
        keyType: CODEC_TO_KEY_TYPE[possibleCodec]
      };
    } catch (e7) {
      return {
        keyBytes: bytes2
      };
    }
  }
  function hexToBytes$1(s3, minLength) {
    let input = s3.startsWith("0x") ? s3.substring(2) : s3;
    if (input.length % 2 !== 0) {
      input = `0${input}`;
    }
    return u8a$2.fromString(input.toLowerCase(), "base16");
  }
  function bytesToHex$1(b7) {
    return u8a$2.toString(b7, "base16");
  }
  function bytesToBigInt(b7) {
    return BigInt(`0x` + u8a$2.toString(b7, "base16"));
  }
  function stringToBytes$1(s3) {
    return u8a$2.fromString(s3, "utf-8");
  }
  function sha256$2(payload) {
    const data = typeof payload === "string" ? fromString2(payload) : payload;
    return sha256$3(data);
  }
  var keccak = keccak_256$1;
  function toEthereumAddress(hexPublicKey) {
    const hashInput = fromString2(hexPublicKey.slice(2), "base16");
    return `0x${toString$12(keccak(hashInput).slice(-20), "base16")}`;
  }
  function publicKeyToAddress$1(publicKey2, otherAddress) {
    const version2 = bytesToHex$1(base58ToBytes(otherAddress).slice(0, 1));
    const publicKeyBuffer = hexToBytes$1(publicKey2);
    const publicKeyHash = ripemd160(sha256$2(publicKeyBuffer));
    const step1 = version2 + bytesToHex$1(publicKeyHash);
    const step2 = sha256$2(hexToBytes$1(step1));
    const step3 = sha256$2(step2);
    const checksum = bytesToHex$1(step3).substring(0, 8);
    const step4 = step1 + checksum;
    return bytesToBase58(hexToBytes$1(step4));
  }
  function publicKeyToAddress(publicKey2, prefix) {
    const publicKeyBuffer = secp256k1$1.ProjectivePoint.fromHex(publicKey2).toRawBytes();
    const hash2 = ripemd160(sha256$2(publicKeyBuffer));
    const words = bech32.toWords(hash2);
    return bech32.encode(prefix, words).replace(prefix, "");
  }
  function verifyBlockchainAccountId(publicKey2, blockchainAccountId) {
    if (blockchainAccountId) {
      const chain2 = blockchainAccountId.split(":");
      switch (chain2[0]) {
        case "bip122":
          chain2[chain2.length - 1] = publicKeyToAddress$1(publicKey2, chain2[chain2.length - 1]);
          break;
        case "cosmos":
          chain2[chain2.length - 1] = publicKeyToAddress(publicKey2, chain2[1]);
          break;
        case "eip155":
          chain2[chain2.length - 1] = toEthereumAddress(publicKey2);
          break;
        default:
          return false;
      }
      return chain2.join(":").toLowerCase() === blockchainAccountId.toLowerCase();
    }
    return false;
  }
  function toSignatureObject(signature, recoverable = false) {
    const rawSig = base64ToBytes(signature);
    if (rawSig.length !== (recoverable ? 65 : 64)) {
      throw new Error("wrong signature length");
    }
    const r = bytesToHex$1(rawSig.slice(0, 32));
    const s3 = bytesToHex$1(rawSig.slice(32, 64));
    const sigObj = {
      r,
      s: s3
    };
    if (recoverable) {
      sigObj.recoveryParam = rawSig[64];
    }
    return sigObj;
  }
  function toSignatureObject2(signature, recoverable = false) {
    const bytes2 = base64ToBytes(signature);
    if (bytes2.length !== (recoverable ? 65 : 64)) {
      throw new Error("wrong signature length");
    }
    return {
      compact: bytes2.slice(0, 64),
      recovery: bytes2[64]
    };
  }
  function verifyES256(data, signature, authenticators) {
    const hash2 = sha256$2(data);
    const sig = p256.Signature.fromCompact(toSignatureObject2(signature).compact);
    const fullPublicKeys = authenticators.filter((a4) => !a4.ethereumAddress && !a4.blockchainAccountId);
    const signer = fullPublicKeys.find((pk) => {
      try {
        const {
          keyBytes
        } = extractPublicKeyBytes$1(pk);
        return p256.verify(sig, hash2, keyBytes);
      } catch (err) {
        return false;
      }
    });
    if (!signer)
      throw new Error("invalid_signature: Signature invalid for JWT");
    return signer;
  }
  function verifyES256K(data, signature, authenticators) {
    const hash2 = sha256$2(data);
    const signatureNormalized = secp256k1$1.Signature.fromCompact(base64ToBytes(signature)).normalizeS();
    const fullPublicKeys = authenticators.filter((a4) => {
      return !a4.ethereumAddress && !a4.blockchainAccountId;
    });
    const blockchainAddressKeys = authenticators.filter((a4) => {
      return a4.ethereumAddress || a4.blockchainAccountId;
    });
    let signer = fullPublicKeys.find((pk) => {
      try {
        const {
          keyBytes
        } = extractPublicKeyBytes$1(pk);
        return secp256k1$1.verify(signatureNormalized, hash2, keyBytes);
      } catch (err) {
        return false;
      }
    });
    if (!signer && blockchainAddressKeys.length > 0) {
      signer = verifyRecoverableES256K(data, signature, blockchainAddressKeys);
    }
    if (!signer)
      throw new Error("invalid_signature: Signature invalid for JWT");
    return signer;
  }
  function verifyRecoverableES256K(data, signature, authenticators) {
    const signatures = [];
    if (signature.length > 86) {
      signatures.push(toSignatureObject2(signature, true));
    } else {
      const so2 = toSignatureObject2(signature, false);
      signatures.push({
        ...so2,
        recovery: 0
      });
      signatures.push({
        ...so2,
        recovery: 1
      });
    }
    const hash2 = sha256$2(data);
    const checkSignatureAgainstSigner = (sigObj) => {
      const signature2 = secp256k1$1.Signature.fromCompact(sigObj.compact).addRecoveryBit(sigObj.recovery || 0);
      const recoveredPublicKey = signature2.recoverPublicKey(hash2);
      const recoveredAddress = toEthereumAddress(recoveredPublicKey.toHex(false)).toLowerCase();
      const recoveredPublicKeyHex = recoveredPublicKey.toHex(false);
      const recoveredCompressedPublicKeyHex = recoveredPublicKey.toHex(true);
      return authenticators.find((a4) => {
        const {
          keyBytes
        } = extractPublicKeyBytes$1(a4);
        const keyHex = bytesToHex$1(keyBytes);
        return keyHex === recoveredPublicKeyHex || keyHex === recoveredCompressedPublicKeyHex || a4.ethereumAddress?.toLowerCase() === recoveredAddress || a4.blockchainAccountId?.split("@eip155")?.[0].toLowerCase() === recoveredAddress || verifyBlockchainAccountId(recoveredPublicKeyHex, a4.blockchainAccountId);
      });
    };
    for (const signature2 of signatures) {
      const verificationMethod = checkSignatureAgainstSigner(signature2);
      if (verificationMethod)
        return verificationMethod;
    }
    throw new Error("invalid_signature: Signature invalid for JWT");
  }
  function verifyEd25519(data, signature, authenticators) {
    const clear = stringToBytes$1(data);
    const signatureBytes = base64ToBytes(signature);
    const signer = authenticators.find((a4) => {
      const {
        keyBytes,
        keyType
      } = extractPublicKeyBytes$1(a4);
      if (keyType === "Ed25519") {
        return ed25519.verify(signatureBytes, clear, keyBytes);
      } else {
        return false;
      }
    });
    if (!signer)
      throw new Error("invalid_signature: Signature invalid for JWT");
    return signer;
  }
  var algorithms = {
    ES256: verifyES256,
    ES256K: verifyES256K,
    "ES256K-R": verifyRecoverableES256K,
    Ed25519: verifyEd25519,
    EdDSA: verifyEd25519
  };
  function VerifierAlgorithm(alg) {
    const impl = algorithms[alg];
    if (!impl)
      throw new Error(`not_supported: Unsupported algorithm ${alg}`);
    return impl;
  }
  VerifierAlgorithm.toSignatureObject = toSignatureObject;
  typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
  typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
  var VerifiableConstants = Object.freeze({
    ERRORS: {
      FiELD_IS_EMPTY: "fieldPath is empty",
      CONTEXT_TYPE_IS_EMPTY: "ctxType is empty",
      IDENTITY_DOES_NOT_EXIST: "Identity does not exist",
      NO_AUTH_CRED_FOUND: "no auth credentials found"
    },
    CREDENTIAL_TYPE: {
      W3C_VERIFIABLE_CREDENTIAL: "VerifiableCredential",
      W3C_VERIFIABLE_PRESENTATION: "VerifiablePresentation"
    },
    CREDENTIAL_SUBJECT_PATH: "https://www.w3.org/2018/credentials#credentialSubject",
    JSONLD_SCHEMA: {
      IDEN3_CREDENTIAL: "https://schema.iden3.io/core/jsonld/iden3proofs.jsonld",
      IDEN3_DISPLAY_METHOD: "https://schema.iden3.io/core/jsonld/displayMethod.jsonld",
      W3C_CREDENTIAL_2018: "https://www.w3.org/2018/credentials/v1",
      W3C_VC_DOCUMENT_2018: `{"@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","VerifiableCredential":{"@id":"https://www.w3.org/2018/credentials#VerifiableCredential","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","cred":"https://www.w3.org/2018/credentials#","sec":"https://w3id.org/security#","xsd":"http://www.w3.org/2001/XMLSchema#","credentialSchema":{"@id":"cred:credentialSchema","@type":"@id","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","cred":"https://www.w3.org/2018/credentials#","JsonSchemaValidator2018":"cred:JsonSchemaValidator2018"}},"credentialStatus":{"@id":"cred:credentialStatus","@type":"@id"},"credentialSubject":{"@id":"cred:credentialSubject","@type":"@id"},"evidence":{"@id":"cred:evidence","@type":"@id"},"expirationDate":{"@id":"cred:expirationDate","@type":"xsd:dateTime"},"holder":{"@id":"cred:holder","@type":"@id"},"issued":{"@id":"cred:issued","@type":"xsd:dateTime"},"issuer":{"@id":"cred:issuer","@type":"@id"},"issuanceDate":{"@id":"cred:issuanceDate","@type":"xsd:dateTime"},"proof":{"@id":"sec:proof","@type":"@id","@container":"@graph"},"refreshService":{"@id":"cred:refreshService","@type":"@id","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","cred":"https://www.w3.org/2018/credentials#","ManualRefreshService2018":"cred:ManualRefreshService2018"}},"termsOfUse":{"@id":"cred:termsOfUse","@type":"@id"},"validFrom":{"@id":"cred:validFrom","@type":"xsd:dateTime"},"validUntil":{"@id":"cred:validUntil","@type":"xsd:dateTime"}}},"VerifiablePresentation":{"@id":"https://www.w3.org/2018/credentials#VerifiablePresentation","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","cred":"https://www.w3.org/2018/credentials#","sec":"https://w3id.org/security#","holder":{"@id":"cred:holder","@type":"@id"},"proof":{"@id":"sec:proof","@type":"@id","@container":"@graph"},"verifiableCredential":{"@id":"cred:verifiableCredential","@type":"@id","@container":"@graph"}}},"EcdsaSecp256k1Signature2019":{"@id":"https://w3id.org/security#EcdsaSecp256k1Signature2019","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","xsd":"http://www.w3.org/2001/XMLSchema#","challenge":"sec:challenge","created":{"@id":"http://purl.org/dc/terms/created","@type":"xsd:dateTime"},"domain":"sec:domain","expires":{"@id":"sec:expiration","@type":"xsd:dateTime"},"jws":"sec:jws","nonce":"sec:nonce","proofPurpose":{"@id":"sec:proofPurpose","@type":"@vocab","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","assertionMethod":{"@id":"sec:assertionMethod","@type":"@id","@container":"@set"},"authentication":{"@id":"sec:authenticationMethod","@type":"@id","@container":"@set"}}},"proofValue":"sec:proofValue","verificationMethod":{"@id":"sec:verificationMethod","@type":"@id"}}},"EcdsaSecp256r1Signature2019":{"@id":"https://w3id.org/security#EcdsaSecp256r1Signature2019","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","xsd":"http://www.w3.org/2001/XMLSchema#","challenge":"sec:challenge","created":{"@id":"http://purl.org/dc/terms/created","@type":"xsd:dateTime"},"domain":"sec:domain","expires":{"@id":"sec:expiration","@type":"xsd:dateTime"},"jws":"sec:jws","nonce":"sec:nonce","proofPurpose":{"@id":"sec:proofPurpose","@type":"@vocab","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","assertionMethod":{"@id":"sec:assertionMethod","@type":"@id","@container":"@set"},"authentication":{"@id":"sec:authenticationMethod","@type":"@id","@container":"@set"}}},"proofValue":"sec:proofValue","verificationMethod":{"@id":"sec:verificationMethod","@type":"@id"}}},"Ed25519Signature2018":{"@id":"https://w3id.org/security#Ed25519Signature2018","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","xsd":"http://www.w3.org/2001/XMLSchema#","challenge":"sec:challenge","created":{"@id":"http://purl.org/dc/terms/created","@type":"xsd:dateTime"},"domain":"sec:domain","expires":{"@id":"sec:expiration","@type":"xsd:dateTime"},"jws":"sec:jws","nonce":"sec:nonce","proofPurpose":{"@id":"sec:proofPurpose","@type":"@vocab","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","assertionMethod":{"@id":"sec:assertionMethod","@type":"@id","@container":"@set"},"authentication":{"@id":"sec:authenticationMethod","@type":"@id","@container":"@set"}}},"proofValue":"sec:proofValue","verificationMethod":{"@id":"sec:verificationMethod","@type":"@id"}}},"RsaSignature2018":{"@id":"https://w3id.org/security#RsaSignature2018","@context":{"@version":1.1,"@protected":true,"challenge":"sec:challenge","created":{"@id":"http://purl.org/dc/terms/created","@type":"xsd:dateTime"},"domain":"sec:domain","expires":{"@id":"sec:expiration","@type":"xsd:dateTime"},"jws":"sec:jws","nonce":"sec:nonce","proofPurpose":{"@id":"sec:proofPurpose","@type":"@vocab","@context":{"@version":1.1,"@protected":true,"id":"@id","type":"@type","sec":"https://w3id.org/security#","assertionMethod":{"@id":"sec:assertionMethod","@type":"@id","@container":"@set"},"authentication":{"@id":"sec:authenticationMethod","@type":"@id","@container":"@set"}}},"proofValue":"sec:proofValue","verificationMethod":{"@id":"sec:verificationMethod","@type":"@id"}}},"proof":{"@id":"https://w3id.org/security#proof","@type":"@id","@container":"@graph"}}}`
    },
    JSON_SCHEMA_VALIDATOR: "JsonSchema2023",
    SERVICE_TYPE: {
      IDEN3_COMM: "iden3-communication",
      PUSH_NOTIFICATION: "push-notification"
    },
    AUTH: {
      AUTH_BJJ_CREDENTIAL_HASH: "013fd3f623559d850fb5b02ff012d0e2",
      AUTH_BJJ_CREDENTIAL_SCHEMA_JSON_URL: "https://schema.iden3.io/core/json/auth.json",
      AUTH_BJJ_CREDENTIAL_SCHEMA_JSONLD_URL: "https://schema.iden3.io/core/jsonld/auth.jsonld",
      AUTH_BJJ_CREDENTIAL_TYPE: "AuthBJJCredential",
      AUTH_BJJ_CREDENTIAL_SCHEMA_JSON: `{"$schema":"http://json-schema.org/draft-07/schema#","$metadata":{"uris":{"jsonLdContext":"https://schema.iden3.io/core/jsonld/auth.jsonld","jsonSchema":"https://schema.iden3.io/core/json/auth.json"},"serialization":{"indexDataSlotA":"x","indexDataSlotB":"y"}},"type":"object","required":["@context","id","type","issuanceDate","credentialSubject","credentialSchema","credentialStatus","issuer"],"properties":{"@context":{"type":["string","array","object"]},"id":{"type":"string"},"type":{"type":["string","array"],"items":{"type":"string"}},"issuer":{"type":["string","object"],"format":"uri","required":["id"],"properties":{"id":{"type":"string","format":"uri"}}},"issuanceDate":{"type":"string","format":"date-time"},"expirationDate":{"type":"string","format":"date-time"},"credentialSchema":{"type":"object","required":["id","type"],"properties":{"id":{"type":"string","format":"uri"},"type":{"type":"string"}}},"credentialSubject":{"type":"object","required":["x","y"],"properties":{"id":{"title":"Credential Subject ID","type":"string","format":"uri"},"x":{"type":"string"},"y":{"type":"string"}}}}}`
    }
  });
  var ProofType;
  (function(ProofType2) {
    ProofType2["BJJSignature"] = "BJJSignature2021";
    ProofType2["Iden3SparseMerkleTreeProof"] = "Iden3SparseMerkleTreeProof";
  })(ProofType || (ProofType = {}));
  var CredentialStatusType;
  (function(CredentialStatusType2) {
    CredentialStatusType2["SparseMerkleTreeProof"] = "SparseMerkleTreeProof";
    CredentialStatusType2["Iden3ReverseSparseMerkleTreeProof"] = "Iden3ReverseSparseMerkleTreeProof";
    CredentialStatusType2["Iden3commRevocationStatusV1"] = "Iden3commRevocationStatusV1.0";
    CredentialStatusType2["Iden3OnchainSparseMerkleTreeProof2023"] = "Iden3OnchainSparseMerkleTreeProof2023";
  })(CredentialStatusType || (CredentialStatusType = {}));
  var ProofPurpose;
  (function(ProofPurpose2) {
    ProofPurpose2["Authentication"] = "Authentication";
  })(ProofPurpose || (ProofPurpose = {}));
  var MerklizedRootPosition;
  (function(MerklizedRootPosition2) {
    MerklizedRootPosition2["Index"] = "index";
    MerklizedRootPosition2["Value"] = "value";
    MerklizedRootPosition2["None"] = "";
  })(MerklizedRootPosition || (MerklizedRootPosition = {}));
  var SubjectPosition;
  (function(SubjectPosition2) {
    SubjectPosition2["None"] = "";
    SubjectPosition2["Index"] = "index";
    SubjectPosition2["Value"] = "value";
  })(SubjectPosition || (SubjectPosition = {}));
  var RefreshServiceType;
  (function(RefreshServiceType2) {
    RefreshServiceType2["Iden3RefreshService2023"] = "Iden3RefreshService2023";
  })(RefreshServiceType || (RefreshServiceType = {}));
  var PaymentRequestDataType;
  (function(PaymentRequestDataType2) {
    PaymentRequestDataType2["Iden3PaymentRequestCryptoV1"] = "Iden3PaymentRequestCryptoV1";
    PaymentRequestDataType2["Iden3PaymentRailsRequestV1"] = "Iden3PaymentRailsRequestV1";
    PaymentRequestDataType2["Iden3PaymentRailsERC20RequestV1"] = "Iden3PaymentRailsERC20RequestV1";
  })(PaymentRequestDataType || (PaymentRequestDataType = {}));
  var PaymentType;
  (function(PaymentType2) {
    PaymentType2["Iden3PaymentCryptoV1"] = "Iden3PaymentCryptoV1";
    PaymentType2["Iden3PaymentRailsV1"] = "Iden3PaymentRailsV1";
    PaymentType2["Iden3PaymentRailsERC20V1"] = "Iden3PaymentRailsERC20V1";
  })(PaymentType || (PaymentType = {}));
  var SupportedPaymentProofType;
  (function(SupportedPaymentProofType2) {
    SupportedPaymentProofType2["EthereumEip712Signature2021"] = "EthereumEip712Signature2021";
  })(SupportedPaymentProofType || (SupportedPaymentProofType = {}));
  var SupportedCurrencies;
  (function(SupportedCurrencies2) {
    SupportedCurrencies2["ETH"] = "ETH";
    SupportedCurrencies2["ETH_WEI"] = "ETHWEI";
    SupportedCurrencies2["ETH_GWEI"] = "ETHGWEI";
    SupportedCurrencies2["MATIC"] = "MATIC";
    SupportedCurrencies2["POL"] = "POL";
    SupportedCurrencies2["USDT"] = "USDT";
    SupportedCurrencies2["USDC"] = "USDC";
  })(SupportedCurrencies || (SupportedCurrencies = {}));
  var PaymentFeatures;
  (function(PaymentFeatures2) {
    PaymentFeatures2["EIP_2612"] = "EIP-2612";
  })(PaymentFeatures || (PaymentFeatures = {}));
  var DisplayMethodType;
  (function(DisplayMethodType2) {
    DisplayMethodType2["Iden3BasicDisplayMethodV1"] = "Iden3BasicDisplayMethodV1";
  })(DisplayMethodType || (DisplayMethodType = {}));
  var Iden3SparseMerkleTreeProof = class {
    constructor(obj) {
      this.coreClaim = obj.coreClaim;
      this.issuerData = obj.issuerData;
      this.type = ProofType.Iden3SparseMerkleTreeProof;
      this.mtp = obj.mtp;
    }
    toJSON() {
      const issuerId = this.issuerData.id;
      return {
        issuerData: {
          id: issuerId.string(),
          state: {
            ...this.issuerData.state,
            rootOfRoots: this.issuerData.state.rootOfRoots.hex(),
            claimsTreeRoot: this.issuerData.state.claimsTreeRoot.hex(),
            revocationTreeRoot: this.issuerData.state.revocationTreeRoot.hex(),
            value: this.issuerData.state.value.hex()
          }
        },
        type: this.type,
        coreClaim: this.coreClaim.hex(),
        mtp: this.mtp.toJSON()
      };
    }
    static fromJSON(obj) {
      let mtp;
      if (obj?.mtp?.notEmpties && obj?.mtp?.depth && obj?.mtp?.siblings) {
        const ne2 = obj?.mtp?.notEmpties;
        const notEmpties = ne2 instanceof Uint8Array ? ne2 : new Uint8Array(Object.values(ne2));
        const siblingsHashes = obj?.mtp?.siblings.map((h6) => V3.fromString(JSON.stringify(h6)));
        const allSiblings = Kt.buildAllSiblings(obj?.mtp?.depth, notEmpties, siblingsHashes);
        let nodeAux = obj.mtp.nodeAux || obj.mtp.node_aux;
        if (nodeAux) {
          nodeAux = {
            key: V3.fromString(JSON.stringify(nodeAux.key)),
            value: V3.fromString(JSON.stringify(nodeAux.value))
          };
        }
        mtp = new Kt({ existence: obj?.mtp.existence, nodeAux, siblings: allSiblings });
      } else {
        mtp = Kt.fromJSON(obj.mtp);
      }
      return new Iden3SparseMerkleTreeProof({
        coreClaim: new P2().fromHex(obj.coreClaim),
        mtp,
        issuerData: {
          id: Q2.parse(obj.issuerData.id),
          state: {
            ...obj.issuerData.state,
            rootOfRoots: V3.fromHex(obj.issuerData.state.rootOfRoots),
            claimsTreeRoot: V3.fromHex(obj.issuerData.state.claimsTreeRoot),
            revocationTreeRoot: V3.fromHex(obj.issuerData.state.revocationTreeRoot),
            value: V3.fromHex(obj.issuerData.state.value)
          }
        }
      });
    }
  };
  var BJJSignatureProof2021 = class {
    constructor(obj) {
      this.type = ProofType.BJJSignature;
      this.issuerData = obj.issuerData;
      this.coreClaim = obj.coreClaim;
      this.signature = obj.signature;
    }
    toJSON() {
      return {
        issuerData: {
          id: this.issuerData.id.string(),
          state: {
            ...this.issuerData.state,
            rootOfRoots: this.issuerData.state.rootOfRoots.hex(),
            claimsTreeRoot: this.issuerData.state.claimsTreeRoot.hex(),
            revocationTreeRoot: this.issuerData.state.revocationTreeRoot.hex(),
            value: this.issuerData.state.value.hex()
          },
          mtp: this.issuerData.mtp.toJSON(),
          authCoreClaim: this.issuerData.authCoreClaim.hex(),
          credentialStatus: this.issuerData.credentialStatus
        },
        type: this.type,
        coreClaim: this.coreClaim.hex(),
        signature: b.encodeString(this.signature.compress())
      };
    }
    static fromJSON(obj) {
      return new BJJSignatureProof2021({
        issuerData: {
          id: Q2.parse(obj.issuerData.id),
          mtp: Kt.fromJSON(obj.issuerData.mtp),
          state: {
            ...obj.issuerData.state,
            rootOfRoots: V3.fromHex(obj.issuerData.state.rootOfRoots),
            claimsTreeRoot: V3.fromHex(obj.issuerData.state.claimsTreeRoot),
            revocationTreeRoot: V3.fromHex(obj.issuerData.state.revocationTreeRoot),
            value: V3.fromHex(obj.issuerData.state.value)
          },
          credentialStatus: obj.issuerData.credentialStatus,
          authCoreClaim: new P2().fromHex(obj.issuerData.authCoreClaim)
        },
        coreClaim: new P2().fromHex(obj.coreClaim),
        signature: EI.newFromCompressed(Uint8Array.from(b.decodeString(obj.signature)).slice(0, 64))
      });
    }
  };
  var getUserDIDFromCredential = (issuerDID, credential) => {
    if (!credential.credentialSubject.id) {
      return issuerDID;
    }
    if (typeof credential.credentialSubject.id !== "string") {
      throw new Error("credential subject `id` is not a string");
    }
    return Q2.parse(credential.credentialSubject.id);
  };
  var lib = {};
  var IdentifierIssuer_1 = class IdentifierIssuer {
    constructor(prefix, existing = /* @__PURE__ */ new Map(), counter = 0) {
      this.prefix = prefix;
      this._existing = existing;
      this.counter = counter;
    }
    clone() {
      const { prefix, _existing, counter } = this;
      return new IdentifierIssuer(prefix, new Map(_existing), counter);
    }
    getId(old) {
      const existing = old && this._existing.get(old);
      if (existing) {
        return existing;
      }
      const identifier = this.prefix + this.counter;
      this.counter++;
      if (old) {
        this._existing.set(old, identifier);
      }
      return identifier;
    }
    hasId(old) {
      return this._existing.has(old);
    }
    getOldIds() {
      return [...this._existing.keys()];
    }
  };
  var crypto$2 = self.crypto || self.msCrypto;
  var MessageDigestBrowser = class MessageDigest {
    constructor(algorithm) {
      if (!(crypto$2 && crypto$2.subtle)) {
        throw new Error("crypto.subtle not found.");
      }
      if (algorithm === "sha256") {
        this.algorithm = { name: "SHA-256" };
      } else if (algorithm === "sha1") {
        this.algorithm = { name: "SHA-1" };
      } else {
        throw new Error(`Unsupported algorithm "${algorithm}".`);
      }
      this._content = "";
    }
    update(msg) {
      this._content += msg;
    }
    async digest() {
      const data = new TextEncoder().encode(this._content);
      const buffer = new Uint8Array(
        await crypto$2.subtle.digest(this.algorithm, data)
      );
      let hex2 = "";
      for (let i4 = 0; i4 < buffer.length; ++i4) {
        hex2 += buffer[i4].toString(16).padStart(2, "0");
      }
      return hex2;
    }
  };
  var Permuter_1 = class Permuter {
    constructor(list) {
      this.current = list.sort();
      this.done = false;
      this.dir = /* @__PURE__ */ new Map();
      for (let i4 = 0; i4 < list.length; ++i4) {
        this.dir.set(list[i4], true);
      }
    }
    hasNext() {
      return !this.done;
    }
    next() {
      const { current, dir } = this;
      const rval = current.slice();
      let k5 = null;
      let pos = 0;
      const length2 = current.length;
      for (let i4 = 0; i4 < length2; ++i4) {
        const element = current[i4];
        const left = dir.get(element);
        if ((k5 === null || element > k5) && (left && i4 > 0 && element > current[i4 - 1] || !left && i4 < length2 - 1 && element > current[i4 + 1])) {
          k5 = element;
          pos = i4;
        }
      }
      if (k5 === null) {
        this.done = true;
      } else {
        const swap = dir.get(k5) ? pos - 1 : pos + 1;
        current[pos] = current[swap];
        current[swap] = k5;
        for (const element of current) {
          if (element > k5) {
            dir.set(element, !dir.get(element));
          }
        }
      }
      return rval;
    }
  };
  var RDF$1 = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  var RDF_LANGSTRING$1 = RDF$1 + "langString";
  var XSD_STRING$2 = "http://www.w3.org/2001/XMLSchema#string";
  var TYPE_NAMED_NODE = "NamedNode";
  var TYPE_BLANK_NODE = "BlankNode";
  var TYPE_LITERAL = "Literal";
  var TYPE_DEFAULT_GRAPH = "DefaultGraph";
  var REGEX$1 = {};
  (() => {
    const iri = "(?:<([^:]+:[^>]*)>)";
    const PN_CHARS_BASE = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
    const PN_CHARS_U = PN_CHARS_BASE + "_";
    const PN_CHARS = PN_CHARS_U + "0-9-\xB7\u0300-\u036F\u203F-\u2040";
    const BLANK_NODE_LABEL = "(_:(?:[" + PN_CHARS_U + "0-9])(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?)";
    const bnode = BLANK_NODE_LABEL;
    const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
    const datatype = "(?:\\^\\^" + iri + ")";
    const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
    const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
    const ws2 = "[ \\t]+";
    const wso = "[ \\t]*";
    const subject = "(?:" + iri + "|" + bnode + ")" + ws2;
    const property = iri + ws2;
    const object2 = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
    const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
    REGEX$1.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
    REGEX$1.empty = new RegExp("^" + wso + "$");
    REGEX$1.quad = new RegExp(
      "^" + wso + subject + property + object2 + graphName + wso + "$"
    );
  })();
  var NQuads_1 = class NQuads {
    static parse(input) {
      const dataset = [];
      const graphs = {};
      const lines = input.split(REGEX$1.eoln);
      let lineNumber = 0;
      for (const line of lines) {
        lineNumber++;
        if (REGEX$1.empty.test(line)) {
          continue;
        }
        const match = line.match(REGEX$1.quad);
        if (match === null) {
          throw new Error("N-Quads parse error on line " + lineNumber + ".");
        }
        const quad = { subject: null, predicate: null, object: null, graph: null };
        if (match[1] !== void 0) {
          quad.subject = { termType: TYPE_NAMED_NODE, value: match[1] };
        } else {
          quad.subject = { termType: TYPE_BLANK_NODE, value: match[2] };
        }
        quad.predicate = { termType: TYPE_NAMED_NODE, value: match[3] };
        if (match[4] !== void 0) {
          quad.object = { termType: TYPE_NAMED_NODE, value: match[4] };
        } else if (match[5] !== void 0) {
          quad.object = { termType: TYPE_BLANK_NODE, value: match[5] };
        } else {
          quad.object = {
            termType: TYPE_LITERAL,
            value: void 0,
            datatype: {
              termType: TYPE_NAMED_NODE
            }
          };
          if (match[7] !== void 0) {
            quad.object.datatype.value = match[7];
          } else if (match[8] !== void 0) {
            quad.object.datatype.value = RDF_LANGSTRING$1;
            quad.object.language = match[8];
          } else {
            quad.object.datatype.value = XSD_STRING$2;
          }
          quad.object.value = _unescape(match[6]);
        }
        if (match[9] !== void 0) {
          quad.graph = {
            termType: TYPE_NAMED_NODE,
            value: match[9]
          };
        } else if (match[10] !== void 0) {
          quad.graph = {
            termType: TYPE_BLANK_NODE,
            value: match[10]
          };
        } else {
          quad.graph = {
            termType: TYPE_DEFAULT_GRAPH,
            value: ""
          };
        }
        if (!(quad.graph.value in graphs)) {
          graphs[quad.graph.value] = [quad];
          dataset.push(quad);
        } else {
          let unique = true;
          const quads = graphs[quad.graph.value];
          for (const q5 of quads) {
            if (_compareTriples(q5, quad)) {
              unique = false;
              break;
            }
          }
          if (unique) {
            quads.push(quad);
            dataset.push(quad);
          }
        }
      }
      return dataset;
    }
    static serialize(dataset) {
      if (!Array.isArray(dataset)) {
        dataset = NQuads.legacyDatasetToQuads(dataset);
      }
      const quads = [];
      for (const quad of dataset) {
        quads.push(NQuads.serializeQuad(quad));
      }
      return quads.sort().join("");
    }
    static serializeQuadComponents(s3, p6, o4, g5) {
      let nquad = "";
      if (s3.termType === TYPE_NAMED_NODE) {
        nquad += `<${s3.value}>`;
      } else {
        nquad += `${s3.value}`;
      }
      nquad += ` <${p6.value}> `;
      if (o4.termType === TYPE_NAMED_NODE) {
        nquad += `<${o4.value}>`;
      } else if (o4.termType === TYPE_BLANK_NODE) {
        nquad += o4.value;
      } else {
        nquad += `"${_escape(o4.value)}"`;
        if (o4.datatype.value === RDF_LANGSTRING$1) {
          if (o4.language) {
            nquad += `@${o4.language}`;
          }
        } else if (o4.datatype.value !== XSD_STRING$2) {
          nquad += `^^<${o4.datatype.value}>`;
        }
      }
      if (g5.termType === TYPE_NAMED_NODE) {
        nquad += ` <${g5.value}>`;
      } else if (g5.termType === TYPE_BLANK_NODE) {
        nquad += ` ${g5.value}`;
      }
      nquad += " .\n";
      return nquad;
    }
    static serializeQuad(quad) {
      return NQuads.serializeQuadComponents(
        quad.subject,
        quad.predicate,
        quad.object,
        quad.graph
      );
    }
    static legacyDatasetToQuads(dataset) {
      const quads = [];
      const termTypeMap = {
        "blank node": TYPE_BLANK_NODE,
        IRI: TYPE_NAMED_NODE,
        literal: TYPE_LITERAL
      };
      for (const graphName in dataset) {
        const triples = dataset[graphName];
        triples.forEach((triple) => {
          const quad = {};
          for (const componentName in triple) {
            const oldComponent = triple[componentName];
            const newComponent = {
              termType: termTypeMap[oldComponent.type],
              value: oldComponent.value
            };
            if (newComponent.termType === TYPE_LITERAL) {
              newComponent.datatype = {
                termType: TYPE_NAMED_NODE
              };
              if ("datatype" in oldComponent) {
                newComponent.datatype.value = oldComponent.datatype;
              }
              if ("language" in oldComponent) {
                if (!("datatype" in oldComponent)) {
                  newComponent.datatype.value = RDF_LANGSTRING$1;
                }
                newComponent.language = oldComponent.language;
              } else if (!("datatype" in oldComponent)) {
                newComponent.datatype.value = XSD_STRING$2;
              }
            }
            quad[componentName] = newComponent;
          }
          if (graphName === "@default") {
            quad.graph = {
              termType: TYPE_DEFAULT_GRAPH,
              value: ""
            };
          } else {
            quad.graph = {
              termType: graphName.startsWith("_:") ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,
              value: graphName
            };
          }
          quads.push(quad);
        });
      }
      return quads;
    }
  };
  function _compareTriples(t1, t2) {
    if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {
      return false;
    }
    if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {
      return false;
    }
    if (t1.object.termType !== TYPE_LITERAL) {
      return true;
    }
    return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;
  }
  var _escapeRegex = /["\\\n\r]/g;
  function _escape(s3) {
    return s3.replace(_escapeRegex, function(match) {
      switch (match) {
        case '"':
          return '\\"';
        case "\\":
          return "\\\\";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
      }
    });
  }
  var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
  function _unescape(s3) {
    return s3.replace(_unescapeRegex, function(match, code2, u4, U6) {
      if (code2) {
        switch (code2) {
          case "t":
            return "	";
          case "b":
            return "\b";
          case "n":
            return "\n";
          case "r":
            return "\r";
          case "f":
            return "\f";
          case '"':
            return '"';
          case "'":
            return "'";
          case "\\":
            return "\\";
        }
      }
      if (u4) {
        return String.fromCharCode(parseInt(u4, 16));
      }
      if (U6) {
        throw new Error("Unsupported U escape");
      }
    });
  }
  var IdentifierIssuer$3 = IdentifierIssuer_1;
  var MessageDigest$3 = MessageDigestBrowser;
  var Permuter$1 = Permuter_1;
  var NQuads$3 = NQuads_1;
  var URDNA2015_1 = class URDNA2015 {
    constructor({
      createMessageDigest = () => new MessageDigest$3("sha256"),
      canonicalIdMap = /* @__PURE__ */ new Map(),
      maxDeepIterations = Infinity
    } = {}) {
      this.name = "URDNA2015";
      this.blankNodeInfo = /* @__PURE__ */ new Map();
      this.canonicalIssuer = new IdentifierIssuer$3("_:c14n", canonicalIdMap);
      this.createMessageDigest = createMessageDigest;
      this.maxDeepIterations = maxDeepIterations;
      this.quads = null;
      this.deepIterations = null;
    }
    async main(dataset) {
      this.deepIterations = /* @__PURE__ */ new Map();
      this.quads = dataset;
      for (const quad of dataset) {
        this._addBlankNodeQuadInfo({ quad, component: quad.subject });
        this._addBlankNodeQuadInfo({ quad, component: quad.object });
        this._addBlankNodeQuadInfo({ quad, component: quad.graph });
      }
      const hashToBlankNodes = /* @__PURE__ */ new Map();
      const nonNormalized = [...this.blankNodeInfo.keys()];
      let i4 = 0;
      for (const id3 of nonNormalized) {
        if (++i4 % 100 === 0) {
          await this._yield();
        }
        await this._hashAndTrackBlankNode({ id: id3, hashToBlankNodes });
      }
      const hashes = [...hashToBlankNodes.keys()].sort();
      const nonUnique = [];
      for (const hash2 of hashes) {
        const idList = hashToBlankNodes.get(hash2);
        if (idList.length > 1) {
          nonUnique.push(idList);
          continue;
        }
        const id3 = idList[0];
        this.canonicalIssuer.getId(id3);
      }
      for (const idList of nonUnique) {
        const hashPathList = [];
        for (const id3 of idList) {
          if (this.canonicalIssuer.hasId(id3)) {
            continue;
          }
          const issuer = new IdentifierIssuer$3("_:b");
          issuer.getId(id3);
          const result = await this.hashNDegreeQuads(id3, issuer);
          hashPathList.push(result);
        }
        hashPathList.sort(_stringHashCompare$1);
        for (const result of hashPathList) {
          const oldIds = result.issuer.getOldIds();
          for (const id3 of oldIds) {
            this.canonicalIssuer.getId(id3);
          }
        }
      }
      const normalized = [];
      for (const quad of this.quads) {
        const nQuad = NQuads$3.serializeQuadComponents(
          this._componentWithCanonicalId(quad.subject),
          quad.predicate,
          this._componentWithCanonicalId(quad.object),
          this._componentWithCanonicalId(quad.graph)
        );
        normalized.push(nQuad);
      }
      normalized.sort();
      return normalized.join("");
    }
    async hashFirstDegreeQuads(id3) {
      const nquads = [];
      const info = this.blankNodeInfo.get(id3);
      const quads = info.quads;
      for (const quad of quads) {
        const copy2 = {
          subject: null,
          predicate: quad.predicate,
          object: null,
          graph: null
        };
        copy2.subject = this.modifyFirstDegreeComponent(
          id3,
          quad.subject,
          "subject"
        );
        copy2.object = this.modifyFirstDegreeComponent(
          id3,
          quad.object,
          "object"
        );
        copy2.graph = this.modifyFirstDegreeComponent(
          id3,
          quad.graph,
          "graph"
        );
        nquads.push(NQuads$3.serializeQuad(copy2));
      }
      nquads.sort();
      const md2 = this.createMessageDigest();
      for (const nquad of nquads) {
        md2.update(nquad);
      }
      info.hash = await md2.digest();
      return info.hash;
    }
    async hashRelatedBlankNode(related, quad, issuer, position) {
      let id3;
      if (this.canonicalIssuer.hasId(related)) {
        id3 = this.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id3 = issuer.getId(related);
      } else {
        id3 = this.blankNodeInfo.get(related).hash;
      }
      const md2 = this.createMessageDigest();
      md2.update(position);
      if (position !== "g") {
        md2.update(this.getRelatedPredicate(quad));
      }
      md2.update(id3);
      return md2.digest();
    }
    async hashNDegreeQuads(id3, issuer) {
      const deepIterations = this.deepIterations.get(id3) || 0;
      if (deepIterations > this.maxDeepIterations) {
        throw new Error(
          `Maximum deep iterations (${this.maxDeepIterations}) exceeded.`
        );
      }
      this.deepIterations.set(id3, deepIterations + 1);
      const md2 = this.createMessageDigest();
      const hashToRelated = await this.createHashToRelated(id3, issuer);
      const hashes = [...hashToRelated.keys()].sort();
      for (const hash2 of hashes) {
        md2.update(hash2);
        let chosenPath = "";
        let chosenIssuer;
        const permuter = new Permuter$1(hashToRelated.get(hash2));
        let i4 = 0;
        while (permuter.hasNext()) {
          const permutation = permuter.next();
          if (++i4 % 3 === 0) {
            await this._yield();
          }
          let issuerCopy = issuer.clone();
          let path = "";
          const recursionList = [];
          let nextPermutation = false;
          for (const related of permutation) {
            if (this.canonicalIssuer.hasId(related)) {
              path += this.canonicalIssuer.getId(related);
            } else {
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              }
              path += issuerCopy.getId(related);
            }
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          for (const related of recursionList) {
            const result = await this.hashNDegreeQuads(related, issuerCopy);
            path += issuerCopy.getId(related);
            path += `<${result.hash}>`;
            issuerCopy = result.issuer;
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        }
        md2.update(chosenPath);
        issuer = chosenIssuer;
      }
      return { hash: await md2.digest(), issuer };
    }
    modifyFirstDegreeComponent(id3, component) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      return {
        termType: "BlankNode",
        value: component.value === id3 ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return `<${quad.predicate.value}>`;
    }
    async createHashToRelated(id3, issuer) {
      const hashToRelated = /* @__PURE__ */ new Map();
      const quads = this.blankNodeInfo.get(id3).quads;
      let i4 = 0;
      for (const quad of quads) {
        if (++i4 % 100 === 0) {
          await this._yield();
        }
        await Promise.all([
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.subject,
            position: "s",
            id: id3,
            issuer,
            hashToRelated
          }),
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.object,
            position: "o",
            id: id3,
            issuer,
            hashToRelated
          }),
          this._addRelatedBlankNodeHash({
            quad,
            component: quad.graph,
            position: "g",
            id: id3,
            issuer,
            hashToRelated
          })
        ]);
      }
      return hashToRelated;
    }
    async _hashAndTrackBlankNode({ id: id3, hashToBlankNodes }) {
      const hash2 = await this.hashFirstDegreeQuads(id3);
      const idList = hashToBlankNodes.get(hash2);
      if (!idList) {
        hashToBlankNodes.set(hash2, [id3]);
      } else {
        idList.push(id3);
      }
    }
    _addBlankNodeQuadInfo({ quad, component }) {
      if (component.termType !== "BlankNode") {
        return;
      }
      const id3 = component.value;
      const info = this.blankNodeInfo.get(id3);
      if (info) {
        info.quads.add(quad);
      } else {
        this.blankNodeInfo.set(id3, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
      }
    }
    async _addRelatedBlankNodeHash({ quad, component, position, id: id3, issuer, hashToRelated }) {
      if (!(component.termType === "BlankNode" && component.value !== id3)) {
        return;
      }
      const related = component.value;
      const hash2 = await this.hashRelatedBlankNode(
        related,
        quad,
        issuer,
        position
      );
      const entries2 = hashToRelated.get(hash2);
      if (entries2) {
        entries2.push(related);
      } else {
        hashToRelated.set(hash2, [related]);
      }
    }
    _componentWithCanonicalId(component) {
      if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
        return {
          termType: "BlankNode",
          value: this.canonicalIssuer.getId(component.value)
        };
      }
      return component;
    }
    async _yield() {
      return new Promise((resolve2) => setImmediate(resolve2));
    }
  };
  function _stringHashCompare$1(a4, b7) {
    return a4.hash < b7.hash ? -1 : a4.hash > b7.hash ? 1 : 0;
  }
  var MessageDigest$2 = MessageDigestBrowser;
  var URDNA20152 = URDNA2015_1;
  var URGNA2012 = class URDNA2012 extends URDNA20152 {
    constructor() {
      super();
      this.name = "URGNA2012";
      this.createMessageDigest = () => new MessageDigest$2("sha1");
    }
    modifyFirstDegreeComponent(id3, component, key) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      if (key === "graph") {
        return {
          termType: "BlankNode",
          value: "_:g"
        };
      }
      return {
        termType: "BlankNode",
        value: component.value === id3 ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return quad.predicate.value;
    }
    async createHashToRelated(id3, issuer) {
      const hashToRelated = /* @__PURE__ */ new Map();
      const quads = this.blankNodeInfo.get(id3).quads;
      let i4 = 0;
      for (const quad of quads) {
        let position;
        let related;
        if (quad.subject.termType === "BlankNode" && quad.subject.value !== id3) {
          related = quad.subject.value;
          position = "p";
        } else if (quad.object.termType === "BlankNode" && quad.object.value !== id3) {
          related = quad.object.value;
          position = "r";
        } else {
          continue;
        }
        if (++i4 % 100 === 0) {
          await this._yield();
        }
        const hash2 = await this.hashRelatedBlankNode(
          related,
          quad,
          issuer,
          position
        );
        const entries2 = hashToRelated.get(hash2);
        if (entries2) {
          entries2.push(related);
        } else {
          hashToRelated.set(hash2, [related]);
        }
      }
      return hashToRelated;
    }
  };
  var IdentifierIssuer$2 = IdentifierIssuer_1;
  var MessageDigest$1 = MessageDigestBrowser;
  var Permuter2 = Permuter_1;
  var NQuads$2 = NQuads_1;
  var URDNA2015Sync_1 = class URDNA2015Sync {
    constructor({
      createMessageDigest = () => new MessageDigest$1("sha256"),
      canonicalIdMap = /* @__PURE__ */ new Map(),
      maxDeepIterations = Infinity
    } = {}) {
      this.name = "URDNA2015";
      this.blankNodeInfo = /* @__PURE__ */ new Map();
      this.canonicalIssuer = new IdentifierIssuer$2("_:c14n", canonicalIdMap);
      this.createMessageDigest = createMessageDigest;
      this.maxDeepIterations = maxDeepIterations;
      this.quads = null;
      this.deepIterations = null;
    }
    main(dataset) {
      this.deepIterations = /* @__PURE__ */ new Map();
      this.quads = dataset;
      for (const quad of dataset) {
        this._addBlankNodeQuadInfo({ quad, component: quad.subject });
        this._addBlankNodeQuadInfo({ quad, component: quad.object });
        this._addBlankNodeQuadInfo({ quad, component: quad.graph });
      }
      const hashToBlankNodes = /* @__PURE__ */ new Map();
      const nonNormalized = [...this.blankNodeInfo.keys()];
      for (const id3 of nonNormalized) {
        this._hashAndTrackBlankNode({ id: id3, hashToBlankNodes });
      }
      const hashes = [...hashToBlankNodes.keys()].sort();
      const nonUnique = [];
      for (const hash2 of hashes) {
        const idList = hashToBlankNodes.get(hash2);
        if (idList.length > 1) {
          nonUnique.push(idList);
          continue;
        }
        const id3 = idList[0];
        this.canonicalIssuer.getId(id3);
      }
      for (const idList of nonUnique) {
        const hashPathList = [];
        for (const id3 of idList) {
          if (this.canonicalIssuer.hasId(id3)) {
            continue;
          }
          const issuer = new IdentifierIssuer$2("_:b");
          issuer.getId(id3);
          const result = this.hashNDegreeQuads(id3, issuer);
          hashPathList.push(result);
        }
        hashPathList.sort(_stringHashCompare);
        for (const result of hashPathList) {
          const oldIds = result.issuer.getOldIds();
          for (const id3 of oldIds) {
            this.canonicalIssuer.getId(id3);
          }
        }
      }
      const normalized = [];
      for (const quad of this.quads) {
        const nQuad = NQuads$2.serializeQuadComponents(
          this._componentWithCanonicalId({ component: quad.subject }),
          quad.predicate,
          this._componentWithCanonicalId({ component: quad.object }),
          this._componentWithCanonicalId({ component: quad.graph })
        );
        normalized.push(nQuad);
      }
      normalized.sort();
      return normalized.join("");
    }
    hashFirstDegreeQuads(id3) {
      const nquads = [];
      const info = this.blankNodeInfo.get(id3);
      const quads = info.quads;
      for (const quad of quads) {
        const copy2 = {
          subject: null,
          predicate: quad.predicate,
          object: null,
          graph: null
        };
        copy2.subject = this.modifyFirstDegreeComponent(
          id3,
          quad.subject,
          "subject"
        );
        copy2.object = this.modifyFirstDegreeComponent(
          id3,
          quad.object,
          "object"
        );
        copy2.graph = this.modifyFirstDegreeComponent(
          id3,
          quad.graph,
          "graph"
        );
        nquads.push(NQuads$2.serializeQuad(copy2));
      }
      nquads.sort();
      const md2 = this.createMessageDigest();
      for (const nquad of nquads) {
        md2.update(nquad);
      }
      info.hash = md2.digest();
      return info.hash;
    }
    hashRelatedBlankNode(related, quad, issuer, position) {
      let id3;
      if (this.canonicalIssuer.hasId(related)) {
        id3 = this.canonicalIssuer.getId(related);
      } else if (issuer.hasId(related)) {
        id3 = issuer.getId(related);
      } else {
        id3 = this.blankNodeInfo.get(related).hash;
      }
      const md2 = this.createMessageDigest();
      md2.update(position);
      if (position !== "g") {
        md2.update(this.getRelatedPredicate(quad));
      }
      md2.update(id3);
      return md2.digest();
    }
    hashNDegreeQuads(id3, issuer) {
      const deepIterations = this.deepIterations.get(id3) || 0;
      if (deepIterations > this.maxDeepIterations) {
        throw new Error(
          `Maximum deep iterations (${this.maxDeepIterations}) exceeded.`
        );
      }
      this.deepIterations.set(id3, deepIterations + 1);
      const md2 = this.createMessageDigest();
      const hashToRelated = this.createHashToRelated(id3, issuer);
      const hashes = [...hashToRelated.keys()].sort();
      for (const hash2 of hashes) {
        md2.update(hash2);
        let chosenPath = "";
        let chosenIssuer;
        const permuter = new Permuter2(hashToRelated.get(hash2));
        while (permuter.hasNext()) {
          const permutation = permuter.next();
          let issuerCopy = issuer.clone();
          let path = "";
          const recursionList = [];
          let nextPermutation = false;
          for (const related of permutation) {
            if (this.canonicalIssuer.hasId(related)) {
              path += this.canonicalIssuer.getId(related);
            } else {
              if (!issuerCopy.hasId(related)) {
                recursionList.push(related);
              }
              path += issuerCopy.getId(related);
            }
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          for (const related of recursionList) {
            const result = this.hashNDegreeQuads(related, issuerCopy);
            path += issuerCopy.getId(related);
            path += `<${result.hash}>`;
            issuerCopy = result.issuer;
            if (chosenPath.length !== 0 && path > chosenPath) {
              nextPermutation = true;
              break;
            }
          }
          if (nextPermutation) {
            continue;
          }
          if (chosenPath.length === 0 || path < chosenPath) {
            chosenPath = path;
            chosenIssuer = issuerCopy;
          }
        }
        md2.update(chosenPath);
        issuer = chosenIssuer;
      }
      return { hash: md2.digest(), issuer };
    }
    modifyFirstDegreeComponent(id3, component) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      return {
        termType: "BlankNode",
        value: component.value === id3 ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return `<${quad.predicate.value}>`;
    }
    createHashToRelated(id3, issuer) {
      const hashToRelated = /* @__PURE__ */ new Map();
      const quads = this.blankNodeInfo.get(id3).quads;
      for (const quad of quads) {
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.subject,
          position: "s",
          id: id3,
          issuer,
          hashToRelated
        });
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.object,
          position: "o",
          id: id3,
          issuer,
          hashToRelated
        });
        this._addRelatedBlankNodeHash({
          quad,
          component: quad.graph,
          position: "g",
          id: id3,
          issuer,
          hashToRelated
        });
      }
      return hashToRelated;
    }
    _hashAndTrackBlankNode({ id: id3, hashToBlankNodes }) {
      const hash2 = this.hashFirstDegreeQuads(id3);
      const idList = hashToBlankNodes.get(hash2);
      if (!idList) {
        hashToBlankNodes.set(hash2, [id3]);
      } else {
        idList.push(id3);
      }
    }
    _addBlankNodeQuadInfo({ quad, component }) {
      if (component.termType !== "BlankNode") {
        return;
      }
      const id3 = component.value;
      const info = this.blankNodeInfo.get(id3);
      if (info) {
        info.quads.add(quad);
      } else {
        this.blankNodeInfo.set(id3, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
      }
    }
    _addRelatedBlankNodeHash({ quad, component, position, id: id3, issuer, hashToRelated }) {
      if (!(component.termType === "BlankNode" && component.value !== id3)) {
        return;
      }
      const related = component.value;
      const hash2 = this.hashRelatedBlankNode(related, quad, issuer, position);
      const entries2 = hashToRelated.get(hash2);
      if (entries2) {
        entries2.push(related);
      } else {
        hashToRelated.set(hash2, [related]);
      }
    }
    _componentWithCanonicalId({ component }) {
      if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
        return {
          termType: "BlankNode",
          value: this.canonicalIssuer.getId(component.value)
        };
      }
      return component;
    }
  };
  function _stringHashCompare(a4, b7) {
    return a4.hash < b7.hash ? -1 : a4.hash > b7.hash ? 1 : 0;
  }
  var MessageDigest2 = MessageDigestBrowser;
  var URDNA2015Sync2 = URDNA2015Sync_1;
  var URGNA2012Sync = class URDNA2012Sync extends URDNA2015Sync2 {
    constructor() {
      super();
      this.name = "URGNA2012";
      this.createMessageDigest = () => new MessageDigest2("sha1");
    }
    modifyFirstDegreeComponent(id3, component, key) {
      if (component.termType !== "BlankNode") {
        return component;
      }
      if (key === "graph") {
        return {
          termType: "BlankNode",
          value: "_:g"
        };
      }
      return {
        termType: "BlankNode",
        value: component.value === id3 ? "_:a" : "_:z"
      };
    }
    getRelatedPredicate(quad) {
      return quad.predicate.value;
    }
    createHashToRelated(id3, issuer) {
      const hashToRelated = /* @__PURE__ */ new Map();
      const quads = this.blankNodeInfo.get(id3).quads;
      for (const quad of quads) {
        let position;
        let related;
        if (quad.subject.termType === "BlankNode" && quad.subject.value !== id3) {
          related = quad.subject.value;
          position = "p";
        } else if (quad.object.termType === "BlankNode" && quad.object.value !== id3) {
          related = quad.object.value;
          position = "r";
        } else {
          continue;
        }
        const hash2 = this.hashRelatedBlankNode(related, quad, issuer, position);
        const entries2 = hashToRelated.get(hash2);
        if (entries2) {
          entries2.push(related);
        } else {
          hashToRelated.set(hash2, [related]);
        }
      }
      return hashToRelated;
    }
  };
  var _nodeResolve_empty = {};
  var _nodeResolve_empty$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });
  var require$$4$2 = /* @__PURE__ */ getAugmentedNamespace(_nodeResolve_empty$1);
  (function(exports) {
    const URDNA20153 = URDNA2015_1;
    const URGNA2012$1 = URGNA2012;
    const URDNA2015Sync3 = URDNA2015Sync_1;
    const URGNA2012Sync$1 = URGNA2012Sync;
    let rdfCanonizeNative;
    try {
      rdfCanonizeNative = require$$4$2;
    } catch (e7) {
    }
    function _inputToDataset(input) {
      if (!Array.isArray(input)) {
        return exports.NQuads.legacyDatasetToQuads(input);
      }
      return input;
    }
    exports.NQuads = NQuads_1;
    exports.IdentifierIssuer = IdentifierIssuer_1;
    exports._rdfCanonizeNative = function(api2) {
      if (api2) {
        rdfCanonizeNative = api2;
      }
      return rdfCanonizeNative;
    };
    exports.canonize = async function(input, options) {
      const dataset = _inputToDataset(input);
      if (options.useNative) {
        if (!rdfCanonizeNative) {
          throw new Error("rdf-canonize-native not available");
        }
        if (options.createMessageDigest) {
          throw new Error(
            '"createMessageDigest" cannot be used with "useNative".'
          );
        }
        return new Promise((resolve2, reject) => rdfCanonizeNative.canonize(dataset, options, (err, canonical) => err ? reject(err) : resolve2(canonical)));
      }
      if (options.algorithm === "URDNA2015") {
        return new URDNA20153(options).main(dataset);
      }
      if (options.algorithm === "URGNA2012") {
        if (options.createMessageDigest) {
          throw new Error(
            '"createMessageDigest" cannot be used with "URGNA2012".'
          );
        }
        return new URGNA2012$1(options).main(dataset);
      }
      if (!("algorithm" in options)) {
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      }
      throw new Error(
        "Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm
      );
    };
    exports._canonizeSync = function(input, options) {
      const dataset = _inputToDataset(input);
      if (options.useNative) {
        if (!rdfCanonizeNative) {
          throw new Error("rdf-canonize-native not available");
        }
        if (options.createMessageDigest) {
          throw new Error(
            '"createMessageDigest" cannot be used with "useNative".'
          );
        }
        return rdfCanonizeNative.canonizeSync(dataset, options);
      }
      if (options.algorithm === "URDNA2015") {
        return new URDNA2015Sync3(options).main(dataset);
      }
      if (options.algorithm === "URGNA2012") {
        if (options.createMessageDigest) {
          throw new Error(
            '"createMessageDigest" cannot be used with "URGNA2012".'
          );
        }
        return new URGNA2012Sync$1(options).main(dataset);
      }
      if (!("algorithm" in options)) {
        throw new Error("No RDF Dataset Canonicalization algorithm specified.");
      }
      throw new Error(
        "Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm
      );
    };
  })(lib);
  var rdfCanonize = lib;
  var api$d = {};
  var types$8 = api$d;
  api$d.isArray = Array.isArray;
  api$d.isBoolean = (v6) => typeof v6 === "boolean" || Object.prototype.toString.call(v6) === "[object Boolean]";
  api$d.isDouble = (v6) => api$d.isNumber(v6) && (String(v6).indexOf(".") !== -1 || Math.abs(v6) >= 1e21);
  api$d.isEmptyObject = (v6) => api$d.isObject(v6) && Object.keys(v6).length === 0;
  api$d.isNumber = (v6) => typeof v6 === "number" || Object.prototype.toString.call(v6) === "[object Number]";
  api$d.isNumeric = (v6) => !isNaN(parseFloat(v6)) && isFinite(v6);
  api$d.isObject = (v6) => Object.prototype.toString.call(v6) === "[object Object]";
  api$d.isString = (v6) => typeof v6 === "string" || Object.prototype.toString.call(v6) === "[object String]";
  api$d.isUndefined = (v6) => typeof v6 === "undefined";
  var types$7 = types$8;
  var api$c = {};
  var graphTypes$5 = api$c;
  api$c.isSubject = (v6) => {
    if (types$7.isObject(v6) && !("@value" in v6 || "@set" in v6 || "@list" in v6)) {
      const keyCount = Object.keys(v6).length;
      return keyCount > 1 || !("@id" in v6);
    }
    return false;
  };
  api$c.isSubjectReference = (v6) => types$7.isObject(v6) && Object.keys(v6).length === 1 && "@id" in v6;
  api$c.isValue = (v6) => types$7.isObject(v6) && "@value" in v6;
  api$c.isList = (v6) => types$7.isObject(v6) && "@list" in v6;
  api$c.isGraph = (v6) => {
    return types$7.isObject(v6) && "@graph" in v6 && Object.keys(v6).filter((key) => key !== "@id" && key !== "@index").length === 1;
  };
  api$c.isSimpleGraph = (v6) => {
    return api$c.isGraph(v6) && !("@id" in v6);
  };
  api$c.isBlankNode = (v6) => {
    if (types$7.isObject(v6)) {
      if ("@id" in v6) {
        const id3 = v6["@id"];
        return !types$7.isString(id3) || id3.indexOf("_:") === 0;
      }
      return Object.keys(v6).length === 0 || !("@value" in v6 || "@set" in v6 || "@list" in v6);
    }
    return false;
  };
  var JsonLdError_1 = class JsonLdError extends Error {
    constructor(message = "An unspecified JSON-LD error occurred.", name = "jsonld.Error", details = {}) {
      super(message);
      this.name = name;
      this.message = message;
      this.details = details;
    }
  };
  var graphTypes$4 = graphTypes$5;
  var types$6 = types$8;
  var IdentifierIssuer$1 = rdfCanonize.IdentifierIssuer;
  var JsonLdError$b = JsonLdError_1;
  var REGEX_BCP47$3 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
  var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
  var REGEX_LINK_HEADER$1 = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
  var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
  var REGEX_KEYWORD$3 = /^@[a-zA-Z]+$/;
  var DEFAULTS = {
    headers: {
      accept: "application/ld+json, application/json"
    }
  };
  var api$b = {};
  var util$6 = api$b;
  api$b.IdentifierIssuer = IdentifierIssuer$1;
  api$b.REGEX_BCP47 = REGEX_BCP47$3;
  api$b.REGEX_KEYWORD = REGEX_KEYWORD$3;
  api$b.clone = function(value) {
    if (value && typeof value === "object") {
      let rval;
      if (types$6.isArray(value)) {
        rval = [];
        for (let i4 = 0; i4 < value.length; ++i4) {
          rval[i4] = api$b.clone(value[i4]);
        }
      } else if (value instanceof Map) {
        rval = /* @__PURE__ */ new Map();
        for (const [k5, v6] of value) {
          rval.set(k5, api$b.clone(v6));
        }
      } else if (value instanceof Set) {
        rval = /* @__PURE__ */ new Set();
        for (const v6 of value) {
          rval.add(api$b.clone(v6));
        }
      } else if (types$6.isObject(value)) {
        rval = {};
        for (const key in value) {
          rval[key] = api$b.clone(value[key]);
        }
      } else {
        rval = value.toString();
      }
      return rval;
    }
    return value;
  };
  api$b.asArray = function(value) {
    return Array.isArray(value) ? value : [value];
  };
  api$b.buildHeaders = (headers = {}) => {
    const hasAccept = Object.keys(headers).some(
      (h6) => h6.toLowerCase() === "accept"
    );
    if (hasAccept) {
      throw new RangeError(
        'Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.'
      );
    }
    return Object.assign({ Accept: DEFAULTS.headers.accept }, headers);
  };
  api$b.parseLinkHeader = (header) => {
    const rval = {};
    const entries2 = header.match(REGEX_LINK_HEADERS);
    for (let i4 = 0; i4 < entries2.length; ++i4) {
      let match = entries2[i4].match(REGEX_LINK_HEADER$1);
      if (!match) {
        continue;
      }
      const result = { target: match[1] };
      const params = match[2];
      while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
        result[match[1]] = match[2] === void 0 ? match[3] : match[2];
      }
      const rel = result.rel || "";
      if (Array.isArray(rval[rel])) {
        rval[rel].push(result);
      } else if (rval.hasOwnProperty(rel)) {
        rval[rel] = [rval[rel], result];
      } else {
        rval[rel] = result;
      }
    }
    return rval;
  };
  api$b.validateTypeValue = (v6, isFrame) => {
    if (types$6.isString(v6)) {
      return;
    }
    if (types$6.isArray(v6) && v6.every((vv) => types$6.isString(vv))) {
      return;
    }
    if (isFrame && types$6.isObject(v6)) {
      switch (Object.keys(v6).length) {
        case 0:
          return;
        case 1:
          if ("@default" in v6 && api$b.asArray(v6["@default"]).every((vv) => types$6.isString(vv))) {
            return;
          }
      }
    }
    throw new JsonLdError$b(
      'Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',
      "jsonld.SyntaxError",
      { code: "invalid type value", value: v6 }
    );
  };
  api$b.hasProperty = (subject, property) => {
    if (subject.hasOwnProperty(property)) {
      const value = subject[property];
      return !types$6.isArray(value) || value.length > 0;
    }
    return false;
  };
  api$b.hasValue = (subject, property, value) => {
    if (api$b.hasProperty(subject, property)) {
      let val = subject[property];
      const isList = graphTypes$4.isList(val);
      if (types$6.isArray(val) || isList) {
        if (isList) {
          val = val["@list"];
        }
        for (let i4 = 0; i4 < val.length; ++i4) {
          if (api$b.compareValues(value, val[i4])) {
            return true;
          }
        }
      } else if (!types$6.isArray(value)) {
        return api$b.compareValues(value, val);
      }
    }
    return false;
  };
  api$b.addValue = (subject, property, value, options) => {
    options = options || {};
    if (!("propertyIsArray" in options)) {
      options.propertyIsArray = false;
    }
    if (!("valueIsArray" in options)) {
      options.valueIsArray = false;
    }
    if (!("allowDuplicate" in options)) {
      options.allowDuplicate = true;
    }
    if (!("prependValue" in options)) {
      options.prependValue = false;
    }
    if (options.valueIsArray) {
      subject[property] = value;
    } else if (types$6.isArray(value)) {
      if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
        subject[property] = [];
      }
      if (options.prependValue) {
        value = value.concat(subject[property]);
        subject[property] = [];
      }
      for (let i4 = 0; i4 < value.length; ++i4) {
        api$b.addValue(subject, property, value[i4], options);
      }
    } else if (subject.hasOwnProperty(property)) {
      const hasValue = !options.allowDuplicate && api$b.hasValue(subject, property, value);
      if (!types$6.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
        subject[property] = [subject[property]];
      }
      if (!hasValue) {
        if (options.prependValue) {
          subject[property].unshift(value);
        } else {
          subject[property].push(value);
        }
      }
    } else {
      subject[property] = options.propertyIsArray ? [value] : value;
    }
  };
  api$b.getValues = (subject, property) => [].concat(subject[property] || []);
  api$b.removeProperty = (subject, property) => {
    delete subject[property];
  };
  api$b.removeValue = (subject, property, value, options) => {
    options = options || {};
    if (!("propertyIsArray" in options)) {
      options.propertyIsArray = false;
    }
    const values = api$b.getValues(subject, property).filter(
      (e7) => !api$b.compareValues(e7, value)
    );
    if (values.length === 0) {
      api$b.removeProperty(subject, property);
    } else if (values.length === 1 && !options.propertyIsArray) {
      subject[property] = values[0];
    } else {
      subject[property] = values;
    }
  };
  api$b.relabelBlankNodes = (input, options) => {
    options = options || {};
    const issuer = options.issuer || new IdentifierIssuer$1("_:b");
    return _labelBlankNodes(issuer, input);
  };
  api$b.compareValues = (v1, v22) => {
    if (v1 === v22) {
      return true;
    }
    if (graphTypes$4.isValue(v1) && graphTypes$4.isValue(v22) && v1["@value"] === v22["@value"] && v1["@type"] === v22["@type"] && v1["@language"] === v22["@language"] && v1["@index"] === v22["@index"]) {
      return true;
    }
    if (types$6.isObject(v1) && "@id" in v1 && types$6.isObject(v22) && "@id" in v22) {
      return v1["@id"] === v22["@id"];
    }
    return false;
  };
  api$b.compareShortestLeast = (a4, b7) => {
    if (a4.length < b7.length) {
      return -1;
    }
    if (b7.length < a4.length) {
      return 1;
    }
    if (a4 === b7) {
      return 0;
    }
    return a4 < b7 ? -1 : 1;
  };
  function _labelBlankNodes(issuer, element) {
    if (types$6.isArray(element)) {
      for (let i4 = 0; i4 < element.length; ++i4) {
        element[i4] = _labelBlankNodes(issuer, element[i4]);
      }
    } else if (graphTypes$4.isList(element)) {
      element["@list"] = _labelBlankNodes(issuer, element["@list"]);
    } else if (types$6.isObject(element)) {
      if (graphTypes$4.isBlankNode(element)) {
        element["@id"] = issuer.getId(element["@id"]);
      }
      const keys = Object.keys(element).sort();
      for (let ki2 = 0; ki2 < keys.length; ++ki2) {
        const key = keys[ki2];
        if (key !== "@id") {
          element[key] = _labelBlankNodes(issuer, element[key]);
        }
      }
    }
    return element;
  }
  var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  var XSD = "http://www.w3.org/2001/XMLSchema#";
  var constants$1 = {
    LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
    LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context",
    RDF,
    RDF_LIST: RDF + "List",
    RDF_FIRST: RDF + "first",
    RDF_REST: RDF + "rest",
    RDF_NIL: RDF + "nil",
    RDF_TYPE: RDF + "type",
    RDF_PLAIN_LITERAL: RDF + "PlainLiteral",
    RDF_XML_LITERAL: RDF + "XMLLiteral",
    RDF_JSON_LITERAL: RDF + "JSON",
    RDF_OBJECT: RDF + "object",
    RDF_LANGSTRING: RDF + "langString",
    XSD,
    XSD_BOOLEAN: XSD + "boolean",
    XSD_DOUBLE: XSD + "double",
    XSD_INTEGER: XSD + "integer",
    XSD_STRING: XSD + "string"
  };
  var RequestQueue_1;
  var hasRequiredRequestQueue;
  function requireRequestQueue() {
    if (hasRequiredRequestQueue)
      return RequestQueue_1;
    hasRequiredRequestQueue = 1;
    RequestQueue_1 = class RequestQueue {
      constructor() {
        this._requests = {};
      }
      wrapLoader(loader) {
        const self2 = this;
        self2._loader = loader;
        return function() {
          return self2.add.apply(self2, arguments);
        };
      }
      async add(url2) {
        let promise = this._requests[url2];
        if (promise) {
          return Promise.resolve(promise);
        }
        promise = this._requests[url2] = this._loader(url2);
        try {
          return await promise;
        } finally {
          delete this._requests[url2];
        }
      }
    };
    return RequestQueue_1;
  }
  var types$5 = types$8;
  var api$a = {};
  var url$1 = api$a;
  api$a.parsers = {
    simple: {
      keys: [
        "href",
        "scheme",
        "authority",
        "path",
        "query",
        "fragment"
      ],
      regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
    },
    full: {
      keys: [
        "href",
        "protocol",
        "scheme",
        "authority",
        "auth",
        "user",
        "password",
        "hostname",
        "port",
        "path",
        "directory",
        "file",
        "query",
        "fragment"
      ],
      regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  };
  api$a.parse = (str, parser) => {
    const parsed = {};
    const o4 = api$a.parsers[parser || "full"];
    const m5 = o4.regex.exec(str);
    let i4 = o4.keys.length;
    while (i4--) {
      parsed[o4.keys[i4]] = m5[i4] === void 0 ? null : m5[i4];
    }
    if (parsed.scheme === "https" && parsed.port === "443" || parsed.scheme === "http" && parsed.port === "80") {
      parsed.href = parsed.href.replace(":" + parsed.port, "");
      parsed.authority = parsed.authority.replace(":" + parsed.port, "");
      parsed.port = null;
    }
    parsed.normalizedPath = api$a.removeDotSegments(parsed.path);
    return parsed;
  };
  api$a.prependBase = (base3, iri) => {
    if (base3 === null) {
      return iri;
    }
    if (api$a.isAbsolute(iri)) {
      return iri;
    }
    if (!base3 || types$5.isString(base3)) {
      base3 = api$a.parse(base3 || "");
    }
    const rel = api$a.parse(iri);
    const transform = {
      protocol: base3.protocol || ""
    };
    if (rel.authority !== null) {
      transform.authority = rel.authority;
      transform.path = rel.path;
      transform.query = rel.query;
    } else {
      transform.authority = base3.authority;
      if (rel.path === "") {
        transform.path = base3.path;
        if (rel.query !== null) {
          transform.query = rel.query;
        } else {
          transform.query = base3.query;
        }
      } else {
        if (rel.path.indexOf("/") === 0) {
          transform.path = rel.path;
        } else {
          let path = base3.path;
          path = path.substr(0, path.lastIndexOf("/") + 1);
          if ((path.length > 0 || base3.authority) && path.substr(-1) !== "/") {
            path += "/";
          }
          path += rel.path;
          transform.path = path;
        }
        transform.query = rel.query;
      }
    }
    if (rel.path !== "") {
      transform.path = api$a.removeDotSegments(transform.path);
    }
    let rval = transform.protocol;
    if (transform.authority !== null) {
      rval += "//" + transform.authority;
    }
    rval += transform.path;
    if (transform.query !== null) {
      rval += "?" + transform.query;
    }
    if (rel.fragment !== null) {
      rval += "#" + rel.fragment;
    }
    if (rval === "") {
      rval = "./";
    }
    return rval;
  };
  api$a.removeBase = (base3, iri) => {
    if (base3 === null) {
      return iri;
    }
    if (!base3 || types$5.isString(base3)) {
      base3 = api$a.parse(base3 || "");
    }
    let root = "";
    if (base3.href !== "") {
      root += (base3.protocol || "") + "//" + (base3.authority || "");
    } else if (iri.indexOf("//")) {
      root += "//";
    }
    if (iri.indexOf(root) !== 0) {
      return iri;
    }
    const rel = api$a.parse(iri.substr(root.length));
    const baseSegments = base3.normalizedPath.split("/");
    const iriSegments = rel.normalizedPath.split("/");
    const last = rel.fragment || rel.query ? 0 : 1;
    while (baseSegments.length > 0 && iriSegments.length > last) {
      if (baseSegments[0] !== iriSegments[0]) {
        break;
      }
      baseSegments.shift();
      iriSegments.shift();
    }
    let rval = "";
    if (baseSegments.length > 0) {
      baseSegments.pop();
      for (let i4 = 0; i4 < baseSegments.length; ++i4) {
        rval += "../";
      }
    }
    rval += iriSegments.join("/");
    if (rel.query !== null) {
      rval += "?" + rel.query;
    }
    if (rel.fragment !== null) {
      rval += "#" + rel.fragment;
    }
    if (rval === "") {
      rval = "./";
    }
    return rval;
  };
  api$a.removeDotSegments = (path) => {
    if (path.length === 0) {
      return "";
    }
    const input = path.split("/");
    const output2 = [];
    while (input.length > 0) {
      const next2 = input.shift();
      const done = input.length === 0;
      if (next2 === ".") {
        if (done) {
          output2.push("");
        }
        continue;
      }
      if (next2 === "..") {
        output2.pop();
        if (done) {
          output2.push("");
        }
        continue;
      }
      output2.push(next2);
    }
    if (path[0] === "/" && output2.length > 0 && output2[0] !== "") {
      output2.unshift("");
    }
    if (output2.length === 1 && output2[0] === "") {
      return "/";
    }
    return output2.join("/");
  };
  var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
  api$a.isAbsolute = (v6) => types$5.isString(v6) && isAbsoluteRegex.test(v6);
  api$a.isRelative = (v6) => types$5.isString(v6);
  var { parseLinkHeader, buildHeaders } = util$6;
  var { LINK_HEADER_CONTEXT } = constants$1;
  var JsonLdError$a = JsonLdError_1;
  var RequestQueue = requireRequestQueue();
  var { prependBase: prependBase$2 } = url$1;
  var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
  var xhr = ({
    secure,
    headers = {},
    xhr: xhr2
  } = { headers: {} }) => {
    headers = buildHeaders(headers);
    const queue = new RequestQueue();
    return queue.wrapLoader(loader);
    async function loader(url2) {
      if (url2.indexOf("http:") !== 0 && url2.indexOf("https:") !== 0) {
        throw new JsonLdError$a(
          'URL could not be dereferenced; only "http" and "https" URLs are supported.',
          "jsonld.InvalidUrl",
          { code: "loading document failed", url: url2 }
        );
      }
      if (secure && url2.indexOf("https") !== 0) {
        throw new JsonLdError$a(
          `URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,
          "jsonld.InvalidUrl",
          { code: "loading document failed", url: url2 }
        );
      }
      let req;
      try {
        req = await _get(xhr2, url2, headers);
      } catch (e7) {
        throw new JsonLdError$a(
          "URL could not be dereferenced, an error occurred.",
          "jsonld.LoadDocumentError",
          { code: "loading document failed", url: url2, cause: e7 }
        );
      }
      if (req.status >= 400) {
        throw new JsonLdError$a(
          "URL could not be dereferenced: " + req.statusText,
          "jsonld.LoadDocumentError",
          {
            code: "loading document failed",
            url: url2,
            httpStatusCode: req.status
          }
        );
      }
      let doc2 = { contextUrl: null, documentUrl: url2, document: req.response };
      let alternate = null;
      const contentType = req.getResponseHeader("Content-Type");
      let linkHeader;
      if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
        linkHeader = req.getResponseHeader("Link");
      }
      if (linkHeader && contentType !== "application/ld+json") {
        const linkHeaders = parseLinkHeader(linkHeader);
        const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];
        if (Array.isArray(linkedContext)) {
          throw new JsonLdError$a(
            "URL could not be dereferenced, it has more than one associated HTTP Link Header.",
            "jsonld.InvalidUrl",
            { code: "multiple context link headers", url: url2 }
          );
        }
        if (linkedContext) {
          doc2.contextUrl = linkedContext.target;
        }
        alternate = linkHeaders.alternate;
        if (alternate && alternate.type == "application/ld+json" && !(contentType || "").match(/^application\/(\w*\+)?json$/)) {
          doc2 = await loader(prependBase$2(url2, alternate.target));
        }
      }
      return doc2;
    }
  };
  function _get(xhr2, url2, headers) {
    xhr2 = xhr2 || XMLHttpRequest;
    const req = new xhr2();
    return new Promise((resolve2, reject) => {
      req.onload = () => resolve2(req);
      req.onerror = (err) => reject(err);
      req.open("GET", url2, true);
      for (const k5 in headers) {
        req.setRequestHeader(k5, headers[k5]);
      }
      req.send();
    });
  }
  var xhrLoader = xhr;
  var api$9 = {};
  var platformBrowser = api$9;
  api$9.setupDocumentLoaders = function(jsonld2) {
    if (typeof XMLHttpRequest !== "undefined") {
      jsonld2.documentLoaders.xhr = xhrLoader;
      jsonld2.useDocumentLoader("xhr");
    }
  };
  api$9.setupGlobals = function(jsonld2) {
    if (typeof globalThis.JsonLdProcessor === "undefined") {
      Object.defineProperty(globalThis, "JsonLdProcessor", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: jsonld2.JsonLdProcessor
      });
    }
  };
  var iterator;
  var hasRequiredIterator;
  function requireIterator() {
    if (hasRequiredIterator)
      return iterator;
    hasRequiredIterator = 1;
    iterator = function(Yallist2) {
      Yallist2.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
    return iterator;
  }
  var yallist = Yallist$1;
  Yallist$1.Node = Node;
  Yallist$1.create = Yallist$1;
  function Yallist$1(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist$1)) {
      self2 = new Yallist$1();
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i4 = 0, l6 = arguments.length; i4 < l6; i4++) {
        self2.push(arguments[i4]);
      }
    }
    return self2;
  }
  Yallist$1.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next2 = node.next;
    var prev2 = node.prev;
    if (next2) {
      next2.prev = prev2;
    }
    if (prev2) {
      prev2.next = next2;
    }
    if (node === this.head) {
      this.head = next2;
    }
    if (node === this.tail) {
      this.tail = prev2;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next2;
  };
  Yallist$1.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head2 = this.head;
    node.list = this;
    node.next = head2;
    if (head2) {
      head2.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist$1.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist$1.prototype.push = function() {
    for (var i4 = 0, l6 = arguments.length; i4 < l6; i4++) {
      push(this, arguments[i4]);
    }
    return this.length;
  };
  Yallist$1.prototype.unshift = function() {
    for (var i4 = 0, l6 = arguments.length; i4 < l6; i4++) {
      unshift(this, arguments[i4]);
    }
    return this.length;
  };
  Yallist$1.prototype.pop = function() {
    if (!this.tail) {
      return void 0;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist$1.prototype.shift = function() {
    if (!this.head) {
      return void 0;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist$1.prototype.forEach = function(fn2, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i4 = 0; walker !== null; i4++) {
      fn2.call(thisp, walker.value, i4, this);
      walker = walker.next;
    }
  };
  Yallist$1.prototype.forEachReverse = function(fn2, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i4 = this.length - 1; walker !== null; i4--) {
      fn2.call(thisp, walker.value, i4, this);
      walker = walker.prev;
    }
  };
  Yallist$1.prototype.get = function(n4) {
    for (var i4 = 0, walker = this.head; walker !== null && i4 < n4; i4++) {
      walker = walker.next;
    }
    if (i4 === n4 && walker !== null) {
      return walker.value;
    }
  };
  Yallist$1.prototype.getReverse = function(n4) {
    for (var i4 = 0, walker = this.tail; walker !== null && i4 < n4; i4++) {
      walker = walker.prev;
    }
    if (i4 === n4 && walker !== null) {
      return walker.value;
    }
  };
  Yallist$1.prototype.map = function(fn2, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();
    for (var walker = this.head; walker !== null; ) {
      res.push(fn2.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist$1.prototype.mapReverse = function(fn2, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();
    for (var walker = this.tail; walker !== null; ) {
      res.push(fn2.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist$1.prototype.reduce = function(fn2, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i4 = 0; walker !== null; i4++) {
      acc = fn2(acc, walker.value, i4);
      walker = walker.next;
    }
    return acc;
  };
  Yallist$1.prototype.reduceReverse = function(fn2, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i4 = this.length - 1; walker !== null; i4--) {
      acc = fn2(acc, walker.value, i4);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist$1.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i4 = 0, walker = this.head; walker !== null; i4++) {
      arr[i4] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist$1.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i4 = 0, walker = this.tail; walker !== null; i4++) {
      arr[i4] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist$1.prototype.slice = function(from2, to2) {
    to2 = to2 || this.length;
    if (to2 < 0) {
      to2 += this.length;
    }
    from2 = from2 || 0;
    if (from2 < 0) {
      from2 += this.length;
    }
    var ret = new Yallist$1();
    if (to2 < from2 || to2 < 0) {
      return ret;
    }
    if (from2 < 0) {
      from2 = 0;
    }
    if (to2 > this.length) {
      to2 = this.length;
    }
    for (var i4 = 0, walker = this.head; walker !== null && i4 < from2; i4++) {
      walker = walker.next;
    }
    for (; walker !== null && i4 < to2; i4++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist$1.prototype.sliceReverse = function(from2, to2) {
    to2 = to2 || this.length;
    if (to2 < 0) {
      to2 += this.length;
    }
    from2 = from2 || 0;
    if (from2 < 0) {
      from2 += this.length;
    }
    var ret = new Yallist$1();
    if (to2 < from2 || to2 < 0) {
      return ret;
    }
    if (from2 < 0) {
      from2 = 0;
    }
    if (to2 > this.length) {
      to2 = this.length;
    }
    for (var i4 = this.length, walker = this.tail; walker !== null && i4 > to2; i4--) {
      walker = walker.prev;
    }
    for (; walker !== null && i4 > from2; i4--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist$1.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i4 = 0, walker = this.head; walker !== null && i4 < start; i4++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i4 = 0; walker && i4 < deleteCount; i4++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i4 = 0; i4 < nodes.length; i4++) {
      walker = insert(this, walker, nodes[i4]);
    }
    return ret;
  };
  Yallist$1.prototype.reverse = function() {
    var head2 = this.head;
    var tail = this.tail;
    for (var walker = head2; walker !== null; walker = walker.prev) {
      var p6 = walker.prev;
      walker.prev = walker.next;
      walker.next = p6;
    }
    this.head = tail;
    this.tail = head2;
    return this;
  };
  function insert(self2, node, value) {
    var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  }
  function push(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  }
  function unshift(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  }
  function Node(value, prev2, next2, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev2, next2, list);
    }
    this.list = list;
    this.value = value;
    if (prev2) {
      prev2.next = this;
      this.prev = prev2;
    } else {
      this.prev = null;
    }
    if (next2) {
      next2.prev = this;
      this.next = next2;
    } else {
      this.next = null;
    }
  }
  try {
    requireIterator()(Yallist$1);
  } catch (er2) {
  }
  var Yallist = yallist;
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;
  var LRUCache = class {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      this[MAX] = options.max || Infinity;
      const lc2 = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc2 !== "function" ? naiveLength : lc2;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn2, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail; walker !== null; ) {
        const prev2 = walker.prev;
        forEachStep(this, fn2, walker, thisp);
        walker = prev2;
      }
    }
    forEach(fn2, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head; walker !== null; ) {
        const next2 = walker.next;
        forEachStep(this, fn2, walker, thisp);
        walker = next2;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k5) => k5.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k5) => k5.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = /* @__PURE__ */ new Map();
      this[LRU_LIST] = new Yallist();
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h6) => h6);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l6 = arr.length - 1; l6 >= 0; l6--) {
        const hit = arr[l6];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value, key) => get(this, key, false));
    }
  };
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return void 0;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev2 = walker.prev;
        del(self2, walker);
        walker = prev2;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };
  var Entry = class {
    constructor(key, value, length2, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length2;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  };
  var forEachStep = (self2, fn2, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = void 0;
    }
    if (hit)
      fn2.call(thisp, hit.value, hit.key, self2);
  };
  var lruCache = LRUCache;
  var LRU$1 = lruCache;
  var MAX_ACTIVE_CONTEXTS = 10;
  var ResolvedContext_1 = class ResolvedContext {
    constructor({ document }) {
      this.document = document;
      this.cache = new LRU$1({ max: MAX_ACTIVE_CONTEXTS });
    }
    getProcessed(activeCtx) {
      return this.cache.get(activeCtx);
    }
    setProcessed(activeCtx, processedCtx) {
      this.cache.set(activeCtx, processedCtx);
    }
  };
  var {
    isArray: _isArray$5,
    isObject: _isObject$4,
    isString: _isString$4
  } = types$8;
  var {
    asArray: _asArray$4
  } = util$6;
  var { prependBase: prependBase$1 } = url$1;
  var JsonLdError$9 = JsonLdError_1;
  var ResolvedContext2 = ResolvedContext_1;
  var MAX_CONTEXT_URLS = 10;
  var ContextResolver_1 = class ContextResolver {
    constructor({ sharedCache }) {
      this.perOpCache = /* @__PURE__ */ new Map();
      this.sharedCache = sharedCache;
    }
    async resolve({
      activeCtx,
      context: context2,
      documentLoader,
      base: base3,
      cycles = /* @__PURE__ */ new Set()
    }) {
      if (context2 && _isObject$4(context2) && context2["@context"]) {
        context2 = context2["@context"];
      }
      context2 = _asArray$4(context2);
      const allResolved = [];
      for (const ctx of context2) {
        if (_isString$4(ctx)) {
          let resolved2 = this._get(ctx);
          if (!resolved2) {
            resolved2 = await this._resolveRemoteContext(
              { activeCtx, url: ctx, documentLoader, base: base3, cycles }
            );
          }
          if (_isArray$5(resolved2)) {
            allResolved.push(...resolved2);
          } else {
            allResolved.push(resolved2);
          }
          continue;
        }
        if (ctx === null) {
          allResolved.push(new ResolvedContext2({ document: null }));
          continue;
        }
        if (!_isObject$4(ctx)) {
          _throwInvalidLocalContext(context2);
        }
        const key = JSON.stringify(ctx);
        let resolved = this._get(key);
        if (!resolved) {
          resolved = new ResolvedContext2({ document: ctx });
          this._cacheResolvedContext({ key, resolved, tag: "static" });
        }
        allResolved.push(resolved);
      }
      return allResolved;
    }
    _get(key) {
      let resolved = this.perOpCache.get(key);
      if (!resolved) {
        const tagMap = this.sharedCache.get(key);
        if (tagMap) {
          resolved = tagMap.get("static");
          if (resolved) {
            this.perOpCache.set(key, resolved);
          }
        }
      }
      return resolved;
    }
    _cacheResolvedContext({ key, resolved, tag }) {
      this.perOpCache.set(key, resolved);
      if (tag !== void 0) {
        let tagMap = this.sharedCache.get(key);
        if (!tagMap) {
          tagMap = /* @__PURE__ */ new Map();
          this.sharedCache.set(key, tagMap);
        }
        tagMap.set(tag, resolved);
      }
      return resolved;
    }
    async _resolveRemoteContext({ activeCtx, url: url2, documentLoader, base: base3, cycles }) {
      url2 = prependBase$1(base3, url2);
      const { context: context2, remoteDoc } = await this._fetchContext(
        { activeCtx, url: url2, documentLoader, cycles }
      );
      base3 = remoteDoc.documentUrl || url2;
      _resolveContextUrls({ context: context2, base: base3 });
      const resolved = await this.resolve(
        { activeCtx, context: context2, documentLoader, base: base3, cycles }
      );
      this._cacheResolvedContext({ key: url2, resolved, tag: remoteDoc.tag });
      return resolved;
    }
    async _fetchContext({ activeCtx, url: url2, documentLoader, cycles }) {
      if (cycles.size > MAX_CONTEXT_URLS) {
        throw new JsonLdError$9(
          "Maximum number of @context URLs exceeded.",
          "jsonld.ContextUrlError",
          {
            code: activeCtx.processingMode === "json-ld-1.0" ? "loading remote context failed" : "context overflow",
            max: MAX_CONTEXT_URLS
          }
        );
      }
      if (cycles.has(url2)) {
        throw new JsonLdError$9(
          "Cyclical @context URLs detected.",
          "jsonld.ContextUrlError",
          {
            code: activeCtx.processingMode === "json-ld-1.0" ? "recursive context inclusion" : "context overflow",
            url: url2
          }
        );
      }
      cycles.add(url2);
      let context2;
      let remoteDoc;
      try {
        remoteDoc = await documentLoader(url2);
        context2 = remoteDoc.document || null;
        if (_isString$4(context2)) {
          context2 = JSON.parse(context2);
        }
      } catch (e7) {
        throw new JsonLdError$9(
          "Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.",
          "jsonld.InvalidUrl",
          { code: "loading remote context failed", url: url2, cause: e7 }
        );
      }
      if (!_isObject$4(context2)) {
        throw new JsonLdError$9(
          "Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.",
          "jsonld.InvalidUrl",
          { code: "invalid remote context", url: url2 }
        );
      }
      if (!("@context" in context2)) {
        context2 = { "@context": {} };
      } else {
        context2 = { "@context": context2["@context"] };
      }
      if (remoteDoc.contextUrl) {
        if (!_isArray$5(context2["@context"])) {
          context2["@context"] = [context2["@context"]];
        }
        context2["@context"].push(remoteDoc.contextUrl);
      }
      return { context: context2, remoteDoc };
    }
  };
  function _throwInvalidLocalContext(ctx) {
    throw new JsonLdError$9(
      "Invalid JSON-LD syntax; @context must be an object.",
      "jsonld.SyntaxError",
      {
        code: "invalid local context",
        context: ctx
      }
    );
  }
  function _resolveContextUrls({ context: context2, base: base3 }) {
    if (!context2) {
      return;
    }
    const ctx = context2["@context"];
    if (_isString$4(ctx)) {
      context2["@context"] = prependBase$1(base3, ctx);
      return;
    }
    if (_isArray$5(ctx)) {
      for (let i4 = 0; i4 < ctx.length; ++i4) {
        const element = ctx[i4];
        if (_isString$4(element)) {
          ctx[i4] = prependBase$1(base3, element);
          continue;
        }
        if (_isObject$4(element)) {
          _resolveContextUrls({ context: { "@context": element }, base: base3 });
        }
      }
      return;
    }
    if (!_isObject$4(ctx)) {
      return;
    }
    for (const term in ctx) {
      _resolveContextUrls({ context: ctx[term], base: base3 });
    }
  }
  var NQuads$1 = rdfCanonize.NQuads;
  var JsonLdError$8 = JsonLdError_1;
  var {
    isArray: _isArray$4
  } = types$8;
  var {
    asArray: _asArray$3
  } = util$6;
  var api$8 = {};
  var events = api$8;
  api$8.defaultEventHandler = null;
  api$8.setupEventHandler = ({ options = {} }) => {
    const eventHandler = [].concat(
      options.safe ? api$8.safeEventHandler : [],
      options.eventHandler ? _asArray$3(options.eventHandler) : [],
      api$8.defaultEventHandler ? api$8.defaultEventHandler : []
    );
    return eventHandler.length === 0 ? null : eventHandler;
  };
  api$8.handleEvent = ({
    event,
    options
  }) => {
    _handle({ event, handlers: options.eventHandler });
  };
  function _handle({ event, handlers }) {
    let doNext = true;
    for (let i4 = 0; doNext && i4 < handlers.length; ++i4) {
      doNext = false;
      const handler = handlers[i4];
      if (_isArray$4(handler)) {
        doNext = _handle({ event, handlers: handler });
      } else if (typeof handler === "function") {
        handler({ event, next: () => {
          doNext = true;
        } });
      } else if (typeof handler === "object") {
        if (event.code in handler) {
          handler[event.code]({ event, next: () => {
            doNext = true;
          } });
        } else {
          doNext = true;
        }
      } else {
        throw new JsonLdError$8(
          "Invalid event handler.",
          "jsonld.InvalidEventHandler",
          { event }
        );
      }
    }
    return doNext;
  }
  var _notSafeEventCodes = /* @__PURE__ */ new Set([
    "empty object",
    "free-floating scalar",
    "invalid @language value",
    "invalid property",
    "null @id value",
    "null @value value",
    "object with only @id",
    "object with only @language",
    "object with only @list",
    "object with only @value",
    "relative @id reference",
    "relative @type reference",
    "relative @vocab reference",
    "reserved @id value",
    "reserved @reverse value",
    "reserved term",
    "blank node predicate",
    "relative graph reference",
    "relative object reference",
    "relative predicate reference",
    "relative subject reference",
    "rdfDirection not set"
  ]);
  api$8.safeEventHandler = function safeEventHandler({ event, next: next2 }) {
    if (event.level === "warning" && _notSafeEventCodes.has(event.code)) {
      throw new JsonLdError$8(
        "Safe mode validation error.",
        "jsonld.ValidationError",
        { event }
      );
    }
    next2();
  };
  api$8.logEventHandler = function logEventHandler({ event, next: next2 }) {
    console.log(`EVENT: ${event.message}`, { event });
    next2();
  };
  api$8.logWarningEventHandler = function logWarningEventHandler({ event, next: next2 }) {
    if (event.level === "warning") {
      console.warn(`WARNING: ${event.message}`, { event });
    }
    next2();
  };
  api$8.unhandledEventHandler = function unhandledEventHandler({ event }) {
    throw new JsonLdError$8(
      "No handler for event.",
      "jsonld.UnhandledEvent",
      { event }
    );
  };
  api$8.setDefaultEventHandler = function({ eventHandler } = {}) {
    api$8.defaultEventHandler = eventHandler ? _asArray$3(eventHandler) : null;
  };
  var util$5 = util$6;
  var JsonLdError$7 = JsonLdError_1;
  var {
    isArray: _isArray$3,
    isObject: _isObject$3,
    isString: _isString$3,
    isUndefined: _isUndefined$2
  } = types$8;
  var {
    isAbsolute: _isAbsoluteIri$2,
    isRelative: _isRelativeIri,
    prependBase
  } = url$1;
  var {
    handleEvent: _handleEvent$3
  } = events;
  var {
    REGEX_BCP47: REGEX_BCP47$2,
    REGEX_KEYWORD: REGEX_KEYWORD$2,
    asArray: _asArray$2,
    compareShortestLeast: _compareShortestLeast$1
  } = util$6;
  var INITIAL_CONTEXT_CACHE = /* @__PURE__ */ new Map();
  var INITIAL_CONTEXT_CACHE_MAX_SIZE = 1e4;
  var api$7 = {};
  var context = api$7;
  api$7.process = async ({
    activeCtx,
    localCtx,
    options,
    propagate = true,
    overrideProtected = false,
    cycles = /* @__PURE__ */ new Set()
  }) => {
    if (_isObject$3(localCtx) && "@context" in localCtx && _isArray$3(localCtx["@context"])) {
      localCtx = localCtx["@context"];
    }
    const ctxs = _asArray$2(localCtx);
    if (ctxs.length === 0) {
      return activeCtx;
    }
    const events2 = [];
    const eventCaptureHandler = [
      ({ event, next: next2 }) => {
        events2.push(event);
        next2();
      }
    ];
    if (options.eventHandler) {
      eventCaptureHandler.push(options.eventHandler);
    }
    const originalOptions = options;
    options = { ...options, eventHandler: eventCaptureHandler };
    const resolved = await options.contextResolver.resolve({
      activeCtx,
      context: localCtx,
      documentLoader: options.documentLoader,
      base: options.base
    });
    if (_isObject$3(resolved[0].document) && typeof resolved[0].document["@propagate"] === "boolean") {
      propagate = resolved[0].document["@propagate"];
    }
    let rval = activeCtx;
    if (!propagate && !rval.previousContext) {
      rval = rval.clone();
      rval.previousContext = activeCtx;
    }
    for (const resolvedContext of resolved) {
      let { document: ctx } = resolvedContext;
      activeCtx = rval;
      if (ctx === null) {
        if (!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {
          throw new JsonLdError$7(
            "Tried to nullify a context with protected terms outside of a term definition.",
            "jsonld.SyntaxError",
            { code: "invalid context nullification" }
          );
        }
        rval = activeCtx = api$7.getInitialContext(options).clone();
        continue;
      }
      const processed = resolvedContext.getProcessed(activeCtx);
      if (processed) {
        if (originalOptions.eventHandler) {
          for (const event of processed.events) {
            _handleEvent$3({ event, options: originalOptions });
          }
        }
        rval = activeCtx = processed.context;
        continue;
      }
      if (_isObject$3(ctx) && "@context" in ctx) {
        ctx = ctx["@context"];
      }
      if (!_isObject$3(ctx)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context must be an object.",
          "jsonld.SyntaxError",
          { code: "invalid local context", context: ctx }
        );
      }
      rval = rval.clone();
      const defined = /* @__PURE__ */ new Map();
      if ("@version" in ctx) {
        if (ctx["@version"] !== 1.1) {
          throw new JsonLdError$7(
            "Unsupported JSON-LD version: " + ctx["@version"],
            "jsonld.UnsupportedVersion",
            { code: "invalid @version value", context: ctx }
          );
        }
        if (activeCtx.processingMode && activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError$7(
            "@version: " + ctx["@version"] + " not compatible with " + activeCtx.processingMode,
            "jsonld.ProcessingModeConflict",
            { code: "processing mode conflict", context: ctx }
          );
        }
        rval.processingMode = "json-ld-1.1";
        rval["@version"] = ctx["@version"];
        defined.set("@version", true);
      }
      rval.processingMode = rval.processingMode || activeCtx.processingMode;
      if ("@base" in ctx) {
        let base3 = ctx["@base"];
        if (base3 === null || _isAbsoluteIri$2(base3))
          ;
        else if (_isRelativeIri(base3)) {
          base3 = prependBase(rval["@base"], base3);
        } else {
          throw new JsonLdError$7(
            'Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',
            "jsonld.SyntaxError",
            { code: "invalid base IRI", context: ctx }
          );
        }
        rval["@base"] = base3;
        defined.set("@base", true);
      }
      if ("@vocab" in ctx) {
        const value = ctx["@vocab"];
        if (value === null) {
          delete rval["@vocab"];
        } else if (!_isString$3(value)) {
          throw new JsonLdError$7(
            'Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',
            "jsonld.SyntaxError",
            { code: "invalid vocab mapping", context: ctx }
          );
        } else if (!_isAbsoluteIri$2(value) && api$7.processingMode(rval, 1)) {
          throw new JsonLdError$7(
            'Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',
            "jsonld.SyntaxError",
            { code: "invalid vocab mapping", context: ctx }
          );
        } else {
          const vocab = _expandIri$3(
            rval,
            value,
            { vocab: true, base: true },
            void 0,
            void 0,
            options
          );
          if (!_isAbsoluteIri$2(vocab)) {
            if (options.eventHandler) {
              _handleEvent$3({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative @vocab reference",
                  level: "warning",
                  message: "Relative @vocab reference found.",
                  details: {
                    vocab
                  }
                },
                options
              });
            }
          }
          rval["@vocab"] = vocab;
        }
        defined.set("@vocab", true);
      }
      if ("@language" in ctx) {
        const value = ctx["@language"];
        if (value === null) {
          delete rval["@language"];
        } else if (!_isString$3(value)) {
          throw new JsonLdError$7(
            'Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',
            "jsonld.SyntaxError",
            { code: "invalid default language", context: ctx }
          );
        } else {
          if (!value.match(REGEX_BCP47$2)) {
            if (options.eventHandler) {
              _handleEvent$3({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language: value
                  }
                },
                options
              });
            }
          }
          rval["@language"] = value.toLowerCase();
        }
        defined.set("@language", true);
      }
      if ("@direction" in ctx) {
        const value = ctx["@direction"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @direction not compatible with " + activeCtx.processingMode,
            "jsonld.SyntaxError",
            { code: "invalid context member", context: ctx }
          );
        }
        if (value === null) {
          delete rval["@direction"];
        } else if (value !== "ltr" && value !== "rtl") {
          throw new JsonLdError$7(
            'Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',
            "jsonld.SyntaxError",
            { code: "invalid base direction", context: ctx }
          );
        } else {
          rval["@direction"] = value;
        }
        defined.set("@direction", true);
      }
      if ("@propagate" in ctx) {
        const value = ctx["@propagate"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @propagate not compatible with " + activeCtx.processingMode,
            "jsonld.SyntaxError",
            { code: "invalid context entry", context: ctx }
          );
        }
        if (typeof value !== "boolean") {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @propagate value must be a boolean.",
            "jsonld.SyntaxError",
            { code: "invalid @propagate value", context: localCtx }
          );
        }
        defined.set("@propagate", true);
      }
      if ("@import" in ctx) {
        const value = ctx["@import"];
        if (activeCtx.processingMode === "json-ld-1.0") {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @import not compatible with " + activeCtx.processingMode,
            "jsonld.SyntaxError",
            { code: "invalid context entry", context: ctx }
          );
        }
        if (!_isString$3(value)) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @import must be a string.",
            "jsonld.SyntaxError",
            { code: "invalid @import value", context: localCtx }
          );
        }
        const resolvedImport = await options.contextResolver.resolve({
          activeCtx,
          context: value,
          documentLoader: options.documentLoader,
          base: options.base
        });
        if (resolvedImport.length !== 1) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @import must reference a single context.",
            "jsonld.SyntaxError",
            { code: "invalid remote context", context: localCtx }
          );
        }
        const processedImport = resolvedImport[0].getProcessed(activeCtx);
        if (processedImport) {
          ctx = processedImport;
        } else {
          const importCtx = resolvedImport[0].document;
          if ("@import" in importCtx) {
            throw new JsonLdError$7(
              "Invalid JSON-LD syntax: imported context must not include @import.",
              "jsonld.SyntaxError",
              { code: "invalid context entry", context: localCtx }
            );
          }
          for (const key in importCtx) {
            if (!ctx.hasOwnProperty(key)) {
              ctx[key] = importCtx[key];
            }
          }
          resolvedImport[0].setProcessed(activeCtx, ctx);
        }
        defined.set("@import", true);
      }
      defined.set("@protected", ctx["@protected"] || false);
      for (const key in ctx) {
        api$7.createTermDefinition({
          activeCtx: rval,
          localCtx: ctx,
          term: key,
          defined,
          options,
          overrideProtected
        });
        if (_isObject$3(ctx[key]) && "@context" in ctx[key]) {
          const keyCtx = ctx[key]["@context"];
          let process2 = true;
          if (_isString$3(keyCtx)) {
            const url2 = prependBase(options.base, keyCtx);
            if (cycles.has(url2)) {
              process2 = false;
            } else {
              cycles.add(url2);
            }
          }
          if (process2) {
            try {
              await api$7.process({
                activeCtx: rval.clone(),
                localCtx: ctx[key]["@context"],
                overrideProtected: true,
                options,
                cycles
              });
            } catch (e7) {
              throw new JsonLdError$7(
                "Invalid JSON-LD syntax; invalid scoped context.",
                "jsonld.SyntaxError",
                {
                  code: "invalid scoped context",
                  context: ctx[key]["@context"],
                  term: key
                }
              );
            }
          }
        }
      }
      resolvedContext.setProcessed(activeCtx, {
        context: rval,
        events: events2
      });
    }
    return rval;
  };
  api$7.createTermDefinition = ({
    activeCtx,
    localCtx,
    term,
    defined,
    options,
    overrideProtected = false
  }) => {
    if (defined.has(term)) {
      if (defined.get(term)) {
        return;
      }
      throw new JsonLdError$7(
        "Cyclical context definition detected.",
        "jsonld.CyclicalContext",
        { code: "cyclic IRI mapping", context: localCtx, term }
      );
    }
    defined.set(term, false);
    let value;
    if (localCtx.hasOwnProperty(term)) {
      value = localCtx[term];
    }
    if (term === "@type" && _isObject$3(value) && (value["@container"] || "@set") === "@set" && api$7.processingMode(activeCtx, 1.1)) {
      const validKeys2 = ["@container", "@id", "@protected"];
      const keys = Object.keys(value);
      if (keys.length === 0 || keys.some((k5) => !validKeys2.includes(k5))) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; keywords cannot be overridden.",
          "jsonld.SyntaxError",
          { code: "keyword redefinition", context: localCtx, term }
        );
      }
    } else if (api$7.isKeyword(term)) {
      throw new JsonLdError$7(
        "Invalid JSON-LD syntax; keywords cannot be overridden.",
        "jsonld.SyntaxError",
        { code: "keyword redefinition", context: localCtx, term }
      );
    } else if (term.match(REGEX_KEYWORD$2)) {
      if (options.eventHandler) {
        _handleEvent$3({
          event: {
            type: ["JsonLdEvent"],
            code: "reserved term",
            level: "warning",
            message: 'Terms beginning with "@" are reserved for future use and dropped.',
            details: {
              term
            }
          },
          options
        });
      }
      return;
    } else if (term === "") {
      throw new JsonLdError$7(
        "Invalid JSON-LD syntax; a term cannot be an empty string.",
        "jsonld.SyntaxError",
        { code: "invalid term definition", context: localCtx }
      );
    }
    const previousMapping = activeCtx.mappings.get(term);
    if (activeCtx.mappings.has(term)) {
      activeCtx.mappings.delete(term);
    }
    let simpleTerm = false;
    if (_isString$3(value) || value === null) {
      simpleTerm = true;
      value = { "@id": value };
    }
    if (!_isObject$3(value)) {
      throw new JsonLdError$7(
        "Invalid JSON-LD syntax; @context term values must be strings or objects.",
        "jsonld.SyntaxError",
        { code: "invalid term definition", context: localCtx }
      );
    }
    const mapping = {};
    activeCtx.mappings.set(term, mapping);
    mapping.reverse = false;
    const validKeys = ["@container", "@id", "@language", "@reverse", "@type"];
    if (api$7.processingMode(activeCtx, 1.1)) {
      validKeys.push(
        "@context",
        "@direction",
        "@index",
        "@nest",
        "@prefix",
        "@protected"
      );
    }
    for (const kw in value) {
      if (!validKeys.includes(kw)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a term definition must not contain " + kw,
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
    }
    const colon = term.indexOf(":");
    mapping._termHasColon = colon > 0;
    if ("@reverse" in value) {
      if ("@id" in value) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a @reverse term definition must not contain @id.",
          "jsonld.SyntaxError",
          { code: "invalid reverse property", context: localCtx }
        );
      }
      if ("@nest" in value) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.",
          "jsonld.SyntaxError",
          { code: "invalid reverse property", context: localCtx }
        );
      }
      const reverse = value["@reverse"];
      if (!_isString$3(reverse)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a @context @reverse value must be a string.",
          "jsonld.SyntaxError",
          { code: "invalid IRI mapping", context: localCtx }
        );
      }
      if (reverse.match(REGEX_KEYWORD$2)) {
        if (options.eventHandler) {
          _handleEvent$3({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @reverse value",
              level: "warning",
              message: '@reverse values beginning with "@" are reserved for future use and dropped.',
              details: {
                reverse
              }
            },
            options
          });
        }
        if (previousMapping) {
          activeCtx.mappings.set(term, previousMapping);
        } else {
          activeCtx.mappings.delete(term);
        }
        return;
      }
      const id4 = _expandIri$3(
        activeCtx,
        reverse,
        { vocab: true, base: false },
        localCtx,
        defined,
        options
      );
      if (!_isAbsoluteIri$2(id4)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.",
          "jsonld.SyntaxError",
          { code: "invalid IRI mapping", context: localCtx }
        );
      }
      mapping["@id"] = id4;
      mapping.reverse = true;
    } else if ("@id" in value) {
      let id4 = value["@id"];
      if (id4 && !_isString$3(id4)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.",
          "jsonld.SyntaxError",
          { code: "invalid IRI mapping", context: localCtx }
        );
      }
      if (id4 === null) {
        mapping["@id"] = null;
      } else if (!api$7.isKeyword(id4) && id4.match(REGEX_KEYWORD$2)) {
        if (options.eventHandler) {
          _handleEvent$3({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @id value",
              level: "warning",
              message: '@id values beginning with "@" are reserved for future use and dropped.',
              details: {
                id: id4
              }
            },
            options
          });
        }
        if (previousMapping) {
          activeCtx.mappings.set(term, previousMapping);
        } else {
          activeCtx.mappings.delete(term);
        }
        return;
      } else if (id4 !== term) {
        id4 = _expandIri$3(
          activeCtx,
          id4,
          { vocab: true, base: false },
          localCtx,
          defined,
          options
        );
        if (!_isAbsoluteIri$2(id4) && !api$7.isKeyword(id4)) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.",
            "jsonld.SyntaxError",
            { code: "invalid IRI mapping", context: localCtx }
          );
        }
        if (term.match(/(?::[^:])|\//)) {
          const termDefined = new Map(defined).set(term, true);
          const termIri = _expandIri$3(
            activeCtx,
            term,
            { vocab: true, base: false },
            localCtx,
            termDefined,
            options
          );
          if (termIri !== id4) {
            throw new JsonLdError$7(
              "Invalid JSON-LD syntax; term in form of IRI must expand to definition.",
              "jsonld.SyntaxError",
              { code: "invalid IRI mapping", context: localCtx }
            );
          }
        }
        mapping["@id"] = id4;
        mapping._prefix = simpleTerm && !mapping._termHasColon && id4.match(/[:\/\?#\[\]@]$/) !== null;
      }
    }
    if (!("@id" in mapping)) {
      if (mapping._termHasColon) {
        const prefix = term.substr(0, colon);
        if (localCtx.hasOwnProperty(prefix)) {
          api$7.createTermDefinition({
            activeCtx,
            localCtx,
            term: prefix,
            defined,
            options
          });
        }
        if (activeCtx.mappings.has(prefix)) {
          const suffix = term.substr(colon + 1);
          mapping["@id"] = activeCtx.mappings.get(prefix)["@id"] + suffix;
        } else {
          mapping["@id"] = term;
        }
      } else if (term === "@type") {
        mapping["@id"] = term;
      } else {
        if (!("@vocab" in activeCtx)) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; @context terms must define an @id.",
            "jsonld.SyntaxError",
            { code: "invalid IRI mapping", context: localCtx, term }
          );
        }
        mapping["@id"] = activeCtx["@vocab"] + term;
      }
    }
    if (value["@protected"] === true || defined.get("@protected") === true && value["@protected"] !== false) {
      activeCtx.protected[term] = true;
      mapping.protected = true;
    }
    defined.set(term, true);
    if ("@type" in value) {
      let type2 = value["@type"];
      if (!_isString$3(type2)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; an @context @type value must be a string.",
          "jsonld.SyntaxError",
          { code: "invalid type mapping", context: localCtx }
        );
      }
      if (type2 === "@json" || type2 === "@none") {
        if (api$7.processingMode(activeCtx, 1)) {
          throw new JsonLdError$7(
            `Invalid JSON-LD syntax; an @context @type value must not be "${type2}" in JSON-LD 1.0 mode.`,
            "jsonld.SyntaxError",
            { code: "invalid type mapping", context: localCtx }
          );
        }
      } else if (type2 !== "@id" && type2 !== "@vocab") {
        type2 = _expandIri$3(
          activeCtx,
          type2,
          { vocab: true, base: false },
          localCtx,
          defined,
          options
        );
        if (!_isAbsoluteIri$2(type2)) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.",
            "jsonld.SyntaxError",
            { code: "invalid type mapping", context: localCtx }
          );
        }
        if (type2.indexOf("_:") === 0) {
          throw new JsonLdError$7(
            "Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.",
            "jsonld.SyntaxError",
            { code: "invalid type mapping", context: localCtx }
          );
        }
      }
      mapping["@type"] = type2;
    }
    if ("@container" in value) {
      const container = _isString$3(value["@container"]) ? [value["@container"]] : value["@container"] || [];
      const validContainers = ["@list", "@set", "@index", "@language"];
      let isValid = true;
      const hasSet = container.includes("@set");
      if (api$7.processingMode(activeCtx, 1.1)) {
        validContainers.push("@graph", "@id", "@type");
        if (container.includes("@list")) {
          if (container.length !== 1) {
            throw new JsonLdError$7(
              "Invalid JSON-LD syntax; @context @container with @list must have no other values",
              "jsonld.SyntaxError",
              { code: "invalid container mapping", context: localCtx }
            );
          }
        } else if (container.includes("@graph")) {
          if (container.some((key) => key !== "@graph" && key !== "@id" && key !== "@index" && key !== "@set")) {
            throw new JsonLdError$7(
              "Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set",
              "jsonld.SyntaxError",
              { code: "invalid container mapping", context: localCtx }
            );
          }
        } else {
          isValid &= container.length <= (hasSet ? 2 : 1);
        }
        if (container.includes("@type")) {
          mapping["@type"] = mapping["@type"] || "@id";
          if (!["@id", "@vocab"].includes(mapping["@type"])) {
            throw new JsonLdError$7(
              "Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.",
              "jsonld.SyntaxError",
              { code: "invalid type mapping", context: localCtx }
            );
          }
        }
      } else {
        isValid &= !_isArray$3(value["@container"]);
        isValid &= container.length <= 1;
      }
      isValid &= container.every((c3) => validContainers.includes(c3));
      isValid &= !(hasSet && container.includes("@list"));
      if (!isValid) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context @container value must be one of the following: " + validContainers.join(", "),
          "jsonld.SyntaxError",
          { code: "invalid container mapping", context: localCtx }
        );
      }
      if (mapping.reverse && !container.every((c3) => ["@index", "@set"].includes(c3))) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.",
          "jsonld.SyntaxError",
          { code: "invalid reverse property", context: localCtx }
        );
      }
      mapping["@container"] = container;
    }
    if ("@index" in value) {
      if (!("@container" in value) || !mapping["@container"].includes("@index")) {
        throw new JsonLdError$7(
          `Invalid JSON-LD syntax; @index without @index in @container: "${value["@index"]}" on term "${term}".`,
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      if (!_isString$3(value["@index"]) || value["@index"].indexOf("@") === 0) {
        throw new JsonLdError$7(
          `Invalid JSON-LD syntax; @index must expand to an IRI: "${value["@index"]}" on term "${term}".`,
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      mapping["@index"] = value["@index"];
    }
    if ("@context" in value) {
      mapping["@context"] = value["@context"];
    }
    if ("@language" in value && !("@type" in value)) {
      let language = value["@language"];
      if (language !== null && !_isString$3(language)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context @language value must be a string or null.",
          "jsonld.SyntaxError",
          { code: "invalid language mapping", context: localCtx }
        );
      }
      if (language !== null) {
        language = language.toLowerCase();
      }
      mapping["@language"] = language;
    }
    if ("@prefix" in value) {
      if (term.match(/:|\//)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context @prefix used on a compact IRI term",
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      if (api$7.isKeyword(mapping["@id"])) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; keywords may not be used as prefixes",
          "jsonld.SyntaxError",
          { code: "invalid term definition", context: localCtx }
        );
      }
      if (typeof value["@prefix"] === "boolean") {
        mapping._prefix = value["@prefix"] === true;
      } else {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context value for @prefix must be boolean",
          "jsonld.SyntaxError",
          { code: "invalid @prefix value", context: localCtx }
        );
      }
    }
    if ("@direction" in value) {
      const direction = value["@direction"];
      if (direction !== null && direction !== "ltr" && direction !== "rtl") {
        throw new JsonLdError$7(
          'Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',
          "jsonld.SyntaxError",
          { code: "invalid base direction", context: localCtx }
        );
      }
      mapping["@direction"] = direction;
    }
    if ("@nest" in value) {
      const nest = value["@nest"];
      if (!_isString$3(nest) || nest !== "@nest" && nest.indexOf("@") === 0) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.",
          "jsonld.SyntaxError",
          { code: "invalid @nest value", context: localCtx }
        );
      }
      mapping["@nest"] = nest;
    }
    const id3 = mapping["@id"];
    if (id3 === "@context" || id3 === "@preserve") {
      throw new JsonLdError$7(
        "Invalid JSON-LD syntax; @context and @preserve cannot be aliased.",
        "jsonld.SyntaxError",
        { code: "invalid keyword alias", context: localCtx }
      );
    }
    if (previousMapping && previousMapping.protected && !overrideProtected) {
      activeCtx.protected[term] = true;
      mapping.protected = true;
      if (!_deepCompare(previousMapping, mapping)) {
        throw new JsonLdError$7(
          "Invalid JSON-LD syntax; tried to redefine a protected term.",
          "jsonld.SyntaxError",
          { code: "protected term redefinition", context: localCtx, term }
        );
      }
    }
  };
  api$7.expandIri = (activeCtx, value, relativeTo, options) => {
    return _expandIri$3(
      activeCtx,
      value,
      relativeTo,
      void 0,
      void 0,
      options
    );
  };
  function _expandIri$3(activeCtx, value, relativeTo, localCtx, defined, options) {
    if (value === null || !_isString$3(value) || api$7.isKeyword(value)) {
      return value;
    }
    if (value.match(REGEX_KEYWORD$2)) {
      return null;
    }
    if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
      api$7.createTermDefinition({
        activeCtx,
        localCtx,
        term: value,
        defined,
        options
      });
    }
    relativeTo = relativeTo || {};
    if (relativeTo.vocab) {
      const mapping = activeCtx.mappings.get(value);
      if (mapping === null) {
        return null;
      }
      if (_isObject$3(mapping) && "@id" in mapping) {
        return mapping["@id"];
      }
    }
    const colon = value.indexOf(":");
    if (colon > 0) {
      const prefix = value.substr(0, colon);
      const suffix = value.substr(colon + 1);
      if (prefix === "_" || suffix.indexOf("//") === 0) {
        return value;
      }
      if (localCtx && localCtx.hasOwnProperty(prefix)) {
        api$7.createTermDefinition({
          activeCtx,
          localCtx,
          term: prefix,
          defined,
          options
        });
      }
      const mapping = activeCtx.mappings.get(prefix);
      if (mapping && mapping._prefix) {
        return mapping["@id"] + suffix;
      }
      if (_isAbsoluteIri$2(value)) {
        return value;
      }
    }
    if (relativeTo.vocab && "@vocab" in activeCtx) {
      const prependedResult = activeCtx["@vocab"] + value;
      value = prependedResult;
    } else if (relativeTo.base) {
      let prependedResult;
      let base3;
      if ("@base" in activeCtx) {
        if (activeCtx["@base"]) {
          base3 = prependBase(options.base, activeCtx["@base"]);
          prependedResult = prependBase(base3, value);
        } else {
          base3 = activeCtx["@base"];
          prependedResult = value;
        }
      } else {
        base3 = options.base;
        prependedResult = prependBase(options.base, value);
      }
      value = prependedResult;
    }
    return value;
  }
  api$7.getInitialContext = (options) => {
    const key = JSON.stringify({ processingMode: options.processingMode });
    const cached = INITIAL_CONTEXT_CACHE.get(key);
    if (cached) {
      return cached;
    }
    const initialContext = {
      processingMode: options.processingMode,
      mappings: /* @__PURE__ */ new Map(),
      inverse: null,
      getInverse: _createInverseContext,
      clone: _cloneActiveContext,
      revertToPreviousContext: _revertToPreviousContext,
      protected: {}
    };
    if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
      INITIAL_CONTEXT_CACHE.clear();
    }
    INITIAL_CONTEXT_CACHE.set(key, initialContext);
    return initialContext;
    function _createInverseContext() {
      const activeCtx = this;
      if (activeCtx.inverse) {
        return activeCtx.inverse;
      }
      const inverse = activeCtx.inverse = {};
      const fastCurieMap = activeCtx.fastCurieMap = {};
      const irisToTerms = {};
      const defaultLanguage = (activeCtx["@language"] || "@none").toLowerCase();
      const defaultDirection = activeCtx["@direction"];
      const mappings = activeCtx.mappings;
      const terms = [...mappings.keys()].sort(_compareShortestLeast$1);
      for (const term of terms) {
        const mapping = mappings.get(term);
        if (mapping === null) {
          continue;
        }
        let container = mapping["@container"] || "@none";
        container = [].concat(container).sort().join("");
        if (mapping["@id"] === null) {
          continue;
        }
        const ids = _asArray$2(mapping["@id"]);
        for (const iri of ids) {
          let entry = inverse[iri];
          const isKeyword2 = api$7.isKeyword(iri);
          if (!entry) {
            inverse[iri] = entry = {};
            if (!isKeyword2 && !mapping._termHasColon) {
              irisToTerms[iri] = [term];
              const fastCurieEntry = { iri, terms: irisToTerms[iri] };
              if (iri[0] in fastCurieMap) {
                fastCurieMap[iri[0]].push(fastCurieEntry);
              } else {
                fastCurieMap[iri[0]] = [fastCurieEntry];
              }
            }
          } else if (!isKeyword2 && !mapping._termHasColon) {
            irisToTerms[iri].push(term);
          }
          if (!entry[container]) {
            entry[container] = {
              "@language": {},
              "@type": {},
              "@any": {}
            };
          }
          entry = entry[container];
          _addPreferredTerm(term, entry["@any"], "@none");
          if (mapping.reverse) {
            _addPreferredTerm(term, entry["@type"], "@reverse");
          } else if (mapping["@type"] === "@none") {
            _addPreferredTerm(term, entry["@any"], "@none");
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          } else if ("@type" in mapping) {
            _addPreferredTerm(term, entry["@type"], mapping["@type"]);
          } else if ("@language" in mapping && "@direction" in mapping) {
            const language = mapping["@language"];
            const direction = mapping["@direction"];
            if (language && direction) {
              _addPreferredTerm(
                term,
                entry["@language"],
                `${language}_${direction}`.toLowerCase()
              );
            } else if (language) {
              _addPreferredTerm(term, entry["@language"], language.toLowerCase());
            } else if (direction) {
              _addPreferredTerm(term, entry["@language"], `_${direction}`);
            } else {
              _addPreferredTerm(term, entry["@language"], "@null");
            }
          } else if ("@language" in mapping) {
            _addPreferredTerm(
              term,
              entry["@language"],
              (mapping["@language"] || "@null").toLowerCase()
            );
          } else if ("@direction" in mapping) {
            if (mapping["@direction"]) {
              _addPreferredTerm(
                term,
                entry["@language"],
                `_${mapping["@direction"]}`
              );
            } else {
              _addPreferredTerm(term, entry["@language"], "@none");
            }
          } else if (defaultDirection) {
            _addPreferredTerm(term, entry["@language"], `_${defaultDirection}`);
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          } else {
            _addPreferredTerm(term, entry["@language"], defaultLanguage);
            _addPreferredTerm(term, entry["@language"], "@none");
            _addPreferredTerm(term, entry["@type"], "@none");
          }
        }
      }
      for (const key2 in fastCurieMap) {
        _buildIriMap(fastCurieMap, key2, 1);
      }
      return inverse;
    }
    function _buildIriMap(iriMap, key2, idx) {
      const entries2 = iriMap[key2];
      const next2 = iriMap[key2] = {};
      let iri;
      let letter;
      for (const entry of entries2) {
        iri = entry.iri;
        if (idx >= iri.length) {
          letter = "";
        } else {
          letter = iri[idx];
        }
        if (letter in next2) {
          next2[letter].push(entry);
        } else {
          next2[letter] = [entry];
        }
      }
      for (const key3 in next2) {
        if (key3 === "") {
          continue;
        }
        _buildIriMap(next2, key3, idx + 1);
      }
    }
    function _addPreferredTerm(term, entry, typeOrLanguageValue) {
      if (!entry.hasOwnProperty(typeOrLanguageValue)) {
        entry[typeOrLanguageValue] = term;
      }
    }
    function _cloneActiveContext() {
      const child = {};
      child.mappings = util$5.clone(this.mappings);
      child.clone = this.clone;
      child.inverse = null;
      child.getInverse = this.getInverse;
      child.protected = util$5.clone(this.protected);
      if (this.previousContext) {
        child.previousContext = this.previousContext.clone();
      }
      child.revertToPreviousContext = this.revertToPreviousContext;
      if ("@base" in this) {
        child["@base"] = this["@base"];
      }
      if ("@language" in this) {
        child["@language"] = this["@language"];
      }
      if ("@vocab" in this) {
        child["@vocab"] = this["@vocab"];
      }
      return child;
    }
    function _revertToPreviousContext() {
      if (!this.previousContext) {
        return this;
      }
      return this.previousContext.clone();
    }
  };
  api$7.getContextValue = (ctx, key, type2) => {
    if (key === null) {
      if (type2 === "@context") {
        return void 0;
      }
      return null;
    }
    if (ctx.mappings.has(key)) {
      const entry = ctx.mappings.get(key);
      if (_isUndefined$2(type2)) {
        return entry;
      }
      if (entry.hasOwnProperty(type2)) {
        return entry[type2];
      }
    }
    if (type2 === "@language" && type2 in ctx) {
      return ctx[type2];
    }
    if (type2 === "@direction" && type2 in ctx) {
      return ctx[type2];
    }
    if (type2 === "@context") {
      return void 0;
    }
    return null;
  };
  api$7.processingMode = (activeCtx, version2) => {
    if (version2.toString() >= "1.1") {
      return !activeCtx.processingMode || activeCtx.processingMode >= "json-ld-" + version2.toString();
    } else {
      return activeCtx.processingMode === "json-ld-1.0";
    }
  };
  api$7.isKeyword = (v6) => {
    if (!_isString$3(v6) || v6[0] !== "@") {
      return false;
    }
    switch (v6) {
      case "@base":
      case "@container":
      case "@context":
      case "@default":
      case "@direction":
      case "@embed":
      case "@explicit":
      case "@graph":
      case "@id":
      case "@included":
      case "@index":
      case "@json":
      case "@language":
      case "@list":
      case "@nest":
      case "@none":
      case "@omitDefault":
      case "@prefix":
      case "@preserve":
      case "@protected":
      case "@requireAll":
      case "@reverse":
      case "@set":
      case "@type":
      case "@value":
      case "@version":
      case "@vocab":
        return true;
    }
    return false;
  };
  function _deepCompare(x1, x22) {
    if (!(x1 && typeof x1 === "object") || !(x22 && typeof x22 === "object")) {
      return x1 === x22;
    }
    const x1Array = Array.isArray(x1);
    if (x1Array !== Array.isArray(x22)) {
      return false;
    }
    if (x1Array) {
      if (x1.length !== x22.length) {
        return false;
      }
      for (let i4 = 0; i4 < x1.length; ++i4) {
        if (!_deepCompare(x1[i4], x22[i4])) {
          return false;
        }
      }
      return true;
    }
    const k1s = Object.keys(x1);
    const k2s = Object.keys(x22);
    if (k1s.length !== k2s.length) {
      return false;
    }
    for (const k1 in x1) {
      let v1 = x1[k1];
      let v22 = x22[k1];
      if (k1 === "@container") {
        if (Array.isArray(v1) && Array.isArray(v22)) {
          v1 = v1.slice().sort();
          v22 = v22.slice().sort();
        }
      }
      if (!_deepCompare(v1, v22)) {
        return false;
      }
    }
    return true;
  }
  var JsonLdError$6 = JsonLdError_1;
  var {
    isArray: _isArray$2,
    isObject: _isObject$2,
    isEmptyObject: _isEmptyObject,
    isString: _isString$2,
    isUndefined: _isUndefined$1
  } = types$8;
  var {
    isList: _isList$1,
    isValue: _isValue$1,
    isGraph: _isGraph$1,
    isSubject: _isSubject
  } = graphTypes$5;
  var {
    expandIri: _expandIri$2,
    getContextValue: _getContextValue$1,
    isKeyword: _isKeyword$1,
    process: _processContext$2,
    processingMode: _processingMode$2
  } = context;
  var {
    isAbsolute: _isAbsoluteIri$1
  } = url$1;
  var {
    REGEX_BCP47: REGEX_BCP47$1,
    REGEX_KEYWORD: REGEX_KEYWORD$1,
    addValue: _addValue$2,
    asArray: _asArray$1,
    getValues: _getValues,
    validateTypeValue: _validateTypeValue
  } = util$6;
  var {
    handleEvent: _handleEvent$2
  } = events;
  var api$6 = {};
  var expand = api$6;
  api$6.expand = async ({
    activeCtx,
    activeProperty = null,
    element,
    options = {},
    insideList = false,
    insideIndex = false,
    typeScopedContext = null
  }) => {
    if (element === null || element === void 0) {
      return null;
    }
    if (activeProperty === "@default") {
      options = Object.assign({}, options, { isFrame: false });
    }
    if (!_isArray$2(element) && !_isObject$2(element)) {
      if (!insideList && (activeProperty === null || _expandIri$2(
        activeCtx,
        activeProperty,
        { vocab: true },
        options
      ) === "@graph")) {
        if (options.eventHandler) {
          _handleEvent$2({
            event: {
              type: ["JsonLdEvent"],
              code: "free-floating scalar",
              level: "warning",
              message: "Dropping free-floating scalar not in a list.",
              details: {
                value: element
              }
            },
            options
          });
        }
        return null;
      }
      return _expandValue({ activeCtx, activeProperty, value: element, options });
    }
    if (_isArray$2(element)) {
      let rval2 = [];
      const container = _getContextValue$1(
        activeCtx,
        activeProperty,
        "@container"
      ) || [];
      insideList = insideList || container.includes("@list");
      for (let i4 = 0; i4 < element.length; ++i4) {
        let e7 = await api$6.expand({
          activeCtx,
          activeProperty,
          element: element[i4],
          options,
          insideIndex,
          typeScopedContext
        });
        if (insideList && _isArray$2(e7)) {
          e7 = { "@list": e7 };
        }
        if (e7 === null) {
          continue;
        }
        if (_isArray$2(e7)) {
          rval2 = rval2.concat(e7);
        } else {
          rval2.push(e7);
        }
      }
      return rval2;
    }
    const expandedActiveProperty = _expandIri$2(
      activeCtx,
      activeProperty,
      { vocab: true },
      options
    );
    const propertyScopedCtx = _getContextValue$1(activeCtx, activeProperty, "@context");
    typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
    let keys = Object.keys(element).sort();
    let mustRevert = !insideIndex;
    if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes("@context")) {
      for (const key of keys) {
        const expandedProperty = _expandIri$2(
          typeScopedContext,
          key,
          { vocab: true },
          options
        );
        if (expandedProperty === "@value") {
          mustRevert = false;
          activeCtx = typeScopedContext;
          break;
        }
        if (expandedProperty === "@id" && keys.length === 1) {
          mustRevert = false;
          break;
        }
      }
    }
    if (mustRevert) {
      activeCtx = activeCtx.revertToPreviousContext();
    }
    if (!_isUndefined$1(propertyScopedCtx)) {
      activeCtx = await _processContext$2({
        activeCtx,
        localCtx: propertyScopedCtx,
        propagate: true,
        overrideProtected: true,
        options
      });
    }
    if ("@context" in element) {
      activeCtx = await _processContext$2(
        { activeCtx, localCtx: element["@context"], options }
      );
    }
    typeScopedContext = activeCtx;
    let typeKey = null;
    for (const key of keys) {
      const expandedProperty = _expandIri$2(activeCtx, key, { vocab: true }, options);
      if (expandedProperty === "@type") {
        typeKey = typeKey || key;
        const value = element[key];
        const types2 = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
        for (const type2 of types2) {
          const ctx = _getContextValue$1(typeScopedContext, type2, "@context");
          if (!_isUndefined$1(ctx)) {
            activeCtx = await _processContext$2({
              activeCtx,
              localCtx: ctx,
              options,
              propagate: false
            });
          }
        }
      }
    }
    let rval = {};
    await _expandObject({
      activeCtx,
      activeProperty,
      expandedActiveProperty,
      element,
      expandedParent: rval,
      options,
      insideList,
      typeKey,
      typeScopedContext
    });
    keys = Object.keys(rval);
    let count = keys.length;
    if ("@value" in rval) {
      if ("@type" in rval && ("@language" in rval || "@direction" in rval)) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',
          "jsonld.SyntaxError",
          { code: "invalid value object", element: rval }
        );
      }
      let validCount = count - 1;
      if ("@type" in rval) {
        validCount -= 1;
      }
      if ("@index" in rval) {
        validCount -= 1;
      }
      if ("@language" in rval) {
        validCount -= 1;
      }
      if ("@direction" in rval) {
        validCount -= 1;
      }
      if (validCount !== 0) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',
          "jsonld.SyntaxError",
          { code: "invalid value object", element: rval }
        );
      }
      const values = rval["@value"] === null ? [] : _asArray$1(rval["@value"]);
      const types2 = _getValues(rval, "@type");
      if (_processingMode$2(activeCtx, 1.1) && types2.includes("@json") && types2.length === 1)
        ;
      else if (values.length === 0) {
        if (options.eventHandler) {
          _handleEvent$2({
            event: {
              type: ["JsonLdEvent"],
              code: "null @value value",
              level: "warning",
              message: "Dropping null @value value.",
              details: {
                value: rval
              }
            },
            options
          });
        }
        rval = null;
      } else if (!values.every((v6) => _isString$2(v6) || _isEmptyObject(v6)) && "@language" in rval) {
        throw new JsonLdError$6(
          "Invalid JSON-LD syntax; only strings may be language-tagged.",
          "jsonld.SyntaxError",
          { code: "invalid language-tagged value", element: rval }
        );
      } else if (!types2.every((t) => _isAbsoluteIri$1(t) && !(_isString$2(t) && t.indexOf("_:") === 0) || _isEmptyObject(t))) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',
          "jsonld.SyntaxError",
          { code: "invalid typed value", element: rval }
        );
      }
    } else if ("@type" in rval && !_isArray$2(rval["@type"])) {
      rval["@type"] = [rval["@type"]];
    } else if ("@set" in rval || "@list" in rval) {
      if (count > 1 && !(count === 2 && "@index" in rval)) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',
          "jsonld.SyntaxError",
          { code: "invalid set or list object", element: rval }
        );
      }
      if ("@set" in rval) {
        rval = rval["@set"];
        keys = Object.keys(rval);
        count = keys.length;
      }
    } else if (count === 1 && "@language" in rval) {
      if (options.eventHandler) {
        _handleEvent$2({
          event: {
            type: ["JsonLdEvent"],
            code: "object with only @language",
            level: "warning",
            message: "Dropping object with only @language.",
            details: {
              value: rval
            }
          },
          options
        });
      }
      rval = null;
    }
    if (_isObject$2(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === "@graph" || (_getContextValue$1(activeCtx, activeProperty, "@container") || []).includes("@graph"))) {
      rval = _dropUnsafeObject({ value: rval, count, options });
    }
    return rval;
  };
  function _dropUnsafeObject({
    value,
    count,
    options
  }) {
    if (count === 0 || "@value" in value || "@list" in value || count === 1 && "@id" in value) {
      if (options.eventHandler) {
        let code2;
        let message;
        if (count === 0) {
          code2 = "empty object";
          message = "Dropping empty object.";
        } else if ("@value" in value) {
          code2 = "object with only @value";
          message = "Dropping object with only @value.";
        } else if ("@list" in value) {
          code2 = "object with only @list";
          message = "Dropping object with only @list.";
        } else if (count === 1 && "@id" in value) {
          code2 = "object with only @id";
          message = "Dropping object with only @id.";
        }
        _handleEvent$2({
          event: {
            type: ["JsonLdEvent"],
            code: code2,
            level: "warning",
            message,
            details: {
              value
            }
          },
          options
        });
      }
      return null;
    }
    return value;
  }
  async function _expandObject({
    activeCtx,
    activeProperty,
    expandedActiveProperty,
    element,
    expandedParent,
    options = {},
    insideList,
    typeKey,
    typeScopedContext
  }) {
    const keys = Object.keys(element).sort();
    const nests = [];
    let unexpandedValue;
    const isJsonType = element[typeKey] && _expandIri$2(
      activeCtx,
      _isArray$2(element[typeKey]) ? element[typeKey][0] : element[typeKey],
      { vocab: true },
      {
        ...options,
        typeExpansion: true
      }
    ) === "@json";
    for (const key of keys) {
      let value = element[key];
      let expandedValue;
      if (key === "@context") {
        continue;
      }
      const expandedProperty = _expandIri$2(activeCtx, key, { vocab: true }, options);
      if (expandedProperty === null || !(_isAbsoluteIri$1(expandedProperty) || _isKeyword$1(expandedProperty))) {
        if (options.eventHandler) {
          _handleEvent$2({
            event: {
              type: ["JsonLdEvent"],
              code: "invalid property",
              level: "warning",
              message: "Dropping property that did not expand into an absolute IRI or keyword.",
              details: {
                property: key,
                expandedProperty
              }
            },
            options
          });
        }
        continue;
      }
      if (_isKeyword$1(expandedProperty)) {
        if (expandedActiveProperty === "@reverse") {
          throw new JsonLdError$6(
            "Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.",
            "jsonld.SyntaxError",
            { code: "invalid reverse property map", value }
          );
        }
        if (expandedProperty in expandedParent && expandedProperty !== "@included" && expandedProperty !== "@type") {
          throw new JsonLdError$6(
            "Invalid JSON-LD syntax; colliding keywords detected.",
            "jsonld.SyntaxError",
            { code: "colliding keywords", keyword: expandedProperty }
          );
        }
      }
      if (expandedProperty === "@id") {
        if (!_isString$2(value)) {
          if (!options.isFrame) {
            throw new JsonLdError$6(
              'Invalid JSON-LD syntax; "@id" value must a string.',
              "jsonld.SyntaxError",
              { code: "invalid @id value", value }
            );
          }
          if (_isObject$2(value)) {
            if (!_isEmptyObject(value)) {
              throw new JsonLdError$6(
                'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
                "jsonld.SyntaxError",
                { code: "invalid @id value", value }
              );
            }
          } else if (_isArray$2(value)) {
            if (!value.every((v6) => _isString$2(v6))) {
              throw new JsonLdError$6(
                'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
                "jsonld.SyntaxError",
                { code: "invalid @id value", value }
              );
            }
          } else {
            throw new JsonLdError$6(
              'Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',
              "jsonld.SyntaxError",
              { code: "invalid @id value", value }
            );
          }
        }
        _addValue$2(
          expandedParent,
          "@id",
          _asArray$1(value).map((v6) => {
            if (_isString$2(v6)) {
              const ve2 = _expandIri$2(activeCtx, v6, { base: true }, options);
              if (options.eventHandler) {
                if (ve2 === null) {
                  if (v6 === null) {
                    _handleEvent$2({
                      event: {
                        type: ["JsonLdEvent"],
                        code: "null @id value",
                        level: "warning",
                        message: "Null @id found.",
                        details: {
                          id: v6
                        }
                      },
                      options
                    });
                  } else {
                    _handleEvent$2({
                      event: {
                        type: ["JsonLdEvent"],
                        code: "reserved @id value",
                        level: "warning",
                        message: "Reserved @id found.",
                        details: {
                          id: v6
                        }
                      },
                      options
                    });
                  }
                } else if (!_isAbsoluteIri$1(ve2)) {
                  _handleEvent$2({
                    event: {
                      type: ["JsonLdEvent"],
                      code: "relative @id reference",
                      level: "warning",
                      message: "Relative @id reference found.",
                      details: {
                        id: v6,
                        expandedId: ve2
                      }
                    },
                    options
                  });
                }
              }
              return ve2;
            }
            return v6;
          }),
          { propertyIsArray: options.isFrame }
        );
        continue;
      }
      if (expandedProperty === "@type") {
        if (_isObject$2(value)) {
          value = Object.fromEntries(Object.entries(value).map(([k5, v6]) => [
            _expandIri$2(typeScopedContext, k5, { vocab: true }),
            _asArray$1(v6).map(
              (vv) => _expandIri$2(
                typeScopedContext,
                vv,
                { base: true, vocab: true },
                { ...options, typeExpansion: true }
              )
            )
          ]));
        }
        _validateTypeValue(value, options.isFrame);
        _addValue$2(
          expandedParent,
          "@type",
          _asArray$1(value).map((v6) => {
            if (_isString$2(v6)) {
              const ve2 = _expandIri$2(
                typeScopedContext,
                v6,
                { base: true, vocab: true },
                { ...options, typeExpansion: true }
              );
              if (ve2 !== "@json" && !_isAbsoluteIri$1(ve2)) {
                if (options.eventHandler) {
                  _handleEvent$2({
                    event: {
                      type: ["JsonLdEvent"],
                      code: "relative @type reference",
                      level: "warning",
                      message: "Relative @type reference found.",
                      details: {
                        type: v6
                      }
                    },
                    options
                  });
                }
              }
              return ve2;
            }
            return v6;
          }),
          { propertyIsArray: !!options.isFrame }
        );
        continue;
      }
      if (expandedProperty === "@included" && _processingMode$2(activeCtx, 1.1)) {
        const includedResult = _asArray$1(await api$6.expand({
          activeCtx,
          activeProperty,
          element: value,
          options
        }));
        if (!includedResult.every((v6) => _isSubject(v6))) {
          throw new JsonLdError$6(
            "Invalid JSON-LD syntax; values of @included must expand to node objects.",
            "jsonld.SyntaxError",
            { code: "invalid @included value", value }
          );
        }
        _addValue$2(
          expandedParent,
          "@included",
          includedResult,
          { propertyIsArray: true }
        );
        continue;
      }
      if (expandedProperty === "@graph" && !(_isObject$2(value) || _isArray$2(value))) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',
          "jsonld.SyntaxError",
          { code: "invalid @graph value", value }
        );
      }
      if (expandedProperty === "@value") {
        unexpandedValue = value;
        if (isJsonType && _processingMode$2(activeCtx, 1.1)) {
          expandedParent["@value"] = value;
        } else {
          _addValue$2(
            expandedParent,
            "@value",
            value,
            { propertyIsArray: options.isFrame }
          );
        }
        continue;
      }
      if (expandedProperty === "@language") {
        if (value === null) {
          continue;
        }
        if (!_isString$2(value) && !options.isFrame) {
          throw new JsonLdError$6(
            'Invalid JSON-LD syntax; "@language" value must be a string.',
            "jsonld.SyntaxError",
            { code: "invalid language-tagged string", value }
          );
        }
        value = _asArray$1(value).map((v6) => _isString$2(v6) ? v6.toLowerCase() : v6);
        for (const language of value) {
          if (_isString$2(language) && !language.match(REGEX_BCP47$1)) {
            if (options.eventHandler) {
              _handleEvent$2({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language
                  }
                },
                options
              });
            }
          }
        }
        _addValue$2(
          expandedParent,
          "@language",
          value,
          { propertyIsArray: options.isFrame }
        );
        continue;
      }
      if (expandedProperty === "@direction") {
        if (!_isString$2(value) && !options.isFrame) {
          throw new JsonLdError$6(
            'Invalid JSON-LD syntax; "@direction" value must be a string.',
            "jsonld.SyntaxError",
            { code: "invalid base direction", value }
          );
        }
        value = _asArray$1(value);
        for (const dir of value) {
          if (_isString$2(dir) && dir !== "ltr" && dir !== "rtl") {
            throw new JsonLdError$6(
              'Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',
              "jsonld.SyntaxError",
              { code: "invalid base direction", value }
            );
          }
        }
        _addValue$2(
          expandedParent,
          "@direction",
          value,
          { propertyIsArray: options.isFrame }
        );
        continue;
      }
      if (expandedProperty === "@index") {
        if (!_isString$2(value)) {
          throw new JsonLdError$6(
            'Invalid JSON-LD syntax; "@index" value must be a string.',
            "jsonld.SyntaxError",
            { code: "invalid @index value", value }
          );
        }
        _addValue$2(expandedParent, "@index", value);
        continue;
      }
      if (expandedProperty === "@reverse") {
        if (!_isObject$2(value)) {
          throw new JsonLdError$6(
            'Invalid JSON-LD syntax; "@reverse" value must be an object.',
            "jsonld.SyntaxError",
            { code: "invalid @reverse value", value }
          );
        }
        expandedValue = await api$6.expand({
          activeCtx,
          activeProperty: "@reverse",
          element: value,
          options
        });
        if ("@reverse" in expandedValue) {
          for (const property in expandedValue["@reverse"]) {
            _addValue$2(
              expandedParent,
              property,
              expandedValue["@reverse"][property],
              { propertyIsArray: true }
            );
          }
        }
        let reverseMap = expandedParent["@reverse"] || null;
        for (const property in expandedValue) {
          if (property === "@reverse") {
            continue;
          }
          if (reverseMap === null) {
            reverseMap = expandedParent["@reverse"] = {};
          }
          _addValue$2(reverseMap, property, [], { propertyIsArray: true });
          const items2 = expandedValue[property];
          for (let ii2 = 0; ii2 < items2.length; ++ii2) {
            const item = items2[ii2];
            if (_isValue$1(item) || _isList$1(item)) {
              throw new JsonLdError$6(
                'Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',
                "jsonld.SyntaxError",
                { code: "invalid reverse property value", value: expandedValue }
              );
            }
            _addValue$2(reverseMap, property, item, { propertyIsArray: true });
          }
        }
        continue;
      }
      if (expandedProperty === "@nest") {
        nests.push(key);
        continue;
      }
      let termCtx = activeCtx;
      const ctx = _getContextValue$1(activeCtx, key, "@context");
      if (!_isUndefined$1(ctx)) {
        termCtx = await _processContext$2({
          activeCtx,
          localCtx: ctx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      const container = _getContextValue$1(termCtx, key, "@container") || [];
      if (container.includes("@language") && _isObject$2(value)) {
        const direction = _getContextValue$1(termCtx, key, "@direction");
        expandedValue = _expandLanguageMap(termCtx, value, direction, options);
      } else if (container.includes("@index") && _isObject$2(value)) {
        const asGraph = container.includes("@graph");
        const indexKey = _getContextValue$1(termCtx, key, "@index") || "@index";
        const propertyIndex = indexKey !== "@index" && _expandIri$2(activeCtx, indexKey, { vocab: true }, options);
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx,
          options,
          activeProperty: key,
          value,
          asGraph,
          indexKey,
          propertyIndex
        });
      } else if (container.includes("@id") && _isObject$2(value)) {
        const asGraph = container.includes("@graph");
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx,
          options,
          activeProperty: key,
          value,
          asGraph,
          indexKey: "@id"
        });
      } else if (container.includes("@type") && _isObject$2(value)) {
        expandedValue = await _expandIndexMap({
          activeCtx: termCtx.revertToPreviousContext(),
          options,
          activeProperty: key,
          value,
          asGraph: false,
          indexKey: "@type"
        });
      } else {
        const isList = expandedProperty === "@list";
        if (isList || expandedProperty === "@set") {
          let nextActiveProperty = activeProperty;
          if (isList && expandedActiveProperty === "@graph") {
            nextActiveProperty = null;
          }
          expandedValue = await api$6.expand({
            activeCtx: termCtx,
            activeProperty: nextActiveProperty,
            element: value,
            options,
            insideList: isList
          });
        } else if (_getContextValue$1(activeCtx, key, "@type") === "@json") {
          expandedValue = {
            "@type": "@json",
            "@value": value
          };
        } else {
          expandedValue = await api$6.expand({
            activeCtx: termCtx,
            activeProperty: key,
            element: value,
            options,
            insideList: false
          });
        }
      }
      if (expandedValue === null && expandedProperty !== "@value") {
        continue;
      }
      if (expandedProperty !== "@list" && !_isList$1(expandedValue) && container.includes("@list")) {
        expandedValue = { "@list": _asArray$1(expandedValue) };
      }
      if (container.includes("@graph") && !container.some((key2) => key2 === "@id" || key2 === "@index")) {
        expandedValue = _asArray$1(expandedValue);
        if (!options.isFrame) {
          expandedValue = expandedValue.filter((v6) => {
            const count = Object.keys(v6).length;
            return _dropUnsafeObject({ value: v6, count, options }) !== null;
          });
        }
        if (expandedValue.length === 0) {
          continue;
        }
        expandedValue = expandedValue.map((v6) => ({ "@graph": _asArray$1(v6) }));
      }
      if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {
        const reverseMap = expandedParent["@reverse"] = expandedParent["@reverse"] || {};
        expandedValue = _asArray$1(expandedValue);
        for (let ii2 = 0; ii2 < expandedValue.length; ++ii2) {
          const item = expandedValue[ii2];
          if (_isValue$1(item) || _isList$1(item)) {
            throw new JsonLdError$6(
              'Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',
              "jsonld.SyntaxError",
              { code: "invalid reverse property value", value: expandedValue }
            );
          }
          _addValue$2(reverseMap, expandedProperty, item, { propertyIsArray: true });
        }
        continue;
      }
      _addValue$2(expandedParent, expandedProperty, expandedValue, {
        propertyIsArray: true
      });
    }
    if ("@value" in expandedParent) {
      if (expandedParent["@type"] === "@json" && _processingMode$2(activeCtx, 1.1))
        ;
      else if ((_isObject$2(unexpandedValue) || _isArray$2(unexpandedValue)) && !options.isFrame) {
        throw new JsonLdError$6(
          'Invalid JSON-LD syntax; "@value" value must not be an object or an array.',
          "jsonld.SyntaxError",
          { code: "invalid value object value", value: unexpandedValue }
        );
      }
    }
    for (const key of nests) {
      const nestedValues = _isArray$2(element[key]) ? element[key] : [element[key]];
      for (const nv of nestedValues) {
        if (!_isObject$2(nv) || Object.keys(nv).some((k5) => _expandIri$2(activeCtx, k5, { vocab: true }, options) === "@value")) {
          throw new JsonLdError$6(
            "Invalid JSON-LD syntax; nested value must be a node object.",
            "jsonld.SyntaxError",
            { code: "invalid @nest value", value: nv }
          );
        }
        await _expandObject({
          activeCtx,
          activeProperty,
          expandedActiveProperty,
          element: nv,
          expandedParent,
          options,
          insideList,
          typeScopedContext,
          typeKey
        });
      }
    }
  }
  function _expandValue({ activeCtx, activeProperty, value, options }) {
    if (value === null || value === void 0) {
      return null;
    }
    const expandedProperty = _expandIri$2(
      activeCtx,
      activeProperty,
      { vocab: true },
      options
    );
    if (expandedProperty === "@id") {
      return _expandIri$2(activeCtx, value, { base: true }, options);
    } else if (expandedProperty === "@type") {
      return _expandIri$2(
        activeCtx,
        value,
        { vocab: true, base: true },
        { ...options, typeExpansion: true }
      );
    }
    const type2 = _getContextValue$1(activeCtx, activeProperty, "@type");
    if ((type2 === "@id" || expandedProperty === "@graph") && _isString$2(value)) {
      const expandedValue = _expandIri$2(activeCtx, value, { base: true }, options);
      if (expandedValue === null && value.match(REGEX_KEYWORD$1)) {
        if (options.eventHandler) {
          _handleEvent$2({
            event: {
              type: ["JsonLdEvent"],
              code: "reserved @id value",
              level: "warning",
              message: "Reserved @id found.",
              details: {
                id: activeProperty
              }
            },
            options
          });
        }
      }
      return { "@id": expandedValue };
    }
    if (type2 === "@vocab" && _isString$2(value)) {
      return {
        "@id": _expandIri$2(activeCtx, value, { vocab: true, base: true }, options)
      };
    }
    if (_isKeyword$1(expandedProperty)) {
      return value;
    }
    const rval = {};
    if (type2 && !["@id", "@vocab", "@none"].includes(type2)) {
      rval["@type"] = type2;
    } else if (_isString$2(value)) {
      const language = _getContextValue$1(activeCtx, activeProperty, "@language");
      if (language !== null) {
        rval["@language"] = language;
      }
      const direction = _getContextValue$1(activeCtx, activeProperty, "@direction");
      if (direction !== null) {
        rval["@direction"] = direction;
      }
    }
    if (!["boolean", "number", "string"].includes(typeof value)) {
      value = value.toString();
    }
    rval["@value"] = value;
    return rval;
  }
  function _expandLanguageMap(activeCtx, languageMap, direction, options) {
    const rval = [];
    const keys = Object.keys(languageMap).sort();
    for (const key of keys) {
      const expandedKey = _expandIri$2(activeCtx, key, { vocab: true }, options);
      let val = languageMap[key];
      if (!_isArray$2(val)) {
        val = [val];
      }
      for (const item of val) {
        if (item === null) {
          continue;
        }
        if (!_isString$2(item)) {
          throw new JsonLdError$6(
            "Invalid JSON-LD syntax; language map values must be strings.",
            "jsonld.SyntaxError",
            { code: "invalid language map value", languageMap }
          );
        }
        const val2 = { "@value": item };
        if (expandedKey !== "@none") {
          if (!key.match(REGEX_BCP47$1)) {
            if (options.eventHandler) {
              _handleEvent$2({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language: key
                  }
                },
                options
              });
            }
          }
          val2["@language"] = key.toLowerCase();
        }
        if (direction) {
          val2["@direction"] = direction;
        }
        rval.push(val2);
      }
    }
    return rval;
  }
  async function _expandIndexMap({
    activeCtx,
    options,
    activeProperty,
    value,
    asGraph,
    indexKey,
    propertyIndex
  }) {
    const rval = [];
    const keys = Object.keys(value).sort();
    const isTypeIndex = indexKey === "@type";
    for (let key of keys) {
      if (isTypeIndex) {
        const ctx = _getContextValue$1(activeCtx, key, "@context");
        if (!_isUndefined$1(ctx)) {
          activeCtx = await _processContext$2({
            activeCtx,
            localCtx: ctx,
            propagate: false,
            options
          });
        }
      }
      let val = value[key];
      if (!_isArray$2(val)) {
        val = [val];
      }
      val = await api$6.expand({
        activeCtx,
        activeProperty,
        element: val,
        options,
        insideList: false,
        insideIndex: true
      });
      let expandedKey;
      if (propertyIndex) {
        if (key === "@none") {
          expandedKey = "@none";
        } else {
          expandedKey = _expandValue(
            { activeCtx, activeProperty: indexKey, value: key, options }
          );
        }
      } else {
        expandedKey = _expandIri$2(activeCtx, key, { vocab: true }, options);
      }
      if (indexKey === "@id") {
        key = _expandIri$2(activeCtx, key, { base: true }, options);
      } else if (isTypeIndex) {
        key = expandedKey;
      }
      for (let item of val) {
        if (asGraph && !_isGraph$1(item)) {
          item = { "@graph": [item] };
        }
        if (indexKey === "@type") {
          if (expandedKey === "@none")
            ;
          else if (item["@type"]) {
            item["@type"] = [key].concat(item["@type"]);
          } else {
            item["@type"] = [key];
          }
        } else if (_isValue$1(item) && !["@language", "@type", "@index"].includes(indexKey)) {
          throw new JsonLdError$6(
            `Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${indexKey}".`,
            "jsonld.SyntaxError",
            { code: "invalid value object", value: item }
          );
        } else if (propertyIndex) {
          if (expandedKey !== "@none") {
            _addValue$2(item, propertyIndex, expandedKey, {
              propertyIsArray: true,
              prependValue: true
            });
          }
        } else if (expandedKey !== "@none" && !(indexKey in item)) {
          item[indexKey] = key;
        }
        rval.push(item);
      }
    }
    return rval;
  }
  var { isKeyword: isKeyword$2 } = context;
  var graphTypes$3 = graphTypes$5;
  var types$4 = types$8;
  var util$4 = util$6;
  var JsonLdError$5 = JsonLdError_1;
  var api$5 = {};
  var nodeMap = api$5;
  api$5.createMergedNodeMap = (input, options) => {
    options = options || {};
    const issuer = options.issuer || new util$4.IdentifierIssuer("_:b");
    const graphs = { "@default": {} };
    api$5.createNodeMap(input, graphs, "@default", issuer);
    return api$5.mergeNodeMaps(graphs);
  };
  api$5.createNodeMap = (input, graphs, graph, issuer, name, list) => {
    if (types$4.isArray(input)) {
      for (const node of input) {
        api$5.createNodeMap(node, graphs, graph, issuer, void 0, list);
      }
      return;
    }
    if (!types$4.isObject(input)) {
      if (list) {
        list.push(input);
      }
      return;
    }
    if (graphTypes$3.isValue(input)) {
      if ("@type" in input) {
        let type2 = input["@type"];
        if (type2.indexOf("_:") === 0) {
          input["@type"] = type2 = issuer.getId(type2);
        }
      }
      if (list) {
        list.push(input);
      }
      return;
    } else if (list && graphTypes$3.isList(input)) {
      const _list = [];
      api$5.createNodeMap(input["@list"], graphs, graph, issuer, name, _list);
      list.push({ "@list": _list });
      return;
    }
    if ("@type" in input) {
      const types2 = input["@type"];
      for (const type2 of types2) {
        if (type2.indexOf("_:") === 0) {
          issuer.getId(type2);
        }
      }
    }
    if (types$4.isUndefined(name)) {
      name = graphTypes$3.isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"];
    }
    if (list) {
      list.push({ "@id": name });
    }
    const subjects = graphs[graph];
    const subject = subjects[name] = subjects[name] || {};
    subject["@id"] = name;
    const properties2 = Object.keys(input).sort();
    for (let property of properties2) {
      if (property === "@id") {
        continue;
      }
      if (property === "@reverse") {
        const referencedNode = { "@id": name };
        const reverseMap = input["@reverse"];
        for (const reverseProperty in reverseMap) {
          const items2 = reverseMap[reverseProperty];
          for (const item of items2) {
            let itemName = item["@id"];
            if (graphTypes$3.isBlankNode(item)) {
              itemName = issuer.getId(itemName);
            }
            api$5.createNodeMap(item, graphs, graph, issuer, itemName);
            util$4.addValue(
              subjects[itemName],
              reverseProperty,
              referencedNode,
              { propertyIsArray: true, allowDuplicate: false }
            );
          }
        }
        continue;
      }
      if (property === "@graph") {
        if (!(name in graphs)) {
          graphs[name] = {};
        }
        api$5.createNodeMap(input[property], graphs, name, issuer);
        continue;
      }
      if (property === "@included") {
        api$5.createNodeMap(input[property], graphs, graph, issuer);
        continue;
      }
      if (property !== "@type" && isKeyword$2(property)) {
        if (property === "@index" && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
          throw new JsonLdError$5(
            "Invalid JSON-LD syntax; conflicting @index property detected.",
            "jsonld.SyntaxError",
            { code: "conflicting indexes", subject }
          );
        }
        subject[property] = input[property];
        continue;
      }
      const objects = input[property];
      if (property.indexOf("_:") === 0) {
        property = issuer.getId(property);
      }
      if (objects.length === 0) {
        util$4.addValue(subject, property, [], { propertyIsArray: true });
        continue;
      }
      for (let o4 of objects) {
        if (property === "@type") {
          o4 = o4.indexOf("_:") === 0 ? issuer.getId(o4) : o4;
        }
        if (graphTypes$3.isSubject(o4) || graphTypes$3.isSubjectReference(o4)) {
          if ("@id" in o4 && !o4["@id"]) {
            continue;
          }
          const id3 = graphTypes$3.isBlankNode(o4) ? issuer.getId(o4["@id"]) : o4["@id"];
          util$4.addValue(
            subject,
            property,
            { "@id": id3 },
            { propertyIsArray: true, allowDuplicate: false }
          );
          api$5.createNodeMap(o4, graphs, graph, issuer, id3);
        } else if (graphTypes$3.isValue(o4)) {
          util$4.addValue(
            subject,
            property,
            o4,
            { propertyIsArray: true, allowDuplicate: false }
          );
        } else if (graphTypes$3.isList(o4)) {
          const _list = [];
          api$5.createNodeMap(o4["@list"], graphs, graph, issuer, name, _list);
          o4 = { "@list": _list };
          util$4.addValue(
            subject,
            property,
            o4,
            { propertyIsArray: true, allowDuplicate: false }
          );
        } else {
          api$5.createNodeMap(o4, graphs, graph, issuer, name);
          util$4.addValue(
            subject,
            property,
            o4,
            { propertyIsArray: true, allowDuplicate: false }
          );
        }
      }
    }
  };
  api$5.mergeNodeMapGraphs = (graphs) => {
    const merged = {};
    for (const name of Object.keys(graphs).sort()) {
      for (const id3 of Object.keys(graphs[name]).sort()) {
        const node = graphs[name][id3];
        if (!(id3 in merged)) {
          merged[id3] = { "@id": id3 };
        }
        const mergedNode = merged[id3];
        for (const property of Object.keys(node).sort()) {
          if (isKeyword$2(property) && property !== "@type") {
            mergedNode[property] = util$4.clone(node[property]);
          } else {
            for (const value of node[property]) {
              util$4.addValue(
                mergedNode,
                property,
                util$4.clone(value),
                { propertyIsArray: true, allowDuplicate: false }
              );
            }
          }
        }
      }
    }
    return merged;
  };
  api$5.mergeNodeMaps = (graphs) => {
    const defaultGraph = graphs["@default"];
    const graphNames = Object.keys(graphs).sort();
    for (const graphName of graphNames) {
      if (graphName === "@default") {
        continue;
      }
      const nodeMap2 = graphs[graphName];
      let subject = defaultGraph[graphName];
      if (!subject) {
        defaultGraph[graphName] = subject = {
          "@id": graphName,
          "@graph": []
        };
      } else if (!("@graph" in subject)) {
        subject["@graph"] = [];
      }
      const graph = subject["@graph"];
      for (const id3 of Object.keys(nodeMap2).sort()) {
        const node = nodeMap2[id3];
        if (!graphTypes$3.isSubjectReference(node)) {
          graph.push(node);
        }
      }
    }
    return defaultGraph;
  };
  var {
    isSubjectReference: _isSubjectReference$2
  } = graphTypes$5;
  var {
    createMergedNodeMap: _createMergedNodeMap$1
  } = nodeMap;
  var api$4 = {};
  var flatten$1 = api$4;
  api$4.flatten = (input) => {
    const defaultGraph = _createMergedNodeMap$1(input);
    const flattened = [];
    const keys = Object.keys(defaultGraph).sort();
    for (let ki2 = 0; ki2 < keys.length; ++ki2) {
      const node = defaultGraph[keys[ki2]];
      if (!_isSubjectReference$2(node)) {
        flattened.push(node);
      }
    }
    return flattened;
  };
  var JsonLdError$4 = JsonLdError_1;
  var graphTypes$2 = graphTypes$5;
  var types$3 = types$8;
  var {
    REGEX_BCP47,
    addValue: _addValue$1
  } = util$6;
  var {
    handleEvent: _handleEvent$1
  } = events;
  var {
    RDF_LIST,
    RDF_FIRST: RDF_FIRST$1,
    RDF_REST: RDF_REST$1,
    RDF_NIL: RDF_NIL$1,
    RDF_TYPE: RDF_TYPE$1,
    RDF_JSON_LITERAL: RDF_JSON_LITERAL$1,
    XSD_BOOLEAN: XSD_BOOLEAN$1,
    XSD_DOUBLE: XSD_DOUBLE$1,
    XSD_INTEGER: XSD_INTEGER$1,
    XSD_STRING: XSD_STRING$1
  } = constants$1;
  var api$3 = {};
  var fromRdf = api$3;
  api$3.fromRDF = async (dataset, options) => {
    const {
      useRdfType = false,
      useNativeTypes = false,
      rdfDirection = null
    } = options;
    const defaultGraph = {};
    const graphMap = { "@default": defaultGraph };
    const referencedOnce = {};
    if (rdfDirection) {
      if (rdfDirection === "compound-literal") {
        throw new JsonLdError$4(
          "Unsupported rdfDirection value.",
          "jsonld.InvalidRdfDirection",
          { value: rdfDirection }
        );
      } else if (rdfDirection !== "i18n-datatype") {
        throw new JsonLdError$4(
          "Unknown rdfDirection value.",
          "jsonld.InvalidRdfDirection",
          { value: rdfDirection }
        );
      }
    }
    for (const quad of dataset) {
      const name = quad.graph.termType === "DefaultGraph" ? "@default" : quad.graph.value;
      if (!(name in graphMap)) {
        graphMap[name] = {};
      }
      if (name !== "@default" && !(name in defaultGraph)) {
        defaultGraph[name] = { "@id": name };
      }
      const nodeMap2 = graphMap[name];
      const s3 = quad.subject.value;
      const p6 = quad.predicate.value;
      const o4 = quad.object;
      if (!(s3 in nodeMap2)) {
        nodeMap2[s3] = { "@id": s3 };
      }
      const node = nodeMap2[s3];
      const objectIsNode = o4.termType.endsWith("Node");
      if (objectIsNode && !(o4.value in nodeMap2)) {
        nodeMap2[o4.value] = { "@id": o4.value };
      }
      if (p6 === RDF_TYPE$1 && !useRdfType && objectIsNode) {
        _addValue$1(node, "@type", o4.value, { propertyIsArray: true });
        continue;
      }
      const value = _RDFToObject(o4, useNativeTypes, rdfDirection, options);
      _addValue$1(node, p6, value, { propertyIsArray: true });
      if (objectIsNode) {
        if (o4.value === RDF_NIL$1) {
          const object2 = nodeMap2[o4.value];
          if (!("usages" in object2)) {
            object2.usages = [];
          }
          object2.usages.push({
            node,
            property: p6,
            value
          });
        } else if (o4.value in referencedOnce) {
          referencedOnce[o4.value] = false;
        } else {
          referencedOnce[o4.value] = {
            node,
            property: p6,
            value
          };
        }
      }
    }
    for (const name in graphMap) {
      const graphObject = graphMap[name];
      if (!(RDF_NIL$1 in graphObject)) {
        continue;
      }
      const nil = graphObject[RDF_NIL$1];
      if (!nil.usages) {
        continue;
      }
      for (let usage of nil.usages) {
        let node = usage.node;
        let property = usage.property;
        let head2 = usage.value;
        const list = [];
        const listNodes = [];
        let nodeKeyCount = Object.keys(node).length;
        while (property === RDF_REST$1 && types$3.isObject(referencedOnce[node["@id"]]) && types$3.isArray(node[RDF_FIRST$1]) && node[RDF_FIRST$1].length === 1 && types$3.isArray(node[RDF_REST$1]) && node[RDF_REST$1].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types$3.isArray(node["@type"]) && node["@type"].length === 1 && node["@type"][0] === RDF_LIST)) {
          list.push(node[RDF_FIRST$1][0]);
          listNodes.push(node["@id"]);
          usage = referencedOnce[node["@id"]];
          node = usage.node;
          property = usage.property;
          head2 = usage.value;
          nodeKeyCount = Object.keys(node).length;
          if (!graphTypes$2.isBlankNode(node)) {
            break;
          }
        }
        delete head2["@id"];
        head2["@list"] = list.reverse();
        for (const listNode of listNodes) {
          delete graphObject[listNode];
        }
      }
      delete nil.usages;
    }
    const result = [];
    const subjects = Object.keys(defaultGraph).sort();
    for (const subject of subjects) {
      const node = defaultGraph[subject];
      if (subject in graphMap) {
        const graph = node["@graph"] = [];
        const graphObject = graphMap[subject];
        const graphSubjects = Object.keys(graphObject).sort();
        for (const graphSubject of graphSubjects) {
          const node2 = graphObject[graphSubject];
          if (!graphTypes$2.isSubjectReference(node2)) {
            graph.push(node2);
          }
        }
      }
      if (!graphTypes$2.isSubjectReference(node)) {
        result.push(node);
      }
    }
    return result;
  };
  function _RDFToObject(o4, useNativeTypes, rdfDirection, options) {
    if (o4.termType.endsWith("Node")) {
      return { "@id": o4.value };
    }
    const rval = { "@value": o4.value };
    if (o4.language) {
      if (!o4.language.match(REGEX_BCP47)) {
        if (options.eventHandler) {
          _handleEvent$1({
            event: {
              type: ["JsonLdEvent"],
              code: "invalid @language value",
              level: "warning",
              message: "@language value must be valid BCP47.",
              details: {
                language: o4.language
              }
            },
            options
          });
        }
      }
      rval["@language"] = o4.language;
    } else {
      let type2 = o4.datatype.value;
      if (!type2) {
        type2 = XSD_STRING$1;
      }
      if (type2 === RDF_JSON_LITERAL$1) {
        type2 = "@json";
        try {
          rval["@value"] = JSON.parse(rval["@value"]);
        } catch (e7) {
          throw new JsonLdError$4(
            "JSON literal could not be parsed.",
            "jsonld.InvalidJsonLiteral",
            { code: "invalid JSON literal", value: rval["@value"], cause: e7 }
          );
        }
      }
      if (useNativeTypes) {
        if (type2 === XSD_BOOLEAN$1) {
          if (rval["@value"] === "true") {
            rval["@value"] = true;
          } else if (rval["@value"] === "false") {
            rval["@value"] = false;
          }
        } else if (types$3.isNumeric(rval["@value"])) {
          if (type2 === XSD_INTEGER$1) {
            const i4 = parseInt(rval["@value"], 10);
            if (i4.toFixed(0) === rval["@value"]) {
              rval["@value"] = i4;
            }
          } else if (type2 === XSD_DOUBLE$1) {
            rval["@value"] = parseFloat(rval["@value"]);
          }
        }
        if (![XSD_BOOLEAN$1, XSD_INTEGER$1, XSD_DOUBLE$1, XSD_STRING$1].includes(type2)) {
          rval["@type"] = type2;
        }
      } else if (rdfDirection === "i18n-datatype" && type2.startsWith("https://www.w3.org/ns/i18n#")) {
        const [, language, direction] = type2.split(/[#_]/);
        if (language.length > 0) {
          rval["@language"] = language;
          if (!language.match(REGEX_BCP47)) {
            if (options.eventHandler) {
              _handleEvent$1({
                event: {
                  type: ["JsonLdEvent"],
                  code: "invalid @language value",
                  level: "warning",
                  message: "@language value must be valid BCP47.",
                  details: {
                    language
                  }
                },
                options
              });
            }
          }
        }
        rval["@direction"] = direction;
      } else if (type2 !== XSD_STRING$1) {
        rval["@type"] = type2;
      }
    }
    return rval;
  }
  var canonicalize = function serialize(object2) {
    if (object2 === null || typeof object2 !== "object" || object2.toJSON != null) {
      return JSON.stringify(object2);
    }
    if (Array.isArray(object2)) {
      return "[" + object2.reduce((t, cv, ci2) => {
        const comma = ci2 === 0 ? "" : ",";
        const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
        return t + comma + serialize(value);
      }, "") + "]";
    }
    return "{" + Object.keys(object2).sort().reduce((t, cv, ci2) => {
      if (object2[cv] === void 0 || typeof object2[cv] === "symbol") {
        return t;
      }
      const comma = t.length === 0 ? "" : ",";
      return t + comma + serialize(cv) + ":" + serialize(object2[cv]);
    }, "") + "}";
  };
  var { createNodeMap } = nodeMap;
  var { isKeyword: isKeyword$1 } = context;
  var graphTypes$1 = graphTypes$5;
  var jsonCanonicalize = canonicalize;
  var JsonLdError$3 = JsonLdError_1;
  var types$2 = types$8;
  var util$3 = util$6;
  var {
    handleEvent: _handleEvent
  } = events;
  var {
    RDF_FIRST,
    RDF_REST,
    RDF_NIL,
    RDF_TYPE,
    RDF_JSON_LITERAL,
    RDF_LANGSTRING,
    XSD_BOOLEAN,
    XSD_DOUBLE,
    XSD_INTEGER,
    XSD_STRING
  } = constants$1;
  var {
    isAbsolute: _isAbsoluteIri
  } = url$1;
  var api$2 = {};
  var toRdf = api$2;
  api$2.toRDF = (input, options) => {
    const issuer = new util$3.IdentifierIssuer("_:b");
    const nodeMap2 = { "@default": {} };
    createNodeMap(input, nodeMap2, "@default", issuer);
    const dataset = [];
    const graphNames = Object.keys(nodeMap2).sort();
    for (const graphName of graphNames) {
      let graphTerm;
      if (graphName === "@default") {
        graphTerm = { termType: "DefaultGraph", value: "" };
      } else if (_isAbsoluteIri(graphName)) {
        if (graphName.startsWith("_:")) {
          graphTerm = { termType: "BlankNode" };
        } else {
          graphTerm = { termType: "NamedNode" };
        }
        graphTerm.value = graphName;
      } else {
        if (options.eventHandler) {
          _handleEvent({
            event: {
              type: ["JsonLdEvent"],
              code: "relative graph reference",
              level: "warning",
              message: "Relative graph reference found.",
              details: {
                graph: graphName
              }
            },
            options
          });
        }
        continue;
      }
      _graphToRDF(dataset, nodeMap2[graphName], graphTerm, issuer, options);
    }
    return dataset;
  };
  function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
    const ids = Object.keys(graph).sort();
    for (const id3 of ids) {
      const node = graph[id3];
      const properties2 = Object.keys(node).sort();
      for (let property of properties2) {
        const items2 = node[property];
        if (property === "@type") {
          property = RDF_TYPE;
        } else if (isKeyword$1(property)) {
          continue;
        }
        for (const item of items2) {
          const subject = {
            termType: id3.startsWith("_:") ? "BlankNode" : "NamedNode",
            value: id3
          };
          if (!_isAbsoluteIri(id3)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative subject reference",
                  level: "warning",
                  message: "Relative subject reference found.",
                  details: {
                    subject: id3
                  }
                },
                options
              });
            }
            continue;
          }
          const predicate = {
            termType: property.startsWith("_:") ? "BlankNode" : "NamedNode",
            value: property
          };
          if (!_isAbsoluteIri(property)) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "relative predicate reference",
                  level: "warning",
                  message: "Relative predicate reference found.",
                  details: {
                    predicate: property
                  }
                },
                options
              });
            }
            continue;
          }
          if (predicate.termType === "BlankNode" && !options.produceGeneralizedRdf) {
            if (options.eventHandler) {
              _handleEvent({
                event: {
                  type: ["JsonLdEvent"],
                  code: "blank node predicate",
                  level: "warning",
                  message: "Dropping blank node predicate.",
                  details: {
                    property: issuer.getOldIds().find((key) => issuer.getId(key) === property)
                  }
                },
                options
              });
            }
            continue;
          }
          const object2 = _objectToRDF(
            item,
            issuer,
            dataset,
            graphTerm,
            options.rdfDirection,
            options
          );
          if (object2) {
            dataset.push({
              subject,
              predicate,
              object: object2,
              graph: graphTerm
            });
          }
        }
      }
    }
  }
  function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection, options) {
    const first = { termType: "NamedNode", value: RDF_FIRST };
    const rest = { termType: "NamedNode", value: RDF_REST };
    const nil = { termType: "NamedNode", value: RDF_NIL };
    const last = list.pop();
    const result = last ? { termType: "BlankNode", value: issuer.getId() } : nil;
    let subject = result;
    for (const item of list) {
      const object2 = _objectToRDF(
        item,
        issuer,
        dataset,
        graphTerm,
        rdfDirection,
        options
      );
      const next2 = { termType: "BlankNode", value: issuer.getId() };
      dataset.push({
        subject,
        predicate: first,
        object: object2,
        graph: graphTerm
      });
      dataset.push({
        subject,
        predicate: rest,
        object: next2,
        graph: graphTerm
      });
      subject = next2;
    }
    if (last) {
      const object2 = _objectToRDF(
        last,
        issuer,
        dataset,
        graphTerm,
        rdfDirection,
        options
      );
      dataset.push({
        subject,
        predicate: first,
        object: object2,
        graph: graphTerm
      });
      dataset.push({
        subject,
        predicate: rest,
        object: nil,
        graph: graphTerm
      });
    }
    return result;
  }
  function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection, options) {
    const object2 = {};
    if (graphTypes$1.isValue(item)) {
      object2.termType = "Literal";
      object2.value = void 0;
      object2.datatype = {
        termType: "NamedNode"
      };
      let value = item["@value"];
      const datatype = item["@type"] || null;
      if (datatype === "@json") {
        object2.value = jsonCanonicalize(value);
        object2.datatype.value = RDF_JSON_LITERAL;
      } else if (types$2.isBoolean(value)) {
        object2.value = value.toString();
        object2.datatype.value = datatype || XSD_BOOLEAN;
      } else if (types$2.isDouble(value) || datatype === XSD_DOUBLE) {
        if (!types$2.isDouble(value)) {
          value = parseFloat(value);
        }
        object2.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
        object2.datatype.value = datatype || XSD_DOUBLE;
      } else if (types$2.isNumber(value)) {
        object2.value = value.toFixed(0);
        object2.datatype.value = datatype || XSD_INTEGER;
      } else if ("@direction" in item && rdfDirection === "i18n-datatype") {
        const language = (item["@language"] || "").toLowerCase();
        const direction = item["@direction"];
        const datatype2 = `https://www.w3.org/ns/i18n#${language}_${direction}`;
        object2.datatype.value = datatype2;
        object2.value = value;
      } else if ("@direction" in item && rdfDirection === "compound-literal") {
        throw new JsonLdError$3(
          "Unsupported rdfDirection value.",
          "jsonld.InvalidRdfDirection",
          { value: rdfDirection }
        );
      } else if ("@direction" in item && rdfDirection) {
        throw new JsonLdError$3(
          "Unknown rdfDirection value.",
          "jsonld.InvalidRdfDirection",
          { value: rdfDirection }
        );
      } else if ("@language" in item) {
        if ("@direction" in item && !rdfDirection) {
          if (options.eventHandler) {
            _handleEvent({
              event: {
                type: ["JsonLdEvent"],
                code: "rdfDirection not set",
                level: "warning",
                message: "rdfDirection not set for @direction.",
                details: {
                  object: object2.value
                }
              },
              options
            });
          }
        }
        object2.value = value;
        object2.datatype.value = datatype || RDF_LANGSTRING;
        object2.language = item["@language"];
      } else {
        if ("@direction" in item && !rdfDirection) {
          if (options.eventHandler) {
            _handleEvent({
              event: {
                type: ["JsonLdEvent"],
                code: "rdfDirection not set",
                level: "warning",
                message: "rdfDirection not set for @direction.",
                details: {
                  object: object2.value
                }
              },
              options
            });
          }
        }
        object2.value = value;
        object2.datatype.value = datatype || XSD_STRING;
      }
    } else if (graphTypes$1.isList(item)) {
      const _list = _listToRDF(
        item["@list"],
        issuer,
        dataset,
        graphTerm,
        rdfDirection,
        options
      );
      object2.termType = _list.termType;
      object2.value = _list.value;
    } else {
      const id3 = types$2.isObject(item) ? item["@id"] : item;
      object2.termType = id3.startsWith("_:") ? "BlankNode" : "NamedNode";
      object2.value = id3;
    }
    if (object2.termType === "NamedNode" && !_isAbsoluteIri(object2.value)) {
      if (options.eventHandler) {
        _handleEvent({
          event: {
            type: ["JsonLdEvent"],
            code: "relative object reference",
            level: "warning",
            message: "Relative object reference found.",
            details: {
              object: object2.value
            }
          },
          options
        });
      }
      return null;
    }
    return object2;
  }
  var { isKeyword } = context;
  var graphTypes = graphTypes$5;
  var types$1 = types$8;
  var util$2 = util$6;
  var url = url$1;
  var JsonLdError$2 = JsonLdError_1;
  var {
    createNodeMap: _createNodeMap$1,
    mergeNodeMapGraphs: _mergeNodeMapGraphs
  } = nodeMap;
  var api$1 = {};
  var frame = api$1;
  api$1.frameMergedOrDefault = (input, frame2, options) => {
    const state = {
      options,
      embedded: false,
      graph: "@default",
      graphMap: { "@default": {} },
      subjectStack: [],
      link: {},
      bnodeMap: {}
    };
    const issuer = new util$2.IdentifierIssuer("_:b");
    _createNodeMap$1(input, state.graphMap, "@default", issuer);
    if (options.merged) {
      state.graphMap["@merged"] = _mergeNodeMapGraphs(state.graphMap);
      state.graph = "@merged";
    }
    state.subjects = state.graphMap[state.graph];
    const framed = [];
    api$1.frame(state, Object.keys(state.subjects).sort(), frame2, framed);
    if (options.pruneBlankNodeIdentifiers) {
      options.bnodesToClear = Object.keys(state.bnodeMap).filter((id3) => state.bnodeMap[id3].length === 1);
    }
    options.link = {};
    return _cleanupPreserve(framed, options);
  };
  api$1.frame = (state, subjects, frame2, parent, property = null) => {
    _validateFrame(frame2);
    frame2 = frame2[0];
    const options = state.options;
    const flags = {
      embed: _getFrameFlag(frame2, options, "embed"),
      explicit: _getFrameFlag(frame2, options, "explicit"),
      requireAll: _getFrameFlag(frame2, options, "requireAll")
    };
    if (!state.link.hasOwnProperty(state.graph)) {
      state.link[state.graph] = {};
    }
    const link = state.link[state.graph];
    const matches = _filterSubjects(state, subjects, frame2, flags);
    const ids = Object.keys(matches).sort();
    for (const id3 of ids) {
      const subject = matches[id3];
      if (property === null) {
        state.uniqueEmbeds = { [state.graph]: {} };
      } else {
        state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
      }
      if (flags.embed === "@link" && id3 in link) {
        _addFrameOutput(parent, property, link[id3]);
        continue;
      }
      const output2 = { "@id": id3 };
      if (id3.indexOf("_:") === 0) {
        util$2.addValue(state.bnodeMap, id3, output2, { propertyIsArray: true });
      }
      link[id3] = output2;
      if ((flags.embed === "@first" || flags.embed === "@last") && state.is11) {
        throw new JsonLdError$2(
          "Invalid JSON-LD syntax; invalid value of @embed.",
          "jsonld.SyntaxError",
          { code: "invalid @embed value", frame: frame2 }
        );
      }
      if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id3)) {
        continue;
      }
      if (state.embedded && (flags.embed === "@never" || _createsCircularReference(subject, state.graph, state.subjectStack))) {
        _addFrameOutput(parent, property, output2);
        continue;
      }
      if (state.embedded && (flags.embed == "@first" || flags.embed == "@once") && state.uniqueEmbeds[state.graph].hasOwnProperty(id3)) {
        _addFrameOutput(parent, property, output2);
        continue;
      }
      if (flags.embed === "@last") {
        if (id3 in state.uniqueEmbeds[state.graph]) {
          _removeEmbed(state, id3);
        }
      }
      state.uniqueEmbeds[state.graph][id3] = { parent, property };
      state.subjectStack.push({ subject, graph: state.graph });
      if (id3 in state.graphMap) {
        let recurse = false;
        let subframe = null;
        if (!("@graph" in frame2)) {
          recurse = state.graph !== "@merged";
          subframe = {};
        } else {
          subframe = frame2["@graph"][0];
          recurse = !(id3 === "@merged" || id3 === "@default");
          if (!types$1.isObject(subframe)) {
            subframe = {};
          }
        }
        if (recurse) {
          api$1.frame(
            { ...state, graph: id3, embedded: false },
            Object.keys(state.graphMap[id3]).sort(),
            [subframe],
            output2,
            "@graph"
          );
        }
      }
      if ("@included" in frame2) {
        api$1.frame(
          { ...state, embedded: false },
          subjects,
          frame2["@included"],
          output2,
          "@included"
        );
      }
      for (const prop of Object.keys(subject).sort()) {
        if (isKeyword(prop)) {
          output2[prop] = util$2.clone(subject[prop]);
          if (prop === "@type") {
            for (const type2 of subject["@type"]) {
              if (type2.indexOf("_:") === 0) {
                util$2.addValue(
                  state.bnodeMap,
                  type2,
                  output2,
                  { propertyIsArray: true }
                );
              }
            }
          }
          continue;
        }
        if (flags.explicit && !(prop in frame2)) {
          continue;
        }
        for (const o4 of subject[prop]) {
          const subframe = prop in frame2 ? frame2[prop] : _createImplicitFrame(flags);
          if (graphTypes.isList(o4)) {
            const subframe2 = frame2[prop] && frame2[prop][0] && frame2[prop][0]["@list"] ? frame2[prop][0]["@list"] : _createImplicitFrame(flags);
            const list = { "@list": [] };
            _addFrameOutput(output2, prop, list);
            const src2 = o4["@list"];
            for (const oo2 of src2) {
              if (graphTypes.isSubjectReference(oo2)) {
                api$1.frame(
                  { ...state, embedded: true },
                  [oo2["@id"]],
                  subframe2,
                  list,
                  "@list"
                );
              } else {
                _addFrameOutput(list, "@list", util$2.clone(oo2));
              }
            }
          } else if (graphTypes.isSubjectReference(o4)) {
            api$1.frame(
              { ...state, embedded: true },
              [o4["@id"]],
              subframe,
              output2,
              prop
            );
          } else if (_valueMatch(subframe[0], o4)) {
            _addFrameOutput(output2, prop, util$2.clone(o4));
          }
        }
      }
      for (const prop of Object.keys(frame2).sort()) {
        if (prop === "@type") {
          if (!types$1.isObject(frame2[prop][0]) || !("@default" in frame2[prop][0])) {
            continue;
          }
        } else if (isKeyword(prop)) {
          continue;
        }
        const next2 = frame2[prop][0] || {};
        const omitDefaultOn = _getFrameFlag(next2, options, "omitDefault");
        if (!omitDefaultOn && !(prop in output2)) {
          let preserve = "@null";
          if ("@default" in next2) {
            preserve = util$2.clone(next2["@default"]);
          }
          if (!types$1.isArray(preserve)) {
            preserve = [preserve];
          }
          output2[prop] = [{ "@preserve": preserve }];
        }
      }
      for (const reverseProp of Object.keys(frame2["@reverse"] || {}).sort()) {
        const subframe = frame2["@reverse"][reverseProp];
        for (const subject2 of Object.keys(state.subjects)) {
          const nodeValues = util$2.getValues(state.subjects[subject2], reverseProp);
          if (nodeValues.some((v6) => v6["@id"] === id3)) {
            output2["@reverse"] = output2["@reverse"] || {};
            util$2.addValue(
              output2["@reverse"],
              reverseProp,
              [],
              { propertyIsArray: true }
            );
            api$1.frame(
              { ...state, embedded: true },
              [subject2],
              subframe,
              output2["@reverse"][reverseProp],
              property
            );
          }
        }
      }
      _addFrameOutput(parent, property, output2);
      state.subjectStack.pop();
    }
  };
  api$1.cleanupNull = (input, options) => {
    if (types$1.isArray(input)) {
      const noNulls = input.map((v6) => api$1.cleanupNull(v6, options));
      return noNulls.filter((v6) => v6);
    }
    if (input === "@null") {
      return null;
    }
    if (types$1.isObject(input)) {
      if ("@id" in input) {
        const id3 = input["@id"];
        if (options.link.hasOwnProperty(id3)) {
          const idx = options.link[id3].indexOf(input);
          if (idx !== -1) {
            return options.link[id3][idx];
          }
          options.link[id3].push(input);
        } else {
          options.link[id3] = [input];
        }
      }
      for (const key in input) {
        input[key] = api$1.cleanupNull(input[key], options);
      }
    }
    return input;
  };
  function _createImplicitFrame(flags) {
    const frame2 = {};
    for (const key in flags) {
      if (flags[key] !== void 0) {
        frame2["@" + key] = [flags[key]];
      }
    }
    return [frame2];
  }
  function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
    for (let i4 = subjectStack.length - 1; i4 >= 0; --i4) {
      const subject = subjectStack[i4];
      if (subject.graph === graph && subject.subject["@id"] === subjectToEmbed["@id"]) {
        return true;
      }
    }
    return false;
  }
  function _getFrameFlag(frame2, options, name) {
    const flag = "@" + name;
    let rval = flag in frame2 ? frame2[flag][0] : options[name];
    if (name === "embed") {
      if (rval === true) {
        rval = "@once";
      } else if (rval === false) {
        rval = "@never";
      } else if (rval !== "@always" && rval !== "@never" && rval !== "@link" && rval !== "@first" && rval !== "@last" && rval !== "@once") {
        throw new JsonLdError$2(
          "Invalid JSON-LD syntax; invalid value of @embed.",
          "jsonld.SyntaxError",
          { code: "invalid @embed value", frame: frame2 }
        );
      }
    }
    return rval;
  }
  function _validateFrame(frame2) {
    if (!types$1.isArray(frame2) || frame2.length !== 1 || !types$1.isObject(frame2[0])) {
      throw new JsonLdError$2(
        "Invalid JSON-LD syntax; a JSON-LD frame must be a single object.",
        "jsonld.SyntaxError",
        { frame: frame2 }
      );
    }
    if ("@id" in frame2[0]) {
      for (const id3 of util$2.asArray(frame2[0]["@id"])) {
        if (!(types$1.isObject(id3) || url.isAbsolute(id3)) || types$1.isString(id3) && id3.indexOf("_:") === 0) {
          throw new JsonLdError$2(
            "Invalid JSON-LD syntax; invalid @id in frame.",
            "jsonld.SyntaxError",
            { code: "invalid frame", frame: frame2 }
          );
        }
      }
    }
    if ("@type" in frame2[0]) {
      for (const type2 of util$2.asArray(frame2[0]["@type"])) {
        if (!(types$1.isObject(type2) || url.isAbsolute(type2) || type2 === "@json") || types$1.isString(type2) && type2.indexOf("_:") === 0) {
          throw new JsonLdError$2(
            "Invalid JSON-LD syntax; invalid @type in frame.",
            "jsonld.SyntaxError",
            { code: "invalid frame", frame: frame2 }
          );
        }
      }
    }
  }
  function _filterSubjects(state, subjects, frame2, flags) {
    const rval = {};
    for (const id3 of subjects) {
      const subject = state.graphMap[state.graph][id3];
      if (_filterSubject(state, subject, frame2, flags)) {
        rval[id3] = subject;
      }
    }
    return rval;
  }
  function _filterSubject(state, subject, frame2, flags) {
    let wildcard = true;
    let matchesSome = false;
    for (const key in frame2) {
      let matchThis = false;
      const nodeValues = util$2.getValues(subject, key);
      const isEmpty = util$2.getValues(frame2, key).length === 0;
      if (key === "@id") {
        if (types$1.isEmptyObject(frame2["@id"][0] || {})) {
          matchThis = true;
        } else if (frame2["@id"].length >= 0) {
          matchThis = frame2["@id"].includes(nodeValues[0]);
        }
        if (!flags.requireAll) {
          return matchThis;
        }
      } else if (key === "@type") {
        wildcard = false;
        if (isEmpty) {
          if (nodeValues.length > 0) {
            return false;
          }
          matchThis = true;
        } else if (frame2["@type"].length === 1 && types$1.isEmptyObject(frame2["@type"][0])) {
          matchThis = nodeValues.length > 0;
        } else {
          for (const type2 of frame2["@type"]) {
            if (types$1.isObject(type2) && "@default" in type2) {
              matchThis = true;
            } else {
              matchThis = matchThis || nodeValues.some((tt4) => tt4 === type2);
            }
          }
        }
        if (!flags.requireAll) {
          return matchThis;
        }
      } else if (isKeyword(key)) {
        continue;
      } else {
        const thisFrame = util$2.getValues(frame2, key)[0];
        let hasDefault = false;
        if (thisFrame) {
          _validateFrame([thisFrame]);
          hasDefault = "@default" in thisFrame;
        }
        wildcard = false;
        if (nodeValues.length === 0 && hasDefault) {
          continue;
        }
        if (nodeValues.length > 0 && isEmpty) {
          return false;
        }
        if (thisFrame === void 0) {
          if (nodeValues.length > 0) {
            return false;
          }
          matchThis = true;
        } else {
          if (graphTypes.isList(thisFrame)) {
            const listValue = thisFrame["@list"][0];
            if (graphTypes.isList(nodeValues[0])) {
              const nodeListValues = nodeValues[0]["@list"];
              if (graphTypes.isValue(listValue)) {
                matchThis = nodeListValues.some((lv) => _valueMatch(listValue, lv));
              } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                matchThis = nodeListValues.some((lv) => _nodeMatch(
                  state,
                  listValue,
                  lv,
                  flags
                ));
              }
            }
          } else if (graphTypes.isValue(thisFrame)) {
            matchThis = nodeValues.some((nv) => _valueMatch(thisFrame, nv));
          } else if (graphTypes.isSubjectReference(thisFrame)) {
            matchThis = nodeValues.some((nv) => _nodeMatch(state, thisFrame, nv, flags));
          } else if (types$1.isObject(thisFrame)) {
            matchThis = nodeValues.length > 0;
          } else {
            matchThis = false;
          }
        }
      }
      if (!matchThis && flags.requireAll) {
        return false;
      }
      matchesSome = matchesSome || matchThis;
    }
    return wildcard || matchesSome;
  }
  function _removeEmbed(state, id3) {
    const embeds = state.uniqueEmbeds[state.graph];
    const embed = embeds[id3];
    const parent = embed.parent;
    const property = embed.property;
    const subject = { "@id": id3 };
    if (types$1.isArray(parent)) {
      for (let i4 = 0; i4 < parent.length; ++i4) {
        if (util$2.compareValues(parent[i4], subject)) {
          parent[i4] = subject;
          break;
        }
      }
    } else {
      const useArray = types$1.isArray(parent[property]);
      util$2.removeValue(parent, property, subject, { propertyIsArray: useArray });
      util$2.addValue(parent, property, subject, { propertyIsArray: useArray });
    }
    const removeDependents = (id4) => {
      const ids = Object.keys(embeds);
      for (const next2 of ids) {
        if (next2 in embeds && types$1.isObject(embeds[next2].parent) && embeds[next2].parent["@id"] === id4) {
          delete embeds[next2];
          removeDependents(next2);
        }
      }
    };
    removeDependents(id3);
  }
  function _cleanupPreserve(input, options) {
    if (types$1.isArray(input)) {
      return input.map((value) => _cleanupPreserve(value, options));
    }
    if (types$1.isObject(input)) {
      if ("@preserve" in input) {
        return input["@preserve"][0];
      }
      if (graphTypes.isValue(input)) {
        return input;
      }
      if (graphTypes.isList(input)) {
        input["@list"] = _cleanupPreserve(input["@list"], options);
        return input;
      }
      if ("@id" in input) {
        const id3 = input["@id"];
        if (options.link.hasOwnProperty(id3)) {
          const idx = options.link[id3].indexOf(input);
          if (idx !== -1) {
            return options.link[id3][idx];
          }
          options.link[id3].push(input);
        } else {
          options.link[id3] = [input];
        }
      }
      for (const prop in input) {
        if (prop === "@id" && options.bnodesToClear.includes(input[prop])) {
          delete input["@id"];
          continue;
        }
        input[prop] = _cleanupPreserve(input[prop], options);
      }
    }
    return input;
  }
  function _addFrameOutput(parent, property, output2) {
    if (types$1.isObject(parent)) {
      util$2.addValue(parent, property, output2, { propertyIsArray: true });
    } else {
      parent.push(output2);
    }
  }
  function _nodeMatch(state, pattern2, value, flags) {
    if (!("@id" in value)) {
      return false;
    }
    const nodeObject = state.subjects[value["@id"]];
    return nodeObject && _filterSubject(state, nodeObject, pattern2, flags);
  }
  function _valueMatch(pattern2, value) {
    const v1 = value["@value"];
    const t1 = value["@type"];
    const l1 = value["@language"];
    const v22 = pattern2["@value"] ? types$1.isArray(pattern2["@value"]) ? pattern2["@value"] : [pattern2["@value"]] : [];
    const t2 = pattern2["@type"] ? types$1.isArray(pattern2["@type"]) ? pattern2["@type"] : [pattern2["@type"]] : [];
    const l22 = pattern2["@language"] ? types$1.isArray(pattern2["@language"]) ? pattern2["@language"] : [pattern2["@language"]] : [];
    if (v22.length === 0 && t2.length === 0 && l22.length === 0) {
      return true;
    }
    if (!(v22.includes(v1) || types$1.isEmptyObject(v22[0]))) {
      return false;
    }
    if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types$1.isEmptyObject(t2[0]))) {
      return false;
    }
    if (!(!l1 && l22.length === 0 || l22.includes(l1) || l1 && types$1.isEmptyObject(l22[0]))) {
      return false;
    }
    return true;
  }
  var JsonLdError$1 = JsonLdError_1;
  var {
    isArray: _isArray$1,
    isObject: _isObject$1,
    isString: _isString$1,
    isUndefined: _isUndefined
  } = types$8;
  var {
    isList: _isList,
    isValue: _isValue,
    isGraph: _isGraph,
    isSimpleGraph: _isSimpleGraph,
    isSubjectReference: _isSubjectReference$1
  } = graphTypes$5;
  var {
    expandIri: _expandIri$1,
    getContextValue: _getContextValue,
    isKeyword: _isKeyword,
    process: _processContext$1,
    processingMode: _processingMode$1
  } = context;
  var {
    removeBase: _removeBase,
    prependBase: _prependBase
  } = url$1;
  var {
    REGEX_KEYWORD,
    addValue: _addValue,
    asArray: _asArray,
    compareShortestLeast: _compareShortestLeast
  } = util$6;
  var api = {};
  var compact = api;
  api.compact = async ({
    activeCtx,
    activeProperty = null,
    element,
    options = {}
  }) => {
    if (_isArray$1(element)) {
      let rval = [];
      for (let i4 = 0; i4 < element.length; ++i4) {
        const compacted = await api.compact({
          activeCtx,
          activeProperty,
          element: element[i4],
          options
        });
        if (compacted === null) {
          continue;
        }
        rval.push(compacted);
      }
      if (options.compactArrays && rval.length === 1) {
        const container = _getContextValue(
          activeCtx,
          activeProperty,
          "@container"
        ) || [];
        if (container.length === 0) {
          rval = rval[0];
        }
      }
      return rval;
    }
    const ctx = _getContextValue(activeCtx, activeProperty, "@context");
    if (!_isUndefined(ctx)) {
      activeCtx = await _processContext$1({
        activeCtx,
        localCtx: ctx,
        propagate: true,
        overrideProtected: true,
        options
      });
    }
    if (_isObject$1(element)) {
      if (options.link && "@id" in element && options.link.hasOwnProperty(element["@id"])) {
        const linked = options.link[element["@id"]];
        for (let i4 = 0; i4 < linked.length; ++i4) {
          if (linked[i4].expanded === element) {
            return linked[i4].compacted;
          }
        }
      }
      if (_isValue(element) || _isSubjectReference$1(element)) {
        const rval2 = api.compactValue({ activeCtx, activeProperty, value: element, options });
        if (options.link && _isSubjectReference$1(element)) {
          if (!options.link.hasOwnProperty(element["@id"])) {
            options.link[element["@id"]] = [];
          }
          options.link[element["@id"]].push({ expanded: element, compacted: rval2 });
        }
        return rval2;
      }
      if (_isList(element)) {
        const container = _getContextValue(
          activeCtx,
          activeProperty,
          "@container"
        ) || [];
        if (container.includes("@list")) {
          return api.compact({
            activeCtx,
            activeProperty,
            element: element["@list"],
            options
          });
        }
      }
      const insideReverse = activeProperty === "@reverse";
      const rval = {};
      const inputCtx = activeCtx;
      if (!_isValue(element) && !_isSubjectReference$1(element)) {
        activeCtx = activeCtx.revertToPreviousContext();
      }
      const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, "@context");
      if (!_isUndefined(propertyScopedCtx)) {
        activeCtx = await _processContext$1({
          activeCtx,
          localCtx: propertyScopedCtx,
          propagate: true,
          overrideProtected: true,
          options
        });
      }
      if (options.link && "@id" in element) {
        if (!options.link.hasOwnProperty(element["@id"])) {
          options.link[element["@id"]] = [];
        }
        options.link[element["@id"]].push({ expanded: element, compacted: rval });
      }
      let types2 = element["@type"] || [];
      if (types2.length > 1) {
        types2 = Array.from(types2).sort();
      }
      const typeContext = activeCtx;
      for (const type2 of types2) {
        const compactedType = api.compactIri(
          { activeCtx: typeContext, iri: type2, relativeTo: { vocab: true } }
        );
        const ctx2 = _getContextValue(inputCtx, compactedType, "@context");
        if (!_isUndefined(ctx2)) {
          activeCtx = await _processContext$1({
            activeCtx,
            localCtx: ctx2,
            options,
            propagate: false
          });
        }
      }
      const keys = Object.keys(element).sort();
      for (const expandedProperty of keys) {
        const expandedValue = element[expandedProperty];
        if (expandedProperty === "@id") {
          let compactedValue = _asArray(expandedValue).map(
            (expandedIri) => api.compactIri({
              activeCtx,
              iri: expandedIri,
              relativeTo: { vocab: false },
              base: options.base
            })
          );
          if (compactedValue.length === 1) {
            compactedValue = compactedValue[0];
          }
          const alias = api.compactIri(
            { activeCtx, iri: "@id", relativeTo: { vocab: true } }
          );
          rval[alias] = compactedValue;
          continue;
        }
        if (expandedProperty === "@type") {
          let compactedValue = _asArray(expandedValue).map(
            (expandedIri) => api.compactIri({
              activeCtx: inputCtx,
              iri: expandedIri,
              relativeTo: { vocab: true }
            })
          );
          if (compactedValue.length === 1) {
            compactedValue = compactedValue[0];
          }
          const alias = api.compactIri(
            { activeCtx, iri: "@type", relativeTo: { vocab: true } }
          );
          const container = _getContextValue(
            activeCtx,
            alias,
            "@container"
          ) || [];
          const typeAsSet = container.includes("@set") && _processingMode$1(activeCtx, 1.1);
          const isArray = typeAsSet || _isArray$1(compactedValue) && expandedValue.length === 0;
          _addValue(rval, alias, compactedValue, { propertyIsArray: isArray });
          continue;
        }
        if (expandedProperty === "@reverse") {
          const compactedValue = await api.compact({
            activeCtx,
            activeProperty: "@reverse",
            element: expandedValue,
            options
          });
          for (const compactedProperty in compactedValue) {
            if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
              const value = compactedValue[compactedProperty];
              const container = _getContextValue(
                activeCtx,
                compactedProperty,
                "@container"
              ) || [];
              const useArray = container.includes("@set") || !options.compactArrays;
              _addValue(
                rval,
                compactedProperty,
                value,
                { propertyIsArray: useArray }
              );
              delete compactedValue[compactedProperty];
            }
          }
          if (Object.keys(compactedValue).length > 0) {
            const alias = api.compactIri({
              activeCtx,
              iri: expandedProperty,
              relativeTo: { vocab: true }
            });
            _addValue(rval, alias, compactedValue);
          }
          continue;
        }
        if (expandedProperty === "@preserve") {
          const compactedValue = await api.compact({
            activeCtx,
            activeProperty,
            element: expandedValue,
            options
          });
          if (!(_isArray$1(compactedValue) && compactedValue.length === 0)) {
            _addValue(rval, expandedProperty, compactedValue);
          }
          continue;
        }
        if (expandedProperty === "@index") {
          const container = _getContextValue(
            activeCtx,
            activeProperty,
            "@container"
          ) || [];
          if (container.includes("@index")) {
            continue;
          }
          const alias = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            relativeTo: { vocab: true }
          });
          _addValue(rval, alias, expandedValue);
          continue;
        }
        if (expandedProperty !== "@graph" && expandedProperty !== "@list" && expandedProperty !== "@included" && _isKeyword(expandedProperty)) {
          const alias = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            relativeTo: { vocab: true }
          });
          _addValue(rval, alias, expandedValue);
          continue;
        }
        if (!_isArray$1(expandedValue)) {
          throw new JsonLdError$1(
            "JSON-LD expansion error; expanded value must be an array.",
            "jsonld.SyntaxError"
          );
        }
        if (expandedValue.length === 0) {
          const itemActiveProperty = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            value: expandedValue,
            relativeTo: { vocab: true },
            reverse: insideReverse
          });
          const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
          let nestResult = rval;
          if (nestProperty) {
            _checkNestProperty(activeCtx, nestProperty, options);
            if (!_isObject$1(rval[nestProperty])) {
              rval[nestProperty] = {};
            }
            nestResult = rval[nestProperty];
          }
          _addValue(
            nestResult,
            itemActiveProperty,
            expandedValue,
            {
              propertyIsArray: true
            }
          );
        }
        for (const expandedItem of expandedValue) {
          const itemActiveProperty = api.compactIri({
            activeCtx,
            iri: expandedProperty,
            value: expandedItem,
            relativeTo: { vocab: true },
            reverse: insideReverse
          });
          const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
          let nestResult = rval;
          if (nestProperty) {
            _checkNestProperty(activeCtx, nestProperty, options);
            if (!_isObject$1(rval[nestProperty])) {
              rval[nestProperty] = {};
            }
            nestResult = rval[nestProperty];
          }
          const container = _getContextValue(
            activeCtx,
            itemActiveProperty,
            "@container"
          ) || [];
          const isGraph = _isGraph(expandedItem);
          const isList = _isList(expandedItem);
          let inner;
          if (isList) {
            inner = expandedItem["@list"];
          } else if (isGraph) {
            inner = expandedItem["@graph"];
          }
          let compactedItem = await api.compact({
            activeCtx,
            activeProperty: itemActiveProperty,
            element: isList || isGraph ? inner : expandedItem,
            options
          });
          if (isList) {
            if (!_isArray$1(compactedItem)) {
              compactedItem = [compactedItem];
            }
            if (!container.includes("@list")) {
              compactedItem = {
                [api.compactIri({
                  activeCtx,
                  iri: "@list",
                  relativeTo: { vocab: true }
                })]: compactedItem
              };
              if ("@index" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@index",
                  relativeTo: { vocab: true }
                })] = expandedItem["@index"];
              }
            } else {
              _addValue(nestResult, itemActiveProperty, compactedItem, {
                valueIsArray: true,
                allowDuplicate: true
              });
              continue;
            }
          }
          if (isGraph) {
            if (container.includes("@graph") && (container.includes("@id") || container.includes("@index") && _isSimpleGraph(expandedItem))) {
              let mapObject;
              if (nestResult.hasOwnProperty(itemActiveProperty)) {
                mapObject = nestResult[itemActiveProperty];
              } else {
                nestResult[itemActiveProperty] = mapObject = {};
              }
              const key = (container.includes("@id") ? expandedItem["@id"] : expandedItem["@index"]) || api.compactIri({
                activeCtx,
                iri: "@none",
                relativeTo: { vocab: true }
              });
              _addValue(
                mapObject,
                key,
                compactedItem,
                {
                  propertyIsArray: !options.compactArrays || container.includes("@set")
                }
              );
            } else if (container.includes("@graph") && _isSimpleGraph(expandedItem)) {
              if (_isArray$1(compactedItem) && compactedItem.length > 1) {
                compactedItem = { "@included": compactedItem };
              }
              _addValue(
                nestResult,
                itemActiveProperty,
                compactedItem,
                {
                  propertyIsArray: !options.compactArrays || container.includes("@set")
                }
              );
            } else {
              if (_isArray$1(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                compactedItem = compactedItem[0];
              }
              compactedItem = {
                [api.compactIri({
                  activeCtx,
                  iri: "@graph",
                  relativeTo: { vocab: true }
                })]: compactedItem
              };
              if ("@id" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@id",
                  relativeTo: { vocab: true }
                })] = expandedItem["@id"];
              }
              if ("@index" in expandedItem) {
                compactedItem[api.compactIri({
                  activeCtx,
                  iri: "@index",
                  relativeTo: { vocab: true }
                })] = expandedItem["@index"];
              }
              _addValue(
                nestResult,
                itemActiveProperty,
                compactedItem,
                {
                  propertyIsArray: !options.compactArrays || container.includes("@set")
                }
              );
            }
          } else if (container.includes("@language") || container.includes("@index") || container.includes("@id") || container.includes("@type")) {
            let mapObject;
            if (nestResult.hasOwnProperty(itemActiveProperty)) {
              mapObject = nestResult[itemActiveProperty];
            } else {
              nestResult[itemActiveProperty] = mapObject = {};
            }
            let key;
            if (container.includes("@language")) {
              if (_isValue(compactedItem)) {
                compactedItem = compactedItem["@value"];
              }
              key = expandedItem["@language"];
            } else if (container.includes("@index")) {
              const indexKey = _getContextValue(
                activeCtx,
                itemActiveProperty,
                "@index"
              ) || "@index";
              const containerKey = api.compactIri(
                { activeCtx, iri: indexKey, relativeTo: { vocab: true } }
              );
              if (indexKey === "@index") {
                key = expandedItem["@index"];
                delete compactedItem[containerKey];
              } else {
                let others;
                [key, ...others] = _asArray(compactedItem[indexKey] || []);
                if (!_isString$1(key)) {
                  key = null;
                } else {
                  switch (others.length) {
                    case 0:
                      delete compactedItem[indexKey];
                      break;
                    case 1:
                      compactedItem[indexKey] = others[0];
                      break;
                    default:
                      compactedItem[indexKey] = others;
                      break;
                  }
                }
              }
            } else if (container.includes("@id")) {
              const idKey = api.compactIri({
                activeCtx,
                iri: "@id",
                relativeTo: { vocab: true }
              });
              key = compactedItem[idKey];
              delete compactedItem[idKey];
            } else if (container.includes("@type")) {
              const typeKey = api.compactIri({
                activeCtx,
                iri: "@type",
                relativeTo: { vocab: true }
              });
              let types3;
              [key, ...types3] = _asArray(compactedItem[typeKey] || []);
              switch (types3.length) {
                case 0:
                  delete compactedItem[typeKey];
                  break;
                case 1:
                  compactedItem[typeKey] = types3[0];
                  break;
                default:
                  compactedItem[typeKey] = types3;
                  break;
              }
              if (Object.keys(compactedItem).length === 1 && "@id" in expandedItem) {
                compactedItem = await api.compact({
                  activeCtx,
                  activeProperty: itemActiveProperty,
                  element: { "@id": expandedItem["@id"] },
                  options
                });
              }
            }
            if (!key) {
              key = api.compactIri({
                activeCtx,
                iri: "@none",
                relativeTo: { vocab: true }
              });
            }
            _addValue(
              mapObject,
              key,
              compactedItem,
              {
                propertyIsArray: container.includes("@set")
              }
            );
          } else {
            const isArray = !options.compactArrays || container.includes("@set") || container.includes("@list") || _isArray$1(compactedItem) && compactedItem.length === 0 || expandedProperty === "@list" || expandedProperty === "@graph";
            _addValue(
              nestResult,
              itemActiveProperty,
              compactedItem,
              { propertyIsArray: isArray }
            );
          }
        }
      }
      return rval;
    }
    return element;
  };
  api.compactIri = ({
    activeCtx,
    iri,
    value = null,
    relativeTo = { vocab: false },
    reverse = false,
    base: base3 = null
  }) => {
    if (iri === null) {
      return iri;
    }
    if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
      activeCtx = activeCtx.previousContext;
    }
    const inverseCtx = activeCtx.getInverse();
    if (_isKeyword(iri) && iri in inverseCtx && "@none" in inverseCtx[iri] && "@type" in inverseCtx[iri]["@none"] && "@none" in inverseCtx[iri]["@none"]["@type"]) {
      return inverseCtx[iri]["@none"]["@type"]["@none"];
    }
    if (relativeTo.vocab && iri in inverseCtx) {
      const defaultLanguage = activeCtx["@language"] || "@none";
      const containers = [];
      if (_isObject$1(value) && "@index" in value && !("@graph" in value)) {
        containers.push("@index", "@index@set");
      }
      if (_isObject$1(value) && "@preserve" in value) {
        value = value["@preserve"][0];
      }
      if (_isGraph(value)) {
        if ("@index" in value) {
          containers.push(
            "@graph@index",
            "@graph@index@set",
            "@index",
            "@index@set"
          );
        }
        if ("@id" in value) {
          containers.push(
            "@graph@id",
            "@graph@id@set"
          );
        }
        containers.push("@graph", "@graph@set", "@set");
        if (!("@index" in value)) {
          containers.push(
            "@graph@index",
            "@graph@index@set",
            "@index",
            "@index@set"
          );
        }
        if (!("@id" in value)) {
          containers.push("@graph@id", "@graph@id@set");
        }
      } else if (_isObject$1(value) && !_isValue(value)) {
        containers.push("@id", "@id@set", "@type", "@set@type");
      }
      let typeOrLanguage = "@language";
      let typeOrLanguageValue = "@null";
      if (reverse) {
        typeOrLanguage = "@type";
        typeOrLanguageValue = "@reverse";
        containers.push("@set");
      } else if (_isList(value)) {
        if (!("@index" in value)) {
          containers.push("@list");
        }
        const list = value["@list"];
        if (list.length === 0) {
          typeOrLanguage = "@any";
          typeOrLanguageValue = "@none";
        } else {
          let commonLanguage = list.length === 0 ? defaultLanguage : null;
          let commonType = null;
          for (let i4 = 0; i4 < list.length; ++i4) {
            const item = list[i4];
            let itemLanguage = "@none";
            let itemType = "@none";
            if (_isValue(item)) {
              if ("@direction" in item) {
                const lang = (item["@language"] || "").toLowerCase();
                const dir = item["@direction"];
                itemLanguage = `${lang}_${dir}`;
              } else if ("@language" in item) {
                itemLanguage = item["@language"].toLowerCase();
              } else if ("@type" in item) {
                itemType = item["@type"];
              } else {
                itemLanguage = "@null";
              }
            } else {
              itemType = "@id";
            }
            if (commonLanguage === null) {
              commonLanguage = itemLanguage;
            } else if (itemLanguage !== commonLanguage && _isValue(item)) {
              commonLanguage = "@none";
            }
            if (commonType === null) {
              commonType = itemType;
            } else if (itemType !== commonType) {
              commonType = "@none";
            }
            if (commonLanguage === "@none" && commonType === "@none") {
              break;
            }
          }
          commonLanguage = commonLanguage || "@none";
          commonType = commonType || "@none";
          if (commonType !== "@none") {
            typeOrLanguage = "@type";
            typeOrLanguageValue = commonType;
          } else {
            typeOrLanguageValue = commonLanguage;
          }
        }
      } else {
        if (_isValue(value)) {
          if ("@language" in value && !("@index" in value)) {
            containers.push("@language", "@language@set");
            typeOrLanguageValue = value["@language"];
            const dir = value["@direction"];
            if (dir) {
              typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;
            }
          } else if ("@direction" in value && !("@index" in value)) {
            typeOrLanguageValue = `_${value["@direction"]}`;
          } else if ("@type" in value) {
            typeOrLanguage = "@type";
            typeOrLanguageValue = value["@type"];
          }
        } else {
          typeOrLanguage = "@type";
          typeOrLanguageValue = "@id";
        }
        containers.push("@set");
      }
      containers.push("@none");
      if (_isObject$1(value) && !("@index" in value)) {
        containers.push("@index", "@index@set");
      }
      if (_isValue(value) && Object.keys(value).length === 1) {
        containers.push("@language", "@language@set");
      }
      const term = _selectTerm(
        activeCtx,
        iri,
        value,
        containers,
        typeOrLanguage,
        typeOrLanguageValue
      );
      if (term !== null) {
        return term;
      }
    }
    if (relativeTo.vocab) {
      if ("@vocab" in activeCtx) {
        const vocab = activeCtx["@vocab"];
        if (iri.indexOf(vocab) === 0 && iri !== vocab) {
          const suffix = iri.substr(vocab.length);
          if (!activeCtx.mappings.has(suffix)) {
            return suffix;
          }
        }
      }
    }
    let choice = null;
    const partialMatches = [];
    let iriMap = activeCtx.fastCurieMap;
    const maxPartialLength = iri.length - 1;
    for (let i4 = 0; i4 < maxPartialLength && iri[i4] in iriMap; ++i4) {
      iriMap = iriMap[iri[i4]];
      if ("" in iriMap) {
        partialMatches.push(iriMap[""][0]);
      }
    }
    for (let i4 = partialMatches.length - 1; i4 >= 0; --i4) {
      const entry = partialMatches[i4];
      const terms = entry.terms;
      for (const term of terms) {
        const curie = term + ":" + iri.substr(entry.iri.length);
        const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)["@id"] === iri);
        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
          choice = curie;
        }
      }
    }
    if (choice !== null) {
      return choice;
    }
    for (const [term, td2] of activeCtx.mappings) {
      if (td2 && td2._prefix && iri.startsWith(term + ":")) {
        throw new JsonLdError$1(
          `Absolute IRI "${iri}" confused with prefix "${term}".`,
          "jsonld.SyntaxError",
          { code: "IRI confused with prefix", context: activeCtx }
        );
      }
    }
    if (!relativeTo.vocab) {
      if ("@base" in activeCtx) {
        if (!activeCtx["@base"]) {
          return iri;
        } else {
          const _iri = _removeBase(_prependBase(base3, activeCtx["@base"]), iri);
          return REGEX_KEYWORD.test(_iri) ? `./${_iri}` : _iri;
        }
      } else {
        return _removeBase(base3, iri);
      }
    }
    return iri;
  };
  api.compactValue = ({ activeCtx, activeProperty, value, options }) => {
    if (_isValue(value)) {
      const type3 = _getContextValue(activeCtx, activeProperty, "@type");
      const language = _getContextValue(activeCtx, activeProperty, "@language");
      const direction = _getContextValue(activeCtx, activeProperty, "@direction");
      const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
      const preserveIndex = "@index" in value && !container.includes("@index");
      if (!preserveIndex && type3 !== "@none") {
        if (value["@type"] === type3) {
          return value["@value"];
        }
        if ("@language" in value && value["@language"] === language && "@direction" in value && value["@direction"] === direction) {
          return value["@value"];
        }
        if ("@language" in value && value["@language"] === language) {
          return value["@value"];
        }
        if ("@direction" in value && value["@direction"] === direction) {
          return value["@value"];
        }
      }
      const keyCount = Object.keys(value).length;
      const isValueOnlyKey = keyCount === 1 || keyCount === 2 && "@index" in value && !preserveIndex;
      const hasDefaultLanguage = "@language" in activeCtx;
      const isValueString = _isString$1(value["@value"]);
      const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)["@language"] === null;
      if (isValueOnlyKey && type3 !== "@none" && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
        return value["@value"];
      }
      const rval = {};
      if (preserveIndex) {
        rval[api.compactIri({
          activeCtx,
          iri: "@index",
          relativeTo: { vocab: true }
        })] = value["@index"];
      }
      if ("@type" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@type",
          relativeTo: { vocab: true }
        })] = api.compactIri(
          { activeCtx, iri: value["@type"], relativeTo: { vocab: true } }
        );
      } else if ("@language" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@language",
          relativeTo: { vocab: true }
        })] = value["@language"];
      }
      if ("@direction" in value) {
        rval[api.compactIri({
          activeCtx,
          iri: "@direction",
          relativeTo: { vocab: true }
        })] = value["@direction"];
      }
      rval[api.compactIri({
        activeCtx,
        iri: "@value",
        relativeTo: { vocab: true }
      })] = value["@value"];
      return rval;
    }
    const expandedProperty = _expandIri$1(
      activeCtx,
      activeProperty,
      { vocab: true },
      options
    );
    const type2 = _getContextValue(activeCtx, activeProperty, "@type");
    const compacted = api.compactIri({
      activeCtx,
      iri: value["@id"],
      relativeTo: { vocab: type2 === "@vocab" },
      base: options.base
    });
    if (type2 === "@id" || type2 === "@vocab" || expandedProperty === "@graph") {
      return compacted;
    }
    return {
      [api.compactIri({
        activeCtx,
        iri: "@id",
        relativeTo: { vocab: true }
      })]: compacted
    };
  };
  function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
    if (typeOrLanguageValue === null) {
      typeOrLanguageValue = "@null";
    }
    const prefs = [];
    if ((typeOrLanguageValue === "@id" || typeOrLanguageValue === "@reverse") && _isObject$1(value) && "@id" in value) {
      if (typeOrLanguageValue === "@reverse") {
        prefs.push("@reverse");
      }
      const term = api.compactIri(
        { activeCtx, iri: value["@id"], relativeTo: { vocab: true } }
      );
      if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)["@id"] === value["@id"]) {
        prefs.push.apply(prefs, ["@vocab", "@id"]);
      } else {
        prefs.push.apply(prefs, ["@id", "@vocab"]);
      }
    } else {
      prefs.push(typeOrLanguageValue);
      const langDir = prefs.find((el2) => el2.includes("_"));
      if (langDir) {
        prefs.push(langDir.replace(/^[^_]+_/, "_"));
      }
    }
    prefs.push("@none");
    const containerMap = activeCtx.inverse[iri];
    for (const container of containers) {
      if (!(container in containerMap)) {
        continue;
      }
      const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
      for (const pref of prefs) {
        if (!(pref in typeOrLanguageValueMap)) {
          continue;
        }
        return typeOrLanguageValueMap[pref];
      }
    }
    return null;
  }
  function _checkNestProperty(activeCtx, nestProperty, options) {
    if (_expandIri$1(activeCtx, nestProperty, { vocab: true }, options) !== "@nest") {
      throw new JsonLdError$1(
        "JSON-LD compact error; nested property must have an @nest value resolving to @nest.",
        "jsonld.SyntaxError",
        { code: "invalid @nest value" }
      );
    }
  }
  var JsonLdProcessor;
  var hasRequiredJsonLdProcessor;
  function requireJsonLdProcessor() {
    if (hasRequiredJsonLdProcessor)
      return JsonLdProcessor;
    hasRequiredJsonLdProcessor = 1;
    JsonLdProcessor = (jsonld2) => {
      class JsonLdProcessor2 {
        toString() {
          return "[object JsonLdProcessor]";
        }
      }
      Object.defineProperty(JsonLdProcessor2, "prototype", {
        writable: false,
        enumerable: false
      });
      Object.defineProperty(JsonLdProcessor2.prototype, "constructor", {
        writable: true,
        enumerable: false,
        configurable: true,
        value: JsonLdProcessor2
      });
      JsonLdProcessor2.compact = function(input, ctx) {
        if (arguments.length < 2) {
          return Promise.reject(
            new TypeError("Could not compact, too few arguments.")
          );
        }
        return jsonld2.compact(input, ctx);
      };
      JsonLdProcessor2.expand = function(input) {
        if (arguments.length < 1) {
          return Promise.reject(
            new TypeError("Could not expand, too few arguments.")
          );
        }
        return jsonld2.expand(input);
      };
      JsonLdProcessor2.flatten = function(input) {
        if (arguments.length < 1) {
          return Promise.reject(
            new TypeError("Could not flatten, too few arguments.")
          );
        }
        return jsonld2.flatten(input);
      };
      return JsonLdProcessor2;
    };
    return JsonLdProcessor;
  }
  var canonize = rdfCanonize;
  var platform = platformBrowser;
  var util$1 = util$6;
  var ContextResolver2 = ContextResolver_1;
  var IdentifierIssuer2 = util$1.IdentifierIssuer;
  var JsonLdError2 = JsonLdError_1;
  var LRU = lruCache;
  var NQuads2 = NQuads$1;
  var { expand: _expand } = expand;
  var { flatten: _flatten } = flatten$1;
  var { fromRDF: _fromRDF } = fromRdf;
  var { toRDF: _toRDF } = toRdf;
  var {
    frameMergedOrDefault: _frameMergedOrDefault,
    cleanupNull: _cleanupNull
  } = frame;
  var {
    isArray: _isArray,
    isObject: _isObject,
    isString: _isString
  } = types$8;
  var {
    isSubjectReference: _isSubjectReference
  } = graphTypes$5;
  var {
    expandIri: _expandIri,
    getInitialContext: _getInitialContext,
    process: _processContext,
    processingMode: _processingMode
  } = context;
  var {
    compact: _compact,
    compactIri: _compactIri
  } = compact;
  var {
    createNodeMap: _createNodeMap,
    createMergedNodeMap: _createMergedNodeMap,
    mergeNodeMaps: _mergeNodeMaps
  } = nodeMap;
  var {
    logEventHandler: _logEventHandler,
    logWarningEventHandler: _logWarningEventHandler,
    safeEventHandler: _safeEventHandler,
    setDefaultEventHandler: _setDefaultEventHandler,
    setupEventHandler: _setupEventHandler,
    strictEventHandler: _strictEventHandler,
    unhandledEventHandler: _unhandledEventHandler
  } = events;
  var wrapper = function(jsonld2) {
    const _rdfParsers = {};
    const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;
    const _resolvedContextCache = new LRU({ max: RESOLVED_CONTEXT_CACHE_MAX_SIZE });
    jsonld2.compact = async function(input, ctx, options) {
      if (arguments.length < 2) {
        throw new TypeError("Could not compact, too few arguments.");
      }
      if (ctx === null) {
        throw new JsonLdError2(
          "The compaction context must not be null.",
          "jsonld.CompactError",
          { code: "invalid local context" }
        );
      }
      if (input === null) {
        return null;
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : "",
        compactArrays: true,
        compactToRelative: true,
        graph: false,
        skipExpansion: false,
        link: false,
        issuer: new IdentifierIssuer2("_:b"),
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      if (options.link) {
        options.skipExpansion = true;
      }
      if (!options.compactToRelative) {
        delete options.base;
      }
      let expanded;
      if (options.skipExpansion) {
        expanded = input;
      } else {
        expanded = await jsonld2.expand(input, options);
      }
      const activeCtx = await jsonld2.processContext(
        _getInitialContext(options),
        ctx,
        options
      );
      let compacted = await _compact({
        activeCtx,
        element: expanded,
        options
      });
      if (options.compactArrays && !options.graph && _isArray(compacted)) {
        if (compacted.length === 1) {
          compacted = compacted[0];
        } else if (compacted.length === 0) {
          compacted = {};
        }
      } else if (options.graph && _isObject(compacted)) {
        compacted = [compacted];
      }
      if (_isObject(ctx) && "@context" in ctx) {
        ctx = ctx["@context"];
      }
      ctx = util$1.clone(ctx);
      if (!_isArray(ctx)) {
        ctx = [ctx];
      }
      const tmp = ctx;
      ctx = [];
      for (let i4 = 0; i4 < tmp.length; ++i4) {
        if (!_isObject(tmp[i4]) || Object.keys(tmp[i4]).length > 0) {
          ctx.push(tmp[i4]);
        }
      }
      const hasContext = ctx.length > 0;
      if (ctx.length === 1) {
        ctx = ctx[0];
      }
      if (_isArray(compacted)) {
        const graphAlias = _compactIri({
          activeCtx,
          iri: "@graph",
          relativeTo: { vocab: true }
        });
        const graph = compacted;
        compacted = {};
        if (hasContext) {
          compacted["@context"] = ctx;
        }
        compacted[graphAlias] = graph;
      } else if (_isObject(compacted) && hasContext) {
        const graph = compacted;
        compacted = { "@context": ctx };
        for (const key in graph) {
          compacted[key] = graph[key];
        }
      }
      return compacted;
    };
    jsonld2.expand = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not expand, too few arguments.");
      }
      options = _setDefaults(options, {
        keepFreeFloatingNodes: false,
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      const toResolve = {};
      const contextsToProcess = [];
      if ("expandContext" in options) {
        const expandContext = util$1.clone(options.expandContext);
        if (_isObject(expandContext) && "@context" in expandContext) {
          toResolve.expandContext = expandContext;
        } else {
          toResolve.expandContext = { "@context": expandContext };
        }
        contextsToProcess.push(toResolve.expandContext);
      }
      let defaultBase;
      if (!_isString(input)) {
        toResolve.input = util$1.clone(input);
      } else {
        const remoteDoc = await jsonld2.get(input, options);
        defaultBase = remoteDoc.documentUrl;
        toResolve.input = remoteDoc.document;
        if (remoteDoc.contextUrl) {
          toResolve.remoteContext = { "@context": remoteDoc.contextUrl };
          contextsToProcess.push(toResolve.remoteContext);
        }
      }
      if (!("base" in options)) {
        options.base = defaultBase || "";
      }
      let activeCtx = _getInitialContext(options);
      for (const localCtx of contextsToProcess) {
        activeCtx = await _processContext({ activeCtx, localCtx, options });
      }
      let expanded = await _expand({
        activeCtx,
        element: toResolve.input,
        options
      });
      if (_isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
        expanded = expanded["@graph"];
      } else if (expanded === null) {
        expanded = [];
      }
      if (!_isArray(expanded)) {
        expanded = [expanded];
      }
      return expanded;
    };
    jsonld2.flatten = async function(input, ctx, options) {
      if (arguments.length < 1) {
        return new TypeError("Could not flatten, too few arguments.");
      }
      if (typeof ctx === "function") {
        ctx = null;
      } else {
        ctx = ctx || null;
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : "",
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      const expanded = await jsonld2.expand(input, options);
      const flattened = _flatten(expanded);
      if (ctx === null) {
        return flattened;
      }
      options.graph = true;
      options.skipExpansion = true;
      const compacted = await jsonld2.compact(flattened, ctx, options);
      return compacted;
    };
    jsonld2.frame = async function(input, frame2, options) {
      if (arguments.length < 2) {
        throw new TypeError("Could not frame, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : "",
        embed: "@once",
        explicit: false,
        requireAll: false,
        omitDefault: false,
        bnodesToClear: [],
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      if (_isString(frame2)) {
        const remoteDoc = await jsonld2.get(frame2, options);
        frame2 = remoteDoc.document;
        if (remoteDoc.contextUrl) {
          let ctx = frame2["@context"];
          if (!ctx) {
            ctx = remoteDoc.contextUrl;
          } else if (_isArray(ctx)) {
            ctx.push(remoteDoc.contextUrl);
          } else {
            ctx = [ctx, remoteDoc.contextUrl];
          }
          frame2["@context"] = ctx;
        }
      }
      const frameContext = frame2 ? frame2["@context"] || {} : {};
      const activeCtx = await jsonld2.processContext(
        _getInitialContext(options),
        frameContext,
        options
      );
      if (!options.hasOwnProperty("omitGraph")) {
        options.omitGraph = _processingMode(activeCtx, 1.1);
      }
      if (!options.hasOwnProperty("pruneBlankNodeIdentifiers")) {
        options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
      }
      const expanded = await jsonld2.expand(input, options);
      const opts = { ...options };
      opts.isFrame = true;
      opts.keepFreeFloatingNodes = true;
      const expandedFrame = await jsonld2.expand(frame2, opts);
      const frameKeys = Object.keys(frame2).map((key) => _expandIri(activeCtx, key, { vocab: true }));
      opts.merged = !frameKeys.includes("@graph");
      opts.is11 = _processingMode(activeCtx, 1.1);
      const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
      opts.graph = !options.omitGraph;
      opts.skipExpansion = true;
      opts.link = {};
      opts.framing = true;
      let compacted = await jsonld2.compact(framed, frameContext, opts);
      opts.link = {};
      compacted = _cleanupNull(compacted, opts);
      return compacted;
    };
    jsonld2.link = async function(input, ctx, options) {
      const frame2 = {};
      if (ctx) {
        frame2["@context"] = ctx;
      }
      frame2["@embed"] = "@link";
      return jsonld2.frame(input, frame2, options);
    };
    jsonld2.normalize = jsonld2.canonize = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not canonize, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : null,
        algorithm: "URDNA2015",
        skipExpansion: false,
        safe: true,
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      if ("inputFormat" in options) {
        if (options.inputFormat !== "application/n-quads" && options.inputFormat !== "application/nquads") {
          throw new JsonLdError2(
            "Unknown canonicalization input format.",
            "jsonld.CanonizeError"
          );
        }
        const parsedInput = NQuads2.parse(input);
        return canonize.canonize(parsedInput, options);
      }
      const opts = { ...options };
      delete opts.format;
      opts.produceGeneralizedRdf = false;
      const dataset = await jsonld2.toRDF(input, opts);
      return canonize.canonize(dataset, options);
    };
    jsonld2.fromRDF = async function(dataset, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not convert from RDF, too few arguments.");
      }
      options = _setDefaults(options, {
        format: _isString(dataset) ? "application/n-quads" : void 0
      });
      const { format: format2 } = options;
      let { rdfParser } = options;
      if (format2) {
        rdfParser = rdfParser || _rdfParsers[format2];
        if (!rdfParser) {
          throw new JsonLdError2(
            "Unknown input format.",
            "jsonld.UnknownFormat",
            { format: format2 }
          );
        }
      } else {
        rdfParser = () => dataset;
      }
      const parsedDataset = await rdfParser(dataset);
      return _fromRDF(parsedDataset, options);
    };
    jsonld2.toRDF = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not convert to RDF, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : "",
        skipExpansion: false,
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      let expanded;
      if (options.skipExpansion) {
        expanded = input;
      } else {
        expanded = await jsonld2.expand(input, options);
      }
      const dataset = _toRDF(expanded, options);
      if (options.format) {
        if (options.format === "application/n-quads" || options.format === "application/nquads") {
          return NQuads2.serialize(dataset);
        }
        throw new JsonLdError2(
          "Unknown output format.",
          "jsonld.UnknownFormat",
          { format: options.format }
        );
      }
      return dataset;
    };
    jsonld2.createNodeMap = async function(input, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not create node map, too few arguments.");
      }
      options = _setDefaults(options, {
        base: _isString(input) ? input : "",
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      const expanded = await jsonld2.expand(input, options);
      return _createMergedNodeMap(expanded, options);
    };
    jsonld2.merge = async function(docs, ctx, options) {
      if (arguments.length < 1) {
        throw new TypeError("Could not merge, too few arguments.");
      }
      if (!_isArray(docs)) {
        throw new TypeError('Could not merge, "docs" must be an array.');
      }
      if (typeof ctx === "function") {
        ctx = null;
      } else {
        ctx = ctx || null;
      }
      options = _setDefaults(options, {
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      const expanded = await Promise.all(docs.map((doc2) => {
        const opts = { ...options };
        return jsonld2.expand(doc2, opts);
      }));
      let mergeNodes = true;
      if ("mergeNodes" in options) {
        mergeNodes = options.mergeNodes;
      }
      const issuer = options.issuer || new IdentifierIssuer2("_:b");
      const graphs = { "@default": {} };
      for (let i4 = 0; i4 < expanded.length; ++i4) {
        const doc2 = util$1.relabelBlankNodes(expanded[i4], {
          issuer: new IdentifierIssuer2("_:b" + i4 + "-")
        });
        const _graphs = mergeNodes || i4 === 0 ? graphs : { "@default": {} };
        _createNodeMap(doc2, _graphs, "@default", issuer);
        if (_graphs !== graphs) {
          for (const graphName in _graphs) {
            const _nodeMap = _graphs[graphName];
            if (!(graphName in graphs)) {
              graphs[graphName] = _nodeMap;
              continue;
            }
            const nodeMap2 = graphs[graphName];
            for (const key in _nodeMap) {
              if (!(key in nodeMap2)) {
                nodeMap2[key] = _nodeMap[key];
              }
            }
          }
        }
      }
      const defaultGraph = _mergeNodeMaps(graphs);
      const flattened = [];
      const keys = Object.keys(defaultGraph).sort();
      for (let ki2 = 0; ki2 < keys.length; ++ki2) {
        const node = defaultGraph[keys[ki2]];
        if (!_isSubjectReference(node)) {
          flattened.push(node);
        }
      }
      if (ctx === null) {
        return flattened;
      }
      options.graph = true;
      options.skipExpansion = true;
      const compacted = await jsonld2.compact(flattened, ctx, options);
      return compacted;
    };
    Object.defineProperty(jsonld2, "documentLoader", {
      get: () => jsonld2._documentLoader,
      set: (v6) => jsonld2._documentLoader = v6
    });
    jsonld2.documentLoader = async (url2) => {
      throw new JsonLdError2(
        "Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.",
        "jsonld.LoadDocumentError",
        { code: "loading document failed", url: url2 }
      );
    };
    jsonld2.get = async function(url2, options) {
      let load;
      if (typeof options.documentLoader === "function") {
        load = options.documentLoader;
      } else {
        load = jsonld2.documentLoader;
      }
      const remoteDoc = await load(url2);
      try {
        if (!remoteDoc.document) {
          throw new JsonLdError2(
            "No remote document found at the given URL.",
            "jsonld.NullRemoteDocument"
          );
        }
        if (_isString(remoteDoc.document)) {
          remoteDoc.document = JSON.parse(remoteDoc.document);
        }
      } catch (e7) {
        throw new JsonLdError2(
          "Could not retrieve a JSON-LD document from the URL.",
          "jsonld.LoadDocumentError",
          {
            code: "loading document failed",
            cause: e7,
            remoteDoc
          }
        );
      }
      return remoteDoc;
    };
    jsonld2.processContext = async function(activeCtx, localCtx, options) {
      options = _setDefaults(options, {
        base: "",
        contextResolver: new ContextResolver2(
          { sharedCache: _resolvedContextCache }
        )
      });
      if (localCtx === null) {
        return _getInitialContext(options);
      }
      localCtx = util$1.clone(localCtx);
      if (!(_isObject(localCtx) && "@context" in localCtx)) {
        localCtx = { "@context": localCtx };
      }
      return _processContext({ activeCtx, localCtx, options });
    };
    jsonld2.getContextValue = context.getContextValue;
    jsonld2.documentLoaders = {};
    jsonld2.useDocumentLoader = function(type2) {
      if (!(type2 in jsonld2.documentLoaders)) {
        throw new JsonLdError2(
          'Unknown document loader type: "' + type2 + '"',
          "jsonld.UnknownDocumentLoader",
          { type: type2 }
        );
      }
      jsonld2.documentLoader = jsonld2.documentLoaders[type2].apply(
        jsonld2,
        Array.prototype.slice.call(arguments, 1)
      );
    };
    jsonld2.registerRDFParser = function(contentType, parser) {
      _rdfParsers[contentType] = parser;
    };
    jsonld2.unregisterRDFParser = function(contentType) {
      delete _rdfParsers[contentType];
    };
    jsonld2.registerRDFParser("application/n-quads", NQuads2.parse);
    jsonld2.registerRDFParser("application/nquads", NQuads2.parse);
    jsonld2.url = url$1;
    jsonld2.logEventHandler = _logEventHandler;
    jsonld2.logWarningEventHandler = _logWarningEventHandler;
    jsonld2.safeEventHandler = _safeEventHandler;
    jsonld2.setDefaultEventHandler = _setDefaultEventHandler;
    jsonld2.strictEventHandler = _strictEventHandler;
    jsonld2.unhandledEventHandler = _unhandledEventHandler;
    jsonld2.util = util$1;
    Object.assign(jsonld2, util$1);
    jsonld2.promises = jsonld2;
    jsonld2.RequestQueue = requireRequestQueue();
    jsonld2.JsonLdProcessor = requireJsonLdProcessor()(jsonld2);
    platform.setupGlobals(jsonld2);
    platform.setupDocumentLoaders(jsonld2);
    function _setDefaults(options, {
      documentLoader = jsonld2.documentLoader,
      ...defaults2
    }) {
      if (options && "compactionMap" in options) {
        throw new JsonLdError2(
          '"compactionMap" not supported.',
          "jsonld.OptionsError"
        );
      }
      if (options && "expansionMap" in options) {
        throw new JsonLdError2(
          '"expansionMap" not supported.',
          "jsonld.OptionsError"
        );
      }
      return Object.assign(
        {},
        { documentLoader },
        defaults2,
        options,
        { eventHandler: _setupEventHandler({ options }) }
      );
    }
    return jsonld2;
  };
  var factory = function() {
    return wrapper(function() {
      return factory();
    });
  };
  wrapper(factory);
  var jsonld = factory;
  var credentialSubjectKey$1 = "credentialSubject";
  var contextFullKey = "@context";
  var serializationFullKey = "iden3_serialization";
  var fieldPrefix = "iden3:v1:";
  var credentialSubjectFullKey = "https://www.w3.org/2018/credentials#credentialSubject";
  var verifiableCredentialFullKey = "https://www.w3.org/2018/credentials#VerifiableCredential";
  var typeFullKey = "@type";
  var fillCoreClaimSlot = async (slotData, mz, path) => {
    if (!path) {
      return;
    }
    path = credentialSubjectKey$1 + "." + path;
    try {
      const p6 = await mz.resolveDocPath(path, mz.options);
      const entry = await mz.entry(p6);
      const intVal = await entry.getValueMtEntry();
      const bytesVal = R2.intToBytes(intVal);
      slotData.set(bytesVal, 0);
    } catch (err) {
      if (err.toString().includes("entry not found")) {
        throw new Error(`field not found in credential ${path}`);
      }
      throw err;
    }
  };
  var getSerializationAttrFromParsedContext = async (ldCtx, tp) => {
    const termDef = ldCtx.mappings;
    if (!termDef) {
      throw new Error("terms definitions is not of correct type");
    }
    const term = termDef.get(tp) ?? [...termDef.values()].find((value) => value["@id"] === tp);
    if (!term) {
      return "";
    }
    const termCtx = term[contextFullKey];
    if (!termCtx) {
      throw new Error("type @context is not of correct type");
    }
    const serStr = termCtx[serializationFullKey] ?? "";
    return serStr;
  };
  var parseSerializationAttr = (serAttr) => {
    if (!serAttr.startsWith(fieldPrefix)) {
      throw new Error("serialization attribute does not have correct prefix");
    }
    const parts = serAttr.slice(fieldPrefix.length).split("&");
    if (parts.length > 4) {
      throw new Error("serialization attribute has too many parts");
    }
    const paths = {};
    for (const part of parts) {
      const kv = part.split("=");
      if (kv.length !== 2) {
        throw new Error("serialization attribute part does not have correct format");
      }
      switch (kv[0]) {
        case "slotIndexA":
          paths.indexAPath = kv[1];
          break;
        case "slotIndexB":
          paths.indexBPath = kv[1];
          break;
        case "slotValueA":
          paths.valueAPath = kv[1];
          break;
        case "slotValueB":
          paths.valueBPath = kv[1];
          break;
        default:
          throw new Error("unknown serialization attribute slot");
      }
    }
    return paths;
  };
  var findCredentialType = (mz) => {
    const opts = mz.options;
    try {
      const path1 = new lf([credentialSubjectFullKey, typeFullKey], opts.hasher);
      const e7 = mz.rawValue(path1);
      return e7;
    } catch (err) {
      const path2 = new lf([typeFullKey], opts.hasher);
      const topLevelTypes = mz.rawValue(path2);
      if (!Array.isArray(topLevelTypes)) {
        throw new Error("top level @type expected to be an array");
      }
      if (topLevelTypes.length !== 2) {
        throw new Error("top level @type expected to be of length 2");
      }
      switch (verifiableCredentialFullKey) {
        case topLevelTypes[0]:
          return topLevelTypes[1];
        case topLevelTypes[1]:
          return topLevelTypes[0];
        default:
          throw new Error("@type(s) are expected to contain VerifiableCredential type");
      }
    }
  };
  var parseCoreClaimSlots = async (ldCtx, mz, credentialType) => {
    const slots = {
      indexA: new Uint8Array(32),
      indexB: new Uint8Array(32),
      valueA: new Uint8Array(32),
      valueB: new Uint8Array(32)
    };
    const serAttr = await getSerializationAttrFromParsedContext(ldCtx, credentialType);
    if (!serAttr) {
      return { slots, nonMerklized: false };
    }
    const sPaths = parseSerializationAttr(serAttr);
    const isSPathEmpty = !Object.values(sPaths).some(Boolean);
    if (isSPathEmpty) {
      return { slots, nonMerklized: true };
    }
    await fillCoreClaimSlot(slots.indexA, mz, sPaths.indexAPath);
    await fillCoreClaimSlot(slots.indexB, mz, sPaths.indexBPath);
    await fillCoreClaimSlot(slots.valueA, mz, sPaths.valueAPath);
    await fillCoreClaimSlot(slots.valueB, mz, sPaths.valueBPath);
    return { slots, nonMerklized: true };
  };
  var calculateCoreSchemaHash = (schemaId) => {
    const sHash = b.decodeString(sha3Exports.keccak256(schemaId));
    return new k2(sHash.slice(sHash.length - 16, sHash.length));
  };
  var W3CCredential = class {
    constructor() {
      this.id = "";
      this["@context"] = [];
      this.type = [];
      this.credentialSubject = {};
      this.issuer = "";
    }
    static fromCredentialRequest(issuer, request) {
      if (!request.id) {
        throw new Error("Credential id is required");
      }
      if (!request.context) {
        throw new Error("Credential context is required");
      }
      const context2 = [
        VerifiableConstants.JSONLD_SCHEMA.W3C_CREDENTIAL_2018,
        VerifiableConstants.JSONLD_SCHEMA.IDEN3_CREDENTIAL,
        ...request.context
      ];
      const credentialType = [
        VerifiableConstants.CREDENTIAL_TYPE.W3C_VERIFIABLE_CREDENTIAL,
        request.type
      ];
      const credentialSubject = request.credentialSubject;
      credentialSubject["type"] = request.type;
      const cr2 = new W3CCredential();
      cr2.id = request.id;
      cr2["@context"] = context2;
      cr2.type = credentialType;
      cr2.credentialSubject = credentialSubject;
      cr2.issuer = issuer.string();
      cr2.credentialSchema = {
        id: request.credentialSchema,
        type: VerifiableConstants.JSON_SCHEMA_VALIDATOR
      };
      cr2.credentialStatus = W3CCredential.buildCredentialStatus(request, issuer);
      request.expiration && (cr2.expirationDate = new Date(request.expiration).toISOString());
      request.refreshService && (cr2.refreshService = request.refreshService);
      request.displayMethod && (cr2.displayMethod = request.displayMethod);
      request.issuanceDate && (cr2.issuanceDate = new Date(request.issuanceDate).toISOString());
      return cr2;
    }
    static buildCredentialStatus(request, issuer) {
      const credentialStatus = {
        id: request.revocationOpts.id,
        type: request.revocationOpts.type,
        revocationNonce: request.revocationOpts.nonce
      };
      switch (request.revocationOpts.type) {
        case CredentialStatusType.SparseMerkleTreeProof:
          return {
            ...credentialStatus,
            id: `${credentialStatus.id.replace(/\/$/, "")}/${credentialStatus.revocationNonce}`
          };
        case CredentialStatusType.Iden3ReverseSparseMerkleTreeProof:
          return {
            ...credentialStatus,
            id: request.revocationOpts.issuerState ? `${credentialStatus.id.replace(/\/$/, "")}/node?state=${request.revocationOpts.issuerState}` : `${credentialStatus.id.replace(/\/$/, "")}`
          };
        case CredentialStatusType.Iden3OnchainSparseMerkleTreeProof2023: {
          const issuerId = Q2.idFromDID(issuer);
          const chainId = et(Q2.blockchainFromId(issuerId), Q2.networkIdFromId(issuerId));
          const searchParams = [
            ["revocationNonce", request.revocationOpts.nonce?.toString() || ""],
            ["contractAddress", `${chainId}:${request.revocationOpts.id}`],
            ["state", request.revocationOpts.issuerState || ""]
          ].filter(([, value]) => Boolean(value)).map(([key, value]) => `${key}=${value}`).join("&");
          return {
            ...credentialStatus,
            id: `${issuer.string()}/credentialStatus?${searchParams}`
          };
        }
        default:
          return credentialStatus;
      }
    }
    toJSON() {
      return {
        ...this,
        proof: Array.isArray(this.proof) ? this.proof.map(this.proofToJSON) : this.proofToJSON(this.proof)
      };
    }
    proofToJSON(p6) {
      if (!p6) {
        return p6;
      }
      if (!p6["type"]) {
        throw new Error("proof must have type property");
      }
      switch (p6.type) {
        case ProofType.Iden3SparseMerkleTreeProof:
        case ProofType.BJJSignature:
          return p6.toJSON();
        default:
          return p6;
      }
    }
    static fromJSON(obj) {
      const w5 = new W3CCredential();
      Object.assign(w5, structuredClone(obj));
      w5.proof = Array.isArray(w5.proof) ? w5.proof.map(W3CCredential.proofFromJSON) : W3CCredential.proofFromJSON(w5.proof);
      return w5;
    }
    async merklize(opts) {
      const credential = { ...this };
      delete credential.proof;
      return await ff.merklizeJSONLD(JSON.stringify(credential), opts);
    }
    getCoreClaimFromProof(proofType) {
      if (Array.isArray(this.proof)) {
        for (const proof of this.proof) {
          const { claim, proofType: extractedProofType } = extractProof(proof);
          if (proofType === extractedProofType) {
            return claim;
          }
        }
      } else if (typeof this.proof === "object") {
        const { claim, proofType: extractedProofType } = extractProof(this.proof);
        if (extractedProofType == proofType) {
          return claim;
        }
      }
      return void 0;
    }
    async toCoreClaim(opts) {
      if (!opts) {
        opts = {
          revNonce: 0,
          version: 0,
          subjectPosition: SubjectPosition.Index,
          merklizedRootPosition: MerklizedRootPosition.None,
          updatable: false,
          merklizeOpts: {}
        };
      }
      const mz = await this.merklize(opts.merklizeOpts);
      const credentialType = findCredentialType(mz);
      const subjectId = this.credentialSubject["id"];
      const ldCtx = await jsonld.processContext(context.getInitialContext({}), this["@context"], mz.options);
      const { slots, nonMerklized } = await parseCoreClaimSlots(ldCtx, mz, credentialType);
      if (nonMerklized && opts.merklizedRootPosition !== MerklizedRootPosition.None) {
        throw new Error("merklized root position is not supported for non-merklized claims");
      }
      if (!nonMerklized && opts.merklizedRootPosition === MerklizedRootPosition.None) {
        opts.merklizedRootPosition = MerklizedRootPosition.Index;
      }
      const schemaHash = calculateCoreSchemaHash(byteEncoder.encode(credentialType));
      const claim = P2.newClaim(schemaHash, C.withIndexDataBytes(slots.indexA, slots.indexB), C.withValueDataBytes(slots.valueA, slots.valueB), C.withRevocationNonce(BigInt(opts.revNonce)), C.withVersion(opts.version));
      if (opts.updatable) {
        claim.setFlagUpdatable(opts.updatable);
      }
      if (this.expirationDate) {
        claim.setExpirationDate(new Date(this.expirationDate));
      }
      if (subjectId) {
        const did = Q2.parse(subjectId.toString());
        const id3 = Q2.idFromDID(did);
        switch (opts.subjectPosition) {
          case "":
          case SubjectPosition.Index:
            claim.setIndexId(id3);
            break;
          case SubjectPosition.Value:
            claim.setValueId(id3);
            break;
          default:
            throw new Error("unknown subject position");
        }
      }
      switch (opts.merklizedRootPosition) {
        case MerklizedRootPosition.Index: {
          const mk = await this.merklize(opts.merklizeOpts);
          claim.setIndexMerklizedRoot((await mk.root()).bigInt());
          break;
        }
        case MerklizedRootPosition.Value: {
          const mk = await this.merklize(opts.merklizeOpts);
          claim.setValueMerklizedRoot((await mk.root()).bigInt());
          break;
        }
        case MerklizedRootPosition.None:
          break;
        default:
          throw new Error("unknown merklized root position");
      }
      return claim;
    }
    getBJJSignature2021Proof() {
      const proof = this.getProofByType(ProofType.BJJSignature);
      if (proof) {
        return proof;
      }
      return void 0;
    }
    getIden3SparseMerkleTreeProof() {
      const proof = this.getProofByType(ProofType.Iden3SparseMerkleTreeProof);
      if (proof) {
        return proof;
      }
      return void 0;
    }
    async verifyProof(proofType, resolverURL, opts) {
      const proof = this.getProofByType(proofType);
      if (!proof) {
        throw new Error("proof not found");
      }
      const coreClaim = this.getCoreClaimFromProof(proofType);
      if (!coreClaim) {
        throw new Error(`can't get core claim`);
      }
      await this.verifyCoreClaimMatch(coreClaim, opts?.merklizeOptions);
      switch (proofType) {
        case ProofType.BJJSignature: {
          if (!opts?.credStatusResolverRegistry) {
            throw new Error("please provide credential status resolver registry");
          }
          const bjjProof = proof;
          const userDID = getUserDIDFromCredential(bjjProof.issuerData.id, this);
          return this.verifyBJJSignatureProof(bjjProof, coreClaim, resolverURL, userDID, opts.credStatusResolverRegistry);
        }
        case ProofType.Iden3SparseMerkleTreeProof: {
          return this.verifyIden3SparseMerkleTreeProof(proof, coreClaim, resolverURL);
        }
        default: {
          throw new Error("invalid proof type");
        }
      }
    }
    async verifyCoreClaimMatch(coreClaim, merklizeOpts) {
      let merklizedRootPosition = "";
      const merklizedPosition = coreClaim.getMerklizedPosition();
      switch (merklizedPosition) {
        case V2.None:
          merklizedRootPosition = MerklizedRootPosition.None;
          break;
        case V2.Index:
          merklizedRootPosition = MerklizedRootPosition.Index;
          break;
        case V2.Value:
          merklizedRootPosition = MerklizedRootPosition.Value;
          break;
      }
      let subjectPosition = "";
      const idPosition = coreClaim.getIdPosition();
      switch (idPosition) {
        case U3.None:
          subjectPosition = SubjectPosition.None;
          break;
        case U3.Index:
          subjectPosition = SubjectPosition.Index;
          break;
        case U3.Value:
          subjectPosition = SubjectPosition.Value;
          break;
      }
      const coreClaimOpts = {
        revNonce: Number(coreClaim.getRevocationNonce()),
        version: coreClaim.getVersion(),
        merklizedRootPosition,
        subjectPosition,
        updatable: coreClaim.getFlagUpdatable(),
        merklizeOpts
      };
      const credentialCoreClaim = await this.toCoreClaim(coreClaimOpts);
      if (coreClaim.hex() != credentialCoreClaim.hex()) {
        throw new Error("proof generated for another credential");
      }
    }
    async verifyBJJSignatureProof(proof, coreClaim, resolverURL, userDID, credStatusResolverRegistry) {
      const authClaim = proof.issuerData.authCoreClaim;
      const rawSlotsInt = authClaim.rawSlotsAsInts();
      const pubKey = new AI([rawSlotsInt[2], rawSlotsInt[3]]);
      const { hi: hi2, hv } = coreClaim.hiHv();
      const claimHash = $.hash([hi2, hv]);
      const bjjValid = pubKey.verifyPoseidon(claimHash, proof.signature);
      if (!bjjValid) {
        throw new Error("signature is not valid");
      }
      await validateDIDDocumentAuth(proof.issuerData.id, resolverURL, proof.issuerData.state.value);
      const credStatusType = proof.issuerData.credentialStatus.type;
      const credStatusResolver = await credStatusResolverRegistry.get(credStatusType);
      if (!credStatusResolver) {
        throw new Error(`please register credential status resolver for ${credStatusType} type`);
      }
      const credStatus = await credStatusResolver.resolve(proof.issuerData.credentialStatus, {
        issuerDID: proof.issuerData.id,
        userDID
      });
      const stateValid = validateTreeState(credStatus.issuer);
      if (!stateValid) {
        throw new Error("signature proof: invalid tree state of the issuer while checking credential status of singing key");
      }
      const revocationNonce = BigInt(proof.issuerData.credentialStatus.revocationNonce || 0);
      if (revocationNonce !== proof.issuerData.authCoreClaim.getRevocationNonce()) {
        throw new Error(`revocation nonce mismatch: revocation nonce from core representation of auth credential is not the same as in its credential`);
      }
      const proofValid = await Mt(V3.fromHex(credStatus.issuer.revocationTreeRoot), credStatus.mtp, revocationNonce, BigInt(0));
      if (!proofValid) {
        throw new Error(`proof validation failed. revNonce=${revocationNonce}`);
      }
      if (credStatus.mtp.existence) {
        throw new Error("signature proof: singing key of the issuer is revoked");
      }
      return true;
    }
    async verifyIden3SparseMerkleTreeProof(proof, coreClaim, resolverURL) {
      await validateDIDDocumentAuth(proof.issuerData.id, resolverURL, proof.issuerData.state.value);
      const { hi: hi2, hv } = coreClaim.hiHv();
      const rootFromProofValue = await Wt(proof.mtp, hi2, hv);
      if (!rootFromProofValue.equals(proof.issuerData.state.claimsTreeRoot)) {
        throw new Error("verifyIden3SparseMerkleTreeProof: root from proof not equal to issuer data claims tree root");
      }
      return true;
    }
    getProofByType(proofType) {
      if (Array.isArray(this.proof)) {
        for (const proof of this.proof) {
          if (proof?.type === proofType) {
            return proof;
          }
        }
      } else if (this.proof?.type == proofType) {
        return this.proof;
      }
      return void 0;
    }
  };
  W3CCredential.proofFromJSON = (p6) => {
    if (!p6) {
      return p6;
    }
    if (!p6["type"]) {
      throw new Error("proof must have type property");
    }
    switch (p6.type) {
      case ProofType.Iden3SparseMerkleTreeProof:
        return Iden3SparseMerkleTreeProof.fromJSON(p6);
      case ProofType.BJJSignature:
        return BJJSignatureProof2021.fromJSON(p6);
      default:
        return p6;
    }
  };
  function extractProof(proof) {
    if (proof instanceof Iden3SparseMerkleTreeProof) {
      return {
        claim: proof.coreClaim,
        proofType: ProofType.Iden3SparseMerkleTreeProof
      };
    }
    if (proof instanceof BJJSignatureProof2021) {
      return { claim: proof.coreClaim, proofType: ProofType.BJJSignature };
    }
    if (typeof proof === "object") {
      const p6 = proof;
      const defaultProofType = p6.type;
      if (!defaultProofType) {
        throw new Error("proof type is not specified");
      }
      if (!p6.coreClaim) {
        throw new Error(`coreClaim field is not defined in proof type ${defaultProofType}`);
      }
      const coreClaim = p6.coreClaim instanceof P2 ? p6.coreClaim : new P2().fromHex(p6.coreClaim);
      return { claim: coreClaim, proofType: defaultProofType };
    }
    throw new Error("proof format is not supported");
  }
  function validateTreeState(treeState) {
    const ctrHash = treeState.claimsTreeRoot ? V3.fromHex(treeState.claimsTreeRoot) : new V3();
    const rtrHash = treeState.revocationTreeRoot ? V3.fromHex(treeState.revocationTreeRoot) : new V3();
    const rorHash = treeState.rootOfRoots ? V3.fromHex(treeState.rootOfRoots) : new V3();
    const wantState = $.hash([ctrHash.bigInt(), rtrHash.bigInt(), rorHash.bigInt()]);
    const stateHash = treeState.state ? V3.fromHex(treeState.state) : new V3();
    return wantState === stateHash.bigInt();
  }
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate$1(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (let i4 = 0; i4 < 256; ++i4) {
    byteToHex.push((i4 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
  }
  function parse(uuid) {
    if (!validate$1(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v6;
    const arr = new Uint8Array(16);
    arr[0] = (v6 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v6 >>> 16 & 255;
    arr[2] = v6 >>> 8 & 255;
    arr[3] = v6 & 255;
    arr[4] = (v6 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v6 & 255;
    arr[6] = (v6 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v6 & 255;
    arr[8] = (v6 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v6 & 255;
    arr[10] = (v6 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v6 / 4294967296 & 255;
    arr[12] = v6 >>> 24 & 255;
    arr[13] = v6 >>> 16 & 255;
    arr[14] = v6 >>> 8 & 255;
    arr[15] = v6 & 255;
    return arr;
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes2 = [];
    for (let i4 = 0; i4 < str.length; ++i4) {
      bytes2.push(str.charCodeAt(i4));
    }
    return bytes2;
  }
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      var _namespace;
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = parse(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes2 = new Uint8Array(16 + value.length);
      bytes2.set(namespace);
      bytes2.set(value, namespace.length);
      bytes2 = hashfunc(bytes2);
      bytes2[6] = bytes2[6] & 15 | version2;
      bytes2[8] = bytes2[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i4 = 0; i4 < 16; ++i4) {
          buf[offset + i4] = bytes2[i4];
        }
        return buf;
      }
      return unsafeStringify(bytes2);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL$1;
    return generateUUID;
  }
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native = {
    randomUUID
  };
  function v42(options, buf, offset) {
    if (native.randomUUID && !buf && !options) {
      return native.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return unsafeStringify(rnds);
  }
  function f4(s3, x6, y5, z6) {
    switch (s3) {
      case 0:
        return x6 & y5 ^ ~x6 & z6;
      case 1:
        return x6 ^ y5 ^ z6;
      case 2:
        return x6 & y5 ^ x6 & z6 ^ y5 & z6;
      case 3:
        return x6 ^ y5 ^ z6;
    }
  }
  function ROTL(x6, n4) {
    return x6 << n4 | x6 >>> 32 - n4;
  }
  function sha1(bytes2) {
    const K4 = [1518500249, 1859775393, 2400959708, 3395469782];
    const H4 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof bytes2 === "string") {
      const msg = unescape(encodeURIComponent(bytes2));
      bytes2 = [];
      for (let i4 = 0; i4 < msg.length; ++i4) {
        bytes2.push(msg.charCodeAt(i4));
      }
    } else if (!Array.isArray(bytes2)) {
      bytes2 = Array.prototype.slice.call(bytes2);
    }
    bytes2.push(128);
    const l6 = bytes2.length / 4 + 2;
    const N10 = Math.ceil(l6 / 16);
    const M6 = new Array(N10);
    for (let i4 = 0; i4 < N10; ++i4) {
      const arr = new Uint32Array(16);
      for (let j5 = 0; j5 < 16; ++j5) {
        arr[j5] = bytes2[i4 * 64 + j5 * 4] << 24 | bytes2[i4 * 64 + j5 * 4 + 1] << 16 | bytes2[i4 * 64 + j5 * 4 + 2] << 8 | bytes2[i4 * 64 + j5 * 4 + 3];
      }
      M6[i4] = arr;
    }
    M6[N10 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
    M6[N10 - 1][14] = Math.floor(M6[N10 - 1][14]);
    M6[N10 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
    for (let i4 = 0; i4 < N10; ++i4) {
      const W5 = new Uint32Array(80);
      for (let t = 0; t < 16; ++t) {
        W5[t] = M6[i4][t];
      }
      for (let t = 16; t < 80; ++t) {
        W5[t] = ROTL(W5[t - 3] ^ W5[t - 8] ^ W5[t - 14] ^ W5[t - 16], 1);
      }
      let a4 = H4[0];
      let b7 = H4[1];
      let c3 = H4[2];
      let d5 = H4[3];
      let e7 = H4[4];
      for (let t = 0; t < 80; ++t) {
        const s3 = Math.floor(t / 20);
        const T6 = ROTL(a4, 5) + f4(s3, b7, c3, d5) + e7 + K4[s3] + W5[t] >>> 0;
        e7 = d5;
        d5 = c3;
        c3 = ROTL(b7, 30) >>> 0;
        b7 = a4;
        a4 = T6;
      }
      H4[0] = H4[0] + a4 >>> 0;
      H4[1] = H4[1] + b7 >>> 0;
      H4[2] = H4[2] + c3 >>> 0;
      H4[3] = H4[3] + d5 >>> 0;
      H4[4] = H4[4] + e7 >>> 0;
    }
    return [H4[0] >> 24 & 255, H4[0] >> 16 & 255, H4[0] >> 8 & 255, H4[0] & 255, H4[1] >> 24 & 255, H4[1] >> 16 & 255, H4[1] >> 8 & 255, H4[1] & 255, H4[2] >> 24 & 255, H4[2] >> 16 & 255, H4[2] >> 8 & 255, H4[2] & 255, H4[3] >> 24 & 255, H4[3] >> 16 & 255, H4[3] >> 8 & 255, H4[3] & 255, H4[4] >> 24 & 255, H4[4] >> 16 & 255, H4[4] >> 8 & 255, H4[4] & 255];
  }
  var v52 = v35("v5", 80, sha1);
  var ajv = { exports: {} };
  var core$4 = {};
  var validate = {};
  var boolSchema = {};
  var errors = {};
  var codegen = {};
  var code$1 = {};
  var hasRequiredCode$1;
  function requireCode$1() {
    if (hasRequiredCode$1)
      return code$1;
    hasRequiredCode$1 = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
      class _CodeOrName {
      }
      exports._CodeOrName = _CodeOrName;
      exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class Name extends _CodeOrName {
        constructor(s3) {
          super();
          if (!exports.IDENTIFIER.test(s3))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = s3;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return false;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      exports.Name = Name;
      class _Code extends _CodeOrName {
        constructor(code2) {
          super();
          this._items = typeof code2 === "string" ? [code2] : code2;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return false;
          const item = this._items[0];
          return item === "" || item === '""';
        }
        get str() {
          var _a2;
          return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s3, c3) => `${s3}${c3}`, "");
        }
        get names() {
          var _a2;
          return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c3) => {
            if (c3 instanceof Name)
              names[c3.str] = (names[c3.str] || 0) + 1;
            return names;
          }, {});
        }
      }
      exports._Code = _Code;
      exports.nil = new _Code("");
      function _5(strs, ...args) {
        const code2 = [strs[0]];
        let i4 = 0;
        while (i4 < args.length) {
          addCodeArg(code2, args[i4]);
          code2.push(strs[++i4]);
        }
        return new _Code(code2);
      }
      exports._ = _5;
      const plus = new _Code("+");
      function str(strs, ...args) {
        const expr = [safeStringify(strs[0])];
        let i4 = 0;
        while (i4 < args.length) {
          expr.push(plus);
          addCodeArg(expr, args[i4]);
          expr.push(plus, safeStringify(strs[++i4]));
        }
        optimize(expr);
        return new _Code(expr);
      }
      exports.str = str;
      function addCodeArg(code2, arg) {
        if (arg instanceof _Code)
          code2.push(...arg._items);
        else if (arg instanceof Name)
          code2.push(arg);
        else
          code2.push(interpolate(arg));
      }
      exports.addCodeArg = addCodeArg;
      function optimize(expr) {
        let i4 = 1;
        while (i4 < expr.length - 1) {
          if (expr[i4] === plus) {
            const res = mergeExprItems(expr[i4 - 1], expr[i4 + 1]);
            if (res !== void 0) {
              expr.splice(i4 - 1, 3, res);
              continue;
            }
            expr[i4++] = "+";
          }
          i4++;
        }
      }
      function mergeExprItems(a4, b7) {
        if (b7 === '""')
          return a4;
        if (a4 === '""')
          return b7;
        if (typeof a4 == "string") {
          if (b7 instanceof Name || a4[a4.length - 1] !== '"')
            return;
          if (typeof b7 != "string")
            return `${a4.slice(0, -1)}${b7}"`;
          if (b7[0] === '"')
            return a4.slice(0, -1) + b7.slice(1);
          return;
        }
        if (typeof b7 == "string" && b7[0] === '"' && !(a4 instanceof Name))
          return `"${a4}${b7.slice(1)}`;
        return;
      }
      function strConcat(c1, c22) {
        return c22.emptyStr() ? c1 : c1.emptyStr() ? c22 : str`${c1}${c22}`;
      }
      exports.strConcat = strConcat;
      function interpolate(x6) {
        return typeof x6 == "number" || typeof x6 == "boolean" || x6 === null ? x6 : safeStringify(Array.isArray(x6) ? x6.join(",") : x6);
      }
      function stringify2(x6) {
        return new _Code(safeStringify(x6));
      }
      exports.stringify = stringify2;
      function safeStringify(x6) {
        return JSON.stringify(x6).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      exports.safeStringify = safeStringify;
      function getProperty(key) {
        return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _5`[${key}]`;
      }
      exports.getProperty = getProperty;
      function getEsmExportName(key) {
        if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
          return new _Code(`${key}`);
        }
        throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
      }
      exports.getEsmExportName = getEsmExportName;
      function regexpCode(rx) {
        return new _Code(rx.toString());
      }
      exports.regexpCode = regexpCode;
    })(code$1);
    return code$1;
  }
  var scope = {};
  var hasRequiredScope;
  function requireScope() {
    if (hasRequiredScope)
      return scope;
    hasRequiredScope = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
      const code_12 = requireCode$1();
      class ValueError extends Error {
        constructor(name) {
          super(`CodeGen: "code" for ${name} not defined`);
          this.value = name.value;
        }
      }
      var UsedValueState;
      (function(UsedValueState2) {
        UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
        UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
      })(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));
      exports.varKinds = {
        const: new code_12.Name("const"),
        let: new code_12.Name("let"),
        var: new code_12.Name("var")
      };
      class Scope {
        constructor({ prefixes, parent } = {}) {
          this._names = {};
          this._prefixes = prefixes;
          this._parent = parent;
        }
        toName(nameOrPrefix) {
          return nameOrPrefix instanceof code_12.Name ? nameOrPrefix : this.name(nameOrPrefix);
        }
        name(prefix) {
          return new code_12.Name(this._newName(prefix));
        }
        _newName(prefix) {
          const ng = this._names[prefix] || this._nameGroup(prefix);
          return `${prefix}${ng.index++}`;
        }
        _nameGroup(prefix) {
          var _a2, _b;
          if (((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
          }
          return this._names[prefix] = { prefix, index: 0 };
        }
      }
      exports.Scope = Scope;
      class ValueScopeName extends code_12.Name {
        constructor(prefix, nameStr) {
          super(nameStr);
          this.prefix = prefix;
        }
        setValue(value, { property, itemIndex }) {
          this.value = value;
          this.scopePath = (0, code_12._)`.${new code_12.Name(property)}[${itemIndex}]`;
        }
      }
      exports.ValueScopeName = ValueScopeName;
      const line = (0, code_12._)`\n`;
      class ValueScope extends Scope {
        constructor(opts) {
          super(opts);
          this._values = {};
          this._scope = opts.scope;
          this.opts = { ...opts, _n: opts.lines ? line : code_12.nil };
        }
        get() {
          return this._scope;
        }
        name(prefix) {
          return new ValueScopeName(prefix, this._newName(prefix));
        }
        value(nameOrPrefix, value) {
          var _a2;
          if (value.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const name = this.toName(nameOrPrefix);
          const { prefix } = name;
          const valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref;
          let vs2 = this._values[prefix];
          if (vs2) {
            const _name = vs2.get(valueKey);
            if (_name)
              return _name;
          } else {
            vs2 = this._values[prefix] = /* @__PURE__ */ new Map();
          }
          vs2.set(valueKey, name);
          const s3 = this._scope[prefix] || (this._scope[prefix] = []);
          const itemIndex = s3.length;
          s3[itemIndex] = value.ref;
          name.setValue(value, { property: prefix, itemIndex });
          return name;
        }
        getValue(prefix, keyOrRef) {
          const vs2 = this._values[prefix];
          if (!vs2)
            return;
          return vs2.get(keyOrRef);
        }
        scopeRefs(scopeName, values = this._values) {
          return this._reduceValues(values, (name) => {
            if (name.scopePath === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return (0, code_12._)`${scopeName}${name.scopePath}`;
          });
        }
        scopeCode(values = this._values, usedValues, getCode) {
          return this._reduceValues(values, (name) => {
            if (name.value === void 0)
              throw new Error(`CodeGen: name "${name}" has no value`);
            return name.value.code;
          }, usedValues, getCode);
        }
        _reduceValues(values, valueCode, usedValues = {}, getCode) {
          let code2 = code_12.nil;
          for (const prefix in values) {
            const vs2 = values[prefix];
            if (!vs2)
              continue;
            const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
            vs2.forEach((name) => {
              if (nameSet.has(name))
                return;
              nameSet.set(name, UsedValueState.Started);
              let c3 = valueCode(name);
              if (c3) {
                const def2 = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                code2 = (0, code_12._)`${code2}${def2} ${name} = ${c3};${this.opts._n}`;
              } else if (c3 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
                code2 = (0, code_12._)`${code2}${c3}${this.opts._n}`;
              } else {
                throw new ValueError(name);
              }
              nameSet.set(name, UsedValueState.Completed);
            });
          }
          return code2;
        }
      }
      exports.ValueScope = ValueScope;
    })(scope);
    return scope;
  }
  var hasRequiredCodegen;
  function requireCodegen() {
    if (hasRequiredCodegen)
      return codegen;
    hasRequiredCodegen = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
      const code_12 = requireCode$1();
      const scope_1 = requireScope();
      var code_2 = requireCode$1();
      Object.defineProperty(exports, "_", { enumerable: true, get: function() {
        return code_2._;
      } });
      Object.defineProperty(exports, "str", { enumerable: true, get: function() {
        return code_2.str;
      } });
      Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
        return code_2.strConcat;
      } });
      Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
        return code_2.nil;
      } });
      Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
        return code_2.getProperty;
      } });
      Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
        return code_2.stringify;
      } });
      Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
        return code_2.regexpCode;
      } });
      Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
        return code_2.Name;
      } });
      var scope_2 = requireScope();
      Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
        return scope_2.Scope;
      } });
      Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
        return scope_2.ValueScope;
      } });
      Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
        return scope_2.ValueScopeName;
      } });
      Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
        return scope_2.varKinds;
      } });
      exports.operators = {
        GT: new code_12._Code(">"),
        GTE: new code_12._Code(">="),
        LT: new code_12._Code("<"),
        LTE: new code_12._Code("<="),
        EQ: new code_12._Code("==="),
        NEQ: new code_12._Code("!=="),
        NOT: new code_12._Code("!"),
        OR: new code_12._Code("||"),
        AND: new code_12._Code("&&"),
        ADD: new code_12._Code("+")
      };
      class Node2 {
        optimizeNodes() {
          return this;
        }
        optimizeNames(_names, _constants) {
          return this;
        }
      }
      class Def extends Node2 {
        constructor(varKind, name, rhs) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.rhs = rhs;
        }
        render({ es5, _n: _n2 }) {
          const varKind = es5 ? scope_1.varKinds.var : this.varKind;
          const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${varKind} ${this.name}${rhs};` + _n2;
        }
        optimizeNames(names, constants) {
          if (!names[this.name.str])
            return;
          if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
          return this;
        }
        get names() {
          return this.rhs instanceof code_12._CodeOrName ? this.rhs.names : {};
        }
      }
      class Assign extends Node2 {
        constructor(lhs, rhs, sideEffects) {
          super();
          this.lhs = lhs;
          this.rhs = rhs;
          this.sideEffects = sideEffects;
        }
        render({ _n: _n2 }) {
          return `${this.lhs} = ${this.rhs};` + _n2;
        }
        optimizeNames(names, constants) {
          if (this.lhs instanceof code_12.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
          this.rhs = optimizeExpr(this.rhs, names, constants);
          return this;
        }
        get names() {
          const names = this.lhs instanceof code_12.Name ? {} : { ...this.lhs.names };
          return addExprNames(names, this.rhs);
        }
      }
      class AssignOp extends Assign {
        constructor(lhs, op, rhs, sideEffects) {
          super(lhs, rhs, sideEffects);
          this.op = op;
        }
        render({ _n: _n2 }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
        }
      }
      class Label extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n: _n2 }) {
          return `${this.label}:` + _n2;
        }
      }
      class Break extends Node2 {
        constructor(label) {
          super();
          this.label = label;
          this.names = {};
        }
        render({ _n: _n2 }) {
          const label = this.label ? ` ${this.label}` : "";
          return `break${label};` + _n2;
        }
      }
      class Throw extends Node2 {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render({ _n: _n2 }) {
          return `throw ${this.error};` + _n2;
        }
        get names() {
          return this.error.names;
        }
      }
      class AnyCode extends Node2 {
        constructor(code2) {
          super();
          this.code = code2;
        }
        render({ _n: _n2 }) {
          return `${this.code};` + _n2;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(names, constants) {
          this.code = optimizeExpr(this.code, names, constants);
          return this;
        }
        get names() {
          return this.code instanceof code_12._CodeOrName ? this.code.names : {};
        }
      }
      class ParentNode extends Node2 {
        constructor(nodes = []) {
          super();
          this.nodes = nodes;
        }
        render(opts) {
          return this.nodes.reduce((code2, n4) => code2 + n4.render(opts), "");
        }
        optimizeNodes() {
          const { nodes } = this;
          let i4 = nodes.length;
          while (i4--) {
            const n4 = nodes[i4].optimizeNodes();
            if (Array.isArray(n4))
              nodes.splice(i4, 1, ...n4);
            else if (n4)
              nodes[i4] = n4;
            else
              nodes.splice(i4, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        optimizeNames(names, constants) {
          const { nodes } = this;
          let i4 = nodes.length;
          while (i4--) {
            const n4 = nodes[i4];
            if (n4.optimizeNames(names, constants))
              continue;
            subtractNames(names, n4.names);
            nodes.splice(i4, 1);
          }
          return nodes.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((names, n4) => addNames(names, n4.names), {});
        }
      }
      class BlockNode extends ParentNode {
        render(opts) {
          return "{" + opts._n + super.render(opts) + "}" + opts._n;
        }
      }
      class Root extends ParentNode {
      }
      class Else extends BlockNode {
      }
      Else.kind = "else";
      class If extends BlockNode {
        constructor(condition, nodes) {
          super(nodes);
          this.condition = condition;
        }
        render(opts) {
          let code2 = `if(${this.condition})` + super.render(opts);
          if (this.else)
            code2 += "else " + this.else.render(opts);
          return code2;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const cond = this.condition;
          if (cond === true)
            return this.nodes;
          let e7 = this.else;
          if (e7) {
            const ns2 = e7.optimizeNodes();
            e7 = this.else = Array.isArray(ns2) ? new Else(ns2) : ns2;
          }
          if (e7) {
            if (cond === false)
              return e7 instanceof If ? e7 : e7.nodes;
            if (this.nodes.length)
              return this;
            return new If(not2(cond), e7 instanceof If ? [e7] : e7.nodes);
          }
          if (cond === false || !this.nodes.length)
            return void 0;
          return this;
        }
        optimizeNames(names, constants) {
          var _a2;
          this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
          if (!(super.optimizeNames(names, constants) || this.else))
            return;
          this.condition = optimizeExpr(this.condition, names, constants);
          return this;
        }
        get names() {
          const names = super.names;
          addExprNames(names, this.condition);
          if (this.else)
            addNames(names, this.else.names);
          return names;
        }
      }
      If.kind = "if";
      class For extends BlockNode {
      }
      For.kind = "for";
      class ForLoop extends For {
        constructor(iteration) {
          super();
          this.iteration = iteration;
        }
        render(opts) {
          return `for(${this.iteration})` + super.render(opts);
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants))
            return;
          this.iteration = optimizeExpr(this.iteration, names, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iteration.names);
        }
      }
      class ForRange extends For {
        constructor(varKind, name, from2, to2) {
          super();
          this.varKind = varKind;
          this.name = name;
          this.from = from2;
          this.to = to2;
        }
        render(opts) {
          const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
          const { name, from: from2, to: to2 } = this;
          return `for(${varKind} ${name}=${from2}; ${name}<${to2}; ${name}++)` + super.render(opts);
        }
        get names() {
          const names = addExprNames(super.names, this.from);
          return addExprNames(names, this.to);
        }
      }
      class ForIter extends For {
        constructor(loop, varKind, name, iterable) {
          super();
          this.loop = loop;
          this.varKind = varKind;
          this.name = name;
          this.iterable = iterable;
        }
        render(opts) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
        }
        optimizeNames(names, constants) {
          if (!super.optimizeNames(names, constants))
            return;
          this.iterable = optimizeExpr(this.iterable, names, constants);
          return this;
        }
        get names() {
          return addNames(super.names, this.iterable.names);
        }
      }
      class Func extends BlockNode {
        constructor(name, args, async) {
          super();
          this.name = name;
          this.args = args;
          this.async = async;
        }
        render(opts) {
          const _async = this.async ? "async " : "";
          return `${_async}function ${this.name}(${this.args})` + super.render(opts);
        }
      }
      Func.kind = "func";
      class Return extends ParentNode {
        render(opts) {
          return "return " + super.render(opts);
        }
      }
      Return.kind = "return";
      class Try extends BlockNode {
        render(opts) {
          let code2 = "try" + super.render(opts);
          if (this.catch)
            code2 += this.catch.render(opts);
          if (this.finally)
            code2 += this.finally.render(opts);
          return code2;
        }
        optimizeNodes() {
          var _a2, _b;
          super.optimizeNodes();
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNodes();
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
          return this;
        }
        optimizeNames(names, constants) {
          var _a2, _b;
          super.optimizeNames(names, constants);
          (_a2 = this.catch) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants);
          (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
          return this;
        }
        get names() {
          const names = super.names;
          if (this.catch)
            addNames(names, this.catch.names);
          if (this.finally)
            addNames(names, this.finally.names);
          return names;
        }
      }
      class Catch extends BlockNode {
        constructor(error2) {
          super();
          this.error = error2;
        }
        render(opts) {
          return `catch(${this.error})` + super.render(opts);
        }
      }
      Catch.kind = "catch";
      class Finally extends BlockNode {
        render(opts) {
          return "finally" + super.render(opts);
        }
      }
      Finally.kind = "finally";
      class CodeGen {
        constructor(extScope, opts = {}) {
          this._values = {};
          this._blockStarts = [];
          this._constants = {};
          this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
          this._extScope = extScope;
          this._scope = new scope_1.Scope({ parent: extScope });
          this._nodes = [new Root()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        name(prefix) {
          return this._scope.name(prefix);
        }
        scopeName(prefix) {
          return this._extScope.name(prefix);
        }
        scopeValue(prefixOrName, value) {
          const name = this._extScope.value(prefixOrName, value);
          const vs2 = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
          vs2.add(name);
          return name;
        }
        getScopeValue(prefix, keyOrRef) {
          return this._extScope.getValue(prefix, keyOrRef);
        }
        scopeRefs(scopeName) {
          return this._extScope.scopeRefs(scopeName, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(varKind, nameOrPrefix, rhs, constant) {
          const name = this._scope.toName(nameOrPrefix);
          if (rhs !== void 0 && constant)
            this._constants[name.str] = rhs;
          this._leafNode(new Def(varKind, name, rhs));
          return name;
        }
        const(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
        }
        let(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
        }
        var(nameOrPrefix, rhs, _constant) {
          return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
        }
        assign(lhs, rhs, sideEffects) {
          return this._leafNode(new Assign(lhs, rhs, sideEffects));
        }
        add(lhs, rhs) {
          return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
        }
        code(c3) {
          if (typeof c3 == "function")
            c3();
          else if (c3 !== code_12.nil)
            this._leafNode(new AnyCode(c3));
          return this;
        }
        object(...keyValues) {
          const code2 = ["{"];
          for (const [key, value] of keyValues) {
            if (code2.length > 1)
              code2.push(",");
            code2.push(key);
            if (key !== value || this.opts.es5) {
              code2.push(":");
              (0, code_12.addCodeArg)(code2, value);
            }
          }
          code2.push("}");
          return new code_12._Code(code2);
        }
        if(condition, thenBody, elseBody) {
          this._blockNode(new If(condition));
          if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
          } else if (thenBody) {
            this.code(thenBody).endIf();
          } else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
          }
          return this;
        }
        elseIf(condition) {
          return this._elseNode(new If(condition));
        }
        else() {
          return this._elseNode(new Else());
        }
        endIf() {
          return this._endBlockNode(If, Else);
        }
        _for(node, forBody) {
          this._blockNode(node);
          if (forBody)
            this.code(forBody).endFor();
          return this;
        }
        for(iteration, forBody) {
          return this._for(new ForLoop(iteration), forBody);
        }
        forRange(nameOrPrefix, from2, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForRange(varKind, name, from2, to2), () => forBody(name));
        }
        forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
          const name = this._scope.toName(nameOrPrefix);
          if (this.opts.es5) {
            const arr = iterable instanceof code_12.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_12._)`${arr}.length`, (i4) => {
              this.var(name, (0, code_12._)`${arr}[${i4}]`);
              forBody(name);
            });
          }
          return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
        }
        forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
          if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_12._)`Object.keys(${obj})`, forBody);
          }
          const name = this._scope.toName(nameOrPrefix);
          return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
        }
        endFor() {
          return this._endBlockNode(For);
        }
        label(label) {
          return this._leafNode(new Label(label));
        }
        break(label) {
          return this._leafNode(new Break(label));
        }
        return(value) {
          const node = new Return();
          this._blockNode(node);
          this.code(value);
          if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(Return);
        }
        try(tryBody, catchCode, finallyCode) {
          if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const node = new Try();
          this._blockNode(node);
          this.code(tryBody);
          if (catchCode) {
            const error2 = this.name("e");
            this._currNode = node.catch = new Catch(error2);
            catchCode(error2);
          }
          if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
          }
          return this._endBlockNode(Catch, Finally);
        }
        throw(error2) {
          return this._leafNode(new Throw(error2));
        }
        block(body, nodeCount) {
          this._blockStarts.push(this._nodes.length);
          if (body)
            this.code(body).endBlock(nodeCount);
          return this;
        }
        endBlock(nodeCount) {
          const len = this._blockStarts.pop();
          if (len === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const toClose = this._nodes.length - len;
          if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
          }
          this._nodes.length = len;
          return this;
        }
        func(name, args = code_12.nil, async, funcBody) {
          this._blockNode(new Func(name, args, async));
          if (funcBody)
            this.code(funcBody).endFunc();
          return this;
        }
        endFunc() {
          return this._endBlockNode(Func);
        }
        optimize(n4 = 1) {
          while (n4-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
          }
        }
        _leafNode(node) {
          this._currNode.nodes.push(node);
          return this;
        }
        _blockNode(node) {
          this._currNode.nodes.push(node);
          this._nodes.push(node);
        }
        _endBlockNode(N12, N23) {
          const n4 = this._currNode;
          if (n4 instanceof N12 || N23 && n4 instanceof N23) {
            this._nodes.pop();
            return this;
          }
          throw new Error(`CodeGen: not in block "${N23 ? `${N12.kind}/${N23.kind}` : N12.kind}"`);
        }
        _elseNode(node) {
          const n4 = this._currNode;
          if (!(n4 instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
          }
          this._currNode = n4.else = node;
          return this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const ns2 = this._nodes;
          return ns2[ns2.length - 1];
        }
        set _currNode(node) {
          const ns2 = this._nodes;
          ns2[ns2.length - 1] = node;
        }
      }
      exports.CodeGen = CodeGen;
      function addNames(names, from2) {
        for (const n4 in from2)
          names[n4] = (names[n4] || 0) + (from2[n4] || 0);
        return names;
      }
      function addExprNames(names, from2) {
        return from2 instanceof code_12._CodeOrName ? addNames(names, from2.names) : names;
      }
      function optimizeExpr(expr, names, constants) {
        if (expr instanceof code_12.Name)
          return replaceName(expr);
        if (!canOptimize(expr))
          return expr;
        return new code_12._Code(expr._items.reduce((items2, c3) => {
          if (c3 instanceof code_12.Name)
            c3 = replaceName(c3);
          if (c3 instanceof code_12._Code)
            items2.push(...c3._items);
          else
            items2.push(c3);
          return items2;
        }, []));
        function replaceName(n4) {
          const c3 = constants[n4.str];
          if (c3 === void 0 || names[n4.str] !== 1)
            return n4;
          delete names[n4.str];
          return c3;
        }
        function canOptimize(e7) {
          return e7 instanceof code_12._Code && e7._items.some((c3) => c3 instanceof code_12.Name && names[c3.str] === 1 && constants[c3.str] !== void 0);
        }
      }
      function subtractNames(names, from2) {
        for (const n4 in from2)
          names[n4] = (names[n4] || 0) - (from2[n4] || 0);
      }
      function not2(x6) {
        return typeof x6 == "boolean" || typeof x6 == "number" || x6 === null ? !x6 : (0, code_12._)`!${par(x6)}`;
      }
      exports.not = not2;
      const andCode = mappend(exports.operators.AND);
      function and(...args) {
        return args.reduce(andCode);
      }
      exports.and = and;
      const orCode = mappend(exports.operators.OR);
      function or3(...args) {
        return args.reduce(orCode);
      }
      exports.or = or3;
      function mappend(op) {
        return (x6, y5) => x6 === code_12.nil ? y5 : y5 === code_12.nil ? x6 : (0, code_12._)`${par(x6)} ${op} ${par(y5)}`;
      }
      function par(x6) {
        return x6 instanceof code_12.Name ? x6 : (0, code_12._)`(${x6})`;
      }
    })(codegen);
    return codegen;
  }
  var util = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    const codegen_12 = requireCodegen();
    const code_12 = requireCode$1();
    function toHash(arr) {
      const hash2 = {};
      for (const item of arr)
        hash2[item] = true;
      return hash2;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it3, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it3, schema);
      return !schemaHasRules(schema, it3.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it3, schema = it3.schema) {
      const { opts, self: self2 } = it3;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules2 = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules2[key])
          checkStrictMode(it3, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules2) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules2[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword2, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_12._)`${schema}`;
      }
      return (0, codegen_12._)`${topSchemaRef}${schemaPath}${(0, codegen_12.getProperty)(keyword2)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs2, f5) {
      if (Array.isArray(xs2)) {
        for (const x6 of xs2)
          f5(x6);
      } else {
        f5(xs2);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen2, from2, to2, toName) => {
        const res = to2 === void 0 ? from2 : to2 instanceof codegen_12.Name ? (from2 instanceof codegen_12.Name ? mergeNames(gen2, from2, to2) : mergeToName(gen2, from2, to2), to2) : from2 instanceof codegen_12.Name ? (mergeToName(gen2, to2, from2), from2) : mergeValues(from2, to2);
        return toName === codegen_12.Name && !(res instanceof codegen_12.Name) ? resultToName(gen2, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen2, from2, to2) => gen2.if((0, codegen_12._)`${to2} !== true && ${from2} !== undefined`, () => {
          gen2.if((0, codegen_12._)`${from2} === true`, () => gen2.assign(to2, true), () => gen2.assign(to2, (0, codegen_12._)`${to2} || {}`).code((0, codegen_12._)`Object.assign(${to2}, ${from2})`));
        }),
        mergeToName: (gen2, from2, to2) => gen2.if((0, codegen_12._)`${to2} !== true`, () => {
          if (from2 === true) {
            gen2.assign(to2, true);
          } else {
            gen2.assign(to2, (0, codegen_12._)`${to2} || {}`);
            setEvaluated(gen2, to2, from2);
          }
        }),
        mergeValues: (from2, to2) => from2 === true ? true : { ...from2, ...to2 },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen2, from2, to2) => gen2.if((0, codegen_12._)`${to2} !== true && ${from2} !== undefined`, () => gen2.assign(to2, (0, codegen_12._)`${from2} === true ? true : ${to2} > ${from2} ? ${to2} : ${from2}`)),
        mergeToName: (gen2, from2, to2) => gen2.if((0, codegen_12._)`${to2} !== true`, () => gen2.assign(to2, from2 === true ? true : (0, codegen_12._)`${to2} > ${from2} ? ${to2} : ${from2}`)),
        mergeValues: (from2, to2) => from2 === true ? true : Math.max(from2, to2),
        resultToName: (gen2, items2) => gen2.var("items", items2)
      })
    };
    function evaluatedPropsToName(gen2, ps2) {
      if (ps2 === true)
        return gen2.var("props", true);
      const props = gen2.var("props", (0, codegen_12._)`{}`);
      if (ps2 !== void 0)
        setEvaluated(gen2, props, ps2);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen2, props, ps2) {
      Object.keys(ps2).forEach((p6) => gen2.assign((0, codegen_12._)`${props}${(0, codegen_12.getProperty)(p6)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    const snippets = {};
    function useFunc(gen2, f5) {
      return gen2.scopeValue("func", {
        ref: f5,
        code: snippets[f5.code] || (snippets[f5.code] = new code_12._Code(f5.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type = exports.Type || (exports.Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_12.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_12._)`"[" + ${dataProp} + "]"` : (0, codegen_12._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_12._)`"/" + ${dataProp}` : (0, codegen_12._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_12.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it3, msg, mode = it3.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it3.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  })(util);
  var names$1 = {};
  var hasRequiredNames;
  function requireNames() {
    if (hasRequiredNames)
      return names$1;
    hasRequiredNames = 1;
    Object.defineProperty(names$1, "__esModule", { value: true });
    const codegen_12 = requireCodegen();
    const names = {
      data: new codegen_12.Name("data"),
      valCxt: new codegen_12.Name("valCxt"),
      instancePath: new codegen_12.Name("instancePath"),
      parentData: new codegen_12.Name("parentData"),
      parentDataProperty: new codegen_12.Name("parentDataProperty"),
      rootData: new codegen_12.Name("rootData"),
      dynamicAnchors: new codegen_12.Name("dynamicAnchors"),
      vErrors: new codegen_12.Name("vErrors"),
      errors: new codegen_12.Name("errors"),
      this: new codegen_12.Name("this"),
      self: new codegen_12.Name("self"),
      scope: new codegen_12.Name("scope"),
      json: new codegen_12.Name("json"),
      jsonPos: new codegen_12.Name("jsonPos"),
      jsonLen: new codegen_12.Name("jsonLen"),
      jsonPart: new codegen_12.Name("jsonPart")
    };
    names$1.default = names;
    return names$1;
  }
  var hasRequiredErrors;
  function requireErrors() {
    if (hasRequiredErrors)
      return errors;
    hasRequiredErrors = 1;
    (function(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
      const codegen_12 = requireCodegen();
      const util_12 = util;
      const names_12 = requireNames();
      exports.keywordError = {
        message: ({ keyword: keyword2 }) => (0, codegen_12.str)`must pass "${keyword2}" keyword validation`
      };
      exports.keyword$DataError = {
        message: ({ keyword: keyword2, schemaType }) => schemaType ? (0, codegen_12.str)`"${keyword2}" keyword must be ${schemaType} ($data)` : (0, codegen_12.str)`"${keyword2}" keyword is invalid ($data)`
      };
      function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
        const { it: it3 } = cxt;
        const { gen: gen2, compositeRule, allErrors } = it3;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
          addError(gen2, errObj);
        } else {
          returnErrors(it3, (0, codegen_12._)`[${errObj}]`);
        }
      }
      exports.reportError = reportError;
      function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
        const { it: it3 } = cxt;
        const { gen: gen2, compositeRule, allErrors } = it3;
        const errObj = errorObjectCode(cxt, error2, errorPaths);
        addError(gen2, errObj);
        if (!(compositeRule || allErrors)) {
          returnErrors(it3, names_12.default.vErrors);
        }
      }
      exports.reportExtraError = reportExtraError;
      function resetErrorsCount(gen2, errsCount) {
        gen2.assign(names_12.default.errors, errsCount);
        gen2.if((0, codegen_12._)`${names_12.default.vErrors} !== null`, () => gen2.if(errsCount, () => gen2.assign((0, codegen_12._)`${names_12.default.vErrors}.length`, errsCount), () => gen2.assign(names_12.default.vErrors, null)));
      }
      exports.resetErrorsCount = resetErrorsCount;
      function extendErrors({ gen: gen2, keyword: keyword2, schemaValue, data, errsCount, it: it3 }) {
        if (errsCount === void 0)
          throw new Error("ajv implementation error");
        const err = gen2.name("err");
        gen2.forRange("i", errsCount, names_12.default.errors, (i4) => {
          gen2.const(err, (0, codegen_12._)`${names_12.default.vErrors}[${i4}]`);
          gen2.if((0, codegen_12._)`${err}.instancePath === undefined`, () => gen2.assign((0, codegen_12._)`${err}.instancePath`, (0, codegen_12.strConcat)(names_12.default.instancePath, it3.errorPath)));
          gen2.assign((0, codegen_12._)`${err}.schemaPath`, (0, codegen_12.str)`${it3.errSchemaPath}/${keyword2}`);
          if (it3.opts.verbose) {
            gen2.assign((0, codegen_12._)`${err}.schema`, schemaValue);
            gen2.assign((0, codegen_12._)`${err}.data`, data);
          }
        });
      }
      exports.extendErrors = extendErrors;
      function addError(gen2, errObj) {
        const err = gen2.const("err", errObj);
        gen2.if((0, codegen_12._)`${names_12.default.vErrors} === null`, () => gen2.assign(names_12.default.vErrors, (0, codegen_12._)`[${err}]`), (0, codegen_12._)`${names_12.default.vErrors}.push(${err})`);
        gen2.code((0, codegen_12._)`${names_12.default.errors}++`);
      }
      function returnErrors(it3, errs) {
        const { gen: gen2, validateName, schemaEnv } = it3;
        if (schemaEnv.$async) {
          gen2.throw((0, codegen_12._)`new ${it3.ValidationError}(${errs})`);
        } else {
          gen2.assign((0, codegen_12._)`${validateName}.errors`, errs);
          gen2.return(false);
        }
      }
      const E4 = {
        keyword: new codegen_12.Name("keyword"),
        schemaPath: new codegen_12.Name("schemaPath"),
        params: new codegen_12.Name("params"),
        propertyName: new codegen_12.Name("propertyName"),
        message: new codegen_12.Name("message"),
        schema: new codegen_12.Name("schema"),
        parentSchema: new codegen_12.Name("parentSchema")
      };
      function errorObjectCode(cxt, error2, errorPaths) {
        const { createErrors } = cxt.it;
        if (createErrors === false)
          return (0, codegen_12._)`{}`;
        return errorObject(cxt, error2, errorPaths);
      }
      function errorObject(cxt, error2, errorPaths = {}) {
        const { gen: gen2, it: it3 } = cxt;
        const keyValues = [
          errorInstancePath(it3, errorPaths),
          errorSchemaPath(cxt, errorPaths)
        ];
        extraErrorProps(cxt, error2, keyValues);
        return gen2.object(...keyValues);
      }
      function errorInstancePath({ errorPath }, { instancePath }) {
        const instPath = instancePath ? (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(instancePath, util_12.Type.Str)}` : errorPath;
        return [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, instPath)];
      }
      function errorSchemaPath({ keyword: keyword2, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
        let schPath = parentSchema ? errSchemaPath : (0, codegen_12.str)`${errSchemaPath}/${keyword2}`;
        if (schemaPath) {
          schPath = (0, codegen_12.str)`${schPath}${(0, util_12.getErrorPath)(schemaPath, util_12.Type.Str)}`;
        }
        return [E4.schemaPath, schPath];
      }
      function extraErrorProps(cxt, { params, message }, keyValues) {
        const { keyword: keyword2, data, schemaValue, it: it3 } = cxt;
        const { opts, propertyName, topSchemaRef, schemaPath } = it3;
        keyValues.push([E4.keyword, keyword2], [E4.params, typeof params == "function" ? params(cxt) : params || (0, codegen_12._)`{}`]);
        if (opts.messages) {
          keyValues.push([E4.message, typeof message == "function" ? message(cxt) : message]);
        }
        if (opts.verbose) {
          keyValues.push([E4.schema, schemaValue], [E4.parentSchema, (0, codegen_12._)`${topSchemaRef}${schemaPath}`], [names_12.default.data, data]);
        }
        if (propertyName)
          keyValues.push([E4.propertyName, propertyName]);
      }
    })(errors);
    return errors;
  }
  var hasRequiredBoolSchema;
  function requireBoolSchema() {
    if (hasRequiredBoolSchema)
      return boolSchema;
    hasRequiredBoolSchema = 1;
    Object.defineProperty(boolSchema, "__esModule", { value: true });
    boolSchema.boolOrEmptySchema = boolSchema.topBoolOrEmptySchema = void 0;
    const errors_1 = requireErrors();
    const codegen_12 = requireCodegen();
    const names_12 = requireNames();
    const boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it3) {
      const { gen: gen2, schema, validateName } = it3;
      if (schema === false) {
        falseSchemaError(it3, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen2.return(names_12.default.data);
      } else {
        gen2.assign((0, codegen_12._)`${validateName}.errors`, null);
        gen2.return(true);
      }
    }
    boolSchema.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it3, valid) {
      const { gen: gen2, schema } = it3;
      if (schema === false) {
        gen2.var(valid, false);
        falseSchemaError(it3);
      } else {
        gen2.var(valid, true);
      }
    }
    boolSchema.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it3, overrideAllErrors) {
      const { gen: gen2, data } = it3;
      const cxt = {
        gen: gen2,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it: it3
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
    return boolSchema;
  }
  var dataType = {};
  var rules = {};
  Object.defineProperty(rules, "__esModule", { value: true });
  rules.getRules = rules.isJSONType = void 0;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x6) {
    return typeof x6 == "string" && jsonTypes.has(x6);
  }
  rules.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  rules.getRules = getRules;
  var applicability = {};
  var hasRequiredApplicability;
  function requireApplicability() {
    if (hasRequiredApplicability)
      return applicability;
    hasRequiredApplicability = 1;
    Object.defineProperty(applicability, "__esModule", { value: true });
    applicability.shouldUseRule = applicability.shouldUseGroup = applicability.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type2) {
      const group = self2.RULES.types[type2];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    applicability.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    applicability.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    applicability.shouldUseRule = shouldUseRule;
    return applicability;
  }
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    const rules_1 = rules;
    const applicability_1 = requireApplicability();
    const errors_1 = requireErrors();
    const codegen_12 = requireCodegen();
    const util_12 = util;
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType = exports.DataType || (exports.DataType = {}));
    function getSchemaTypes(schema) {
      const types2 = getJSONTypes(schema.type);
      const hasNull = types2.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types2.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types2.push("null");
      }
      return types2;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts2) {
      const types2 = Array.isArray(ts2) ? ts2 : ts2 ? [ts2] : [];
      if (types2.every(rules_1.isJSONType))
        return types2;
      throw new Error("type must be JSONType or JSONType[]: " + types2.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it3, types2) {
      const { gen: gen2, data, opts } = it3;
      const coerceTo = coerceToTypes(types2, opts.coerceTypes);
      const checkTypes = types2.length > 0 && !(coerceTo.length === 0 && types2.length === 1 && (0, applicability_1.schemaHasRulesForType)(it3, types2[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types2, data, opts.strictNumbers, DataType.Wrong);
        gen2.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it3, types2, coerceTo);
          else
            reportTypeError(it3);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    const COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types2, coerceTypes) {
      return coerceTypes ? types2.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it3, types2, coerceTo) {
      const { gen: gen2, data, opts } = it3;
      const dataType2 = gen2.let("dataType", (0, codegen_12._)`typeof ${data}`);
      const coerced = gen2.let("coerced", (0, codegen_12._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen2.if((0, codegen_12._)`${dataType2} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen2.assign(data, (0, codegen_12._)`${data}[0]`).assign(dataType2, (0, codegen_12._)`typeof ${data}`).if(checkDataTypes(types2, data, opts.strictNumbers), () => gen2.assign(coerced, data)));
      }
      gen2.if((0, codegen_12._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen2.else();
      reportTypeError(it3);
      gen2.endIf();
      gen2.if((0, codegen_12._)`${coerced} !== undefined`, () => {
        gen2.assign(data, coerced);
        assignParentData(it3, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen2.elseIf((0, codegen_12._)`${dataType2} == "number" || ${dataType2} == "boolean"`).assign(coerced, (0, codegen_12._)`"" + ${data}`).elseIf((0, codegen_12._)`${data} === null`).assign(coerced, (0, codegen_12._)`""`);
            return;
          case "number":
            gen2.elseIf((0, codegen_12._)`${dataType2} == "boolean" || ${data} === null
              || (${dataType2} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_12._)`+${data}`);
            return;
          case "integer":
            gen2.elseIf((0, codegen_12._)`${dataType2} === "boolean" || ${data} === null
              || (${dataType2} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_12._)`+${data}`);
            return;
          case "boolean":
            gen2.elseIf((0, codegen_12._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_12._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen2.elseIf((0, codegen_12._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen2.assign(coerced, null);
            return;
          case "array":
            gen2.elseIf((0, codegen_12._)`${dataType2} === "string" || ${dataType2} === "number"
              || ${dataType2} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_12._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen: gen2, parentData, parentDataProperty }, expr) {
      gen2.if((0, codegen_12._)`${parentData} !== undefined`, () => gen2.assign((0, codegen_12._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType2, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_12.operators.EQ : codegen_12.operators.NEQ;
      let cond;
      switch (dataType2) {
        case "null":
          return (0, codegen_12._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_12._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_12._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_12._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_12._)`typeof ${data} ${EQ} ${dataType2}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_12.not)(cond);
      function numCond(_cond = codegen_12.nil) {
        return (0, codegen_12.and)((0, codegen_12._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_12._)`isFinite(${data})` : codegen_12.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types2 = (0, util_12.toHash)(dataTypes);
      if (types2.array && types2.object) {
        const notObj = (0, codegen_12._)`typeof ${data} != "object"`;
        cond = types2.null ? notObj : (0, codegen_12._)`!${data} || ${notObj}`;
        delete types2.null;
        delete types2.array;
        delete types2.object;
      } else {
        cond = codegen_12.nil;
      }
      if (types2.number)
        delete types2.integer;
      for (const t in types2)
        cond = (0, codegen_12.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    const typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_12._)`{type: ${schema}}` : (0, codegen_12._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it3) {
      const cxt = getTypeErrorContext(it3);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it3) {
      const { gen: gen2, data, schema } = it3;
      const schemaCode = (0, util_12.schemaRefOrVal)(it3, schema, "type");
      return {
        gen: gen2,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it: it3
      };
    }
  })(dataType);
  var defaults = {};
  var hasRequiredDefaults;
  function requireDefaults() {
    if (hasRequiredDefaults)
      return defaults;
    hasRequiredDefaults = 1;
    Object.defineProperty(defaults, "__esModule", { value: true });
    defaults.assignDefaults = void 0;
    const codegen_12 = requireCodegen();
    const util_12 = util;
    function assignDefaults(it3, ty) {
      const { properties: properties2, items: items2 } = it3.schema;
      if (ty === "object" && properties2) {
        for (const key in properties2) {
          assignDefault(it3, key, properties2[key].default);
        }
      } else if (ty === "array" && Array.isArray(items2)) {
        items2.forEach((sch, i4) => assignDefault(it3, i4, sch.default));
      }
    }
    defaults.assignDefaults = assignDefaults;
    function assignDefault(it3, prop, defaultValue) {
      const { gen: gen2, compositeRule, data, opts } = it3;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_12._)`${data}${(0, codegen_12.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_12.checkStrictMode)(it3, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_12._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_12._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen2.if(condition, (0, codegen_12._)`${childData} = ${(0, codegen_12.stringify)(defaultValue)}`);
    }
    return defaults;
  }
  var keyword = {};
  var code = {};
  var hasRequiredCode;
  function requireCode() {
    if (hasRequiredCode)
      return code;
    hasRequiredCode = 1;
    Object.defineProperty(code, "__esModule", { value: true });
    code.validateUnion = code.validateArray = code.usePattern = code.callValidateCode = code.schemaProperties = code.allSchemaProperties = code.noPropertyInData = code.propertyInData = code.isOwnProperty = code.hasPropFunc = code.reportMissingProp = code.checkMissingProp = code.checkReportMissingProp = void 0;
    const codegen_12 = requireCodegen();
    const util_12 = util;
    const names_12 = requireNames();
    const util_22 = util;
    function checkReportMissingProp(cxt, prop) {
      const { gen: gen2, data, it: it3 } = cxt;
      gen2.if(noPropertyInData(gen2, data, prop, it3.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_12._)`${prop}` }, true);
        cxt.error();
      });
    }
    code.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen: gen2, data, it: { opts } }, properties2, missing) {
      return (0, codegen_12.or)(...properties2.map((prop) => (0, codegen_12.and)(noPropertyInData(gen2, data, prop, opts.ownProperties), (0, codegen_12._)`${missing} = ${prop}`)));
    }
    code.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    code.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen2) {
      return gen2.scopeValue("func", {
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_12._)`Object.prototype.hasOwnProperty`
      });
    }
    code.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen2, data, property) {
      return (0, codegen_12._)`${hasPropFunc(gen2)}.call(${data}, ${property})`;
    }
    code.isOwnProperty = isOwnProperty;
    function propertyInData(gen2, data, property, ownProperties) {
      const cond = (0, codegen_12._)`${data}${(0, codegen_12.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_12._)`${cond} && ${isOwnProperty(gen2, data, property)}` : cond;
    }
    code.propertyInData = propertyInData;
    function noPropertyInData(gen2, data, property, ownProperties) {
      const cond = (0, codegen_12._)`${data}${(0, codegen_12.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_12.or)(cond, (0, codegen_12.not)(isOwnProperty(gen2, data, property))) : cond;
    }
    code.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p6) => p6 !== "__proto__") : [];
    }
    code.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it3, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p6) => !(0, util_12.alwaysValidSchema)(it3, schemaMap[p6]));
    }
    code.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen: gen2, topSchemaRef, schemaPath, errorPath }, it: it3 }, func, context2, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_12._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_12.default.instancePath, (0, codegen_12.strConcat)(names_12.default.instancePath, errorPath)],
        [names_12.default.parentData, it3.parentData],
        [names_12.default.parentDataProperty, it3.parentDataProperty],
        [names_12.default.rootData, names_12.default.rootData]
      ];
      if (it3.opts.dynamicRef)
        valCxt.push([names_12.default.dynamicAnchors, names_12.default.dynamicAnchors]);
      const args = (0, codegen_12._)`${dataAndSchema}, ${gen2.object(...valCxt)}`;
      return context2 !== codegen_12.nil ? (0, codegen_12._)`${func}.call(${context2}, ${args})` : (0, codegen_12._)`${func}(${args})`;
    }
    code.callValidateCode = callValidateCode;
    const newRegExp = (0, codegen_12._)`new RegExp`;
    function usePattern({ gen: gen2, it: { opts } }, pattern2) {
      const u4 = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern2, u4);
      return gen2.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_12._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_22.useFunc)(gen2, regExp)}(${pattern2}, ${u4})`
      });
    }
    code.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen: gen2, data, keyword: keyword2, it: it3 } = cxt;
      const valid = gen2.name("valid");
      if (it3.allErrors) {
        const validArr = gen2.let("valid", true);
        validateItems(() => gen2.assign(validArr, false));
        return validArr;
      }
      gen2.var(valid, true);
      validateItems(() => gen2.break());
      return valid;
      function validateItems(notValid) {
        const len = gen2.const("len", (0, codegen_12._)`${data}.length`);
        gen2.forRange("i", 0, len, (i4) => {
          cxt.subschema({
            keyword: keyword2,
            dataProp: i4,
            dataPropType: util_12.Type.Num
          }, valid);
          gen2.if((0, codegen_12.not)(valid), notValid);
        });
      }
    }
    code.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen: gen2, schema, keyword: keyword2, it: it3 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_12.alwaysValidSchema)(it3, sch));
      if (alwaysValid && !it3.opts.unevaluated)
        return;
      const valid = gen2.let("valid", false);
      const schValid = gen2.name("_valid");
      gen2.block(() => schema.forEach((_sch, i4) => {
        const schCxt = cxt.subschema({
          keyword: keyword2,
          schemaProp: i4,
          compositeRule: true
        }, schValid);
        gen2.assign(valid, (0, codegen_12._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen2.if((0, codegen_12.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    code.validateUnion = validateUnion;
    return code;
  }
  var hasRequiredKeyword;
  function requireKeyword() {
    if (hasRequiredKeyword)
      return keyword;
    hasRequiredKeyword = 1;
    Object.defineProperty(keyword, "__esModule", { value: true });
    keyword.validateKeywordUsage = keyword.validSchemaType = keyword.funcKeywordCode = keyword.macroKeywordCode = void 0;
    const codegen_12 = requireCodegen();
    const names_12 = requireNames();
    const code_12 = requireCode();
    const errors_1 = requireErrors();
    function macroKeywordCode(cxt, def2) {
      const { gen: gen2, keyword: keyword2, schema, parentSchema, it: it3 } = cxt;
      const macroSchema = def2.macro.call(it3.self, schema, parentSchema, it3);
      const schemaRef = useKeyword(gen2, keyword2, macroSchema);
      if (it3.opts.validateSchema !== false)
        it3.self.validateSchema(macroSchema, true);
      const valid = gen2.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_12.nil,
        errSchemaPath: `${it3.errSchemaPath}/${keyword2}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    keyword.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def2) {
      var _a2;
      const { gen: gen2, keyword: keyword2, schema, parentSchema, $data, it: it3 } = cxt;
      checkAsyncKeyword(it3, def2);
      const validate2 = !$data && def2.compile ? def2.compile.call(it3.self, schema, parentSchema, it3) : def2.validate;
      const validateRef = useKeyword(gen2, keyword2, validate2);
      const valid = gen2.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a2 = def2.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def2.errors === false) {
          assignValid();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def2.async ? validateAsync() : validateSync();
          if (def2.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen2.let("ruleErrs", null);
        gen2.try(() => assignValid((0, codegen_12._)`await `), (e7) => gen2.assign(valid, false).if((0, codegen_12._)`${e7} instanceof ${it3.ValidationError}`, () => gen2.assign(ruleErrs, (0, codegen_12._)`${e7}.errors`), () => gen2.throw(e7)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_12._)`${validateRef}.errors`;
        gen2.assign(validateErrs, null);
        assignValid(codegen_12.nil);
        return validateErrs;
      }
      function assignValid(_await = def2.async ? (0, codegen_12._)`await ` : codegen_12.nil) {
        const passCxt = it3.opts.passContext ? names_12.default.this : names_12.default.self;
        const passSchema = !("compile" in def2 && !$data || def2.schema === false);
        gen2.assign(valid, (0, codegen_12._)`${_await}${(0, code_12.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def2.modifying);
      }
      function reportErrs(errors2) {
        var _a3;
        gen2.if((0, codegen_12.not)((_a3 = def2.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors2);
      }
    }
    keyword.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen: gen2, data, it: it3 } = cxt;
      gen2.if(it3.parentData, () => gen2.assign(data, (0, codegen_12._)`${it3.parentData}[${it3.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen: gen2 } = cxt;
      gen2.if((0, codegen_12._)`Array.isArray(${errs})`, () => {
        gen2.assign(names_12.default.vErrors, (0, codegen_12._)`${names_12.default.vErrors} === null ? ${errs} : ${names_12.default.vErrors}.concat(${errs})`).assign(names_12.default.errors, (0, codegen_12._)`${names_12.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def2) {
      if (def2.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen2, keyword2, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword2}" failed to compile`);
      return gen2.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_12.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st3) => st3 === "array" ? Array.isArray(schema) : st3 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st3 || allowUndefined && typeof schema == "undefined");
    }
    keyword.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def2, keyword2) {
      if (Array.isArray(def2.keyword) ? !def2.keyword.includes(keyword2) : def2.keyword !== keyword2) {
        throw new Error("ajv implementation error");
      }
      const deps = def2.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword2}: ${deps.join(",")}`);
      }
      if (def2.validateSchema) {
        const valid = def2.validateSchema(schema[keyword2]);
        if (!valid) {
          const msg = `keyword "${keyword2}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def2.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    keyword.validateKeywordUsage = validateKeywordUsage;
    return keyword;
  }
  var subschema = {};
  var hasRequiredSubschema;
  function requireSubschema() {
    if (hasRequiredSubschema)
      return subschema;
    hasRequiredSubschema = 1;
    Object.defineProperty(subschema, "__esModule", { value: true });
    subschema.extendSubschemaMode = subschema.extendSubschemaData = subschema.getSubschema = void 0;
    const codegen_12 = requireCodegen();
    const util_12 = util;
    function getSubschema(it3, { keyword: keyword2, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword2 !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword2 !== void 0) {
        const sch = it3.schema[keyword2];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_12._)`${it3.schemaPath}${(0, codegen_12.getProperty)(keyword2)}`,
          errSchemaPath: `${it3.errSchemaPath}/${keyword2}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_12._)`${it3.schemaPath}${(0, codegen_12.getProperty)(keyword2)}${(0, codegen_12.getProperty)(schemaProp)}`,
          errSchemaPath: `${it3.errSchemaPath}/${keyword2}/${(0, util_12.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    subschema.getSubschema = getSubschema;
    function extendSubschemaData(subschema2, it3, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen: gen2 } = it3;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it3;
        const nextData = gen2.let("data", (0, codegen_12._)`${it3.data}${(0, codegen_12.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema2.errorPath = (0, codegen_12.str)`${errorPath}${(0, util_12.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema2.parentDataProperty = (0, codegen_12._)`${dataProp}`;
        subschema2.dataPathArr = [...dataPathArr, subschema2.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_12.Name ? data : gen2.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema2.propertyName = propertyName;
      }
      if (dataTypes)
        subschema2.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema2.data = _nextData;
        subschema2.dataLevel = it3.dataLevel + 1;
        subschema2.dataTypes = [];
        it3.definedProperties = /* @__PURE__ */ new Set();
        subschema2.parentData = it3.data;
        subschema2.dataNames = [...it3.dataNames, _nextData];
      }
    }
    subschema.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema2, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema2.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema2.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema2.allErrors = allErrors;
      subschema2.jtdDiscriminator = jtdDiscriminator;
      subschema2.jtdMetadata = jtdMetadata;
    }
    subschema.extendSubschemaMode = extendSubschemaMode;
    return subschema;
  }
  var resolve$1 = {};
  var fastDeepEqual = function equal(a4, b7) {
    if (a4 === b7)
      return true;
    if (a4 && b7 && typeof a4 == "object" && typeof b7 == "object") {
      if (a4.constructor !== b7.constructor)
        return false;
      var length2, i4, keys;
      if (Array.isArray(a4)) {
        length2 = a4.length;
        if (length2 != b7.length)
          return false;
        for (i4 = length2; i4-- !== 0; )
          if (!equal(a4[i4], b7[i4]))
            return false;
        return true;
      }
      if (a4.constructor === RegExp)
        return a4.source === b7.source && a4.flags === b7.flags;
      if (a4.valueOf !== Object.prototype.valueOf)
        return a4.valueOf() === b7.valueOf();
      if (a4.toString !== Object.prototype.toString)
        return a4.toString() === b7.toString();
      keys = Object.keys(a4);
      length2 = keys.length;
      if (length2 !== Object.keys(b7).length)
        return false;
      for (i4 = length2; i4-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b7, keys[i4]))
          return false;
      for (i4 = length2; i4-- !== 0; ) {
        var key = keys[i4];
        if (!equal(a4[key], b7[key]))
          return false;
      }
      return true;
    }
    return a4 !== a4 && b7 !== b7;
  };
  var jsonSchemaTraverse = { exports: {} };
  var traverse$1 = jsonSchemaTraverse.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse$1.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse$1.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse$1.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse$1.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse$1.arrayKeywords) {
            for (var i4 = 0; i4 < sch.length; i4++)
              _traverse(opts, pre, post, sch[i4], jsonPtr + "/" + key + "/" + i4, rootSchema, jsonPtr, key, schema, i4);
          }
        } else if (key in traverse$1.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse$1.keywords || opts.allKeys && !(key in traverse$1.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  var jsonSchemaTraverseExports = jsonSchemaTraverse.exports;
  Object.defineProperty(resolve$1, "__esModule", { value: true });
  resolve$1.getSchemaRefs = resolve$1.resolveUrl = resolve$1.normalizeId = resolve$1._getFullPath = resolve$1.getFullPath = resolve$1.inlineRef = void 0;
  var util_1$p = util;
  var equal$2 = fastDeepEqual;
  var traverse = jsonSchemaTraverseExports;
  var SIMPLE_INLINED = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit2 = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit2 === true)
      return !hasRef(schema);
    if (!limit2)
      return false;
    return countKeys(schema) <= limit2;
  }
  resolve$1.inlineRef = inlineRef;
  var REF_KEYWORDS = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1$p.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id3 = "", normalize2) {
    if (normalize2 !== false)
      id3 = normalizeId(id3);
    const p6 = resolver.parse(id3);
    return _getFullPath(resolver, p6);
  }
  resolve$1.getFullPath = getFullPath;
  function _getFullPath(resolver, p6) {
    const serialized = resolver.serialize(p6);
    return serialized.split("#")[0] + "#";
  }
  resolve$1._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id3) {
    return id3 ? id3.replace(TRAILING_SLASH_HASH, "") : "";
  }
  resolve$1.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id3) {
    id3 = normalizeId(id3);
    return resolver.resolve(baseId, id3);
  }
  resolve$1.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = /* @__PURE__ */ new Set();
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _5, parentJsonPtr) => {
      if (parentJsonPtr === void 0)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let baseId2 = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        baseId2 = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = baseId2;
      function addRef(ref2) {
        const _resolve = this.opts.uriResolver.resolve;
        ref2 = normalizeId(baseId2 ? _resolve(baseId2, ref2) : ref2);
        if (schemaRefs.has(ref2))
          throw ambiguos(ref2);
        schemaRefs.add(ref2);
        let schOrRef = this.refs[ref2];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref2);
        } else if (ref2 !== normalizeId(fullPath)) {
          if (ref2[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref2], ref2);
            localRefs[ref2] = sch;
          } else {
            this.refs[ref2] = fullPath;
          }
        }
        return ref2;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref2) {
      if (sch2 !== void 0 && !equal$2(sch1, sch2))
        throw ambiguos(ref2);
    }
    function ambiguos(ref2) {
      return new Error(`reference "${ref2}" resolves to more than one schema`);
    }
  }
  resolve$1.getSchemaRefs = getSchemaRefs;
  var hasRequiredValidate;
  function requireValidate() {
    if (hasRequiredValidate)
      return validate;
    hasRequiredValidate = 1;
    Object.defineProperty(validate, "__esModule", { value: true });
    validate.getData = validate.KeywordCxt = validate.validateFunctionCode = void 0;
    const boolSchema_1 = requireBoolSchema();
    const dataType_12 = dataType;
    const applicability_1 = requireApplicability();
    const dataType_2 = dataType;
    const defaults_1 = requireDefaults();
    const keyword_1 = requireKeyword();
    const subschema_1 = requireSubschema();
    const codegen_12 = requireCodegen();
    const names_12 = requireNames();
    const resolve_12 = resolve$1;
    const util_12 = util;
    const errors_1 = requireErrors();
    function validateFunctionCode(it3) {
      if (isSchemaObj(it3)) {
        checkKeywords(it3);
        if (schemaCxtHasRules(it3)) {
          topSchemaObjCode(it3);
          return;
        }
      }
      validateFunction(it3, () => (0, boolSchema_1.topBoolOrEmptySchema)(it3));
    }
    validate.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen: gen2, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen2.func(validateName, (0, codegen_12._)`${names_12.default.data}, ${names_12.default.valCxt}`, schemaEnv.$async, () => {
          gen2.code((0, codegen_12._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen2, opts);
          gen2.code(body);
        });
      } else {
        gen2.func(validateName, (0, codegen_12._)`${names_12.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen2.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_12._)`{${names_12.default.instancePath}="", ${names_12.default.parentData}, ${names_12.default.parentDataProperty}, ${names_12.default.rootData}=${names_12.default.data}${opts.dynamicRef ? (0, codegen_12._)`, ${names_12.default.dynamicAnchors}={}` : codegen_12.nil}}={}`;
    }
    function destructureValCxtES5(gen2, opts) {
      gen2.if(names_12.default.valCxt, () => {
        gen2.var(names_12.default.instancePath, (0, codegen_12._)`${names_12.default.valCxt}.${names_12.default.instancePath}`);
        gen2.var(names_12.default.parentData, (0, codegen_12._)`${names_12.default.valCxt}.${names_12.default.parentData}`);
        gen2.var(names_12.default.parentDataProperty, (0, codegen_12._)`${names_12.default.valCxt}.${names_12.default.parentDataProperty}`);
        gen2.var(names_12.default.rootData, (0, codegen_12._)`${names_12.default.valCxt}.${names_12.default.rootData}`);
        if (opts.dynamicRef)
          gen2.var(names_12.default.dynamicAnchors, (0, codegen_12._)`${names_12.default.valCxt}.${names_12.default.dynamicAnchors}`);
      }, () => {
        gen2.var(names_12.default.instancePath, (0, codegen_12._)`""`);
        gen2.var(names_12.default.parentData, (0, codegen_12._)`undefined`);
        gen2.var(names_12.default.parentDataProperty, (0, codegen_12._)`undefined`);
        gen2.var(names_12.default.rootData, names_12.default.data);
        if (opts.dynamicRef)
          gen2.var(names_12.default.dynamicAnchors, (0, codegen_12._)`{}`);
      });
    }
    function topSchemaObjCode(it3) {
      const { schema, opts, gen: gen2 } = it3;
      validateFunction(it3, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it3);
        checkNoDefault(it3);
        gen2.let(names_12.default.vErrors, null);
        gen2.let(names_12.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it3);
        typeAndKeywords(it3);
        returnResults(it3);
      });
      return;
    }
    function resetEvaluated(it3) {
      const { gen: gen2, validateName } = it3;
      it3.evaluated = gen2.const("evaluated", (0, codegen_12._)`${validateName}.evaluated`);
      gen2.if((0, codegen_12._)`${it3.evaluated}.dynamicProps`, () => gen2.assign((0, codegen_12._)`${it3.evaluated}.props`, (0, codegen_12._)`undefined`));
      gen2.if((0, codegen_12._)`${it3.evaluated}.dynamicItems`, () => gen2.assign((0, codegen_12._)`${it3.evaluated}.items`, (0, codegen_12._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_12._)`/*# sourceURL=${schId} */` : codegen_12.nil;
    }
    function subschemaCode(it3, valid) {
      if (isSchemaObj(it3)) {
        checkKeywords(it3);
        if (schemaCxtHasRules(it3)) {
          subSchemaObjCode(it3, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it3, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it3) {
      return typeof it3.schema != "boolean";
    }
    function subSchemaObjCode(it3, valid) {
      const { schema, gen: gen2, opts } = it3;
      if (opts.$comment && schema.$comment)
        commentKeyword(it3);
      updateContext(it3);
      checkAsyncSchema(it3);
      const errsCount = gen2.const("_errs", names_12.default.errors);
      typeAndKeywords(it3, errsCount);
      gen2.var(valid, (0, codegen_12._)`${errsCount} === ${names_12.default.errors}`);
    }
    function checkKeywords(it3) {
      (0, util_12.checkUnknownRules)(it3);
      checkRefsAndKeywords(it3);
    }
    function typeAndKeywords(it3, errsCount) {
      if (it3.opts.jtd)
        return schemaKeywords(it3, [], false, errsCount);
      const types2 = (0, dataType_12.getSchemaTypes)(it3.schema);
      const checkedTypes = (0, dataType_12.coerceAndCheckDataType)(it3, types2);
      schemaKeywords(it3, types2, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it3) {
      const { schema, errSchemaPath, opts, self: self2 } = it3;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_12.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it3) {
      const { schema, opts } = it3;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_12.checkStrictMode)(it3, "default is ignored in the schema root");
      }
    }
    function updateContext(it3) {
      const schId = it3.schema[it3.opts.schemaId];
      if (schId)
        it3.baseId = (0, resolve_12.resolveUrl)(it3.opts.uriResolver, it3.baseId, schId);
    }
    function checkAsyncSchema(it3) {
      if (it3.schema.$async && !it3.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen: gen2, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen2.code((0, codegen_12._)`${names_12.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_12.str)`${errSchemaPath}/$comment`;
        const rootName = gen2.scopeValue("root", { ref: schemaEnv.root });
        gen2.code((0, codegen_12._)`${names_12.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it3) {
      const { gen: gen2, schemaEnv, validateName, ValidationError, opts } = it3;
      if (schemaEnv.$async) {
        gen2.if((0, codegen_12._)`${names_12.default.errors} === 0`, () => gen2.return(names_12.default.data), () => gen2.throw((0, codegen_12._)`new ${ValidationError}(${names_12.default.vErrors})`));
      } else {
        gen2.assign((0, codegen_12._)`${validateName}.errors`, names_12.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it3);
        gen2.return((0, codegen_12._)`${names_12.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen: gen2, evaluated, props, items: items2 }) {
      if (props instanceof codegen_12.Name)
        gen2.assign((0, codegen_12._)`${evaluated}.props`, props);
      if (items2 instanceof codegen_12.Name)
        gen2.assign((0, codegen_12._)`${evaluated}.items`, items2);
    }
    function schemaKeywords(it3, types2, typeErrors, errsCount) {
      const { gen: gen2, schema, data, allErrors, opts, self: self2 } = it3;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_12.schemaHasRulesButRef)(schema, RULES))) {
        gen2.block(() => keywordCode(it3, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it3, types2);
      gen2.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen2.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it3, group);
          if (types2.length === 1 && types2[0] === group.type && typeErrors) {
            gen2.else();
            (0, dataType_2.reportTypeError)(it3);
          }
          gen2.endIf();
        } else {
          iterateKeywords(it3, group);
        }
        if (!allErrors)
          gen2.if((0, codegen_12._)`${names_12.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it3, group) {
      const { gen: gen2, schema, opts: { useDefaults } } = it3;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it3, group.type);
      gen2.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it3, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it3, types2) {
      if (it3.schemaEnv.meta || !it3.opts.strictTypes)
        return;
      checkContextTypes(it3, types2);
      if (!it3.opts.allowUnionTypes)
        checkMultipleTypes(it3, types2);
      checkKeywordTypes(it3, it3.dataTypes);
    }
    function checkContextTypes(it3, types2) {
      if (!types2.length)
        return;
      if (!it3.dataTypes.length) {
        it3.dataTypes = types2;
        return;
      }
      types2.forEach((t) => {
        if (!includesType(it3.dataTypes, t)) {
          strictTypesError(it3, `type "${t}" not allowed by context "${it3.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it3, types2);
    }
    function checkMultipleTypes(it3, ts2) {
      if (ts2.length > 1 && !(ts2.length === 2 && ts2.includes("null"))) {
        strictTypesError(it3, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it3, ts2) {
      const rules2 = it3.self.RULES.all;
      for (const keyword2 in rules2) {
        const rule = rules2[keyword2];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it3.schema, rule)) {
          const { type: type2 } = rule.definition;
          if (type2.length && !type2.some((t) => hasApplicableType(ts2, t))) {
            strictTypesError(it3, `missing type "${type2.join(",")}" for keyword "${keyword2}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts2, t) {
      return ts2.includes(t) || t === "integer" && ts2.includes("number");
    }
    function narrowSchemaTypes(it3, withTypes) {
      const ts2 = [];
      for (const t of it3.dataTypes) {
        if (includesType(withTypes, t))
          ts2.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts2.push("integer");
      }
      it3.dataTypes = ts2;
    }
    function strictTypesError(it3, msg) {
      const schemaPath = it3.schemaEnv.baseId + it3.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_12.checkStrictMode)(it3, msg, it3.opts.strictTypes);
    }
    class KeywordCxt {
      constructor(it3, def2, keyword2) {
        (0, keyword_1.validateKeywordUsage)(it3, def2, keyword2);
        this.gen = it3.gen;
        this.allErrors = it3.allErrors;
        this.keyword = keyword2;
        this.data = it3.data;
        this.schema = it3.schema[keyword2];
        this.$data = def2.$data && it3.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_12.schemaRefOrVal)(it3, this.schema, keyword2, this.$data);
        this.schemaType = def2.schemaType;
        this.parentSchema = it3.schema;
        this.params = {};
        this.it = it3;
        this.def = def2;
        if (this.$data) {
          this.schemaCode = it3.gen.const("vSchema", getData(this.$data, it3));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def2.schemaType, def2.allowUndefined)) {
            throw new Error(`${keyword2} value must be ${JSON.stringify(def2.schemaType)}`);
          }
        }
        if ("code" in def2 ? def2.trackErrors : def2.errors !== false) {
          this.errsCount = it3.gen.const("_errs", names_12.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_12.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_12.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_12._)`${schemaCode} !== undefined && (${(0, codegen_12.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_12.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_12.nil, $dataValid = codegen_12.nil) {
        if (!this.$data)
          return;
        const { gen: gen2, schemaCode, schemaType, def: def2 } = this;
        gen2.if((0, codegen_12.or)((0, codegen_12._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_12.nil)
          gen2.assign(valid, true);
        if (schemaType.length || def2.validateSchema) {
          gen2.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_12.nil)
            gen2.assign(valid, false);
        }
        gen2.else();
      }
      invalid$data() {
        const { gen: gen2, schemaCode, schemaType, def: def2, it: it3 } = this;
        return (0, codegen_12.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_12.Name))
              throw new Error("ajv implementation error");
            const st3 = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_12._)`${(0, dataType_2.checkDataTypes)(st3, schemaCode, it3.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_12.nil;
        }
        function invalid$DataSchema() {
          if (def2.validateSchema) {
            const validateSchemaRef = gen2.scopeValue("validate$data", { ref: def2.validateSchema });
            return (0, codegen_12._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_12.nil;
        }
      }
      subschema(appl, valid) {
        const subschema2 = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema2, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema2, appl);
        const nextContext = { ...this.it, ...subschema2, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it: it3, gen: gen2 } = this;
        if (!it3.opts.unevaluated)
          return;
        if (it3.props !== true && schemaCxt.props !== void 0) {
          it3.props = util_12.mergeEvaluated.props(gen2, schemaCxt.props, it3.props, toName);
        }
        if (it3.items !== true && schemaCxt.items !== void 0) {
          it3.items = util_12.mergeEvaluated.items(gen2, schemaCxt.items, it3.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it: it3, gen: gen2 } = this;
        if (it3.opts.unevaluated && (it3.props !== true || it3.items !== true)) {
          gen2.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_12.Name));
          return true;
        }
      }
    }
    validate.KeywordCxt = KeywordCxt;
    function keywordCode(it3, keyword2, def2, ruleType) {
      const cxt = new KeywordCxt(it3, def2, keyword2);
      if ("code" in def2) {
        def2.code(cxt, ruleType);
      } else if (cxt.$data && def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      } else if ("macro" in def2) {
        (0, keyword_1.macroKeywordCode)(cxt, def2);
      } else if (def2.compile || def2.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def2);
      }
    }
    const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_12.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_12.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_12._)`${data}${(0, codegen_12.getProperty)((0, util_12.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_12._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    validate.getData = getData;
    return validate;
  }
  var validation_error = {};
  var hasRequiredValidation_error;
  function requireValidation_error() {
    if (hasRequiredValidation_error)
      return validation_error;
    hasRequiredValidation_error = 1;
    Object.defineProperty(validation_error, "__esModule", { value: true });
    class ValidationError extends Error {
      constructor(errors2) {
        super("validation failed");
        this.errors = errors2;
        this.ajv = this.validation = true;
      }
    }
    validation_error.default = ValidationError;
    return validation_error;
  }
  var ref_error = {};
  var hasRequiredRef_error;
  function requireRef_error() {
    if (hasRequiredRef_error)
      return ref_error;
    hasRequiredRef_error = 1;
    Object.defineProperty(ref_error, "__esModule", { value: true });
    const resolve_12 = resolve$1;
    class MissingRefError extends Error {
      constructor(resolver, baseId, ref2, msg) {
        super(msg || `can't resolve reference ${ref2} from id ${baseId}`);
        this.missingRef = (0, resolve_12.resolveUrl)(resolver, baseId, ref2);
        this.missingSchema = (0, resolve_12.normalizeId)((0, resolve_12.getFullPath)(resolver, this.missingRef));
      }
    }
    ref_error.default = MissingRefError;
    return ref_error;
  }
  var compile = {};
  Object.defineProperty(compile, "__esModule", { value: true });
  compile.resolveSchema = compile.getCompilingSchema = compile.resolveRef = compile.compileSchema = compile.SchemaEnv = void 0;
  var codegen_1$q = requireCodegen();
  var validation_error_1 = requireValidation_error();
  var names_1$5 = requireNames();
  var resolve_1 = resolve$1;
  var util_1$o = util;
  var validate_1$1 = requireValidate();
  var SchemaEnv = class {
    constructor(env) {
      var _a2;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
      this.refs = {};
    }
  };
  compile.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen2 = new codegen_1$q.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen2.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1$q._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen2.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen: gen2,
      allErrors: this.opts.allErrors,
      data: names_1$5.default.data,
      parentData: names_1$5.default.parentData,
      parentDataProperty: names_1$5.default.parentDataProperty,
      dataNames: [names_1$5.default.data],
      dataPathArr: [codegen_1$q.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: gen2.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1$q.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1$q.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1$q._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1$1.validateFunctionCode)(schemaCxt);
      gen2.optimize(this.opts.code.optimize);
      const validateCode = gen2.toString();
      sourceCode = `${gen2.scopeRefs(names_1$5.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1$5.default.self}`, `${names_1$5.default.scope}`, sourceCode);
      const validate2 = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate2 });
      validate2.errors = null;
      validate2.schema = sch.schema;
      validate2.schemaEnv = sch;
      if (sch.$async)
        validate2.$async = true;
      if (this.opts.code.source === true) {
        validate2.source = { validateName, validateCode, scopeValues: gen2._values };
      }
      if (this.opts.unevaluated) {
        const { props, items: items2 } = schemaCxt;
        validate2.evaluated = {
          props: props instanceof codegen_1$q.Name ? void 0 : props,
          items: items2 instanceof codegen_1$q.Name ? void 0 : items2,
          dynamicProps: props instanceof codegen_1$q.Name,
          dynamicItems: items2 instanceof codegen_1$q.Name
        };
        if (validate2.source)
          validate2.source.evaluated = (0, codegen_1$q.stringify)(validate2.evaluated);
      }
      sch.validate = validate2;
      return sch;
    } catch (e7) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e7;
    } finally {
      this._compilations.delete(sch);
    }
  }
  compile.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref2) {
    var _a2;
    ref2 = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref2);
    const schOrFunc = root.refs[ref2];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref2);
    if (_sch === void 0) {
      const schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref2];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === void 0)
      return;
    return root.refs[ref2] = inlineOrCompile.call(this, _sch);
  }
  compile.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  compile.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s22) {
    return s1.schema === s22.schema && s1.root === s22.root && s1.baseId === s22.baseId;
  }
  function resolve(root, ref2) {
    let sch;
    while (typeof (sch = this.refs[ref2]) == "string")
      ref2 = sch;
    return sch || this.schemas[ref2] || resolveSchema.call(this, root, ref2);
  }
  function resolveSchema(root, ref2) {
    const p6 = this.opts.uriResolver.parse(ref2);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p6);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p6, root);
    }
    const id3 = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id3] || this.schemas[id3];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p6, sch);
    }
    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id3 === (0, resolve_1.normalizeId)(ref2)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p6, schOrRef);
  }
  compile.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a2;
    if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1$o.unescapeFragment)(part)];
      if (partSchema === void 0)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1$o.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return void 0;
  }
  var $id$g = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
  var description = "Meta-schema for $data reference (JSON AnySchema extension proposal)";
  var type$g = "object";
  var required$1 = [
    "$data"
  ];
  var properties$h = {
    $data: {
      type: "string",
      anyOf: [
        {
          format: "relative-json-pointer"
        },
        {
          format: "json-pointer"
        }
      ]
    }
  };
  var additionalProperties$1 = false;
  var require$$9 = {
    $id: $id$g,
    description,
    type: type$g,
    required: required$1,
    properties: properties$h,
    additionalProperties: additionalProperties$1
  };
  var uri$1 = {};
  var uri_all = { exports: {} };
  (function(module, exports) {
    (function(global2, factory2) {
      factory2(exports);
    })(commonjsGlobal2, function(exports2) {
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl2 = sets.length - 1;
          for (var x6 = 1; x6 < xl2; ++x6) {
            sets[x6] = sets[x6].slice(1, -1);
          }
          sets[xl2] = sets[xl2].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o4) {
        return o4 === void 0 ? "undefined" : o4 === null ? "null" : Object.prototype.toString.call(o4).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray2(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]", DIGIT$$ = "[0-9]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+");
        subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+");
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i4) {
          var _arr = [];
          var _n2 = true;
          var _d2 = false;
          var _e2 = void 0;
          try {
            for (var _i2 = arr[Symbol.iterator](), _s2; !(_n2 = (_s2 = _i2.next()).done); _n2 = true) {
              _arr.push(_s2.value);
              if (i4 && _arr.length === i4)
                break;
            }
          } catch (err) {
            _d2 = true;
            _e2 = err;
          } finally {
            try {
              if (!_n2 && _i2["return"])
                _i2["return"]();
            } finally {
              if (_d2)
                throw _e2;
            }
          }
          return _arr;
        }
        return function(arr, i4) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i4);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i4 = 0, arr2 = Array(arr.length); i4 < arr.length; i4++)
            arr2[i4] = arr[i4];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base3 = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors2 = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base3 - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$12(type2) {
        throw new RangeError(errors2[type2]);
      }
      function map(array, fn2) {
        var result = [];
        var length2 = array.length;
        while (length2--) {
          result[length2] = fn2(array[length2]);
        }
        return result;
      }
      function mapDomain(string3, fn2) {
        var parts = string3.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string3 = parts[1];
        }
        string3 = string3.replace(regexSeparators, ".");
        var labels = string3.split(".");
        var encoded = map(labels, fn2).join(".");
        return result + encoded;
      }
      function ucs2decode(string3) {
        var output2 = [];
        var counter = 0;
        var length2 = string3.length;
        while (counter < length2) {
          var value = string3.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length2) {
            var extra = string3.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output2.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output2.push(value);
              counter--;
            }
          } else {
            output2.push(value);
          }
        }
        return output2;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base3;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k5 = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k5 += base3) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k5 + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode2 = function decode3(input) {
        var output2 = [];
        var inputLength = input.length;
        var i4 = 0;
        var n4 = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j5 = 0; j5 < basic; ++j5) {
          if (input.charCodeAt(j5) >= 128) {
            error$12("not-basic");
          }
          output2.push(input.charCodeAt(j5));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i4;
          for (var w5 = 1, k5 = base3; ; k5 += base3) {
            if (index >= inputLength) {
              error$12("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base3 || digit > floor((maxInt - i4) / w5)) {
              error$12("overflow");
            }
            i4 += digit * w5;
            var t = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base3 - t;
            if (w5 > floor(maxInt / baseMinusT)) {
              error$12("overflow");
            }
            w5 *= baseMinusT;
          }
          var out = output2.length + 1;
          bias = adapt(i4 - oldi, out, oldi == 0);
          if (floor(i4 / out) > maxInt - n4) {
            error$12("overflow");
          }
          n4 += floor(i4 / out);
          i4 %= out;
          output2.splice(i4++, 0, n4);
        }
        return String.fromCodePoint.apply(String, output2);
      };
      var encode2 = function encode3(input) {
        var output2 = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n4 = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output2.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output2.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output2.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m5 = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n4 && currentValue < m5) {
                m5 = currentValue;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m5 - n4 > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$12("overflow");
          }
          delta += (m5 - n4) * handledCPCountPlusOne;
          n4 = m5;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n4 && ++delta > maxInt) {
                error$12("overflow");
              }
              if (_currentValue == n4) {
                var q5 = delta;
                for (var k5 = base3; ; k5 += base3) {
                  var t = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
                  if (q5 < t) {
                    break;
                  }
                  var qMinusT = q5 - t;
                  var baseMinusT = base3 - t;
                  output2.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q5 = floor(qMinusT / baseMinusT);
                }
                output2.push(stringFromCharCode(digitToBasic(q5, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n4;
        }
        return output2.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string3) {
          return regexPunycode.test(string3) ? decode2(string3.slice(4).toLowerCase()) : string3;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string3) {
          return regexNonASCII.test(string3) ? "xn--" + encode2(string3) : string3;
        });
      };
      var punycode = {
        "version": "2.1.0",
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode2,
        "encode": encode2,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c3 = chr.charCodeAt(0);
        var e7 = void 0;
        if (c3 < 16)
          e7 = "%0" + c3.toString(16).toUpperCase();
        else if (c3 < 128)
          e7 = "%" + c3.toString(16).toUpperCase();
        else if (c3 < 2048)
          e7 = "%" + (c3 >> 6 | 192).toString(16).toUpperCase() + "%" + (c3 & 63 | 128).toString(16).toUpperCase();
        else
          e7 = "%" + (c3 >> 12 | 224).toString(16).toUpperCase() + "%" + (c3 >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c3 & 63 | 128).toString(16).toUpperCase();
        return e7;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i4 = 0;
        var il2 = str.length;
        while (i4 < il2) {
          var c3 = parseInt(str.substr(i4 + 1, 2), 16);
          if (c3 < 128) {
            newStr += String.fromCharCode(c3);
            i4 += 3;
          } else if (c3 >= 194 && c3 < 224) {
            if (il2 - i4 >= 6) {
              var c22 = parseInt(str.substr(i4 + 4, 2), 16);
              newStr += String.fromCharCode((c3 & 31) << 6 | c22 & 63);
            } else {
              newStr += str.substr(i4, 6);
            }
            i4 += 6;
          } else if (c3 >= 224) {
            if (il2 - i4 >= 9) {
              var _c2 = parseInt(str.substr(i4 + 4, 2), 16);
              var c32 = parseInt(str.substr(i4 + 7, 2), 16);
              newStr += String.fromCharCode((c3 & 15) << 12 | (_c2 & 63) << 6 | c32 & 63);
            } else {
              newStr += str.substr(i4, 9);
            }
            i4 += 9;
          } else {
            newStr += str.substr(i4, 3);
            i4 += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x6 = 0; x6 < fieldCount; ++x6) {
            fields[x6] = firstFields[x6] || lastFields[lastFieldsStart + x6] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a4, b7) {
            return b7.length - a4.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse2(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e7) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e7;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_5, $1, $22) {
            return "[" + $1 + ($22 ? "%25" + $22 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output2 = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output2.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s3 = im[0];
              input = input.slice(s3.length);
              output2.push(s3);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output2.join("");
      }
      function serialize2(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host))
            ;
          else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e7) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e7;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s3 = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s3 = removeDotSegments(s3);
          }
          if (authority === void 0) {
            s3 = s3.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s3);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base4, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base4 = parse2(serialize2(base4, options), options);
          relative = parse2(serialize2(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base4.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base4.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base4.userinfo !== void 0 || base4.host !== void 0 || base4.port !== void 0) && !base4.path) {
                  target.path = "/" + relative.path;
                } else if (!base4.path) {
                  target.path = relative.path;
                } else {
                  target.path = base4.path.slice(0, base4.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base4.userinfo;
            target.host = base4.host;
            target.port = base4.port;
          }
          target.scheme = base4.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve2(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize2(resolveComponents(parse2(baseURI, schemelessOptions), parse2(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize2(uri2, options) {
        if (typeof uri2 === "string") {
          uri2 = serialize2(parse2(uri2, options), options);
        } else if (typeOf(uri2) === "object") {
          uri2 = parse2(serialize2(uri2, options), options);
        }
        return uri2;
      }
      function equal3(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize2(parse2(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize2(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize2(parse2(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize2(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse3(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize3(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse3(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize3(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O3 = {};
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED2 = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to2 = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x6 = 0, xl2 = hfields.length; x6 < xl2; ++x6) {
              var hfield = hfields[x6].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to2.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to2.length; _x2 < _xl2; ++_x2) {
            var addr = to2[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e7) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e7;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to2[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to2 = toArray2(mailtoComponents.to);
          if (to2) {
            for (var x6 = 0, xl2 = to2.length; x6 < xl2; ++x6) {
              var toAddr = String(to2[x6]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED2, decodeUnreserved).replace(PCT_ENCODED2, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e7) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e7;
              }
              to2[x6] = localPart + "@" + domain;
            }
            components.path = to2.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O3[name]) {
              fields.push(name.replace(PCT_ENCODED2, decodeUnreserved).replace(PCT_ENCODED2, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED2, decodeUnreserved).replace(PCT_ENCODED2, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse3(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize3(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse2;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize2;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve2;
      exports2.normalize = normalize2;
      exports2.equal = equal3;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  })(uri_all, uri_all.exports);
  var uri_allExports = uri_all.exports;
  Object.defineProperty(uri$1, "__esModule", { value: true });
  var uri = uri_allExports;
  uri.code = 'require("ajv/dist/runtime/uri").default';
  uri$1.default = uri;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_12 = requireValidate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_12.KeywordCxt;
    } });
    var codegen_12 = requireCodegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_12._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_12.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_12.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_12.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_12.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_12.CodeGen;
    } });
    const validation_error_12 = requireValidation_error();
    const ref_error_12 = requireRef_error();
    const rules_1 = rules;
    const compile_12 = compile;
    const codegen_2 = requireCodegen();
    const resolve_12 = resolve$1;
    const dataType_12 = dataType;
    const util_12 = util;
    const $dataRefSchema = require$$9;
    const uri_1 = uri$1;
    const defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    const META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    const EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    const removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    const deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    const MAX_EXPRESSION = 200;
    function requiredOptions(o4) {
      var _a2, _b, _c2, _d2, _e2, _f, _g, _h2, _j, _k, _l2, _m, _o2, _p, _q, _r2, _s2, _t3, _u2, _v, _w, _x, _y, _z, _0;
      const s3 = o4.strict;
      const _optz = (_a2 = o4.code) === null || _a2 === void 0 ? void 0 : _a2.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c2 = (_b = o4.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c2 !== void 0 ? _c2 : defaultRegExp;
      const uriResolver = (_d2 = o4.uriResolver) !== null && _d2 !== void 0 ? _d2 : uri_1.default;
      return {
        strictSchema: (_f = (_e2 = o4.strictSchema) !== null && _e2 !== void 0 ? _e2 : s3) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h2 = (_g = o4.strictNumbers) !== null && _g !== void 0 ? _g : s3) !== null && _h2 !== void 0 ? _h2 : true,
        strictTypes: (_k = (_j = o4.strictTypes) !== null && _j !== void 0 ? _j : s3) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l2 = o4.strictTuples) !== null && _l2 !== void 0 ? _l2 : s3) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o2 = o4.strictRequired) !== null && _o2 !== void 0 ? _o2 : s3) !== null && _p !== void 0 ? _p : false,
        code: o4.code ? { ...o4.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o4.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r2 = o4.loopEnum) !== null && _r2 !== void 0 ? _r2 : MAX_EXPRESSION,
        meta: (_s2 = o4.meta) !== null && _s2 !== void 0 ? _s2 : true,
        messages: (_t3 = o4.messages) !== null && _t3 !== void 0 ? _t3 : true,
        inlineRefs: (_u2 = o4.inlineRefs) !== null && _u2 !== void 0 ? _u2 : true,
        schemaId: (_v = o4.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o4.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o4.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o4.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o4.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o4.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    class Ajv2 {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v6;
        if (typeof schemaKeyRef == "string") {
          v6 = this.getSchema(schemaKeyRef);
          if (!v6)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v6 = this.compile(schemaKeyRef);
        }
        const valid = v6(data);
        if (!("$async" in v6))
          this.errors = v6.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e7) {
            if (!(e7 instanceof ref_error_12.default))
              throw e7;
            checkLoaded.call(this, e7);
            await loadMissingSchema.call(this, e7.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref2, missingRef }) {
          if (this.refs[ref2]) {
            throw new Error(`AnySchema ${ref2} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref2) {
          const _schema = await _loadSchema.call(this, ref2);
          if (!this.refs[ref2])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref2])
            this.addSchema(_schema, ref2, meta);
        }
        async function _loadSchema(ref2) {
          const p6 = this._loading[ref2];
          if (p6)
            return p6;
          try {
            return await (this._loading[ref2] = loadSchema(ref2));
          } finally {
            delete this._loading[ref2];
          }
        }
      }
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id3;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id3 = schema[schemaId];
          if (id3 !== void 0 && typeof id3 != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_12.normalizeId)(key || id3);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema2;
        $schema2 = schema.$schema;
        if ($schema2 !== void 0 && typeof $schema2 != "string") {
          throw new Error("$schema must be a string");
        }
        $schema2 = $schema2 || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema2) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema2, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_12.SchemaEnv({ schema: {}, schemaId });
          sch = compile_12.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id3 = schemaKeyRef[this.opts.schemaId];
            if (id3) {
              id3 = (0, resolve_12.normalizeId)(id3);
              delete this.schemas[id3];
              delete this.refs[id3];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      addVocabulary(definitions2) {
        for (const def2 of definitions2)
          this.addKeyword(def2);
        return this;
      }
      addKeyword(kwdOrDef, def2) {
        let keyword2;
        if (typeof kwdOrDef == "string") {
          keyword2 = kwdOrDef;
          if (typeof def2 == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def2.keyword = keyword2;
          }
        } else if (typeof kwdOrDef == "object" && def2 === void 0) {
          def2 = kwdOrDef;
          keyword2 = def2.keyword;
          if (Array.isArray(keyword2) && !keyword2.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword2, def2);
        if (!def2) {
          (0, util_12.eachItem)(keyword2, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def2);
        const definition = {
          ...def2,
          type: (0, dataType_12.getJSONTypes)(def2.type),
          schemaType: (0, dataType_12.getJSONTypes)(def2.schemaType)
        };
        (0, util_12.eachItem)(keyword2, definition.type.length === 0 ? (k5) => addRule.call(this, k5, definition) : (k5) => definition.type.forEach((t) => addRule.call(this, k5, definition, t)));
        return this;
      }
      getKeyword(keyword2) {
        const rule = this.RULES.all[keyword2];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      removeKeyword(keyword2) {
        const { RULES } = this;
        delete RULES.keywords[keyword2];
        delete RULES.all[keyword2];
        for (const group of RULES.rules) {
          const i4 = group.rules.findIndex((rule) => rule.keyword === keyword2);
          if (i4 >= 0)
            group.rules.splice(i4, 1);
        }
        return this;
      }
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors2 = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors2 || errors2.length === 0)
          return "No errors";
        return errors2.map((e7) => `${dataVar}${e7.instancePath} ${e7.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema2, keywordsJsonPointers) {
        const rules2 = this.RULES.all;
        metaSchema2 = JSON.parse(JSON.stringify(metaSchema2));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema2;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules2) {
            const rule = rules2[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema2;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id3;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id3 = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_12.normalizeId)(id3 || baseId);
        const localRefs = resolve_12.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_12.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id3) {
        if (this.schemas[id3] || this.refs[id3]) {
          throw new Error(`schema with key or id "${id3}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_12.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_12.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    }
    exports.default = Ajv2;
    Ajv2.ValidationError = validation_error_12.default;
    Ajv2.MissingRefError = ref_error_12.default;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_12.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword2 in defs) {
        const def2 = defs[keyword2];
        if (!def2.keyword)
          def2.keyword = keyword2;
        this.addKeyword(def2);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    const noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    const KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword2, def2) {
      const { RULES } = this;
      (0, util_12.eachItem)(keyword2, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def2)
        return;
      if (def2.$data && !("code" in def2 || "validate" in def2)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword2, definition, dataType2) {
      var _a2;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType2 && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType2);
      if (!ruleGroup) {
        ruleGroup = { type: dataType2, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword2] = true;
      if (!definition)
        return;
      const rule = {
        keyword: keyword2,
        definition: {
          ...definition,
          type: (0, dataType_12.getJSONTypes)(definition.type),
          schemaType: (0, dataType_12.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword2] = rule;
      (_a2 = definition.implements) === null || _a2 === void 0 ? void 0 : _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i4 = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i4 >= 0) {
        ruleGroup.rules.splice(i4, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def2) {
      let { metaSchema: metaSchema2 } = def2;
      if (metaSchema2 === void 0)
        return;
      if (def2.$data && this.opts.$data)
        metaSchema2 = schemaOrData(metaSchema2);
      def2.validateSchema = this.compile(metaSchema2, true);
    }
    const $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  })(core$4);
  var draft7 = {};
  var core$3 = {};
  var id$1 = {};
  Object.defineProperty(id$1, "__esModule", { value: true });
  var def$B = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  id$1.default = def$B;
  var ref = {};
  Object.defineProperty(ref, "__esModule", { value: true });
  ref.callRef = ref.getValidate = void 0;
  var ref_error_1 = requireRef_error();
  var code_1$8 = requireCode();
  var codegen_1$p = requireCodegen();
  var names_1$4 = requireNames();
  var compile_1$2 = compile;
  var util_1$n = util;
  var def$A = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen: gen2, schema: $ref, it: it3 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it3;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1$2.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === void 0)
        throw new ref_error_1.default(it3.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1$2.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen2.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1$p._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v6 = getValidate(cxt, sch);
        callRef(cxt, v6, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen2.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1$p.stringify)(sch) } : { ref: sch });
        const valid = gen2.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1$p.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen: gen2 } = cxt;
    return sch.validate ? gen2.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1$p._)`${gen2.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  ref.getValidate = getValidate;
  function callRef(cxt, v6, sch, $async) {
    const { gen: gen2, it: it3 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it3;
    const passCxt = opts.passContext ? names_1$4.default.this : codegen_1$p.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen2.let("valid");
      gen2.try(() => {
        gen2.code((0, codegen_1$p._)`await ${(0, code_1$8.callValidateCode)(cxt, v6, passCxt)}`);
        addEvaluatedFrom(v6);
        if (!allErrors)
          gen2.assign(valid, true);
      }, (e7) => {
        gen2.if((0, codegen_1$p._)`!(${e7} instanceof ${it3.ValidationError})`, () => gen2.throw(e7));
        addErrorsFrom(e7);
        if (!allErrors)
          gen2.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1$8.callValidateCode)(cxt, v6, passCxt), () => addEvaluatedFrom(v6), () => addErrorsFrom(v6));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1$p._)`${source}.errors`;
      gen2.assign(names_1$4.default.vErrors, (0, codegen_1$p._)`${names_1$4.default.vErrors} === null ? ${errs} : ${names_1$4.default.vErrors}.concat(${errs})`);
      gen2.assign(names_1$4.default.errors, (0, codegen_1$p._)`${names_1$4.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a2;
      if (!it3.opts.unevaluated)
        return;
      const schEvaluated = (_a2 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
      if (it3.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== void 0) {
            it3.props = util_1$n.mergeEvaluated.props(gen2, schEvaluated.props, it3.props);
          }
        } else {
          const props = gen2.var("props", (0, codegen_1$p._)`${source}.evaluated.props`);
          it3.props = util_1$n.mergeEvaluated.props(gen2, props, it3.props, codegen_1$p.Name);
        }
      }
      if (it3.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== void 0) {
            it3.items = util_1$n.mergeEvaluated.items(gen2, schEvaluated.items, it3.items);
          }
        } else {
          const items2 = gen2.var("items", (0, codegen_1$p._)`${source}.evaluated.items`);
          it3.items = util_1$n.mergeEvaluated.items(gen2, items2, it3.items, codegen_1$p.Name);
        }
      }
    }
  }
  ref.callRef = callRef;
  ref.default = def$A;
  Object.defineProperty(core$3, "__esModule", { value: true });
  var id_1 = id$1;
  var ref_1$2 = ref;
  var core$2 = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1$2.default
  ];
  core$3.default = core$2;
  var validation$3 = {};
  var limitNumber = {};
  Object.defineProperty(limitNumber, "__esModule", { value: true });
  var codegen_1$o = requireCodegen();
  var ops = codegen_1$o.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error$k = {
    message: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o.str)`must be ${KWDs[keyword2].okStr} ${schemaCode}`,
    params: ({ keyword: keyword2, schemaCode }) => (0, codegen_1$o._)`{comparison: ${KWDs[keyword2].okStr}, limit: ${schemaCode}}`
  };
  var def$z = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$k,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1$o._)`${data} ${KWDs[keyword2].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  limitNumber.default = def$z;
  var multipleOf = {};
  Object.defineProperty(multipleOf, "__esModule", { value: true });
  var codegen_1$n = requireCodegen();
  var error$j = {
    message: ({ schemaCode }) => (0, codegen_1$n.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1$n._)`{multipleOf: ${schemaCode}}`
  };
  var def$y = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error: error$j,
    code(cxt) {
      const { gen: gen2, data, schemaCode, it: it3 } = cxt;
      const prec = it3.opts.multipleOfPrecision;
      const res = gen2.let("res");
      const invalid = prec ? (0, codegen_1$n._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1$n._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1$n._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  multipleOf.default = def$y;
  var limitLength = {};
  var ucs2length$1 = {};
  Object.defineProperty(ucs2length$1, "__esModule", { value: true });
  function ucs2length(str) {
    const len = str.length;
    let length2 = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length2++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length2;
  }
  ucs2length$1.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  Object.defineProperty(limitLength, "__esModule", { value: true });
  var codegen_1$m = requireCodegen();
  var util_1$m = util;
  var ucs2length_1 = ucs2length$1;
  var error$i = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxLength" ? "more" : "fewer";
      return (0, codegen_1$m.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1$m._)`{limit: ${schemaCode}}`
  };
  var def$x = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error: error$i,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode, it: it3 } = cxt;
      const op = keyword2 === "maxLength" ? codegen_1$m.operators.GT : codegen_1$m.operators.LT;
      const len = it3.opts.unicode === false ? (0, codegen_1$m._)`${data}.length` : (0, codegen_1$m._)`${(0, util_1$m.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1$m._)`${len} ${op} ${schemaCode}`);
    }
  };
  limitLength.default = def$x;
  var pattern = {};
  Object.defineProperty(pattern, "__esModule", { value: true });
  var code_1$7 = requireCode();
  var codegen_1$l = requireCodegen();
  var error$h = {
    message: ({ schemaCode }) => (0, codegen_1$l.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$l._)`{pattern: ${schemaCode}}`
  };
  var def$w = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error: error$h,
    code(cxt) {
      const { data, $data, schema, schemaCode, it: it3 } = cxt;
      const u4 = it3.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1$l._)`(new RegExp(${schemaCode}, ${u4}))` : (0, code_1$7.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1$l._)`!${regExp}.test(${data})`);
    }
  };
  pattern.default = def$w;
  var limitProperties = {};
  Object.defineProperty(limitProperties, "__esModule", { value: true });
  var codegen_1$k = requireCodegen();
  var error$g = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1$k.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1$k._)`{limit: ${schemaCode}}`
  };
  var def$v = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error: error$g,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      const op = keyword2 === "maxProperties" ? codegen_1$k.operators.GT : codegen_1$k.operators.LT;
      cxt.fail$data((0, codegen_1$k._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  limitProperties.default = def$v;
  var required = {};
  Object.defineProperty(required, "__esModule", { value: true });
  var code_1$6 = requireCode();
  var codegen_1$j = requireCodegen();
  var util_1$l = util;
  var error$f = {
    message: ({ params: { missingProperty } }) => (0, codegen_1$j.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1$j._)`{missingProperty: ${missingProperty}}`
  };
  var def$u = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error: error$f,
    code(cxt) {
      const { gen: gen2, schema, schemaCode, data, $data, it: it3 } = cxt;
      const { opts } = it3;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it3.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
            const schemaPath = it3.schemaEnv.baseId + it3.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1$l.checkStrictMode)(it3, msg, it3.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1$j.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1$6.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen2.let("missing");
        if (useLoop || $data) {
          const valid = gen2.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen2.if((0, code_1$6.checkMissingProp)(cxt, schema, missing));
          (0, code_1$6.reportMissingProp)(cxt, missing);
          gen2.else();
        }
      }
      function loopAllRequired() {
        gen2.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen2.if((0, code_1$6.noPropertyInData)(gen2, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen2.forOf(missing, schemaCode, () => {
          gen2.assign(valid, (0, code_1$6.propertyInData)(gen2, data, missing, opts.ownProperties));
          gen2.if((0, codegen_1$j.not)(valid), () => {
            cxt.error();
            gen2.break();
          });
        }, codegen_1$j.nil);
      }
    }
  };
  required.default = def$u;
  var limitItems = {};
  Object.defineProperty(limitItems, "__esModule", { value: true });
  var codegen_1$i = requireCodegen();
  var error$e = {
    message({ keyword: keyword2, schemaCode }) {
      const comp = keyword2 === "maxItems" ? "more" : "fewer";
      return (0, codegen_1$i.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1$i._)`{limit: ${schemaCode}}`
  };
  var def$t = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error: error$e,
    code(cxt) {
      const { keyword: keyword2, data, schemaCode } = cxt;
      const op = keyword2 === "maxItems" ? codegen_1$i.operators.GT : codegen_1$i.operators.LT;
      cxt.fail$data((0, codegen_1$i._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  limitItems.default = def$t;
  var uniqueItems = {};
  var equal$1 = {};
  Object.defineProperty(equal$1, "__esModule", { value: true });
  var equal2 = fastDeepEqual;
  equal2.code = 'require("ajv/dist/runtime/equal").default';
  equal$1.default = equal2;
  Object.defineProperty(uniqueItems, "__esModule", { value: true });
  var dataType_1 = dataType;
  var codegen_1$h = requireCodegen();
  var util_1$k = util;
  var equal_1$2 = equal$1;
  var error$d = {
    message: ({ params: { i: i4, j: j5 } }) => (0, codegen_1$h.str)`must NOT have duplicate items (items ## ${j5} and ${i4} are identical)`,
    params: ({ params: { i: i4, j: j5 } }) => (0, codegen_1$h._)`{i: ${i4}, j: ${j5}}`
  };
  var def$s = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error: error$d,
    code(cxt) {
      const { gen: gen2, data, $data, schema, parentSchema, schemaCode, it: it3 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen2.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1$h._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i4 = gen2.let("i", (0, codegen_1$h._)`${data}.length`);
        const j5 = gen2.let("j");
        cxt.setParams({ i: i4, j: j5 });
        gen2.assign(valid, true);
        gen2.if((0, codegen_1$h._)`${i4} > 1`, () => (canOptimize() ? loopN : loopN2)(i4, j5));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i4, j5) {
        const item = gen2.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it3.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen2.const("indices", (0, codegen_1$h._)`{}`);
        gen2.for((0, codegen_1$h._)`;${i4}--;`, () => {
          gen2.let(item, (0, codegen_1$h._)`${data}[${i4}]`);
          gen2.if(wrongType, (0, codegen_1$h._)`continue`);
          if (itemTypes.length > 1)
            gen2.if((0, codegen_1$h._)`typeof ${item} == "string"`, (0, codegen_1$h._)`${item} += "_"`);
          gen2.if((0, codegen_1$h._)`typeof ${indices}[${item}] == "number"`, () => {
            gen2.assign(j5, (0, codegen_1$h._)`${indices}[${item}]`);
            cxt.error();
            gen2.assign(valid, false).break();
          }).code((0, codegen_1$h._)`${indices}[${item}] = ${i4}`);
        });
      }
      function loopN2(i4, j5) {
        const eql = (0, util_1$k.useFunc)(gen2, equal_1$2.default);
        const outer = gen2.name("outer");
        gen2.label(outer).for((0, codegen_1$h._)`;${i4}--;`, () => gen2.for((0, codegen_1$h._)`${j5} = ${i4}; ${j5}--;`, () => gen2.if((0, codegen_1$h._)`${eql}(${data}[${i4}], ${data}[${j5}])`, () => {
          cxt.error();
          gen2.assign(valid, false).break(outer);
        })));
      }
    }
  };
  uniqueItems.default = def$s;
  var _const = {};
  Object.defineProperty(_const, "__esModule", { value: true });
  var codegen_1$g = requireCodegen();
  var util_1$j = util;
  var equal_1$1 = equal$1;
  var error$c = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1$g._)`{allowedValue: ${schemaCode}}`
  };
  var def$r = {
    keyword: "const",
    $data: true,
    error: error$c,
    code(cxt) {
      const { gen: gen2, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1$g._)`!${(0, util_1$j.useFunc)(gen2, equal_1$1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1$g._)`${schema} !== ${data}`);
      }
    }
  };
  _const.default = def$r;
  var _enum = {};
  Object.defineProperty(_enum, "__esModule", { value: true });
  var codegen_1$f = requireCodegen();
  var util_1$i = util;
  var equal_1 = equal$1;
  var error$b = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1$f._)`{allowedValues: ${schemaCode}}`
  };
  var def$q = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error: error$b,
    code(cxt) {
      const { gen: gen2, data, $data, schema, schemaCode, it: it3 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it3.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1$i.useFunc)(gen2, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen2.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen2.const("vSchema", schemaCode);
        valid = (0, codegen_1$f.or)(...schema.map((_x, i4) => equalCode(vSchema, i4)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen2.assign(valid, false);
        gen2.forOf("v", schemaCode, (v6) => gen2.if((0, codegen_1$f._)`${getEql()}(${data}, ${v6})`, () => gen2.assign(valid, true).break()));
      }
      function equalCode(vSchema, i4) {
        const sch = schema[i4];
        return typeof sch === "object" && sch !== null ? (0, codegen_1$f._)`${getEql()}(${data}, ${vSchema}[${i4}])` : (0, codegen_1$f._)`${data} === ${sch}`;
      }
    }
  };
  _enum.default = def$q;
  Object.defineProperty(validation$3, "__esModule", { value: true });
  var limitNumber_1 = limitNumber;
  var multipleOf_1 = multipleOf;
  var limitLength_1 = limitLength;
  var pattern_1 = pattern;
  var limitProperties_1 = limitProperties;
  var required_1 = required;
  var limitItems_1 = limitItems;
  var uniqueItems_1 = uniqueItems;
  var const_1 = _const;
  var enum_1 = _enum;
  var validation$2 = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  validation$3.default = validation$2;
  var applicator$2 = {};
  var additionalItems = {};
  Object.defineProperty(additionalItems, "__esModule", { value: true });
  additionalItems.validateAdditionalItems = void 0;
  var codegen_1$e = requireCodegen();
  var util_1$h = util;
  var error$a = {
    message: ({ params: { len } }) => (0, codegen_1$e.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$e._)`{limit: ${len}}`
  };
  var def$p = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: error$a,
    code(cxt) {
      const { parentSchema, it: it3 } = cxt;
      const { items: items2 } = parentSchema;
      if (!Array.isArray(items2)) {
        (0, util_1$h.checkStrictMode)(it3, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items2);
    }
  };
  function validateAdditionalItems(cxt, items2) {
    const { gen: gen2, schema, data, keyword: keyword2, it: it3 } = cxt;
    it3.items = true;
    const len = gen2.const("len", (0, codegen_1$e._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items2.length });
      cxt.pass((0, codegen_1$e._)`${len} <= ${items2.length}`);
    } else if (typeof schema == "object" && !(0, util_1$h.alwaysValidSchema)(it3, schema)) {
      const valid = gen2.var("valid", (0, codegen_1$e._)`${len} <= ${items2.length}`);
      gen2.if((0, codegen_1$e.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen2.forRange("i", items2.length, len, (i4) => {
        cxt.subschema({ keyword: keyword2, dataProp: i4, dataPropType: util_1$h.Type.Num }, valid);
        if (!it3.allErrors)
          gen2.if((0, codegen_1$e.not)(valid), () => gen2.break());
      });
    }
  }
  additionalItems.validateAdditionalItems = validateAdditionalItems;
  additionalItems.default = def$p;
  var prefixItems = {};
  var items = {};
  Object.defineProperty(items, "__esModule", { value: true });
  items.validateTuple = void 0;
  var codegen_1$d = requireCodegen();
  var util_1$g = util;
  var code_1$5 = requireCode();
  var def$o = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it3 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it3.items = true;
      if ((0, util_1$g.alwaysValidSchema)(it3, schema))
        return;
      cxt.ok((0, code_1$5.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen: gen2, parentSchema, data, keyword: keyword2, it: it3 } = cxt;
    checkStrictTuple(parentSchema);
    if (it3.opts.unevaluated && schArr.length && it3.items !== true) {
      it3.items = util_1$g.mergeEvaluated.items(gen2, schArr.length, it3.items);
    }
    const valid = gen2.name("valid");
    const len = gen2.const("len", (0, codegen_1$d._)`${data}.length`);
    schArr.forEach((sch, i4) => {
      if ((0, util_1$g.alwaysValidSchema)(it3, sch))
        return;
      gen2.if((0, codegen_1$d._)`${len} > ${i4}`, () => cxt.subschema({
        keyword: keyword2,
        schemaProp: i4,
        dataProp: i4
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it3;
      const l6 = schArr.length;
      const fullTuple = l6 === sch.minItems && (l6 === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword2}" is ${l6}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1$g.checkStrictMode)(it3, msg, opts.strictTuples);
      }
    }
  }
  items.validateTuple = validateTuple;
  items.default = def$o;
  Object.defineProperty(prefixItems, "__esModule", { value: true });
  var items_1$1 = items;
  var def$n = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1$1.validateTuple)(cxt, "items")
  };
  prefixItems.default = def$n;
  var items2020 = {};
  Object.defineProperty(items2020, "__esModule", { value: true });
  var codegen_1$c = requireCodegen();
  var util_1$f = util;
  var code_1$4 = requireCode();
  var additionalItems_1$1 = additionalItems;
  var error$9 = {
    message: ({ params: { len } }) => (0, codegen_1$c.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1$c._)`{limit: ${len}}`
  };
  var def$m = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: error$9,
    code(cxt) {
      const { schema, parentSchema, it: it3 } = cxt;
      const { prefixItems: prefixItems2 } = parentSchema;
      it3.items = true;
      if ((0, util_1$f.alwaysValidSchema)(it3, schema))
        return;
      if (prefixItems2)
        (0, additionalItems_1$1.validateAdditionalItems)(cxt, prefixItems2);
      else
        cxt.ok((0, code_1$4.validateArray)(cxt));
    }
  };
  items2020.default = def$m;
  var contains = {};
  Object.defineProperty(contains, "__esModule", { value: true });
  var codegen_1$b = requireCodegen();
  var util_1$e = util;
  var error$8 = {
    message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b.str)`must contain at least ${min} valid item(s)` : (0, codegen_1$b.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1$b._)`{minContains: ${min}}` : (0, codegen_1$b._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def$l = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error: error$8,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data, it: it3 } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it3.opts.next) {
        min = minContains === void 0 ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen2.const("len", (0, codegen_1$b._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === void 0 && min === 0) {
        (0, util_1$e.checkStrictMode)(it3, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== void 0 && min > max) {
        (0, util_1$e.checkStrictMode)(it3, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1$e.alwaysValidSchema)(it3, schema)) {
        let cond = (0, codegen_1$b._)`${len} >= ${min}`;
        if (max !== void 0)
          cond = (0, codegen_1$b._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it3.items = true;
      const valid = gen2.name("valid");
      if (max === void 0 && min === 1) {
        validateItems(valid, () => gen2.if(valid, () => gen2.break()));
      } else if (min === 0) {
        gen2.let(valid, true);
        if (max !== void 0)
          gen2.if((0, codegen_1$b._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen2.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen2.name("_valid");
        const count = gen2.let("count", 0);
        validateItems(schValid, () => gen2.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen2.forRange("i", 0, len, (i4) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i4,
            dataPropType: util_1$e.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen2.code((0, codegen_1$b._)`${count}++`);
        if (max === void 0) {
          gen2.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen2.assign(valid, true).break());
        } else {
          gen2.if((0, codegen_1$b._)`${count} > ${max}`, () => gen2.assign(valid, false).break());
          if (min === 1)
            gen2.assign(valid, true);
          else
            gen2.if((0, codegen_1$b._)`${count} >= ${min}`, () => gen2.assign(valid, true));
        }
      }
    }
  };
  contains.default = def$l;
  var dependencies = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    const codegen_12 = requireCodegen();
    const util_12 = util;
    const code_12 = requireCode();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_12.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_12._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
    };
    const def2 = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen: gen2, data, it: it3 } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen2.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_12.propertyInData)(gen2, data, prop, it3.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it3.allErrors) {
          gen2.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_12.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen2.if((0, codegen_12._)`${hasProperty} && (${(0, code_12.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_12.reportMissingProp)(cxt, missing);
          gen2.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen: gen2, data, keyword: keyword2, it: it3 } = cxt;
      const valid = gen2.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_12.alwaysValidSchema)(it3, schemaDeps[prop]))
          continue;
        gen2.if(
          (0, code_12.propertyInData)(gen2, data, prop, it3.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword: keyword2, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen2.var(valid, true)
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def2;
  })(dependencies);
  var propertyNames = {};
  Object.defineProperty(propertyNames, "__esModule", { value: true });
  var codegen_1$a = requireCodegen();
  var util_1$d = util;
  var error$7 = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1$a._)`{propertyName: ${params.propertyName}}`
  };
  var def$k = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: error$7,
    code(cxt) {
      const { gen: gen2, schema, data, it: it3 } = cxt;
      if ((0, util_1$d.alwaysValidSchema)(it3, schema))
        return;
      const valid = gen2.name("valid");
      gen2.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen2.if((0, codegen_1$a.not)(valid), () => {
          cxt.error(true);
          if (!it3.allErrors)
            gen2.break();
        });
      });
      cxt.ok(valid);
    }
  };
  propertyNames.default = def$k;
  var additionalProperties = {};
  Object.defineProperty(additionalProperties, "__esModule", { value: true });
  var code_1$3 = requireCode();
  var codegen_1$9 = requireCodegen();
  var names_1$3 = requireNames();
  var util_1$c = util;
  var error$6 = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1$9._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def$j = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error: error$6,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data, errsCount, it: it3 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it3;
      it3.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1$c.alwaysValidSchema)(it3, schema))
        return;
      const props = (0, code_1$3.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1$3.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1$9._)`${errsCount} === ${names_1$3.default.errors}`);
      function checkAdditionalProperties() {
        gen2.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen2.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1$c.schemaRefOrVal)(it3, parentSchema.properties, "properties");
          definedProp = (0, code_1$3.isOwnProperty)(gen2, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1$9.or)(...props.map((p6) => (0, codegen_1$9._)`${key} === ${p6}`));
        } else {
          definedProp = codegen_1$9.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1$9.or)(definedProp, ...patProps.map((p6) => (0, codegen_1$9._)`${(0, code_1$3.usePattern)(cxt, p6)}.test(${key})`));
        }
        return (0, codegen_1$9.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen2.code((0, codegen_1$9._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen2.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1$c.alwaysValidSchema)(it3, schema)) {
          const valid = gen2.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen2.if((0, codegen_1$9.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen2.if((0, codegen_1$9.not)(valid), () => gen2.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors2) {
        const subschema2 = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1$c.Type.Str
        };
        if (errors2 === false) {
          Object.assign(subschema2, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema2, valid);
      }
    }
  };
  additionalProperties.default = def$j;
  var properties$g = {};
  Object.defineProperty(properties$g, "__esModule", { value: true });
  var validate_1 = requireValidate();
  var code_1$2 = requireCode();
  var util_1$b = util;
  var additionalProperties_1$1 = additionalProperties;
  var def$i = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen: gen2, schema, parentSchema, data, it: it3 } = cxt;
      if (it3.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
        additionalProperties_1$1.default.code(new validate_1.KeywordCxt(it3, additionalProperties_1$1.default, "additionalProperties"));
      }
      const allProps = (0, code_1$2.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it3.definedProperties.add(prop);
      }
      if (it3.opts.unevaluated && allProps.length && it3.props !== true) {
        it3.props = util_1$b.mergeEvaluated.props(gen2, (0, util_1$b.toHash)(allProps), it3.props);
      }
      const properties2 = allProps.filter((p6) => !(0, util_1$b.alwaysValidSchema)(it3, schema[p6]));
      if (properties2.length === 0)
        return;
      const valid = gen2.name("valid");
      for (const prop of properties2) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen2.if((0, code_1$2.propertyInData)(gen2, data, prop, it3.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it3.allErrors)
            gen2.else().var(valid, true);
          gen2.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it3.opts.useDefaults && !it3.compositeRule && schema[prop].default !== void 0;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  properties$g.default = def$i;
  var patternProperties = {};
  Object.defineProperty(patternProperties, "__esModule", { value: true });
  var code_1$1 = requireCode();
  var codegen_1$8 = requireCodegen();
  var util_1$a = util;
  var util_2 = util;
  var def$h = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen: gen2, schema, data, parentSchema, it: it3 } = cxt;
      const { opts } = it3;
      const patterns = (0, code_1$1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p6) => (0, util_1$a.alwaysValidSchema)(it3, schema[p6]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it3.opts.unevaluated || it3.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen2.name("valid");
      if (it3.props !== true && !(it3.props instanceof codegen_1$8.Name)) {
        it3.props = (0, util_2.evaluatedPropsToName)(gen2, it3.props);
      }
      const { props } = it3;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it3.allErrors) {
            validateProperties(pat);
          } else {
            gen2.var(valid, true);
            validateProperties(pat);
            gen2.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1$a.checkStrictMode)(it3, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen2.forIn("key", data, (key) => {
          gen2.if((0, codegen_1$8._)`${(0, code_1$1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it3.opts.unevaluated && props !== true) {
              gen2.assign((0, codegen_1$8._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it3.allErrors) {
              gen2.if((0, codegen_1$8.not)(valid), () => gen2.break());
            }
          });
        });
      }
    }
  };
  patternProperties.default = def$h;
  var not = {};
  Object.defineProperty(not, "__esModule", { value: true });
  var util_1$9 = util;
  var def$g = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen: gen2, schema, it: it3 } = cxt;
      if ((0, util_1$9.alwaysValidSchema)(it3, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen2.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  not.default = def$g;
  var anyOf = {};
  Object.defineProperty(anyOf, "__esModule", { value: true });
  var code_1 = requireCode();
  var def$f = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  anyOf.default = def$f;
  var oneOf = {};
  Object.defineProperty(oneOf, "__esModule", { value: true });
  var codegen_1$7 = requireCodegen();
  var util_1$8 = util;
  var error$5 = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1$7._)`{passingSchemas: ${params.passing}}`
  };
  var def$e = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error: error$5,
    code(cxt) {
      const { gen: gen2, schema, parentSchema, it: it3 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it3.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen2.let("valid", false);
      const passing = gen2.let("passing", null);
      const schValid = gen2.name("_valid");
      cxt.setParams({ passing });
      gen2.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i4) => {
          let schCxt;
          if ((0, util_1$8.alwaysValidSchema)(it3, sch)) {
            gen2.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i4,
              compositeRule: true
            }, schValid);
          }
          if (i4 > 0) {
            gen2.if((0, codegen_1$7._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1$7._)`[${passing}, ${i4}]`).else();
          }
          gen2.if(schValid, () => {
            gen2.assign(valid, true);
            gen2.assign(passing, i4);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1$7.Name);
          });
        });
      }
    }
  };
  oneOf.default = def$e;
  var allOf$2 = {};
  Object.defineProperty(allOf$2, "__esModule", { value: true });
  var util_1$7 = util;
  var def$d = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen: gen2, schema, it: it3 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen2.name("valid");
      schema.forEach((sch, i4) => {
        if ((0, util_1$7.alwaysValidSchema)(it3, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i4 }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  allOf$2.default = def$d;
  var _if = {};
  Object.defineProperty(_if, "__esModule", { value: true });
  var codegen_1$6 = requireCodegen();
  var util_1$6 = util;
  var error$4 = {
    message: ({ params }) => (0, codegen_1$6.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1$6._)`{failingKeyword: ${params.ifClause}}`
  };
  var def$c = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error: error$4,
    code(cxt) {
      const { gen: gen2, parentSchema, it: it3 } = cxt;
      if (parentSchema.then === void 0 && parentSchema.else === void 0) {
        (0, util_1$6.checkStrictMode)(it3, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it3, "then");
      const hasElse = hasSchema(it3, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen2.let("valid", true);
      const schValid = gen2.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen2.let("ifClause");
        cxt.setParams({ ifClause });
        gen2.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen2.if(schValid, validateClause("then"));
      } else {
        gen2.if((0, codegen_1$6.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword2, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword: keyword2 }, schValid);
          gen2.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen2.assign(ifClause, (0, codegen_1$6._)`${keyword2}`);
          else
            cxt.setParams({ ifClause: keyword2 });
        };
      }
    }
  };
  function hasSchema(it3, keyword2) {
    const schema = it3.schema[keyword2];
    return schema !== void 0 && !(0, util_1$6.alwaysValidSchema)(it3, schema);
  }
  _if.default = def$c;
  var thenElse = {};
  Object.defineProperty(thenElse, "__esModule", { value: true });
  var util_1$5 = util;
  var def$b = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: keyword2, parentSchema, it: it3 }) {
      if (parentSchema.if === void 0)
        (0, util_1$5.checkStrictMode)(it3, `"${keyword2}" without "if" is ignored`);
    }
  };
  thenElse.default = def$b;
  Object.defineProperty(applicator$2, "__esModule", { value: true });
  var additionalItems_1 = additionalItems;
  var prefixItems_1 = prefixItems;
  var items_1 = items;
  var items2020_1 = items2020;
  var contains_1 = contains;
  var dependencies_1$2 = dependencies;
  var propertyNames_1 = propertyNames;
  var additionalProperties_1 = additionalProperties;
  var properties_1 = properties$g;
  var patternProperties_1 = patternProperties;
  var not_1 = not;
  var anyOf_1 = anyOf;
  var oneOf_1 = oneOf;
  var allOf_1 = allOf$2;
  var if_1 = _if;
  var thenElse_1 = thenElse;
  function getApplicator(draft20202 = false) {
    const applicator2 = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1$2.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft20202)
      applicator2.push(prefixItems_1.default, items2020_1.default);
    else
      applicator2.push(additionalItems_1.default, items_1.default);
    applicator2.push(contains_1.default);
    return applicator2;
  }
  applicator$2.default = getApplicator;
  var format$4 = {};
  var format$3 = {};
  Object.defineProperty(format$3, "__esModule", { value: true });
  var codegen_1$5 = requireCodegen();
  var error$3 = {
    message: ({ schemaCode }) => (0, codegen_1$5.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1$5._)`{format: ${schemaCode}}`
  };
  var def$a = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error: error$3,
    code(cxt, ruleType) {
      const { gen: gen2, data, $data, schema, schemaCode, it: it3 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it3;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen2.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen2.const("fDef", (0, codegen_1$5._)`${fmts}[${schemaCode}]`);
        const fType = gen2.let("fType");
        const format2 = gen2.let("format");
        gen2.if((0, codegen_1$5._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen2.assign(fType, (0, codegen_1$5._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1$5._)`${fDef}.validate`), () => gen2.assign(fType, (0, codegen_1$5._)`"string"`).assign(format2, fDef));
        cxt.fail$data((0, codegen_1$5.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1$5.nil;
          return (0, codegen_1$5._)`${schemaCode} && !${format2}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1$5._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1$5._)`${format2}(${data})`;
          const validData = (0, codegen_1$5._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
          return (0, codegen_1$5._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format2, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code2 = fmtDef instanceof RegExp ? (0, codegen_1$5.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1$5._)`${opts.code.formats}${(0, codegen_1$5.getProperty)(schema)}` : void 0;
          const fmt = gen2.scopeValue("formats", { key: schema, ref: fmtDef, code: code2 });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1$5._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1$5._)`await ${fmtRef}(${data})`;
          }
          return typeof format2 == "function" ? (0, codegen_1$5._)`${fmtRef}(${data})` : (0, codegen_1$5._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  format$3.default = def$a;
  Object.defineProperty(format$4, "__esModule", { value: true });
  var format_1$2 = format$3;
  var format$2 = [format_1$2.default];
  format$4.default = format$2;
  var metadata$2 = {};
  Object.defineProperty(metadata$2, "__esModule", { value: true });
  metadata$2.contentVocabulary = metadata$2.metadataVocabulary = void 0;
  metadata$2.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  metadata$2.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
  Object.defineProperty(draft7, "__esModule", { value: true });
  var core_1$1 = core$3;
  var validation_1$1 = validation$3;
  var applicator_1$1 = applicator$2;
  var format_1$1 = format$4;
  var metadata_1$1 = metadata$2;
  var draft7Vocabularies = [
    core_1$1.default,
    validation_1$1.default,
    (0, applicator_1$1.default)(),
    format_1$1.default,
    metadata_1$1.metadataVocabulary,
    metadata_1$1.contentVocabulary
  ];
  draft7.default = draft7Vocabularies;
  var discriminator = {};
  var types = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    (function(DiscrError) {
      DiscrError["Tag"] = "tag";
      DiscrError["Mapping"] = "mapping";
    })(exports.DiscrError || (exports.DiscrError = {}));
  })(types);
  Object.defineProperty(discriminator, "__esModule", { value: true });
  var codegen_1$4 = requireCodegen();
  var types_1 = types;
  var compile_1$1 = compile;
  var util_1$4 = util;
  var error$2 = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1$4._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def$9 = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: error$2,
    code(cxt) {
      const { gen: gen2, data, schema, parentSchema, it: it3 } = cxt;
      const { oneOf: oneOf2 } = parentSchema;
      if (!it3.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf2)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen2.let("valid", false);
      const tag = gen2.const("tag", (0, codegen_1$4._)`${data}${(0, codegen_1$4.getProperty)(tagName)}`);
      gen2.if((0, codegen_1$4._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen2.if(false);
        for (const tagValue in mapping) {
          gen2.elseIf((0, codegen_1$4._)`${tag} === ${tagValue}`);
          gen2.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen2.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen2.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen2.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1$4.Name);
        return _valid;
      }
      function getMapping() {
        var _a2;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i4 = 0; i4 < oneOf2.length; i4++) {
          let sch = oneOf2[i4];
          if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1$4.schemaHasRulesButRef)(sch, it3.self.RULES)) {
            sch = compile_1$1.resolveRef.call(it3.self, it3.schemaEnv.root, it3.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);
            if (sch instanceof compile_1$1.SchemaEnv)
              sch = sch.schema;
          }
          const propSch = (_a2 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i4);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required: required2 }) {
          return Array.isArray(required2) && required2.includes(tagName);
        }
        function addMappings(sch, i4) {
          if (sch.const) {
            addMapping(sch.const, i4);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i4);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i4) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i4;
        }
      }
    }
  };
  discriminator.default = def$9;
  var $schema$f = "http://json-schema.org/draft-07/schema#";
  var $id$f = "http://json-schema.org/draft-07/schema#";
  var title$f = "Core schema meta-schema";
  var definitions = {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: {
        $ref: "#"
      }
    },
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      allOf: [
        {
          $ref: "#/definitions/nonNegativeInteger"
        },
        {
          "default": 0
        }
      ]
    },
    simpleTypes: {
      "enum": [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true,
      "default": []
    }
  };
  var type$f = [
    "object",
    "boolean"
  ];
  var properties$f = {
    $id: {
      type: "string",
      format: "uri-reference"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $comment: {
      type: "string"
    },
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    "default": true,
    readOnly: {
      type: "boolean",
      "default": false
    },
    examples: {
      type: "array",
      items: true
    },
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: {
      $ref: "#/definitions/nonNegativeInteger"
    },
    minLength: {
      $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    pattern: {
      type: "string",
      format: "regex"
    },
    additionalItems: {
      $ref: "#"
    },
    items: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/schemaArray"
        }
      ],
      "default": true
    },
    maxItems: {
      $ref: "#/definitions/nonNegativeInteger"
    },
    minItems: {
      $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    uniqueItems: {
      type: "boolean",
      "default": false
    },
    contains: {
      $ref: "#"
    },
    maxProperties: {
      $ref: "#/definitions/nonNegativeInteger"
    },
    minProperties: {
      $ref: "#/definitions/nonNegativeIntegerDefault0"
    },
    required: {
      $ref: "#/definitions/stringArray"
    },
    additionalProperties: {
      $ref: "#"
    },
    definitions: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      "default": {}
    },
    properties: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      "default": {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      propertyNames: {
        format: "regex"
      },
      "default": {}
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [
          {
            $ref: "#"
          },
          {
            $ref: "#/definitions/stringArray"
          }
        ]
      }
    },
    propertyNames: {
      $ref: "#"
    },
    "const": true,
    "enum": {
      type: "array",
      items: true,
      minItems: 1,
      uniqueItems: true
    },
    type: {
      anyOf: [
        {
          $ref: "#/definitions/simpleTypes"
        },
        {
          type: "array",
          items: {
            $ref: "#/definitions/simpleTypes"
          },
          minItems: 1,
          uniqueItems: true
        }
      ]
    },
    format: {
      type: "string"
    },
    contentMediaType: {
      type: "string"
    },
    contentEncoding: {
      type: "string"
    },
    "if": {
      $ref: "#"
    },
    then: {
      $ref: "#"
    },
    "else": {
      $ref: "#"
    },
    allOf: {
      $ref: "#/definitions/schemaArray"
    },
    anyOf: {
      $ref: "#/definitions/schemaArray"
    },
    oneOf: {
      $ref: "#/definitions/schemaArray"
    },
    not: {
      $ref: "#"
    }
  };
  var require$$3$2 = {
    $schema: $schema$f,
    $id: $id$f,
    title: title$f,
    definitions,
    type: type$f,
    properties: properties$f,
    "default": true
  };
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    const core_12 = core$4;
    const draft7_1 = draft7;
    const discriminator_1 = discriminator;
    const draft7MetaSchema = require$$3$2;
    const META_SUPPORT_DATA2 = ["/properties"];
    const META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    class Ajv2 extends core_12.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v6) => this.addVocabulary(v6));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema2 = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA2) : draft7MetaSchema;
        this.addMetaSchema(metaSchema2, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    module.exports = exports = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_12 = requireValidate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_12.KeywordCxt;
    } });
    var codegen_12 = requireCodegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_12._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_12.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_12.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_12.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_12.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_12.CodeGen;
    } });
    var validation_error_12 = requireValidation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_12.default;
    } });
    var ref_error_12 = requireRef_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_12.default;
    } });
  })(ajv, ajv.exports);
  var ajvExports = ajv.exports;
  var Ajv = /* @__PURE__ */ getDefaultExportFromCjs(ajvExports);
  var _2020 = { exports: {} };
  var draft2020 = {};
  var dynamic$1 = {};
  var dynamicAnchor$1 = {};
  Object.defineProperty(dynamicAnchor$1, "__esModule", { value: true });
  dynamicAnchor$1.dynamicAnchor = void 0;
  var codegen_1$3 = requireCodegen();
  var names_1$2 = requireNames();
  var compile_1 = compile;
  var ref_1$1 = ref;
  var def$8 = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (cxt) => dynamicAnchor(cxt, cxt.schema)
  };
  function dynamicAnchor(cxt, anchor) {
    const { gen: gen2, it: it3 } = cxt;
    it3.schemaEnv.root.dynamicAnchors[anchor] = true;
    const v6 = (0, codegen_1$3._)`${names_1$2.default.dynamicAnchors}${(0, codegen_1$3.getProperty)(anchor)}`;
    const validate2 = it3.errSchemaPath === "#" ? it3.validateName : _getValidate(cxt);
    gen2.if((0, codegen_1$3._)`!${v6}`, () => gen2.assign(v6, validate2));
  }
  dynamicAnchor$1.dynamicAnchor = dynamicAnchor;
  function _getValidate(cxt) {
    const { schemaEnv, schema, self: self2 } = cxt.it;
    const { root, baseId, localRefs, meta } = schemaEnv.root;
    const { schemaId } = self2.opts;
    const sch = new compile_1.SchemaEnv({ schema, schemaId, root, baseId, localRefs, meta });
    compile_1.compileSchema.call(self2, sch);
    return (0, ref_1$1.getValidate)(cxt, sch);
  }
  dynamicAnchor$1.default = def$8;
  var dynamicRef$1 = {};
  Object.defineProperty(dynamicRef$1, "__esModule", { value: true });
  dynamicRef$1.dynamicRef = void 0;
  var codegen_1$2 = requireCodegen();
  var names_1$1 = requireNames();
  var ref_1 = ref;
  var def$7 = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (cxt) => dynamicRef(cxt, cxt.schema)
  };
  function dynamicRef(cxt, ref2) {
    const { gen: gen2, keyword: keyword2, it: it3 } = cxt;
    if (ref2[0] !== "#")
      throw new Error(`"${keyword2}" only supports hash fragment reference`);
    const anchor = ref2.slice(1);
    if (it3.allErrors) {
      _dynamicRef();
    } else {
      const valid = gen2.let("valid", false);
      _dynamicRef(valid);
      cxt.ok(valid);
    }
    function _dynamicRef(valid) {
      if (it3.schemaEnv.root.dynamicAnchors[anchor]) {
        const v6 = gen2.let("_v", (0, codegen_1$2._)`${names_1$1.default.dynamicAnchors}${(0, codegen_1$2.getProperty)(anchor)}`);
        gen2.if(v6, _callRef(v6, valid), _callRef(it3.validateName, valid));
      } else {
        _callRef(it3.validateName, valid)();
      }
    }
    function _callRef(validate2, valid) {
      return valid ? () => gen2.block(() => {
        (0, ref_1.callRef)(cxt, validate2);
        gen2.let(valid, true);
      }) : () => (0, ref_1.callRef)(cxt, validate2);
    }
  }
  dynamicRef$1.dynamicRef = dynamicRef;
  dynamicRef$1.default = def$7;
  var recursiveAnchor = {};
  Object.defineProperty(recursiveAnchor, "__esModule", { value: true });
  var dynamicAnchor_1$1 = dynamicAnchor$1;
  var util_1$3 = util;
  var def$6 = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(cxt) {
      if (cxt.schema)
        (0, dynamicAnchor_1$1.dynamicAnchor)(cxt, "");
      else
        (0, util_1$3.checkStrictMode)(cxt.it, "$recursiveAnchor: false is ignored");
    }
  };
  recursiveAnchor.default = def$6;
  var recursiveRef = {};
  Object.defineProperty(recursiveRef, "__esModule", { value: true });
  var dynamicRef_1$1 = dynamicRef$1;
  var def$5 = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (cxt) => (0, dynamicRef_1$1.dynamicRef)(cxt, cxt.schema)
  };
  recursiveRef.default = def$5;
  Object.defineProperty(dynamic$1, "__esModule", { value: true });
  var dynamicAnchor_1 = dynamicAnchor$1;
  var dynamicRef_1 = dynamicRef$1;
  var recursiveAnchor_1 = recursiveAnchor;
  var recursiveRef_1 = recursiveRef;
  var dynamic = [dynamicAnchor_1.default, dynamicRef_1.default, recursiveAnchor_1.default, recursiveRef_1.default];
  dynamic$1.default = dynamic;
  var next$1 = {};
  var dependentRequired = {};
  Object.defineProperty(dependentRequired, "__esModule", { value: true });
  var dependencies_1$1 = dependencies;
  var def$4 = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: dependencies_1$1.error,
    code: (cxt) => (0, dependencies_1$1.validatePropertyDeps)(cxt)
  };
  dependentRequired.default = def$4;
  var dependentSchemas = {};
  Object.defineProperty(dependentSchemas, "__esModule", { value: true });
  var dependencies_1 = dependencies;
  var def$3 = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (cxt) => (0, dependencies_1.validateSchemaDeps)(cxt)
  };
  dependentSchemas.default = def$3;
  var limitContains = {};
  Object.defineProperty(limitContains, "__esModule", { value: true });
  var util_1$2 = util;
  var def$2 = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: keyword2, parentSchema, it: it3 }) {
      if (parentSchema.contains === void 0) {
        (0, util_1$2.checkStrictMode)(it3, `"${keyword2}" without "contains" is ignored`);
      }
    }
  };
  limitContains.default = def$2;
  Object.defineProperty(next$1, "__esModule", { value: true });
  var dependentRequired_1 = dependentRequired;
  var dependentSchemas_1 = dependentSchemas;
  var limitContains_1 = limitContains;
  var next = [dependentRequired_1.default, dependentSchemas_1.default, limitContains_1.default];
  next$1.default = next;
  var unevaluated$2 = {};
  var unevaluatedProperties = {};
  Object.defineProperty(unevaluatedProperties, "__esModule", { value: true });
  var codegen_1$1 = requireCodegen();
  var util_1$1 = util;
  var names_1 = requireNames();
  var error$1 = {
    message: "must NOT have unevaluated properties",
    params: ({ params }) => (0, codegen_1$1._)`{unevaluatedProperty: ${params.unevaluatedProperty}}`
  };
  var def$1 = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: true,
    error: error$1,
    code(cxt) {
      const { gen: gen2, schema, data, errsCount, it: it3 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, props } = it3;
      if (props instanceof codegen_1$1.Name) {
        gen2.if((0, codegen_1$1._)`${props} !== true`, () => gen2.forIn("key", data, (key) => gen2.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))));
      } else if (props !== true) {
        gen2.forIn("key", data, (key) => props === void 0 ? unevaluatedPropCode(key) : gen2.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key)));
      }
      it3.props = true;
      cxt.ok((0, codegen_1$1._)`${errsCount} === ${names_1.default.errors}`);
      function unevaluatedPropCode(key) {
        if (schema === false) {
          cxt.setParams({ unevaluatedProperty: key });
          cxt.error();
          if (!allErrors)
            gen2.break();
          return;
        }
        if (!(0, util_1$1.alwaysValidSchema)(it3, schema)) {
          const valid = gen2.name("valid");
          cxt.subschema({
            keyword: "unevaluatedProperties",
            dataProp: key,
            dataPropType: util_1$1.Type.Str
          }, valid);
          if (!allErrors)
            gen2.if((0, codegen_1$1.not)(valid), () => gen2.break());
        }
      }
      function unevaluatedDynamic(evaluatedProps, key) {
        return (0, codegen_1$1._)`!${evaluatedProps} || !${evaluatedProps}[${key}]`;
      }
      function unevaluatedStatic(evaluatedProps, key) {
        const ps2 = [];
        for (const p6 in evaluatedProps) {
          if (evaluatedProps[p6] === true)
            ps2.push((0, codegen_1$1._)`${key} !== ${p6}`);
        }
        return (0, codegen_1$1.and)(...ps2);
      }
    }
  };
  unevaluatedProperties.default = def$1;
  var unevaluatedItems = {};
  Object.defineProperty(unevaluatedItems, "__esModule", { value: true });
  var codegen_1 = requireCodegen();
  var util_1 = util;
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error,
    code(cxt) {
      const { gen: gen2, schema, data, it: it3 } = cxt;
      const items2 = it3.items || 0;
      if (items2 === true)
        return;
      const len = gen2.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items2 });
        cxt.fail((0, codegen_1._)`${len} > ${items2}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it3, schema)) {
        const valid = gen2.var("valid", (0, codegen_1._)`${len} <= ${items2}`);
        gen2.if((0, codegen_1.not)(valid), () => validateItems(valid, items2));
        cxt.ok(valid);
      }
      it3.items = true;
      function validateItems(valid, from2) {
        gen2.forRange("i", from2, len, (i4) => {
          cxt.subschema({ keyword: "unevaluatedItems", dataProp: i4, dataPropType: util_1.Type.Num }, valid);
          if (!it3.allErrors)
            gen2.if((0, codegen_1.not)(valid), () => gen2.break());
        });
      }
    }
  };
  unevaluatedItems.default = def;
  Object.defineProperty(unevaluated$2, "__esModule", { value: true });
  var unevaluatedProperties_1 = unevaluatedProperties;
  var unevaluatedItems_1 = unevaluatedItems;
  var unevaluated$1 = [unevaluatedProperties_1.default, unevaluatedItems_1.default];
  unevaluated$2.default = unevaluated$1;
  Object.defineProperty(draft2020, "__esModule", { value: true });
  var core_1 = core$3;
  var validation_1 = validation$3;
  var applicator_1 = applicator$2;
  var dynamic_1 = dynamic$1;
  var next_1 = next$1;
  var unevaluated_1 = unevaluated$2;
  var format_1 = format$4;
  var metadata_1 = metadata$2;
  var draft2020Vocabularies = [
    dynamic_1.default,
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(true),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary,
    next_1.default,
    unevaluated_1.default
  ];
  draft2020.default = draft2020Vocabularies;
  var jsonSchema202012 = {};
  var $schema$e = "https://json-schema.org/draft/2020-12/schema";
  var $id$e = "https://json-schema.org/draft/2020-12/schema";
  var $vocabulary$e = {
    "https://json-schema.org/draft/2020-12/vocab/core": true,
    "https://json-schema.org/draft/2020-12/vocab/applicator": true,
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,
    "https://json-schema.org/draft/2020-12/vocab/validation": true,
    "https://json-schema.org/draft/2020-12/vocab/meta-data": true,
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,
    "https://json-schema.org/draft/2020-12/vocab/content": true
  };
  var $dynamicAnchor$7 = "meta";
  var title$e = "Core and Validation specifications meta-schema";
  var allOf$1 = [
    {
      $ref: "meta/core"
    },
    {
      $ref: "meta/applicator"
    },
    {
      $ref: "meta/unevaluated"
    },
    {
      $ref: "meta/validation"
    },
    {
      $ref: "meta/meta-data"
    },
    {
      $ref: "meta/format-annotation"
    },
    {
      $ref: "meta/content"
    }
  ];
  var type$e = [
    "object",
    "boolean"
  ];
  var $comment = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.";
  var properties$e = {
    definitions: {
      $comment: '"definitions" has been replaced by "$defs".',
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      },
      deprecated: true,
      "default": {}
    },
    dependencies: {
      $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
      type: "object",
      additionalProperties: {
        anyOf: [
          {
            $dynamicRef: "#meta"
          },
          {
            $ref: "meta/validation#/$defs/stringArray"
          }
        ]
      },
      deprecated: true,
      "default": {}
    },
    $recursiveAnchor: {
      $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
      $ref: "meta/core#/$defs/anchorString",
      deprecated: true
    },
    $recursiveRef: {
      $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
      $ref: "meta/core#/$defs/uriReferenceString",
      deprecated: true
    }
  };
  var require$$0$1 = {
    $schema: $schema$e,
    $id: $id$e,
    $vocabulary: $vocabulary$e,
    $dynamicAnchor: $dynamicAnchor$7,
    title: title$e,
    allOf: allOf$1,
    type: type$e,
    $comment,
    properties: properties$e
  };
  var $schema$d = "https://json-schema.org/draft/2020-12/schema";
  var $id$d = "https://json-schema.org/draft/2020-12/meta/applicator";
  var $vocabulary$d = {
    "https://json-schema.org/draft/2020-12/vocab/applicator": true
  };
  var $dynamicAnchor$6 = "meta";
  var title$d = "Applicator vocabulary meta-schema";
  var type$d = [
    "object",
    "boolean"
  ];
  var properties$d = {
    prefixItems: {
      $ref: "#/$defs/schemaArray"
    },
    items: {
      $dynamicRef: "#meta"
    },
    contains: {
      $dynamicRef: "#meta"
    },
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    properties: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      },
      "default": {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      },
      propertyNames: {
        format: "regex"
      },
      "default": {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      },
      "default": {}
    },
    propertyNames: {
      $dynamicRef: "#meta"
    },
    "if": {
      $dynamicRef: "#meta"
    },
    then: {
      $dynamicRef: "#meta"
    },
    "else": {
      $dynamicRef: "#meta"
    },
    allOf: {
      $ref: "#/$defs/schemaArray"
    },
    anyOf: {
      $ref: "#/$defs/schemaArray"
    },
    oneOf: {
      $ref: "#/$defs/schemaArray"
    },
    not: {
      $dynamicRef: "#meta"
    }
  };
  var $defs$4 = {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: {
        $dynamicRef: "#meta"
      }
    }
  };
  var require$$1$1 = {
    $schema: $schema$d,
    $id: $id$d,
    $vocabulary: $vocabulary$d,
    $dynamicAnchor: $dynamicAnchor$6,
    title: title$d,
    type: type$d,
    properties: properties$d,
    $defs: $defs$4
  };
  var $schema$c = "https://json-schema.org/draft/2020-12/schema";
  var $id$c = "https://json-schema.org/draft/2020-12/meta/unevaluated";
  var $vocabulary$c = {
    "https://json-schema.org/draft/2020-12/vocab/unevaluated": true
  };
  var $dynamicAnchor$5 = "meta";
  var title$c = "Unevaluated applicator vocabulary meta-schema";
  var type$c = [
    "object",
    "boolean"
  ];
  var properties$c = {
    unevaluatedItems: {
      $dynamicRef: "#meta"
    },
    unevaluatedProperties: {
      $dynamicRef: "#meta"
    }
  };
  var require$$2$1 = {
    $schema: $schema$c,
    $id: $id$c,
    $vocabulary: $vocabulary$c,
    $dynamicAnchor: $dynamicAnchor$5,
    title: title$c,
    type: type$c,
    properties: properties$c
  };
  var $schema$b = "https://json-schema.org/draft/2020-12/schema";
  var $id$b = "https://json-schema.org/draft/2020-12/meta/content";
  var $vocabulary$b = {
    "https://json-schema.org/draft/2020-12/vocab/content": true
  };
  var $dynamicAnchor$4 = "meta";
  var title$b = "Content vocabulary meta-schema";
  var type$b = [
    "object",
    "boolean"
  ];
  var properties$b = {
    contentEncoding: {
      type: "string"
    },
    contentMediaType: {
      type: "string"
    },
    contentSchema: {
      $dynamicRef: "#meta"
    }
  };
  var require$$3$1 = {
    $schema: $schema$b,
    $id: $id$b,
    $vocabulary: $vocabulary$b,
    $dynamicAnchor: $dynamicAnchor$4,
    title: title$b,
    type: type$b,
    properties: properties$b
  };
  var $schema$a = "https://json-schema.org/draft/2020-12/schema";
  var $id$a = "https://json-schema.org/draft/2020-12/meta/core";
  var $vocabulary$a = {
    "https://json-schema.org/draft/2020-12/vocab/core": true
  };
  var $dynamicAnchor$3 = "meta";
  var title$a = "Core vocabulary meta-schema";
  var type$a = [
    "object",
    "boolean"
  ];
  var properties$a = {
    $id: {
      $ref: "#/$defs/uriReferenceString",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      $ref: "#/$defs/uriString"
    },
    $ref: {
      $ref: "#/$defs/uriReferenceString"
    },
    $anchor: {
      $ref: "#/$defs/anchorString"
    },
    $dynamicRef: {
      $ref: "#/$defs/uriReferenceString"
    },
    $dynamicAnchor: {
      $ref: "#/$defs/anchorString"
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        $ref: "#/$defs/uriString"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: {
        $dynamicRef: "#meta"
      }
    }
  };
  var $defs$3 = {
    anchorString: {
      type: "string",
      pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
    },
    uriString: {
      type: "string",
      format: "uri"
    },
    uriReferenceString: {
      type: "string",
      format: "uri-reference"
    }
  };
  var require$$4$1 = {
    $schema: $schema$a,
    $id: $id$a,
    $vocabulary: $vocabulary$a,
    $dynamicAnchor: $dynamicAnchor$3,
    title: title$a,
    type: type$a,
    properties: properties$a,
    $defs: $defs$3
  };
  var $schema$9 = "https://json-schema.org/draft/2020-12/schema";
  var $id$9 = "https://json-schema.org/draft/2020-12/meta/format-annotation";
  var $vocabulary$9 = {
    "https://json-schema.org/draft/2020-12/vocab/format-annotation": true
  };
  var $dynamicAnchor$2 = "meta";
  var title$9 = "Format vocabulary meta-schema for annotation results";
  var type$9 = [
    "object",
    "boolean"
  ];
  var properties$9 = {
    format: {
      type: "string"
    }
  };
  var require$$5$1 = {
    $schema: $schema$9,
    $id: $id$9,
    $vocabulary: $vocabulary$9,
    $dynamicAnchor: $dynamicAnchor$2,
    title: title$9,
    type: type$9,
    properties: properties$9
  };
  var $schema$8 = "https://json-schema.org/draft/2020-12/schema";
  var $id$8 = "https://json-schema.org/draft/2020-12/meta/meta-data";
  var $vocabulary$8 = {
    "https://json-schema.org/draft/2020-12/vocab/meta-data": true
  };
  var $dynamicAnchor$1 = "meta";
  var title$8 = "Meta-data vocabulary meta-schema";
  var type$8 = [
    "object",
    "boolean"
  ];
  var properties$8 = {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    "default": true,
    deprecated: {
      type: "boolean",
      "default": false
    },
    readOnly: {
      type: "boolean",
      "default": false
    },
    writeOnly: {
      type: "boolean",
      "default": false
    },
    examples: {
      type: "array",
      items: true
    }
  };
  var require$$6$1 = {
    $schema: $schema$8,
    $id: $id$8,
    $vocabulary: $vocabulary$8,
    $dynamicAnchor: $dynamicAnchor$1,
    title: title$8,
    type: type$8,
    properties: properties$8
  };
  var $schema$7 = "https://json-schema.org/draft/2020-12/schema";
  var $id$7 = "https://json-schema.org/draft/2020-12/meta/validation";
  var $vocabulary$7 = {
    "https://json-schema.org/draft/2020-12/vocab/validation": true
  };
  var $dynamicAnchor = "meta";
  var title$7 = "Validation vocabulary meta-schema";
  var type$7 = [
    "object",
    "boolean"
  ];
  var properties$7 = {
    type: {
      anyOf: [
        {
          $ref: "#/$defs/simpleTypes"
        },
        {
          type: "array",
          items: {
            $ref: "#/$defs/simpleTypes"
          },
          minItems: 1,
          uniqueItems: true
        }
      ]
    },
    "const": true,
    "enum": {
      type: "array",
      items: true
    },
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minLength: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minItems: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    uniqueItems: {
      type: "boolean",
      "default": false
    },
    maxContains: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      "default": 1
    },
    maxProperties: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minProperties: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    required: {
      $ref: "#/$defs/stringArray"
    },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    }
  };
  var $defs$2 = {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      "default": 0
    },
    simpleTypes: {
      "enum": [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true,
      "default": []
    }
  };
  var require$$7 = {
    $schema: $schema$7,
    $id: $id$7,
    $vocabulary: $vocabulary$7,
    $dynamicAnchor,
    title: title$7,
    type: type$7,
    properties: properties$7,
    $defs: $defs$2
  };
  Object.defineProperty(jsonSchema202012, "__esModule", { value: true });
  var metaSchema$1 = require$$0$1;
  var applicator$1 = require$$1$1;
  var unevaluated = require$$2$1;
  var content$1 = require$$3$1;
  var core$1 = require$$4$1;
  var format$1 = require$$5$1;
  var metadata$1 = require$$6$1;
  var validation$1 = require$$7;
  var META_SUPPORT_DATA$1 = ["/properties"];
  function addMetaSchema2020($data) {
    [
      metaSchema$1,
      applicator$1,
      unevaluated,
      content$1,
      core$1,
      with$data(this, format$1),
      metadata$1,
      with$data(this, validation$1)
    ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
    return this;
    function with$data(ajv2, sch) {
      return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA$1) : sch;
    }
  }
  jsonSchema202012.default = addMetaSchema2020;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    const core_12 = core$4;
    const draft2020_1 = draft2020;
    const discriminator_1 = discriminator;
    const json_schema_2020_12_1 = jsonSchema202012;
    const META_SCHEMA_ID = "https://json-schema.org/draft/2020-12/schema";
    class Ajv20202 extends core_12.default {
      constructor(opts = {}) {
        super({
          ...opts,
          dynamicRef: true,
          next: true,
          unevaluated: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        draft2020_1.default.forEach((v6) => this.addVocabulary(v6));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data, meta } = this.opts;
        if (!meta)
          return;
        json_schema_2020_12_1.default.call(this, $data);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    module.exports = exports = Ajv20202;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv20202;
    var validate_12 = requireValidate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_12.KeywordCxt;
    } });
    var codegen_12 = requireCodegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_12._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_12.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_12.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_12.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_12.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_12.CodeGen;
    } });
    var validation_error_12 = requireValidation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_12.default;
    } });
    var ref_error_12 = requireRef_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_12.default;
    } });
  })(_2020, _2020.exports);
  var _2020Exports = _2020.exports;
  var Ajv2020 = /* @__PURE__ */ getDefaultExportFromCjs(_2020Exports);
  var _2019 = { exports: {} };
  var jsonSchema201909 = {};
  var $schema$6 = "https://json-schema.org/draft/2019-09/schema";
  var $id$6 = "https://json-schema.org/draft/2019-09/schema";
  var $vocabulary$6 = {
    "https://json-schema.org/draft/2019-09/vocab/core": true,
    "https://json-schema.org/draft/2019-09/vocab/applicator": true,
    "https://json-schema.org/draft/2019-09/vocab/validation": true,
    "https://json-schema.org/draft/2019-09/vocab/meta-data": true,
    "https://json-schema.org/draft/2019-09/vocab/format": false,
    "https://json-schema.org/draft/2019-09/vocab/content": true
  };
  var $recursiveAnchor$6 = true;
  var title$6 = "Core and Validation specifications meta-schema";
  var allOf = [
    {
      $ref: "meta/core"
    },
    {
      $ref: "meta/applicator"
    },
    {
      $ref: "meta/validation"
    },
    {
      $ref: "meta/meta-data"
    },
    {
      $ref: "meta/format"
    },
    {
      $ref: "meta/content"
    }
  ];
  var type$6 = [
    "object",
    "boolean"
  ];
  var properties$6 = {
    definitions: {
      $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",
      type: "object",
      additionalProperties: {
        $recursiveRef: "#"
      },
      "default": {}
    },
    dependencies: {
      $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"',
      type: "object",
      additionalProperties: {
        anyOf: [
          {
            $recursiveRef: "#"
          },
          {
            $ref: "meta/validation#/$defs/stringArray"
          }
        ]
      }
    }
  };
  var require$$0 = {
    $schema: $schema$6,
    $id: $id$6,
    $vocabulary: $vocabulary$6,
    $recursiveAnchor: $recursiveAnchor$6,
    title: title$6,
    allOf,
    type: type$6,
    properties: properties$6
  };
  var $schema$5 = "https://json-schema.org/draft/2019-09/schema";
  var $id$5 = "https://json-schema.org/draft/2019-09/meta/applicator";
  var $vocabulary$5 = {
    "https://json-schema.org/draft/2019-09/vocab/applicator": true
  };
  var $recursiveAnchor$5 = true;
  var title$5 = "Applicator vocabulary meta-schema";
  var type$5 = [
    "object",
    "boolean"
  ];
  var properties$5 = {
    additionalItems: {
      $recursiveRef: "#"
    },
    unevaluatedItems: {
      $recursiveRef: "#"
    },
    items: {
      anyOf: [
        {
          $recursiveRef: "#"
        },
        {
          $ref: "#/$defs/schemaArray"
        }
      ]
    },
    contains: {
      $recursiveRef: "#"
    },
    additionalProperties: {
      $recursiveRef: "#"
    },
    unevaluatedProperties: {
      $recursiveRef: "#"
    },
    properties: {
      type: "object",
      additionalProperties: {
        $recursiveRef: "#"
      },
      "default": {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: {
        $recursiveRef: "#"
      },
      propertyNames: {
        format: "regex"
      },
      "default": {}
    },
    dependentSchemas: {
      type: "object",
      additionalProperties: {
        $recursiveRef: "#"
      }
    },
    propertyNames: {
      $recursiveRef: "#"
    },
    "if": {
      $recursiveRef: "#"
    },
    then: {
      $recursiveRef: "#"
    },
    "else": {
      $recursiveRef: "#"
    },
    allOf: {
      $ref: "#/$defs/schemaArray"
    },
    anyOf: {
      $ref: "#/$defs/schemaArray"
    },
    oneOf: {
      $ref: "#/$defs/schemaArray"
    },
    not: {
      $recursiveRef: "#"
    }
  };
  var $defs$1 = {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: {
        $recursiveRef: "#"
      }
    }
  };
  var require$$1 = {
    $schema: $schema$5,
    $id: $id$5,
    $vocabulary: $vocabulary$5,
    $recursiveAnchor: $recursiveAnchor$5,
    title: title$5,
    type: type$5,
    properties: properties$5,
    $defs: $defs$1
  };
  var $schema$4 = "https://json-schema.org/draft/2019-09/schema";
  var $id$4 = "https://json-schema.org/draft/2019-09/meta/content";
  var $vocabulary$4 = {
    "https://json-schema.org/draft/2019-09/vocab/content": true
  };
  var $recursiveAnchor$4 = true;
  var title$4 = "Content vocabulary meta-schema";
  var type$4 = [
    "object",
    "boolean"
  ];
  var properties$4 = {
    contentMediaType: {
      type: "string"
    },
    contentEncoding: {
      type: "string"
    },
    contentSchema: {
      $recursiveRef: "#"
    }
  };
  var require$$2 = {
    $schema: $schema$4,
    $id: $id$4,
    $vocabulary: $vocabulary$4,
    $recursiveAnchor: $recursiveAnchor$4,
    title: title$4,
    type: type$4,
    properties: properties$4
  };
  var $schema$3 = "https://json-schema.org/draft/2019-09/schema";
  var $id$3 = "https://json-schema.org/draft/2019-09/meta/core";
  var $vocabulary$3 = {
    "https://json-schema.org/draft/2019-09/vocab/core": true
  };
  var $recursiveAnchor$3 = true;
  var title$3 = "Core vocabulary meta-schema";
  var type$3 = [
    "object",
    "boolean"
  ];
  var properties$3 = {
    $id: {
      type: "string",
      format: "uri-reference",
      $comment: "Non-empty fragments not allowed.",
      pattern: "^[^#]*#?$"
    },
    $schema: {
      type: "string",
      format: "uri"
    },
    $anchor: {
      type: "string",
      pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$"
    },
    $ref: {
      type: "string",
      format: "uri-reference"
    },
    $recursiveRef: {
      type: "string",
      format: "uri-reference"
    },
    $recursiveAnchor: {
      type: "boolean",
      "default": false
    },
    $vocabulary: {
      type: "object",
      propertyNames: {
        type: "string",
        format: "uri"
      },
      additionalProperties: {
        type: "boolean"
      }
    },
    $comment: {
      type: "string"
    },
    $defs: {
      type: "object",
      additionalProperties: {
        $recursiveRef: "#"
      },
      "default": {}
    }
  };
  var require$$3 = {
    $schema: $schema$3,
    $id: $id$3,
    $vocabulary: $vocabulary$3,
    $recursiveAnchor: $recursiveAnchor$3,
    title: title$3,
    type: type$3,
    properties: properties$3
  };
  var $schema$2 = "https://json-schema.org/draft/2019-09/schema";
  var $id$2 = "https://json-schema.org/draft/2019-09/meta/format";
  var $vocabulary$2 = {
    "https://json-schema.org/draft/2019-09/vocab/format": true
  };
  var $recursiveAnchor$2 = true;
  var title$2 = "Format vocabulary meta-schema";
  var type$2 = [
    "object",
    "boolean"
  ];
  var properties$2 = {
    format: {
      type: "string"
    }
  };
  var require$$4 = {
    $schema: $schema$2,
    $id: $id$2,
    $vocabulary: $vocabulary$2,
    $recursiveAnchor: $recursiveAnchor$2,
    title: title$2,
    type: type$2,
    properties: properties$2
  };
  var $schema$1 = "https://json-schema.org/draft/2019-09/schema";
  var $id$1 = "https://json-schema.org/draft/2019-09/meta/meta-data";
  var $vocabulary$1 = {
    "https://json-schema.org/draft/2019-09/vocab/meta-data": true
  };
  var $recursiveAnchor$1 = true;
  var title$1 = "Meta-data vocabulary meta-schema";
  var type$1 = [
    "object",
    "boolean"
  ];
  var properties$1 = {
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    "default": true,
    deprecated: {
      type: "boolean",
      "default": false
    },
    readOnly: {
      type: "boolean",
      "default": false
    },
    writeOnly: {
      type: "boolean",
      "default": false
    },
    examples: {
      type: "array",
      items: true
    }
  };
  var require$$5 = {
    $schema: $schema$1,
    $id: $id$1,
    $vocabulary: $vocabulary$1,
    $recursiveAnchor: $recursiveAnchor$1,
    title: title$1,
    type: type$1,
    properties: properties$1
  };
  var $schema = "https://json-schema.org/draft/2019-09/schema";
  var $id = "https://json-schema.org/draft/2019-09/meta/validation";
  var $vocabulary = {
    "https://json-schema.org/draft/2019-09/vocab/validation": true
  };
  var $recursiveAnchor = true;
  var title = "Validation vocabulary meta-schema";
  var type = [
    "object",
    "boolean"
  ];
  var properties = {
    multipleOf: {
      type: "number",
      exclusiveMinimum: 0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "number"
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "number"
    },
    maxLength: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minLength: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    pattern: {
      type: "string",
      format: "regex"
    },
    maxItems: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minItems: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    uniqueItems: {
      type: "boolean",
      "default": false
    },
    maxContains: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minContains: {
      $ref: "#/$defs/nonNegativeInteger",
      "default": 1
    },
    maxProperties: {
      $ref: "#/$defs/nonNegativeInteger"
    },
    minProperties: {
      $ref: "#/$defs/nonNegativeIntegerDefault0"
    },
    required: {
      $ref: "#/$defs/stringArray"
    },
    dependentRequired: {
      type: "object",
      additionalProperties: {
        $ref: "#/$defs/stringArray"
      }
    },
    "const": true,
    "enum": {
      type: "array",
      items: true
    },
    type: {
      anyOf: [
        {
          $ref: "#/$defs/simpleTypes"
        },
        {
          type: "array",
          items: {
            $ref: "#/$defs/simpleTypes"
          },
          minItems: 1,
          uniqueItems: true
        }
      ]
    }
  };
  var $defs = {
    nonNegativeInteger: {
      type: "integer",
      minimum: 0
    },
    nonNegativeIntegerDefault0: {
      $ref: "#/$defs/nonNegativeInteger",
      "default": 0
    },
    simpleTypes: {
      "enum": [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string"
      ]
    },
    stringArray: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: true,
      "default": []
    }
  };
  var require$$6 = {
    $schema,
    $id,
    $vocabulary,
    $recursiveAnchor,
    title,
    type,
    properties,
    $defs
  };
  Object.defineProperty(jsonSchema201909, "__esModule", { value: true });
  var metaSchema = require$$0;
  var applicator = require$$1;
  var content = require$$2;
  var core = require$$3;
  var format = require$$4;
  var metadata = require$$5;
  var validation = require$$6;
  var META_SUPPORT_DATA = ["/properties"];
  function addMetaSchema2019($data) {
    [
      metaSchema,
      applicator,
      content,
      core,
      with$data(this, format),
      metadata,
      with$data(this, validation)
    ].forEach((sch) => this.addMetaSchema(sch, void 0, false));
    return this;
    function with$data(ajv2, sch) {
      return $data ? ajv2.$dataMetaSchema(sch, META_SUPPORT_DATA) : sch;
    }
  }
  jsonSchema201909.default = addMetaSchema2019;
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    const core_12 = core$4;
    const draft7_1 = draft7;
    const dynamic_12 = dynamic$1;
    const next_12 = next$1;
    const unevaluated_12 = unevaluated$2;
    const discriminator_1 = discriminator;
    const json_schema_2019_09_1 = jsonSchema201909;
    const META_SCHEMA_ID = "https://json-schema.org/draft/2019-09/schema";
    class Ajv20192 extends core_12.default {
      constructor(opts = {}) {
        super({
          ...opts,
          dynamicRef: true,
          next: true,
          unevaluated: true
        });
      }
      _addVocabularies() {
        super._addVocabularies();
        this.addVocabulary(dynamic_12.default);
        draft7_1.default.forEach((v6) => this.addVocabulary(v6));
        this.addVocabulary(next_12.default);
        this.addVocabulary(unevaluated_12.default);
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data, meta } = this.opts;
        if (!meta)
          return;
        json_schema_2019_09_1.default.call(this, $data);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    }
    module.exports = exports = Ajv20192;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv20192;
    var validate_12 = requireValidate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_12.KeywordCxt;
    } });
    var codegen_12 = requireCodegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_12._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_12.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_12.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_12.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_12.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_12.CodeGen;
    } });
    var validation_error_12 = requireValidation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_12.default;
    } });
    var ref_error_12 = requireRef_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_12.default;
    } });
  })(_2019, _2019.exports);
  var _2019Exports = _2019.exports;
  var Ajv2019 = /* @__PURE__ */ getDefaultExportFromCjs(_2019Exports);
  var dist = { exports: {} };
  var formats = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate2, compare2) {
      return { validate: validate2, compare: compare2 };
    }
    exports.fullFormats = {
      date: fmtDef(date, compareDate),
      time: fmtDef(time, compareTime),
      "date-time": fmtDef(date_time, compareDateTime),
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: uri2,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      byte,
      int32: { type: "number", validate: validateInt32 },
      int64: { type: "number", validate: validateInt64 },
      float: { type: "number", validate: validateNumber },
      double: { type: "number", validate: validateNumber },
      password: true,
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d22) {
      if (!(d1 && d22))
        return void 0;
      if (d1 > d22)
        return 1;
      if (d1 < d22)
        return -1;
      return 0;
    }
    const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    function time(str, withTimeZone) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hour = +matches[1];
      const minute = +matches[2];
      const second = +matches[3];
      const timeZone = matches[5];
      return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
    }
    function compareTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a22 = TIME.exec(t2);
      if (!(a1 && a22))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
      t2 = a22[1] + a22[2] + a22[3] + (a22[4] || "");
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    const DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
    }
    function compareDateTime(dt1, dt22) {
      if (!(dt1 && dt22))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d22, t2] = dt22.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d22);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    const NOT_URI_FRAGMENT = /\/|:/;
    const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri2(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    const MIN_INT32 = -(2 ** 31);
    const MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    const Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        return true;
      } catch (e7) {
        return false;
      }
    }
  })(formats);
  var limit = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    const ajv_1 = ajvExports;
    const codegen_12 = requireCodegen();
    const ops2 = codegen_12.operators;
    const KWDs2 = {
      formatMaximum: { okStr: "<=", ok: ops2.LTE, fail: ops2.GT },
      formatMinimum: { okStr: ">=", ok: ops2.GTE, fail: ops2.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops2.LT, fail: ops2.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops2.GT, fail: ops2.LTE }
    };
    const error2 = {
      message: ({ keyword: keyword2, schemaCode }) => codegen_12.str`should be ${KWDs2[keyword2].okStr} ${schemaCode}`,
      params: ({ keyword: keyword2, schemaCode }) => codegen_12._`{comparison: ${KWDs2[keyword2].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs2),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen: gen2, data, schemaCode, keyword: keyword2, it: it3 } = cxt;
        const { opts, self: self2 } = it3;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it3, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen2.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen2.const("fmt", codegen_12._`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data(codegen_12.or(codegen_12._`typeof ${fmt} != "object"`, codegen_12._`${fmt} instanceof RegExp`, codegen_12._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self2.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword2}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen2.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? codegen_12._`${opts.code.formats}${codegen_12.getProperty(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return codegen_12._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs2[keyword2].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const formatLimitPlugin = (ajv2) => {
      ajv2.addKeyword(exports.formatLimitDefinition);
      return ajv2;
    };
    exports.default = formatLimitPlugin;
  })(limit);
  (function(module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const formats_1 = formats;
    const limit_1 = limit;
    const codegen_12 = requireCodegen();
    const fullName = new codegen_12.Name("fullFormats");
    const fastName = new codegen_12.Name("fastFormats");
    const formatsPlugin = (ajv2, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv2, opts, formats_1.fullFormats, fullName);
        return ajv2;
      }
      const [formats2, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv2, list, formats2, exportName);
      if (opts.keywords)
        limit_1.default(ajv2);
      return ajv2;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats2 = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f5 = formats2[name];
      if (!f5)
        throw new Error(`Unknown format "${name}"`);
      return f5;
    };
    function addFormats(ajv2, list, fs3, exportName) {
      var _a2;
      var _b;
      (_a2 = (_b = ajv2.opts.code).formats) !== null && _a2 !== void 0 ? _a2 : _b.formats = codegen_12._`require("ajv-formats/dist/formats").${exportName}`;
      for (const f5 of list)
        ajv2.addFormat(f5, fs3[f5]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  })(dist, dist.exports);
  var distExports = dist.exports;
  var defaultOpts = { verbose: true, strict: false };
  var defaultJSONSchemaValidator = new Ajv(defaultOpts);
  var JSON_SCHEMA_VALIDATORS_REGISTRY = {
    "http://json-schema.org/draft-07/schema": defaultJSONSchemaValidator,
    "https://json-schema.org/draft/2019-09/schema": new Ajv2019(defaultOpts),
    "https://json-schema.org/draft/2020-12/schema": new Ajv2020(defaultOpts)
  };
  var doc = JSON.parse(VerifiableConstants.JSONLD_SCHEMA.W3C_VC_DOCUMENT_2018);
  var version = "6.13.4";
  function checkType(value, type2, name) {
    const types2 = type2.split("|").map((t) => t.trim());
    for (let i4 = 0; i4 < types2.length; i4++) {
      switch (type2) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type2) {
            return;
          }
      }
    }
    const error2 = new Error(`invalid value for type ${type2}`);
    error2.code = "INVALID_ARGUMENT";
    error2.argument = `value.${name}`;
    error2.value = value;
    throw error2;
  }
  async function resolveProperties(value) {
    const keys = Object.keys(value);
    const results = await Promise.all(keys.map((k5) => Promise.resolve(value[k5])));
    return results.reduce((accum, v6, index) => {
      accum[keys[index]] = v6;
      return accum;
    }, {});
  }
  function defineProperties(target, values, types2) {
    for (let key in values) {
      let value = values[key];
      const type2 = types2 ? types2[key] : null;
      if (type2) {
        checkType(value, type2, key);
      }
      Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
  }
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i4 = 0; i4 < value.length; i4++) {
        result += HEX[value[i4] >> 4];
        result += HEX[value[i4] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map((k5) => `${stringify(k5)}: ${stringify(value[k5])}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function isError(error2, code2) {
    return error2 && error2.code === code2;
  }
  function isCallException(error2) {
    return isError(error2, "CALL_EXCEPTION");
  }
  function makeError(message, code2, info) {
    let shortMessage = message;
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key in info) {
          if (key === "shortMessage") {
            continue;
          }
          const value = info[key];
          details.push(key + "=" + stringify(value));
        }
      }
      details.push(`code=${code2}`);
      details.push(`version=${version}`);
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    let error2;
    switch (code2) {
      case "INVALID_ARGUMENT":
        error2 = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error2 = new RangeError(message);
        break;
      default:
        error2 = new Error(message);
    }
    defineProperties(error2, { code: code2 });
    if (info) {
      Object.assign(error2, info);
    }
    if (error2.shortMessage == null) {
      defineProperties(error2, { shortMessage });
    }
    return error2;
  }
  function assert2(check, message, code2, info) {
    if (!check) {
      throw makeError(message, code2, info);
    }
  }
  function assertArgument(check, message, name, value) {
    assert2(check, message, "INVALID_ARGUMENT", { argument: name, value });
  }
  function assertArgumentCount(count, expectedCount, message) {
    if (message == null) {
      message = "";
    }
    if (message) {
      message = ": " + message;
    }
    assert2(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
      count,
      expectedCount
    });
    assert2(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
      count,
      expectedCount
    });
  }
  ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      if (form === "NFD") {
        const check = String.fromCharCode(233).normalize("NFD");
        const expected = String.fromCharCode(101, 769);
        if (check !== expected) {
          throw new Error("broken");
        }
      }
      accum.push(form);
    } catch (error2) {
    }
    return accum;
  }, []);
  function assertPrivate(givenGuard, guard, className) {
    if (className == null) {
      className = "";
    }
    if (givenGuard !== guard) {
      let method = className, operation = "new";
      if (className) {
        method += ".";
        operation += " " + className;
      }
      assert2(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
        operation
      });
    }
  }
  function _getBytes(value, name, copy2) {
    if (value instanceof Uint8Array) {
      if (copy2) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i4 = 0; i4 < result.length; i4++) {
        result[i4] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
  }
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
  }
  function isHexString(value, length2) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length2 === "number" && value.length !== 2 + 2 * length2) {
      return false;
    }
    if (length2 === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  function isBytesLike(value) {
    return isHexString(value, true) || value instanceof Uint8Array;
  }
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes2 = getBytes(data);
    let result = "0x";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      const v6 = bytes2[i4];
      result += HexCharacters[(v6 & 240) >> 4] + HexCharacters[v6 & 15];
    }
    return result;
  }
  function concat(datas) {
    return "0x" + datas.map((d5) => hexlify(d5).substring(2)).join("");
  }
  function dataLength(data) {
    if (isHexString(data, true)) {
      return (data.length - 2) / 2;
    }
    return getBytes(data).length;
  }
  function dataSlice(data, start, end) {
    const bytes2 = getBytes(data);
    if (end != null && end > bytes2.length) {
      assert2(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: bytes2,
        length: bytes2.length,
        offset: end
      });
    }
    return hexlify(bytes2.slice(start == null ? 0 : start, end == null ? bytes2.length : end));
  }
  function zeroPad(data, length2, left) {
    const bytes2 = getBytes(data);
    assert2(length2 >= bytes2.length, "padding exceeds data length", "BUFFER_OVERRUN", {
      buffer: new Uint8Array(bytes2),
      length: length2,
      offset: length2 + 1
    });
    const result = new Uint8Array(length2);
    result.fill(0);
    if (left) {
      result.set(bytes2, length2 - bytes2.length);
    } else {
      result.set(bytes2, 0);
    }
    return hexlify(result);
  }
  function zeroPadValue(data, length2) {
    return zeroPad(data, length2, true);
  }
  function zeroPadBytes(data, length2) {
    return zeroPad(data, length2, false);
  }
  var BN_0$9 = BigInt(0);
  var BN_1$4 = BigInt(1);
  var maxValue = 9007199254740991;
  function fromTwos(_value, _width) {
    const value = getUint(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    assert2(value >> width === BN_0$9, "overflow", "NUMERIC_FAULT", {
      operation: "fromTwos",
      fault: "overflow",
      value: _value
    });
    if (value >> width - BN_1$4) {
      const mask2 = (BN_1$4 << width) - BN_1$4;
      return -((~value & mask2) + BN_1$4);
    }
    return value;
  }
  function toTwos(_value, _width) {
    let value = getBigInt(_value, "value");
    const width = BigInt(getNumber(_width, "width"));
    const limit2 = BN_1$4 << width - BN_1$4;
    if (value < BN_0$9) {
      value = -value;
      assert2(value <= limit2, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value
      });
      const mask2 = (BN_1$4 << width) - BN_1$4;
      return (~value & mask2) + BN_1$4;
    } else {
      assert2(value < limit2, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: _value
      });
    }
    return value;
  }
  function mask(_value, _bits) {
    const value = getUint(_value, "value");
    const bits2 = BigInt(getNumber(_bits, "bits"));
    return value & (BN_1$4 << bits2) - BN_1$4;
  }
  function getBigInt(value, name) {
    switch (typeof value) {
      case "bigint":
        return value;
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e7) {
          assertArgument(false, `invalid BigNumberish string: ${e7.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
  }
  function getUint(value, name) {
    const result = getBigInt(value, name);
    assert2(result >= BN_0$9, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value
    });
    return result;
  }
  var Nibbles = "0123456789abcdef";
  function toBigInt(value) {
    if (value instanceof Uint8Array) {
      let result = "0x0";
      for (const v6 of value) {
        result += Nibbles[v6 >> 4];
        result += Nibbles[v6 & 15];
      }
      return BigInt(result);
    }
    return getBigInt(value);
  }
  function getNumber(value, name) {
    switch (typeof value) {
      case "bigint":
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return Number(value);
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name);
        } catch (e7) {
          assertArgument(false, `invalid numeric string: ${e7.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
  }
  function toNumber2(value) {
    return getNumber(toBigInt(value));
  }
  function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      const width = getNumber(_width, "width");
      assert2(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value
      });
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }
  function toBeArray(_value) {
    const value = getUint(_value, "value");
    if (value === BN_0$9) {
      return new Uint8Array([]);
    }
    let hex2 = value.toString(16);
    if (hex2.length % 2) {
      hex2 = "0" + hex2;
    }
    const result = new Uint8Array(hex2.length / 2);
    for (let i4 = 0; i4 < result.length; i4++) {
      const offset = i4 * 2;
      result[i4] = parseInt(hex2.substring(offset, offset + 2), 16);
    }
    return result;
  }
  function toQuantity(value) {
    let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
    while (result.startsWith("0")) {
      result = result.substring(1);
    }
    if (result === "") {
      result = "0";
    }
    return "0x" + result;
  }
  var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  BigInt(0);
  var BN_58 = BigInt(58);
  function encodeBase58(_value) {
    const bytes2 = getBytes(_value);
    let value = toBigInt(bytes2);
    let result = "";
    while (value) {
      result = Alphabet[Number(value % BN_58)] + result;
      value /= BN_58;
    }
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      if (bytes2[i4]) {
        break;
      }
      result = Alphabet[0] + result;
    }
    return result;
  }
  function decodeBase64(textData) {
    textData = atob(textData);
    const data = new Uint8Array(textData.length);
    for (let i4 = 0; i4 < textData.length; i4++) {
      data[i4] = textData.charCodeAt(i4);
    }
    return getBytes(data);
  }
  function encodeBase64(_data) {
    const data = getBytes(_data);
    let textData = "";
    for (let i4 = 0; i4 < data.length; i4++) {
      textData += String.fromCharCode(data[i4]);
    }
    return btoa(textData);
  }
  var EventPayload = class {
    filter;
    emitter;
    #listener;
    constructor(emitter, listener, filter) {
      this.#listener = listener;
      defineProperties(this, { emitter, filter });
    }
    async removeListener() {
      if (this.#listener == null) {
        return;
      }
      await this.emitter.off(this.filter, this.#listener);
    }
  };
  function errorFunc(reason, offset, bytes2, output2, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes2);
  }
  function ignoreFunc(reason, offset, bytes2, output2, badCodepoint) {
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
      let i4 = 0;
      for (let o4 = offset + 1; o4 < bytes2.length; o4++) {
        if (bytes2[o4] >> 6 !== 2) {
          break;
        }
        i4++;
      }
      return i4;
    }
    if (reason === "OVERRUN") {
      return bytes2.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes2, output2, badCodepoint) {
    if (reason === "OVERLONG") {
      assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
      output2.push(badCodepoint);
      return 0;
    }
    output2.push(65533);
    return ignoreFunc(reason, offset, bytes2);
  }
  var Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
      onError = Utf8ErrorFuncs.error;
    }
    const bytes2 = getBytes(_bytes, "bytes");
    const result = [];
    let i4 = 0;
    while (i4 < bytes2.length) {
      const c3 = bytes2[i4++];
      if (c3 >> 7 === 0) {
        result.push(c3);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c3 & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c3 & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c3 & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c3 & 192) === 128) {
          i4 += onError("UNEXPECTED_CONTINUE", i4 - 1, bytes2, result);
        } else {
          i4 += onError("BAD_PREFIX", i4 - 1, bytes2, result);
        }
        continue;
      }
      if (i4 - 1 + extraLength >= bytes2.length) {
        i4 += onError("OVERRUN", i4 - 1, bytes2, result);
        continue;
      }
      let res = c3 & (1 << 8 - extraLength - 1) - 1;
      for (let j5 = 0; j5 < extraLength; j5++) {
        let nextChar = bytes2[i4];
        if ((nextChar & 192) != 128) {
          i4 += onError("MISSING_CONTINUE", i4, bytes2, result);
          res = null;
          break;
        }
        res = res << 6 | nextChar & 63;
        i4++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i4 += onError("OUT_OF_RANGE", i4 - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i4 += onError("UTF16_SURROGATE", i4 - 1 - extraLength, bytes2, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i4 += onError("OVERLONG", i4 - 1 - extraLength, bytes2, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form) {
    assertArgument(typeof str === "string", "invalid string value", "str", str);
    let result = [];
    for (let i4 = 0; i4 < str.length; i4++) {
      const c3 = str.charCodeAt(i4);
      if (c3 < 128) {
        result.push(c3);
      } else if (c3 < 2048) {
        result.push(c3 >> 6 | 192);
        result.push(c3 & 63 | 128);
      } else if ((c3 & 64512) == 55296) {
        i4++;
        const c22 = str.charCodeAt(i4);
        assertArgument(i4 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
        const pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c3 >> 12 | 224);
        result.push(c3 >> 6 & 63 | 128);
        result.push(c3 & 63 | 128);
      }
    }
    return new Uint8Array(result);
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes2, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes2, onError));
  }
  function createGetUrl(options) {
    async function getUrl(req, _signal) {
      assert2(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
      const protocol = req.url.split(":")[0].toLowerCase();
      assert2(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
        info: { protocol },
        operation: "request"
      });
      assert2(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
        operation: "request"
      });
      let error2 = null;
      const controller = new AbortController();
      const timer = setTimeout(() => {
        error2 = makeError("request timeout", "TIMEOUT");
        controller.abort();
      }, req.timeout);
      if (_signal) {
        _signal.addListener(() => {
          error2 = makeError("request cancelled", "CANCELLED");
          controller.abort();
        });
      }
      const init2 = {
        method: req.method,
        headers: new Headers(Array.from(req)),
        body: req.body || void 0,
        signal: controller.signal
      };
      let resp;
      try {
        resp = await fetch(req.url, init2);
      } catch (_error) {
        clearTimeout(timer);
        if (error2) {
          throw error2;
        }
        throw _error;
      }
      clearTimeout(timer);
      const headers = {};
      resp.headers.forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
      const respBody = await resp.arrayBuffer();
      const body = respBody == null ? null : new Uint8Array(respBody);
      return {
        statusCode: resp.status,
        statusMessage: resp.statusText,
        headers,
        body
      };
    }
    return getUrl;
  }
  var MAX_ATTEMPTS = 12;
  var SLOT_INTERVAL = 250;
  var defaultGetUrlFunc = createGetUrl();
  var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
  var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
  var locked$1 = false;
  async function dataGatewayFunc(url2, signal) {
    try {
      const match = url2.match(reData);
      if (!match) {
        throw new Error("invalid data");
      }
      return new FetchResponse(200, "OK", {
        "content-type": match[1] || "text/plain"
      }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
    } catch (error2) {
      return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url2));
    }
  }
  function getIpfsGatewayFunc(baseUrl) {
    async function gatewayIpfs(url2, signal) {
      try {
        const match = url2.match(reIpfs);
        if (!match) {
          throw new Error("invalid link");
        }
        return new FetchRequest(`${baseUrl}${match[2]}`);
      } catch (error2) {
        return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url2));
      }
    }
    return gatewayIpfs;
  }
  var Gateways = {
    "data": dataGatewayFunc,
    "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
  };
  var fetchSignals = /* @__PURE__ */ new WeakMap();
  var FetchCancelSignal = class {
    #listeners;
    #cancelled;
    constructor(request) {
      this.#listeners = [];
      this.#cancelled = false;
      fetchSignals.set(request, () => {
        if (this.#cancelled) {
          return;
        }
        this.#cancelled = true;
        for (const listener of this.#listeners) {
          setTimeout(() => {
            listener();
          }, 0);
        }
        this.#listeners = [];
      });
    }
    addListener(listener) {
      assert2(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
        operation: "fetchCancelSignal.addCancelListener"
      });
      this.#listeners.push(listener);
    }
    get cancelled() {
      return this.#cancelled;
    }
    checkSignal() {
      assert2(!this.cancelled, "cancelled", "CANCELLED", {});
    }
  };
  function checkSignal(signal) {
    if (signal == null) {
      throw new Error("missing signal; should not happen");
    }
    signal.checkSignal();
    return signal;
  }
  var FetchRequest = class {
    #allowInsecure;
    #gzip;
    #headers;
    #method;
    #timeout;
    #url;
    #body;
    #bodyType;
    #creds;
    #preflight;
    #process;
    #retry;
    #signal;
    #throttle;
    #getUrlFunc;
    get url() {
      return this.#url;
    }
    set url(url2) {
      this.#url = String(url2);
    }
    get body() {
      if (this.#body == null) {
        return null;
      }
      return new Uint8Array(this.#body);
    }
    set body(body) {
      if (body == null) {
        this.#body = void 0;
        this.#bodyType = void 0;
      } else if (typeof body === "string") {
        this.#body = toUtf8Bytes(body);
        this.#bodyType = "text/plain";
      } else if (body instanceof Uint8Array) {
        this.#body = body;
        this.#bodyType = "application/octet-stream";
      } else if (typeof body === "object") {
        this.#body = toUtf8Bytes(JSON.stringify(body));
        this.#bodyType = "application/json";
      } else {
        throw new Error("invalid body");
      }
    }
    hasBody() {
      return this.#body != null;
    }
    get method() {
      if (this.#method) {
        return this.#method;
      }
      if (this.hasBody()) {
        return "POST";
      }
      return "GET";
    }
    set method(method) {
      if (method == null) {
        method = "";
      }
      this.#method = String(method).toUpperCase();
    }
    get headers() {
      const headers = Object.assign({}, this.#headers);
      if (this.#creds) {
        headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
      }
      if (this.allowGzip) {
        headers["accept-encoding"] = "gzip";
      }
      if (headers["content-type"] == null && this.#bodyType) {
        headers["content-type"] = this.#bodyType;
      }
      if (this.body) {
        headers["content-length"] = String(this.body.length);
      }
      return headers;
    }
    getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    setHeader(key, value) {
      this.#headers[String(key).toLowerCase()] = String(value);
    }
    clearHeaders() {
      this.#headers = {};
    }
    [Symbol.iterator]() {
      const headers = this.headers;
      const keys = Object.keys(headers);
      let index = 0;
      return {
        next: () => {
          if (index < keys.length) {
            const key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return { value: void 0, done: true };
        }
      };
    }
    get credentials() {
      return this.#creds || null;
    }
    setCredentials(username, password) {
      assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
      this.#creds = `${username}:${password}`;
    }
    get allowGzip() {
      return this.#gzip;
    }
    set allowGzip(value) {
      this.#gzip = !!value;
    }
    get allowInsecureAuthentication() {
      return !!this.#allowInsecure;
    }
    set allowInsecureAuthentication(value) {
      this.#allowInsecure = !!value;
    }
    get timeout() {
      return this.#timeout;
    }
    set timeout(timeout) {
      assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
      this.#timeout = timeout;
    }
    get preflightFunc() {
      return this.#preflight || null;
    }
    set preflightFunc(preflight) {
      this.#preflight = preflight;
    }
    get processFunc() {
      return this.#process || null;
    }
    set processFunc(process2) {
      this.#process = process2;
    }
    get retryFunc() {
      return this.#retry || null;
    }
    set retryFunc(retry) {
      this.#retry = retry;
    }
    get getUrlFunc() {
      return this.#getUrlFunc || defaultGetUrlFunc;
    }
    set getUrlFunc(value) {
      this.#getUrlFunc = value;
    }
    constructor(url2) {
      this.#url = String(url2);
      this.#allowInsecure = false;
      this.#gzip = true;
      this.#headers = {};
      this.#method = "";
      this.#timeout = 3e5;
      this.#throttle = {
        slotInterval: SLOT_INTERVAL,
        maxAttempts: MAX_ATTEMPTS
      };
      this.#getUrlFunc = null;
    }
    toString() {
      return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
    }
    setThrottleParams(params) {
      if (params.slotInterval != null) {
        this.#throttle.slotInterval = params.slotInterval;
      }
      if (params.maxAttempts != null) {
        this.#throttle.maxAttempts = params.maxAttempts;
      }
    }
    async #send(attempt, expires, delay, _request, _response) {
      if (attempt >= this.#throttle.maxAttempts) {
        return _response.makeServerError("exceeded maximum retry limit");
      }
      assert2(getTime$1() <= expires, "timeout", "TIMEOUT", {
        operation: "request.send",
        reason: "timeout",
        request: _request
      });
      if (delay > 0) {
        await wait(delay);
      }
      let req = this.clone();
      const scheme = (req.url.split(":")[0] || "").toLowerCase();
      if (scheme in Gateways) {
        const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
        if (result instanceof FetchResponse) {
          let response2 = result;
          if (this.processFunc) {
            checkSignal(_request.#signal);
            try {
              response2 = await this.processFunc(req, response2);
            } catch (error2) {
              if (error2.throttle == null || typeof error2.stall !== "number") {
                response2.makeServerError("error in post-processing function", error2).assertOk();
              }
            }
          }
          return response2;
        }
        req = result;
      }
      if (this.preflightFunc) {
        req = await this.preflightFunc(req);
      }
      const resp = await this.getUrlFunc(req, checkSignal(_request.#signal));
      let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
      if (response.statusCode === 301 || response.statusCode === 302) {
        try {
          const location = response.headers.location || "";
          return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
        } catch (error2) {
        }
        return response;
      } else if (response.statusCode === 429) {
        if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
          const retryAfter = response.headers["retry-after"];
          let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
            delay2 = parseInt(retryAfter);
          }
          return req.clone().#send(attempt + 1, expires, delay2, _request, response);
        }
      }
      if (this.processFunc) {
        checkSignal(_request.#signal);
        try {
          response = await this.processFunc(req, response);
        } catch (error2) {
          if (error2.throttle == null || typeof error2.stall !== "number") {
            response.makeServerError("error in post-processing function", error2).assertOk();
          }
          let delay2 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (error2.stall >= 0) {
            delay2 = error2.stall;
          }
          return req.clone().#send(attempt + 1, expires, delay2, _request, response);
        }
      }
      return response;
    }
    send() {
      assert2(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
      this.#signal = new FetchCancelSignal(this);
      return this.#send(0, getTime$1() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
    }
    cancel() {
      assert2(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
      const signal = fetchSignals.get(this);
      if (!signal) {
        throw new Error("missing signal; should not happen");
      }
      signal();
    }
    redirect(location) {
      const current = this.url.split(":")[0].toLowerCase();
      const target = location.split(":")[0].toLowerCase();
      assert2(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
        operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
      });
      const req = new FetchRequest(location);
      req.method = "GET";
      req.allowGzip = this.allowGzip;
      req.timeout = this.timeout;
      req.#headers = Object.assign({}, this.#headers);
      if (this.#body) {
        req.#body = new Uint8Array(this.#body);
      }
      req.#bodyType = this.#bodyType;
      return req;
    }
    clone() {
      const clone = new FetchRequest(this.url);
      clone.#method = this.#method;
      if (this.#body) {
        clone.#body = this.#body;
      }
      clone.#bodyType = this.#bodyType;
      clone.#headers = Object.assign({}, this.#headers);
      clone.#creds = this.#creds;
      if (this.allowGzip) {
        clone.allowGzip = true;
      }
      clone.timeout = this.timeout;
      if (this.allowInsecureAuthentication) {
        clone.allowInsecureAuthentication = true;
      }
      clone.#preflight = this.#preflight;
      clone.#process = this.#process;
      clone.#retry = this.#retry;
      clone.#throttle = Object.assign({}, this.#throttle);
      clone.#getUrlFunc = this.#getUrlFunc;
      return clone;
    }
    static lockConfig() {
      locked$1 = true;
    }
    static getGateway(scheme) {
      return Gateways[scheme.toLowerCase()] || null;
    }
    static registerGateway(scheme, func) {
      scheme = scheme.toLowerCase();
      if (scheme === "http" || scheme === "https") {
        throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
      }
      if (locked$1) {
        throw new Error("gateways locked");
      }
      Gateways[scheme] = func;
    }
    static registerGetUrl(getUrl) {
      if (locked$1) {
        throw new Error("gateways locked");
      }
      defaultGetUrlFunc = getUrl;
    }
    static createGetUrlFunc(options) {
      return createGetUrl();
    }
    static createDataGateway() {
      return dataGatewayFunc;
    }
    static createIpfsGatewayFunc(baseUrl) {
      return getIpfsGatewayFunc(baseUrl);
    }
  };
  var FetchResponse = class {
    #statusCode;
    #statusMessage;
    #headers;
    #body;
    #request;
    #error;
    toString() {
      return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
    }
    get statusCode() {
      return this.#statusCode;
    }
    get statusMessage() {
      return this.#statusMessage;
    }
    get headers() {
      return Object.assign({}, this.#headers);
    }
    get body() {
      return this.#body == null ? null : new Uint8Array(this.#body);
    }
    get bodyText() {
      try {
        return this.#body == null ? "" : toUtf8String(this.#body);
      } catch (error2) {
        assert2(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
          operation: "bodyText",
          info: { response: this }
        });
      }
    }
    get bodyJson() {
      try {
        return JSON.parse(this.bodyText);
      } catch (error2) {
        assert2(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
          operation: "bodyJson",
          info: { response: this }
        });
      }
    }
    [Symbol.iterator]() {
      const headers = this.headers;
      const keys = Object.keys(headers);
      let index = 0;
      return {
        next: () => {
          if (index < keys.length) {
            const key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return { value: void 0, done: true };
        }
      };
    }
    constructor(statusCode, statusMessage, headers, body, request) {
      this.#statusCode = statusCode;
      this.#statusMessage = statusMessage;
      this.#headers = Object.keys(headers).reduce((accum, k5) => {
        accum[k5.toLowerCase()] = String(headers[k5]);
        return accum;
      }, {});
      this.#body = body == null ? null : new Uint8Array(body);
      this.#request = request || null;
      this.#error = { message: "" };
    }
    makeServerError(message, error2) {
      let statusMessage;
      if (!message) {
        message = `${this.statusCode} ${this.statusMessage}`;
        statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
      } else {
        statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
      }
      const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || void 0);
      response.#error = { message, error: error2 };
      return response;
    }
    throwThrottleError(message, stall2) {
      if (stall2 == null) {
        stall2 = -1;
      } else {
        assertArgument(Number.isInteger(stall2) && stall2 >= 0, "invalid stall timeout", "stall", stall2);
      }
      const error2 = new Error(message || "throttling requests");
      defineProperties(error2, { stall: stall2, throttle: true });
      throw error2;
    }
    getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    hasBody() {
      return this.#body != null;
    }
    get request() {
      return this.#request;
    }
    ok() {
      return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
    }
    assertOk() {
      if (this.ok()) {
        return;
      }
      let { message, error: error2 } = this.#error;
      if (message === "") {
        message = `server response ${this.statusCode} ${this.statusMessage}`;
      }
      let requestUrl = null;
      if (this.request) {
        requestUrl = this.request.url;
      }
      let responseBody = null;
      try {
        if (this.#body) {
          responseBody = toUtf8String(this.#body);
        }
      } catch (e7) {
      }
      assert2(false, message, "SERVER_ERROR", {
        request: this.request || "unknown request",
        response: this,
        error: error2,
        info: {
          requestUrl,
          responseBody,
          responseStatus: `${this.statusCode} ${this.statusMessage}`
        }
      });
    }
  };
  function getTime$1() {
    return new Date().getTime();
  }
  function unpercent(value) {
    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code2) => {
      return String.fromCharCode(parseInt(code2, 16));
    }));
  }
  function wait(delay) {
    return new Promise((resolve2) => setTimeout(resolve2, delay));
  }
  var BN_N1 = BigInt(-1);
  var BN_0$8 = BigInt(0);
  var BN_1$3 = BigInt(1);
  var BN_5 = BigInt(5);
  var Zeros$1 = "0000";
  while (Zeros$1.length < 80) {
    Zeros$1 += Zeros$1;
  }
  function hexlifyByte(value) {
    let result = value.toString(16);
    while (result.length < 2) {
      result = "0" + result;
    }
    return "0x" + result;
  }
  function unarrayifyInteger(data, offset, length2) {
    let result = 0;
    for (let i4 = 0; i4 < length2; i4++) {
      result = result * 256 + data[offset + i4];
    }
    return result;
  }
  function _decodeChildren(data, offset, childOffset, length2) {
    const result = [];
    while (childOffset < offset + 1 + length2) {
      const decoded = _decode(data, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      assert2(childOffset <= offset + 1 + length2, "child data too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: length2,
        offset
      });
    }
    return { consumed: 1 + length2, result };
  }
  function _decode(data, offset) {
    assert2(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: 0,
      offset: 1
    });
    const checkOffset = (offset2) => {
      assert2(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: data.length,
        offset: offset2
      });
    };
    if (data[offset] >= 248) {
      const lengthLength = data[offset] - 247;
      checkOffset(offset + 1 + lengthLength);
      const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
      checkOffset(offset + 1 + lengthLength + length2);
      return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length2);
    } else if (data[offset] >= 192) {
      const length2 = data[offset] - 192;
      checkOffset(offset + 1 + length2);
      return _decodeChildren(data, offset, offset + 1, length2);
    } else if (data[offset] >= 184) {
      const lengthLength = data[offset] - 183;
      checkOffset(offset + 1 + lengthLength);
      const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
      checkOffset(offset + 1 + lengthLength + length2);
      const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
      return { consumed: 1 + lengthLength + length2, result };
    } else if (data[offset] >= 128) {
      const length2 = data[offset] - 128;
      checkOffset(offset + 1 + length2);
      const result = hexlify(data.slice(offset + 1, offset + 1 + length2));
      return { consumed: 1 + length2, result };
    }
    return { consumed: 1, result: hexlifyByte(data[offset]) };
  }
  function decodeRlp(_data) {
    const data = getBytes(_data, "data");
    const decoded = _decode(data, 0);
    assertArgument(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
    return decoded.result;
  }
  function arrayifyInteger(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  }
  function _encode(object2) {
    if (Array.isArray(object2)) {
      let payload = [];
      object2.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length3 = arrayifyInteger(payload.length);
      length3.unshift(247 + length3.length);
      return length3.concat(payload);
    }
    const data = Array.prototype.slice.call(getBytes(object2, "object"));
    if (data.length === 1 && data[0] <= 127) {
      return data;
    } else if (data.length <= 55) {
      data.unshift(128 + data.length);
      return data;
    }
    const length2 = arrayifyInteger(data.length);
    length2.unshift(183 + length2.length);
    return length2.concat(data);
  }
  var nibbles = "0123456789abcdef";
  function encodeRlp(object2) {
    let result = "0x";
    for (const v6 of _encode(object2)) {
      result += nibbles[v6 >> 4];
      result += nibbles[v6 & 15];
    }
    return result;
  }
  var WordSize = 32;
  var Padding = new Uint8Array(WordSize);
  var passProperties$1 = ["then"];
  var _guard$2 = {};
  var resultNames = /* @__PURE__ */ new WeakMap();
  function getNames(result) {
    return resultNames.get(result);
  }
  function setNames(result, names) {
    resultNames.set(result, names);
  }
  function throwError(name, error2) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error2;
    throw wrapped;
  }
  function toObject(names, items2, deep) {
    if (names.indexOf(null) >= 0) {
      return items2.map((item, index) => {
        if (item instanceof Result) {
          return toObject(getNames(item), item, deep);
        }
        return item;
      });
    }
    return names.reduce((accum, name, index) => {
      let item = items2.getValue(name);
      if (!(name in accum)) {
        if (deep && item instanceof Result) {
          item = toObject(getNames(item), item, deep);
        }
        accum[name] = item;
      }
      return accum;
    }, {});
  }
  var Result = class extends Array {
    #names;
    constructor(...args) {
      const guard = args[0];
      let items2 = args[1];
      let names = (args[2] || []).slice();
      let wrap = true;
      if (guard !== _guard$2) {
        items2 = args;
        names = [];
        wrap = false;
      }
      super(items2.length);
      items2.forEach((item, index) => {
        this[index] = item;
      });
      const nameCounts = names.reduce((accum, name) => {
        if (typeof name === "string") {
          accum.set(name, (accum.get(name) || 0) + 1);
        }
        return accum;
      }, /* @__PURE__ */ new Map());
      setNames(this, Object.freeze(items2.map((item, index) => {
        const name = names[index];
        if (name != null && nameCounts.get(name) === 1) {
          return name;
        }
        return null;
      })));
      this.#names = [];
      if (!wrap) {
        return;
      }
      Object.freeze(this);
      const proxy = new Proxy(this, {
        get: (target, prop, receiver) => {
          if (typeof prop === "string") {
            if (prop.match(/^[0-9]+$/)) {
              const index = getNumber(prop, "%index");
              if (index < 0 || index >= this.length) {
                throw new RangeError("out of result range");
              }
              const item = target[index];
              if (item instanceof Error) {
                throwError(`index ${index}`, item);
              }
              return item;
            }
            if (passProperties$1.indexOf(prop) >= 0) {
              return Reflect.get(target, prop, receiver);
            }
            const value = target[prop];
            if (value instanceof Function) {
              return function(...args2) {
                return value.apply(this === receiver ? target : this, args2);
              };
            } else if (!(prop in target)) {
              return target.getValue.apply(this === receiver ? target : this, [prop]);
            }
          }
          return Reflect.get(target, prop, receiver);
        }
      });
      setNames(proxy, getNames(this));
      return proxy;
    }
    toArray(deep) {
      const result = [];
      this.forEach((item, index) => {
        if (item instanceof Error) {
          throwError(`index ${index}`, item);
        }
        if (deep && item instanceof Result) {
          item = item.toArray(deep);
        }
        result.push(item);
      });
      return result;
    }
    toObject(deep) {
      const names = getNames(this);
      return names.reduce((accum, name, index) => {
        assert2(name != null, `value at index ${index} unnamed`, "UNSUPPORTED_OPERATION", {
          operation: "toObject()"
        });
        return toObject(names, this, deep);
      }, {});
    }
    slice(start, end) {
      if (start == null) {
        start = 0;
      }
      if (start < 0) {
        start += this.length;
        if (start < 0) {
          start = 0;
        }
      }
      if (end == null) {
        end = this.length;
      }
      if (end < 0) {
        end += this.length;
        if (end < 0) {
          end = 0;
        }
      }
      if (end > this.length) {
        end = this.length;
      }
      const _names = getNames(this);
      const result = [], names = [];
      for (let i4 = start; i4 < end; i4++) {
        result.push(this[i4]);
        names.push(_names[i4]);
      }
      return new Result(_guard$2, result, names);
    }
    filter(callback, thisArg) {
      const _names = getNames(this);
      const result = [], names = [];
      for (let i4 = 0; i4 < this.length; i4++) {
        const item = this[i4];
        if (item instanceof Error) {
          throwError(`index ${i4}`, item);
        }
        if (callback.call(thisArg, item, i4, this)) {
          result.push(item);
          names.push(_names[i4]);
        }
      }
      return new Result(_guard$2, result, names);
    }
    map(callback, thisArg) {
      const result = [];
      for (let i4 = 0; i4 < this.length; i4++) {
        const item = this[i4];
        if (item instanceof Error) {
          throwError(`index ${i4}`, item);
        }
        result.push(callback.call(thisArg, item, i4, this));
      }
      return result;
    }
    getValue(name) {
      const index = getNames(this).indexOf(name);
      if (index === -1) {
        return void 0;
      }
      const value = this[index];
      if (value instanceof Error) {
        throwError(`property ${JSON.stringify(name)}`, value.error);
      }
      return value;
    }
    static fromItems(items2, keys) {
      return new Result(_guard$2, items2, keys);
    }
  };
  function getValue$1(value) {
    let bytes2 = toBeArray(value);
    assert2(bytes2.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes2, length: WordSize, offset: bytes2.length });
    if (bytes2.length !== WordSize) {
      bytes2 = getBytesCopy(concat([Padding.slice(bytes2.length % WordSize), bytes2]));
    }
    return bytes2;
  }
  var Coder = class {
    name;
    type;
    localName;
    dynamic;
    constructor(name, type2, localName, dynamic2) {
      defineProperties(this, { name, type: type2, localName, dynamic: dynamic2 }, {
        name: "string",
        type: "string",
        localName: "string",
        dynamic: "boolean"
      });
    }
    _throwError(message, value) {
      assertArgument(false, message, this.localName, value);
    }
  };
  var Writer = class {
    #data;
    #dataLength;
    constructor() {
      this.#data = [];
      this.#dataLength = 0;
    }
    get data() {
      return concat(this.#data);
    }
    get length() {
      return this.#dataLength;
    }
    #writeData(data) {
      this.#data.push(data);
      this.#dataLength += data.length;
      return data.length;
    }
    appendWriter(writer) {
      return this.#writeData(getBytesCopy(writer.data));
    }
    writeBytes(value) {
      let bytes2 = getBytesCopy(value);
      const paddingOffset = bytes2.length % WordSize;
      if (paddingOffset) {
        bytes2 = getBytesCopy(concat([bytes2, Padding.slice(paddingOffset)]));
      }
      return this.#writeData(bytes2);
    }
    writeValue(value) {
      return this.#writeData(getValue$1(value));
    }
    writeUpdatableValue() {
      const offset = this.#data.length;
      this.#data.push(Padding);
      this.#dataLength += WordSize;
      return (value) => {
        this.#data[offset] = getValue$1(value);
      };
    }
  };
  var Reader = class {
    allowLoose;
    #data;
    #offset;
    #bytesRead;
    #parent;
    #maxInflation;
    constructor(data, allowLoose, maxInflation) {
      defineProperties(this, { allowLoose: !!allowLoose });
      this.#data = getBytesCopy(data);
      this.#bytesRead = 0;
      this.#parent = null;
      this.#maxInflation = maxInflation != null ? maxInflation : 1024;
      this.#offset = 0;
    }
    get data() {
      return hexlify(this.#data);
    }
    get dataLength() {
      return this.#data.length;
    }
    get consumed() {
      return this.#offset;
    }
    get bytes() {
      return new Uint8Array(this.#data);
    }
    #incrementBytesRead(count) {
      if (this.#parent) {
        return this.#parent.#incrementBytesRead(count);
      }
      this.#bytesRead += count;
      assert2(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
        buffer: getBytesCopy(this.#data),
        offset: this.#offset,
        length: count,
        info: {
          bytesRead: this.#bytesRead,
          dataLength: this.dataLength
        }
      });
    }
    #peekBytes(offset, length2, loose) {
      let alignedLength = Math.ceil(length2 / WordSize) * WordSize;
      if (this.#offset + alignedLength > this.#data.length) {
        if (this.allowLoose && loose && this.#offset + length2 <= this.#data.length) {
          alignedLength = length2;
        } else {
          assert2(false, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: getBytesCopy(this.#data),
            length: this.#data.length,
            offset: this.#offset + alignedLength
          });
        }
      }
      return this.#data.slice(this.#offset, this.#offset + alignedLength);
    }
    subReader(offset) {
      const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);
      reader.#parent = this;
      return reader;
    }
    readBytes(length2, loose) {
      let bytes2 = this.#peekBytes(0, length2, !!loose);
      this.#incrementBytesRead(length2);
      this.#offset += bytes2.length;
      return bytes2.slice(0, length2);
    }
    readValue() {
      return toBigInt(this.readBytes(WordSize));
    }
    readIndex() {
      return toNumber2(this.readBytes(WordSize));
    }
  };
  function number(n4) {
    if (!Number.isSafeInteger(n4) || n4 < 0)
      throw new Error(`Wrong positive integer: ${n4}`);
  }
  function bytes(b7, ...lengths) {
    if (!(b7 instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b7.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b7.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var crypto$1 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  var u8a$1 = (a4) => a4 instanceof Uint8Array;
  var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  function utf8ToBytes$1(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes$1(data);
    if (!u8a$1(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes$1(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a4) => sum + a4.length, 0));
    let pad = 0;
    arrays.forEach((a4) => {
      if (!u8a$1(a4))
        throw new Error("Uint8Array expected");
      r.set(a4, pad);
      pad += a4.length;
    });
    return r;
  }
  var Hash2 = class {
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto$1 && typeof crypto$1.getRandomValues === "function") {
      return crypto$1.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }
  var HMAC2 = class extends Hash2 {
    constructor(hash$12, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      hash(hash$12);
      const key = toBytes(_key);
      this.iHash = hash$12.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash$12.create().update(key).digest() : key);
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash$12.create();
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      exists(this);
      bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to2) {
      to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to2 = to2;
      to2.finished = finished;
      to2.destroyed = destroyed;
      to2.blockLen = blockLen;
      to2.outputLen = outputLen;
      to2.oHash = oHash._cloneInto(to2.oHash);
      to2.iHash = iHash._cloneInto(to2.iHash);
      return to2;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash2, key, message) => new HMAC2(hash2, key).update(message).digest();
  hmac.create = (hash2, key) => new HMAC2(hash2, key);
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh2 = Number(value >> _32n2 & _u32_max);
    const wl2 = Number(value & _u32_max);
    const h6 = isLE2 ? 4 : 0;
    const l6 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h6, wh2, isLE2);
    view.setUint32(byteOffset + l6, wl2, isLE2);
  }
  var SHA2 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      exists(this);
      output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i4 = pos; i4 < blockLen; i4++)
        buffer[i4] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i4 = 0; i4 < outLen; i4++)
        oview.setUint32(4 * i4, state[i4], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to2) {
      to2 || (to2 = new this.constructor());
      to2.set(...this.get());
      const { blockLen, buffer, length: length2, finished, destroyed, pos } = this;
      to2.length = length2;
      to2.pos = pos;
      to2.finished = finished;
      to2.destroyed = destroyed;
      if (length2 % blockLen)
        to2.buffer.set(buffer);
      return to2;
    }
  };
  var Chi = (a4, b7, c3) => a4 & b7 ^ ~a4 & c3;
  var Maj = (a4, b7, c3) => a4 & b7 ^ a4 & c3 ^ b7 & c3;
  var SHA256_K = /* @__PURE__ */ new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = /* @__PURE__ */ new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA2562 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A: A5, B: B6, C: C5, D: D4, E: E4, F: F4, G: G7, H: H4 } = this;
      return [A5, B6, C5, D4, E4, F4, G7, H4];
    }
    set(A5, B6, C5, D4, E4, F4, G7, H4) {
      this.A = A5 | 0;
      this.B = B6 | 0;
      this.C = C5 | 0;
      this.D = D4 | 0;
      this.E = E4 | 0;
      this.F = F4 | 0;
      this.G = G7 | 0;
      this.H = H4 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        SHA256_W[i4] = view.getUint32(offset, false);
      for (let i4 = 16; i4 < 64; i4++) {
        const W15 = SHA256_W[i4 - 15];
        const W22 = SHA256_W[i4 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
        SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
      }
      let { A: A5, B: B6, C: C5, D: D4, E: E4, F: F4, G: G7, H: H4 } = this;
      for (let i4 = 0; i4 < 64; i4++) {
        const sigma1 = rotr(E4, 6) ^ rotr(E4, 11) ^ rotr(E4, 25);
        const T12 = H4 + sigma1 + Chi(E4, F4, G7) + SHA256_K[i4] + SHA256_W[i4] | 0;
        const sigma0 = rotr(A5, 2) ^ rotr(A5, 13) ^ rotr(A5, 22);
        const T22 = sigma0 + Maj(A5, B6, C5) | 0;
        H4 = G7;
        G7 = F4;
        F4 = E4;
        E4 = D4 + T12 | 0;
        D4 = C5;
        C5 = B6;
        B6 = A5;
        A5 = T12 + T22 | 0;
      }
      A5 = A5 + this.A | 0;
      B6 = B6 + this.B | 0;
      C5 = C5 + this.C | 0;
      D4 = D4 + this.D | 0;
      E4 = E4 + this.E | 0;
      F4 = F4 + this.F | 0;
      G7 = G7 + this.G | 0;
      H4 = H4 + this.H | 0;
      this.set(A5, B6, C5, D4, E4, F4, G7, H4);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var sha256$1 = /* @__PURE__ */ wrapConstructor(() => new SHA2562());
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n4, le2 = false) {
    if (le2)
      return { h: Number(n4 & U32_MASK64), l: Number(n4 >> _32n & U32_MASK64) };
    return { h: Number(n4 >> _32n & U32_MASK64) | 0, l: Number(n4 & U32_MASK64) | 0 };
  }
  function split$1(lst, le2 = false) {
    let Ah2 = new Uint32Array(lst.length);
    let Al2 = new Uint32Array(lst.length);
    for (let i4 = 0; i4 < lst.length; i4++) {
      const { h: h6, l: l6 } = fromBig(lst[i4], le2);
      [Ah2[i4], Al2[i4]] = [h6, l6];
    }
    return [Ah2, Al2];
  }
  var toBig = (h6, l6) => BigInt(h6 >>> 0) << _32n | BigInt(l6 >>> 0);
  var shrSH = (h6, _l2, s3) => h6 >>> s3;
  var shrSL = (h6, l6, s3) => h6 << 32 - s3 | l6 >>> s3;
  var rotrSH = (h6, l6, s3) => h6 >>> s3 | l6 << 32 - s3;
  var rotrSL = (h6, l6, s3) => h6 << 32 - s3 | l6 >>> s3;
  var rotrBH = (h6, l6, s3) => h6 << 64 - s3 | l6 >>> s3 - 32;
  var rotrBL = (h6, l6, s3) => h6 >>> s3 - 32 | l6 << 64 - s3;
  var rotr32H = (_h2, l6) => l6;
  var rotr32L = (h6, _l2) => h6;
  var rotlSH = (h6, l6, s3) => h6 << s3 | l6 >>> 32 - s3;
  var rotlSL = (h6, l6, s3) => l6 << s3 | h6 >>> 32 - s3;
  var rotlBH = (h6, l6, s3) => l6 << s3 - 32 | h6 >>> 64 - s3;
  var rotlBL = (h6, l6, s3) => h6 << s3 - 32 | l6 >>> 64 - s3;
  function add2(Ah2, Al2, Bh2, Bl2) {
    const l6 = (Al2 >>> 0) + (Bl2 >>> 0);
    return { h: Ah2 + Bh2 + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
  }
  var add3L = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
  var add3H = (low, Ah2, Bh2, Ch2) => Ah2 + Bh2 + Ch2 + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
  var add4H = (low, Ah2, Bh2, Ch2, Dh2) => Ah2 + Bh2 + Ch2 + Dh2 + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
  var add5H = (low, Ah2, Bh2, Ch2, Dh2, Eh2) => Ah2 + Bh2 + Ch2 + Dh2 + Eh2 + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split: split$1,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add: add2,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n4) => BigInt(n4))))();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA5122 = class extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    get() {
      const { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
      return [Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2];
    }
    set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2) {
      this.Ah = Ah2 | 0;
      this.Al = Al2 | 0;
      this.Bh = Bh2 | 0;
      this.Bl = Bl2 | 0;
      this.Ch = Ch2 | 0;
      this.Cl = Cl2 | 0;
      this.Dh = Dh2 | 0;
      this.Dl = Dl2 | 0;
      this.Eh = Eh2 | 0;
      this.El = El2 | 0;
      this.Fh = Fh2 | 0;
      this.Fl = Fl2 | 0;
      this.Gh = Gh2 | 0;
      this.Gl = Gl2 | 0;
      this.Hh = Hh2 | 0;
      this.Hl = Hl2 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4) {
        SHA512_W_H[i4] = view.getUint32(offset);
        SHA512_W_L[i4] = view.getUint32(offset += 4);
      }
      for (let i4 = 16; i4 < 80; i4++) {
        const W15h = SHA512_W_H[i4 - 15] | 0;
        const W15l = SHA512_W_L[i4 - 15] | 0;
        const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
        const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i4 - 2] | 0;
        const W2l = SHA512_W_L[i4 - 2] | 0;
        const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
        const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
        const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
        const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
        SHA512_W_H[i4] = SUMh | 0;
        SHA512_W_L[i4] = SUMl | 0;
      }
      let { Ah: Ah2, Al: Al2, Bh: Bh2, Bl: Bl2, Ch: Ch2, Cl: Cl2, Dh: Dh2, Dl: Dl2, Eh: Eh2, El: El2, Fh: Fh2, Fl: Fl2, Gh: Gh2, Gl: Gl2, Hh: Hh2, Hl: Hl2 } = this;
      for (let i4 = 0; i4 < 80; i4++) {
        const sigma1h = u64.rotrSH(Eh2, El2, 14) ^ u64.rotrSH(Eh2, El2, 18) ^ u64.rotrBH(Eh2, El2, 41);
        const sigma1l = u64.rotrSL(Eh2, El2, 14) ^ u64.rotrSL(Eh2, El2, 18) ^ u64.rotrBL(Eh2, El2, 41);
        const CHIh = Eh2 & Fh2 ^ ~Eh2 & Gh2;
        const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
        const T1ll = u64.add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
        const T1h = u64.add5H(T1ll, Hh2, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
        const T1l = T1ll | 0;
        const sigma0h = u64.rotrSH(Ah2, Al2, 28) ^ u64.rotrBH(Ah2, Al2, 34) ^ u64.rotrBH(Ah2, Al2, 39);
        const sigma0l = u64.rotrSL(Ah2, Al2, 28) ^ u64.rotrBL(Ah2, Al2, 34) ^ u64.rotrBL(Ah2, Al2, 39);
        const MAJh = Ah2 & Bh2 ^ Ah2 & Ch2 ^ Bh2 & Ch2;
        const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
        Hh2 = Gh2 | 0;
        Hl2 = Gl2 | 0;
        Gh2 = Fh2 | 0;
        Gl2 = Fl2 | 0;
        Fh2 = Eh2 | 0;
        Fl2 = El2 | 0;
        ({ h: Eh2, l: El2 } = u64.add(Dh2 | 0, Dl2 | 0, T1h | 0, T1l | 0));
        Dh2 = Ch2 | 0;
        Dl2 = Cl2 | 0;
        Ch2 = Bh2 | 0;
        Cl2 = Bl2 | 0;
        Bh2 = Ah2 | 0;
        Bl2 = Al2 | 0;
        const All = u64.add3L(T1l, sigma0l, MAJl);
        Ah2 = u64.add3H(All, T1h, sigma0h, MAJh);
        Al2 = All | 0;
      }
      ({ h: Ah2, l: Al2 } = u64.add(this.Ah | 0, this.Al | 0, Ah2 | 0, Al2 | 0));
      ({ h: Bh2, l: Bl2 } = u64.add(this.Bh | 0, this.Bl | 0, Bh2 | 0, Bl2 | 0));
      ({ h: Ch2, l: Cl2 } = u64.add(this.Ch | 0, this.Cl | 0, Ch2 | 0, Cl2 | 0));
      ({ h: Dh2, l: Dl2 } = u64.add(this.Dh | 0, this.Dl | 0, Dh2 | 0, Dl2 | 0));
      ({ h: Eh2, l: El2 } = u64.add(this.Eh | 0, this.El | 0, Eh2 | 0, El2 | 0));
      ({ h: Fh2, l: Fl2 } = u64.add(this.Fh | 0, this.Fl | 0, Fh2 | 0, Fl2 | 0));
      ({ h: Gh2, l: Gl2 } = u64.add(this.Gh | 0, this.Gl | 0, Gh2 | 0, Gl2 | 0));
      ({ h: Hh2, l: Hl2 } = u64.add(this.Hh | 0, this.Hl | 0, Hh2 | 0, Hl2 | 0));
      this.set(Ah2, Al2, Bh2, Bl2, Ch2, Cl2, Dh2, Dl2, Eh2, El2, Fh2, Fl2, Gh2, Gl2, Hh2, Hl2);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA5122());
  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  }
  getGlobal();
  function createHash(algo) {
    switch (algo) {
      case "sha256":
        return sha256$1.create();
      case "sha512":
        return sha512.create();
    }
    assertArgument(false, "invalid hashing algorithm name", "algorithm", algo);
  }
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n$4 = /* @__PURE__ */ BigInt(0);
  var _1n$5 = /* @__PURE__ */ BigInt(1);
  var _2n$3 = /* @__PURE__ */ BigInt(2);
  var _7n = /* @__PURE__ */ BigInt(7);
  var _256n = /* @__PURE__ */ BigInt(256);
  var _0x71n = /* @__PURE__ */ BigInt(113);
  for (let round = 0, R5 = _1n$5, x6 = 1, y5 = 0; round < 24; round++) {
    [x6, y5] = [y5, (2 * x6 + 3 * y5) % 5];
    SHA3_PI.push(2 * (5 * y5 + x6));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n$4;
    for (let j5 = 0; j5 < 7; j5++) {
      R5 = (R5 << _1n$5 ^ (R5 >> _7n) * _0x71n) % _256n;
      if (R5 & _2n$3)
        t ^= _1n$5 << (_1n$5 << /* @__PURE__ */ BigInt(j5)) - _1n$5;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split$1(_SHA3_IOTA, true);
  var rotlH = (h6, l6, s3) => s3 > 32 ? rotlBH(h6, l6, s3) : rotlSH(h6, l6, s3);
  var rotlL = (h6, l6, s3) => s3 > 32 ? rotlBL(h6, l6, s3) : rotlSL(h6, l6, s3);
  function keccakP(s3, rounds = 24) {
    const B6 = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x6 = 0; x6 < 10; x6++)
        B6[x6] = s3[x6] ^ s3[x6 + 10] ^ s3[x6 + 20] ^ s3[x6 + 30] ^ s3[x6 + 40];
      for (let x6 = 0; x6 < 10; x6 += 2) {
        const idx1 = (x6 + 8) % 10;
        const idx0 = (x6 + 2) % 10;
        const B0 = B6[idx0];
        const B1 = B6[idx0 + 1];
        const Th2 = rotlH(B0, B1, 1) ^ B6[idx1];
        const Tl2 = rotlL(B0, B1, 1) ^ B6[idx1 + 1];
        for (let y5 = 0; y5 < 50; y5 += 10) {
          s3[x6 + y5] ^= Th2;
          s3[x6 + y5 + 1] ^= Tl2;
        }
      }
      let curH = s3[2];
      let curL = s3[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th2 = rotlH(curH, curL, shift);
        const Tl2 = rotlL(curH, curL, shift);
        const PI2 = SHA3_PI[t];
        curH = s3[PI2];
        curL = s3[PI2 + 1];
        s3[PI2] = Th2;
        s3[PI2 + 1] = Tl2;
      }
      for (let y5 = 0; y5 < 50; y5 += 10) {
        for (let x6 = 0; x6 < 10; x6++)
          B6[x6] = s3[y5 + x6];
        for (let x6 = 0; x6 < 10; x6++)
          s3[y5 + x6] ^= ~B6[(x6 + 2) % 10] & B6[(x6 + 4) % 10];
      }
      s3[0] ^= SHA3_IOTA_H[round];
      s3[1] ^= SHA3_IOTA_L[round];
    }
    B6.fill(0);
  }
  var Keccak2 = class extends Hash2 {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u322(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i4 = 0; i4 < take; i4++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      exists(this, false);
      bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      number(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to2) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to2 || (to2 = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to2.state32.set(this.state32);
      to2.pos = this.pos;
      to2.posOut = this.posOut;
      to2.finished = this.finished;
      to2.rounds = rounds;
      to2.suffix = suffix;
      to2.outputLen = outputLen;
      to2.enableXOF = enableXOF;
      to2.destroyed = this.destroyed;
      return to2;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak2(blockLen, suffix, outputLen));
  var keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  var locked = false;
  var _keccak256 = function(data) {
    return keccak_256(data);
  };
  var __keccak256 = _keccak256;
  function keccak2562(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__keccak256(data));
  }
  keccak2562._ = _keccak256;
  keccak2562.lock = function() {
    locked = true;
  };
  keccak2562.register = function(func) {
    if (locked) {
      throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
  };
  Object.freeze(keccak2562);
  var _sha256 = function(data) {
    return createHash("sha256").update(data).digest();
  };
  var __sha256 = _sha256;
  var locked256 = false;
  function sha256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__sha256(data));
  }
  sha256._ = _sha256;
  sha256.lock = function() {
    locked256 = true;
  };
  sha256.register = function(func) {
    if (locked256) {
      throw new Error("sha256 is locked");
    }
    __sha256 = func;
  };
  Object.freeze(sha256);
  Object.freeze(sha256);
  var _0n$3 = BigInt(0);
  var _1n$4 = BigInt(1);
  var _2n$2 = BigInt(2);
  var u8a = (a4) => a4 instanceof Uint8Array;
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_5, i4) => i4.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      hex2 += hexes[bytes2[i4]];
    }
    return hex2;
  }
  function numberToHexUnpadded(num) {
    const hex2 = num.toString(16);
    return hex2.length & 1 ? `0${hex2}` : hex2;
  }
  function hexToNumber(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
  }
  function hexToBytes(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    const len = hex2.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i4 = 0; i4 < array.length; i4++) {
      const j5 = i4 * 2;
      const hexByte = hex2.slice(j5, j5 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i4] = byte;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n4, len) {
    return hexToBytes(n4.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n4, len) {
    return numberToBytesBE(n4, len).reverse();
  }
  function numberToVarBytesBE(n4) {
    return hexToBytes(numberToHexUnpadded(n4));
  }
  function ensureBytes(title2, hex2, expectedLength) {
    let res;
    if (typeof hex2 === "string") {
      try {
        res = hexToBytes(hex2);
      } catch (e7) {
        throw new Error(`${title2} must be valid hex string, got "${hex2}". Cause: ${e7}`);
      }
    } else if (u8a(hex2)) {
      res = Uint8Array.from(hex2);
    } else {
      throw new Error(`${title2} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title2} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a4) => sum + a4.length, 0));
    let pad = 0;
    arrays.forEach((a4) => {
      if (!u8a(a4))
        throw new Error("Uint8Array expected");
      r.set(a4, pad);
      pad += a4.length;
    });
    return r;
  }
  function equalBytes(b1, b22) {
    if (b1.length !== b22.length)
      return false;
    for (let i4 = 0; i4 < b1.length; i4++)
      if (b1[i4] !== b22[i4])
        return false;
    return true;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n4) {
    let len;
    for (len = 0; n4 > _0n$3; n4 >>= _1n$4, len += 1)
      ;
    return len;
  }
  function bitGet(n4, pos) {
    return n4 >> BigInt(pos) & _1n$4;
  }
  var bitSet = (n4, pos, value) => {
    return n4 | (value ? _1n$4 : _0n$3) << BigInt(pos);
  };
  var bitMask = (n4) => (_2n$2 << BigInt(n4 - 1)) - _1n$4;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v6 = u8n(hashLen);
    let k5 = u8n(hashLen);
    let i4 = 0;
    const reset = () => {
      v6.fill(1);
      k5.fill(0);
      i4 = 0;
    };
    const h6 = (...b7) => hmacFn(k5, v6, ...b7);
    const reseed = (seed = u8n()) => {
      k5 = h6(u8fr([0]), seed);
      v6 = h6();
      if (seed.length === 0)
        return;
      k5 = h6(u8fr([1]), seed);
      v6 = h6();
    };
    const gen2 = () => {
      if (i4++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v6 = h6();
        const sl2 = v6.slice();
        out.push(sl2);
        len += v6.length;
      }
      return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen2())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object2) => object2.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object2, validators, optValidators = {}) {
    const checkField = (fieldName, type2, isOptional) => {
      const checkVal = validatorFns[type2];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type2}", expected function`);
      const val = object2[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object2)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type2}`);
      }
    };
    for (const [fieldName, type2] of Object.entries(validators))
      checkField(fieldName, type2, false);
    for (const [fieldName, type2] of Object.entries(optValidators))
      checkField(fieldName, type2, true);
    return object2;
  }
  var ut2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    bitGet,
    bitLen,
    bitMask,
    bitSet,
    bytesToHex,
    bytesToNumberBE,
    bytesToNumberLE,
    concatBytes,
    createHmacDrbg,
    ensureBytes,
    equalBytes,
    hexToBytes,
    hexToNumber,
    numberToBytesBE,
    numberToBytesLE,
    numberToHexUnpadded,
    numberToVarBytesBE,
    utf8ToBytes,
    validateObject
  });
  var _0n$2 = BigInt(0);
  var _1n$3 = BigInt(1);
  var _2n$1 = BigInt(2);
  var _3n$1 = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  BigInt(9);
  BigInt(16);
  function mod2(a4, b7) {
    const result = a4 % b7;
    return result >= _0n$2 ? result : b7 + result;
  }
  function pow2(num, power, modulo) {
    if (modulo <= _0n$2 || power < _0n$2)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n$3)
      return _0n$2;
    let res = _1n$3;
    while (power > _0n$2) {
      if (power & _1n$3)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n$3;
    }
    return res;
  }
  function pow22(x6, power, modulo) {
    let res = x6;
    while (power-- > _0n$2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n$2 || modulo <= _0n$2) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a4 = mod2(number2, modulo);
    let b7 = modulo;
    let x6 = _0n$2, u4 = _1n$3;
    while (a4 !== _0n$2) {
      const q5 = b7 / a4;
      const r = b7 % a4;
      const m5 = x6 - u4 * q5;
      b7 = a4, a4 = r, x6 = u4, u4 = m5;
    }
    const gcd2 = b7;
    if (gcd2 !== _1n$3)
      throw new Error("invert: does not exist");
    return mod2(x6, modulo);
  }
  function tonelliShanks(P5) {
    const legendreC = (P5 - _1n$3) / _2n$1;
    let Q5, S6, Z5;
    for (Q5 = P5 - _1n$3, S6 = 0; Q5 % _2n$1 === _0n$2; Q5 /= _2n$1, S6++)
      ;
    for (Z5 = _2n$1; Z5 < P5 && pow2(Z5, legendreC, P5) !== P5 - _1n$3; Z5++)
      ;
    if (S6 === 1) {
      const p1div4 = (P5 + _1n$3) / _4n;
      return function tonelliFast(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q5 + _1n$3) / _2n$1;
    return function tonelliSlow(Fp2, n4) {
      if (Fp2.pow(n4, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r = S6;
      let g5 = Fp2.pow(Fp2.mul(Fp2.ONE, Z5), Q5);
      let x6 = Fp2.pow(n4, Q1div2);
      let b7 = Fp2.pow(n4, Q5);
      while (!Fp2.eql(b7, Fp2.ONE)) {
        if (Fp2.eql(b7, Fp2.ZERO))
          return Fp2.ZERO;
        let m5 = 1;
        for (let t2 = Fp2.sqr(b7); m5 < r; m5++) {
          if (Fp2.eql(t2, Fp2.ONE))
            break;
          t2 = Fp2.sqr(t2);
        }
        const ge2 = Fp2.pow(g5, _1n$3 << BigInt(r - m5 - 1));
        g5 = Fp2.sqr(ge2);
        x6 = Fp2.mul(x6, ge2);
        b7 = Fp2.mul(b7, g5);
        r = m5;
      }
      return x6;
    };
  }
  function FpSqrt(P5) {
    if (P5 % _4n === _3n$1) {
      const p1div4 = (P5 + _1n$3) / _4n;
      return function sqrt3mod4(Fp2, n4) {
        const root = Fp2.pow(n4, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P5 % _8n === _5n) {
      const c1 = (P5 - _5n) / _8n;
      return function sqrt5mod8(Fp2, n4) {
        const n22 = Fp2.mul(n4, _2n$1);
        const v6 = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n4, v6);
        const i4 = Fp2.mul(Fp2.mul(nv, _2n$1), v6);
        const root = Fp2.mul(nv, Fp2.sub(i4, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n4))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    return tonelliShanks(P5);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f5, num, power) {
    if (power < _0n$2)
      throw new Error("Expected power > 0");
    if (power === _0n$2)
      return f5.ONE;
    if (power === _1n$3)
      return num;
    let p6 = f5.ONE;
    let d5 = num;
    while (power > _0n$2) {
      if (power & _1n$3)
        p6 = f5.mul(p6, d5);
      d5 = f5.sqr(d5);
      power >>= _1n$3;
    }
    return p6;
  }
  function FpInvertBatch(f5, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = acc;
      return f5.mul(acc, num);
    }, f5.ONE);
    const inverted = f5.inv(lastMultiplied);
    nums.reduceRight((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = f5.mul(acc, tmp[i4]);
      return f5.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n4, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n4.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n$2)
      throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f5 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n$2,
      ONE: _1n$3,
      create: (num) => mod2(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n$2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n$2,
      isOdd: (num) => (num & _1n$3) === _1n$3,
      neg: (num) => mod2(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod2(num * num, ORDER),
      add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f5, num, power),
      div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n4) => sqrtP(f5, n4)),
      invertBatch: (lst) => FpInvertBatch(f5, lst),
      cmov: (a4, b7, c3) => c3 ? b7 : a4,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f5);
  }
  function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== "bigint")
      throw new Error("field order must be bigint");
    const bitLength2 = fieldOrder.toString(2).length;
    return Math.ceil(bitLength2 / 8);
  }
  function getMinHashLength(fieldOrder) {
    const length2 = getFieldBytesLength(fieldOrder);
    return length2 + Math.ceil(length2 / 2);
  }
  function mapHashToField(key, fieldOrder, isLE2 = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    if (len < 16 || len < minLen || len > 1024)
      throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
    const reduced = mod2(num, fieldOrder - _1n$3) + _1n$3;
    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
  }
  var _0n$1 = BigInt(0);
  var _1n$2 = BigInt(1);
  function wNAF(c3, bits2) {
    const constTimeNegate = (condition, item) => {
      const neg2 = item.negate();
      return condition ? neg2 : item;
    };
    const opts = (W5) => {
      const windows = Math.ceil(bits2 / W5) + 1;
      const windowSize = 2 ** (W5 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      unsafeLadder(elm, n4) {
        let p6 = c3.ZERO;
        let d5 = elm;
        while (n4 > _0n$1) {
          if (n4 & _1n$2)
            p6 = p6.add(d5);
          d5 = d5.double();
          n4 >>= _1n$2;
        }
        return p6;
      },
      precomputeWindow(elm, W5) {
        const { windows, windowSize } = opts(W5);
        const points = [];
        let p6 = elm;
        let base3 = p6;
        for (let window2 = 0; window2 < windows; window2++) {
          base3 = p6;
          points.push(base3);
          for (let i4 = 1; i4 < windowSize; i4++) {
            base3 = base3.add(p6);
            points.push(base3);
          }
          p6 = base3.double();
        }
        return points;
      },
      wNAF(W5, precomputes, n4) {
        const { windows, windowSize } = opts(W5);
        let p6 = c3.ZERO;
        let f5 = c3.BASE;
        const mask2 = BigInt(2 ** W5 - 1);
        const maxNumber = 2 ** W5;
        const shiftBy = BigInt(W5);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n4 & mask2);
          n4 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n4 += _1n$2;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f5 = f5.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p6 = p6.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p6, f: f5 };
      },
      wNAFCached(P5, precomputesMap, n4, transform) {
        const W5 = P5._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P5);
        if (!comp) {
          comp = this.precomputeWindow(P5, W5);
          if (W5 !== 1) {
            precomputesMap.set(P5, transform(comp));
          }
        }
        return this.wNAF(W5, comp, n4);
      }
    };
  }
  function validateBasic(curve2) {
    validateField(curve2.Fp);
    validateObject(curve2, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve2.n, curve2.nBitLength),
      ...curve2,
      ...{ p: curve2.Fp.ORDER }
    });
  }
  function validatePointOpts(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a: a4 } = opts;
    if (endo) {
      if (!Fp2.eql(a4, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut2;
  var DER = {
    Err: class DERErr2 extends Error {
      constructor(m5 = "") {
        super(m5);
      }
    },
    _parseInt(data) {
      const { Err: E4 } = DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E4("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E4("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E4("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E4("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex2) {
      const { Err: E4 } = DER;
      const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
      if (!(data instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l6 = data.length;
      if (l6 < 2 || data[0] != 48)
        throw new E4("Invalid signature tag");
      if (data[1] !== l6 - 2)
        throw new E4("Invalid signature: incorrect length");
      const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
      const { d: s3, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E4("Invalid signature: left bytes after parsing");
      return { r, s: s3 };
    },
    hexFromSig(sig) {
      const slice = (s4) => Number.parseInt(s4[0], 16) & 8 ? "00" + s4 : s4;
      const h6 = (num) => {
        const hex2 = num.toString(16);
        return hex2.length & 1 ? `0${hex2}` : hex2;
      };
      const s3 = slice(h6(sig.s));
      const r = slice(h6(sig.r));
      const shl2 = s3.length / 2;
      const rhl = r.length / 2;
      const sl2 = h6(shl2);
      const rl2 = h6(rhl);
      return `30${h6(rhl + shl2 + 4)}02${rl2}${r}02${sl2}${s3}`;
    }
  };
  var _0n = BigInt(0);
  var _1n$1 = BigInt(1);
  BigInt(2);
  var _3n = BigInt(3);
  BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes2 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
      const a4 = point.toAffine();
      return concatBytes(Uint8Array.from([4]), Fp2.toBytes(a4.x), Fp2.toBytes(a4.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x6 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y5 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x: x6, y: y5 };
    });
    function weierstrassEquation(x6) {
      const { a: a4, b: b7 } = CURVE;
      const x22 = Fp2.sqr(x6);
      const x32 = Fp2.mul(x22, x6);
      return Fp2.add(Fp2.add(x32, Fp2.mul(x6, a4)), b7);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n4 } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error2) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod2(num, n4);
      assertGE(num);
      return num;
    }
    const pointPrecomputes2 = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point))
        throw new Error("ProjectivePoint expected");
    }
    class Point {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      static fromAffine(p6) {
        const { x: x6, y: y5 } = p6 || {};
        if (!p6 || !Fp2.isValid(x6) || !Fp2.isValid(y5))
          throw new Error("invalid affine point");
        if (p6 instanceof Point)
          throw new Error("projective point not allowed");
        const is0 = (i4) => Fp2.eql(i4, Fp2.ZERO);
        if (is0(x6) && is0(y5))
          return Point.ZERO;
        return new Point(x6, y5, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p6) => p6.pz));
        return points.map((p6, i4) => p6.toAffine(toInv[i4])).map(Point.fromAffine);
      }
      static fromHex(hex2) {
        const P5 = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
        P5.assertValidity();
        return P5;
      }
      static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes2.delete(this);
      }
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: x6, y: y5 } = this.toAffine();
        if (!Fp2.isValid(x6) || !Fp2.isValid(y5))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y5);
        const right = weierstrassEquation(x6);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: y5 } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y5);
        throw new Error("Field doesn't support isOdd");
      }
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X22, Z1));
        const U22 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
        return U1 && U22;
      }
      negate() {
        return new Point(this.px, Fp2.neg(this.py), this.pz);
      }
      double() {
        const { a: a4, b: b7 } = CURVE;
        const b32 = Fp2.mul(b7, _3n);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X32 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t2 = Fp2.mul(Z1, Z1);
        let t3 = Fp2.mul(X1, Y1);
        t3 = Fp2.add(t3, t3);
        Z32 = Fp2.mul(X1, Z1);
        Z32 = Fp2.add(Z32, Z32);
        X32 = Fp2.mul(a4, Z32);
        Y32 = Fp2.mul(b32, t2);
        Y32 = Fp2.add(X32, Y32);
        X32 = Fp2.sub(t1, Y32);
        Y32 = Fp2.add(t1, Y32);
        Y32 = Fp2.mul(X32, Y32);
        X32 = Fp2.mul(t3, X32);
        Z32 = Fp2.mul(b32, Z32);
        t2 = Fp2.mul(a4, t2);
        t3 = Fp2.sub(t0, t2);
        t3 = Fp2.mul(a4, t3);
        t3 = Fp2.add(t3, Z32);
        Z32 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z32, t0);
        t0 = Fp2.add(t0, t2);
        t0 = Fp2.mul(t0, t3);
        Y32 = Fp2.add(Y32, t0);
        t2 = Fp2.mul(Y1, Z1);
        t2 = Fp2.add(t2, t2);
        t0 = Fp2.mul(t2, t3);
        X32 = Fp2.sub(X32, t0);
        Z32 = Fp2.mul(t2, t1);
        Z32 = Fp2.add(Z32, Z32);
        Z32 = Fp2.add(Z32, Z32);
        return new Point(X32, Y32, Z32);
      }
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X22, py: Y22, pz: Z22 } = other;
        let X32 = Fp2.ZERO, Y32 = Fp2.ZERO, Z32 = Fp2.ZERO;
        const a4 = CURVE.a;
        const b32 = Fp2.mul(CURVE.b, _3n);
        let t0 = Fp2.mul(X1, X22);
        let t1 = Fp2.mul(Y1, Y22);
        let t2 = Fp2.mul(Z1, Z22);
        let t3 = Fp2.add(X1, Y1);
        let t4 = Fp2.add(X22, Y22);
        t3 = Fp2.mul(t3, t4);
        t4 = Fp2.add(t0, t1);
        t3 = Fp2.sub(t3, t4);
        t4 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X22, Z22);
        t4 = Fp2.mul(t4, t5);
        t5 = Fp2.add(t0, t2);
        t4 = Fp2.sub(t4, t5);
        t5 = Fp2.add(Y1, Z1);
        X32 = Fp2.add(Y22, Z22);
        t5 = Fp2.mul(t5, X32);
        X32 = Fp2.add(t1, t2);
        t5 = Fp2.sub(t5, X32);
        Z32 = Fp2.mul(a4, t4);
        X32 = Fp2.mul(b32, t2);
        Z32 = Fp2.add(X32, Z32);
        X32 = Fp2.sub(t1, Z32);
        Z32 = Fp2.add(t1, Z32);
        Y32 = Fp2.mul(X32, Z32);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t2 = Fp2.mul(a4, t2);
        t4 = Fp2.mul(b32, t4);
        t1 = Fp2.add(t1, t2);
        t2 = Fp2.sub(t0, t2);
        t2 = Fp2.mul(a4, t2);
        t4 = Fp2.add(t4, t2);
        t0 = Fp2.mul(t1, t4);
        Y32 = Fp2.add(Y32, t0);
        t0 = Fp2.mul(t5, t4);
        X32 = Fp2.mul(t3, X32);
        X32 = Fp2.sub(X32, t0);
        t0 = Fp2.mul(t3, t1);
        Z32 = Fp2.mul(t5, Z32);
        Z32 = Fp2.add(Z32, t0);
        return new Point(X32, Y32, Z32);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point.ZERO);
      }
      wNAF(n4) {
        return wnaf.wNAFCached(this, pointPrecomputes2, n4, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p6) => p6.pz));
          return comp.map((p6, i4) => p6.toAffine(toInv[i4])).map(Point.fromAffine);
        });
      }
      multiplyUnsafe(n4) {
        const I5 = Point.ZERO;
        if (n4 === _0n)
          return I5;
        assertGE(n4);
        if (n4 === _1n$1)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n4);
        let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n4);
        let k1p = I5;
        let k2p = I5;
        let d5 = this;
        while (k1 > _0n || k22 > _0n) {
          if (k1 & _1n$1)
            k1p = k1p.add(d5);
          if (k22 & _1n$1)
            k2p = k2p.add(d5);
          d5 = d5.double();
          k1 >>= _1n$1;
          k22 >>= _1n$1;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      multiply(scalar) {
        assertGE(scalar);
        let n4 = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n4);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k22);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p6, f: f5 } = this.wNAF(n4);
          point = p6;
          fake = f5;
        }
        return Point.normalizeZ([point, fake])[0];
      }
      multiplyAndAddUnsafe(Q5, a4, b7) {
        const G7 = Point.BASE;
        const mul2 = (P5, a5) => a5 === _0n || a5 === _1n$1 || !P5.equals(G7) ? P5.multiplyUnsafe(a5) : P5.multiply(a5);
        const sum = mul2(this, a4).add(mul2(Q5, b7));
        return sum.is0() ? void 0 : sum;
      }
      toAffine(iz) {
        const { px: x6, py: y5, pz: z6 } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z6);
        const ax = Fp2.mul(x6, iz);
        const ay = Fp2.mul(y5, iz);
        const zz = Fp2.mul(z6, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n$1)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n$1)
          return this;
        if (clearCofactor)
          return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes2(Point, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex(this.toRawBytes(isCompressed));
      }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve2) {
    const opts = validateBasic(curve2);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n < num && num < Fp2.ORDER;
    }
    function modN(a4) {
      return mod2(a4, CURVE_ORDER);
    }
    function invN(a4) {
      return invert(a4, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(_c2, point, isCompressed) {
        const a4 = point.toAffine();
        const x6 = Fp2.toBytes(a4.x);
        const cat = concatBytes;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x6);
        } else {
          return cat(Uint8Array.from([4]), x6, Fp2.toBytes(a4.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head2 = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head2 === 2 || head2 === 3)) {
          const x6 = bytesToNumberBE(tail);
          if (!isValidFieldElement(x6))
            throw new Error("Point is not on curve");
          const y22 = weierstrassEquation(x6);
          let y5 = Fp2.sqrt(y22);
          const isYOdd = (y5 & _1n$1) === _1n$1;
          const isHeadOdd = (head2 & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y5 = Fp2.neg(y5);
          return { x: x6, y: y5 };
        } else if (len === uncompressedLen && head2 === 4) {
          const x6 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y5 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x: x6, y: y5 };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n$1;
      return number2 > HALF;
    }
    function normalizeS(s3) {
      return isBiggerThanHalfOrder(s3) ? modN(-s3) : s3;
    }
    const slcNum = (b7, from2, to2) => bytesToNumberBE(b7.slice(from2, to2));
    class Signature2 {
      constructor(r, s3, recovery) {
        this.r = r;
        this.s = s3;
        this.recovery = recovery;
        this.assertValidity();
      }
      static fromCompact(hex2) {
        const l6 = CURVE.nByteLength;
        hex2 = ensureBytes("compactSignature", hex2, l6 * 2);
        return new Signature2(slcNum(hex2, 0, l6), slcNum(hex2, l6, 2 * l6));
      }
      static fromDER(hex2) {
        const { r, s: s3 } = DER.toSig(ensureBytes("DER", hex2));
        return new Signature2(r, s3);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature2(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r, s: s3, recovery: rec } = this;
        const h6 = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R5 = Point.fromHex(prefix + numToNByteStr(radj));
        const ir2 = invN(radj);
        const u1 = modN(-h6 * ir2);
        const u22 = modN(s3 * ir2);
        const Q5 = Point.BASE.multiplyAndAddUnsafe(R5, u1, u22);
        if (!Q5)
          throw new Error("point at infinify");
        Q5.assertValidity();
        return Q5;
      }
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature2(this.r, modN(-this.s), this.recovery) : this;
      }
      toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error2) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      randomPrivateKey: () => {
        const length2 = getMinHashLength(CURVE.n);
        return mapHashToField(CURVE.randomBytes(length2), CURVE.n);
      },
      precompute(windowSize = 8, point = Point.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey(privateKey, isCompressed = true) {
      return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b7 = Point.fromHex(publicB);
      return b7.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k5) => k5 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d5 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d5), int2octets(h1int)];
      if (ent != null) {
        const e7 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e7));
      }
      const seed = concatBytes(...seedArgs);
      const m5 = h1int;
      function k2sig(kBytes) {
        const k5 = bits2int(kBytes);
        if (!isWithinCurveOrder(k5))
          return;
        const ik = invN(k5);
        const q5 = Point.BASE.multiply(k5).toAffine();
        const r = modN(q5.x);
        if (r === _0n)
          return;
        const s3 = modN(ik * modN(m5 + r * d5));
        if (s3 === _0n)
          return;
        let recovery = (q5.x === r ? 0 : 2) | Number(q5.y & _1n$1);
        let normS = s3;
        if (lowS && isBiggerThanHalfOrder(s3)) {
          normS = normalizeS(s3);
          recovery ^= 1;
        }
        return new Signature2(r, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C5 = CURVE;
      const drbg = createHmacDrbg(C5.hash.outputLen, C5.nByteLength, C5.hmac);
      return drbg(seed, k2sig);
    }
    Point.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey2, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey2 = ensureBytes("publicKey", publicKey2);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P5;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature2.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature2.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r2, s: s4 } = sg;
          _sig = new Signature2(r2, s4);
        } else {
          throw new Error("PARSE");
        }
        P5 = Point.fromHex(publicKey2);
      } catch (error2) {
        if (error2.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r, s: s3 } = _sig;
      const h6 = bits2int_modN(msgHash);
      const is2 = invN(s3);
      const u1 = modN(h6 * is2);
      const u22 = modN(r * is2);
      const R5 = Point.BASE.multiplyAndAddUnsafe(P5, u1, u22)?.toAffine();
      if (!R5)
        return false;
      const v6 = modN(R5.x);
      return v6 === r;
    }
    return {
      CURVE,
      getPublicKey,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point,
      Signature: Signature2,
      utils: utils2
    };
  }
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes$1(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
    return Object.freeze({ ...create(defHash), create });
  }
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var divNearest = (a4, b7) => (a4 + b7 / _2n) / b7;
  function sqrtMod(y5) {
    const P5 = secp256k1P;
    const _3n2 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b22 = y5 * y5 * y5 % P5;
    const b32 = b22 * b22 * y5 % P5;
    const b62 = pow22(b32, _3n2, P5) * b32 % P5;
    const b9 = pow22(b62, _3n2, P5) * b32 % P5;
    const b11 = pow22(b9, _2n, P5) * b22 % P5;
    const b222 = pow22(b11, _11n, P5) * b11 % P5;
    const b44 = pow22(b222, _22n, P5) * b222 % P5;
    const b88 = pow22(b44, _44n, P5) * b44 % P5;
    const b176 = pow22(b88, _88n, P5) * b88 % P5;
    const b220 = pow22(b176, _44n, P5) * b44 % P5;
    const b223 = pow22(b220, _3n2, P5) * b32 % P5;
    const t1 = pow22(b223, _23n, P5) * b222 % P5;
    const t2 = pow22(t1, _6n, P5) * b22 % P5;
    const root = pow22(t2, _2n, P5);
    if (!Fp.eql(Fp.sqr(root), y5))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k5) => {
        const n4 = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b22 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b22 * k5, n4);
        const c22 = divNearest(-b1 * k5, n4);
        let k1 = mod2(k5 - c1 * a1 - c22 * a22, n4);
        let k22 = mod2(-c1 * b1 - c22 * b22, n4);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n4 - k1;
        if (k2neg)
          k22 = n4 - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k5);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    }
  }, sha256$1);
  BigInt(0);
  var ZeroAddress = "0x0000000000000000000000000000000000000000";
  var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var BN_0$7 = BigInt(0);
  var BN_1$2 = BigInt(1);
  var BN_2$2 = BigInt(2);
  var BN_27$1 = BigInt(27);
  var BN_28$1 = BigInt(28);
  var BN_35$1 = BigInt(35);
  var _guard$1 = {};
  function toUint256(value) {
    return zeroPadValue(toBeArray(value), 32);
  }
  var Signature = class {
    #r;
    #s;
    #v;
    #networkV;
    get r() {
      return this.#r;
    }
    set r(value) {
      assertArgument(dataLength(value) === 32, "invalid r", "value", value);
      this.#r = hexlify(value);
    }
    get s() {
      return this.#s;
    }
    set s(_value) {
      assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
      const value = hexlify(_value);
      assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
      this.#s = value;
    }
    get v() {
      return this.#v;
    }
    set v(value) {
      const v6 = getNumber(value, "value");
      assertArgument(v6 === 27 || v6 === 28, "invalid v", "v", value);
      this.#v = v6;
    }
    get networkV() {
      return this.#networkV;
    }
    get legacyChainId() {
      const v6 = this.networkV;
      if (v6 == null) {
        return null;
      }
      return Signature.getChainId(v6);
    }
    get yParity() {
      return this.v === 27 ? 0 : 1;
    }
    get yParityAndS() {
      const yParityAndS = getBytes(this.s);
      if (this.yParity) {
        yParityAndS[0] |= 128;
      }
      return hexlify(yParityAndS);
    }
    get compactSerialized() {
      return concat([this.r, this.yParityAndS]);
    }
    get serialized() {
      return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
    }
    constructor(guard, r, s3, v6) {
      assertPrivate(guard, _guard$1, "Signature");
      this.#r = r;
      this.#s = s3;
      this.#v = v6;
      this.#networkV = null;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
    }
    clone() {
      const clone = new Signature(_guard$1, this.r, this.s, this.v);
      if (this.networkV) {
        clone.#networkV = this.networkV;
      }
      return clone;
    }
    toJSON() {
      const networkV = this.networkV;
      return {
        _type: "signature",
        networkV: networkV != null ? networkV.toString() : null,
        r: this.r,
        s: this.s,
        v: this.v
      };
    }
    static getChainId(v6) {
      const bv = getBigInt(v6, "v");
      if (bv == BN_27$1 || bv == BN_28$1) {
        return BN_0$7;
      }
      assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v6);
      return (bv - BN_35$1) / BN_2$2;
    }
    static getChainIdV(chainId, v6) {
      return getBigInt(chainId) * BN_2$2 + BigInt(35 + v6 - 27);
    }
    static getNormalizedV(v6) {
      const bv = getBigInt(v6);
      if (bv === BN_0$7 || bv === BN_27$1) {
        return 27;
      }
      if (bv === BN_1$2 || bv === BN_28$1) {
        return 28;
      }
      assertArgument(bv >= BN_35$1, "invalid v", "v", v6);
      return bv & BN_1$2 ? 27 : 28;
    }
    static from(sig) {
      function assertError(check, message) {
        assertArgument(check, message, "signature", sig);
      }
      if (sig == null) {
        return new Signature(_guard$1, ZeroHash, ZeroHash, 27);
      }
      if (typeof sig === "string") {
        const bytes2 = getBytes(sig, "signature");
        if (bytes2.length === 64) {
          const r2 = hexlify(bytes2.slice(0, 32));
          const s4 = bytes2.slice(32, 64);
          const v7 = s4[0] & 128 ? 28 : 27;
          s4[0] &= 127;
          return new Signature(_guard$1, r2, hexlify(s4), v7);
        }
        if (bytes2.length === 65) {
          const r2 = hexlify(bytes2.slice(0, 32));
          const s4 = bytes2.slice(32, 64);
          assertError((s4[0] & 128) === 0, "non-canonical s");
          const v7 = Signature.getNormalizedV(bytes2[64]);
          return new Signature(_guard$1, r2, hexlify(s4), v7);
        }
        assertError(false, "invalid raw signature length");
      }
      if (sig instanceof Signature) {
        return sig.clone();
      }
      const _r2 = sig.r;
      assertError(_r2 != null, "missing r");
      const r = toUint256(_r2);
      const s3 = function(s4, yParityAndS) {
        if (s4 != null) {
          return toUint256(s4);
        }
        if (yParityAndS != null) {
          assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
          const bytes2 = getBytes(yParityAndS);
          bytes2[0] &= 127;
          return hexlify(bytes2);
        }
        assertError(false, "missing s");
      }(sig.s, sig.yParityAndS);
      assertError((getBytes(s3)[0] & 128) == 0, "non-canonical s");
      const { networkV, v: v6 } = function(_v, yParityAndS, yParity) {
        if (_v != null) {
          const v7 = getBigInt(_v);
          return {
            networkV: v7 >= BN_35$1 ? v7 : void 0,
            v: Signature.getNormalizedV(v7)
          };
        }
        if (yParityAndS != null) {
          assertError(isHexString(yParityAndS, 32), "invalid yParityAndS");
          return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
        }
        if (yParity != null) {
          switch (getNumber(yParity, "sig.yParity")) {
            case 0:
              return { v: 27 };
            case 1:
              return { v: 28 };
          }
          assertError(false, "invalid yParity");
        }
        assertError(false, "missing v");
      }(sig.v, sig.yParityAndS, sig.yParity);
      const result = new Signature(_guard$1, r, s3, v6);
      if (networkV) {
        result.#networkV = networkV;
      }
      assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
      assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
      return result;
    }
  };
  var SigningKey = class {
    #privateKey;
    constructor(privateKey) {
      assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
      this.#privateKey = hexlify(privateKey);
    }
    get privateKey() {
      return this.#privateKey;
    }
    get publicKey() {
      return SigningKey.computePublicKey(this.#privateKey);
    }
    get compressedPublicKey() {
      return SigningKey.computePublicKey(this.#privateKey, true);
    }
    sign(digest) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      const sig = secp256k1.sign(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
        lowS: true
      });
      return Signature.from({
        r: toBeHex(sig.r, 32),
        s: toBeHex(sig.s, 32),
        v: sig.recovery ? 28 : 27
      });
    }
    computeSharedSecret(other) {
      const pubKey = SigningKey.computePublicKey(other);
      return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey), false));
    }
    static computePublicKey(key, compressed) {
      let bytes2 = getBytes(key, "key");
      if (bytes2.length === 32) {
        const pubKey = secp256k1.getPublicKey(bytes2, !!compressed);
        return hexlify(pubKey);
      }
      if (bytes2.length === 64) {
        const pub = new Uint8Array(65);
        pub[0] = 4;
        pub.set(bytes2, 1);
        bytes2 = pub;
      }
      const point = secp256k1.ProjectivePoint.fromHex(bytes2);
      return hexlify(point.toRawBytes(compressed));
    }
    static recoverPublicKey(digest, signature) {
      assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
      const sig = Signature.from(signature);
      let secpSig = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s])));
      secpSig = secpSig.addRecoveryBit(sig.yParity);
      const pubKey = secpSig.recoverPublicKey(getBytesCopy(digest));
      assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature);
      return "0x" + pubKey.toHex(false);
    }
    static addPoints(p0, p1, compressed) {
      const pub0 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
      const pub1 = secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
      return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
  };
  var BN_0$6 = BigInt(0);
  var BN_36 = BigInt(36);
  function getChecksumAddress(address) {
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i4 = 0; i4 < 40; i4++) {
      expanded[i4] = chars[i4].charCodeAt(0);
    }
    const hashed = getBytes(keccak2562(expanded));
    for (let i4 = 0; i4 < 40; i4 += 2) {
      if (hashed[i4 >> 1] >> 4 >= 8) {
        chars[i4] = chars[i4].toUpperCase();
      }
      if ((hashed[i4 >> 1] & 15) >= 8) {
        chars[i4 + 1] = chars[i4 + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  var ibanLookup = {};
  for (let i4 = 0; i4 < 10; i4++) {
    ibanLookup[String(i4)] = String(i4);
  }
  for (let i4 = 0; i4 < 26; i4++) {
    ibanLookup[String.fromCharCode(65 + i4)] = String(10 + i4);
  }
  var safeDigits = 15;
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c3) => {
      return ibanLookup[c3];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  var Base36 = function() {
    const result = {};
    for (let i4 = 0; i4 < 36; i4++) {
      const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i4];
      result[key] = BigInt(i4);
    }
    return result;
  }();
  function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_0$6;
    for (let i4 = 0; i4 < value.length; i4++) {
      result = result * BN_36 + Base36[value[i4]];
    }
    return result;
  }
  function getAddress(address) {
    assertArgument(typeof address === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (!address.startsWith("0x")) {
        address = "0x" + address;
      }
      const result = getChecksumAddress(address);
      assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
      return result;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
      let result = fromBase36(address.substring(4)).toString(16);
      while (result.length < 40) {
        result = "0" + result;
      }
      return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
  }
  function getCreateAddress(tx) {
    const from2 = getAddress(tx.from);
    const nonce = getBigInt(tx.nonce, "tx.nonce");
    let nonceHex = nonce.toString(16);
    if (nonceHex === "0") {
      nonceHex = "0x";
    } else if (nonceHex.length % 2) {
      nonceHex = "0x0" + nonceHex;
    } else {
      nonceHex = "0x" + nonceHex;
    }
    return getAddress(dataSlice(keccak2562(encodeRlp([from2, nonceHex])), 12));
  }
  function isAddressable(value) {
    return value && typeof value.getAddress === "function";
  }
  async function checkAddress(target, promise) {
    const result = await promise;
    if (result == null || result === "0x0000000000000000000000000000000000000000") {
      assert2(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
      assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
    }
    return getAddress(result);
  }
  function resolveAddress(target, resolver) {
    if (typeof target === "string") {
      if (target.match(/^0x[0-9a-f]{40}$/i)) {
        return getAddress(target);
      }
      assert2(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
      return checkAddress(target, resolver.resolveName(target));
    } else if (isAddressable(target)) {
      return checkAddress(target, target.getAddress());
    } else if (target && typeof target.then === "function") {
      return checkAddress(target, target);
    }
    assertArgument(false, "unsupported addressable value", "target", target);
  }
  var _gaurd = {};
  function n3(value, width) {
    let signed2 = false;
    if (width < 0) {
      signed2 = true;
      width *= -1;
    }
    return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
  }
  function b6(value, size) {
    return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
  }
  var _typedSymbol = Symbol.for("_ethers_typed");
  var Typed = class {
    type;
    value;
    #options;
    _typedSymbol;
    constructor(gaurd, type2, value, options) {
      if (options == null) {
        options = null;
      }
      assertPrivate(_gaurd, gaurd, "Typed");
      defineProperties(this, { _typedSymbol, type: type2, value });
      this.#options = options;
      this.format();
    }
    format() {
      if (this.type === "array") {
        throw new Error("");
      } else if (this.type === "dynamicArray") {
        throw new Error("");
      } else if (this.type === "tuple") {
        return `tuple(${this.value.map((v6) => v6.format()).join(",")})`;
      }
      return this.type;
    }
    defaultValue() {
      return 0;
    }
    minValue() {
      return 0;
    }
    maxValue() {
      return 0;
    }
    isBigInt() {
      return !!this.type.match(/^u?int[0-9]+$/);
    }
    isData() {
      return this.type.startsWith("bytes");
    }
    isString() {
      return this.type === "string";
    }
    get tupleName() {
      if (this.type !== "tuple") {
        throw TypeError("not a tuple");
      }
      return this.#options;
    }
    get arrayLength() {
      if (this.type !== "array") {
        throw TypeError("not an array");
      }
      if (this.#options === true) {
        return -1;
      }
      if (this.#options === false) {
        return this.value.length;
      }
      return null;
    }
    static from(type2, value) {
      return new Typed(_gaurd, type2, value);
    }
    static uint8(v6) {
      return n3(v6, 8);
    }
    static uint16(v6) {
      return n3(v6, 16);
    }
    static uint24(v6) {
      return n3(v6, 24);
    }
    static uint32(v6) {
      return n3(v6, 32);
    }
    static uint40(v6) {
      return n3(v6, 40);
    }
    static uint48(v6) {
      return n3(v6, 48);
    }
    static uint56(v6) {
      return n3(v6, 56);
    }
    static uint64(v6) {
      return n3(v6, 64);
    }
    static uint72(v6) {
      return n3(v6, 72);
    }
    static uint80(v6) {
      return n3(v6, 80);
    }
    static uint88(v6) {
      return n3(v6, 88);
    }
    static uint96(v6) {
      return n3(v6, 96);
    }
    static uint104(v6) {
      return n3(v6, 104);
    }
    static uint112(v6) {
      return n3(v6, 112);
    }
    static uint120(v6) {
      return n3(v6, 120);
    }
    static uint128(v6) {
      return n3(v6, 128);
    }
    static uint136(v6) {
      return n3(v6, 136);
    }
    static uint144(v6) {
      return n3(v6, 144);
    }
    static uint152(v6) {
      return n3(v6, 152);
    }
    static uint160(v6) {
      return n3(v6, 160);
    }
    static uint168(v6) {
      return n3(v6, 168);
    }
    static uint176(v6) {
      return n3(v6, 176);
    }
    static uint184(v6) {
      return n3(v6, 184);
    }
    static uint192(v6) {
      return n3(v6, 192);
    }
    static uint200(v6) {
      return n3(v6, 200);
    }
    static uint208(v6) {
      return n3(v6, 208);
    }
    static uint216(v6) {
      return n3(v6, 216);
    }
    static uint224(v6) {
      return n3(v6, 224);
    }
    static uint232(v6) {
      return n3(v6, 232);
    }
    static uint240(v6) {
      return n3(v6, 240);
    }
    static uint248(v6) {
      return n3(v6, 248);
    }
    static uint256(v6) {
      return n3(v6, 256);
    }
    static uint(v6) {
      return n3(v6, 256);
    }
    static int8(v6) {
      return n3(v6, -8);
    }
    static int16(v6) {
      return n3(v6, -16);
    }
    static int24(v6) {
      return n3(v6, -24);
    }
    static int32(v6) {
      return n3(v6, -32);
    }
    static int40(v6) {
      return n3(v6, -40);
    }
    static int48(v6) {
      return n3(v6, -48);
    }
    static int56(v6) {
      return n3(v6, -56);
    }
    static int64(v6) {
      return n3(v6, -64);
    }
    static int72(v6) {
      return n3(v6, -72);
    }
    static int80(v6) {
      return n3(v6, -80);
    }
    static int88(v6) {
      return n3(v6, -88);
    }
    static int96(v6) {
      return n3(v6, -96);
    }
    static int104(v6) {
      return n3(v6, -104);
    }
    static int112(v6) {
      return n3(v6, -112);
    }
    static int120(v6) {
      return n3(v6, -120);
    }
    static int128(v6) {
      return n3(v6, -128);
    }
    static int136(v6) {
      return n3(v6, -136);
    }
    static int144(v6) {
      return n3(v6, -144);
    }
    static int152(v6) {
      return n3(v6, -152);
    }
    static int160(v6) {
      return n3(v6, -160);
    }
    static int168(v6) {
      return n3(v6, -168);
    }
    static int176(v6) {
      return n3(v6, -176);
    }
    static int184(v6) {
      return n3(v6, -184);
    }
    static int192(v6) {
      return n3(v6, -192);
    }
    static int200(v6) {
      return n3(v6, -200);
    }
    static int208(v6) {
      return n3(v6, -208);
    }
    static int216(v6) {
      return n3(v6, -216);
    }
    static int224(v6) {
      return n3(v6, -224);
    }
    static int232(v6) {
      return n3(v6, -232);
    }
    static int240(v6) {
      return n3(v6, -240);
    }
    static int248(v6) {
      return n3(v6, -248);
    }
    static int256(v6) {
      return n3(v6, -256);
    }
    static int(v6) {
      return n3(v6, -256);
    }
    static bytes1(v6) {
      return b6(v6, 1);
    }
    static bytes2(v6) {
      return b6(v6, 2);
    }
    static bytes3(v6) {
      return b6(v6, 3);
    }
    static bytes4(v6) {
      return b6(v6, 4);
    }
    static bytes5(v6) {
      return b6(v6, 5);
    }
    static bytes6(v6) {
      return b6(v6, 6);
    }
    static bytes7(v6) {
      return b6(v6, 7);
    }
    static bytes8(v6) {
      return b6(v6, 8);
    }
    static bytes9(v6) {
      return b6(v6, 9);
    }
    static bytes10(v6) {
      return b6(v6, 10);
    }
    static bytes11(v6) {
      return b6(v6, 11);
    }
    static bytes12(v6) {
      return b6(v6, 12);
    }
    static bytes13(v6) {
      return b6(v6, 13);
    }
    static bytes14(v6) {
      return b6(v6, 14);
    }
    static bytes15(v6) {
      return b6(v6, 15);
    }
    static bytes16(v6) {
      return b6(v6, 16);
    }
    static bytes17(v6) {
      return b6(v6, 17);
    }
    static bytes18(v6) {
      return b6(v6, 18);
    }
    static bytes19(v6) {
      return b6(v6, 19);
    }
    static bytes20(v6) {
      return b6(v6, 20);
    }
    static bytes21(v6) {
      return b6(v6, 21);
    }
    static bytes22(v6) {
      return b6(v6, 22);
    }
    static bytes23(v6) {
      return b6(v6, 23);
    }
    static bytes24(v6) {
      return b6(v6, 24);
    }
    static bytes25(v6) {
      return b6(v6, 25);
    }
    static bytes26(v6) {
      return b6(v6, 26);
    }
    static bytes27(v6) {
      return b6(v6, 27);
    }
    static bytes28(v6) {
      return b6(v6, 28);
    }
    static bytes29(v6) {
      return b6(v6, 29);
    }
    static bytes30(v6) {
      return b6(v6, 30);
    }
    static bytes31(v6) {
      return b6(v6, 31);
    }
    static bytes32(v6) {
      return b6(v6, 32);
    }
    static address(v6) {
      return new Typed(_gaurd, "address", v6);
    }
    static bool(v6) {
      return new Typed(_gaurd, "bool", !!v6);
    }
    static bytes(v6) {
      return new Typed(_gaurd, "bytes", v6);
    }
    static string(v6) {
      return new Typed(_gaurd, "string", v6);
    }
    static array(v6, dynamic2) {
      throw new Error("not implemented yet");
    }
    static tuple(v6, name) {
      throw new Error("not implemented yet");
    }
    static overrides(v6) {
      return new Typed(_gaurd, "overrides", Object.assign({}, v6));
    }
    static isTyped(value) {
      return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
    }
    static dereference(value, type2) {
      if (Typed.isTyped(value)) {
        if (value.type !== type2) {
          throw new Error(`invalid type: expecetd ${type2}, got ${value.type}`);
        }
        return value.value;
      }
      return value;
    }
  };
  var AddressCoder = class extends Coder {
    constructor(localName) {
      super("address", "address", localName, false);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, _value) {
      let value = Typed.dereference(_value, "string");
      try {
        value = getAddress(value);
      } catch (error2) {
        return this._throwError(error2.message, _value);
      }
      return writer.writeValue(value);
    }
    decode(reader) {
      return getAddress(toBeHex(reader.readValue(), 20));
    }
  };
  var AnonymousCoder = class extends Coder {
    coder;
    constructor(coder) {
      super(coder.name, coder.type, "_", coder.dynamic);
      this.coder = coder;
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(writer, value) {
      return this.coder.encode(writer, value);
    }
    decode(reader) {
      return this.coder.decode(reader);
    }
  };
  function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && typeof values === "object") {
      let unique = {};
      arrayValues = coders.map((coder) => {
        const name = coder.localName;
        assert2(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
        assert2(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
        unique[name] = true;
        return values[name];
      });
    } else {
      assertArgument(false, "invalid tuple value", "tuple", values);
    }
    assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
    let staticWriter = new Writer();
    let dynamicWriter = new Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
      let value = arrayValues[index];
      if (coder.dynamic) {
        let dynamicOffset = dynamicWriter.length;
        coder.encode(dynamicWriter, value);
        let updateFunc = staticWriter.writeUpdatableValue();
        updateFuncs.push((baseOffset) => {
          updateFunc(baseOffset + dynamicOffset);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    updateFuncs.forEach((func) => {
      func(staticWriter.length);
    });
    let length2 = writer.appendWriter(staticWriter);
    length2 += writer.appendWriter(dynamicWriter);
    return length2;
  }
  function unpack(reader, coders) {
    let values = [];
    let keys = [];
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
      let value = null;
      if (coder.dynamic) {
        let offset = reader.readIndex();
        let offsetReader = baseReader.subReader(offset);
        try {
          value = coder.decode(offsetReader);
        } catch (error2) {
          if (isError(error2, "BUFFER_OVERRUN")) {
            throw error2;
          }
          value = error2;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error2) {
          if (isError(error2, "BUFFER_OVERRUN")) {
            throw error2;
          }
          value = error2;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value == void 0) {
        throw new Error("investigate");
      }
      values.push(value);
      keys.push(coder.localName || null);
    });
    return Result.fromItems(values, keys);
  }
  var ArrayCoder = class extends Coder {
    coder;
    length;
    constructor(coder, length2, localName) {
      const type2 = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
      const dynamic2 = length2 === -1 || coder.dynamic;
      super("array", type2, localName, dynamic2);
      defineProperties(this, { coder, length: length2 });
    }
    defaultValue() {
      const defaultChild = this.coder.defaultValue();
      const result = [];
      for (let i4 = 0; i4 < this.length; i4++) {
        result.push(defaultChild);
      }
      return result;
    }
    encode(writer, _value) {
      const value = Typed.dereference(_value, "array");
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      let count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      let coders = [];
      for (let i4 = 0; i4 < value.length; i4++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    }
    decode(reader) {
      let count = this.length;
      if (count === -1) {
        count = reader.readIndex();
        assert2(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
      }
      let coders = [];
      for (let i4 = 0; i4 < count; i4++) {
        coders.push(new AnonymousCoder(this.coder));
      }
      return unpack(reader, coders);
    }
  };
  var BooleanCoder = class extends Coder {
    constructor(localName) {
      super("bool", "bool", localName, false);
    }
    defaultValue() {
      return false;
    }
    encode(writer, _value) {
      const value = Typed.dereference(_value, "bool");
      return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
      return !!reader.readValue();
    }
  };
  var DynamicBytesCoder = class extends Coder {
    constructor(type2, localName) {
      super(type2, type2, localName, true);
    }
    defaultValue() {
      return "0x";
    }
    encode(writer, value) {
      value = getBytesCopy(value);
      let length2 = writer.writeValue(value.length);
      length2 += writer.writeBytes(value);
      return length2;
    }
    decode(reader) {
      return reader.readBytes(reader.readIndex(), true);
    }
  };
  var BytesCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("bytes", localName);
    }
    decode(reader) {
      return hexlify(super.decode(reader));
    }
  };
  var FixedBytesCoder = class extends Coder {
    size;
    constructor(size, localName) {
      let name = "bytes" + String(size);
      super(name, name, localName, false);
      defineProperties(this, { size }, { size: "number" });
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(writer, _value) {
      let data = getBytesCopy(Typed.dereference(_value, this.type));
      if (data.length !== this.size) {
        this._throwError("incorrect data length", _value);
      }
      return writer.writeBytes(data);
    }
    decode(reader) {
      return hexlify(reader.readBytes(this.size));
    }
  };
  var Empty = new Uint8Array([]);
  var NullCoder = class extends Coder {
    constructor(localName) {
      super("null", "", localName, false);
    }
    defaultValue() {
      return null;
    }
    encode(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes(Empty);
    }
    decode(reader) {
      reader.readBytes(0);
      return null;
    }
  };
  var BN_0$5 = BigInt(0);
  var BN_1$1 = BigInt(1);
  var BN_MAX_UINT256$1 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var NumberCoder = class extends Coder {
    size;
    signed;
    constructor(size, signed2, localName) {
      const name = (signed2 ? "int" : "uint") + size * 8;
      super(name, name, localName, false);
      defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
    }
    defaultValue() {
      return 0;
    }
    encode(writer, _value) {
      let value = getBigInt(Typed.dereference(_value, this.type));
      let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
      if (this.signed) {
        let bounds = mask(maxUintValue, this.size * 8 - 1);
        if (value > bounds || value < -(bounds + BN_1$1)) {
          this._throwError("value out-of-bounds", _value);
        }
        value = toTwos(value, 8 * WordSize);
      } else if (value < BN_0$5 || value > mask(maxUintValue, this.size * 8)) {
        this._throwError("value out-of-bounds", _value);
      }
      return writer.writeValue(value);
    }
    decode(reader) {
      let value = mask(reader.readValue(), this.size * 8);
      if (this.signed) {
        value = fromTwos(value, this.size * 8);
      }
      return value;
    }
  };
  var StringCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("string", localName);
    }
    defaultValue() {
      return "";
    }
    encode(writer, _value) {
      return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
    }
    decode(reader) {
      return toUtf8String(super.decode(reader));
    }
  };
  var TupleCoder = class extends Coder {
    coders;
    constructor(coders, localName) {
      let dynamic2 = false;
      const types2 = [];
      coders.forEach((coder) => {
        if (coder.dynamic) {
          dynamic2 = true;
        }
        types2.push(coder.type);
      });
      const type2 = "tuple(" + types2.join(",") + ")";
      super("tuple", type2, localName, dynamic2);
      defineProperties(this, { coders: Object.freeze(coders.slice()) });
    }
    defaultValue() {
      const values = [];
      this.coders.forEach((coder) => {
        values.push(coder.defaultValue());
      });
      const uniqueNames = this.coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
          if (!accum[name]) {
            accum[name] = 0;
          }
          accum[name]++;
        }
        return accum;
      }, {});
      this.coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
          return;
        }
        if (name === "length") {
          name = "_length";
        }
        if (values[name] != null) {
          return;
        }
        values[name] = values[index];
      });
      return Object.freeze(values);
    }
    encode(writer, _value) {
      const value = Typed.dereference(_value, "tuple");
      return pack(writer, this.coders, value);
    }
    decode(reader) {
      return unpack(reader, this.coders);
    }
  };
  function id2(value) {
    return keccak2562(toUtf8Bytes(value));
  }
  var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
  var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
  var NSM_MAX = 4;
  function decode_arithmetic(bytes2) {
    let pos = 0;
    function u16() {
      return bytes2[pos++] << 8 | bytes2[pos++];
    }
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1];
    for (let i4 = 1; i4 < symbol_count; i4++) {
      acc.push(total += u16());
    }
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        read_buffer = read_buffer << 8 | bytes2[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    const N10 = 31;
    const FULL = 2 ** N10;
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    let register = 0;
    for (let i4 = 0; i4 < N10; i4++)
      register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL;
    while (true) {
      let value = Math.floor(((register - low + 1) * total - 1) / range);
      let start = 0;
      let end = symbol_count;
      while (end - start > 1) {
        let mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0)
        break;
      symbols.push(start);
      let a4 = low + Math.floor(range * acc[start] / total);
      let b7 = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a4 ^ b7) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a4 = a4 << 1 & MASK;
        b7 = b7 << 1 & MASK | 1;
      }
      while (a4 & ~b7 & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a4 = a4 << 1 ^ HALF;
        b7 = (b7 ^ HALF) << 1 | HALF | 1;
      }
      low = a4;
      range = 1 + b7 - a4;
    }
    let offset = symbol_count - 4;
    return symbols.map((x6) => {
      switch (x6 - offset) {
        case 3:
          return offset + 65792 + (bytes2[pos_payload++] << 16 | bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
        case 2:
          return offset + 256 + (bytes2[pos_payload++] << 8 | bytes2[pos_payload++]);
        case 1:
          return offset + bytes2[pos_payload++];
        default:
          return x6 - 1;
      }
    });
  }
  function read_payload(v6) {
    let pos = 0;
    return () => v6[pos++];
  }
  function read_compressed_payload(s3) {
    return read_payload(decode_arithmetic(unsafe_atob(s3)));
  }
  function unsafe_atob(s3) {
    let lookup = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c3, i4) => lookup[c3.charCodeAt(0)] = i4);
    let n4 = s3.length;
    let ret = new Uint8Array(6 * n4 >> 3);
    for (let i4 = 0, pos = 0, width = 0, carry = 0; i4 < n4; i4++) {
      carry = carry << 6 | lookup[s3.charCodeAt(i4)];
      width += 6;
      if (width >= 8) {
        ret[pos++] = carry >> (width -= 8);
      }
    }
    return ret;
  }
  function signed(i4) {
    return i4 & 1 ? ~i4 >> 1 : i4 >> 1;
  }
  function read_deltas(n4, next2) {
    let v6 = Array(n4);
    for (let i4 = 0, x6 = 0; i4 < n4; i4++)
      v6[i4] = x6 += signed(next2());
    return v6;
  }
  function read_sorted(next2, prev2 = 0) {
    let ret = [];
    while (true) {
      let x6 = next2();
      let n4 = next2();
      if (!n4)
        break;
      prev2 += x6;
      for (let i4 = 0; i4 < n4; i4++) {
        ret.push(prev2 + i4);
      }
      prev2 += n4 + 1;
    }
    return ret;
  }
  function read_sorted_arrays(next2) {
    return read_array_while(() => {
      let v6 = read_sorted(next2);
      if (v6.length)
        return v6;
    });
  }
  function read_mapped(next2) {
    let ret = [];
    while (true) {
      let w5 = next2();
      if (w5 == 0)
        break;
      ret.push(read_linear_table(w5, next2));
    }
    while (true) {
      let w5 = next2() - 1;
      if (w5 < 0)
        break;
      ret.push(read_replacement_table(w5, next2));
    }
    return ret.flat();
  }
  function read_array_while(next2) {
    let v6 = [];
    while (true) {
      let x6 = next2(v6.length);
      if (!x6)
        break;
      v6.push(x6);
    }
    return v6;
  }
  function read_transposed(n4, w5, next2) {
    let m5 = Array(n4).fill().map(() => []);
    for (let i4 = 0; i4 < w5; i4++) {
      read_deltas(n4, next2).forEach((x6, j5) => m5[j5].push(x6));
    }
    return m5;
  }
  function read_linear_table(w5, next2) {
    let dx = 1 + next2();
    let dy = next2();
    let vN = read_array_while(next2);
    let m5 = read_transposed(vN.length, 1 + w5, next2);
    return m5.flatMap((v6, i4) => {
      let [x6, ...ys2] = v6;
      return Array(vN[i4]).fill().map((_5, j5) => {
        let j_dy = j5 * dy;
        return [x6 + j5 * dx, ys2.map((y5) => y5 + j_dy)];
      });
    });
  }
  function read_replacement_table(w5, next2) {
    let n4 = 1 + next2();
    let m5 = read_transposed(n4, 1 + w5, next2);
    return m5.map((v6) => [v6[0], v6.slice(1)]);
  }
  function read_trie(next2) {
    let ret = [];
    let sorted = read_sorted(next2);
    expand2(decode2([]), []);
    return ret;
    function decode2(Q5) {
      let S6 = next2();
      let B6 = read_array_while(() => {
        let cps = read_sorted(next2).map((i4) => sorted[i4]);
        if (cps.length)
          return decode2(cps);
      });
      return { S: S6, B: B6, Q: Q5 };
    }
    function expand2({ S: S6, B: B6 }, cps, saved) {
      if (S6 & 4 && saved === cps[cps.length - 1])
        return;
      if (S6 & 2)
        saved = cps[cps.length - 1];
      if (S6 & 1)
        ret.push(cps);
      for (let br2 of B6) {
        for (let cp of br2.Q) {
          expand2(br2, [...cps, cp], saved);
        }
      }
    }
  }
  function hex_cp(cp) {
    return cp.toString(16).toUpperCase().padStart(2, "0");
  }
  function quote_cp(cp) {
    return `{${hex_cp(cp)}}`;
  }
  function explode_cp(s3) {
    let cps = [];
    for (let pos = 0, len = s3.length; pos < len; ) {
      let cp = s3.codePointAt(pos);
      pos += cp < 65536 ? 1 : 2;
      cps.push(cp);
    }
    return cps;
  }
  function str_from_cps(cps) {
    const chunk = 4096;
    let len = cps.length;
    if (len < chunk)
      return String.fromCodePoint(...cps);
    let buf = [];
    for (let i4 = 0; i4 < len; ) {
      buf.push(String.fromCodePoint(...cps.slice(i4, i4 += chunk)));
    }
    return buf.join("");
  }
  function compare_arrays(a4, b7) {
    let n4 = a4.length;
    let c3 = n4 - b7.length;
    for (let i4 = 0; c3 == 0 && i4 < n4; i4++)
      c3 = a4[i4] - b7[i4];
    return c3;
  }
  var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
  var S0 = 44032;
  var L0 = 4352;
  var V0 = 4449;
  var T0 = 4519;
  var L_COUNT = 19;
  var V_COUNT = 21;
  var T_COUNT = 28;
  var N_COUNT = V_COUNT * T_COUNT;
  var S_COUNT = L_COUNT * N_COUNT;
  var S1 = S0 + S_COUNT;
  var L1 = L0 + L_COUNT;
  var V1 = V0 + V_COUNT;
  var T1 = T0 + T_COUNT;
  function unpack_cc(packed) {
    return packed >> 24 & 255;
  }
  function unpack_cp(packed) {
    return packed & 16777215;
  }
  var SHIFTED_RANK;
  var EXCLUSIONS;
  var DECOMP;
  var RECOMP;
  function init$1() {
    let r = read_compressed_payload(COMPRESSED);
    SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v6, i4) => v6.map((x6) => [x6, i4 + 1 << 24])));
    EXCLUSIONS = new Set(read_sorted(r));
    DECOMP = /* @__PURE__ */ new Map();
    RECOMP = /* @__PURE__ */ new Map();
    for (let [cp, cps] of read_mapped(r)) {
      if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        let [a4, b7] = cps;
        let bucket = RECOMP.get(a4);
        if (!bucket) {
          bucket = /* @__PURE__ */ new Map();
          RECOMP.set(a4, bucket);
        }
        bucket.set(b7, cp);
      }
      DECOMP.set(cp, cps.reverse());
    }
  }
  function is_hangul(cp) {
    return cp >= S0 && cp < S1;
  }
  function compose_pair(a4, b7) {
    if (a4 >= L0 && a4 < L1 && b7 >= V0 && b7 < V1) {
      return S0 + (a4 - L0) * N_COUNT + (b7 - V0) * T_COUNT;
    } else if (is_hangul(a4) && b7 > T0 && b7 < T1 && (a4 - S0) % T_COUNT == 0) {
      return a4 + (b7 - T0);
    } else {
      let recomp = RECOMP.get(a4);
      if (recomp) {
        recomp = recomp.get(b7);
        if (recomp) {
          return recomp;
        }
      }
      return -1;
    }
  }
  function decomposed(cps) {
    if (!SHIFTED_RANK)
      init$1();
    let ret = [];
    let buf = [];
    let check_order = false;
    function add3(cp) {
      let cc2 = SHIFTED_RANK.get(cp);
      if (cc2) {
        check_order = true;
        cp |= cc2;
      }
      ret.push(cp);
    }
    for (let cp of cps) {
      while (true) {
        if (cp < 128) {
          ret.push(cp);
        } else if (is_hangul(cp)) {
          let s_index = cp - S0;
          let l_index = s_index / N_COUNT | 0;
          let v_index = s_index % N_COUNT / T_COUNT | 0;
          let t_index = s_index % T_COUNT;
          add3(L0 + l_index);
          add3(V0 + v_index);
          if (t_index > 0)
            add3(T0 + t_index);
        } else {
          let mapped = DECOMP.get(cp);
          if (mapped) {
            buf.push(...mapped);
          } else {
            add3(cp);
          }
        }
        if (!buf.length)
          break;
        cp = buf.pop();
      }
    }
    if (check_order && ret.length > 1) {
      let prev_cc = unpack_cc(ret[0]);
      for (let i4 = 1; i4 < ret.length; i4++) {
        let cc2 = unpack_cc(ret[i4]);
        if (cc2 == 0 || prev_cc <= cc2) {
          prev_cc = cc2;
          continue;
        }
        let j5 = i4 - 1;
        while (true) {
          let tmp = ret[j5 + 1];
          ret[j5 + 1] = ret[j5];
          ret[j5] = tmp;
          if (!j5)
            break;
          prev_cc = unpack_cc(ret[--j5]);
          if (prev_cc <= cc2)
            break;
        }
        prev_cc = unpack_cc(ret[i4]);
      }
    }
    return ret;
  }
  function composed_from_decomposed(v6) {
    let ret = [];
    let stack = [];
    let prev_cp = -1;
    let prev_cc = 0;
    for (let packed of v6) {
      let cc2 = unpack_cc(packed);
      let cp = unpack_cp(packed);
      if (prev_cp == -1) {
        if (cc2 == 0) {
          prev_cp = cp;
        } else {
          ret.push(cp);
        }
      } else if (prev_cc > 0 && prev_cc >= cc2) {
        if (cc2 == 0) {
          ret.push(prev_cp, ...stack);
          stack.length = 0;
          prev_cp = cp;
        } else {
          stack.push(cp);
        }
        prev_cc = cc2;
      } else {
        let composed = compose_pair(prev_cp, cp);
        if (composed >= 0) {
          prev_cp = composed;
        } else if (prev_cc == 0 && cc2 == 0) {
          ret.push(prev_cp);
          prev_cp = cp;
        } else {
          stack.push(cp);
          prev_cc = cc2;
        }
      }
    }
    if (prev_cp >= 0) {
      ret.push(prev_cp, ...stack);
    }
    return ret;
  }
  function nfd(cps) {
    return decomposed(cps).map(unpack_cp);
  }
  function nfc(cps) {
    return composed_from_decomposed(decomposed(cps));
  }
  var HYPHEN = 45;
  var STOP_CH = ".";
  var FE0F = 65039;
  var UNIQUE_PH = 1;
  var Array_from = (x6) => Array.from(x6);
  function group_has_cp(g5, cp) {
    return g5.P.has(cp) || g5.Q.has(cp);
  }
  var Emoji = class extends Array {
    get is_emoji() {
      return true;
    }
  };
  var MAPPED;
  var IGNORED;
  var CM;
  var NSM;
  var ESCAPE;
  var GROUPS;
  var WHOLE_VALID;
  var WHOLE_MAP;
  var VALID;
  var EMOJI_LIST;
  var EMOJI_ROOT;
  function init() {
    if (MAPPED)
      return;
    let r = read_compressed_payload(COMPRESSED$1);
    const read_sorted_array = () => read_sorted(r);
    const read_sorted_set = () => new Set(read_sorted_array());
    const set_add_many = (set2, v6) => v6.forEach((x6) => set2.add(x6));
    MAPPED = new Map(read_mapped(r));
    IGNORED = read_sorted_set();
    CM = read_sorted_array();
    NSM = new Set(read_sorted_array().map((i4) => CM[i4]));
    CM = new Set(CM);
    ESCAPE = read_sorted_set();
    read_sorted_set();
    let chunks = read_sorted_arrays(r);
    let unrestricted = r();
    const read_chunked = () => {
      let set2 = /* @__PURE__ */ new Set();
      read_sorted_array().forEach((i4) => set_add_many(set2, chunks[i4]));
      set_add_many(set2, read_sorted_array());
      return set2;
    };
    GROUPS = read_array_while((i4) => {
      let N10 = read_array_while(r).map((x6) => x6 + 96);
      if (N10.length) {
        let R5 = i4 >= unrestricted;
        N10[0] -= 32;
        N10 = str_from_cps(N10);
        if (R5)
          N10 = `Restricted[${N10}]`;
        let P5 = read_chunked();
        let Q5 = read_chunked();
        let M6 = !r();
        return { N: N10, P: P5, Q: Q5, M: M6, R: R5 };
      }
    });
    WHOLE_VALID = read_sorted_set();
    WHOLE_MAP = /* @__PURE__ */ new Map();
    let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a4, b7) => a4 - b7);
    wholes.forEach((cp, i4) => {
      let d5 = r();
      let w5 = wholes[i4] = d5 ? wholes[i4 - d5] : { V: [], M: /* @__PURE__ */ new Map() };
      w5.V.push(cp);
      if (!WHOLE_VALID.has(cp)) {
        WHOLE_MAP.set(cp, w5);
      }
    });
    for (let { V: V5, M: M6 } of new Set(WHOLE_MAP.values())) {
      let recs = [];
      for (let cp of V5) {
        let gs2 = GROUPS.filter((g5) => group_has_cp(g5, cp));
        let rec = recs.find(({ G: G7 }) => gs2.some((g5) => G7.has(g5)));
        if (!rec) {
          rec = { G: /* @__PURE__ */ new Set(), V: [] };
          recs.push(rec);
        }
        rec.V.push(cp);
        set_add_many(rec.G, gs2);
      }
      let union = recs.flatMap((x6) => Array_from(x6.G));
      for (let { G: G7, V: V6 } of recs) {
        let complement = new Set(union.filter((g5) => !G7.has(g5)));
        for (let cp of V6) {
          M6.set(cp, complement);
        }
      }
    }
    VALID = /* @__PURE__ */ new Set();
    let multi = /* @__PURE__ */ new Set();
    const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
    for (let g5 of GROUPS) {
      for (let cp of g5.P)
        add_to_union(cp);
      for (let cp of g5.Q)
        add_to_union(cp);
    }
    for (let cp of VALID) {
      if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
        WHOLE_MAP.set(cp, UNIQUE_PH);
      }
    }
    set_add_many(VALID, nfd(VALID));
    EMOJI_LIST = read_trie(r).map((v6) => Emoji.from(v6)).sort(compare_arrays);
    EMOJI_ROOT = /* @__PURE__ */ new Map();
    for (let cps of EMOJI_LIST) {
      let prev2 = [EMOJI_ROOT];
      for (let cp of cps) {
        let next2 = prev2.map((node) => {
          let child = node.get(cp);
          if (!child) {
            child = /* @__PURE__ */ new Map();
            node.set(cp, child);
          }
          return child;
        });
        if (cp === FE0F) {
          prev2.push(...next2);
        } else {
          prev2 = next2;
        }
      }
      for (let x6 of prev2) {
        x6.V = cps;
      }
    }
  }
  function quoted_cp(cp) {
    return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
  }
  function bidi_qq(s3) {
    return `"${s3}"\u200E`;
  }
  function check_label_extension(cps) {
    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
      throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
    }
  }
  function check_leading_underscore(cps) {
    const UNDERSCORE = 95;
    for (let i4 = cps.lastIndexOf(UNDERSCORE); i4 > 0; ) {
      if (cps[--i4] !== UNDERSCORE) {
        throw new Error("underscore allowed only at start");
      }
    }
  }
  function check_fenced(cps) {
    let cp = cps[0];
    let prev2 = FENCED.get(cp);
    if (prev2)
      throw error_placement(`leading ${prev2}`);
    let n4 = cps.length;
    let last = -1;
    for (let i4 = 1; i4 < n4; i4++) {
      cp = cps[i4];
      let match = FENCED.get(cp);
      if (match) {
        if (last == i4)
          throw error_placement(`${prev2} + ${match}`);
        last = i4 + 1;
        prev2 = match;
      }
    }
    if (last == n4)
      throw error_placement(`trailing ${prev2}`);
  }
  function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
    let buf = [];
    if (is_combining_mark(cps[0]))
      buf.push("\u25CC");
    if (cps.length > max) {
      max >>= 1;
      cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
    }
    let prev2 = 0;
    let n4 = cps.length;
    for (let i4 = 0; i4 < n4; i4++) {
      let cp = cps[i4];
      if (should_escape(cp)) {
        buf.push(str_from_cps(cps.slice(prev2, i4)));
        buf.push(quoter(cp));
        prev2 = i4 + 1;
      }
    }
    buf.push(str_from_cps(cps.slice(prev2, n4)));
    return buf.join("");
  }
  function is_combining_mark(cp) {
    init();
    return CM.has(cp);
  }
  function should_escape(cp) {
    init();
    return ESCAPE.has(cp);
  }
  function ens_normalize(name) {
    return flatten(split(name, nfc, filter_fe0f));
  }
  function split(name, nf2, ef2) {
    if (!name)
      return [];
    init();
    let offset = 0;
    return name.split(STOP_CH).map((label) => {
      let input = explode_cp(label);
      let info = {
        input,
        offset
      };
      offset += input.length + 1;
      try {
        let tokens = info.tokens = tokens_from_str(input, nf2, ef2);
        let token_count = tokens.length;
        let type2;
        if (!token_count) {
          throw new Error(`empty label`);
        }
        let norm = info.output = tokens.flat();
        check_leading_underscore(norm);
        let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
        if (!emoji && norm.every((cp) => cp < 128)) {
          check_label_extension(norm);
          type2 = "ASCII";
        } else {
          let chars = tokens.flatMap((x6) => x6.is_emoji ? [] : x6);
          if (!chars.length) {
            type2 = "Emoji";
          } else {
            if (CM.has(norm[0]))
              throw error_placement("leading combining mark");
            for (let i4 = 1; i4 < token_count; i4++) {
              let cps = tokens[i4];
              if (!cps.is_emoji && CM.has(cps[0])) {
                throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i4 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
              }
            }
            check_fenced(norm);
            let unique = Array_from(new Set(chars));
            let [g5] = determine_group(unique);
            check_group(g5, chars);
            check_whole(g5, unique);
            type2 = g5.N;
          }
        }
        info.type = type2;
      } catch (err) {
        info.error = err;
      }
      return info;
    });
  }
  function check_whole(group, unique) {
    let maker;
    let shared = [];
    for (let cp of unique) {
      let whole = WHOLE_MAP.get(cp);
      if (whole === UNIQUE_PH)
        return;
      if (whole) {
        let set2 = whole.M.get(cp);
        maker = maker ? maker.filter((g5) => set2.has(g5)) : Array_from(set2);
        if (!maker.length)
          return;
      } else {
        shared.push(cp);
      }
    }
    if (maker) {
      for (let g5 of maker) {
        if (shared.every((cp) => group_has_cp(g5, cp))) {
          throw new Error(`whole-script confusable: ${group.N}/${g5.N}`);
        }
      }
    }
  }
  function determine_group(unique) {
    let groups = GROUPS;
    for (let cp of unique) {
      let gs2 = groups.filter((g5) => group_has_cp(g5, cp));
      if (!gs2.length) {
        if (!GROUPS.some((g5) => group_has_cp(g5, cp))) {
          throw error_disallowed(cp);
        } else {
          throw error_group_member(groups[0], cp);
        }
      }
      groups = gs2;
      if (gs2.length == 1)
        break;
    }
    return groups;
  }
  function flatten(split2) {
    return split2.map(({ input, error: error2, output: output2 }) => {
      if (error2) {
        let msg = error2.message;
        throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
      }
      return str_from_cps(output2);
    }).join(STOP_CH);
  }
  function error_disallowed(cp) {
    return new Error(`disallowed character: ${quoted_cp(cp)}`);
  }
  function error_group_member(g5, cp) {
    let quoted = quoted_cp(cp);
    let gg = GROUPS.find((g6) => g6.P.has(cp));
    if (gg) {
      quoted = `${gg.N} ${quoted}`;
    }
    return new Error(`illegal mixture: ${g5.N} + ${quoted}`);
  }
  function error_placement(where) {
    return new Error(`illegal placement: ${where}`);
  }
  function check_group(g5, cps) {
    for (let cp of cps) {
      if (!group_has_cp(g5, cp)) {
        throw error_group_member(g5, cp);
      }
    }
    if (g5.M) {
      let decomposed2 = nfd(cps);
      for (let i4 = 1, e7 = decomposed2.length; i4 < e7; i4++) {
        if (NSM.has(decomposed2[i4])) {
          let j5 = i4 + 1;
          for (let cp; j5 < e7 && NSM.has(cp = decomposed2[j5]); j5++) {
            for (let k5 = i4; k5 < j5; k5++) {
              if (decomposed2[k5] == cp) {
                throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
              }
            }
          }
          if (j5 - i4 > NSM_MAX) {
            throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i4 - 1, j5)))} (${j5 - i4}/${NSM_MAX})`);
          }
          i4 = j5;
        }
      }
    }
  }
  function tokens_from_str(input, nf2, ef2) {
    let ret = [];
    let chars = [];
    input = input.slice().reverse();
    while (input.length) {
      let emoji = consume_emoji_reversed(input);
      if (emoji) {
        if (chars.length) {
          ret.push(nf2(chars));
          chars = [];
        }
        ret.push(ef2(emoji));
      } else {
        let cp = input.pop();
        if (VALID.has(cp)) {
          chars.push(cp);
        } else {
          let cps = MAPPED.get(cp);
          if (cps) {
            chars.push(...cps);
          } else if (!IGNORED.has(cp)) {
            throw error_disallowed(cp);
          }
        }
      }
    }
    if (chars.length) {
      ret.push(nf2(chars));
    }
    return ret;
  }
  function filter_fe0f(cps) {
    return cps.filter((cp) => cp != FE0F);
  }
  function consume_emoji_reversed(cps, eaten) {
    let node = EMOJI_ROOT;
    let emoji;
    let pos = cps.length;
    while (pos) {
      node = node.get(cps[--pos]);
      if (!node)
        break;
      let { V: V5 } = node;
      if (V5) {
        emoji = V5;
        cps.length = pos;
      }
    }
    return emoji;
  }
  var Zeros = new Uint8Array(32);
  Zeros.fill(0);
  function checkComponent(comp) {
    assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
    return comp;
  }
  function ensNameSplit(name) {
    const bytes2 = toUtf8Bytes(ensNormalize(name));
    const comps = [];
    if (name.length === 0) {
      return comps;
    }
    let last = 0;
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      const d5 = bytes2[i4];
      if (d5 === 46) {
        comps.push(checkComponent(bytes2.slice(last, i4)));
        last = i4 + 1;
      }
    }
    assertArgument(last < bytes2.length, "invalid ENS name; empty component", "name", name);
    comps.push(checkComponent(bytes2.slice(last)));
    return comps;
  }
  function ensNormalize(name) {
    try {
      if (name.length === 0) {
        throw new Error("empty label");
      }
      return ens_normalize(name);
    } catch (error2) {
      assertArgument(false, `invalid ENS name (${error2.message})`, "name", name);
    }
  }
  function namehash(name) {
    assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
    assertArgument(name.length, `invalid ENS name (empty label)`, "name", name);
    let result = Zeros;
    const comps = ensNameSplit(name);
    while (comps.length) {
      result = keccak2562(concat([result, keccak2562(comps.pop())]));
    }
    return hexlify(result);
  }
  function dnsEncode(name, _maxLength) {
    const length2 = _maxLength;
    assertArgument(length2 <= 255, "DNS encoded label cannot exceed 255", "length", length2);
    return hexlify(concat(ensNameSplit(name).map((comp) => {
      assertArgument(comp.length <= length2, `label ${JSON.stringify(name)} exceeds ${length2} bytes`, "name", name);
      const bytes2 = new Uint8Array(comp.length + 1);
      bytes2.set(comp, 1);
      bytes2[0] = bytes2.length - 1;
      return bytes2;
    }))) + "00";
  }
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress(addr),
      storageKeys: storageKeys.map((storageKey, index) => {
        assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set2, index) => {
        if (Array.isArray(set2)) {
          assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
          return accessSetify(set2[0], set2[1]);
        }
        assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
        return accessSetify(set2.address, set2.storageKeys);
      });
    }
    assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a4, b7) => a4.address.localeCompare(b7.address));
    return result;
  }
  function computeAddress(key) {
    let pubkey;
    if (typeof key === "string") {
      pubkey = SigningKey.computePublicKey(key, false);
    } else {
      pubkey = key.publicKey;
    }
    return getAddress(keccak2562("0x" + pubkey.substring(4)).substring(26));
  }
  function recoverAddress(digest, signature) {
    return computeAddress(SigningKey.recoverPublicKey(digest, signature));
  }
  var BN_0$4 = BigInt(0);
  var BN_2$1 = BigInt(2);
  var BN_27 = BigInt(27);
  var BN_28 = BigInt(28);
  var BN_35 = BigInt(35);
  var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var BLOB_SIZE = 4096 * 32;
  function getVersionedHash(version2, hash2) {
    let versioned = version2.toString(16);
    while (versioned.length < 2) {
      versioned = "0" + versioned;
    }
    versioned += sha256(hash2).substring(4);
    return "0x" + versioned;
  }
  function handleAddress(value) {
    if (value === "0x") {
      return null;
    }
    return getAddress(value);
  }
  function handleAccessList(value, param) {
    try {
      return accessListify(value);
    } catch (error2) {
      assertArgument(false, error2.message, param, value);
    }
  }
  function handleNumber(_value, param) {
    if (_value === "0x") {
      return 0;
    }
    return getNumber(_value, param);
  }
  function handleUint(_value, param) {
    if (_value === "0x") {
      return BN_0$4;
    }
    const value = getBigInt(_value, param);
    assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
    return value;
  }
  function formatNumber(_value, name) {
    const value = getBigInt(_value, "value");
    const result = toBeArray(value);
    assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
    return result;
  }
  function formatAccessList(value) {
    return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
  }
  function formatHashes(value, param) {
    assertArgument(Array.isArray(value), `invalid ${param}`, "value", value);
    for (let i4 = 0; i4 < value.length; i4++) {
      assertArgument(isHexString(value[i4], 32), "invalid ${ param } hash", `value[${i4}]`, value[i4]);
    }
    return value;
  }
  function _parseLegacy(data) {
    const fields = decodeRlp(data);
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
    const tx = {
      type: 0,
      nonce: handleNumber(fields[0], "nonce"),
      gasPrice: handleUint(fields[1], "gasPrice"),
      gasLimit: handleUint(fields[2], "gasLimit"),
      to: handleAddress(fields[3]),
      value: handleUint(fields[4], "value"),
      data: hexlify(fields[5]),
      chainId: BN_0$4
    };
    if (fields.length === 6) {
      return tx;
    }
    const v6 = handleUint(fields[6], "v");
    const r = handleUint(fields[7], "r");
    const s3 = handleUint(fields[8], "s");
    if (r === BN_0$4 && s3 === BN_0$4) {
      tx.chainId = v6;
    } else {
      let chainId = (v6 - BN_35) / BN_2$1;
      if (chainId < BN_0$4) {
        chainId = BN_0$4;
      }
      tx.chainId = chainId;
      assertArgument(chainId !== BN_0$4 || (v6 === BN_27 || v6 === BN_28), "non-canonical legacy v", "v", fields[6]);
      tx.signature = Signature.from({
        r: zeroPadValue(fields[7], 32),
        s: zeroPadValue(fields[8], 32),
        v: v6
      });
    }
    return tx;
  }
  function _serializeLegacy(tx, sig) {
    const fields = [
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.gasPrice || 0, "gasPrice"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data
    ];
    let chainId = BN_0$4;
    if (tx.chainId != BN_0$4) {
      chainId = getBigInt(tx.chainId, "tx.chainId");
      assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
    } else if (tx.signature) {
      const legacy = tx.signature.legacyChainId;
      if (legacy != null) {
        chainId = legacy;
      }
    }
    if (!sig) {
      if (chainId !== BN_0$4) {
        fields.push(toBeArray(chainId));
        fields.push("0x");
        fields.push("0x");
      }
      return encodeRlp(fields);
    }
    let v6 = BigInt(27 + sig.yParity);
    if (chainId !== BN_0$4) {
      v6 = Signature.getChainIdV(chainId, sig.v);
    } else if (BigInt(sig.v) !== v6) {
      assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
    }
    fields.push(toBeArray(v6));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
    return encodeRlp(fields);
  }
  function _parseEipSignature(tx, fields) {
    let yParity;
    try {
      yParity = handleNumber(fields[0], "yParity");
      if (yParity !== 0 && yParity !== 1) {
        throw new Error("bad yParity");
      }
    } catch (error2) {
      assertArgument(false, "invalid yParity", "yParity", fields[0]);
    }
    const r = zeroPadValue(fields[1], 32);
    const s3 = zeroPadValue(fields[2], 32);
    const signature = Signature.from({ r, s: s3, yParity });
    tx.signature = signature;
  }
  function _parseEip1559(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data));
    const tx = {
      type: 2,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: hexlify(fields[7]),
      accessList: handleAccessList(fields[8], "accessList")
    };
    if (fields.length === 9) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(9));
    return tx;
  }
  function _serializeEip1559(tx, sig) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || [])
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
    }
    return concat(["0x02", encodeRlp(fields)]);
  }
  function _parseEip2930(data) {
    const fields = decodeRlp(getBytes(data).slice(1));
    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data));
    const tx = {
      type: 1,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      gasPrice: handleUint(fields[2], "gasPrice"),
      gasLimit: handleUint(fields[3], "gasLimit"),
      to: handleAddress(fields[4]),
      value: handleUint(fields[5], "value"),
      data: hexlify(fields[6]),
      accessList: handleAccessList(fields[7], "accessList")
    };
    if (fields.length === 8) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(8));
    return tx;
  }
  function _serializeEip2930(tx, sig) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.gasPrice || 0, "gasPrice"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || "0x",
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || [])
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "recoveryParam"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
    }
    return concat(["0x01", encodeRlp(fields)]);
  }
  function _parseEip4844(data) {
    let fields = decodeRlp(getBytes(data).slice(1));
    let typeName = "3";
    let blobs = null;
    if (fields.length === 4 && Array.isArray(fields[0])) {
      typeName = "3 (network format)";
      const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
      assertArgument(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
      assertArgument(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
      assertArgument(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
      assertArgument(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
      assertArgument(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
      blobs = [];
      for (let i4 = 0; i4 < fields[1].length; i4++) {
        blobs.push({
          data: fBlobs[i4],
          commitment: fCommits[i4],
          proof: fProofs[i4]
        });
      }
      fields = fields[0];
    }
    assertArgument(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", hexlify(data));
    const tx = {
      type: 3,
      chainId: handleUint(fields[0], "chainId"),
      nonce: handleNumber(fields[1], "nonce"),
      maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
      maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
      gasPrice: null,
      gasLimit: handleUint(fields[4], "gasLimit"),
      to: handleAddress(fields[5]),
      value: handleUint(fields[6], "value"),
      data: hexlify(fields[7]),
      accessList: handleAccessList(fields[8], "accessList"),
      maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
      blobVersionedHashes: fields[10]
    };
    if (blobs) {
      tx.blobs = blobs;
    }
    assertArgument(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
    assertArgument(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
    for (let i4 = 0; i4 < tx.blobVersionedHashes.length; i4++) {
      assertArgument(isHexString(tx.blobVersionedHashes[i4], 32), `invalid blobVersionedHash at index ${i4}: must be length 32`, "data", data);
    }
    if (fields.length === 11) {
      return tx;
    }
    _parseEipSignature(tx, fields.slice(11));
    return tx;
  }
  function _serializeEip4844(tx, sig, blobs) {
    const fields = [
      formatNumber(tx.chainId, "chainId"),
      formatNumber(tx.nonce, "nonce"),
      formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(tx.gasLimit, "gasLimit"),
      tx.to || ZeroAddress,
      formatNumber(tx.value, "value"),
      tx.data,
      formatAccessList(tx.accessList || []),
      formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
      formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
    ];
    if (sig) {
      fields.push(formatNumber(sig.yParity, "yParity"));
      fields.push(toBeArray(sig.r));
      fields.push(toBeArray(sig.s));
      if (blobs) {
        return concat([
          "0x03",
          encodeRlp([
            fields,
            blobs.map((b7) => b7.data),
            blobs.map((b7) => b7.commitment),
            blobs.map((b7) => b7.proof)
          ])
        ]);
      }
    }
    return concat(["0x03", encodeRlp(fields)]);
  }
  var Transaction = class {
    #type;
    #to;
    #data;
    #nonce;
    #gasLimit;
    #gasPrice;
    #maxPriorityFeePerGas;
    #maxFeePerGas;
    #value;
    #chainId;
    #sig;
    #accessList;
    #maxFeePerBlobGas;
    #blobVersionedHashes;
    #kzg;
    #blobs;
    get type() {
      return this.#type;
    }
    set type(value) {
      switch (value) {
        case null:
          this.#type = null;
          break;
        case 0:
        case "legacy":
          this.#type = 0;
          break;
        case 1:
        case "berlin":
        case "eip-2930":
          this.#type = 1;
          break;
        case 2:
        case "london":
        case "eip-1559":
          this.#type = 2;
          break;
        case 3:
        case "cancun":
        case "eip-4844":
          this.#type = 3;
          break;
        default:
          assertArgument(false, "unsupported transaction type", "type", value);
      }
    }
    get typeName() {
      switch (this.type) {
        case 0:
          return "legacy";
        case 1:
          return "eip-2930";
        case 2:
          return "eip-1559";
        case 3:
          return "eip-4844";
      }
      return null;
    }
    get to() {
      const value = this.#to;
      if (value == null && this.type === 3) {
        return ZeroAddress;
      }
      return value;
    }
    set to(value) {
      this.#to = value == null ? null : getAddress(value);
    }
    get nonce() {
      return this.#nonce;
    }
    set nonce(value) {
      this.#nonce = getNumber(value, "value");
    }
    get gasLimit() {
      return this.#gasLimit;
    }
    set gasLimit(value) {
      this.#gasLimit = getBigInt(value);
    }
    get gasPrice() {
      const value = this.#gasPrice;
      if (value == null && (this.type === 0 || this.type === 1)) {
        return BN_0$4;
      }
      return value;
    }
    set gasPrice(value) {
      this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
    }
    get maxPriorityFeePerGas() {
      const value = this.#maxPriorityFeePerGas;
      if (value == null) {
        if (this.type === 2 || this.type === 3) {
          return BN_0$4;
        }
        return null;
      }
      return value;
    }
    set maxPriorityFeePerGas(value) {
      this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
    }
    get maxFeePerGas() {
      const value = this.#maxFeePerGas;
      if (value == null) {
        if (this.type === 2 || this.type === 3) {
          return BN_0$4;
        }
        return null;
      }
      return value;
    }
    set maxFeePerGas(value) {
      this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
    }
    get data() {
      return this.#data;
    }
    set data(value) {
      this.#data = hexlify(value);
    }
    get value() {
      return this.#value;
    }
    set value(value) {
      this.#value = getBigInt(value, "value");
    }
    get chainId() {
      return this.#chainId;
    }
    set chainId(value) {
      this.#chainId = getBigInt(value);
    }
    get signature() {
      return this.#sig || null;
    }
    set signature(value) {
      this.#sig = value == null ? null : Signature.from(value);
    }
    get accessList() {
      const value = this.#accessList || null;
      if (value == null) {
        if (this.type === 1 || this.type === 2 || this.type === 3) {
          return [];
        }
        return null;
      }
      return value;
    }
    set accessList(value) {
      this.#accessList = value == null ? null : accessListify(value);
    }
    get maxFeePerBlobGas() {
      const value = this.#maxFeePerBlobGas;
      if (value == null && this.type === 3) {
        return BN_0$4;
      }
      return value;
    }
    set maxFeePerBlobGas(value) {
      this.#maxFeePerBlobGas = value == null ? null : getBigInt(value, "maxFeePerBlobGas");
    }
    get blobVersionedHashes() {
      let value = this.#blobVersionedHashes;
      if (value == null && this.type === 3) {
        return [];
      }
      return value;
    }
    set blobVersionedHashes(value) {
      if (value != null) {
        assertArgument(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
        value = value.slice();
        for (let i4 = 0; i4 < value.length; i4++) {
          assertArgument(isHexString(value[i4], 32), "invalid blobVersionedHash", `value[${i4}]`, value[i4]);
        }
      }
      this.#blobVersionedHashes = value;
    }
    get blobs() {
      if (this.#blobs == null) {
        return null;
      }
      return this.#blobs.map((b7) => Object.assign({}, b7));
    }
    set blobs(_blobs) {
      if (_blobs == null) {
        this.#blobs = null;
        return;
      }
      const blobs = [];
      const versionedHashes = [];
      for (let i4 = 0; i4 < _blobs.length; i4++) {
        const blob = _blobs[i4];
        if (isBytesLike(blob)) {
          assert2(this.#kzg, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
            operation: "set blobs()"
          });
          let data = getBytes(blob);
          assertArgument(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i4}]`, blob);
          if (data.length !== BLOB_SIZE) {
            const padded = new Uint8Array(BLOB_SIZE);
            padded.set(data);
            data = padded;
          }
          const commit = this.#kzg.blobToKzgCommitment(data);
          const proof = hexlify(this.#kzg.computeBlobKzgProof(data, commit));
          blobs.push({
            data: hexlify(data),
            commitment: hexlify(commit),
            proof
          });
          versionedHashes.push(getVersionedHash(1, commit));
        } else {
          const commit = hexlify(blob.commitment);
          blobs.push({
            data: hexlify(blob.data),
            commitment: commit,
            proof: hexlify(blob.proof)
          });
          versionedHashes.push(getVersionedHash(1, commit));
        }
      }
      this.#blobs = blobs;
      this.#blobVersionedHashes = versionedHashes;
    }
    get kzg() {
      return this.#kzg;
    }
    set kzg(kzg) {
      this.#kzg = kzg;
    }
    constructor() {
      this.#type = null;
      this.#to = null;
      this.#nonce = 0;
      this.#gasLimit = BN_0$4;
      this.#gasPrice = null;
      this.#maxPriorityFeePerGas = null;
      this.#maxFeePerGas = null;
      this.#data = "0x";
      this.#value = BN_0$4;
      this.#chainId = BN_0$4;
      this.#sig = null;
      this.#accessList = null;
      this.#maxFeePerBlobGas = null;
      this.#blobVersionedHashes = null;
      this.#blobs = null;
      this.#kzg = null;
    }
    get hash() {
      if (this.signature == null) {
        return null;
      }
      return keccak2562(this.#getSerialized(true, false));
    }
    get unsignedHash() {
      return keccak2562(this.unsignedSerialized);
    }
    get from() {
      if (this.signature == null) {
        return null;
      }
      return recoverAddress(this.unsignedHash, this.signature);
    }
    get fromPublicKey() {
      if (this.signature == null) {
        return null;
      }
      return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
    }
    isSigned() {
      return this.signature != null;
    }
    #getSerialized(signed2, sidecar) {
      assert2(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
      const sig = signed2 ? this.signature : null;
      switch (this.inferType()) {
        case 0:
          return _serializeLegacy(this, sig);
        case 1:
          return _serializeEip2930(this, sig);
        case 2:
          return _serializeEip1559(this, sig);
        case 3:
          return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      }
      assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    }
    get serialized() {
      return this.#getSerialized(true, true);
    }
    get unsignedSerialized() {
      return this.#getSerialized(false, false);
    }
    inferType() {
      const types2 = this.inferTypes();
      if (types2.indexOf(2) >= 0) {
        return 2;
      }
      return types2.pop();
    }
    inferTypes() {
      const hasGasPrice = this.gasPrice != null;
      const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
      const hasAccessList = this.accessList != null;
      const hasBlob = this.#maxFeePerBlobGas != null || this.#blobVersionedHashes;
      if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
        assert2(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
      }
      assert2(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
      assert2(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
      const types2 = [];
      if (this.type != null) {
        types2.push(this.type);
      } else {
        if (hasFee) {
          types2.push(2);
        } else if (hasGasPrice) {
          types2.push(1);
          if (!hasAccessList) {
            types2.push(0);
          }
        } else if (hasAccessList) {
          types2.push(1);
          types2.push(2);
        } else if (hasBlob && this.to) {
          types2.push(3);
        } else {
          types2.push(0);
          types2.push(1);
          types2.push(2);
          types2.push(3);
        }
      }
      types2.sort();
      return types2;
    }
    isLegacy() {
      return this.type === 0;
    }
    isBerlin() {
      return this.type === 1;
    }
    isLondon() {
      return this.type === 2;
    }
    isCancun() {
      return this.type === 3;
    }
    clone() {
      return Transaction.from(this);
    }
    toJSON() {
      const s3 = (v6) => {
        if (v6 == null) {
          return null;
        }
        return v6.toString();
      };
      return {
        type: this.type,
        to: this.to,
        data: this.data,
        nonce: this.nonce,
        gasLimit: s3(this.gasLimit),
        gasPrice: s3(this.gasPrice),
        maxPriorityFeePerGas: s3(this.maxPriorityFeePerGas),
        maxFeePerGas: s3(this.maxFeePerGas),
        value: s3(this.value),
        chainId: s3(this.chainId),
        sig: this.signature ? this.signature.toJSON() : null,
        accessList: this.accessList
      };
    }
    static from(tx) {
      if (tx == null) {
        return new Transaction();
      }
      if (typeof tx === "string") {
        const payload = getBytes(tx);
        if (payload[0] >= 127) {
          return Transaction.from(_parseLegacy(payload));
        }
        switch (payload[0]) {
          case 1:
            return Transaction.from(_parseEip2930(payload));
          case 2:
            return Transaction.from(_parseEip1559(payload));
          case 3:
            return Transaction.from(_parseEip4844(payload));
        }
        assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
      }
      const result = new Transaction();
      if (tx.type != null) {
        result.type = tx.type;
      }
      if (tx.to != null) {
        result.to = tx.to;
      }
      if (tx.nonce != null) {
        result.nonce = tx.nonce;
      }
      if (tx.gasLimit != null) {
        result.gasLimit = tx.gasLimit;
      }
      if (tx.gasPrice != null) {
        result.gasPrice = tx.gasPrice;
      }
      if (tx.maxPriorityFeePerGas != null) {
        result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
      }
      if (tx.maxFeePerGas != null) {
        result.maxFeePerGas = tx.maxFeePerGas;
      }
      if (tx.maxFeePerBlobGas != null) {
        result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
      }
      if (tx.data != null) {
        result.data = tx.data;
      }
      if (tx.value != null) {
        result.value = tx.value;
      }
      if (tx.chainId != null) {
        result.chainId = tx.chainId;
      }
      if (tx.signature != null) {
        result.signature = Signature.from(tx.signature);
      }
      if (tx.accessList != null) {
        result.accessList = tx.accessList;
      }
      if (tx.blobVersionedHashes != null) {
        result.blobVersionedHashes = tx.blobVersionedHashes;
      }
      if (tx.kzg != null) {
        result.kzg = tx.kzg;
      }
      if (tx.blobs != null) {
        result.blobs = tx.blobs;
      }
      if (tx.hash != null) {
        assertArgument(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
        assertArgument(result.hash === tx.hash, "hash mismatch", "tx", tx);
      }
      if (tx.from != null) {
        assertArgument(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
        assertArgument(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
      }
      return result;
    }
  };
  var padding = new Uint8Array(32);
  padding.fill(0);
  var BN__1 = BigInt(-1);
  var BN_0$3 = BigInt(0);
  var BN_1 = BigInt(1);
  var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function hexPadRight(value) {
    const bytes2 = getBytes(value);
    const padOffset = bytes2.length % 32;
    if (padOffset) {
      return concat([bytes2, padding.slice(padOffset)]);
    }
    return hexlify(bytes2);
  }
  var hexTrue = toBeHex(BN_1, 32);
  var hexFalse = toBeHex(BN_0$3, 32);
  var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  };
  var domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  function checkString(key) {
    return function(value) {
      assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
      return value;
    };
  }
  var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(_value) {
      const value = getBigInt(_value, "domain.chainId");
      assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
      if (Number.isSafeInteger(value)) {
        return Number(value);
      }
      return toQuantity(value);
    },
    verifyingContract: function(value) {
      try {
        return getAddress(value).toLowerCase();
      } catch (error2) {
      }
      assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function(value) {
      const bytes2 = getBytes(value, "domain.salt");
      assertArgument(bytes2.length === 32, `invalid domain value "salt"`, "domain.salt", value);
      return hexlify(bytes2);
    }
  };
  function getBaseEncoder(type2) {
    {
      const match = type2.match(/^(u?)int(\d+)$/);
      if (match) {
        const signed2 = match[1] === "";
        const width = parseInt(match[2]);
        assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type2);
        const boundsUpper = mask(BN_MAX_UINT256, signed2 ? width - 1 : width);
        const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0$3;
        return function(_value) {
          const value = getBigInt(_value, "value");
          assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type2}`, "value", value);
          return toBeHex(signed2 ? toTwos(value, 256) : value, 32);
        };
      }
    }
    {
      const match = type2.match(/^bytes(\d+)$/);
      if (match) {
        const width = parseInt(match[1]);
        assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type2);
        return function(value) {
          const bytes2 = getBytes(value);
          assertArgument(bytes2.length === width, `invalid length for ${type2}`, "value", value);
          return hexPadRight(value);
        };
      }
    }
    switch (type2) {
      case "address":
        return function(value) {
          return zeroPadValue(getAddress(value), 32);
        };
      case "bool":
        return function(value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function(value) {
          return keccak2562(value);
        };
      case "string":
        return function(value) {
          return id2(value);
        };
    }
    return null;
  }
  function encodeType(name, fields) {
    return `${name}(${fields.map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",")})`;
  }
  function splitArray(type2) {
    const match = type2.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
    if (match) {
      return {
        base: match[1],
        index: match[2] + match[4],
        array: {
          base: match[1],
          prefix: match[1] + match[2],
          count: match[5] ? parseInt(match[5]) : -1
        }
      };
    }
    return { base: type2 };
  }
  var TypedDataEncoder = class {
    primaryType;
    #types;
    get types() {
      return JSON.parse(this.#types);
    }
    #fullTypes;
    #encoderCache;
    constructor(_types) {
      this.#fullTypes = /* @__PURE__ */ new Map();
      this.#encoderCache = /* @__PURE__ */ new Map();
      const links = /* @__PURE__ */ new Map();
      const parents = /* @__PURE__ */ new Map();
      const subtypes = /* @__PURE__ */ new Map();
      const types2 = {};
      Object.keys(_types).forEach((type2) => {
        types2[type2] = _types[type2].map(({ name, type: type3 }) => {
          let { base: base3, index } = splitArray(type3);
          if (base3 === "int" && !_types["int"]) {
            base3 = "int256";
          }
          if (base3 === "uint" && !_types["uint"]) {
            base3 = "uint256";
          }
          return { name, type: base3 + (index || "") };
        });
        links.set(type2, /* @__PURE__ */ new Set());
        parents.set(type2, []);
        subtypes.set(type2, /* @__PURE__ */ new Set());
      });
      this.#types = JSON.stringify(types2);
      for (const name in types2) {
        const uniqueNames = /* @__PURE__ */ new Set();
        for (const field of types2[name]) {
          assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types);
          uniqueNames.add(field.name);
          const baseType = splitArray(field.type).base;
          assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types);
          const encoder = getBaseEncoder(baseType);
          if (encoder) {
            continue;
          }
          assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types);
          parents.get(baseType).push(name);
          links.get(name).add(baseType);
        }
      }
      const primaryTypes = Array.from(parents.keys()).filter((n4) => parents.get(n4).length === 0);
      assertArgument(primaryTypes.length !== 0, "missing primary type", "types", _types);
      assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", _types);
      defineProperties(this, { primaryType: primaryTypes[0] });
      function checkCircular(type2, found) {
        assertArgument(!found.has(type2), `circular type reference to ${JSON.stringify(type2)}`, "types", _types);
        found.add(type2);
        for (const child of links.get(type2)) {
          if (!parents.has(child)) {
            continue;
          }
          checkCircular(child, found);
          for (const subtype of found) {
            subtypes.get(subtype).add(child);
          }
        }
        found.delete(type2);
      }
      checkCircular(this.primaryType, /* @__PURE__ */ new Set());
      for (const [name, set2] of subtypes) {
        const st3 = Array.from(set2);
        st3.sort();
        this.#fullTypes.set(name, encodeType(name, types2[name]) + st3.map((t) => encodeType(t, types2[t])).join(""));
      }
    }
    getEncoder(type2) {
      let encoder = this.#encoderCache.get(type2);
      if (!encoder) {
        encoder = this.#getEncoder(type2);
        this.#encoderCache.set(type2, encoder);
      }
      return encoder;
    }
    #getEncoder(type2) {
      {
        const encoder = getBaseEncoder(type2);
        if (encoder) {
          return encoder;
        }
      }
      const array = splitArray(type2).array;
      if (array) {
        const subtype = array.prefix;
        const subEncoder = this.getEncoder(subtype);
        return (value) => {
          assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
          let result = value.map(subEncoder);
          if (this.#fullTypes.has(subtype)) {
            result = result.map(keccak2562);
          }
          return keccak2562(concat(result));
        };
      }
      const fields = this.types[type2];
      if (fields) {
        const encodedType = id2(this.#fullTypes.get(type2));
        return (value) => {
          const values = fields.map(({ name, type: type3 }) => {
            const result = this.getEncoder(type3)(value[name]);
            if (this.#fullTypes.has(type3)) {
              return keccak2562(result);
            }
            return result;
          });
          values.unshift(encodedType);
          return concat(values);
        };
      }
      assertArgument(false, `unknown type: ${type2}`, "type", type2);
    }
    encodeType(name) {
      const result = this.#fullTypes.get(name);
      assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
      return result;
    }
    encodeData(type2, value) {
      return this.getEncoder(type2)(value);
    }
    hashStruct(name, value) {
      return keccak2562(this.encodeData(name, value));
    }
    encode(value) {
      return this.encodeData(this.primaryType, value);
    }
    hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
    _visit(type2, value, callback) {
      {
        const encoder = getBaseEncoder(type2);
        if (encoder) {
          return callback(type2, value);
        }
      }
      const array = splitArray(type2).array;
      if (array) {
        assertArgument(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
        return value.map((v6) => this._visit(array.prefix, v6, callback));
      }
      const fields = this.types[type2];
      if (fields) {
        return fields.reduce((accum, { name, type: type3 }) => {
          accum[name] = this._visit(type3, value[name], callback);
          return accum;
        }, {});
      }
      assertArgument(false, `unknown type: ${type2}`, "type", type2);
    }
    visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
    static from(types2) {
      return new TypedDataEncoder(types2);
    }
    static getPrimaryType(types2) {
      return TypedDataEncoder.from(types2).primaryType;
    }
    static hashStruct(name, types2, value) {
      return TypedDataEncoder.from(types2).hashStruct(name, value);
    }
    static hashDomain(domain) {
      const domainFields = [];
      for (const name in domain) {
        if (domain[name] == null) {
          continue;
        }
        const type2 = domainFieldTypes[name];
        assertArgument(type2, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
        domainFields.push({ name, type: type2 });
      }
      domainFields.sort((a4, b7) => {
        return domainFieldNames.indexOf(a4.name) - domainFieldNames.indexOf(b7.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types2, value) {
      return concat([
        "0x1901",
        TypedDataEncoder.hashDomain(domain),
        TypedDataEncoder.from(types2).hash(value)
      ]);
    }
    static hash(domain, types2, value) {
      return keccak2562(TypedDataEncoder.encode(domain, types2, value));
    }
    static async resolveNames(domain, types2, value, resolveName) {
      domain = Object.assign({}, domain);
      for (const key in domain) {
        if (domain[key] == null) {
          delete domain[key];
        }
      }
      const ensCache = {};
      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && !isHexString(value2, 20)) {
          ensCache[value2] = "0x";
        }
        return value2;
      });
      for (const name in ensCache) {
        ensCache[name] = await resolveName(name);
      }
      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      }
      value = encoder.visit(value, (type2, value2) => {
        if (type2 === "address" && ensCache[value2]) {
          return ensCache[value2];
        }
        return value2;
      });
      return { domain, value };
    }
    static getPayload(domain, types2, value) {
      TypedDataEncoder.hashDomain(domain);
      const domainValues = {};
      const domainTypes = [];
      domainFieldNames.forEach((name) => {
        const value2 = domain[name];
        if (value2 == null) {
          return;
        }
        domainValues[name] = domainChecks[name](value2);
        domainTypes.push({ name, type: domainFieldTypes[name] });
      });
      const encoder = TypedDataEncoder.from(types2);
      types2 = encoder.types;
      const typesWithDomain = Object.assign({}, types2);
      assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types2);
      typesWithDomain.EIP712Domain = domainTypes;
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, (type2, value2) => {
          if (type2.match(/^bytes(\d*)/)) {
            return hexlify(getBytes(value2));
          }
          if (type2.match(/^u?int/)) {
            return getBigInt(value2).toString();
          }
          switch (type2) {
            case "address":
              return value2.toLowerCase();
            case "bool":
              return !!value2;
            case "string":
              assertArgument(typeof value2 === "string", "invalid string", "value", value2);
              return value2;
          }
          assertArgument(false, "unsupported type", "type", type2);
        })
      };
    }
  };
  function setify(items2) {
    const result = /* @__PURE__ */ new Set();
    items2.forEach((k5) => result.add(k5));
    return Object.freeze(result);
  }
  var _kwVisibDeploy = "external public payable override";
  var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
  var _kwVisib = "constant external internal payable private public pure view override";
  var KwVisib = setify(_kwVisib.split(" "));
  var _kwTypes = "constructor error event fallback function receive struct";
  var KwTypes = setify(_kwTypes.split(" "));
  var _kwModifiers = "calldata memory storage payable indexed";
  var KwModifiers = setify(_kwModifiers.split(" "));
  var _kwOther = "tuple returns";
  var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
  var Keywords = setify(_keywords.split(" "));
  var SimpleTokens = {
    "(": "OPEN_PAREN",
    ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET",
    "]": "CLOSE_BRACKET",
    ",": "COMMA",
    "@": "AT"
  };
  var regexWhitespacePrefix = new RegExp("^(\\s*)");
  var regexNumberPrefix = new RegExp("^([0-9]+)");
  var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
  var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
  var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
  var TokenString = class {
    #offset;
    #tokens;
    get offset() {
      return this.#offset;
    }
    get length() {
      return this.#tokens.length - this.#offset;
    }
    constructor(tokens) {
      this.#offset = 0;
      this.#tokens = tokens.slice();
    }
    clone() {
      return new TokenString(this.#tokens);
    }
    reset() {
      this.#offset = 0;
    }
    #subTokenString(from2 = 0, to2 = 0) {
      return new TokenString(this.#tokens.slice(from2, to2).map((t) => {
        return Object.freeze(Object.assign({}, t, {
          match: t.match - from2,
          linkBack: t.linkBack - from2,
          linkNext: t.linkNext - from2
        }));
      }));
    }
    popKeyword(allowed) {
      const top = this.peek();
      if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
        throw new Error(`expected keyword ${top.text}`);
      }
      return this.pop().text;
    }
    popType(type2) {
      if (this.peek().type !== type2) {
        const top = this.peek();
        throw new Error(`expected ${type2}; got ${top.type} ${JSON.stringify(top.text)}`);
      }
      return this.pop().text;
    }
    popParen() {
      const top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      const result = this.#subTokenString(this.#offset + 1, top.match + 1);
      this.#offset = top.match + 1;
      return result;
    }
    popParams() {
      const top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      const result = [];
      while (this.#offset < top.match - 1) {
        const link = this.peek().linkNext;
        result.push(this.#subTokenString(this.#offset + 1, link));
        this.#offset = link;
      }
      this.#offset = top.match + 1;
      return result;
    }
    peek() {
      if (this.#offset >= this.#tokens.length) {
        throw new Error("out-of-bounds");
      }
      return this.#tokens[this.#offset];
    }
    peekKeyword(allowed) {
      const top = this.peekType("KEYWORD");
      return top != null && allowed.has(top) ? top : null;
    }
    peekType(type2) {
      if (this.length === 0) {
        return null;
      }
      const top = this.peek();
      return top.type === type2 ? top.text : null;
    }
    pop() {
      const result = this.peek();
      this.#offset++;
      return result;
    }
    toString() {
      const tokens = [];
      for (let i4 = this.#offset; i4 < this.#tokens.length; i4++) {
        const token = this.#tokens[i4];
        tokens.push(`${token.type}:${token.text}`);
      }
      return `<TokenString ${tokens.join(" ")}>`;
    }
  };
  function lex(text) {
    const tokens = [];
    const throwError2 = (message) => {
      const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
      throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
      let cur = text.substring(offset);
      let match = cur.match(regexWhitespacePrefix);
      if (match) {
        offset += match[1].length;
        cur = text.substring(offset);
      }
      const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
      tokens.push(token);
      let type2 = SimpleTokens[cur[0]] || "";
      if (type2) {
        token.type = type2;
        token.text = cur[0];
        offset++;
        if (type2 === "OPEN_PAREN") {
          brackets.push(tokens.length - 1);
          commas.push(tokens.length - 1);
        } else if (type2 == "CLOSE_PAREN") {
          if (brackets.length === 0) {
            throwError2("no matching open bracket");
          }
          token.match = brackets.pop();
          tokens[token.match].match = tokens.length - 1;
          token.depth--;
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
        } else if (type2 === "COMMA") {
          token.linkBack = commas.pop();
          tokens[token.linkBack].linkNext = tokens.length - 1;
          commas.push(tokens.length - 1);
        } else if (type2 === "OPEN_BRACKET") {
          token.type = "BRACKET";
        } else if (type2 === "CLOSE_BRACKET") {
          let suffix = tokens.pop().text;
          if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
            const value = tokens.pop().text;
            suffix = value + suffix;
            tokens[tokens.length - 1].value = getNumber(value);
          }
          if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
            throw new Error("missing opening bracket");
          }
          tokens[tokens.length - 1].text += suffix;
        }
        continue;
      }
      match = cur.match(regexIdPrefix);
      if (match) {
        token.text = match[1];
        offset += token.text.length;
        if (Keywords.has(token.text)) {
          token.type = "KEYWORD";
          continue;
        }
        if (token.text.match(regexType)) {
          token.type = "TYPE";
          continue;
        }
        token.type = "ID";
        continue;
      }
      match = cur.match(regexNumberPrefix);
      if (match) {
        token.text = match[1];
        token.type = "NUMBER";
        offset += token.text.length;
        continue;
      }
      throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
  }
  function allowSingle(set2, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
      if (set2.has(key)) {
        included.push(key);
      }
    }
    if (included.length > 1) {
      throw new Error(`conflicting types: ${included.join(", ")}`);
    }
  }
  function consumeName(type2, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
      const keyword2 = tokens.pop().text;
      if (keyword2 !== type2) {
        throw new Error(`expected ${type2}, got ${keyword2}`);
      }
    }
    return tokens.popType("ID");
  }
  function consumeKeywords(tokens, allowed) {
    const keywords = /* @__PURE__ */ new Set();
    while (true) {
      const keyword2 = tokens.peekType("KEYWORD");
      if (keyword2 == null || allowed && !allowed.has(keyword2)) {
        break;
      }
      tokens.pop();
      if (keywords.has(keyword2)) {
        throw new Error(`duplicate keywords: ${JSON.stringify(keyword2)}`);
      }
      keywords.add(keyword2);
    }
    return Object.freeze(keywords);
  }
  function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    if (modifiers.has("view")) {
      return "view";
    }
    if (modifiers.has("pure")) {
      return "pure";
    }
    if (modifiers.has("payable")) {
      return "payable";
    }
    if (modifiers.has("nonpayable")) {
      return "nonpayable";
    }
    if (modifiers.has("constant")) {
      return "view";
    }
    return "nonpayable";
  }
  function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
  }
  function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
      tokens.pop();
      if (tokens.peekType("NUMBER")) {
        return getBigInt(tokens.pop().text);
      }
      throw new Error("invalid gas");
    }
    return null;
  }
  function consumeEoi(tokens) {
    if (tokens.length) {
      throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
    }
  }
  var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
  function verifyBasicType(type2) {
    const match = type2.match(regexType);
    assertArgument(match, "invalid type", "type", type2);
    if (type2 === "uint") {
      return "uint256";
    }
    if (type2 === "int") {
      return "int256";
    }
    if (match[2]) {
      const length2 = parseInt(match[2]);
      assertArgument(length2 !== 0 && length2 <= 32, "invalid bytes length", "type", type2);
    } else if (match[3]) {
      const size = parseInt(match[3]);
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type2);
    }
    return type2;
  }
  var _guard = {};
  var internal$1 = Symbol.for("_ethers_internal");
  var ParamTypeInternal = "_ParamTypeInternal";
  var ErrorFragmentInternal = "_ErrorInternal";
  var EventFragmentInternal = "_EventInternal";
  var ConstructorFragmentInternal = "_ConstructorInternal";
  var FallbackFragmentInternal = "_FallbackInternal";
  var FunctionFragmentInternal = "_FunctionInternal";
  var StructFragmentInternal = "_StructInternal";
  var ParamType = class {
    name;
    type;
    baseType;
    indexed;
    components;
    arrayLength;
    arrayChildren;
    constructor(guard, name, type2, baseType, indexed, components, arrayLength, arrayChildren) {
      assertPrivate(guard, _guard, "ParamType");
      Object.defineProperty(this, internal$1, { value: ParamTypeInternal });
      if (components) {
        components = Object.freeze(components.slice());
      }
      if (baseType === "array") {
        if (arrayLength == null || arrayChildren == null) {
          throw new Error("");
        }
      } else if (arrayLength != null || arrayChildren != null) {
        throw new Error("");
      }
      if (baseType === "tuple") {
        if (components == null) {
          throw new Error("");
        }
      } else if (components != null) {
        throw new Error("");
      }
      defineProperties(this, {
        name,
        type: type2,
        baseType,
        indexed,
        components,
        arrayLength,
        arrayChildren
      });
    }
    format(format2) {
      if (format2 == null) {
        format2 = "sighash";
      }
      if (format2 === "json") {
        const name = this.name || "";
        if (this.isArray()) {
          const result3 = JSON.parse(this.arrayChildren.format("json"));
          result3.name = name;
          result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
          return JSON.stringify(result3);
        }
        const result2 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name
        };
        if (typeof this.indexed === "boolean") {
          result2.indexed = this.indexed;
        }
        if (this.isTuple()) {
          result2.components = this.components.map((c3) => JSON.parse(c3.format(format2)));
        }
        return JSON.stringify(result2);
      }
      let result = "";
      if (this.isArray()) {
        result += this.arrayChildren.format(format2);
        result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
      } else {
        if (this.isTuple()) {
          result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (format2 !== "sighash") {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (format2 === "full" && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    }
    isArray() {
      return this.baseType === "array";
    }
    isTuple() {
      return this.baseType === "tuple";
    }
    isIndexable() {
      return this.indexed != null;
    }
    walk(value, process2) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        const _this = this;
        return value.map((v6) => _this.arrayChildren.walk(v6, process2));
      }
      if (this.isTuple()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid tuple value");
        }
        if (value.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        const _this = this;
        return value.map((v6, i4) => _this.components[i4].walk(v6, process2));
      }
      return process2(this.type, value);
    }
    #walkAsync(promises, value, process2, setValue) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        const childType = this.arrayChildren;
        const result2 = value.slice();
        result2.forEach((value2, index) => {
          childType.#walkAsync(promises, value2, process2, (value3) => {
            result2[index] = value3;
          });
        });
        setValue(result2);
        return;
      }
      if (this.isTuple()) {
        const components = this.components;
        let result2;
        if (Array.isArray(value)) {
          result2 = value.slice();
        } else {
          if (value == null || typeof value !== "object") {
            throw new Error("invalid tuple value");
          }
          result2 = components.map((param) => {
            if (!param.name) {
              throw new Error("cannot use object value with unnamed components");
            }
            if (!(param.name in value)) {
              throw new Error(`missing value for component ${param.name}`);
            }
            return value[param.name];
          });
        }
        if (result2.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        result2.forEach((value2, index) => {
          components[index].#walkAsync(promises, value2, process2, (value3) => {
            result2[index] = value3;
          });
        });
        setValue(result2);
        return;
      }
      const result = process2(this.type, value);
      if (result.then) {
        promises.push(async function() {
          setValue(await result);
        }());
      } else {
        setValue(result);
      }
    }
    async walkAsync(value, process2) {
      const promises = [];
      const result = [value];
      this.#walkAsync(promises, value, process2, (value2) => {
        result[0] = value2;
      });
      if (promises.length) {
        await Promise.all(promises);
      }
      return result[0];
    }
    static from(obj, allowIndexed) {
      if (ParamType.isParamType(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return ParamType.from(lex(obj), allowIndexed);
        } catch (error2) {
          assertArgument(false, "invalid param type", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        let type3 = "", baseType = "";
        let comps = null;
        if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
          baseType = "tuple";
          comps = obj.popParams().map((t) => ParamType.from(t));
          type3 = `tuple(${comps.map((c3) => c3.format()).join(",")})`;
        } else {
          type3 = verifyBasicType(obj.popType("TYPE"));
          baseType = type3;
        }
        let arrayChildren = null;
        let arrayLength = null;
        while (obj.length && obj.peekType("BRACKET")) {
          const bracket = obj.pop();
          arrayChildren = new ParamType(_guard, "", type3, baseType, null, comps, arrayLength, arrayChildren);
          arrayLength = bracket.value;
          type3 += bracket.text;
          baseType = "array";
          comps = null;
        }
        let indexed2 = null;
        const keywords = consumeKeywords(obj, KwModifiers);
        if (keywords.has("indexed")) {
          if (!allowIndexed) {
            throw new Error("");
          }
          indexed2 = true;
        }
        const name2 = obj.peekType("ID") ? obj.pop().text : "";
        if (obj.length) {
          throw new Error("leftover tokens");
        }
        return new ParamType(_guard, name2, type3, baseType, indexed2, comps, arrayLength, arrayChildren);
      }
      const name = obj.name;
      assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
      let indexed = obj.indexed;
      if (indexed != null) {
        assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
        indexed = !!indexed;
      }
      let type2 = obj.type;
      let arrayMatch = type2.match(regexArrayType);
      if (arrayMatch) {
        const arrayLength = parseInt(arrayMatch[2] || "-1");
        const arrayChildren = ParamType.from({
          type: arrayMatch[1],
          components: obj.components
        });
        return new ParamType(_guard, name || "", type2, "array", indexed, null, arrayLength, arrayChildren);
      }
      if (type2 === "tuple" || type2.startsWith("tuple(") || type2.startsWith("(")) {
        const comps = obj.components != null ? obj.components.map((c3) => ParamType.from(c3)) : null;
        const tuple = new ParamType(_guard, name || "", type2, "tuple", indexed, comps, null, null);
        return tuple;
      }
      type2 = verifyBasicType(obj.type);
      return new ParamType(_guard, name || "", type2, type2, indexed, null, null, null);
    }
    static isParamType(value) {
      return value && value[internal$1] === ParamTypeInternal;
    }
  };
  var Fragment = class {
    type;
    inputs;
    constructor(guard, type2, inputs) {
      assertPrivate(guard, _guard, "Fragment");
      inputs = Object.freeze(inputs.slice());
      defineProperties(this, { type: type2, inputs });
    }
    static from(obj) {
      if (typeof obj === "string") {
        try {
          Fragment.from(JSON.parse(obj));
        } catch (e7) {
        }
        return Fragment.from(lex(obj));
      }
      if (obj instanceof TokenString) {
        const type2 = obj.peekKeyword(KwTypes);
        switch (type2) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
      } else if (typeof obj === "object") {
        switch (obj.type) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
        assert2(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
          operation: "Fragment.from"
        });
      }
      assertArgument(false, "unsupported frgament object", "obj", obj);
    }
    static isConstructor(value) {
      return ConstructorFragment.isFragment(value);
    }
    static isError(value) {
      return ErrorFragment.isFragment(value);
    }
    static isEvent(value) {
      return EventFragment.isFragment(value);
    }
    static isFunction(value) {
      return FunctionFragment.isFragment(value);
    }
    static isStruct(value) {
      return StructFragment.isFragment(value);
    }
  };
  var NamedFragment = class extends Fragment {
    name;
    constructor(guard, type2, name, inputs) {
      super(guard, type2, inputs);
      assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
      inputs = Object.freeze(inputs.slice());
      defineProperties(this, { name });
    }
  };
  function joinParams(format2, params) {
    return "(" + params.map((p6) => p6.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
  }
  var ErrorFragment = class extends NamedFragment {
    constructor(guard, name, inputs) {
      super(guard, "error", name, inputs);
      Object.defineProperty(this, internal$1, { value: ErrorFragmentInternal });
    }
    get selector() {
      return id2(this.format("sighash")).substring(0, 10);
    }
    format(format2) {
      if (format2 == null) {
        format2 = "sighash";
      }
      if (format2 === "json") {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
        });
      }
      const result = [];
      if (format2 !== "sighash") {
        result.push("error");
      }
      result.push(this.name + joinParams(format2, this.inputs));
      return result.join(" ");
    }
    static from(obj) {
      if (ErrorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return ErrorFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        const name = consumeName("error", obj);
        const inputs = consumeParams(obj);
        consumeEoi(obj);
        return new ErrorFragment(_guard, name, inputs);
      }
      return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    static isFragment(value) {
      return value && value[internal$1] === ErrorFragmentInternal;
    }
  };
  var EventFragment = class extends NamedFragment {
    anonymous;
    constructor(guard, name, inputs, anonymous) {
      super(guard, "event", name, inputs);
      Object.defineProperty(this, internal$1, { value: EventFragmentInternal });
      defineProperties(this, { anonymous });
    }
    get topicHash() {
      return id2(this.format("sighash"));
    }
    format(format2) {
      if (format2 == null) {
        format2 = "sighash";
      }
      if (format2 === "json") {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2)))
        });
      }
      const result = [];
      if (format2 !== "sighash") {
        result.push("event");
      }
      result.push(this.name + joinParams(format2, this.inputs));
      if (format2 !== "sighash" && this.anonymous) {
        result.push("anonymous");
      }
      return result.join(" ");
    }
    static getTopicHash(name, params) {
      params = (params || []).map((p6) => ParamType.from(p6));
      const fragment = new EventFragment(_guard, name, params, false);
      return fragment.topicHash;
    }
    static from(obj) {
      if (EventFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return EventFragment.from(lex(obj));
        } catch (error2) {
          assertArgument(false, "invalid event fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        const name = consumeName("event", obj);
        const inputs = consumeParams(obj, true);
        const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
        consumeEoi(obj);
        return new EventFragment(_guard, name, inputs, anonymous);
      }
      return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p6) => ParamType.from(p6, true)) : [], !!obj.anonymous);
    }
    static isFragment(value) {
      return value && value[internal$1] === EventFragmentInternal;
    }
  };
  var ConstructorFragment = class extends Fragment {
    payable;
    gas;
    constructor(guard, type2, inputs, payable, gas) {
      super(guard, type2, inputs);
      Object.defineProperty(this, internal$1, { value: ConstructorFragmentInternal });
      defineProperties(this, { payable, gas });
    }
    format(format2) {
      assert2(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
      if (format2 === "json") {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.payable ? "payable" : "undefined",
          payable: this.payable,
          gas: this.gas != null ? this.gas : void 0,
          inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2)))
        });
      }
      const result = [`constructor${joinParams(format2, this.inputs)}`];
      if (this.payable) {
        result.push("payable");
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
      return result.join(" ");
    }
    static from(obj) {
      if (ConstructorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return ConstructorFragment.from(lex(obj));
        } catch (error2) {
          assertArgument(false, "invalid constuctor fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        consumeKeywords(obj, setify(["constructor"]));
        const inputs = consumeParams(obj);
        const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
        const gas = consumeGas(obj);
        consumeEoi(obj);
        return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
      }
      return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
    }
    static isFragment(value) {
      return value && value[internal$1] === ConstructorFragmentInternal;
    }
  };
  var FallbackFragment = class extends Fragment {
    payable;
    constructor(guard, inputs, payable) {
      super(guard, "fallback", inputs);
      Object.defineProperty(this, internal$1, { value: FallbackFragmentInternal });
      defineProperties(this, { payable });
    }
    format(format2) {
      const type2 = this.inputs.length === 0 ? "receive" : "fallback";
      if (format2 === "json") {
        const stateMutability = this.payable ? "payable" : "nonpayable";
        return JSON.stringify({ type: type2, stateMutability });
      }
      return `${type2}()${this.payable ? " payable" : ""}`;
    }
    static from(obj) {
      if (FallbackFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return FallbackFragment.from(lex(obj));
        } catch (error2) {
          assertArgument(false, "invalid fallback fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        const errorObj = obj.toString();
        const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
        assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
        const type2 = obj.popKeyword(setify(["fallback", "receive"]));
        if (type2 === "receive") {
          const inputs2 = consumeParams(obj);
          assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
          consumeKeywords(obj, setify(["payable"]));
          consumeEoi(obj);
          return new FallbackFragment(_guard, [], true);
        }
        let inputs = consumeParams(obj);
        if (inputs.length) {
          assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i4) => i4.format("minimal")).join(", "));
        } else {
          inputs = [ParamType.from("bytes")];
        }
        const mutability = consumeMutability(obj);
        assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          const outputs = consumeParams(obj);
          assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i4) => i4.format("minimal")).join(", "));
        }
        consumeEoi(obj);
        return new FallbackFragment(_guard, inputs, mutability === "payable");
      }
      if (obj.type === "receive") {
        return new FallbackFragment(_guard, [], true);
      }
      if (obj.type === "fallback") {
        const inputs = [ParamType.from("bytes")];
        const payable = obj.stateMutability === "payable";
        return new FallbackFragment(_guard, inputs, payable);
      }
      assertArgument(false, "invalid fallback description", "obj", obj);
    }
    static isFragment(value) {
      return value && value[internal$1] === FallbackFragmentInternal;
    }
  };
  var FunctionFragment = class extends NamedFragment {
    constant;
    outputs;
    stateMutability;
    payable;
    gas;
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
      super(guard, "function", name, inputs);
      Object.defineProperty(this, internal$1, { value: FunctionFragmentInternal });
      outputs = Object.freeze(outputs.slice());
      const constant = stateMutability === "view" || stateMutability === "pure";
      const payable = stateMutability === "payable";
      defineProperties(this, { constant, gas, outputs, payable, stateMutability });
    }
    get selector() {
      return id2(this.format("sighash")).substring(0, 10);
    }
    format(format2) {
      if (format2 == null) {
        format2 = "sighash";
      }
      if (format2 === "json") {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
          payable: this.payable,
          gas: this.gas != null ? this.gas : void 0,
          inputs: this.inputs.map((i4) => JSON.parse(i4.format(format2))),
          outputs: this.outputs.map((o4) => JSON.parse(o4.format(format2)))
        });
      }
      const result = [];
      if (format2 !== "sighash") {
        result.push("function");
      }
      result.push(this.name + joinParams(format2, this.inputs));
      if (format2 !== "sighash") {
        if (this.stateMutability !== "nonpayable") {
          result.push(this.stateMutability);
        }
        if (this.outputs && this.outputs.length) {
          result.push("returns");
          result.push(joinParams(format2, this.outputs));
        }
        if (this.gas != null) {
          result.push(`@${this.gas.toString()}`);
        }
      }
      return result.join(" ");
    }
    static getSelector(name, params) {
      params = (params || []).map((p6) => ParamType.from(p6));
      const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
      return fragment.selector;
    }
    static from(obj) {
      if (FunctionFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return FunctionFragment.from(lex(obj));
        } catch (error2) {
          assertArgument(false, "invalid function fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        const name = consumeName("function", obj);
        const inputs = consumeParams(obj);
        const mutability = consumeMutability(obj);
        let outputs = [];
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          outputs = consumeParams(obj);
        }
        const gas = consumeGas(obj);
        consumeEoi(obj);
        return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
      }
      let stateMutability = obj.stateMutability;
      if (stateMutability == null) {
        stateMutability = "payable";
        if (typeof obj.constant === "boolean") {
          stateMutability = "view";
          if (!obj.constant) {
            stateMutability = "payable";
            if (typeof obj.payable === "boolean" && !obj.payable) {
              stateMutability = "nonpayable";
            }
          }
        } else if (typeof obj.payable === "boolean" && !obj.payable) {
          stateMutability = "nonpayable";
        }
      }
      return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
    }
    static isFragment(value) {
      return value && value[internal$1] === FunctionFragmentInternal;
    }
  };
  var StructFragment = class extends NamedFragment {
    constructor(guard, name, inputs) {
      super(guard, "struct", name, inputs);
      Object.defineProperty(this, internal$1, { value: StructFragmentInternal });
    }
    format() {
      throw new Error("@TODO");
    }
    static from(obj) {
      if (typeof obj === "string") {
        try {
          return StructFragment.from(lex(obj));
        } catch (error2) {
          assertArgument(false, "invalid struct fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        const name = consumeName("struct", obj);
        const inputs = consumeParams(obj);
        consumeEoi(obj);
        return new StructFragment(_guard, name, inputs);
      }
      return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    static isFragment(value) {
      return value && value[internal$1] === StructFragmentInternal;
    }
  };
  var PanicReasons$1 = /* @__PURE__ */ new Map();
  PanicReasons$1.set(0, "GENERIC_PANIC");
  PanicReasons$1.set(1, "ASSERT_FALSE");
  PanicReasons$1.set(17, "OVERFLOW");
  PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
  PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
  PanicReasons$1.set(34, "BAD_STORAGE_DATA");
  PanicReasons$1.set(49, "STACK_UNDERFLOW");
  PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
  PanicReasons$1.set(65, "OUT_OF_MEMORY");
  PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  var defaultCoder = null;
  var defaultMaxInflation = 1024;
  function getBuiltinCallException(action, tx, data, abiCoder) {
    let message = "missing revert data";
    let reason = null;
    const invocation = null;
    let revert = null;
    if (data) {
      message = "execution reverted";
      const bytes2 = getBytes(data);
      data = hexlify(data);
      if (bytes2.length === 0) {
        message += " (no data present; likely require(false) occurred";
        reason = "require(false)";
      } else if (bytes2.length % 32 !== 4) {
        message += " (could not decode reason; invalid data length)";
      } else if (hexlify(bytes2.slice(0, 4)) === "0x08c379a0") {
        try {
          reason = abiCoder.decode(["string"], bytes2.slice(4))[0];
          revert = {
            signature: "Error(string)",
            name: "Error",
            args: [reason]
          };
          message += `: ${JSON.stringify(reason)}`;
        } catch (error2) {
          message += " (could not decode reason; invalid string data)";
        }
      } else if (hexlify(bytes2.slice(0, 4)) === "0x4e487b71") {
        try {
          const code2 = Number(abiCoder.decode(["uint256"], bytes2.slice(4))[0]);
          revert = {
            signature: "Panic(uint256)",
            name: "Panic",
            args: [code2]
          };
          reason = `Panic due to ${PanicReasons$1.get(code2) || "UNKNOWN"}(${code2})`;
          message += `: ${reason}`;
        } catch (error2) {
          message += " (could not decode panic code)";
        }
      } else {
        message += " (unknown custom error)";
      }
    }
    const transaction = {
      to: tx.to ? getAddress(tx.to) : null,
      data: tx.data || "0x"
    };
    if (tx.from) {
      transaction.from = getAddress(tx.from);
    }
    return makeError(message, "CALL_EXCEPTION", {
      action,
      data,
      reason,
      transaction,
      invocation,
      revert
    });
  }
  var AbiCoder = class {
    #getCoder(param) {
      if (param.isArray()) {
        return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
      }
      if (param.isTuple()) {
        return new TupleCoder(param.components.map((c3) => this.#getCoder(c3)), param.name);
      }
      switch (param.baseType) {
        case "address":
          return new AddressCoder(param.name);
        case "bool":
          return new BooleanCoder(param.name);
        case "string":
          return new StringCoder(param.name);
        case "bytes":
          return new BytesCoder(param.name);
        case "":
          return new NullCoder(param.name);
      }
      let match = param.type.match(paramTypeNumber);
      if (match) {
        let size = parseInt(match[2] || "256");
        assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
        return new NumberCoder(size / 8, match[1] === "int", param.name);
      }
      match = param.type.match(paramTypeBytes);
      if (match) {
        let size = parseInt(match[1]);
        assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
        return new FixedBytesCoder(size, param.name);
      }
      assertArgument(false, "invalid type", "type", param.type);
    }
    getDefaultValue(types2) {
      const coders = types2.map((type2) => this.#getCoder(ParamType.from(type2)));
      const coder = new TupleCoder(coders, "_");
      return coder.defaultValue();
    }
    encode(types2, values) {
      assertArgumentCount(values.length, types2.length, "types/values length mismatch");
      const coders = types2.map((type2) => this.#getCoder(ParamType.from(type2)));
      const coder = new TupleCoder(coders, "_");
      const writer = new Writer();
      coder.encode(writer, values);
      return writer.data;
    }
    decode(types2, data, loose) {
      const coders = types2.map((type2) => this.#getCoder(ParamType.from(type2)));
      const coder = new TupleCoder(coders, "_");
      return coder.decode(new Reader(data, loose, defaultMaxInflation));
    }
    static _setDefaultMaxInflation(value) {
      assertArgument(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
      defaultMaxInflation = value;
    }
    static defaultAbiCoder() {
      if (defaultCoder == null) {
        defaultCoder = new AbiCoder();
      }
      return defaultCoder;
    }
    static getBuiltinCallException(action, tx, data) {
      return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
  };
  var LogDescription = class {
    fragment;
    name;
    signature;
    topic;
    args;
    constructor(fragment, topic, args) {
      const name = fragment.name, signature = fragment.format();
      defineProperties(this, {
        fragment,
        name,
        signature,
        topic,
        args
      });
    }
  };
  var TransactionDescription = class {
    fragment;
    name;
    args;
    signature;
    selector;
    value;
    constructor(fragment, selector, args, value) {
      const name = fragment.name, signature = fragment.format();
      defineProperties(this, {
        fragment,
        name,
        args,
        signature,
        selector,
        value
      });
    }
  };
  var ErrorDescription = class {
    fragment;
    name;
    args;
    signature;
    selector;
    constructor(fragment, selector, args) {
      const name = fragment.name, signature = fragment.format();
      defineProperties(this, {
        fragment,
        name,
        args,
        signature,
        selector
      });
    }
  };
  var Indexed = class {
    hash;
    _isIndexed;
    static isIndexed(value) {
      return !!(value && value._isIndexed);
    }
    constructor(hash2) {
      defineProperties(this, { hash: hash2, _isIndexed: true });
    }
  };
  var PanicReasons = {
    "0": "generic panic",
    "1": "assert(false)",
    "17": "arithmetic overflow",
    "18": "division or modulo by zero",
    "33": "enum overflow",
    "34": "invalid encoded storage byte array accessed",
    "49": "out-of-bounds array access; popping on an empty array",
    "50": "out-of-bounds access of an array or bytesN",
    "65": "out of memory",
    "81": "uninitialized function"
  };
  var BuiltinErrors = {
    "0x08c379a0": {
      signature: "Error(string)",
      name: "Error",
      inputs: ["string"],
      reason: (message) => {
        return `reverted with reason string ${JSON.stringify(message)}`;
      }
    },
    "0x4e487b71": {
      signature: "Panic(uint256)",
      name: "Panic",
      inputs: ["uint256"],
      reason: (code2) => {
        let reason = "unknown panic code";
        if (code2 >= 0 && code2 <= 255 && PanicReasons[code2.toString()]) {
          reason = PanicReasons[code2.toString()];
        }
        return `reverted with panic code 0x${code2.toString(16)} (${reason})`;
      }
    }
  };
  var Interface = class {
    fragments;
    deploy;
    fallback;
    receive;
    #errors;
    #events;
    #functions;
    #abiCoder;
    constructor(fragments) {
      let abi = [];
      if (typeof fragments === "string") {
        abi = JSON.parse(fragments);
      } else {
        abi = fragments;
      }
      this.#functions = /* @__PURE__ */ new Map();
      this.#errors = /* @__PURE__ */ new Map();
      this.#events = /* @__PURE__ */ new Map();
      const frags = [];
      for (const a4 of abi) {
        try {
          frags.push(Fragment.from(a4));
        } catch (error2) {
          console.log(`[Warning] Invalid Fragment ${JSON.stringify(a4)}:`, error2.message);
        }
      }
      defineProperties(this, {
        fragments: Object.freeze(frags)
      });
      let fallback = null;
      let receive = false;
      this.#abiCoder = this.getAbiCoder();
      this.fragments.forEach((fragment, index) => {
        let bucket;
        switch (fragment.type) {
          case "constructor":
            if (this.deploy) {
              console.log("duplicate definition - constructor");
              return;
            }
            defineProperties(this, { deploy: fragment });
            return;
          case "fallback":
            if (fragment.inputs.length === 0) {
              receive = true;
            } else {
              assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
              fallback = fragment;
              receive = fallback.payable;
            }
            return;
          case "function":
            bucket = this.#functions;
            break;
          case "event":
            bucket = this.#events;
            break;
          case "error":
            bucket = this.#errors;
            break;
          default:
            return;
        }
        const signature = fragment.format();
        if (bucket.has(signature)) {
          return;
        }
        bucket.set(signature, fragment);
      });
      if (!this.deploy) {
        defineProperties(this, {
          deploy: ConstructorFragment.from("constructor()")
        });
      }
      defineProperties(this, { fallback, receive });
    }
    format(minimal) {
      const format2 = minimal ? "minimal" : "full";
      const abi = this.fragments.map((f5) => f5.format(format2));
      return abi;
    }
    formatJson() {
      const abi = this.fragments.map((f5) => f5.format("json"));
      return JSON.stringify(abi.map((j5) => JSON.parse(j5)));
    }
    getAbiCoder() {
      return AbiCoder.defaultAbiCoder();
    }
    #getFunction(key, values, forceUnique) {
      if (isHexString(key)) {
        const selector = key.toLowerCase();
        for (const fragment of this.#functions.values()) {
          if (selector === fragment.selector) {
            return fragment;
          }
        }
        return null;
      }
      if (key.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of this.#functions) {
          if (name.split("(")[0] === key) {
            matching.push(fragment);
          }
        }
        if (values) {
          const lastValue = values.length > 0 ? values[values.length - 1] : null;
          let valueLength = values.length;
          let allowOptions = true;
          if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
            allowOptions = false;
            valueLength--;
          }
          for (let i4 = matching.length - 1; i4 >= 0; i4--) {
            const inputs = matching[i4].inputs.length;
            if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
              matching.splice(i4, 1);
            }
          }
          for (let i4 = matching.length - 1; i4 >= 0; i4--) {
            const inputs = matching[i4].inputs;
            for (let j5 = 0; j5 < values.length; j5++) {
              if (!Typed.isTyped(values[j5])) {
                continue;
              }
              if (j5 >= inputs.length) {
                if (values[j5].type === "overrides") {
                  continue;
                }
                matching.splice(i4, 1);
                break;
              }
              if (values[j5].type !== inputs[j5].baseType) {
                matching.splice(i4, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
          const lastArg = values[values.length - 1];
          if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
            matching.splice(0, 1);
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m5) => JSON.stringify(m5.format())).join(", ");
          assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
        }
        return matching[0];
      }
      const result = this.#functions.get(FunctionFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    }
    getFunctionName(key) {
      const fragment = this.#getFunction(key, null, false);
      assertArgument(fragment, "no matching function", "key", key);
      return fragment.name;
    }
    hasFunction(key) {
      return !!this.#getFunction(key, null, false);
    }
    getFunction(key, values) {
      return this.#getFunction(key, values || null, true);
    }
    forEachFunction(callback) {
      const names = Array.from(this.#functions.keys());
      names.sort((a4, b7) => a4.localeCompare(b7));
      for (let i4 = 0; i4 < names.length; i4++) {
        const name = names[i4];
        callback(this.#functions.get(name), i4);
      }
    }
    #getEvent(key, values, forceUnique) {
      if (isHexString(key)) {
        const eventTopic = key.toLowerCase();
        for (const fragment of this.#events.values()) {
          if (eventTopic === fragment.topicHash) {
            return fragment;
          }
        }
        return null;
      }
      if (key.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of this.#events) {
          if (name.split("(")[0] === key) {
            matching.push(fragment);
          }
        }
        if (values) {
          for (let i4 = matching.length - 1; i4 >= 0; i4--) {
            if (matching[i4].inputs.length < values.length) {
              matching.splice(i4, 1);
            }
          }
          for (let i4 = matching.length - 1; i4 >= 0; i4--) {
            const inputs = matching[i4].inputs;
            for (let j5 = 0; j5 < values.length; j5++) {
              if (!Typed.isTyped(values[j5])) {
                continue;
              }
              if (values[j5].type !== inputs[j5].baseType) {
                matching.splice(i4, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m5) => JSON.stringify(m5.format())).join(", ");
          assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
        }
        return matching[0];
      }
      const result = this.#events.get(EventFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    }
    getEventName(key) {
      const fragment = this.#getEvent(key, null, false);
      assertArgument(fragment, "no matching event", "key", key);
      return fragment.name;
    }
    hasEvent(key) {
      return !!this.#getEvent(key, null, false);
    }
    getEvent(key, values) {
      return this.#getEvent(key, values || null, true);
    }
    forEachEvent(callback) {
      const names = Array.from(this.#events.keys());
      names.sort((a4, b7) => a4.localeCompare(b7));
      for (let i4 = 0; i4 < names.length; i4++) {
        const name = names[i4];
        callback(this.#events.get(name), i4);
      }
    }
    getError(key, values) {
      if (isHexString(key)) {
        const selector = key.toLowerCase();
        if (BuiltinErrors[selector]) {
          return ErrorFragment.from(BuiltinErrors[selector].signature);
        }
        for (const fragment of this.#errors.values()) {
          if (selector === fragment.selector) {
            return fragment;
          }
        }
        return null;
      }
      if (key.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of this.#errors) {
          if (name.split("(")[0] === key) {
            matching.push(fragment);
          }
        }
        if (matching.length === 0) {
          if (key === "Error") {
            return ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic") {
            return ErrorFragment.from("error Panic(uint256)");
          }
          return null;
        } else if (matching.length > 1) {
          const matchStr = matching.map((m5) => JSON.stringify(m5.format())).join(", ");
          assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
        }
        return matching[0];
      }
      key = ErrorFragment.from(key).format();
      if (key === "Error(string)") {
        return ErrorFragment.from("error Error(string)");
      }
      if (key === "Panic(uint256)") {
        return ErrorFragment.from("error Panic(uint256)");
      }
      const result = this.#errors.get(key);
      if (result) {
        return result;
      }
      return null;
    }
    forEachError(callback) {
      const names = Array.from(this.#errors.keys());
      names.sort((a4, b7) => a4.localeCompare(b7));
      for (let i4 = 0; i4 < names.length; i4++) {
        const name = names[i4];
        callback(this.#errors.get(name), i4);
      }
    }
    _decodeParams(params, data) {
      return this.#abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
      return this.#abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
      if (typeof fragment === "string") {
        const f5 = this.getError(fragment);
        assertArgument(f5, "unknown error", "fragment", fragment);
        fragment = f5;
      }
      assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
      return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    encodeErrorResult(fragment, values) {
      if (typeof fragment === "string") {
        const f5 = this.getError(fragment);
        assertArgument(f5, "unknown error", "fragment", fragment);
        fragment = f5;
      }
      return concat([
        fragment.selector,
        this._encodeParams(fragment.inputs, values || [])
      ]);
    }
    decodeFunctionData(fragment, data) {
      if (typeof fragment === "string") {
        const f5 = this.getFunction(fragment);
        assertArgument(f5, "unknown function", "fragment", fragment);
        fragment = f5;
      }
      assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
      return this._decodeParams(fragment.inputs, dataSlice(data, 4));
    }
    encodeFunctionData(fragment, values) {
      if (typeof fragment === "string") {
        const f5 = this.getFunction(fragment);
        assertArgument(f5, "unknown function", "fragment", fragment);
        fragment = f5;
      }
      return concat([
        fragment.selector,
        this._encodeParams(fragment.inputs, values || [])
      ]);
    }
    decodeFunctionResult(fragment, data) {
      if (typeof fragment === "string") {
        const f5 = this.getFunction(fragment);
        assertArgument(f5, "unknown function", "fragment", fragment);
        fragment = f5;
      }
      let message = "invalid length for result data";
      const bytes2 = getBytesCopy(data);
      if (bytes2.length % 32 === 0) {
        try {
          return this.#abiCoder.decode(fragment.outputs, bytes2);
        } catch (error2) {
          message = "could not decode result data";
        }
      }
      assert2(false, message, "BAD_DATA", {
        value: hexlify(bytes2),
        info: { method: fragment.name, signature: fragment.format() }
      });
    }
    makeError(_data, tx) {
      const data = getBytes(_data, "data");
      const error2 = AbiCoder.getBuiltinCallException("call", tx, data);
      const customPrefix = "execution reverted (unknown custom error)";
      if (error2.message.startsWith(customPrefix)) {
        const selector = hexlify(data.slice(0, 4));
        const ef2 = this.getError(selector);
        if (ef2) {
          try {
            const args = this.#abiCoder.decode(ef2.inputs, data.slice(4));
            error2.revert = {
              name: ef2.name,
              signature: ef2.format(),
              args
            };
            error2.reason = error2.revert.signature;
            error2.message = `execution reverted: ${error2.reason}`;
          } catch (e7) {
            error2.message = `execution reverted (coult not decode custom error)`;
          }
        }
      }
      const parsed = this.parseTransaction(tx);
      if (parsed) {
        error2.invocation = {
          method: parsed.name,
          signature: parsed.signature,
          args: parsed.args
        };
      }
      return error2;
    }
    encodeFunctionResult(fragment, values) {
      if (typeof fragment === "string") {
        const f5 = this.getFunction(fragment);
        assertArgument(f5, "unknown function", "fragment", fragment);
        fragment = f5;
      }
      return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
    }
    encodeFilterTopics(fragment, values) {
      if (typeof fragment === "string") {
        const f5 = this.getEvent(fragment);
        assertArgument(f5, "unknown event", "eventFragment", fragment);
        fragment = f5;
      }
      assert2(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
      const topics = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      const encodeTopic = (param, value) => {
        if (param.type === "string") {
          return id2(value);
        } else if (param.type === "bytes") {
          return keccak2562(hexlify(value));
        }
        if (param.type === "bool" && typeof value === "boolean") {
          value = value ? "0x01" : "0x00";
        } else if (param.type.match(/^u?int/)) {
          value = toBeHex(value);
        } else if (param.type.match(/^bytes/)) {
          value = zeroPadBytes(value, 32);
        } else if (param.type === "address") {
          this.#abiCoder.encode(["address"], [value]);
        }
        return zeroPadValue(hexlify(value), 32);
      };
      values.forEach((value, index) => {
        const param = fragment.inputs[index];
        if (!param.indexed) {
          assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map((value2) => encodeTopic(param, value2)));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    }
    encodeEventLog(fragment, values) {
      if (typeof fragment === "string") {
        const f5 = this.getEvent(fragment);
        assertArgument(f5, "unknown event", "eventFragment", fragment);
        fragment = f5;
      }
      const topics = [];
      const dataTypes = [];
      const dataValues = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
      fragment.inputs.forEach((param, index) => {
        const value = values[index];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push(id2(value));
          } else if (param.type === "bytes") {
            topics.push(keccak2562(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            throw new Error("not implemented");
          } else {
            topics.push(this.#abiCoder.encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: this.#abiCoder.encode(dataTypes, dataValues),
        topics
      };
    }
    decodeEventLog(fragment, data, topics) {
      if (typeof fragment === "string") {
        const f5 = this.getEvent(fragment);
        assertArgument(f5, "unknown event", "eventFragment", fragment);
        fragment = f5;
      }
      if (topics != null && !fragment.anonymous) {
        const eventTopic = fragment.topicHash;
        assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
        topics = topics.slice(1);
      }
      const indexed = [];
      const nonIndexed = [];
      const dynamic2 = [];
      fragment.inputs.forEach((param, index) => {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
            dynamic2.push(true);
          } else {
            indexed.push(param);
            dynamic2.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic2.push(false);
        }
      });
      const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
      const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);
      const values = [];
      const keys = [];
      let nonIndexedIndex = 0, indexedIndex = 0;
      fragment.inputs.forEach((param, index) => {
        let value = null;
        if (param.indexed) {
          if (resultIndexed == null) {
            value = new Indexed(null);
          } else if (dynamic2[index]) {
            value = new Indexed(resultIndexed[indexedIndex++]);
          } else {
            try {
              value = resultIndexed[indexedIndex++];
            } catch (error2) {
              value = error2;
            }
          }
        } else {
          try {
            value = resultNonIndexed[nonIndexedIndex++];
          } catch (error2) {
            value = error2;
          }
        }
        values.push(value);
        keys.push(param.name || null);
      });
      return Result.fromItems(values, keys);
    }
    parseTransaction(tx) {
      const data = getBytes(tx.data, "tx.data");
      const value = getBigInt(tx.value != null ? tx.value : 0, "tx.value");
      const fragment = this.getFunction(hexlify(data.slice(0, 4)));
      if (!fragment) {
        return null;
      }
      const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
      return new TransactionDescription(fragment, fragment.selector, args, value);
    }
    parseCallResult(data) {
      throw new Error("@TODO");
    }
    parseLog(log) {
      const fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    parseError(data) {
      const hexData = hexlify(data);
      const fragment = this.getError(dataSlice(hexData, 0, 4));
      if (!fragment) {
        return null;
      }
      const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
      return new ErrorDescription(fragment, fragment.selector, args);
    }
    static from(value) {
      if (value instanceof Interface) {
        return value;
      }
      if (typeof value === "string") {
        return new Interface(JSON.parse(value));
      }
      if (typeof value.formatJson === "function") {
        return new Interface(value.formatJson());
      }
      if (typeof value.format === "function") {
        return new Interface(value.format("json"));
      }
      return new Interface(value);
    }
  };
  var BN_0$2 = BigInt(0);
  function getValue(value) {
    if (value == null) {
      return null;
    }
    return value;
  }
  function toJson(value) {
    if (value == null) {
      return null;
    }
    return value.toString();
  }
  var FeeData = class {
    gasPrice;
    maxFeePerGas;
    maxPriorityFeePerGas;
    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
      defineProperties(this, {
        gasPrice: getValue(gasPrice),
        maxFeePerGas: getValue(maxFeePerGas),
        maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
      });
    }
    toJSON() {
      const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
      return {
        _type: "FeeData",
        gasPrice: toJson(gasPrice),
        maxFeePerGas: toJson(maxFeePerGas),
        maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
      };
    }
  };
  function copyRequest(req) {
    const result = {};
    if (req.to) {
      result.to = req.to;
    }
    if (req.from) {
      result.from = req.from;
    }
    if (req.data) {
      result.data = hexlify(req.data);
    }
    const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
    for (const key of bigIntKeys) {
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = getBigInt(req[key], `request.${key}`);
    }
    const numberKeys = "type,nonce".split(/,/);
    for (const key of numberKeys) {
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = getNumber(req[key], `request.${key}`);
    }
    if (req.accessList) {
      result.accessList = accessListify(req.accessList);
    }
    if ("blockTag" in req) {
      result.blockTag = req.blockTag;
    }
    if ("enableCcipRead" in req) {
      result.enableCcipRead = !!req.enableCcipRead;
    }
    if ("customData" in req) {
      result.customData = req.customData;
    }
    if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
      result.blobVersionedHashes = req.blobVersionedHashes.slice();
    }
    if ("kzg" in req) {
      result.kzg = req.kzg;
    }
    if ("blobs" in req && req.blobs) {
      result.blobs = req.blobs.map((b7) => {
        if (isBytesLike(b7)) {
          return hexlify(b7);
        }
        return Object.assign({}, b7);
      });
    }
    return result;
  }
  var Block = class {
    provider;
    number;
    hash;
    timestamp;
    parentHash;
    parentBeaconBlockRoot;
    nonce;
    difficulty;
    gasLimit;
    gasUsed;
    stateRoot;
    receiptsRoot;
    blobGasUsed;
    excessBlobGas;
    miner;
    prevRandao;
    extraData;
    baseFeePerGas;
    #transactions;
    constructor(block, provider) {
      this.#transactions = block.transactions.map((tx) => {
        if (typeof tx !== "string") {
          return new TransactionResponse(tx, provider);
        }
        return tx;
      });
      defineProperties(this, {
        provider,
        hash: getValue(block.hash),
        number: block.number,
        timestamp: block.timestamp,
        parentHash: block.parentHash,
        parentBeaconBlockRoot: block.parentBeaconBlockRoot,
        nonce: block.nonce,
        difficulty: block.difficulty,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        blobGasUsed: block.blobGasUsed,
        excessBlobGas: block.excessBlobGas,
        miner: block.miner,
        prevRandao: getValue(block.prevRandao),
        extraData: block.extraData,
        baseFeePerGas: getValue(block.baseFeePerGas),
        stateRoot: block.stateRoot,
        receiptsRoot: block.receiptsRoot
      });
    }
    get transactions() {
      return this.#transactions.map((tx) => {
        if (typeof tx === "string") {
          return tx;
        }
        return tx.hash;
      });
    }
    get prefetchedTransactions() {
      const txs = this.#transactions.slice();
      if (txs.length === 0) {
        return [];
      }
      assert2(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
        operation: "transactionResponses()"
      });
      return txs;
    }
    toJSON() {
      const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash2, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
      return {
        _type: "Block",
        baseFeePerGas: toJson(baseFeePerGas),
        difficulty: toJson(difficulty),
        extraData,
        gasLimit: toJson(gasLimit),
        gasUsed: toJson(gasUsed),
        blobGasUsed: toJson(this.blobGasUsed),
        excessBlobGas: toJson(this.excessBlobGas),
        hash: hash2,
        miner,
        prevRandao,
        nonce,
        number: number2,
        parentHash,
        timestamp,
        parentBeaconBlockRoot,
        stateRoot,
        receiptsRoot,
        transactions
      };
    }
    [Symbol.iterator]() {
      let index = 0;
      const txs = this.transactions;
      return {
        next: () => {
          if (index < this.length) {
            return {
              value: txs[index++],
              done: false
            };
          }
          return { value: void 0, done: true };
        }
      };
    }
    get length() {
      return this.#transactions.length;
    }
    get date() {
      if (this.timestamp == null) {
        return null;
      }
      return new Date(this.timestamp * 1e3);
    }
    async getTransaction(indexOrHash) {
      let tx = void 0;
      if (typeof indexOrHash === "number") {
        tx = this.#transactions[indexOrHash];
      } else {
        const hash2 = indexOrHash.toLowerCase();
        for (const v6 of this.#transactions) {
          if (typeof v6 === "string") {
            if (v6 !== hash2) {
              continue;
            }
            tx = v6;
            break;
          } else {
            if (v6.hash === hash2) {
              continue;
            }
            tx = v6;
            break;
          }
        }
      }
      if (tx == null) {
        throw new Error("no such tx");
      }
      if (typeof tx === "string") {
        return await this.provider.getTransaction(tx);
      } else {
        return tx;
      }
    }
    getPrefetchedTransaction(indexOrHash) {
      const txs = this.prefetchedTransactions;
      if (typeof indexOrHash === "number") {
        return txs[indexOrHash];
      }
      indexOrHash = indexOrHash.toLowerCase();
      for (const tx of txs) {
        if (tx.hash === indexOrHash) {
          return tx;
        }
      }
      assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
    }
    isMined() {
      return !!this.hash;
    }
    isLondon() {
      return !!this.baseFeePerGas;
    }
    orphanedEvent() {
      if (!this.isMined()) {
        throw new Error("");
      }
      return createOrphanedBlockFilter(this);
    }
  };
  var Log = class {
    provider;
    transactionHash;
    blockHash;
    blockNumber;
    removed;
    address;
    data;
    topics;
    index;
    transactionIndex;
    constructor(log, provider) {
      this.provider = provider;
      const topics = Object.freeze(log.topics.slice());
      defineProperties(this, {
        transactionHash: log.transactionHash,
        blockHash: log.blockHash,
        blockNumber: log.blockNumber,
        removed: log.removed,
        address: log.address,
        data: log.data,
        topics,
        index: log.index,
        transactionIndex: log.transactionIndex
      });
    }
    toJSON() {
      const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;
      return {
        _type: "log",
        address,
        blockHash,
        blockNumber,
        data,
        index,
        removed,
        topics,
        transactionHash,
        transactionIndex
      };
    }
    async getBlock() {
      const block = await this.provider.getBlock(this.blockHash);
      assert2(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
      return block;
    }
    async getTransaction() {
      const tx = await this.provider.getTransaction(this.transactionHash);
      assert2(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
      return tx;
    }
    async getTransactionReceipt() {
      const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
      assert2(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
      return receipt;
    }
    removedEvent() {
      return createRemovedLogFilter(this);
    }
  };
  var TransactionReceipt = class {
    provider;
    to;
    from;
    contractAddress;
    hash;
    index;
    blockHash;
    blockNumber;
    logsBloom;
    gasUsed;
    blobGasUsed;
    cumulativeGasUsed;
    gasPrice;
    blobGasPrice;
    type;
    status;
    root;
    #logs;
    constructor(tx, provider) {
      this.#logs = Object.freeze(tx.logs.map((log) => {
        return new Log(log, provider);
      }));
      let gasPrice = BN_0$2;
      if (tx.effectiveGasPrice != null) {
        gasPrice = tx.effectiveGasPrice;
      } else if (tx.gasPrice != null) {
        gasPrice = tx.gasPrice;
      }
      defineProperties(this, {
        provider,
        to: tx.to,
        from: tx.from,
        contractAddress: tx.contractAddress,
        hash: tx.hash,
        index: tx.index,
        blockHash: tx.blockHash,
        blockNumber: tx.blockNumber,
        logsBloom: tx.logsBloom,
        gasUsed: tx.gasUsed,
        cumulativeGasUsed: tx.cumulativeGasUsed,
        blobGasUsed: tx.blobGasUsed,
        gasPrice,
        blobGasPrice: tx.blobGasPrice,
        type: tx.type,
        status: tx.status,
        root: tx.root
      });
    }
    get logs() {
      return this.#logs;
    }
    toJSON() {
      const {
        to: to2,
        from: from2,
        contractAddress,
        hash: hash2,
        index,
        blockHash,
        blockNumber,
        logsBloom,
        logs,
        status,
        root
      } = this;
      return {
        _type: "TransactionReceipt",
        blockHash,
        blockNumber,
        contractAddress,
        cumulativeGasUsed: toJson(this.cumulativeGasUsed),
        from: from2,
        gasPrice: toJson(this.gasPrice),
        blobGasUsed: toJson(this.blobGasUsed),
        blobGasPrice: toJson(this.blobGasPrice),
        gasUsed: toJson(this.gasUsed),
        hash: hash2,
        index,
        logs,
        logsBloom,
        root,
        status,
        to: to2
      };
    }
    get length() {
      return this.logs.length;
    }
    [Symbol.iterator]() {
      let index = 0;
      return {
        next: () => {
          if (index < this.length) {
            return { value: this.logs[index++], done: false };
          }
          return { value: void 0, done: true };
        }
      };
    }
    get fee() {
      return this.gasUsed * this.gasPrice;
    }
    async getBlock() {
      const block = await this.provider.getBlock(this.blockHash);
      if (block == null) {
        throw new Error("TODO");
      }
      return block;
    }
    async getTransaction() {
      const tx = await this.provider.getTransaction(this.hash);
      if (tx == null) {
        throw new Error("TODO");
      }
      return tx;
    }
    async getResult() {
      return await this.provider.getTransactionResult(this.hash);
    }
    async confirmations() {
      return await this.provider.getBlockNumber() - this.blockNumber + 1;
    }
    removedEvent() {
      return createRemovedTransactionFilter(this);
    }
    reorderedEvent(other) {
      assert2(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
      return createReorderedTransactionFilter(this, other);
    }
  };
  var TransactionResponse = class {
    provider;
    blockNumber;
    blockHash;
    index;
    hash;
    type;
    to;
    from;
    nonce;
    gasLimit;
    gasPrice;
    maxPriorityFeePerGas;
    maxFeePerGas;
    maxFeePerBlobGas;
    data;
    value;
    chainId;
    signature;
    accessList;
    blobVersionedHashes;
    #startBlock;
    constructor(tx, provider) {
      this.provider = provider;
      this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
      this.blockHash = tx.blockHash != null ? tx.blockHash : null;
      this.hash = tx.hash;
      this.index = tx.index;
      this.type = tx.type;
      this.from = tx.from;
      this.to = tx.to || null;
      this.gasLimit = tx.gasLimit;
      this.nonce = tx.nonce;
      this.data = tx.data;
      this.value = tx.value;
      this.gasPrice = tx.gasPrice;
      this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
      this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
      this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
      this.chainId = tx.chainId;
      this.signature = tx.signature;
      this.accessList = tx.accessList != null ? tx.accessList : null;
      this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
      this.#startBlock = -1;
    }
    toJSON() {
      const { blockNumber, blockHash, index, hash: hash2, type: type2, to: to2, from: from2, nonce, data, signature, accessList, blobVersionedHashes } = this;
      return {
        _type: "TransactionResponse",
        accessList,
        blockNumber,
        blockHash,
        blobVersionedHashes,
        chainId: toJson(this.chainId),
        data,
        from: from2,
        gasLimit: toJson(this.gasLimit),
        gasPrice: toJson(this.gasPrice),
        hash: hash2,
        maxFeePerGas: toJson(this.maxFeePerGas),
        maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
        maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
        nonce,
        signature,
        to: to2,
        index,
        type: type2,
        value: toJson(this.value)
      };
    }
    async getBlock() {
      let blockNumber = this.blockNumber;
      if (blockNumber == null) {
        const tx = await this.getTransaction();
        if (tx) {
          blockNumber = tx.blockNumber;
        }
      }
      if (blockNumber == null) {
        return null;
      }
      const block = this.provider.getBlock(blockNumber);
      if (block == null) {
        throw new Error("TODO");
      }
      return block;
    }
    async getTransaction() {
      return this.provider.getTransaction(this.hash);
    }
    async confirmations() {
      if (this.blockNumber == null) {
        const { tx, blockNumber: blockNumber2 } = await resolveProperties({
          tx: this.getTransaction(),
          blockNumber: this.provider.getBlockNumber()
        });
        if (tx == null || tx.blockNumber == null) {
          return 0;
        }
        return blockNumber2 - tx.blockNumber + 1;
      }
      const blockNumber = await this.provider.getBlockNumber();
      return blockNumber - this.blockNumber + 1;
    }
    async wait(_confirms, _timeout) {
      const confirms = _confirms == null ? 1 : _confirms;
      const timeout = _timeout == null ? 0 : _timeout;
      let startBlock = this.#startBlock;
      let nextScan = -1;
      let stopScanning = startBlock === -1 ? true : false;
      const checkReplacement = async () => {
        if (stopScanning) {
          return null;
        }
        const { blockNumber, nonce } = await resolveProperties({
          blockNumber: this.provider.getBlockNumber(),
          nonce: this.provider.getTransactionCount(this.from)
        });
        if (nonce < this.nonce) {
          startBlock = blockNumber;
          return;
        }
        if (stopScanning) {
          return null;
        }
        const mined = await this.getTransaction();
        if (mined && mined.blockNumber != null) {
          return;
        }
        if (nextScan === -1) {
          nextScan = startBlock - 3;
          if (nextScan < this.#startBlock) {
            nextScan = this.#startBlock;
          }
        }
        while (nextScan <= blockNumber) {
          if (stopScanning) {
            return null;
          }
          const block = await this.provider.getBlock(nextScan, true);
          if (block == null) {
            return;
          }
          for (const hash2 of block) {
            if (hash2 === this.hash) {
              return;
            }
          }
          for (let i4 = 0; i4 < block.length; i4++) {
            const tx = await block.getTransaction(i4);
            if (tx.from === this.from && tx.nonce === this.nonce) {
              if (stopScanning) {
                return null;
              }
              const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
              if (receipt2 == null) {
                return;
              }
              if (blockNumber - receipt2.blockNumber + 1 < confirms) {
                return;
              }
              let reason = "replaced";
              if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                reason = "repriced";
              } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0$2) {
                reason = "cancelled";
              }
              assert2(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                cancelled: reason === "replaced" || reason === "cancelled",
                reason,
                replacement: tx.replaceableTransaction(startBlock),
                hash: tx.hash,
                receipt: receipt2
              });
            }
          }
          nextScan++;
        }
        return;
      };
      const checkReceipt = (receipt2) => {
        if (receipt2 == null || receipt2.status !== 0) {
          return receipt2;
        }
        assert2(false, "transaction execution reverted", "CALL_EXCEPTION", {
          action: "sendTransaction",
          data: null,
          reason: null,
          invocation: null,
          revert: null,
          transaction: {
            to: receipt2.to,
            from: receipt2.from,
            data: ""
          },
          receipt: receipt2
        });
      };
      const receipt = await this.provider.getTransactionReceipt(this.hash);
      if (confirms === 0) {
        return checkReceipt(receipt);
      }
      if (receipt) {
        if (await receipt.confirmations() >= confirms) {
          return checkReceipt(receipt);
        }
      } else {
        await checkReplacement();
        if (confirms === 0) {
          return null;
        }
      }
      const waiter = new Promise((resolve2, reject) => {
        const cancellers = [];
        const cancel = () => {
          cancellers.forEach((c3) => c3());
        };
        cancellers.push(() => {
          stopScanning = true;
        });
        if (timeout > 0) {
          const timer = setTimeout(() => {
            cancel();
            reject(makeError("wait for transaction timeout", "TIMEOUT"));
          }, timeout);
          cancellers.push(() => {
            clearTimeout(timer);
          });
        }
        const txListener = async (receipt2) => {
          if (await receipt2.confirmations() >= confirms) {
            cancel();
            try {
              resolve2(checkReceipt(receipt2));
            } catch (error2) {
              reject(error2);
            }
          }
        };
        cancellers.push(() => {
          this.provider.off(this.hash, txListener);
        });
        this.provider.on(this.hash, txListener);
        if (startBlock >= 0) {
          const replaceListener = async () => {
            try {
              await checkReplacement();
            } catch (error2) {
              if (isError(error2, "TRANSACTION_REPLACED")) {
                cancel();
                reject(error2);
                return;
              }
            }
            if (!stopScanning) {
              this.provider.once("block", replaceListener);
            }
          };
          cancellers.push(() => {
            this.provider.off("block", replaceListener);
          });
          this.provider.once("block", replaceListener);
        }
      });
      return await waiter;
    }
    isMined() {
      return this.blockHash != null;
    }
    isLegacy() {
      return this.type === 0;
    }
    isBerlin() {
      return this.type === 1;
    }
    isLondon() {
      return this.type === 2;
    }
    isCancun() {
      return this.type === 3;
    }
    removedEvent() {
      assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
      return createRemovedTransactionFilter(this);
    }
    reorderedEvent(other) {
      assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
      assert2(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
      return createReorderedTransactionFilter(this, other);
    }
    replaceableTransaction(startBlock) {
      assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
      const tx = new TransactionResponse(this, this.provider);
      tx.#startBlock = startBlock;
      return tx;
    }
  };
  function createOrphanedBlockFilter(block) {
    return { orphan: "drop-block", hash: block.hash, number: block.number };
  }
  function createReorderedTransactionFilter(tx, other) {
    return { orphan: "reorder-transaction", tx, other };
  }
  function createRemovedTransactionFilter(tx) {
    return { orphan: "drop-transaction", tx };
  }
  function createRemovedLogFilter(log) {
    return { orphan: "drop-log", log: {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      address: log.address,
      data: log.data,
      topics: Object.freeze(log.topics.slice()),
      index: log.index
    } };
  }
  var EventLog = class extends Log {
    interface;
    fragment;
    args;
    constructor(log, iface, fragment) {
      super(log, log.provider);
      const args = iface.decodeEventLog(fragment, log.data, log.topics);
      defineProperties(this, { args, fragment, interface: iface });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  };
  var UndecodedEventLog = class extends Log {
    error;
    constructor(log, error2) {
      super(log, log.provider);
      defineProperties(this, { error: error2 });
    }
  };
  var ContractTransactionReceipt = class extends TransactionReceipt {
    #iface;
    constructor(iface, provider, tx) {
      super(tx, provider);
      this.#iface = iface;
    }
    get logs() {
      return super.logs.map((log) => {
        const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
        if (fragment) {
          try {
            return new EventLog(log, this.#iface, fragment);
          } catch (error2) {
            return new UndecodedEventLog(log, error2);
          }
        }
        return log;
      });
    }
  };
  var ContractTransactionResponse = class extends TransactionResponse {
    #iface;
    constructor(iface, provider, tx) {
      super(tx, provider);
      this.#iface = iface;
    }
    async wait(confirms, timeout) {
      const receipt = await super.wait(confirms, timeout);
      if (receipt == null) {
        return null;
      }
      return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
    }
  };
  var ContractUnknownEventPayload = class extends EventPayload {
    log;
    constructor(contract, listener, filter, log) {
      super(contract, listener, filter);
      defineProperties(this, { log });
    }
    async getBlock() {
      return await this.log.getBlock();
    }
    async getTransaction() {
      return await this.log.getTransaction();
    }
    async getTransactionReceipt() {
      return await this.log.getTransactionReceipt();
    }
  };
  var ContractEventPayload = class extends ContractUnknownEventPayload {
    constructor(contract, listener, filter, fragment, _log) {
      super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));
      const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
      defineProperties(this, { args, fragment });
    }
    get eventName() {
      return this.fragment.name;
    }
    get eventSignature() {
      return this.fragment.format();
    }
  };
  var BN_0$1 = BigInt(0);
  function canCall(value) {
    return value && typeof value.call === "function";
  }
  function canEstimate(value) {
    return value && typeof value.estimateGas === "function";
  }
  function canResolve(value) {
    return value && typeof value.resolveName === "function";
  }
  function canSend(value) {
    return value && typeof value.sendTransaction === "function";
  }
  function getResolver(value) {
    if (value != null) {
      if (canResolve(value)) {
        return value;
      }
      if (value.provider) {
        return value.provider;
      }
    }
    return void 0;
  }
  var PreparedTopicFilter = class {
    #filter;
    fragment;
    constructor(contract, fragment, args) {
      defineProperties(this, { fragment });
      if (fragment.inputs.length < args.length) {
        throw new Error("too many arguments");
      }
      const runner = getRunner(contract.runner, "resolveName");
      const resolver = canResolve(runner) ? runner : null;
      this.#filter = async function() {
        const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
          const arg = args[index];
          if (arg == null) {
            return null;
          }
          return param.walkAsync(args[index], (type2, value) => {
            if (type2 === "address") {
              if (Array.isArray(value)) {
                return Promise.all(value.map((v6) => resolveAddress(v6, resolver)));
              }
              return resolveAddress(value, resolver);
            }
            return value;
          });
        }));
        return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
      }();
    }
    getTopicFilter() {
      return this.#filter;
    }
  };
  function getRunner(value, feature) {
    if (value == null) {
      return null;
    }
    if (typeof value[feature] === "function") {
      return value;
    }
    if (value.provider && typeof value.provider[feature] === "function") {
      return value.provider;
    }
    return null;
  }
  function getProvider(value) {
    if (value == null) {
      return null;
    }
    return value.provider || null;
  }
  async function copyOverrides(arg, allowed) {
    const _overrides = Typed.dereference(arg, "overrides");
    assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
    const overrides = copyRequest(_overrides);
    assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
    assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
    if (overrides.from) {
      overrides.from = overrides.from;
    }
    return overrides;
  }
  async function resolveArgs(_runner, inputs, args) {
    const runner = getRunner(_runner, "resolveName");
    const resolver = canResolve(runner) ? runner : null;
    return await Promise.all(inputs.map((param, index) => {
      return param.walkAsync(args[index], (type2, value) => {
        value = Typed.dereference(value, type2);
        if (type2 === "address") {
          return resolveAddress(value, resolver);
        }
        return value;
      });
    }));
  }
  function buildWrappedFallback(contract) {
    const populateTransaction = async function(overrides) {
      const tx = await copyOverrides(overrides, ["data"]);
      tx.to = await contract.getAddress();
      if (tx.from) {
        tx.from = await resolveAddress(tx.from, getResolver(contract.runner));
      }
      const iface = contract.interface;
      const noValue = getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
      const noData = (tx.data || "0x") === "0x";
      if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
        assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
      }
      assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
      const payable = iface.receive || iface.fallback && iface.fallback.payable;
      assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
      assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
      return tx;
    };
    const staticCall = async function(overrides) {
      const runner = getRunner(contract.runner, "call");
      assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
      const tx = await populateTransaction(overrides);
      try {
        return await runner.call(tx);
      } catch (error2) {
        if (isCallException(error2) && error2.data) {
          throw contract.interface.makeError(error2.data, tx);
        }
        throw error2;
      }
    };
    const send = async function(overrides) {
      const runner = contract.runner;
      assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
      const tx = await runner.sendTransaction(await populateTransaction(overrides));
      const provider = getProvider(contract.runner);
      return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function(overrides) {
      const runner = getRunner(contract.runner, "estimateGas");
      assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
      return await runner.estimateGas(await populateTransaction(overrides));
    };
    const method = async (overrides) => {
      return await send(overrides);
    };
    defineProperties(method, {
      _contract: contract,
      estimateGas,
      populateTransaction,
      send,
      staticCall
    });
    return method;
  }
  function buildWrappedMethod(contract, key) {
    const getFragment = function(...args) {
      const fragment = contract.interface.getFunction(key, args);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key, args }
      });
      return fragment;
    };
    const populateTransaction = async function(...args) {
      const fragment = getFragment(...args);
      let overrides = {};
      if (fragment.inputs.length + 1 === args.length) {
        overrides = await copyOverrides(args.pop());
        if (overrides.from) {
          overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));
        }
      }
      if (fragment.inputs.length !== args.length) {
        throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
      }
      const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
      return Object.assign({}, overrides, await resolveProperties({
        to: contract.getAddress(),
        data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
      }));
    };
    const staticCall = async function(...args) {
      const result = await staticCallResult(...args);
      if (result.length === 1) {
        return result[0];
      }
      return result;
    };
    const send = async function(...args) {
      const runner = contract.runner;
      assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
      const tx = await runner.sendTransaction(await populateTransaction(...args));
      const provider = getProvider(contract.runner);
      return new ContractTransactionResponse(contract.interface, provider, tx);
    };
    const estimateGas = async function(...args) {
      const runner = getRunner(contract.runner, "estimateGas");
      assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
      return await runner.estimateGas(await populateTransaction(...args));
    };
    const staticCallResult = async function(...args) {
      const runner = getRunner(contract.runner, "call");
      assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
      const tx = await populateTransaction(...args);
      let result = "0x";
      try {
        result = await runner.call(tx);
      } catch (error2) {
        if (isCallException(error2) && error2.data) {
          throw contract.interface.makeError(error2.data, tx);
        }
        throw error2;
      }
      const fragment = getFragment(...args);
      return contract.interface.decodeFunctionResult(fragment, result);
    };
    const method = async (...args) => {
      const fragment = getFragment(...args);
      if (fragment.constant) {
        return await staticCall(...args);
      }
      return await send(...args);
    };
    defineProperties(method, {
      name: contract.interface.getFunctionName(key),
      _contract: contract,
      _key: key,
      getFragment,
      estimateGas,
      populateTransaction,
      send,
      staticCall,
      staticCallResult
    });
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const fragment = contract.interface.getFunction(key);
        assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key }
        });
        return fragment;
      }
    });
    return method;
  }
  function buildWrappedEvent(contract, key) {
    const getFragment = function(...args) {
      const fragment = contract.interface.getEvent(key, args);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key, args }
      });
      return fragment;
    };
    const method = function(...args) {
      return new PreparedTopicFilter(contract, getFragment(...args), args);
    };
    defineProperties(method, {
      name: contract.interface.getEventName(key),
      _contract: contract,
      _key: key,
      getFragment
    });
    Object.defineProperty(method, "fragment", {
      configurable: false,
      enumerable: true,
      get: () => {
        const fragment = contract.interface.getEvent(key);
        assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key }
        });
        return fragment;
      }
    });
    return method;
  }
  var internal = Symbol.for("_ethersInternal_contract");
  var internalValues = /* @__PURE__ */ new WeakMap();
  function setInternal(contract, values) {
    internalValues.set(contract[internal], values);
  }
  function getInternal(contract) {
    return internalValues.get(contract[internal]);
  }
  function isDeferred(value) {
    return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
  }
  async function getSubInfo(contract, event) {
    let topics;
    let fragment = null;
    if (Array.isArray(event)) {
      const topicHashify = function(name) {
        if (isHexString(name, 32)) {
          return name;
        }
        const fragment2 = contract.interface.getEvent(name);
        assertArgument(fragment2, "unknown fragment", "name", name);
        return fragment2.topicHash;
      };
      topics = event.map((e7) => {
        if (e7 == null) {
          return null;
        }
        if (Array.isArray(e7)) {
          return e7.map(topicHashify);
        }
        return topicHashify(e7);
      });
    } else if (event === "*") {
      topics = [null];
    } else if (typeof event === "string") {
      if (isHexString(event, 32)) {
        topics = [event];
      } else {
        fragment = contract.interface.getEvent(event);
        assertArgument(fragment, "unknown fragment", "event", event);
        topics = [fragment.topicHash];
      }
    } else if (isDeferred(event)) {
      topics = await event.getTopicFilter();
    } else if ("fragment" in event) {
      fragment = event.fragment;
      topics = [fragment.topicHash];
    } else {
      assertArgument(false, "unknown event name", "event", event);
    }
    topics = topics.map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        const items2 = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
        if (items2.length === 1) {
          return items2[0];
        }
        items2.sort();
        return items2;
      }
      return t.toLowerCase();
    });
    const tag = topics.map((t) => {
      if (t == null) {
        return "null";
      }
      if (Array.isArray(t)) {
        return t.join("|");
      }
      return t;
    }).join("&");
    return { fragment, tag, topics };
  }
  async function hasSub(contract, event) {
    const { subs } = getInternal(contract);
    return subs.get((await getSubInfo(contract, event)).tag) || null;
  }
  async function getSub(contract, operation, event) {
    const provider = getProvider(contract.runner);
    assert2(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
    const { fragment, tag, topics } = await getSubInfo(contract, event);
    const { addr, subs } = getInternal(contract);
    let sub2 = subs.get(tag);
    if (!sub2) {
      const address = addr ? addr : contract;
      const filter = { address, topics };
      const listener = (log) => {
        let foundFragment = fragment;
        if (foundFragment == null) {
          try {
            foundFragment = contract.interface.getEvent(log.topics[0]);
          } catch (error2) {
          }
        }
        if (foundFragment) {
          const _foundFragment = foundFragment;
          const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
          emit(contract, event, args, (listener2) => {
            return new ContractEventPayload(contract, listener2, event, _foundFragment, log);
          });
        } else {
          emit(contract, event, [], (listener2) => {
            return new ContractUnknownEventPayload(contract, listener2, event, log);
          });
        }
      };
      let starting = [];
      const start = () => {
        if (starting.length) {
          return;
        }
        starting.push(provider.on(filter, listener));
      };
      const stop = async () => {
        if (starting.length == 0) {
          return;
        }
        let started = starting;
        starting = [];
        await Promise.all(started);
        provider.off(filter, listener);
      };
      sub2 = { tag, listeners: [], start, stop };
      subs.set(tag, sub2);
    }
    return sub2;
  }
  var lastEmit = Promise.resolve();
  async function _emit(contract, event, args, payloadFunc) {
    await lastEmit;
    const sub2 = await hasSub(contract, event);
    if (!sub2) {
      return false;
    }
    const count = sub2.listeners.length;
    sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
      const passArgs = Array.from(args);
      if (payloadFunc) {
        passArgs.push(payloadFunc(once ? null : listener));
      }
      try {
        listener.call(contract, ...passArgs);
      } catch (error2) {
      }
      return !once;
    });
    if (sub2.listeners.length === 0) {
      sub2.stop();
      getInternal(contract).subs.delete(sub2.tag);
    }
    return count > 0;
  }
  async function emit(contract, event, args, payloadFunc) {
    try {
      await lastEmit;
    } catch (error2) {
    }
    const resultPromise = _emit(contract, event, args, payloadFunc);
    lastEmit = resultPromise;
    return await resultPromise;
  }
  var passProperties = ["then"];
  var BaseContract = class {
    target;
    interface;
    runner;
    filters;
    [internal];
    fallback;
    constructor(target, abi, runner, _deployTx) {
      assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
      if (runner == null) {
        runner = null;
      }
      const iface = Interface.from(abi);
      defineProperties(this, { target, runner, interface: iface });
      Object.defineProperty(this, internal, { value: {} });
      let addrPromise;
      let addr = null;
      let deployTx = null;
      if (_deployTx) {
        const provider = getProvider(runner);
        deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);
      }
      let subs = /* @__PURE__ */ new Map();
      if (typeof target === "string") {
        if (isHexString(target)) {
          addr = target;
          addrPromise = Promise.resolve(target);
        } else {
          const resolver = getRunner(runner, "resolveName");
          if (!canResolve(resolver)) {
            throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
              operation: "resolveName"
            });
          }
          addrPromise = resolver.resolveName(target).then((addr2) => {
            if (addr2 == null) {
              throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                value: target
              });
            }
            getInternal(this).addr = addr2;
            return addr2;
          });
        }
      } else {
        addrPromise = target.getAddress().then((addr2) => {
          if (addr2 == null) {
            throw new Error("TODO");
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
      setInternal(this, { addrPromise, addr, deployTx, subs });
      const filters = new Proxy({}, {
        get: (target2, prop, receiver) => {
          if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target2, prop, receiver);
          }
          try {
            return this.getEvent(prop);
          } catch (error2) {
            if (!isError(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
              throw error2;
            }
          }
          return void 0;
        },
        has: (target2, prop) => {
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.has(target2, prop);
          }
          return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
        }
      });
      defineProperties(this, { filters });
      defineProperties(this, {
        fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
      });
      return new Proxy(this, {
        get: (target2, prop, receiver) => {
          if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target2, prop, receiver);
          }
          try {
            return target2.getFunction(prop);
          } catch (error2) {
            if (!isError(error2, "INVALID_ARGUMENT") || error2.argument !== "key") {
              throw error2;
            }
          }
          return void 0;
        },
        has: (target2, prop) => {
          if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
            return Reflect.has(target2, prop);
          }
          return target2.interface.hasFunction(prop);
        }
      });
    }
    connect(runner) {
      return new BaseContract(this.target, this.interface, runner);
    }
    attach(target) {
      return new BaseContract(target, this.interface, this.runner);
    }
    async getAddress() {
      return await getInternal(this).addrPromise;
    }
    async getDeployedCode() {
      const provider = getProvider(this.runner);
      assert2(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
      const code2 = await provider.getCode(await this.getAddress());
      if (code2 === "0x") {
        return null;
      }
      return code2;
    }
    async waitForDeployment() {
      const deployTx = this.deploymentTransaction();
      if (deployTx) {
        await deployTx.wait();
        return this;
      }
      const code2 = await this.getDeployedCode();
      if (code2 != null) {
        return this;
      }
      const provider = getProvider(this.runner);
      assert2(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
      return new Promise((resolve2, reject) => {
        const checkCode = async () => {
          try {
            const code3 = await this.getDeployedCode();
            if (code3 != null) {
              return resolve2(this);
            }
            provider.once("block", checkCode);
          } catch (error2) {
            reject(error2);
          }
        };
        checkCode();
      });
    }
    deploymentTransaction() {
      return getInternal(this).deployTx;
    }
    getFunction(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      const func = buildWrappedMethod(this, key);
      return func;
    }
    getEvent(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      return buildWrappedEvent(this, key);
    }
    async queryTransaction(hash2) {
      throw new Error("@TODO");
    }
    async queryFilter(event, fromBlock, toBlock) {
      if (fromBlock == null) {
        fromBlock = 0;
      }
      if (toBlock == null) {
        toBlock = "latest";
      }
      const { addr, addrPromise } = getInternal(this);
      const address = addr ? addr : await addrPromise;
      const { fragment, topics } = await getSubInfo(this, event);
      const filter = { address, topics, fromBlock, toBlock };
      const provider = getProvider(this.runner);
      assert2(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
      return (await provider.getLogs(filter)).map((log) => {
        let foundFragment = fragment;
        if (foundFragment == null) {
          try {
            foundFragment = this.interface.getEvent(log.topics[0]);
          } catch (error2) {
          }
        }
        if (foundFragment) {
          try {
            return new EventLog(log, this.interface, foundFragment);
          } catch (error2) {
            return new UndecodedEventLog(log, error2);
          }
        }
        return new Log(log, provider);
      });
    }
    async on(event, listener) {
      const sub2 = await getSub(this, "on", event);
      sub2.listeners.push({ listener, once: false });
      sub2.start();
      return this;
    }
    async once(event, listener) {
      const sub2 = await getSub(this, "once", event);
      sub2.listeners.push({ listener, once: true });
      sub2.start();
      return this;
    }
    async emit(event, ...args) {
      return await emit(this, event, args, null);
    }
    async listenerCount(event) {
      if (event) {
        const sub2 = await hasSub(this, event);
        if (!sub2) {
          return 0;
        }
        return sub2.listeners.length;
      }
      const { subs } = getInternal(this);
      let total = 0;
      for (const { listeners } of subs.values()) {
        total += listeners.length;
      }
      return total;
    }
    async listeners(event) {
      if (event) {
        const sub2 = await hasSub(this, event);
        if (!sub2) {
          return [];
        }
        return sub2.listeners.map(({ listener }) => listener);
      }
      const { subs } = getInternal(this);
      let result = [];
      for (const { listeners } of subs.values()) {
        result = result.concat(listeners.map(({ listener }) => listener));
      }
      return result;
    }
    async off(event, listener) {
      const sub2 = await hasSub(this, event);
      if (!sub2) {
        return this;
      }
      if (listener) {
        const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
        if (index >= 0) {
          sub2.listeners.splice(index, 1);
        }
      }
      if (listener == null || sub2.listeners.length === 0) {
        sub2.stop();
        getInternal(this).subs.delete(sub2.tag);
      }
      return this;
    }
    async removeAllListeners(event) {
      if (event) {
        const sub2 = await hasSub(this, event);
        if (!sub2) {
          return this;
        }
        sub2.stop();
        getInternal(this).subs.delete(sub2.tag);
      } else {
        const { subs } = getInternal(this);
        for (const { tag, stop } of subs.values()) {
          stop();
          subs.delete(tag);
        }
      }
      return this;
    }
    async addListener(event, listener) {
      return await this.on(event, listener);
    }
    async removeListener(event, listener) {
      return await this.off(event, listener);
    }
    static buildClass(abi) {
      class CustomContract extends BaseContract {
        constructor(address, runner = null) {
          super(address, abi, runner);
        }
      }
      return CustomContract;
    }
    static from(target, abi, runner) {
      if (runner == null) {
        runner = null;
      }
      const contract = new this(target, abi, runner);
      return contract;
    }
  };
  function _ContractBase() {
    return BaseContract;
  }
  var Contract = class extends _ContractBase() {
  };
  function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
      link = link.substring(12);
    } else if (link.match(/^ipfs:\/\//i)) {
      link = link.substring(7);
    } else {
      assertArgument(false, "unsupported IPFS format", "link", link);
    }
    return `https://gateway.ipfs.io/ipfs/${link}`;
  }
  var MulticoinProviderPlugin = class {
    name;
    constructor(name) {
      defineProperties(this, { name });
    }
    connect(proivder) {
      return this;
    }
    supportsCoinType(coinType) {
      return false;
    }
    async encodeAddress(coinType, address) {
      throw new Error("unsupported coin");
    }
    async decodeAddress(coinType, data) {
      throw new Error("unsupported coin");
    }
  };
  var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
  var matchers = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
  ];
  var _supports2544, _resolver, _fetch, fetch_fn, _getResolver, getResolver_fn;
  var _EnsResolver = class {
    constructor(provider, address, name) {
      __privateAdd(this, _fetch);
      __publicField(this, "provider");
      __publicField(this, "address");
      __publicField(this, "name");
      __privateAdd(this, _supports2544, void 0);
      __privateAdd(this, _resolver, void 0);
      defineProperties(this, { provider, address, name });
      __privateSet(this, _supports2544, null);
      __privateSet(this, _resolver, new Contract(address, [
        "function supportsInterface(bytes4) view returns (bool)",
        "function resolve(bytes, bytes) view returns (bytes)",
        "function addr(bytes32) view returns (address)",
        "function addr(bytes32, uint) view returns (bytes)",
        "function text(bytes32, string) view returns (string)",
        "function contenthash(bytes32) view returns (bytes)"
      ], provider));
    }
    async supportsWildcard() {
      if (__privateGet(this, _supports2544) == null) {
        __privateSet(this, _supports2544, (async () => {
          try {
            return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
          } catch (error2) {
            if (isError(error2, "CALL_EXCEPTION")) {
              return false;
            }
            __privateSet(this, _supports2544, null);
            throw error2;
          }
        })());
      }
      return await __privateGet(this, _supports2544);
    }
    async getAddress(coinType) {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const result = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32)");
          if (result == null || result === ZeroAddress) {
            return null;
          }
          return result;
        } catch (error2) {
          if (isError(error2, "CALL_EXCEPTION")) {
            return null;
          }
          throw error2;
        }
      }
      if (coinType >= 0 && coinType < 2147483648) {
        let ethCoinType = coinType + 2147483648;
        const data2 = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
        if (isHexString(data2, 20)) {
          return getAddress(data2);
        }
      }
      let coinPlugin = null;
      for (const plugin of this.provider.plugins) {
        if (!(plugin instanceof MulticoinProviderPlugin)) {
          continue;
        }
        if (plugin.supportsCoinType(coinType)) {
          coinPlugin = plugin;
          break;
        }
      }
      if (coinPlugin == null) {
        return null;
      }
      const data = await __privateMethod(this, _fetch, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
      if (data == null || data === "0x") {
        return null;
      }
      const address = await coinPlugin.decodeAddress(coinType, data);
      if (address != null) {
        return address;
      }
      assert2(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
        operation: `getAddress(${coinType})`,
        info: { coinType, data }
      });
    }
    async getText(key) {
      const data = await __privateMethod(this, _fetch, fetch_fn).call(this, "text(bytes32,string)", [key]);
      if (data == null || data === "0x") {
        return null;
      }
      return data;
    }
    async getContentHash() {
      const data = await __privateMethod(this, _fetch, fetch_fn).call(this, "contenthash(bytes32)");
      if (data == null || data === "0x") {
        return null;
      }
      const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
        const length2 = parseInt(ipfs[4], 16);
        if (ipfs[5].length === length2 * 2) {
          return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
        }
      }
      const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm && swarm[1].length === 64) {
        return `bzz://${swarm[1]}`;
      }
      assert2(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
        operation: "getContentHash()",
        info: { data }
      });
    }
    async getAvatar() {
      const avatar = await this._getAvatar();
      return avatar.url;
    }
    async _getAvatar() {
      const linkage = [{ type: "name", value: this.name }];
      try {
        const avatar = await this.getText("avatar");
        if (avatar == null) {
          linkage.push({ type: "!avatar", value: "" });
          return { url: null, linkage };
        }
        linkage.push({ type: "avatar", value: avatar });
        for (let i4 = 0; i4 < matchers.length; i4++) {
          const match = avatar.match(matchers[i4]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
            case "data":
              linkage.push({ type: "url", value: avatar });
              return { linkage, url: avatar };
            case "ipfs": {
              const url2 = getIpfsLink(avatar);
              linkage.push({ type: "ipfs", value: avatar });
              linkage.push({ type: "url", value: url2 });
              return { linkage, url: url2 };
            }
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
              linkage.push({ type: scheme, value: avatar });
              const owner = await this.getAddress();
              if (owner == null) {
                linkage.push({ type: "!owner", value: "" });
                return { url: null, linkage };
              }
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
                return { url: null, linkage };
              }
              const tokenId = comps[1];
              const contract = new Contract(comps[0], [
                "function tokenURI(uint) view returns (string)",
                "function ownerOf(uint) view returns (address)",
                "function uri(uint) view returns (string)",
                "function balanceOf(address, uint256) view returns (uint)"
              ], this.provider);
              if (scheme === "erc721") {
                const tokenOwner = await contract.ownerOf(tokenId);
                if (owner !== tokenOwner) {
                  linkage.push({ type: "!owner", value: tokenOwner });
                  return { url: null, linkage };
                }
                linkage.push({ type: "owner", value: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = await contract.balanceOf(owner, tokenId);
                if (!balance) {
                  linkage.push({ type: "!balance", value: "0" });
                  return { url: null, linkage };
                }
                linkage.push({ type: "balance", value: balance.toString() });
              }
              let metadataUrl = await contract[selector](tokenId);
              if (metadataUrl == null || metadataUrl === "0x") {
                linkage.push({ type: "!metadata-url", value: "" });
                return { url: null, linkage };
              }
              linkage.push({ type: "metadata-url-base", value: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
                linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
              }
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({ type: "metadata-url", value: metadataUrl });
              let metadata2 = {};
              const response = await new FetchRequest(metadataUrl).send();
              response.assertOk();
              try {
                metadata2 = response.bodyJson;
              } catch (error2) {
                try {
                  linkage.push({ type: "!metadata", value: response.bodyText });
                } catch (error3) {
                  const bytes2 = response.body;
                  if (bytes2) {
                    linkage.push({ type: "!metadata", value: hexlify(bytes2) });
                  }
                  return { url: null, linkage };
                }
                return { url: null, linkage };
              }
              if (!metadata2) {
                linkage.push({ type: "!metadata", value: "" });
                return { url: null, linkage };
              }
              linkage.push({ type: "metadata", value: JSON.stringify(metadata2) });
              let imageUrl = metadata2.image;
              if (typeof imageUrl !== "string") {
                linkage.push({ type: "!imageUrl", value: "" });
                return { url: null, linkage };
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i))
                ;
              else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                  return { url: null, linkage };
                }
                linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", value: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error2) {
      }
      return { linkage, url: null };
    }
    static async getEnsAddress(provider) {
      const network = await provider.getNetwork();
      const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
      assert2(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
        operation: "getEnsAddress",
        info: { network }
      });
      return ensPlugin.address;
    }
    static async fromName(provider, name) {
      var _a2;
      let currentName = name;
      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        }
        if (name !== "eth" && currentName === "eth") {
          return null;
        }
        const addr = await __privateMethod(_a2 = _EnsResolver, _getResolver, getResolver_fn).call(_a2, provider, currentName);
        if (addr != null) {
          const resolver = new _EnsResolver(provider, addr, name);
          if (currentName !== name && !await resolver.supportsWildcard()) {
            return null;
          }
          return resolver;
        }
        currentName = currentName.split(".").slice(1).join(".");
      }
    }
  };
  var EnsResolver = _EnsResolver;
  _supports2544 = new WeakMap();
  _resolver = new WeakMap();
  _fetch = new WeakSet();
  fetch_fn = async function(funcName, params) {
    params = (params || []).slice();
    const iface = __privateGet(this, _resolver).interface;
    params.unshift(namehash(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert2(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name, 255),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await __privateGet(this, _resolver)[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error2) {
      if (!isError(error2, "CALL_EXCEPTION")) {
        throw error2;
      }
    }
    return null;
  };
  _getResolver = new WeakSet();
  getResolver_fn = async function(provider, name) {
    const ensAddr = await _EnsResolver.getEnsAddress(provider);
    try {
      const contract = new Contract(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider);
      const addr = await contract.resolver(namehash(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error2) {
      throw error2;
    }
    return null;
  };
  __privateAdd(EnsResolver, _getResolver);
  var BN_0 = BigInt(0);
  function allowNull(format2, nullValue) {
    return function(value) {
      if (value == null) {
        return nullValue;
      }
      return format2(value);
    };
  }
  function arrayOf(format2, allowNull2) {
    return (array) => {
      if (allowNull2 && array == null) {
        return null;
      }
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }
      return array.map((i4) => format2(i4));
    };
  }
  function object(format2, altNames) {
    return (value) => {
      const result = {};
      for (const key in format2) {
        let srcKey = key;
        if (altNames && key in altNames && !(srcKey in value)) {
          for (const altKey of altNames[key]) {
            if (altKey in value) {
              srcKey = altKey;
              break;
            }
          }
        }
        try {
          const nv = format2[key](value[srcKey]);
          if (nv !== void 0) {
            result[key] = nv;
          }
        } catch (error2) {
          const message = error2 instanceof Error ? error2.message : "not-an-error";
          assert2(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
        }
      }
      return result;
    };
  }
  function formatBoolean(value) {
    switch (value) {
      case true:
      case "true":
        return true;
      case false:
      case "false":
        return false;
    }
    assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
  }
  function formatData(value) {
    assertArgument(isHexString(value, true), "invalid data", "value", value);
    return value;
  }
  function formatHash(value) {
    assertArgument(isHexString(value, 32), "invalid hash", "value", value);
    return value;
  }
  var _formatLog = object({
    address: getAddress,
    blockHash: formatHash,
    blockNumber: getNumber,
    data: formatData,
    index: getNumber,
    removed: allowNull(formatBoolean, false),
    topics: arrayOf(formatHash),
    transactionHash: formatHash,
    transactionIndex: getNumber
  }, {
    index: ["logIndex"]
  });
  function formatLog(value) {
    return _formatLog(value);
  }
  var _formatBlock = object({
    hash: allowNull(formatHash),
    parentHash: formatHash,
    parentBeaconBlockRoot: allowNull(formatHash, null),
    number: getNumber,
    timestamp: getNumber,
    nonce: allowNull(formatData),
    difficulty: getBigInt,
    gasLimit: getBigInt,
    gasUsed: getBigInt,
    stateRoot: allowNull(formatHash, null),
    receiptsRoot: allowNull(formatHash, null),
    blobGasUsed: allowNull(getBigInt, null),
    excessBlobGas: allowNull(getBigInt, null),
    miner: allowNull(getAddress),
    prevRandao: allowNull(formatHash, null),
    extraData: formatData,
    baseFeePerGas: allowNull(getBigInt)
  }, {
    prevRandao: ["mixHash"]
  });
  function formatBlock(value) {
    const result = _formatBlock(value);
    result.transactions = value.transactions.map((tx) => {
      if (typeof tx === "string") {
        return tx;
      }
      return formatTransactionResponse(tx);
    });
    return result;
  }
  var _formatReceiptLog = object({
    transactionIndex: getNumber,
    blockNumber: getNumber,
    transactionHash: formatHash,
    address: getAddress,
    topics: arrayOf(formatHash),
    data: formatData,
    index: getNumber,
    blockHash: formatHash
  }, {
    index: ["logIndex"]
  });
  function formatReceiptLog(value) {
    return _formatReceiptLog(value);
  }
  var _formatTransactionReceipt = object({
    to: allowNull(getAddress, null),
    from: allowNull(getAddress, null),
    contractAddress: allowNull(getAddress, null),
    index: getNumber,
    root: allowNull(hexlify),
    gasUsed: getBigInt,
    blobGasUsed: allowNull(getBigInt, null),
    logsBloom: allowNull(formatData),
    blockHash: formatHash,
    hash: formatHash,
    logs: arrayOf(formatReceiptLog),
    blockNumber: getNumber,
    cumulativeGasUsed: getBigInt,
    effectiveGasPrice: allowNull(getBigInt),
    blobGasPrice: allowNull(getBigInt, null),
    status: allowNull(getNumber),
    type: allowNull(getNumber, 0)
  }, {
    effectiveGasPrice: ["gasPrice"],
    hash: ["transactionHash"],
    index: ["transactionIndex"]
  });
  function formatTransactionReceipt(value) {
    return _formatTransactionReceipt(value);
  }
  function formatTransactionResponse(value) {
    if (value.to && getBigInt(value.to) === BN_0) {
      value.to = "0x0000000000000000000000000000000000000000";
    }
    const result = object({
      hash: formatHash,
      index: allowNull(getNumber, void 0),
      type: (value2) => {
        if (value2 === "0x" || value2 == null) {
          return 0;
        }
        return getNumber(value2);
      },
      accessList: allowNull(accessListify, null),
      blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
      blockHash: allowNull(formatHash, null),
      blockNumber: allowNull(getNumber, null),
      transactionIndex: allowNull(getNumber, null),
      from: getAddress,
      gasPrice: allowNull(getBigInt),
      maxPriorityFeePerGas: allowNull(getBigInt),
      maxFeePerGas: allowNull(getBigInt),
      maxFeePerBlobGas: allowNull(getBigInt, null),
      gasLimit: getBigInt,
      to: allowNull(getAddress, null),
      value: getBigInt,
      nonce: getNumber,
      data: formatData,
      creates: allowNull(getAddress, null),
      chainId: allowNull(getBigInt, null)
    }, {
      data: ["input"],
      gasLimit: ["gas"],
      index: ["transactionIndex"]
    })(value);
    if (result.to == null && result.creates == null) {
      result.creates = getCreateAddress(result);
    }
    if ((value.type === 1 || value.type === 2) && value.accessList == null) {
      result.accessList = [];
    }
    if (value.signature) {
      result.signature = Signature.from(value.signature);
    } else {
      result.signature = Signature.from(value);
    }
    if (result.chainId == null) {
      const chainId = result.signature.legacyChainId;
      if (chainId != null) {
        result.chainId = chainId;
      }
    }
    if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
      result.blockHash = null;
    }
    return result;
  }
  var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
  var NetworkPlugin = class {
    name;
    constructor(name) {
      defineProperties(this, { name });
    }
    clone() {
      return new NetworkPlugin(this.name);
    }
  };
  var GasCostPlugin = class extends NetworkPlugin {
    effectiveBlock;
    txBase;
    txCreate;
    txDataZero;
    txDataNonzero;
    txAccessListStorageKey;
    txAccessListAddress;
    constructor(effectiveBlock, costs) {
      if (effectiveBlock == null) {
        effectiveBlock = 0;
      }
      super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
      const props = { effectiveBlock };
      function set2(name, nullish) {
        let value = (costs || {})[name];
        if (value == null) {
          value = nullish;
        }
        assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
        props[name] = value;
      }
      set2("txBase", 21e3);
      set2("txCreate", 32e3);
      set2("txDataZero", 4);
      set2("txDataNonzero", 16);
      set2("txAccessListStorageKey", 1900);
      set2("txAccessListAddress", 2400);
      defineProperties(this, props);
    }
    clone() {
      return new GasCostPlugin(this.effectiveBlock, this);
    }
  };
  var EnsPlugin = class extends NetworkPlugin {
    address;
    targetNetwork;
    constructor(address, targetNetwork) {
      super("org.ethers.plugins.network.Ens");
      defineProperties(this, {
        address: address || EnsAddress,
        targetNetwork: targetNetwork == null ? 1 : targetNetwork
      });
    }
    clone() {
      return new EnsPlugin(this.address, this.targetNetwork);
    }
  };
  var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
    #url;
    #processFunc;
    get url() {
      return this.#url;
    }
    get processFunc() {
      return this.#processFunc;
    }
    constructor(url2, processFunc) {
      super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      this.#url = url2;
      this.#processFunc = processFunc;
    }
    clone() {
      return this;
    }
  };
  var Networks = /* @__PURE__ */ new Map();
  var Network = class {
    #name;
    #chainId;
    #plugins;
    constructor(name, chainId) {
      this.#name = name;
      this.#chainId = getBigInt(chainId);
      this.#plugins = /* @__PURE__ */ new Map();
    }
    toJSON() {
      return { name: this.name, chainId: String(this.chainId) };
    }
    get name() {
      return this.#name;
    }
    set name(value) {
      this.#name = value;
    }
    get chainId() {
      return this.#chainId;
    }
    set chainId(value) {
      this.#chainId = getBigInt(value, "chainId");
    }
    matches(other) {
      if (other == null) {
        return false;
      }
      if (typeof other === "string") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return this.name === other;
      }
      if (typeof other === "number" || typeof other === "bigint") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return false;
      }
      if (typeof other === "object") {
        if (other.chainId != null) {
          try {
            return this.chainId === getBigInt(other.chainId);
          } catch (error2) {
          }
          return false;
        }
        if (other.name != null) {
          return this.name === other.name;
        }
        return false;
      }
      return false;
    }
    get plugins() {
      return Array.from(this.#plugins.values());
    }
    attachPlugin(plugin) {
      if (this.#plugins.get(plugin.name)) {
        throw new Error(`cannot replace existing plugin: ${plugin.name} `);
      }
      this.#plugins.set(plugin.name, plugin.clone());
      return this;
    }
    getPlugin(name) {
      return this.#plugins.get(name) || null;
    }
    getPlugins(basename) {
      return this.plugins.filter((p6) => p6.name.split("#")[0] === basename);
    }
    clone() {
      const clone = new Network(this.name, this.chainId);
      this.plugins.forEach((plugin) => {
        clone.attachPlugin(plugin.clone());
      });
      return clone;
    }
    computeIntrinsicGas(tx) {
      const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
      let gas = costs.txBase;
      if (tx.to == null) {
        gas += costs.txCreate;
      }
      if (tx.data) {
        for (let i4 = 2; i4 < tx.data.length; i4 += 2) {
          if (tx.data.substring(i4, i4 + 2) === "00") {
            gas += costs.txDataZero;
          } else {
            gas += costs.txDataNonzero;
          }
        }
      }
      if (tx.accessList) {
        const accessList = accessListify(tx.accessList);
        for (const addr in accessList) {
          gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
        }
      }
      return gas;
    }
    static from(network) {
      injectCommonNetworks();
      if (network == null) {
        return Network.from("mainnet");
      }
      if (typeof network === "number") {
        network = BigInt(network);
      }
      if (typeof network === "string" || typeof network === "bigint") {
        const networkFunc = Networks.get(network);
        if (networkFunc) {
          return networkFunc();
        }
        if (typeof network === "bigint") {
          return new Network("unknown", network);
        }
        assertArgument(false, "unknown network", "network", network);
      }
      if (typeof network.clone === "function") {
        const clone = network.clone();
        return clone;
      }
      if (typeof network === "object") {
        assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
        const custom = new Network(network.name, network.chainId);
        if (network.ensAddress || network.ensNetwork != null) {
          custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
        }
        return custom;
      }
      assertArgument(false, "invalid network", "network", network);
    }
    static register(nameOrChainId, networkFunc) {
      if (typeof nameOrChainId === "number") {
        nameOrChainId = BigInt(nameOrChainId);
      }
      const existing = Networks.get(nameOrChainId);
      if (existing) {
        assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
      }
      Networks.set(nameOrChainId, networkFunc);
    }
  };
  function parseUnits(_value, decimals) {
    const value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    const comps = value.split(".");
    if (comps.length === 1) {
      comps.push("");
    }
    if (comps.length !== 2) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    while (comps[1].length < decimals) {
      comps[1] += "0";
    }
    if (comps[1].length > 9) {
      let frac = BigInt(comps[1].substring(0, 9));
      if (!comps[1].substring(9).match(/^0+$/)) {
        frac++;
      }
      comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
  }
  function getGasStationPlugin(url2) {
    return new FetchUrlFeeDataNetworkPlugin(url2, async (fetchFeeData, provider, request) => {
      request.setHeader("User-Agent", "ethers");
      let response;
      try {
        const [_response, _feeData] = await Promise.all([
          request.send(),
          fetchFeeData()
        ]);
        response = _response;
        const payload = response.bodyJson.standard;
        const feeData = {
          gasPrice: _feeData.gasPrice,
          maxFeePerGas: parseUnits(payload.maxFee, 9),
          maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
        };
        return feeData;
      } catch (error2) {
        assert2(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
      }
    });
  }
  var injected = false;
  function injectCommonNetworks() {
    if (injected) {
      return;
    }
    injected = true;
    function registerEth(name, chainId, options) {
      const func = function() {
        const network = new Network(name, chainId);
        if (options.ensNetwork != null) {
          network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
        }
        network.attachPlugin(new GasCostPlugin());
        (options.plugins || []).forEach((plugin) => {
          network.attachPlugin(plugin);
        });
        return network;
      };
      Network.register(name, func);
      Network.register(chainId, func);
      if (options.altNames) {
        options.altNames.forEach((name2) => {
          Network.register(name2, func);
        });
      }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
    registerEth("holesky", 17e3, { ensNetwork: 17e3 });
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
      ensNetwork: 1
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("arbitrum-sepolia", 421614, {});
    registerEth("base", 8453, { ensNetwork: 1 });
    registerEth("base-goerli", 84531, {});
    registerEth("base-sepolia", 84532, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("linea-sepolia", 59141, {});
    registerEth("matic", 137, {
      ensNetwork: 1,
      plugins: [
        getGasStationPlugin("https://gasstation.polygon.technology/v2")
      ]
    });
    registerEth("matic-amoy", 80002, {});
    registerEth("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [
        getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
      ]
    });
    registerEth("optimism", 10, {
      ensNetwork: 1,
      plugins: []
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("optimism-sepolia", 11155420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
  }
  function copy$2(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var PollingBlockSubscriber = class {
    #provider;
    #poller;
    #interval;
    #blockNumber;
    constructor(provider) {
      this.#provider = provider;
      this.#poller = null;
      this.#interval = 4e3;
      this.#blockNumber = -2;
    }
    get pollingInterval() {
      return this.#interval;
    }
    set pollingInterval(value) {
      this.#interval = value;
    }
    async #poll() {
      try {
        const blockNumber = await this.#provider.getBlockNumber();
        if (this.#blockNumber === -2) {
          this.#blockNumber = blockNumber;
          return;
        }
        if (blockNumber !== this.#blockNumber) {
          for (let b7 = this.#blockNumber + 1; b7 <= blockNumber; b7++) {
            if (this.#poller == null) {
              return;
            }
            await this.#provider.emit("block", b7);
          }
          this.#blockNumber = blockNumber;
        }
      } catch (error2) {
      }
      if (this.#poller == null) {
        return;
      }
      this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    }
    start() {
      if (this.#poller) {
        return;
      }
      this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
      this.#poll();
    }
    stop() {
      if (!this.#poller) {
        return;
      }
      this.#provider._clearTimeout(this.#poller);
      this.#poller = null;
    }
    pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        this.#blockNumber = -2;
      }
    }
    resume() {
      this.start();
    }
  };
  var OnBlockSubscriber = class {
    #provider;
    #poll;
    #running;
    constructor(provider) {
      this.#provider = provider;
      this.#running = false;
      this.#poll = (blockNumber) => {
        this._poll(blockNumber, this.#provider);
      };
    }
    async _poll(blockNumber, provider) {
      throw new Error("sub-classes must override this");
    }
    start() {
      if (this.#running) {
        return;
      }
      this.#running = true;
      this.#poll(-2);
      this.#provider.on("block", this.#poll);
    }
    stop() {
      if (!this.#running) {
        return;
      }
      this.#running = false;
      this.#provider.off("block", this.#poll);
    }
    pause(dropWhilePaused) {
      this.stop();
    }
    resume() {
      this.start();
    }
  };
  var PollingBlockTagSubscriber = class extends OnBlockSubscriber {
    #tag;
    #lastBlock;
    constructor(provider, tag) {
      super(provider);
      this.#tag = tag;
      this.#lastBlock = -2;
    }
    pause(dropWhilePaused) {
      if (dropWhilePaused) {
        this.#lastBlock = -2;
      }
      super.pause(dropWhilePaused);
    }
    async _poll(blockNumber, provider) {
      const block = await provider.getBlock(this.#tag);
      if (block == null) {
        return;
      }
      if (this.#lastBlock === -2) {
        this.#lastBlock = block.number;
      } else if (block.number > this.#lastBlock) {
        provider.emit(this.#tag, block.number);
        this.#lastBlock = block.number;
      }
    }
  };
  var PollingOrphanSubscriber = class extends OnBlockSubscriber {
    #filter;
    constructor(provider, filter) {
      super(provider);
      this.#filter = copy$2(filter);
    }
    async _poll(blockNumber, provider) {
      throw new Error("@TODO");
    }
  };
  var PollingTransactionSubscriber = class extends OnBlockSubscriber {
    #hash;
    constructor(provider, hash2) {
      super(provider);
      this.#hash = hash2;
    }
    async _poll(blockNumber, provider) {
      const tx = await provider.getTransactionReceipt(this.#hash);
      if (tx) {
        provider.emit(this.#hash, tx);
      }
    }
  };
  var PollingEventSubscriber = class {
    #provider;
    #filter;
    #poller;
    #running;
    #blockNumber;
    constructor(provider, filter) {
      this.#provider = provider;
      this.#filter = copy$2(filter);
      this.#poller = this.#poll.bind(this);
      this.#running = false;
      this.#blockNumber = -2;
    }
    async #poll(blockNumber) {
      if (this.#blockNumber === -2) {
        return;
      }
      const filter = copy$2(this.#filter);
      filter.fromBlock = this.#blockNumber + 1;
      filter.toBlock = blockNumber;
      const logs = await this.#provider.getLogs(filter);
      if (logs.length === 0) {
        if (this.#blockNumber < blockNumber - 60) {
          this.#blockNumber = blockNumber - 60;
        }
        return;
      }
      for (const log of logs) {
        this.#provider.emit(this.#filter, log);
        this.#blockNumber = log.blockNumber;
      }
    }
    start() {
      if (this.#running) {
        return;
      }
      this.#running = true;
      if (this.#blockNumber === -2) {
        this.#provider.getBlockNumber().then((blockNumber) => {
          this.#blockNumber = blockNumber;
        });
      }
      this.#provider.on("block", this.#poller);
    }
    stop() {
      if (!this.#running) {
        return;
      }
      this.#running = false;
      this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        this.#blockNumber = -2;
      }
    }
    resume() {
      this.start();
    }
  };
  var BN_2 = BigInt(2);
  var MAX_CCIP_REDIRECTS = 10;
  function isPromise(value) {
    return value && typeof value.then === "function";
  }
  function getTag(prefix, value) {
    return prefix + ":" + JSON.stringify(value, (k5, v6) => {
      if (v6 == null) {
        return "null";
      }
      if (typeof v6 === "bigint") {
        return `bigint:${v6.toString()}`;
      }
      if (typeof v6 === "string") {
        return v6.toLowerCase();
      }
      if (typeof v6 === "object" && !Array.isArray(v6)) {
        const keys = Object.keys(v6);
        keys.sort();
        return keys.reduce((accum, key) => {
          accum[key] = v6[key];
          return accum;
        }, {});
      }
      return v6;
    });
  }
  var UnmanagedSubscriber = class {
    name;
    constructor(name) {
      defineProperties(this, { name });
    }
    start() {
    }
    stop() {
    }
    pause(dropWhilePaused) {
    }
    resume() {
    }
  };
  function copy$1(value) {
    return JSON.parse(JSON.stringify(value));
  }
  function concisify(items2) {
    items2 = Array.from(new Set(items2).values());
    items2.sort();
    return items2;
  }
  async function getSubscription(_event, provider) {
    if (_event == null) {
      throw new Error("invalid event");
    }
    if (Array.isArray(_event)) {
      _event = { topics: _event };
    }
    if (typeof _event === "string") {
      switch (_event) {
        case "block":
        case "debug":
        case "error":
        case "finalized":
        case "network":
        case "pending":
        case "safe": {
          return { type: _event, tag: _event };
        }
      }
    }
    if (isHexString(_event, 32)) {
      const hash2 = _event.toLowerCase();
      return { type: "transaction", tag: getTag("tx", { hash: hash2 }), hash: hash2 };
    }
    if (_event.orphan) {
      const event = _event;
      return { type: "orphan", tag: getTag("orphan", event), filter: copy$1(event) };
    }
    if (_event.address || _event.topics) {
      const event = _event;
      const filter = {
        topics: (event.topics || []).map((t) => {
          if (t == null) {
            return null;
          }
          if (Array.isArray(t)) {
            return concisify(t.map((t2) => t2.toLowerCase()));
          }
          return t.toLowerCase();
        })
      };
      if (event.address) {
        const addresses = [];
        const promises = [];
        const addAddress = (addr) => {
          if (isHexString(addr)) {
            addresses.push(addr);
          } else {
            promises.push((async () => {
              addresses.push(await resolveAddress(addr, provider));
            })());
          }
        };
        if (Array.isArray(event.address)) {
          event.address.forEach(addAddress);
        } else {
          addAddress(event.address);
        }
        if (promises.length) {
          await Promise.all(promises);
        }
        filter.address = concisify(addresses.map((a4) => a4.toLowerCase()));
      }
      return { filter, tag: getTag("event", filter), type: "event" };
    }
    assertArgument(false, "unknown ProviderEvent", "event", _event);
  }
  function getTime() {
    return new Date().getTime();
  }
  var defaultOptions$1 = {
    cacheTimeout: 250,
    pollingInterval: 4e3
  };
  var AbstractProvider = class {
    #subs;
    #plugins;
    #pausedState;
    #destroyed;
    #networkPromise;
    #anyNetwork;
    #performCache;
    #lastBlockNumber;
    #nextTimer;
    #timers;
    #disableCcipRead;
    #options;
    constructor(_network, options) {
      this.#options = Object.assign({}, defaultOptions$1, options || {});
      if (_network === "any") {
        this.#anyNetwork = true;
        this.#networkPromise = null;
      } else if (_network) {
        const network = Network.from(_network);
        this.#anyNetwork = false;
        this.#networkPromise = Promise.resolve(network);
        setTimeout(() => {
          this.emit("network", network, null);
        }, 0);
      } else {
        this.#anyNetwork = false;
        this.#networkPromise = null;
      }
      this.#lastBlockNumber = -1;
      this.#performCache = /* @__PURE__ */ new Map();
      this.#subs = /* @__PURE__ */ new Map();
      this.#plugins = /* @__PURE__ */ new Map();
      this.#pausedState = null;
      this.#destroyed = false;
      this.#nextTimer = 1;
      this.#timers = /* @__PURE__ */ new Map();
      this.#disableCcipRead = false;
    }
    get pollingInterval() {
      return this.#options.pollingInterval;
    }
    get provider() {
      return this;
    }
    get plugins() {
      return Array.from(this.#plugins.values());
    }
    attachPlugin(plugin) {
      if (this.#plugins.get(plugin.name)) {
        throw new Error(`cannot replace existing plugin: ${plugin.name} `);
      }
      this.#plugins.set(plugin.name, plugin.connect(this));
      return this;
    }
    getPlugin(name) {
      return this.#plugins.get(name) || null;
    }
    get disableCcipRead() {
      return this.#disableCcipRead;
    }
    set disableCcipRead(value) {
      this.#disableCcipRead = !!value;
    }
    async #perform(req) {
      const timeout = this.#options.cacheTimeout;
      if (timeout < 0) {
        return await this._perform(req);
      }
      const tag = getTag(req.method, req);
      let perform = this.#performCache.get(tag);
      if (!perform) {
        perform = this._perform(req);
        this.#performCache.set(tag, perform);
        setTimeout(() => {
          if (this.#performCache.get(tag) === perform) {
            this.#performCache.delete(tag);
          }
        }, timeout);
      }
      return await perform;
    }
    async ccipReadFetch(tx, calldata, urls) {
      if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
        return null;
      }
      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];
      for (let i4 = 0; i4 < urls.length; i4++) {
        const url2 = urls[i4];
        const href = url2.replace("{sender}", sender).replace("{data}", data);
        const request = new FetchRequest(href);
        if (url2.indexOf("{data}") === -1) {
          request.body = { data, sender };
        }
        this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i4, urls });
        let errorMessage = "unknown error";
        let resp;
        try {
          resp = await request.send();
        } catch (error2) {
          errorMessages.push(error2.message);
          this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error: error2 } });
          continue;
        }
        try {
          const result = resp.bodyJson;
          if (result.data) {
            this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
            return result.data;
          }
          if (result.message) {
            errorMessage = result.message;
          }
          this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
        } catch (error2) {
        }
        assert2(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url: url2, errorMessage } });
        errorMessages.push(errorMessage);
      }
      assert2(false, `error encountered during CCIP fetch: ${errorMessages.map((m5) => JSON.stringify(m5)).join(", ")}`, "OFFCHAIN_FAULT", {
        reason: "500_SERVER_ERROR",
        transaction: tx,
        info: { urls, errorMessages }
      });
    }
    _wrapBlock(value, network) {
      return new Block(formatBlock(value), this);
    }
    _wrapLog(value, network) {
      return new Log(formatLog(value), this);
    }
    _wrapTransactionReceipt(value, network) {
      return new TransactionReceipt(formatTransactionReceipt(value), this);
    }
    _wrapTransactionResponse(tx, network) {
      return new TransactionResponse(formatTransactionResponse(tx), this);
    }
    _detectNetwork() {
      assert2(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
        operation: "_detectNetwork"
      });
    }
    async _perform(req) {
      assert2(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
        operation: req.method,
        info: req
      });
    }
    async getBlockNumber() {
      const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
      if (this.#lastBlockNumber >= 0) {
        this.#lastBlockNumber = blockNumber;
      }
      return blockNumber;
    }
    _getAddress(address) {
      return resolveAddress(address, this);
    }
    _getBlockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      switch (blockTag) {
        case "earliest":
          return "0x0";
        case "finalized":
        case "latest":
        case "pending":
        case "safe":
          return blockTag;
      }
      if (isHexString(blockTag)) {
        if (isHexString(blockTag, 32)) {
          return blockTag;
        }
        return toQuantity(blockTag);
      }
      if (typeof blockTag === "bigint") {
        blockTag = getNumber(blockTag, "blockTag");
      }
      if (typeof blockTag === "number") {
        if (blockTag >= 0) {
          return toQuantity(blockTag);
        }
        if (this.#lastBlockNumber >= 0) {
          return toQuantity(this.#lastBlockNumber + blockTag);
        }
        return this.getBlockNumber().then((b7) => toQuantity(b7 + blockTag));
      }
      assertArgument(false, "invalid blockTag", "blockTag", blockTag);
    }
    _getFilter(filter) {
      const topics = (filter.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      });
      const blockHash = "blockHash" in filter ? filter.blockHash : void 0;
      const resolve2 = (_address, fromBlock2, toBlock2) => {
        let address2 = void 0;
        switch (_address.length) {
          case 0:
            break;
          case 1:
            address2 = _address[0];
            break;
          default:
            _address.sort();
            address2 = _address;
        }
        if (blockHash) {
          if (fromBlock2 != null || toBlock2 != null) {
            throw new Error("invalid filter");
          }
        }
        const filter2 = {};
        if (address2) {
          filter2.address = address2;
        }
        if (topics.length) {
          filter2.topics = topics;
        }
        if (fromBlock2) {
          filter2.fromBlock = fromBlock2;
        }
        if (toBlock2) {
          filter2.toBlock = toBlock2;
        }
        if (blockHash) {
          filter2.blockHash = blockHash;
        }
        return filter2;
      };
      let address = [];
      if (filter.address) {
        if (Array.isArray(filter.address)) {
          for (const addr of filter.address) {
            address.push(this._getAddress(addr));
          }
        } else {
          address.push(this._getAddress(filter.address));
        }
      }
      let fromBlock = void 0;
      if ("fromBlock" in filter) {
        fromBlock = this._getBlockTag(filter.fromBlock);
      }
      let toBlock = void 0;
      if ("toBlock" in filter) {
        toBlock = this._getBlockTag(filter.toBlock);
      }
      if (address.filter((a4) => typeof a4 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
        return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
          return resolve2(result[0], result[1], result[2]);
        });
      }
      return resolve2(address, fromBlock, toBlock);
    }
    _getTransactionRequest(_request) {
      const request = copyRequest(_request);
      const promises = [];
      ["to", "from"].forEach((key) => {
        if (request[key] == null) {
          return;
        }
        const addr = resolveAddress(request[key], this);
        if (isPromise(addr)) {
          promises.push(async function() {
            request[key] = await addr;
          }());
        } else {
          request[key] = addr;
        }
      });
      if (request.blockTag != null) {
        const blockTag = this._getBlockTag(request.blockTag);
        if (isPromise(blockTag)) {
          promises.push(async function() {
            request.blockTag = await blockTag;
          }());
        } else {
          request.blockTag = blockTag;
        }
      }
      if (promises.length) {
        return async function() {
          await Promise.all(promises);
          return request;
        }();
      }
      return request;
    }
    async getNetwork() {
      if (this.#networkPromise == null) {
        const detectNetwork = (async () => {
          try {
            const network = await this._detectNetwork();
            this.emit("network", network, null);
            return network;
          } catch (error2) {
            if (this.#networkPromise === detectNetwork) {
              this.#networkPromise = null;
            }
            throw error2;
          }
        })();
        this.#networkPromise = detectNetwork;
        return (await detectNetwork).clone();
      }
      const networkPromise = this.#networkPromise;
      const [expected, actual] = await Promise.all([
        networkPromise,
        this._detectNetwork()
      ]);
      if (expected.chainId !== actual.chainId) {
        if (this.#anyNetwork) {
          this.emit("network", actual, expected);
          if (this.#networkPromise === networkPromise) {
            this.#networkPromise = Promise.resolve(actual);
          }
        } else {
          assert2(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
            event: "changed"
          });
        }
      }
      return expected.clone();
    }
    async getFeeData() {
      const network = await this.getNetwork();
      const getFeeDataFunc = async () => {
        const { _block, gasPrice, priorityFee } = await resolveProperties({
          _block: this.#getBlock("latest", false),
          gasPrice: (async () => {
            try {
              const value = await this.#perform({ method: "getGasPrice" });
              return getBigInt(value, "%response");
            } catch (error2) {
            }
            return null;
          })(),
          priorityFee: (async () => {
            try {
              const value = await this.#perform({ method: "getPriorityFee" });
              return getBigInt(value, "%response");
            } catch (error2) {
            }
            return null;
          })()
        });
        let maxFeePerGas = null;
        let maxPriorityFeePerGas = null;
        const block = this._wrapBlock(_block, network);
        if (block && block.baseFeePerGas) {
          maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
          maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
        }
        return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
      };
      const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      if (plugin) {
        const req = new FetchRequest(plugin.url);
        const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
        return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
      }
      return await getFeeDataFunc();
    }
    async estimateGas(_tx) {
      let tx = this._getTransactionRequest(_tx);
      if (isPromise(tx)) {
        tx = await tx;
      }
      return getBigInt(await this.#perform({
        method: "estimateGas",
        transaction: tx
      }), "%response");
    }
    async #call(tx, blockTag, attempt) {
      assert2(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
        reason: "TOO_MANY_REDIRECTS",
        transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
      });
      const transaction = copyRequest(tx);
      try {
        return hexlify(await this._perform({ method: "call", transaction, blockTag }));
      } catch (error2) {
        if (!this.disableCcipRead && isCallException(error2) && error2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && dataSlice(error2.data, 0, 4) === "0x556f1830") {
          const data = error2.data;
          const txSender = await resolveAddress(transaction.to, this);
          let ccipArgs;
          try {
            ccipArgs = parseOffchainLookup(dataSlice(error2.data, 4));
          } catch (error3) {
            assert2(false, error3.message, "OFFCHAIN_FAULT", {
              reason: "BAD_DATA",
              transaction,
              info: { data }
            });
          }
          assert2(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
            action: "call",
            data,
            reason: "OffchainLookup",
            transaction,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: ccipArgs.errorArgs
            }
          });
          const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
          assert2(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
            reason: "FETCH_FAILED",
            transaction,
            info: { data: error2.data, errorArgs: ccipArgs.errorArgs }
          });
          const tx2 = {
            to: txSender,
            data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
          };
          this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
          try {
            const result = await this.#call(tx2, blockTag, attempt + 1);
            this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
            return result;
          } catch (error3) {
            this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error3 });
            throw error3;
          }
        }
        throw error2;
      }
    }
    async #checkNetwork(promise) {
      const { value } = await resolveProperties({
        network: this.getNetwork(),
        value: promise
      });
      return value;
    }
    async call(_tx) {
      const { tx, blockTag } = await resolveProperties({
        tx: this._getTransactionRequest(_tx),
        blockTag: this._getBlockTag(_tx.blockTag)
      });
      return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1));
    }
    async #getAccountValue(request, _address, _blockTag) {
      let address = this._getAddress(_address);
      let blockTag = this._getBlockTag(_blockTag);
      if (typeof address !== "string" || typeof blockTag !== "string") {
        [address, blockTag] = await Promise.all([address, blockTag]);
      }
      return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));
    }
    async getBalance(address, blockTag) {
      return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address, blockTag), "%response");
    }
    async getTransactionCount(address, blockTag) {
      return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address, blockTag), "%response");
    }
    async getCode(address, blockTag) {
      return hexlify(await this.#getAccountValue({ method: "getCode" }, address, blockTag));
    }
    async getStorage(address, _position, blockTag) {
      const position = getBigInt(_position, "position");
      return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address, blockTag));
    }
    async broadcastTransaction(signedTx) {
      const { blockNumber, hash: hash2, network } = await resolveProperties({
        blockNumber: this.getBlockNumber(),
        hash: this._perform({
          method: "broadcastTransaction",
          signedTransaction: signedTx
        }),
        network: this.getNetwork()
      });
      const tx = Transaction.from(signedTx);
      if (tx.hash !== hash2) {
        throw new Error("@TODO: the returned hash did not match");
      }
      return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
    }
    async #getBlock(block, includeTransactions) {
      if (isHexString(block, 32)) {
        return await this.#perform({
          method: "getBlock",
          blockHash: block,
          includeTransactions
        });
      }
      let blockTag = this._getBlockTag(block);
      if (typeof blockTag !== "string") {
        blockTag = await blockTag;
      }
      return await this.#perform({
        method: "getBlock",
        blockTag,
        includeTransactions
      });
    }
    async getBlock(block, prefetchTxs) {
      const { network, params } = await resolveProperties({
        network: this.getNetwork(),
        params: this.#getBlock(block, !!prefetchTxs)
      });
      if (params == null) {
        return null;
      }
      return this._wrapBlock(params, network);
    }
    async getTransaction(hash2) {
      const { network, params } = await resolveProperties({
        network: this.getNetwork(),
        params: this.#perform({ method: "getTransaction", hash: hash2 })
      });
      if (params == null) {
        return null;
      }
      return this._wrapTransactionResponse(params, network);
    }
    async getTransactionReceipt(hash2) {
      const { network, params } = await resolveProperties({
        network: this.getNetwork(),
        params: this.#perform({ method: "getTransactionReceipt", hash: hash2 })
      });
      if (params == null) {
        return null;
      }
      if (params.gasPrice == null && params.effectiveGasPrice == null) {
        const tx = await this.#perform({ method: "getTransaction", hash: hash2 });
        if (tx == null) {
          throw new Error("report this; could not find tx or effectiveGasPrice");
        }
        params.effectiveGasPrice = tx.gasPrice;
      }
      return this._wrapTransactionReceipt(params, network);
    }
    async getTransactionResult(hash2) {
      const { result } = await resolveProperties({
        network: this.getNetwork(),
        result: this.#perform({ method: "getTransactionResult", hash: hash2 })
      });
      if (result == null) {
        return null;
      }
      return hexlify(result);
    }
    async getLogs(_filter) {
      let filter = this._getFilter(_filter);
      if (isPromise(filter)) {
        filter = await filter;
      }
      const { network, params } = await resolveProperties({
        network: this.getNetwork(),
        params: this.#perform({ method: "getLogs", filter })
      });
      return params.map((p6) => this._wrapLog(p6, network));
    }
    _getProvider(chainId) {
      assert2(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
        operation: "_getProvider()"
      });
    }
    async getResolver(name) {
      return await EnsResolver.fromName(this, name);
    }
    async getAvatar(name) {
      const resolver = await this.getResolver(name);
      if (resolver) {
        return await resolver.getAvatar();
      }
      return null;
    }
    async resolveName(name) {
      const resolver = await this.getResolver(name);
      if (resolver) {
        return await resolver.getAddress();
      }
      return null;
    }
    async lookupAddress(address) {
      address = getAddress(address);
      const node = namehash(address.substring(2).toLowerCase() + ".addr.reverse");
      try {
        const ensAddr = await EnsResolver.getEnsAddress(this);
        const ensContract = new Contract(ensAddr, [
          "function resolver(bytes32) view returns (address)"
        ], this);
        const resolver = await ensContract.resolver(node);
        if (resolver == null || resolver === ZeroAddress) {
          return null;
        }
        const resolverContract = new Contract(resolver, [
          "function name(bytes32) view returns (string)"
        ], this);
        const name = await resolverContract.name(node);
        const check = await this.resolveName(name);
        if (check !== address) {
          return null;
        }
        return name;
      } catch (error2) {
        if (isError(error2, "BAD_DATA") && error2.value === "0x") {
          return null;
        }
        if (isError(error2, "CALL_EXCEPTION")) {
          return null;
        }
        throw error2;
      }
      return null;
    }
    async waitForTransaction(hash2, _confirms, timeout) {
      const confirms = _confirms != null ? _confirms : 1;
      if (confirms === 0) {
        return this.getTransactionReceipt(hash2);
      }
      return new Promise(async (resolve2, reject) => {
        let timer = null;
        const listener = async (blockNumber) => {
          try {
            const receipt = await this.getTransactionReceipt(hash2);
            if (receipt != null) {
              if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                resolve2(receipt);
                if (timer) {
                  clearTimeout(timer);
                  timer = null;
                }
                return;
              }
            }
          } catch (error2) {
            console.log("EEE", error2);
          }
          this.once("block", listener);
        };
        if (timeout != null) {
          timer = setTimeout(() => {
            if (timer == null) {
              return;
            }
            timer = null;
            this.off("block", listener);
            reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
          }, timeout);
        }
        listener(await this.getBlockNumber());
      });
    }
    async waitForBlock(blockTag) {
      assert2(false, "not implemented yet", "NOT_IMPLEMENTED", {
        operation: "waitForBlock"
      });
    }
    _clearTimeout(timerId) {
      const timer = this.#timers.get(timerId);
      if (!timer) {
        return;
      }
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      this.#timers.delete(timerId);
    }
    _setTimeout(_func, timeout) {
      if (timeout == null) {
        timeout = 0;
      }
      const timerId = this.#nextTimer++;
      const func = () => {
        this.#timers.delete(timerId);
        _func();
      };
      if (this.paused) {
        this.#timers.set(timerId, { timer: null, func, time: timeout });
      } else {
        const timer = setTimeout(func, timeout);
        this.#timers.set(timerId, { timer, func, time: getTime() });
      }
      return timerId;
    }
    _forEachSubscriber(func) {
      for (const sub2 of this.#subs.values()) {
        func(sub2.subscriber);
      }
    }
    _getSubscriber(sub2) {
      switch (sub2.type) {
        case "debug":
        case "error":
        case "network":
          return new UnmanagedSubscriber(sub2.type);
        case "block": {
          const subscriber = new PollingBlockSubscriber(this);
          subscriber.pollingInterval = this.pollingInterval;
          return subscriber;
        }
        case "safe":
        case "finalized":
          return new PollingBlockTagSubscriber(this, sub2.type);
        case "event":
          return new PollingEventSubscriber(this, sub2.filter);
        case "transaction":
          return new PollingTransactionSubscriber(this, sub2.hash);
        case "orphan":
          return new PollingOrphanSubscriber(this, sub2.filter);
      }
      throw new Error(`unsupported event: ${sub2.type}`);
    }
    _recoverSubscriber(oldSub, newSub) {
      for (const sub2 of this.#subs.values()) {
        if (sub2.subscriber === oldSub) {
          if (sub2.started) {
            sub2.subscriber.stop();
          }
          sub2.subscriber = newSub;
          if (sub2.started) {
            newSub.start();
          }
          if (this.#pausedState != null) {
            newSub.pause(this.#pausedState);
          }
          break;
        }
      }
    }
    async #hasSub(event, emitArgs) {
      let sub2 = await getSubscription(event, this);
      if (sub2.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
        sub2 = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
      }
      return this.#subs.get(sub2.tag) || null;
    }
    async #getSub(event) {
      const subscription = await getSubscription(event, this);
      const tag = subscription.tag;
      let sub2 = this.#subs.get(tag);
      if (!sub2) {
        const subscriber = this._getSubscriber(subscription);
        const addressableMap = /* @__PURE__ */ new WeakMap();
        const nameMap = /* @__PURE__ */ new Map();
        sub2 = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
        this.#subs.set(tag, sub2);
      }
      return sub2;
    }
    async on(event, listener) {
      const sub2 = await this.#getSub(event);
      sub2.listeners.push({ listener, once: false });
      if (!sub2.started) {
        sub2.subscriber.start();
        sub2.started = true;
        if (this.#pausedState != null) {
          sub2.subscriber.pause(this.#pausedState);
        }
      }
      return this;
    }
    async once(event, listener) {
      const sub2 = await this.#getSub(event);
      sub2.listeners.push({ listener, once: true });
      if (!sub2.started) {
        sub2.subscriber.start();
        sub2.started = true;
        if (this.#pausedState != null) {
          sub2.subscriber.pause(this.#pausedState);
        }
      }
      return this;
    }
    async emit(event, ...args) {
      const sub2 = await this.#hasSub(event, args);
      if (!sub2 || sub2.listeners.length === 0) {
        return false;
      }
      const count = sub2.listeners.length;
      sub2.listeners = sub2.listeners.filter(({ listener, once }) => {
        const payload = new EventPayload(this, once ? null : listener, event);
        try {
          listener.call(this, ...args, payload);
        } catch (error2) {
        }
        return !once;
      });
      if (sub2.listeners.length === 0) {
        if (sub2.started) {
          sub2.subscriber.stop();
        }
        this.#subs.delete(sub2.tag);
      }
      return count > 0;
    }
    async listenerCount(event) {
      if (event) {
        const sub2 = await this.#hasSub(event);
        if (!sub2) {
          return 0;
        }
        return sub2.listeners.length;
      }
      let total = 0;
      for (const { listeners } of this.#subs.values()) {
        total += listeners.length;
      }
      return total;
    }
    async listeners(event) {
      if (event) {
        const sub2 = await this.#hasSub(event);
        if (!sub2) {
          return [];
        }
        return sub2.listeners.map(({ listener }) => listener);
      }
      let result = [];
      for (const { listeners } of this.#subs.values()) {
        result = result.concat(listeners.map(({ listener }) => listener));
      }
      return result;
    }
    async off(event, listener) {
      const sub2 = await this.#hasSub(event);
      if (!sub2) {
        return this;
      }
      if (listener) {
        const index = sub2.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
        if (index >= 0) {
          sub2.listeners.splice(index, 1);
        }
      }
      if (!listener || sub2.listeners.length === 0) {
        if (sub2.started) {
          sub2.subscriber.stop();
        }
        this.#subs.delete(sub2.tag);
      }
      return this;
    }
    async removeAllListeners(event) {
      if (event) {
        const { tag, started, subscriber } = await this.#getSub(event);
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      } else {
        for (const [tag, { started, subscriber }] of this.#subs) {
          if (started) {
            subscriber.stop();
          }
          this.#subs.delete(tag);
        }
      }
      return this;
    }
    async addListener(event, listener) {
      return await this.on(event, listener);
    }
    async removeListener(event, listener) {
      return this.off(event, listener);
    }
    get destroyed() {
      return this.#destroyed;
    }
    destroy() {
      this.removeAllListeners();
      for (const timerId of this.#timers.keys()) {
        this._clearTimeout(timerId);
      }
      this.#destroyed = true;
    }
    get paused() {
      return this.#pausedState != null;
    }
    set paused(pause) {
      if (!!pause === this.paused) {
        return;
      }
      if (this.paused) {
        this.resume();
      } else {
        this.pause(false);
      }
    }
    pause(dropWhilePaused) {
      this.#lastBlockNumber = -1;
      if (this.#pausedState != null) {
        if (this.#pausedState == !!dropWhilePaused) {
          return;
        }
        assert2(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
          operation: "pause"
        });
      }
      this._forEachSubscriber((s3) => s3.pause(dropWhilePaused));
      this.#pausedState = !!dropWhilePaused;
      for (const timer of this.#timers.values()) {
        if (timer.timer) {
          clearTimeout(timer.timer);
        }
        timer.time = getTime() - timer.time;
      }
    }
    resume() {
      if (this.#pausedState == null) {
        return;
      }
      this._forEachSubscriber((s3) => s3.resume());
      this.#pausedState = null;
      for (const timer of this.#timers.values()) {
        let timeout = timer.time;
        if (timeout < 0) {
          timeout = 0;
        }
        timer.time = getTime();
        setTimeout(timer.func, timeout);
      }
    }
  };
  function _parseString(result, start) {
    try {
      const bytes2 = _parseBytes(result, start);
      if (bytes2) {
        return toUtf8String(bytes2);
      }
    } catch (error2) {
    }
    return null;
  }
  function _parseBytes(result, start) {
    if (result === "0x") {
      return null;
    }
    try {
      const offset = getNumber(dataSlice(result, start, start + 32));
      const length2 = getNumber(dataSlice(result, offset, offset + 32));
      return dataSlice(result, offset + 32, offset + 32 + length2);
    } catch (error2) {
    }
    return null;
  }
  function numPad(value) {
    const result = toBeArray(value);
    if (result.length > 32) {
      throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
  }
  function bytesPad(value) {
    if (value.length % 32 === 0) {
      return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
  }
  var empty = new Uint8Array([]);
  function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    for (let i4 = 0; i4 < datas.length; i4++) {
      result.push(empty);
      byteCount += 32;
    }
    for (let i4 = 0; i4 < datas.length; i4++) {
      const data = getBytes(datas[i4]);
      result[i4] = numPad(byteCount);
      result.push(numPad(data.length));
      result.push(bytesPad(data));
      byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return concat(result);
  }
  var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
  function parseOffchainLookup(data) {
    const result = {
      sender: "",
      urls: [],
      calldata: "",
      selector: "",
      extraData: "",
      errorArgs: []
    };
    assert2(dataLength(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
      reason: "insufficient OffchainLookup data"
    });
    const sender = dataSlice(data, 0, 32);
    assert2(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup sender"
    });
    result.sender = dataSlice(sender, 12);
    try {
      const urls = [];
      const urlsOffset = getNumber(dataSlice(data, 32, 64));
      const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));
      const urlsData = dataSlice(data, urlsOffset + 32);
      for (let u4 = 0; u4 < urlsLength; u4++) {
        const url2 = _parseString(urlsData, u4 * 32);
        if (url2 == null) {
          throw new Error("abort");
        }
        urls.push(url2);
      }
      result.urls = urls;
    } catch (error2) {
      assert2(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup urls"
      });
    }
    try {
      const calldata = _parseBytes(data, 64);
      if (calldata == null) {
        throw new Error("abort");
      }
      result.calldata = calldata;
    } catch (error2) {
      assert2(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup calldata"
      });
    }
    assert2(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup callbaackSelector"
    });
    result.selector = dataSlice(data, 96, 100);
    try {
      const extraData = _parseBytes(data, 128);
      if (extraData == null) {
        throw new Error("abort");
      }
      result.extraData = extraData;
    } catch (error2) {
      assert2(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup extraData"
      });
    }
    result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k5) => result[k5]);
    return result;
  }
  function checkProvider(signer, operation) {
    if (signer.provider) {
      return signer.provider;
    }
    assert2(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
  }
  async function populate(signer, tx) {
    let pop = copyRequest(tx);
    if (pop.to != null) {
      pop.to = resolveAddress(pop.to, signer);
    }
    if (pop.from != null) {
      const from2 = pop.from;
      pop.from = Promise.all([
        signer.getAddress(),
        resolveAddress(from2, signer)
      ]).then(([address, from3]) => {
        assertArgument(address.toLowerCase() === from3.toLowerCase(), "transaction from mismatch", "tx.from", from3);
        return address;
      });
    } else {
      pop.from = signer.getAddress();
    }
    return await resolveProperties(pop);
  }
  var AbstractSigner = class {
    provider;
    constructor(provider) {
      defineProperties(this, { provider: provider || null });
    }
    async getNonce(blockTag) {
      return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
    }
    async populateCall(tx) {
      const pop = await populate(this, tx);
      return pop;
    }
    async populateTransaction(tx) {
      const provider = checkProvider(this, "populateTransaction");
      const pop = await populate(this, tx);
      if (pop.nonce == null) {
        pop.nonce = await this.getNonce("pending");
      }
      if (pop.gasLimit == null) {
        pop.gasLimit = await this.estimateGas(pop);
      }
      const network = await this.provider.getNetwork();
      if (pop.chainId != null) {
        const chainId = getBigInt(pop.chainId);
        assertArgument(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
      } else {
        pop.chainId = network.chainId;
      }
      const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
      if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
        assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
      } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
        assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
      }
      if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
        pop.type = 2;
      } else if (pop.type === 0 || pop.type === 1) {
        const feeData = await provider.getFeeData();
        assert2(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
          operation: "getGasPrice"
        });
        if (pop.gasPrice == null) {
          pop.gasPrice = feeData.gasPrice;
        }
      } else {
        const feeData = await provider.getFeeData();
        if (pop.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            pop.type = 2;
            if (pop.gasPrice != null) {
              const gasPrice = pop.gasPrice;
              delete pop.gasPrice;
              pop.maxFeePerGas = gasPrice;
              pop.maxPriorityFeePerGas = gasPrice;
            } else {
              if (pop.maxFeePerGas == null) {
                pop.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (pop.maxPriorityFeePerGas == null) {
                pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            assert2(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
              operation: "populateTransaction"
            });
            if (pop.gasPrice == null) {
              pop.gasPrice = feeData.gasPrice;
            }
            pop.type = 0;
          } else {
            assert2(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
              operation: "signer.getFeeData"
            });
          }
        } else if (pop.type === 2 || pop.type === 3) {
          if (pop.maxFeePerGas == null) {
            pop.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (pop.maxPriorityFeePerGas == null) {
            pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      return await resolveProperties(pop);
    }
    async estimateGas(tx) {
      return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
    }
    async call(tx) {
      return checkProvider(this, "call").call(await this.populateCall(tx));
    }
    async resolveName(name) {
      const provider = checkProvider(this, "resolveName");
      return await provider.resolveName(name);
    }
    async sendTransaction(tx) {
      const provider = checkProvider(this, "sendTransaction");
      const pop = await this.populateTransaction(tx);
      delete pop.from;
      const txObj = Transaction.from(pop);
      return await provider.broadcastTransaction(await this.signTransaction(txObj));
    }
  };
  function copy(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  var FilterIdSubscriber = class {
    #provider;
    #filterIdPromise;
    #poller;
    #running;
    #network;
    #hault;
    constructor(provider) {
      this.#provider = provider;
      this.#filterIdPromise = null;
      this.#poller = this.#poll.bind(this);
      this.#running = false;
      this.#network = null;
      this.#hault = false;
    }
    _subscribe(provider) {
      throw new Error("subclasses must override this");
    }
    _emitResults(provider, result) {
      throw new Error("subclasses must override this");
    }
    _recover(provider) {
      throw new Error("subclasses must override this");
    }
    async #poll(blockNumber) {
      try {
        if (this.#filterIdPromise == null) {
          this.#filterIdPromise = this._subscribe(this.#provider);
        }
        let filterId = null;
        try {
          filterId = await this.#filterIdPromise;
        } catch (error2) {
          if (!isError(error2, "UNSUPPORTED_OPERATION") || error2.operation !== "eth_newFilter") {
            throw error2;
          }
        }
        if (filterId == null) {
          this.#filterIdPromise = null;
          this.#provider._recoverSubscriber(this, this._recover(this.#provider));
          return;
        }
        const network = await this.#provider.getNetwork();
        if (!this.#network) {
          this.#network = network;
        }
        if (this.#network.chainId !== network.chainId) {
          throw new Error("chaid changed");
        }
        if (this.#hault) {
          return;
        }
        const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
        await this._emitResults(this.#provider, result);
      } catch (error2) {
        console.log("@TODO", error2);
      }
      this.#provider.once("block", this.#poller);
    }
    #teardown() {
      const filterIdPromise = this.#filterIdPromise;
      if (filterIdPromise) {
        this.#filterIdPromise = null;
        filterIdPromise.then((filterId) => {
          if (this.#provider.destroyed) {
            return;
          }
          this.#provider.send("eth_uninstallFilter", [filterId]);
        });
      }
    }
    start() {
      if (this.#running) {
        return;
      }
      this.#running = true;
      this.#poll(-2);
    }
    stop() {
      if (!this.#running) {
        return;
      }
      this.#running = false;
      this.#hault = true;
      this.#teardown();
      this.#provider.off("block", this.#poller);
    }
    pause(dropWhilePaused) {
      if (dropWhilePaused) {
        this.#teardown();
      }
      this.#provider.off("block", this.#poller);
    }
    resume() {
      this.start();
    }
  };
  var FilterIdEventSubscriber = class extends FilterIdSubscriber {
    #event;
    constructor(provider, filter) {
      super(provider);
      this.#event = copy(filter);
    }
    _recover(provider) {
      return new PollingEventSubscriber(provider, this.#event);
    }
    async _subscribe(provider) {
      const filterId = await provider.send("eth_newFilter", [this.#event]);
      return filterId;
    }
    async _emitResults(provider, results) {
      for (const result of results) {
        provider.emit(this.#event, provider._wrapLog(result, provider._network));
      }
    }
  };
  var FilterIdPendingSubscriber = class extends FilterIdSubscriber {
    async _subscribe(provider) {
      return await provider.send("eth_newPendingTransactionFilter", []);
    }
    async _emitResults(provider, results) {
      for (const result of results) {
        provider.emit("pending", result);
      }
    }
  };
  var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
  function deepCopy(value) {
    if (value == null || Primitive.indexOf(typeof value) >= 0) {
      return value;
    }
    if (typeof value.getAddress === "function") {
      return value;
    }
    if (Array.isArray(value)) {
      return value.map(deepCopy);
    }
    if (typeof value === "object") {
      return Object.keys(value).reduce((accum, key) => {
        accum[key] = value[key];
        return accum;
      }, {});
    }
    throw new Error(`should not happen: ${value} (${typeof value})`);
  }
  function stall(duration) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, duration);
    });
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  function isPollable(value) {
    return value && typeof value.pollingInterval === "number";
  }
  var defaultOptions = {
    polling: false,
    staticNetwork: null,
    batchStallTime: 10,
    batchMaxSize: 1 << 20,
    batchMaxCount: 100,
    cacheTimeout: 250,
    pollingInterval: 4e3
  };
  var JsonRpcSigner = class extends AbstractSigner {
    address;
    constructor(provider, address) {
      super(provider);
      address = getAddress(address);
      defineProperties(this, { address });
    }
    connect(provider) {
      assert2(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
        operation: "signer.connect"
      });
    }
    async getAddress() {
      return this.address;
    }
    async populateTransaction(tx) {
      return await this.populateCall(tx);
    }
    async sendUncheckedTransaction(_tx) {
      const tx = deepCopy(_tx);
      const promises = [];
      if (tx.from) {
        const _from = tx.from;
        promises.push((async () => {
          const from2 = await resolveAddress(_from, this.provider);
          assertArgument(from2 != null && from2.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
          tx.from = from2;
        })());
      } else {
        tx.from = this.address;
      }
      if (tx.gasLimit == null) {
        promises.push((async () => {
          tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
        })());
      }
      if (tx.to != null) {
        const _to = tx.to;
        promises.push((async () => {
          tx.to = await resolveAddress(_to, this.provider);
        })());
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      const hexTx = this.provider.getRpcTransaction(tx);
      return this.provider.send("eth_sendTransaction", [hexTx]);
    }
    async sendTransaction(tx) {
      const blockNumber = await this.provider.getBlockNumber();
      const hash2 = await this.sendUncheckedTransaction(tx);
      return await new Promise((resolve2, reject) => {
        const timeouts = [1e3, 100];
        let invalids = 0;
        const checkTx = async () => {
          try {
            const tx2 = await this.provider.getTransaction(hash2);
            if (tx2 != null) {
              resolve2(tx2.replaceableTransaction(blockNumber));
              return;
            }
          } catch (error2) {
            if (isError(error2, "CANCELLED") || isError(error2, "BAD_DATA") || isError(error2, "NETWORK_ERROR") || isError(error2, "UNSUPPORTED_OPERATION")) {
              if (error2.info == null) {
                error2.info = {};
              }
              error2.info.sendTransactionHash = hash2;
              reject(error2);
              return;
            }
            if (isError(error2, "INVALID_ARGUMENT")) {
              invalids++;
              if (error2.info == null) {
                error2.info = {};
              }
              error2.info.sendTransactionHash = hash2;
              if (invalids > 10) {
                reject(error2);
                return;
              }
            }
            this.provider.emit("error", makeError("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error: error2 }));
          }
          this.provider._setTimeout(() => {
            checkTx();
          }, timeouts.pop() || 4e3);
        };
        checkTx();
      });
    }
    async signTransaction(_tx) {
      const tx = deepCopy(_tx);
      if (tx.from) {
        const from2 = await resolveAddress(tx.from, this.provider);
        assertArgument(from2 != null && from2.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx.from = from2;
      } else {
        tx.from = this.address;
      }
      const hexTx = this.provider.getRpcTransaction(tx);
      return await this.provider.send("eth_signTransaction", [hexTx]);
    }
    async signMessage(_message) {
      const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
      return await this.provider.send("personal_sign", [
        hexlify(message),
        this.address.toLowerCase()
      ]);
    }
    async signTypedData(domain, types2, _value) {
      const value = deepCopy(_value);
      const populated = await TypedDataEncoder.resolveNames(domain, types2, value, async (value2) => {
        const address = await resolveAddress(value2);
        assertArgument(address != null, "TypedData does not support null address", "value", value2);
        return address;
      });
      return await this.provider.send("eth_signTypedData_v4", [
        this.address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
      ]);
    }
    async unlock(password) {
      return this.provider.send("personal_unlockAccount", [
        this.address.toLowerCase(),
        password,
        null
      ]);
    }
    async _legacySignMessage(_message) {
      const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
      return await this.provider.send("eth_sign", [
        this.address.toLowerCase(),
        hexlify(message)
      ]);
    }
  };
  var JsonRpcApiProvider = class extends AbstractProvider {
    #options;
    #nextId;
    #payloads;
    #drainTimer;
    #notReady;
    #network;
    #pendingDetectNetwork;
    #scheduleDrain() {
      if (this.#drainTimer) {
        return;
      }
      const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
      this.#drainTimer = setTimeout(() => {
        this.#drainTimer = null;
        const payloads = this.#payloads;
        this.#payloads = [];
        while (payloads.length) {
          const batch = [payloads.shift()];
          while (payloads.length) {
            if (batch.length === this.#options.batchMaxCount) {
              break;
            }
            batch.push(payloads.shift());
            const bytes2 = JSON.stringify(batch.map((p6) => p6.payload));
            if (bytes2.length > this.#options.batchMaxSize) {
              payloads.unshift(batch.pop());
              break;
            }
          }
          (async () => {
            const payload = batch.length === 1 ? batch[0].payload : batch.map((p6) => p6.payload);
            this.emit("debug", { action: "sendRpcPayload", payload });
            try {
              const result = await this._send(payload);
              this.emit("debug", { action: "receiveRpcResult", result });
              for (const { resolve: resolve2, reject, payload: payload2 } of batch) {
                if (this.destroyed) {
                  reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                  continue;
                }
                const resp = result.filter((r) => r.id === payload2.id)[0];
                if (resp == null) {
                  const error2 = makeError("missing response for request", "BAD_DATA", {
                    value: result,
                    info: { payload: payload2 }
                  });
                  this.emit("error", error2);
                  reject(error2);
                  continue;
                }
                if ("error" in resp) {
                  reject(this.getRpcError(payload2, resp));
                  continue;
                }
                resolve2(resp.result);
              }
            } catch (error2) {
              this.emit("debug", { action: "receiveRpcError", error: error2 });
              for (const { reject } of batch) {
                reject(error2);
              }
            }
          })();
        }
      }, stallTime);
    }
    constructor(network, options) {
      super(network, options);
      this.#nextId = 1;
      this.#options = Object.assign({}, defaultOptions, options || {});
      this.#payloads = [];
      this.#drainTimer = null;
      this.#network = null;
      this.#pendingDetectNetwork = null;
      {
        let resolve2 = null;
        const promise = new Promise((_resolve) => {
          resolve2 = _resolve;
        });
        this.#notReady = { promise, resolve: resolve2 };
      }
      const staticNetwork = this._getOption("staticNetwork");
      if (typeof staticNetwork === "boolean") {
        assertArgument(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
        if (staticNetwork && network != null) {
          this.#network = Network.from(network);
        }
      } else if (staticNetwork) {
        assertArgument(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
        this.#network = staticNetwork;
      }
    }
    _getOption(key) {
      return this.#options[key];
    }
    get _network() {
      assert2(this.#network, "network is not available yet", "NETWORK_ERROR");
      return this.#network;
    }
    async _perform(req) {
      if (req.method === "call" || req.method === "estimateGas") {
        let tx = req.transaction;
        if (tx && tx.type != null && getBigInt(tx.type)) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = await this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              req = Object.assign({}, req, {
                transaction: Object.assign({}, tx, { type: void 0 })
              });
            }
          }
        }
      }
      const request = this.getRpcRequest(req);
      if (request != null) {
        return await this.send(request.method, request.args);
      }
      return super._perform(req);
    }
    async _detectNetwork() {
      const network = this._getOption("staticNetwork");
      if (network) {
        if (network === true) {
          if (this.#network) {
            return this.#network;
          }
        } else {
          return network;
        }
      }
      if (this.#pendingDetectNetwork) {
        return await this.#pendingDetectNetwork;
      }
      if (this.ready) {
        this.#pendingDetectNetwork = (async () => {
          try {
            const result = Network.from(getBigInt(await this.send("eth_chainId", [])));
            this.#pendingDetectNetwork = null;
            return result;
          } catch (error2) {
            this.#pendingDetectNetwork = null;
            throw error2;
          }
        })();
        return await this.#pendingDetectNetwork;
      }
      this.#pendingDetectNetwork = (async () => {
        const payload = {
          id: this.#nextId++,
          method: "eth_chainId",
          params: [],
          jsonrpc: "2.0"
        };
        this.emit("debug", { action: "sendRpcPayload", payload });
        let result;
        try {
          result = (await this._send(payload))[0];
          this.#pendingDetectNetwork = null;
        } catch (error2) {
          this.#pendingDetectNetwork = null;
          this.emit("debug", { action: "receiveRpcError", error: error2 });
          throw error2;
        }
        this.emit("debug", { action: "receiveRpcResult", result });
        if ("result" in result) {
          return Network.from(getBigInt(result.result));
        }
        throw this.getRpcError(payload, result);
      })();
      return await this.#pendingDetectNetwork;
    }
    _start() {
      if (this.#notReady == null || this.#notReady.resolve == null) {
        return;
      }
      this.#notReady.resolve();
      this.#notReady = null;
      (async () => {
        while (this.#network == null && !this.destroyed) {
          try {
            this.#network = await this._detectNetwork();
          } catch (error2) {
            if (this.destroyed) {
              break;
            }
            console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
            this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error: error2 } }));
            await stall(1e3);
          }
        }
        this.#scheduleDrain();
      })();
    }
    async _waitUntilReady() {
      if (this.#notReady == null) {
        return;
      }
      return await this.#notReady.promise;
    }
    _getSubscriber(sub2) {
      if (sub2.type === "pending") {
        return new FilterIdPendingSubscriber(this);
      }
      if (sub2.type === "event") {
        if (this._getOption("polling")) {
          return new PollingEventSubscriber(this, sub2.filter);
        }
        return new FilterIdEventSubscriber(this, sub2.filter);
      }
      if (sub2.type === "orphan" && sub2.filter.orphan === "drop-log") {
        return new UnmanagedSubscriber("orphan");
      }
      return super._getSubscriber(sub2);
    }
    get ready() {
      return this.#notReady == null;
    }
    getRpcTransaction(tx) {
      const result = {};
      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
        if (tx[key] == null) {
          return;
        }
        let dstKey = key;
        if (key === "gasLimit") {
          dstKey = "gas";
        }
        result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
      });
      ["from", "to", "data"].forEach((key) => {
        if (tx[key] == null) {
          return;
        }
        result[key] = hexlify(tx[key]);
      });
      if (tx.accessList) {
        result["accessList"] = accessListify(tx.accessList);
      }
      if (tx.blobVersionedHashes) {
        result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h6) => h6.toLowerCase());
      }
      return result;
    }
    getRpcRequest(req) {
      switch (req.method) {
        case "chainId":
          return { method: "eth_chainId", args: [] };
        case "getBlockNumber":
          return { method: "eth_blockNumber", args: [] };
        case "getGasPrice":
          return { method: "eth_gasPrice", args: [] };
        case "getPriorityFee":
          return { method: "eth_maxPriorityFeePerGas", args: [] };
        case "getBalance":
          return {
            method: "eth_getBalance",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getTransactionCount":
          return {
            method: "eth_getTransactionCount",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getCode":
          return {
            method: "eth_getCode",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getStorage":
          return {
            method: "eth_getStorageAt",
            args: [
              getLowerCase(req.address),
              "0x" + req.position.toString(16),
              req.blockTag
            ]
          };
        case "broadcastTransaction":
          return {
            method: "eth_sendRawTransaction",
            args: [req.signedTransaction]
          };
        case "getBlock":
          if ("blockTag" in req) {
            return {
              method: "eth_getBlockByNumber",
              args: [req.blockTag, !!req.includeTransactions]
            };
          } else if ("blockHash" in req) {
            return {
              method: "eth_getBlockByHash",
              args: [req.blockHash, !!req.includeTransactions]
            };
          }
          break;
        case "getTransaction":
          return {
            method: "eth_getTransactionByHash",
            args: [req.hash]
          };
        case "getTransactionReceipt":
          return {
            method: "eth_getTransactionReceipt",
            args: [req.hash]
          };
        case "call":
          return {
            method: "eth_call",
            args: [this.getRpcTransaction(req.transaction), req.blockTag]
          };
        case "estimateGas": {
          return {
            method: "eth_estimateGas",
            args: [this.getRpcTransaction(req.transaction)]
          };
        }
        case "getLogs":
          if (req.filter && req.filter.address != null) {
            if (Array.isArray(req.filter.address)) {
              req.filter.address = req.filter.address.map(getLowerCase);
            } else {
              req.filter.address = getLowerCase(req.filter.address);
            }
          }
          return { method: "eth_getLogs", args: [req.filter] };
      }
      return null;
    }
    getRpcError(payload, _error) {
      const { method } = payload;
      const { error: error2 } = _error;
      if (method === "eth_estimateGas" && error2.message) {
        const msg = error2.message;
        if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
          return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: payload.params[0],
            info: { payload, error: error2 }
          });
        }
      }
      if (method === "eth_call" || method === "eth_estimateGas") {
        const result = spelunkData(error2);
        const e7 = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
        e7.info = { error: error2, payload };
        return e7;
      }
      const message = JSON.stringify(spelunkMessage(error2));
      if (typeof error2.message === "string" && error2.message.match(/user denied|ethers-user-denied/i)) {
        const actionMap = {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        };
        return makeError(`user rejected action`, "ACTION_REJECTED", {
          action: actionMap[method] || "unknown",
          reason: "rejected",
          info: { payload, error: error2 }
        });
      }
      if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
        const transaction = payload.params[0];
        if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
          return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction,
            info: { error: error2 }
          });
        }
        if (message.match(/nonce/i) && message.match(/too low/i)) {
          return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error: error2 } });
        }
        if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
          return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error: error2 } });
        }
        if (message.match(/only replay-protected/i)) {
          return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
            operation: method,
            info: { transaction, info: { error: error2 } }
          });
        }
      }
      let unsupported = !!message.match(/the method .* does not exist/i);
      if (!unsupported) {
        if (error2 && error2.details && error2.details.startsWith("Unauthorized method:")) {
          unsupported = true;
        }
      }
      if (unsupported) {
        return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
          operation: payload.method,
          info: { error: error2, payload }
        });
      }
      return makeError("could not coalesce error", "UNKNOWN_ERROR", { error: error2, payload });
    }
    send(method, params) {
      if (this.destroyed) {
        return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
      }
      const id3 = this.#nextId++;
      const promise = new Promise((resolve2, reject) => {
        this.#payloads.push({
          resolve: resolve2,
          reject,
          payload: { method, params, id: id3, jsonrpc: "2.0" }
        });
      });
      this.#scheduleDrain();
      return promise;
    }
    async getSigner(address) {
      if (address == null) {
        address = 0;
      }
      const accountsPromise = this.send("eth_accounts", []);
      if (typeof address === "number") {
        const accounts2 = await accountsPromise;
        if (address >= accounts2.length) {
          throw new Error("no such account");
        }
        return new JsonRpcSigner(this, accounts2[address]);
      }
      const { accounts } = await resolveProperties({
        network: this.getNetwork(),
        accounts: accountsPromise
      });
      address = getAddress(address);
      for (const account of accounts) {
        if (getAddress(account) === address) {
          return new JsonRpcSigner(this, address);
        }
      }
      throw new Error("invalid account");
    }
    async listAccounts() {
      const accounts = await this.send("eth_accounts", []);
      return accounts.map((a4) => new JsonRpcSigner(this, a4));
    }
    destroy() {
      if (this.#drainTimer) {
        clearTimeout(this.#drainTimer);
        this.#drainTimer = null;
      }
      for (const { payload, reject } of this.#payloads) {
        reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
      }
      this.#payloads = [];
      super.destroy();
    }
  };
  var JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
    #pollingInterval;
    constructor(network, options) {
      super(network, options);
      let pollingInterval = this._getOption("pollingInterval");
      if (pollingInterval == null) {
        pollingInterval = defaultOptions.pollingInterval;
      }
      this.#pollingInterval = pollingInterval;
    }
    _getSubscriber(sub2) {
      const subscriber = super._getSubscriber(sub2);
      if (isPollable(subscriber)) {
        subscriber.pollingInterval = this.#pollingInterval;
      }
      return subscriber;
    }
    get pollingInterval() {
      return this.#pollingInterval;
    }
    set pollingInterval(value) {
      if (!Number.isInteger(value) || value < 0) {
        throw new Error("invalid interval");
      }
      this.#pollingInterval = value;
      this._forEachSubscriber((sub2) => {
        if (isPollable(sub2)) {
          sub2.pollingInterval = this.#pollingInterval;
        }
      });
    }
  };
  var JsonRpcProvider = class extends JsonRpcApiPollingProvider {
    #connect;
    constructor(url2, network, options) {
      if (url2 == null) {
        url2 = "http://localhost:8545";
      }
      super(network, options);
      if (typeof url2 === "string") {
        this.#connect = new FetchRequest(url2);
      } else {
        this.#connect = url2.clone();
      }
    }
    _getConnection() {
      return this.#connect.clone();
    }
    async send(method, params) {
      await this._start();
      return await super.send(method, params);
    }
    async _send(payload) {
      const request = this._getConnection();
      request.body = JSON.stringify(payload);
      request.setHeader("content-type", "application/json");
      const response = await request.send();
      response.assertOk();
      let resp = response.bodyJson;
      if (!Array.isArray(resp)) {
        resp = [resp];
      }
      return resp;
    }
  };
  function spelunkData(value) {
    if (value == null) {
      return null;
    }
    if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString(value.data)) {
      return { message: value.message, data: value.data };
    }
    if (typeof value === "object") {
      for (const key in value) {
        const result = spelunkData(value[key]);
        if (result) {
          return result;
        }
      }
      return null;
    }
    if (typeof value === "string") {
      try {
        return spelunkData(JSON.parse(value));
      } catch (error2) {
      }
    }
    return null;
  }
  function _spelunkMessage(value, result) {
    if (value == null) {
      return;
    }
    if (typeof value.message === "string") {
      result.push(value.message);
    }
    if (typeof value === "object") {
      for (const key in value) {
        _spelunkMessage(value[key], result);
      }
    }
    if (typeof value === "string") {
      try {
        return _spelunkMessage(JSON.parse(value), result);
      } catch (error2) {
      }
    }
  }
  function spelunkMessage(value) {
    const result = [];
    _spelunkMessage(value, result);
    return result;
  }
  var defaultMTLevels = 40;
  var defaultValueArraySize = 64;
  var defaultMTLevelsOnChain = 64;
  var defaultMTLevelsClaim = 32;
  var BaseConfig = class {
    getMTLevel() {
      return this.mtLevel ? this.mtLevel : defaultMTLevels;
    }
    getMTLevelsClaim() {
      return this.mtLevelClaim ? this.mtLevelClaim : defaultMTLevelsClaim;
    }
    getValueArrSize() {
      return this.maxValueArraySize ? this.maxValueArraySize : defaultValueArraySize;
    }
    getMTLevelOnChain() {
      return this.mtLevelOnChain ? this.mtLevelOnChain : defaultMTLevelsOnChain;
    }
  };
  var prepareSiblingsStr = (proof, levels) => {
    const siblings = proof.allSiblings();
    for (let i4 = siblings.length; i4 < levels; i4++) {
      siblings.push(M3);
    }
    return siblings.map((s3) => s3.bigInt().toString());
  };
  var prepareCircuitArrayValues = (arr, size) => {
    if (!arr) {
      arr = [];
    }
    if (arr.length > size) {
      throw new Error(`array size ${arr.length} is bigger max expected size ${size}`);
    }
    for (let i4 = arr.length; i4 < size; i4++) {
      arr.push(BigInt(0));
    }
    return arr;
  };
  var bigIntArrayToStringArray = (arr) => {
    return arr.map((a4) => a4.toString());
  };
  var getNodeAuxValue = (p6) => {
    if (p6?.existence) {
      return {
        key: M3,
        value: M3,
        noAux: "0"
      };
    }
    if (p6?.nodeAux?.value !== void 0 && p6?.nodeAux?.key !== void 0) {
      return {
        key: p6.nodeAux.key,
        value: p6.nodeAux.value,
        noAux: "0"
      };
    }
    return {
      key: M3,
      value: M3,
      noAux: "1"
    };
  };
  var XSDNS;
  (function(XSDNS2) {
    XSDNS2["Boolean"] = "http://www.w3.org/2001/XMLSchema#boolean";
    XSDNS2["Integer"] = "http://www.w3.org/2001/XMLSchema#integer";
    XSDNS2["NonNegativeInteger"] = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger";
    XSDNS2["NonPositiveInteger"] = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger";
    XSDNS2["NegativeInteger"] = "http://www.w3.org/2001/XMLSchema#negativeInteger";
    XSDNS2["PositiveInteger"] = "http://www.w3.org/2001/XMLSchema#positiveInteger";
    XSDNS2["DateTime"] = "http://www.w3.org/2001/XMLSchema#dateTime";
    XSDNS2["Double"] = "http://www.w3.org/2001/XMLSchema#double";
    XSDNS2["String"] = "http://www.w3.org/2001/XMLSchema#string";
  })(XSDNS || (XSDNS = {}));
  var Operators;
  (function(Operators2) {
    Operators2[Operators2["NOOP"] = 0] = "NOOP";
    Operators2[Operators2["EQ"] = 1] = "EQ";
    Operators2[Operators2["LT"] = 2] = "LT";
    Operators2[Operators2["GT"] = 3] = "GT";
    Operators2[Operators2["IN"] = 4] = "IN";
    Operators2[Operators2["NIN"] = 5] = "NIN";
    Operators2[Operators2["NE"] = 6] = "NE";
    Operators2[Operators2["LTE"] = 7] = "LTE";
    Operators2[Operators2["GTE"] = 8] = "GTE";
    Operators2[Operators2["BETWEEN"] = 9] = "BETWEEN";
    Operators2[Operators2["NONBETWEEN"] = 10] = "NONBETWEEN";
    Operators2[Operators2["EXISTS"] = 11] = "EXISTS";
    Operators2[Operators2["SD"] = 16] = "SD";
    Operators2[Operators2["NULLIFY"] = 17] = "NULLIFY";
  })(Operators || (Operators = {}));
  var QueryOperators = {
    $noop: Operators.NOOP,
    $eq: Operators.EQ,
    $lt: Operators.LT,
    $gt: Operators.GT,
    $in: Operators.IN,
    $nin: Operators.NIN,
    $ne: Operators.NE,
    $lte: Operators.LTE,
    $gte: Operators.GTE,
    $between: Operators.BETWEEN,
    $nonbetween: Operators.NONBETWEEN,
    $exists: Operators.EXISTS,
    $sd: Operators.SD,
    $nullify: Operators.NULLIFY
  };
  var allOperations$1 = Object.values(QueryOperators);
  var availableTypesOperators = /* @__PURE__ */ new Map([
    [
      XSDNS.Boolean,
      [QueryOperators.$eq, QueryOperators.$ne, QueryOperators.$sd, QueryOperators.$exists]
    ],
    [XSDNS.Integer, allOperations$1],
    [XSDNS.NonNegativeInteger, allOperations$1],
    [XSDNS.PositiveInteger, allOperations$1],
    [
      XSDNS.Double,
      [
        QueryOperators.$eq,
        QueryOperators.$ne,
        QueryOperators.$in,
        QueryOperators.$nin,
        QueryOperators.$sd,
        QueryOperators.$exists
      ]
    ],
    [
      XSDNS.String,
      [
        QueryOperators.$eq,
        QueryOperators.$ne,
        QueryOperators.$in,
        QueryOperators.$nin,
        QueryOperators.$sd,
        QueryOperators.$exists
      ]
    ],
    [XSDNS.DateTime, allOperations$1]
  ]);
  var CircuitId;
  (function(CircuitId2) {
    CircuitId2["AuthV2"] = "authV2";
    CircuitId2["StateTransition"] = "stateTransition";
    CircuitId2["AtomicQueryMTPV2"] = "credentialAtomicQueryMTPV2";
    CircuitId2["AtomicQueryMTPV2OnChain"] = "credentialAtomicQueryMTPV2OnChain";
    CircuitId2["AtomicQuerySigV2"] = "credentialAtomicQuerySigV2";
    CircuitId2["AtomicQuerySigV2OnChain"] = "credentialAtomicQuerySigV2OnChain";
    CircuitId2["AtomicQueryV3"] = "credentialAtomicQueryV3-beta.1";
    CircuitId2["AtomicQueryV3OnChain"] = "credentialAtomicQueryV3OnChain-beta.1";
    CircuitId2["LinkedMultiQuery10"] = "linkedMultiQuery10-beta.1";
  })(CircuitId || (CircuitId = {}));
  var CircuitError;
  (function(CircuitError2) {
    CircuitError2["EmptyAuthClaimProof"] = "empty auth claim mtp proof";
    CircuitError2["EmptyAuthClaimProofInTheNewState"] = "empty auth claim mtp proof in the new state";
    CircuitError2["EmptyAuthClaimNonRevProof"] = "empty auth claim non-revocation mtp proof";
    CircuitError2["EmptyChallengeSignature"] = "empty challenge signature";
    CircuitError2["EmptyClaimSignature"] = "empty claim signature";
    CircuitError2["EmptyClaimProof"] = "empty claim mtp proof";
    CircuitError2["EmptyClaimNonRevProof"] = "empty claim non-revocation mtp proof";
    CircuitError2["EmptyIssuerAuthClaimProof"] = "empty issuer auth claim mtp proof";
    CircuitError2["EmptyIssuerAuthClaimNonRevProof"] = "empty issuer auth claim non-revocation mtp proof";
    CircuitError2["EmptyJsonLDQueryProof"] = "empty JSON-LD query mtp proof";
    CircuitError2["EmptyJsonLDQueryValue"] = "empty JSON-LD query value";
    CircuitError2["EmptyJsonLDQueryPath"] = "empty JSON-LD query path";
    CircuitError2["EmptyQueryValue"] = "empty query value";
    CircuitError2["EmptyJsonLDQueryValues"] = "empty JSON-LD query values";
    CircuitError2["EmptyId"] = "empty Id";
    CircuitError2["EmptyChallenge"] = "empty challenge";
    CircuitError2["EmptyGISTProof"] = "empty GIST merkle tree proof";
    CircuitError2["EmptyTreeState"] = "empty tree state";
    CircuitError2["EmptyRequestID"] = "empty request ID";
    CircuitError2["InvalidProofType"] = "invalid proof type";
    CircuitError2["InvalidValuesArrSize"] = "invalid query Values array size";
    CircuitError2["InvalidOperationType"] = "invalid operation type";
  })(CircuitError || (CircuitError = {}));
  var ValueProof = class {
    constructor() {
      this.path = BigInt(0);
      this.value = BigInt(0);
      this.mtp = new Kt();
    }
    validate() {
      if (typeof this.path !== "bigint") {
        throw new Error(CircuitError.EmptyJsonLDQueryPath);
      }
      if (typeof this.value !== "bigint") {
        throw new Error(CircuitError.EmptyJsonLDQueryValue);
      }
      if (!this.mtp) {
        throw new Error(CircuitError.EmptyJsonLDQueryProof);
      }
    }
  };
  var AtomicQueryMTPV2OnChainPubSignals = class extends BaseConfig {
    pubSignalsUnmarshal(data) {
      const sVals = JSON.parse(byteDecoder.decode(data));
      let fieldIdx = 0;
      this.merklized = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.userID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.circuitQueryHash = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.requestID = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.challenge = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.gistRoot = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.issuerClaimIdenState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.isRevocationChecked = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerClaimNonRevState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.timestamp = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      return this;
    }
    getStatesInfo() {
      return {
        states: [
          { id: this.issuerID, state: this.issuerClaimIdenState },
          { id: this.issuerID, state: this.issuerClaimNonRevState }
        ],
        gists: [{ id: this.userID, root: this.gistRoot }]
      };
    }
  };
  var AtomicQueryV3OnChainPubSignals = class extends BaseConfig {
    pubSignalsUnmarshal(data) {
      const sVals = JSON.parse(byteDecoder.decode(data));
      let fieldIdx = 0;
      this.userID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.circuitQueryHash = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.linkID = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.nullifier = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.operatorOutput = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.proofType = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.requestID = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.challenge = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.gistRoot = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.issuerClaimNonRevState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.timestamp = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.isBJJAuthEnabled = parseInt(sVals[fieldIdx]);
      return this;
    }
    getStatesInfo() {
      return {
        states: [
          { id: this.issuerID, state: this.issuerState },
          { id: this.issuerID, state: this.issuerClaimNonRevState }
        ],
        gists: [{ id: this.userID, root: this.gistRoot }]
      };
    }
  };
  var AtomicQuerySigV2OnChainPubSignals = class extends BaseConfig {
    pubSignalsUnmarshal(data) {
      const sVals = JSON.parse(byteDecoder.decode(data));
      let fieldIdx = 0;
      this.merklized = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.userID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.circuitQueryHash = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerAuthState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.requestID = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.challenge = BigInt(sVals[fieldIdx]);
      fieldIdx++;
      this.gistRoot = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerID = $2.fromBigInt(BigInt(sVals[fieldIdx]));
      fieldIdx++;
      this.isRevocationChecked = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      this.issuerClaimNonRevState = V3.fromString(sVals[fieldIdx]);
      fieldIdx++;
      this.timestamp = parseInt(sVals[fieldIdx]);
      fieldIdx++;
      return this;
    }
    getStatesInfo() {
      return {
        states: [
          { id: this.issuerID, state: this.issuerAuthState },
          { id: this.issuerID, state: this.issuerClaimNonRevState }
        ],
        gists: [{ id: this.userID, root: this.gistRoot }]
      };
    }
  };
  var LinkedMultiQueryInputs = class extends BaseConfig {
    inputsMarshal() {
      const claimPathMtp = [];
      const claimPathMtpNoAux = [];
      const claimPathMtpAuxHi = [];
      const claimPathMtpAuxHv = [];
      const claimPathKey = [];
      const claimPathValue = [];
      const slotIndex = [];
      const operator = [];
      const value = [];
      const valueArraySize = [];
      for (let i4 = 0; i4 < LinkedMultiQueryInputs.queryCount; i4++) {
        if (!this.query[i4]) {
          claimPathMtp.push(new Array(this.getMTLevelsClaim()).fill("0"));
          claimPathMtpNoAux.push("0");
          claimPathMtpAuxHi.push("0");
          claimPathMtpAuxHv.push("0");
          claimPathKey.push("0");
          claimPathValue.push("0");
          slotIndex.push(0);
          operator.push(0);
          const valuesArr2 = prepareCircuitArrayValues([], this.getValueArrSize());
          value.push(bigIntArrayToStringArray(valuesArr2));
          valueArraySize.push(0);
          continue;
        }
        let valueProof = this.query[i4].valueProof;
        if (!valueProof) {
          valueProof = new ValueProof();
          valueProof.path = 0n;
          valueProof.value = 0n;
          valueProof.mtp = new Kt();
        }
        claimPathMtp.push(prepareSiblingsStr(valueProof.mtp, this.getMTLevelsClaim()));
        const nodAuxJSONLD = getNodeAuxValue(valueProof.mtp);
        claimPathMtpNoAux.push(nodAuxJSONLD.noAux);
        claimPathMtpAuxHi.push(nodAuxJSONLD.key.bigInt().toString());
        claimPathMtpAuxHv.push(nodAuxJSONLD.value.bigInt().toString());
        claimPathKey.push(valueProof.path.toString());
        claimPathValue.push(valueProof.value.toString());
        slotIndex.push(this.query[i4].slotIndex);
        operator.push(this.query[i4].operator);
        valueArraySize.push(this.query[i4].values.length);
        const valuesArr = prepareCircuitArrayValues(this.query[i4].values, this.getValueArrSize());
        value.push(bigIntArrayToStringArray(valuesArr));
      }
      const s3 = {
        linkNonce: this.linkNonce.toString(),
        issuerClaim: this.claim.marshalJson(),
        claimSchema: this.claim.getSchemaHash().bigInt().toString(),
        claimPathMtp,
        claimPathMtpNoAux,
        claimPathMtpAuxHi,
        claimPathMtpAuxHv,
        claimPathKey,
        claimPathValue,
        slotIndex,
        operator,
        value,
        valueArraySize
      };
      return byteEncoder.encode(JSON.stringify(s3));
    }
  };
  LinkedMultiQueryInputs.queryCount = 10;
  var TransactionService = class {
    constructor(_provider) {
      this._provider = _provider;
    }
    async getTransactionReceiptAndBlock(txnHash) {
      const receipt = await this._provider.getTransactionReceipt(txnHash);
      const block = await receipt?.getBlock();
      return { receipt: receipt || void 0, block };
    }
    async sendTransactionRequest(signer, request) {
      const tx = await signer.sendTransaction(request);
      const txnReceipt = await tx.wait();
      if (!txnReceipt) {
        throw new Error(`transaction: ${tx.hash} failed to mined`);
      }
      const status = txnReceipt.status;
      const txnHash = txnReceipt.hash;
      if (!status) {
        throw new Error(`transaction: ${txnHash} failed to mined`);
      }
      return { txnHash, txnReceipt };
    }
    async resendTransaction(signer, request, opts) {
      const feeData = await this._provider.getFeeData();
      let { maxFeePerGas, maxPriorityFeePerGas, gasPrice } = feeData;
      if (opts?.increasedFeesPercentage) {
        const multiplyVal = BigInt((opts.increasedFeesPercentage + 100) / 100);
        maxFeePerGas = maxFeePerGas ? maxFeePerGas * multiplyVal : null;
        maxPriorityFeePerGas = maxPriorityFeePerGas ? maxPriorityFeePerGas * multiplyVal : null;
        gasPrice = gasPrice ? gasPrice * multiplyVal : null;
      }
      request.maxFeePerGas = maxFeePerGas;
      request.maxPriorityFeePerGas = maxPriorityFeePerGas;
      request.gasPrice = gasPrice;
      return this.sendTransactionRequest(signer, request);
    }
  };
  var abi$2 = [
    {
      inputs: [],
      name: "InvalidInitialization",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "string",
          name: "message",
          type: "string"
        },
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          internalType: "uint256",
          name: "linkID",
          type: "uint256"
        },
        {
          internalType: "uint64",
          name: "requestIdToCompare",
          type: "uint64"
        },
        {
          internalType: "uint256",
          name: "linkIdToCompare",
          type: "uint256"
        }
      ],
      name: "LinkedProofError",
      type: "error"
    },
    {
      inputs: [],
      name: "NotInitializing",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "OwnableInvalidOwner",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "OwnableUnauthorizedAccount",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint64",
          name: "version",
          type: "uint64"
        }
      ],
      name: "Initialized",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferStarted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "previousOwner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "OwnershipTransferred",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          indexed: true,
          internalType: "address",
          name: "requestOwner",
          type: "address"
        },
        {
          indexed: false,
          internalType: "string",
          name: "metadata",
          type: "string"
        },
        {
          indexed: false,
          internalType: "address",
          name: "validator",
          type: "address"
        },
        {
          indexed: false,
          internalType: "bytes",
          name: "data",
          type: "bytes"
        }
      ],
      name: "ZKPRequestSet",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          indexed: true,
          internalType: "address",
          name: "caller",
          type: "address"
        }
      ],
      name: "ZKPResponseSubmitted",
      type: "event"
    },
    {
      inputs: [],
      name: "REQUESTS_RETURN_LIMIT",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "VERSION",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "acceptOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ICircuitValidator",
          name: "validator",
          type: "address"
        }
      ],
      name: "addValidatorToWhitelist",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "disableZKPRequest",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "enableZKPRequest",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "getProofStatus",
      outputs: [
        {
          components: [
            {
              internalType: "bool",
              name: "isVerified",
              type: "bool"
            },
            {
              internalType: "string",
              name: "validatorVersion",
              type: "string"
            },
            {
              internalType: "uint256",
              name: "blockNumber",
              type: "uint256"
            },
            {
              internalType: "uint256",
              name: "blockTimestamp",
              type: "uint256"
            }
          ],
          internalType: "struct IZKPVerifier.ProofStatus",
          name: "",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "user",
          type: "address"
        },
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          internalType: "string",
          name: "key",
          type: "string"
        }
      ],
      name: "getProofStorageField",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "getRequestOwner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "getZKPRequest",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "metadata",
              type: "string"
            },
            {
              internalType: "contract ICircuitValidator",
              name: "validator",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          internalType: "struct IZKPVerifier.ZKPRequest",
          name: "zkpRequest",
          type: "tuple"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "startIndex",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "length",
          type: "uint256"
        }
      ],
      name: "getZKPRequests",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "metadata",
              type: "string"
            },
            {
              internalType: "contract ICircuitValidator",
              name: "validator",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          internalType: "struct IZKPVerifier.ZKPRequest[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getZKPRequestsCount",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract IStateCrossChain",
          name: "stateCrossChain",
          type: "address"
        }
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "isProofVerified",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ICircuitValidator",
          name: "validator",
          type: "address"
        }
      ],
      name: "isWhitelistedValidator",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "isZKPRequestEnabled",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "owner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pendingOwner",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ICircuitValidator",
          name: "validator",
          type: "address"
        }
      ],
      name: "removeValidatorFromWhitelist",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        }
      ],
      name: "requestIdExists",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          internalType: "address",
          name: "requestOwner",
          type: "address"
        }
      ],
      name: "setRequestOwner",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          components: [
            {
              internalType: "string",
              name: "metadata",
              type: "string"
            },
            {
              internalType: "contract ICircuitValidator",
              name: "validator",
              type: "address"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          internalType: "struct IZKPVerifier.ZKPRequest",
          name: "request",
          type: "tuple"
        }
      ],
      name: "setZKPRequest",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          internalType: "uint256[]",
          name: "inputs",
          type: "uint256[]"
        },
        {
          internalType: "uint256[2]",
          name: "a",
          type: "uint256[2]"
        },
        {
          internalType: "uint256[2][2]",
          name: "b",
          type: "uint256[2][2]"
        },
        {
          internalType: "uint256[2]",
          name: "c",
          type: "uint256[2]"
        }
      ],
      name: "submitZKPResponse",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          components: [
            {
              internalType: "uint64",
              name: "requestId",
              type: "uint64"
            },
            {
              internalType: "bytes",
              name: "zkProof",
              type: "bytes"
            },
            {
              internalType: "bytes",
              name: "data",
              type: "bytes"
            }
          ],
          internalType: "struct ZKPResponse[]",
          name: "responses",
          type: "tuple[]"
        },
        {
          internalType: "bytes",
          name: "crossChainProof",
          type: "bytes"
        }
      ],
      name: "submitZKPResponseV2",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newOwner",
          type: "address"
        }
      ],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "sender",
          type: "address"
        },
        {
          internalType: "uint64[]",
          name: "requestIds",
          type: "uint64[]"
        }
      ],
      name: "verifyLinkedProofs",
      outputs: [],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint64",
          name: "requestId",
          type: "uint64"
        },
        {
          internalType: "uint256[]",
          name: "inputs",
          type: "uint256[]"
        },
        {
          internalType: "uint256[2]",
          name: "a",
          type: "uint256[2]"
        },
        {
          internalType: "uint256[2][2]",
          name: "b",
          type: "uint256[2][2]"
        },
        {
          internalType: "uint256[2]",
          name: "c",
          type: "uint256[2]"
        },
        {
          internalType: "address",
          name: "sender",
          type: "address"
        }
      ],
      name: "verifyZKPResponse",
      outputs: [
        {
          components: [
            {
              internalType: "string",
              name: "key",
              type: "string"
            },
            {
              internalType: "uint256",
              name: "inputValue",
              type: "uint256"
            }
          ],
          internalType: "struct ICircuitValidator.KeyToInputValue[]",
          name: "",
          type: "tuple[]"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "version",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "pure",
      type: "function"
    }
  ];
  var maxGasLimit = 10000000n;
  var FunctionSignatures;
  (function(FunctionSignatures2) {
    FunctionSignatures2["SubmitZKPResponseV1"] = "b68967e2";
    FunctionSignatures2["SubmitZKPResponseV2"] = "ade09fcd";
  })(FunctionSignatures || (FunctionSignatures = {}));
  var OnChainZKPVerifier = class {
    constructor(_configs, _opts) {
      this._configs = _configs;
      this._opts = _opts;
    }
    static async prepareTxArgsSubmitV1(txData, zkProofResponse) {
      if (txData.method_id.replace("0x", "") !== FunctionSignatures.SubmitZKPResponseV1) {
        throw new Error(`prepareTxArgsSubmitV1 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`);
      }
      const requestID = zkProofResponse.id;
      const inputs = zkProofResponse.pub_signals;
      const payload = [
        requestID,
        inputs,
        zkProofResponse.proof.pi_a.slice(0, 2),
        [
          [zkProofResponse.proof.pi_b[0][1], zkProofResponse.proof.pi_b[0][0]],
          [zkProofResponse.proof.pi_b[1][1], zkProofResponse.proof.pi_b[1][0]]
        ],
        zkProofResponse.proof.pi_c.slice(0, 2)
      ];
      return payload;
    }
    async prepareTxArgsSubmitV1(txData, zkProofResponse) {
      return OnChainZKPVerifier.prepareTxArgsSubmitV1(txData, zkProofResponse);
    }
    async submitZKPResponse(ethSigner, txData, zkProofResponses) {
      const chainConfig = this._configs.find((i4) => i4.chainId == txData.chain_id);
      if (!chainConfig) {
        throw new Error(`config for chain id ${txData.chain_id} was not found`);
      }
      if (txData.method_id.replace("0x", "") !== FunctionSignatures.SubmitZKPResponseV1) {
        throw new Error(`submitZKPResponse function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV1}' is supported.`);
      }
      const provider = new JsonRpcProvider(chainConfig.url, chainConfig.chainId);
      ethSigner = ethSigner.connect(provider);
      const response = /* @__PURE__ */ new Map();
      const feeData = await provider.getFeeData();
      const maxFeePerGas = chainConfig.maxFeePerGas ? BigInt(chainConfig.maxFeePerGas) : feeData.maxFeePerGas;
      const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas ? BigInt(chainConfig.maxPriorityFeePerGas) : feeData.maxPriorityFeePerGas;
      const verifierContract = new Contract(txData.contract_address, abi$2);
      for (const zkProofResponse of zkProofResponses) {
        const txArgs = await this.prepareTxArgsSubmitV1(txData, zkProofResponse);
        const payload = await verifierContract.submitZKPResponse.populateTransaction(...txArgs);
        const request = {
          to: txData.contract_address,
          data: payload.data,
          maxFeePerGas,
          maxPriorityFeePerGas
        };
        let gasLimit;
        try {
          gasLimit = await ethSigner.estimateGas(request);
        } catch (e7) {
          gasLimit = maxGasLimit;
        }
        request.gasLimit = gasLimit;
        const transactionService = new TransactionService(provider);
        const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);
        response.set(txnHash, zkProofResponse);
      }
      return response;
    }
    async submitZKPResponseV2(ethSigner, txData, zkProofResponses) {
      const chainConfig = this._configs.find((i4) => i4.chainId == txData.chain_id);
      if (!chainConfig) {
        throw new Error(`config for chain id ${txData.chain_id} was not found`);
      }
      if (txData.method_id.replace("0x", "") !== FunctionSignatures.SubmitZKPResponseV2) {
        throw new Error(`submitZKPResponseV2 function doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`);
      }
      if (!this._opts?.didResolverUrl) {
        throw new Error(`did resolver url required for crosschain verification`);
      }
      const provider = new JsonRpcProvider(chainConfig.url, chainConfig.chainId);
      ethSigner = ethSigner.connect(provider);
      const txDataArgs = await this.prepareTxArgsSubmitV2(txData, zkProofResponses);
      const feeData = await provider.getFeeData();
      const maxFeePerGas = chainConfig.maxFeePerGas ? BigInt(chainConfig.maxFeePerGas) : feeData.maxFeePerGas;
      const maxPriorityFeePerGas = chainConfig.maxPriorityFeePerGas ? BigInt(chainConfig.maxPriorityFeePerGas) : feeData.maxPriorityFeePerGas;
      const verifierContract = new Contract(txData.contract_address, abi$2);
      const txRequestData = await verifierContract.submitZKPResponseV2.populateTransaction(...txDataArgs);
      const request = {
        to: txData.contract_address,
        data: txRequestData.data,
        maxFeePerGas,
        maxPriorityFeePerGas
      };
      let gasLimit;
      try {
        gasLimit = await ethSigner.estimateGas(request);
      } catch (e7) {
        gasLimit = maxGasLimit;
      }
      request.gasLimit = gasLimit;
      const transactionService = new TransactionService(provider);
      const { txnHash } = await transactionService.sendTransactionRequest(ethSigner, request);
      return (/* @__PURE__ */ new Map()).set(txnHash, zkProofResponses);
    }
    static async prepareTxArgsSubmitV2(resolverUrl, txData, zkProofResponses) {
      if (txData.method_id.replace("0x", "") !== FunctionSignatures.SubmitZKPResponseV2) {
        throw new Error(`submit cross chain doesn't implement requested method id. Only '0x${FunctionSignatures.SubmitZKPResponseV2}' is supported.`);
      }
      const gistUpdateArr = [];
      const stateUpdateArr = [];
      const payload = [];
      const gistUpdateResolutionsPending = [];
      const stateUpdateResolutionsPending = [];
      for (const zkProof of zkProofResponses) {
        const requestID = zkProof.id;
        const inputs = zkProof.pub_signals;
        if (!this._supportedCircuits.includes(zkProof.circuitId)) {
          throw new Error(`Circuit ${zkProof.circuitId} not supported by OnChainZKPVerifier`);
        }
        const zkProofEncoded = this.packZkpProof(inputs, zkProof.proof.pi_a.slice(0, 2), [
          [zkProof.proof.pi_b[0][1], zkProof.proof.pi_b[0][0]],
          [zkProof.proof.pi_b[1][1], zkProof.proof.pi_b[1][0]]
        ], zkProof.proof.pi_c.slice(0, 2));
        const stateInfo = this.getOnChainGistRootStatePubSignals(zkProof.circuitId, zkProof.pub_signals);
        const gistUpdateResolutions = [];
        for (const gist of stateInfo.gists) {
          const gistResolutionPending = gistUpdateResolutionsPending.find((g5) => g5 == JSON.stringify(gist));
          if (gistResolutionPending) {
            continue;
          }
          gistUpdateResolutionsPending.push(JSON.stringify(gist));
          gistUpdateResolutions.push(this.resolveDidDocumentEip712MessageAndSignature(Q2.parseFromId(gist.id), resolverUrl, {
            gist: gist.root
          }));
        }
        const stateUpdateResolutions = [];
        for (const state of stateInfo.states) {
          const stateResolutionPending = stateUpdateResolutionsPending.find((s3) => s3 == JSON.stringify(state));
          if (stateResolutionPending) {
            continue;
          }
          stateUpdateResolutionsPending.push(JSON.stringify(state));
          stateUpdateResolutions.push(this.resolveDidDocumentEip712MessageAndSignature(Q2.parseFromId(state.id), resolverUrl, {
            state: state.state
          }));
        }
        if (gistUpdateResolutions.length > 0) {
          gistUpdateArr.push(...await Promise.all(gistUpdateResolutions));
        }
        if (stateUpdateResolutions.length > 0) {
          stateUpdateArr.push(...await Promise.all(stateUpdateResolutions));
        }
        const metadataArr = [];
        if (zkProof.vp) {
          for (const key in zkProof.vp.verifiableCredential.credentialSubject) {
            if (key === "@type") {
              continue;
            }
            const metadataValue = $.hashBytes(byteEncoder.encode(JSON.stringify(zkProof.vp.verifiableCredential.credentialSubject[key])));
            const bytesValue = byteEncoder.encode(metadataValue.toString());
            metadataArr.push({
              key,
              value: bytesValue
            });
          }
        }
        const metadata2 = metadataArr.length ? this.packMetadatas(metadataArr) : "0x";
        payload.push({
          requestId: requestID,
          zkProof: zkProofEncoded,
          data: metadata2
        });
      }
      const crossChainProofs = this.packCrossChainProofs(gistUpdateArr, stateUpdateArr);
      return [payload, crossChainProofs];
    }
    async prepareTxArgsSubmitV2(txData, zkProofResponses) {
      if (!this._opts?.didResolverUrl) {
        throw new Error(`did resolver url required for crosschain verification`);
      }
      return OnChainZKPVerifier.prepareTxArgsSubmitV2(this._opts.didResolverUrl, txData, zkProofResponses);
    }
    static packZkpProof(inputs, a4, b7, c3) {
      return new AbiCoder().encode(["uint256[] inputs", "uint256[2]", "uint256[2][2]", "uint256[2]"], [inputs, a4, b7, c3]);
    }
    static packCrossChainProofs(gistUpdateArr, stateUpdateArr) {
      const proofs = [];
      for (const globalStateUpdate of gistUpdateArr) {
        proofs.push({
          proofType: "globalStateProof",
          proof: this.packGlobalStateMsg(globalStateUpdate)
        });
      }
      for (const stateUpdate of stateUpdateArr) {
        proofs.push({
          proofType: "stateProof",
          proof: this.packIdentityStateMsg(stateUpdate)
        });
      }
      return new AbiCoder().encode(["tuple(string proofType,bytes proof)[]"], [proofs]);
    }
    static packGlobalStateMsg(msg) {
      return new AbiCoder().encode([
        "tuple(tuple(uint256 timestamp,bytes2 idType,uint256 root,uint256 replacedAtTimestamp) globalStateMsg,bytes signature,)"
      ], [msg]);
    }
    static packIdentityStateMsg(msg) {
      return new AbiCoder().encode([
        "tuple(tuple(uint256 timestamp,uint256 id,uint256 state,uint256 replacedAtTimestamp) idStateMsg,bytes signature,)"
      ], [msg]);
    }
    static packMetadatas(metas) {
      return new AbiCoder().encode(["tuple(string key,bytes value)[]"], [metas]);
    }
    static getOnChainGistRootStatePubSignals(onChainCircuitId, inputs) {
      let atomicQueryPubSignals;
      switch (onChainCircuitId) {
        case CircuitId.AtomicQueryMTPV2OnChain:
          atomicQueryPubSignals = new AtomicQueryMTPV2OnChainPubSignals();
          break;
        case CircuitId.AtomicQuerySigV2OnChain:
          atomicQueryPubSignals = new AtomicQuerySigV2OnChainPubSignals();
          break;
        case CircuitId.AtomicQueryV3OnChain:
          atomicQueryPubSignals = new AtomicQueryV3OnChainPubSignals();
          break;
      }
      const encodedInputs = byteEncoder.encode(JSON.stringify(inputs));
      atomicQueryPubSignals.pubSignalsUnmarshal(encodedInputs);
      return atomicQueryPubSignals.getStatesInfo();
    }
    static async resolveDidDocumentEip712MessageAndSignature(did, resolverUrl, opts) {
      const didDoc = await resolveDidDocument(did, resolverUrl, {
        ...opts,
        signature: DIDDocumentSignature.EthereumEip712Signature2021
      });
      if (!didDoc.didResolutionMetadata.proof?.length) {
        throw new Error("No proof found in resolved DID document");
      }
      const message = didDoc.didResolutionMetadata.proof[0].eip712.message;
      const signature = didDoc.didResolutionMetadata.proof[0].proofValue;
      const isGistRequest = opts?.gist && !opts.state;
      if (isGistRequest) {
        return {
          globalStateMsg: {
            timestamp: message.timestamp,
            idType: message.idType,
            root: message.root,
            replacedAtTimestamp: message.replacedAtTimestamp
          },
          signature
        };
      }
      return {
        idStateMsg: {
          timestamp: message.timestamp,
          id: message.id,
          state: message.state,
          replacedAtTimestamp: message.replacedAtTimestamp
        },
        signature
      };
    }
  };
  OnChainZKPVerifier._supportedCircuits = [
    CircuitId.AtomicQueryMTPV2OnChain,
    CircuitId.AtomicQuerySigV2OnChain,
    CircuitId.AtomicQueryV3OnChain
  ];
  var NonMerklizedIssuerInterfaces;
  (function(NonMerklizedIssuerInterfaces2) {
    NonMerklizedIssuerInterfaces2["InterfaceDetection"] = "0x01ffc9a7";
    NonMerklizedIssuerInterfaces2["InterfaceNonMerklizedIssuer"] = "0x58874949";
    NonMerklizedIssuerInterfaces2["InterfaceGetCredential"] = "0x5d1ca631";
  })(NonMerklizedIssuerInterfaces || (NonMerklizedIssuerInterfaces = {}));
  var ValueHashes;
  (function(ValueHashes2) {
    ValueHashes2["BooleanTrue"] = "18586133768512220936620570745912940619677854269274689475585506675881198879027";
    ValueHashes2["BooleanFalse"] = "19014214495641488759237505126948346942972912379615652741039992445865937985820";
  })(ValueHashes || (ValueHashes = {}));
  var MerkleTreeType;
  (function(MerkleTreeType2) {
    MerkleTreeType2[MerkleTreeType2["Claims"] = 0] = "Claims";
    MerkleTreeType2[MerkleTreeType2["Revocations"] = 1] = "Revocations";
    MerkleTreeType2[MerkleTreeType2["Roots"] = 2] = "Roots";
  })(MerkleTreeType || (MerkleTreeType = {}));
  var SearchError;
  (function(SearchError2) {
    SearchError2["NotDefinedQueryKey"] = "not defined query key";
    SearchError2["NotDefinedComparator"] = "not defined comparator";
  })(SearchError || (SearchError = {}));
  var truthyValues = [true, 1, "true"];
  var falsyValues = [false, 0, "false"];
  var equalsComparator = (a4, b7) => {
    if (Array.isArray(a4) && Array.isArray(b7)) {
      return a4.length === b7.length && a4.every((val, index) => val === b7[index]);
    }
    if (!Array.isArray(a4) && Array.isArray(b7)) {
      return b7.includes(a4);
    }
    if (Array.isArray(a4) && !Array.isArray(b7)) {
      return a4.includes(b7);
    }
    a4 = a4;
    b7 = b7;
    if (truthyValues.includes(a4) && truthyValues.includes(b7)) {
      return true;
    }
    if (falsyValues.includes(a4) && falsyValues.includes(b7)) {
      return true;
    }
    return a4 === b7;
  };
  var greaterThan = (a4, b7) => {
    if (Array.isArray(a4) && Array.isArray(b7)) {
      return a4.every((val, index) => val > b7[index]);
    }
    if (!Array.isArray(a4) && Array.isArray(b7)) {
      return b7.every((val) => a4 > val);
    }
    if (Array.isArray(a4) && !Array.isArray(b7)) {
      return a4.every((val) => val > b7);
    }
    return a4 > b7;
  };
  var greaterThanOrEqual = (a4, b7) => {
    if (Array.isArray(a4) && Array.isArray(b7)) {
      return a4.every((val, index) => val >= b7[index]);
    }
    if (!Array.isArray(a4) && Array.isArray(b7)) {
      return b7.every((val) => a4 >= val);
    }
    if (Array.isArray(a4) && !Array.isArray(b7)) {
      return a4.every((val) => val >= b7);
    }
    return a4 >= b7;
  };
  var lessThanOrEqual = (a4, b7) => {
    if (Array.isArray(a4) && Array.isArray(b7)) {
      return a4.every((val, index) => val <= b7[index]);
    }
    if (!Array.isArray(a4) && Array.isArray(b7)) {
      return b7.every((val) => a4 <= val);
    }
    if (Array.isArray(a4) && !Array.isArray(b7)) {
      return a4.every((val) => val <= b7);
    }
    return a4 <= b7;
  };
  var existsComparator = (a4, b7) => {
    if (truthyValues.includes(b7) && typeof a4 !== "undefined") {
      return true;
    }
    if (falsyValues.includes(b7) && (a4 === void 0 || Array.isArray(a4) && !a4.length)) {
      return true;
    }
    return false;
  };
  var inOperator = (a4, b7) => {
    if (Array.isArray(a4) && Array.isArray(b7)) {
      return a4.every((val) => b7.includes(val));
    }
    if (!Array.isArray(a4) && Array.isArray(b7)) {
      return b7.includes(a4);
    }
    if (Array.isArray(a4) && !Array.isArray(b7)) {
      return a4.includes(b7);
    }
    return false;
  };
  var betweenOperator = (a4, b7) => {
    if (!Array.isArray(b7) || b7.length !== 2) {
      throw new Error("$between/$nonbetween operator value should be 2 elements array");
    }
    const [min, max] = b7.map(BigInt);
    const predicate = (val) => val >= min && val <= max;
    if (Array.isArray(a4)) {
      return a4.map(BigInt).every(predicate);
    }
    return predicate(BigInt(a4));
  };
  var comparatorOptions = {
    $noop: () => true,
    $sd: () => true,
    $exists: (a4, b7) => existsComparator(a4, b7),
    $eq: (a4, b7) => equalsComparator(a4, b7),
    $in: (a4, b7) => inOperator(a4, b7),
    $nin: (a4, b7) => !inOperator(a4, b7),
    $gt: (a4, b7) => greaterThan(a4, b7),
    $lt: (a4, b7) => !greaterThanOrEqual(a4, b7),
    $ne: (a4, b7) => !equalsComparator(a4, b7),
    $gte: (a4, b7) => greaterThanOrEqual(a4, b7),
    $lte: (a4, b7) => lessThanOrEqual(a4, b7),
    $between: (a4, b7) => betweenOperator(a4, b7),
    $nonbetween: (a4, b7) => !betweenOperator(a4, b7)
  };
  var resolvePath = (object2, path, defaultValue = null) => {
    const pathParts = path.split(".");
    let o4 = object2;
    for (const part of pathParts) {
      if (o4 === null || o4 === void 0) {
        return defaultValue;
      }
      o4 = o4[part];
    }
    return o4;
  };
  var FilterQuery = class {
    constructor(path, operatorFunc, value, isReverseParams = false) {
      this.path = path;
      this.operatorFunc = operatorFunc;
      this.value = value;
      this.isReverseParams = isReverseParams;
    }
    execute(credential) {
      if (!this.operatorFunc) {
        throw new Error(SearchError.NotDefinedComparator);
      }
      const credentialPathValue = resolvePath(credential, this.path);
      if ((credentialPathValue === null || credentialPathValue === void 0) && this.operatorFunc !== comparatorOptions.$exists) {
        return false;
      }
      if (this.isReverseParams) {
        return this.operatorFunc(this.value, credentialPathValue);
      }
      return this.operatorFunc(credentialPathValue, this.value);
    }
  };
  var StandardJSONCredentialsQueryFilter = (query) => {
    return Object.keys(query).reduce((acc, queryKey) => {
      const queryValue = query[queryKey];
      switch (queryKey) {
        case "claimId":
          return acc.concat(new FilterQuery("id", comparatorOptions.$eq, queryValue));
        case "allowedIssuers": {
          const queryValueParam = queryValue || ["*"];
          if (queryValueParam.includes("*")) {
            return acc;
          }
          return acc.concat(new FilterQuery("issuer", comparatorOptions.$in, queryValue));
        }
        case "type":
          return acc.concat(new FilterQuery("type", comparatorOptions.$in, queryValue, true));
        case "context":
          return acc.concat(new FilterQuery("@context", comparatorOptions.$in, queryValue, true));
        case "credentialSubjectId":
          return acc.concat(new FilterQuery("credentialSubject.id", comparatorOptions.$eq, queryValue));
        case "schema":
          return acc.concat(new FilterQuery("credentialSchema.id", comparatorOptions.$eq, queryValue));
        case "credentialSubject": {
          const reqFilters = Object.keys(queryValue).reduce((acc2, fieldKey) => {
            const fieldParams = queryValue[fieldKey];
            if (typeof fieldParams === "object" && Object.keys(fieldParams).length === 0) {
              return acc2.concat([
                new FilterQuery(`credentialSubject.${fieldKey}`, comparatorOptions.$noop, null)
              ]);
            }
            const res = Object.keys(fieldParams).map((comparator) => {
              const value = fieldParams[comparator];
              const path = `credentialSubject.${fieldKey}`;
              return new FilterQuery(path, comparatorOptions[comparator], value);
            });
            return acc2.concat(res);
          }, []);
          return acc.concat(reqFilters);
        }
        case "proofType":
        case "groupId":
        case "skipClaimRevocationCheck": {
          return acc;
        }
        default:
          throw new Error(`${queryKey} : ${SearchError.NotDefinedQueryKey}`);
      }
    }, []);
  };
  var MERKLE_TREE_TYPES = [
    MerkleTreeType.Claims,
    MerkleTreeType.Revocations,
    MerkleTreeType.Roots
  ];
  var createMerkleTreeMetaInfo = (identifier) => {
    const treesMeta = [];
    for (let index = 0; index < MERKLE_TREE_TYPES.length; index++) {
      const mType = MERKLE_TREE_TYPES[index];
      const treeId = `${identifier}+${mType}`;
      treesMeta.push({ treeId, identifier, type: mType });
    }
    return treesMeta;
  };
  var StorageErrors;
  (function(StorageErrors2) {
    StorageErrors2["ItemNotFound"] = "item not found";
  })(StorageErrors || (StorageErrors = {}));
  var MerkleTreeLocalStorage = class {
    constructor(_mtDepth) {
      this._mtDepth = _mtDepth;
    }
    async createIdentityMerkleTrees(identifier) {
      if (!identifier) {
        identifier = `${v42()}`;
      }
      const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);
      if (meta) {
        const metaInfo = JSON.parse(meta);
        const presentMetaForIdentifier = metaInfo.find((m5) => m5.treeId === `${identifier}+${m5.type}`);
        if (presentMetaForIdentifier) {
          throw new Error(`Present merkle tree meta information in the store for current identifier ${identifier}`);
        }
        const identityMetaInfo = metaInfo.filter((m5) => m5.identifier === identifier);
        if (identityMetaInfo.length > 0) {
          return identityMetaInfo;
        }
        const treesMeta2 = createMerkleTreeMetaInfo(identifier);
        localStorage.setItem(MerkleTreeLocalStorage.storageKeyMeta, JSON.stringify([...metaInfo, ...treesMeta2]));
        return [...metaInfo, ...treesMeta2];
      }
      const treesMeta = createMerkleTreeMetaInfo(identifier);
      localStorage.setItem(MerkleTreeLocalStorage.storageKeyMeta, JSON.stringify(treesMeta));
      return treesMeta;
    }
    async getIdentityMerkleTreesInfo(identifier) {
      const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);
      if (meta) {
        const metaInfo = JSON.parse(meta);
        return metaInfo.filter((m5) => m5.identifier === identifier);
      }
      throw new Error(`Merkle tree meta not found for identifier ${identifier}`);
    }
    async getMerkleTreeByIdentifierAndType(identifier, mtType) {
      const resultMeta = this.getMeta(identifier, mtType);
      return new Jt(new Z3(B3(resultMeta.treeId)), true, this._mtDepth);
    }
    getMeta(identifier, mtType) {
      const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);
      const err = new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);
      if (!meta) {
        throw err;
      }
      const metaInfo = JSON.parse(meta);
      const resultMeta = metaInfo.filter((m5) => m5.identifier === identifier && m5.type === mtType)[0];
      if (!resultMeta) {
        throw err;
      }
      return resultMeta;
    }
    async addToMerkleTree(identifier, mtType, hindex, hvalue) {
      const resultMeta = this.getMeta(identifier, mtType);
      const tree = new Jt(new Z3(B3(resultMeta.treeId)), true, this._mtDepth);
      await tree.add(hindex, hvalue);
    }
    async bindMerkleTreeToNewIdentifier(oldIdentifier, newIdentifier) {
      const meta = localStorage.getItem(MerkleTreeLocalStorage.storageKeyMeta);
      if (!meta) {
        throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);
      }
      const metaInfo = JSON.parse(meta);
      const treesMeta = metaInfo.filter((m5) => m5.identifier === oldIdentifier).map((m5) => ({ ...m5, identifier: newIdentifier }));
      if (treesMeta.length === 0) {
        throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);
      }
      const newMetaInfo = [...metaInfo.filter((m5) => m5.identifier !== oldIdentifier), ...treesMeta];
      localStorage.setItem(MerkleTreeLocalStorage.storageKeyMeta, JSON.stringify(newMetaInfo));
    }
  };
  MerkleTreeLocalStorage.storageKeyMeta = "merkle-tree-meta";
  var MerkleTreeIndexedDBStorage = class {
    constructor(_mtDepth) {
      this._mtDepth = _mtDepth;
      this._merkleTreeMetaStore = createStore(`${MerkleTreeIndexedDBStorage.storageKeyMeta}-db`, MerkleTreeIndexedDBStorage.storageKeyMeta);
      this._bindingStore = createStore(`${MerkleTreeIndexedDBStorage.storageBindingKeyMeta}-db`, MerkleTreeIndexedDBStorage.storageBindingKeyMeta);
    }
    async createIdentityMerkleTrees(identifier) {
      if (!identifier) {
        identifier = `${v42()}`;
      }
      const existingBinging = await get$1(identifier, this._bindingStore);
      if (existingBinging) {
        throw new Error(`Present merkle tree meta information in the store for current identifier ${identifier}`);
      }
      const treesMeta = createMerkleTreeMetaInfo(identifier);
      await set(identifier, treesMeta, this._merkleTreeMetaStore);
      return treesMeta;
    }
    async getIdentityMerkleTreesInfo(identifier) {
      const meta = await get$1(identifier, this._merkleTreeMetaStore);
      if (meta) {
        return meta;
      }
      throw new Error(`Merkle tree meta not found for identifier ${identifier}`);
    }
    async getMerkleTreeByIdentifierAndType(identifier, mtType) {
      const meta = await get$1(identifier, this._merkleTreeMetaStore);
      const err = new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);
      if (!meta) {
        throw err;
      }
      const resultMeta = meta.find((m5) => m5.identifier === identifier && m5.type === mtType);
      if (!resultMeta) {
        throw err;
      }
      return new Jt(new lt(B3(resultMeta.treeId)), true, this._mtDepth);
    }
    async addToMerkleTree(identifier, mtType, hindex, hvalue) {
      const meta = await get$1(identifier, this._merkleTreeMetaStore);
      if (!meta) {
        throw new Error(`Merkle tree meta not found for identifier ${identifier}`);
      }
      const resultMeta = meta.find((m5) => m5.identifier === identifier && m5.type === mtType);
      if (!resultMeta) {
        throw new Error(`Merkle tree not found for identifier ${identifier} and type ${mtType}`);
      }
      const tree = new Jt(new lt(B3(resultMeta.treeId)), true, this._mtDepth);
      await tree.add(hindex, hvalue);
    }
    async bindMerkleTreeToNewIdentifier(oldIdentifier, newIdentifier) {
      const meta = await get$1(oldIdentifier, this._merkleTreeMetaStore);
      if (!meta || !meta?.length) {
        throw new Error(`Merkle tree meta not found for identifier ${oldIdentifier}`);
      }
      const treesMeta = meta.map((m5) => ({
        ...m5,
        identifier: newIdentifier
      }));
      await del$1(oldIdentifier, this._merkleTreeMetaStore);
      await set(newIdentifier, treesMeta, this._merkleTreeMetaStore);
      await set(oldIdentifier, newIdentifier, this._bindingStore);
    }
  };
  MerkleTreeIndexedDBStorage.storageKeyMeta = "merkle-tree-meta";
  MerkleTreeIndexedDBStorage.storageBindingKeyMeta = "binding-did";
  var CircuitStorage = class {
    constructor(_dataSource) {
      this._dataSource = _dataSource;
    }
    async loadCircuitData(circuitId) {
      const circuitData = await this._dataSource.get(circuitId.toString(), "circuitId");
      if (!circuitData) {
        throw new Error(`${StorageErrors.ItemNotFound}: ${circuitId}`);
      }
      return circuitData;
    }
    async saveCircuitData(circuitId, circuitData) {
      await this._dataSource.save(circuitId.toString(), circuitData, "circuitId");
    }
  };
  CircuitStorage.storageKey = "circuits";
  var CredentialStorage = class {
    constructor(_dataSource) {
      this._dataSource = _dataSource;
    }
    async listCredentials() {
      const creds = await this._dataSource.load();
      return creds.filter((i4) => i4 !== void 0).map((cred) => cred && W3CCredential.fromJSON(cred));
    }
    async saveCredential(credential) {
      return this._dataSource.save(credential.id, credential.toJSON());
    }
    async saveAllCredentials(credentials) {
      for (const credential of credentials) {
        await this.saveCredential(credential);
      }
    }
    async removeCredential(id3) {
      return this._dataSource.delete(id3);
    }
    async findCredentialById(id3) {
      const cred = await this._dataSource.get(id3);
      return cred && W3CCredential.fromJSON(cred);
    }
    async findCredentialsByQuery(query) {
      const filters = StandardJSONCredentialsQueryFilter(query);
      const creds = (await this._dataSource.load()).filter((credential) => filters.every((filter) => filter.execute(credential)));
      const mappedCreds = creds.filter((i4) => i4 !== void 0).map((cred) => W3CCredential.fromJSON(cred));
      return mappedCreds;
    }
  };
  CredentialStorage.storageKey = "credentials";
  var IdentityStorage = class {
    constructor(_identityDataSource, _profileDataSource) {
      this._identityDataSource = _identityDataSource;
      this._profileDataSource = _profileDataSource;
    }
    async saveProfile(profile) {
      const profiles = await this._profileDataSource.load();
      const identityProfiles = profiles.filter((p6) => p6.genesisIdentifier === profile.genesisIdentifier);
      const toSave = identityProfiles.length ? [...identityProfiles, profile] : [profile];
      for (let index = 0; index < toSave.length; index++) {
        const element = toSave[index];
        await this._profileDataSource.save(element.id, element);
      }
    }
    async getProfileByVerifier(verifier) {
      return this._profileDataSource.get(verifier, "verifier");
    }
    async getProfileById(profileId) {
      return this._profileDataSource.get(profileId);
    }
    async getProfilesByGenesisIdentifier(genesisIdentifier) {
      return (await this._profileDataSource.load()).filter((p6) => p6.genesisIdentifier === genesisIdentifier);
    }
    async getAllIdentities() {
      return this._identityDataSource.load();
    }
    async saveIdentity(identity2) {
      return this._identityDataSource.save(identity2.did, identity2, "did");
    }
    async getIdentity(identifier) {
      return this._identityDataSource.get(identifier, "did");
    }
  };
  IdentityStorage.identitiesStorageKey = "identities";
  IdentityStorage.profilesStorageKey = "profiles";
  var NodeType;
  (function(NodeType2) {
    NodeType2[NodeType2["Unknown"] = 0] = "Unknown";
    NodeType2[NodeType2["Middle"] = 1] = "Middle";
    NodeType2[NodeType2["Leaf"] = 2] = "Leaf";
    NodeType2[NodeType2["State"] = 3] = "State";
  })(NodeType || (NodeType = {}));
  var IDEN3_PROTOCOL = "https://iden3-communication.io/";
  var PROTOCOL_MESSAGE_TYPE = Object.freeze({
    AUTHORIZATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}authorization/1.0/request`,
    AUTHORIZATION_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}authorization/1.0/response`,
    CREDENTIAL_ISSUANCE_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/issuance-request`,
    CREDENTIAL_FETCH_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/fetch-request`,
    CREDENTIAL_OFFER_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/offer`,
    CREDENTIAL_ISSUANCE_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/issuance-response`,
    CREDENTIAL_REFRESH_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/refresh`,
    DEVICE_REGISTRATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}devices/1.0/registration`,
    MESSAGE_FETCH_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}messages/1.0/fetch`,
    PROOF_GENERATION_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/request`,
    PROOF_GENERATION_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/response`,
    REVOCATION_STATUS_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}revocation/1.0/request-status`,
    REVOCATION_STATUS_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}revocation/1.0/status`,
    CONTRACT_INVOKE_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/contract-invoke-request`,
    CONTRACT_INVOKE_RESPONSE_MESSAGE_TYPE: `${IDEN3_PROTOCOL}proofs/1.0/contract-invoke-response`,
    CREDENTIAL_ONCHAIN_OFFER_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/1.0/onchain-offer`,
    PROPOSAL_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/proposal-request`,
    PROPOSAL_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/proposal`,
    PAYMENT_REQUEST_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/payment-request`,
    PAYMENT_MESSAGE_TYPE: `${IDEN3_PROTOCOL}credentials/0.1/payment`
  });
  var MediaType;
  (function(MediaType2) {
    MediaType2["ZKPMessage"] = "application/iden3-zkp-json";
    MediaType2["PlainMessage"] = "application/iden3comm-plain-json";
    MediaType2["SignedMessage"] = "application/iden3comm-signed-json";
  })(MediaType || (MediaType = {}));
  var ProtocolVersion;
  (function(ProtocolVersion2) {
    ProtocolVersion2["V1"] = "iden3comm/v1";
  })(ProtocolVersion || (ProtocolVersion = {}));
  var AcceptAuthCircuits;
  (function(AcceptAuthCircuits2) {
    AcceptAuthCircuits2["AuthV2"] = "authV2";
    AcceptAuthCircuits2["AuthV3"] = "authV3";
  })(AcceptAuthCircuits || (AcceptAuthCircuits = {}));
  var AcceptJwzAlgorithms;
  (function(AcceptJwzAlgorithms2) {
    AcceptJwzAlgorithms2["Groth16"] = "groth16";
  })(AcceptJwzAlgorithms || (AcceptJwzAlgorithms = {}));
  var AcceptJwsAlgorithms;
  (function(AcceptJwsAlgorithms2) {
    AcceptJwsAlgorithms2["ES256K"] = "ES256K";
    AcceptJwsAlgorithms2["ES256KR"] = "ES256K-R";
  })(AcceptJwsAlgorithms || (AcceptJwsAlgorithms = {}));
  var defaultAcceptProfile = {
    protocolVersion: ProtocolVersion.V1,
    env: MediaType.ZKPMessage,
    circuits: [AcceptAuthCircuits.AuthV2],
    alg: [AcceptJwzAlgorithms.Groth16]
  };
  var DEFAULT_PROOF_VERIFY_DELAY = 1 * 60 * 60 * 1e3;
  var DEFAULT_AUTH_VERIFY_DELAY = 5 * 60 * 1e3;
  async function witnessBuilder(code2, options) {
    options = options || {};
    let wasmModule;
    try {
      wasmModule = await WebAssembly.compile(code2);
    } catch (err) {
      throw new Error(err);
    }
    let errStr = "";
    let msgStr = "";
    const instance = await WebAssembly.instantiate(wasmModule, {
      runtime: {
        exceptionHandler: function(code3) {
          let err;
          if (code3 == 1) {
            err = "Signal not found.\n";
          } else if (code3 == 2) {
            err = "Too many signals set.\n";
          } else if (code3 == 3) {
            err = "Signal already set.\n";
          } else if (code3 == 4) {
            err = "Assert Failed.\n";
          } else if (code3 == 5) {
            err = "Not enough memory.\n";
          } else if (code3 == 6) {
            err = "Input signal array access exceeds the size.\n";
          } else {
            err = "Unknown error.\n";
          }
          throw new Error(err + errStr);
        },
        printErrorMessage: function() {
          errStr += getMessage() + "\n";
        },
        writeBufferMessage: function() {
          const msg = getMessage();
          if (msg === "\n") {
            msgStr = "";
          } else {
            if (msgStr !== "") {
              msgStr += " ";
            }
            msgStr += msg;
          }
        },
        showSharedRWMemory: function() {
          printSharedRWMemory();
        }
      }
    });
    const sanityCheck = options;
    const wc2 = new WitnessCalculator(instance, sanityCheck);
    return wc2;
    function getMessage() {
      let message = "";
      let c3 = instance.exports.getMessageChar();
      while (c3 != 0) {
        message += String.fromCharCode(c3);
        c3 = instance.exports.getMessageChar();
      }
      return message;
    }
    function printSharedRWMemory() {
      const shared_rw_memory_size = instance.exports.getFieldNumLen32();
      const arr = new Uint32Array(shared_rw_memory_size);
      for (let j5 = 0; j5 < shared_rw_memory_size; j5++) {
        arr[shared_rw_memory_size - 1 - j5] = instance.exports.readSharedRWMemory(j5);
      }
      if (msgStr !== "") {
        msgStr += " ";
      }
      msgStr += fromArray32(arr).toString();
    }
  }
  var WitnessCalculator = class {
    constructor(instance, sanityCheck) {
      this.instance = instance;
      this.instance = instance;
      this.version = this.instance.exports.getVersion();
      this.n32 = this.instance.exports.getFieldNumLen32();
      this.instance.exports.getRawPrime();
      const arr = new Uint32Array(this.n32);
      for (let i4 = 0; i4 < this.n32; i4++) {
        arr[this.n32 - 1 - i4] = this.instance.exports.readSharedRWMemory(i4);
      }
      this.prime = fromArray32(arr);
      this.witnessSize = this.instance.exports.getWitnessSize();
      this.sanityCheck = sanityCheck;
    }
    circom_version() {
      return this.instance.exports.getVersion();
    }
    async _doCalculateWitness(input, sanityCheck) {
      this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
      const keys = Object.keys(input);
      let input_counter = 0;
      keys.forEach((k5) => {
        const h6 = fnvHash2(k5);
        const hMSB = parseInt(h6.slice(0, 8), 16);
        const hLSB = parseInt(h6.slice(8, 16), 16);
        const fArr = flatArray2(input[k5]);
        const signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);
        if (signalSize < 0) {
          throw new Error(`Signal ${k5} not found
`);
        }
        if (fArr.length < signalSize) {
          throw new Error(`Not enough values for input signal ${k5}
`);
        }
        if (fArr.length > signalSize) {
          throw new Error(`Too many values for input signal ${k5}
`);
        }
        for (let i4 = 0; i4 < fArr.length; i4++) {
          const arrFr = toArray322(BigInt(fArr[i4]) % this.prime, this.n32);
          for (let j5 = 0; j5 < this.n32; j5++) {
            this.instance.exports.writeSharedRWMemory(j5, arrFr[this.n32 - 1 - j5]);
          }
          try {
            this.instance.exports.setInputSignal(hMSB, hLSB, i4);
            input_counter++;
          } catch (err) {
            throw new Error(err);
          }
        }
      });
      if (input_counter < this.instance.exports.getInputSize()) {
        throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
      }
    }
    async calculateWitness(input, sanityCheck) {
      const w5 = [];
      await this._doCalculateWitness(input, sanityCheck);
      for (let i4 = 0; i4 < this.witnessSize; i4++) {
        this.instance.exports.getWitness(i4);
        const arr = new Uint32Array(this.n32);
        for (let j5 = 0; j5 < this.n32; j5++) {
          arr[this.n32 - 1 - j5] = this.instance.exports.readSharedRWMemory(j5);
        }
        w5.push(fromArray32(arr));
      }
      return w5;
    }
    async calculateBinWitness(input, sanityCheck) {
      const buff32 = new Uint32Array(this.witnessSize * this.n32);
      const buff = new Uint8Array(buff32.buffer);
      await this._doCalculateWitness(input, sanityCheck);
      for (let i4 = 0; i4 < this.witnessSize; i4++) {
        this.instance.exports.getWitness(i4);
        const pos = i4 * this.n32;
        for (let j5 = 0; j5 < this.n32; j5++) {
          buff32[pos + j5] = this.instance.exports.readSharedRWMemory(j5);
        }
      }
      return buff;
    }
    async calculateWTNSBin(input, sanityCheck) {
      const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
      const buff = new Uint8Array(buff32.buffer);
      await this._doCalculateWitness(input, sanityCheck);
      buff[0] = "w".charCodeAt(0);
      buff[1] = "t".charCodeAt(0);
      buff[2] = "n".charCodeAt(0);
      buff[3] = "s".charCodeAt(0);
      buff32[1] = 2;
      buff32[2] = 2;
      buff32[3] = 1;
      const n8 = this.n32 * 4;
      const idSection1length = 8 + n8;
      const idSection1lengthHex = idSection1length.toString(16);
      buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
      buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
      buff32[6] = n8;
      this.instance.exports.getRawPrime();
      let pos = 7;
      for (let j5 = 0; j5 < this.n32; j5++) {
        buff32[pos + j5] = this.instance.exports.readSharedRWMemory(j5);
      }
      pos += this.n32;
      buff32[pos] = this.witnessSize;
      pos++;
      buff32[pos] = 2;
      pos++;
      const idSection2length = n8 * this.witnessSize;
      const idSection2lengthHex = idSection2length.toString(16);
      buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
      buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
      pos += 2;
      for (let i4 = 0; i4 < this.witnessSize; i4++) {
        this.instance.exports.getWitness(i4);
        for (let j5 = 0; j5 < this.n32; j5++) {
          buff32[pos + j5] = this.instance.exports.readSharedRWMemory(j5);
        }
        pos += this.n32;
      }
      return buff;
    }
  };
  function toArray322(rem, size) {
    const res = [];
    const radix = BigInt(4294967296);
    while (rem) {
      res.unshift(Number(rem % radix));
      rem = rem / radix;
    }
    if (size) {
      let i4 = size - res.length;
      while (i4 > 0) {
        res.unshift(0);
        i4--;
      }
    }
    return res;
  }
  function fromArray32(arr) {
    let res = BigInt(0);
    const radix = BigInt(4294967296);
    for (let i4 = 0; i4 < arr.length; i4++) {
      res = res * radix + BigInt(arr[i4]);
    }
    return res;
  }
  function flatArray2(a4) {
    const res = [];
    fillArray(res, a4);
    return res;
    function fillArray(res2, a5) {
      if (Array.isArray(a5)) {
        for (let i4 = 0; i4 < a5.length; i4++) {
          fillArray(res2, a5[i4]);
        }
      } else {
        res2.push(a5);
      }
    }
  }
  function fnvHash2(str) {
    const uint64_max = BigInt(2) ** BigInt(64);
    let hash2 = BigInt("0xCBF29CE484222325");
    for (let i4 = 0; i4 < str.length; i4++) {
      hash2 ^= BigInt(str[i4].charCodeAt());
      hash2 *= BigInt(1099511628211);
      hash2 %= uint64_max;
    }
    let hashHex = hash2.toString(16);
    const n4 = 16 - hashHex.length;
    hashHex = "0".repeat(n4).concat(hashHex);
    return hashHex;
  }
  var NativeProver = class {
    constructor(_circuitStorage) {
      this._circuitStorage = _circuitStorage;
    }
    async verify(zkp, circuitId) {
      try {
        const circuitData = await this._circuitStorage.loadCircuitData(circuitId);
        if (!circuitData.verificationKey) {
          throw new Error(`verification file doesn't exist for circuit ${circuitId}`);
        }
        const result = await groth16.verify(JSON.parse(byteDecoder.decode(circuitData.verificationKey)), zkp.pub_signals, zkp.proof);
        await this.terminateCurve();
        return result;
      } catch (e7) {
        console.log(e7);
        return false;
      }
    }
    async generate(inputs, circuitId) {
      const circuitData = await this._circuitStorage.loadCircuitData(circuitId);
      if (!circuitData.wasm) {
        throw new Error(`wasm file doesn't exist for circuit ${circuitId}`);
      }
      const witnessCalculator = await witnessBuilder(circuitData.wasm);
      const parsedData = JSON.parse(byteDecoder.decode(inputs));
      const wtnsBytes = await witnessCalculator.calculateWTNSBin(parsedData, 0);
      if (!circuitData.provingKey) {
        throw new Error(`proving file doesn't exist for circuit ${circuitId}`);
      }
      const { proof, publicSignals } = await groth16.prove(circuitData.provingKey, wtnsBytes);
      await this.terminateCurve();
      return {
        proof,
        pub_signals: publicSignals
      };
    }
    async terminateCurve() {
      const curve2 = await getCurveFromName(NativeProver.curveName);
      curve2.terminate();
    }
  };
  NativeProver.curveName = "bn128";
  var { getProvingMethod } = T5;
  var CredentialOfferStatus;
  (function(CredentialOfferStatus2) {
    CredentialOfferStatus2["Pending"] = "pending";
    CredentialOfferStatus2["Completed"] = "completed";
    CredentialOfferStatus2["Rejected"] = "rejected";
  })(CredentialOfferStatus || (CredentialOfferStatus = {}));
  var allOperations = Object.values(QueryOperators);
  var v2Operations = [
    Operators.NOOP,
    Operators.EQ,
    Operators.LT,
    Operators.GT,
    Operators.IN,
    Operators.NIN,
    Operators.NE,
    Operators.SD
  ];
  var v2OnChainOperations = [
    Operators.EQ,
    Operators.LT,
    Operators.GT,
    Operators.IN,
    Operators.NIN,
    Operators.NE
  ];
  var circuitValidator = {
    [CircuitId.AtomicQueryMTPV2]: { maxQueriesCount: 1, supportedOperations: v2Operations },
    [CircuitId.AtomicQueryMTPV2OnChain]: {
      maxQueriesCount: 1,
      supportedOperations: v2OnChainOperations
    },
    [CircuitId.AtomicQuerySigV2]: { maxQueriesCount: 1, supportedOperations: v2Operations },
    [CircuitId.AtomicQuerySigV2OnChain]: {
      maxQueriesCount: 1,
      supportedOperations: v2OnChainOperations
    },
    [CircuitId.AtomicQueryV3]: { maxQueriesCount: 1, supportedOperations: allOperations },
    [CircuitId.AtomicQueryV3OnChain]: { maxQueriesCount: 1, supportedOperations: allOperations },
    [CircuitId.AuthV2]: { maxQueriesCount: 0, supportedOperations: [] },
    [CircuitId.StateTransition]: { maxQueriesCount: 0, supportedOperations: [] },
    [CircuitId.LinkedMultiQuery10]: { maxQueriesCount: 10, supportedOperations: allOperations }
  };
  var defaultProofGenerationDelayOpts = 24 * 60 * 60 * 1e3;
  var userStateError = new Error(`user state is not valid`);

  // src/privado.js
  var go2 = async () => {
    const didType = esm_exports.buildDIDType(
      esm_exports.DidMethod.Iden3,
      esm_exports.Blockchain.Polygon,
      esm_exports.NetworkId.Amoy
    );
    const genesis = esm_exports.genesisFromEthAddress(hexToBytes$3(ethAddress));
    const identifier = new esm_exports.Id(didType, genesis);
    const did = esm_exports.DID.parseFromId(identifier);
    const msgBytes = ethers.utils.arrayify(
      ethers.utils.keccak256(
        new TextEncoder().encode(
          typeof msgToSign === "string" ? msgToSign : JSON.stringify(msgToSign)
        )
      )
    );
    await LitActions.ethPersonalSignMessageEcdsa({
      message: msgBytes,
      publicKey,
      sigName: "Privado.ID"
    });
    const response = JSON.stringify(
      {
        did: did.string()
      },
      null,
      2
    );
    LitActions.setResponse({
      response
    });
  };
  go2();
})();
/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.9.3
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2023
 * @license MIT
 */
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
// disallow aliasing @context and @preserve
// remove @preserve
// remove @preserve from results
